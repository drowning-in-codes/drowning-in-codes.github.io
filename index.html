<!DOCTYPE html>
<html lang="zh-CN">
<head>
<script src="/live2d-widget/autoload.js"></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/blog_32px.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/blog_32px.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/blog_16px.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w">
  <meta name="msvalidate.01" content="7226864CE87CE9DE8C008385273846FF">
  <meta name="baidu-site-verification" content="code-fjFXVtiL7j" />

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>
<link href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" rel="stylesheet">
  <meta name="description" content="什么也无法舍弃的人，什么也做不了.">
<meta property="og:type" content="website">
<meta property="og:title" content="Sekyoro的博客小屋">
<meta property="og:url" content="https://sekyoro.top/index.html">
<meta property="og:site_name" content="Sekyoro的博客小屋">
<meta property="og:description" content="什么也无法舍弃的人，什么也做不了.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Sekyoro">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://sekyoro.top/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
 

<script>
  var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });
</script>



  <script src="/js/src/activate-power-mode.min.js"></script>
  <script>
    POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);
  </script>


  <title>Sekyoro的博客小屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
<!-- require JQuery -->
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<!-- require pjax -->
<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/index.min.js"></script>


   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>


  <div class="container use-motion">
    <div class="headband"></div>
	
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sekyoro的博客小屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sekyoro.top/2021/09/21/%E5%91%BD%E4%BB%A4%E9%9B%86-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg">
      <meta itemprop="name" content="Sekyoro">
      <meta itemprop="description" content="什么也无法舍弃的人，什么也做不了.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sekyoro的博客小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/21/%E5%91%BD%E4%BB%A4%E9%9B%86-4/" class="post-title-link" itemprop="url">命令集_4</a>
        </h2>

        <div class="post-meta">
		
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-21 10:55:51 / 修改时间：10:57:00" itemprop="dateCreated datePublished" datetime="2021-09-21T10:55:51+08:00">2021-09-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux-study/" itemprop="url" rel="index"><span itemprop="name">Linux_study</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Linux进程与磁盘管理"><a href="#Linux进程与磁盘管理" class="headerlink" title="Linux进程与磁盘管理"></a>Linux进程与磁盘管理</h2><p><strong>进程</strong>（process）：进程是程序在一个数据集合上的一次执行过程，在早期的 UNIX、Linux 2.4 及更早的版本中，它是系统进行资源分配和调度的独立基本单位。</p>
<ul>
<li>动态性：进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。</li>
<li>并发性：进程可以做到在一个时间段内，有多个程序在运行中。程序只是静态的实体，所以不存在并发性。</li>
<li>独立性：进程可以独立分配资源，独立接受调度，独立地运行。</li>
<li>异步性：进程以不可预知的速度向前推进。</li>
<li>结构性：进程拥有代码段、数据段、PCB（进程控制块，进程存在的唯一标志）。也正是因为有结构性，进程才可以做到独立地运行。</li>
</ul>
<blockquote>
<p><strong>并发：</strong>在一个时间段内，宏观来看有多个程序都在活动，有条不紊的执行（每一瞬间只有一个在执行，只是在一段时间有多个程序都执行过）</p>
<p><strong>并行：</strong>在每一个瞬间，都有多个程序都在同时执行，这个必须有多个 CPU 才行</p>
</blockquote>
<p><strong>线程</strong>（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。</p>
<h3 id="进程分类"><a href="#进程分类" class="headerlink" title="进程分类"></a>进程分类</h3><ul>
<li>用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。</li>
<li>系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行</li>
</ul>
<ul>
<li>交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。</li>
<li>批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。</li>
<li>守护进程：守护进程是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如 httpd 进程，一直处于运行状态，等待用户的访问。还有经常用的 cron（在 centOS 系列为 crond）进程，这个进程为 crontab 的守护进程，可以周期性的执行用户设定的某些任务。</li>
</ul>
<p>我们启动了终端，就是启动了一个 bash 进程，我们可以在 bash 中再输入 bash 则会再启动一个 bash 的进程，此时第二个 bash 进程就是由第一个 bash 进程创建出来的，他们之间关系是父进程与子进程</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915105254.png" alt="image-20210915105254288"></p>
<h3 id="进程查看"><a href="#进程查看" class="headerlink" title="进程查看"></a>进程查看</h3><p>我们可以通过 <code>top</code> 实时的查看进程的状态，以及系统的一些信息（如 CPU、内存信息等），我们还可以通过 <code>ps</code> 来静态查看当前的进程信息，同时我们还可以使用 <code>pstree</code> 来查看当前活跃进程的树形结构。</p>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>查看系统中使用CPU、使用内存最多的进程；</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>
<p>对于进程，平时我们最常想知道的就是哪些进程占用CPU最多，占用内存最多。以下两个命令就可以满足要求:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P：根据CPU使用百分比大小进行排序。</span><br><span class="line">M：根据驻留内存大小进行排序。</span><br><span class="line">i：使top不显示任何闲置或者僵死进程。</span><br></pre></td></tr></table></figure>
<p>可以说 top就是linux下的任务管理器</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915110542.png" alt="image-20210915110542055"></p>
<p><strong>关于进程情况</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>列名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>PID</td>
<td>进程 id</td>
</tr>
<tr>
<td>USER</td>
<td>该进程的所属用户</td>
</tr>
<tr>
<td>PR</td>
<td>该进程执行的优先级 priority 值  越小越高</td>
</tr>
<tr>
<td>NI</td>
<td>该进程的 nice 值</td>
</tr>
<tr>
<td>VIRT</td>
<td>该进程任务所使用的虚拟内存的总数</td>
</tr>
<tr>
<td>RES</td>
<td>该进程所使用的物理内存数，也称之为驻留内存数</td>
</tr>
<tr>
<td>SHR</td>
<td>该进程共享内存的大小</td>
</tr>
<tr>
<td>S</td>
<td>该进程进程的状态: S=sleep R=running Z=zombie</td>
</tr>
<tr>
<td>%CPU</td>
<td>该进程 CPU 的利用率</td>
</tr>
<tr>
<td>%MEM</td>
<td>该进程内存的利用率</td>
</tr>
<tr>
<td>TIME+</td>
<td>该进程活跃的总时间</td>
</tr>
<tr>
<td>COMMAND</td>
<td>该进程运行的名字</td>
</tr>
</tbody>
</table>
</div>
<p><strong>NICE 值</strong>叫做静态优先级，是用户空间的一个优先级值，其取值范围是 -20 至 19。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。nice 值中的 -20 到 19，中 -20 优先级最高， 0 是默认的值，而 19 优先级最低。</p>
<p><strong>PR 值</strong>表示 Priority 值叫动态优先级，是进程在内核中实际的优先级值，进程优先级的取值范围是通过一个宏定义的，这个宏的名称是 <code>MAX_PRIO</code>，它的值为 140。Linux 实际上实现了 140 个优先级范围，取值范围是从 <code>0-139</code>，这个值越小，优先级越高。而这其中的 <code>0-99</code> 是实时进程的值，而 <code>100-139</code> 是给用户的。</p>
<p>其中 PR 中的 <code>100 to 139</code> 值部分有这么一个对应 <code>PR = 20 + (-20 to +19)</code>，这里的 <code>-20 to +19</code> 便是 nice 值，所以说两个虽然都是优先级，而且有千丝万缕的关系，但是他们的值，他们的作用范围并不相同。</p>
<p><strong>VIRT</strong> 任务所使用的虚拟内存的总数，其中包含所有的代码，数据，共享库和被换出 swap 空间的页面等所占据空间的总数。</p>
<p>下面来解析一下</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915110618.png" alt="image-20210915110618881"></p>
<ul>
<li>第一行</li>
</ul>
<p>11:05:55 ： 系统当前时间 </p>
<p>up 219min ： 系统开机到现在经过了多少时间</p>
<p>1 user ： 当前1用户在线</p>
<p>load average: 0.14, 0.09, 0.11： 系统1分钟、5分钟、15分钟的CPU负载信息</p>
<ul>
<li>第二行</li>
</ul>
<p>Tasks：任务;296total：当前有87个任务，也就是87个进程。</p>
<p>running：2个进程正在运行</p>
<p>294sleeping：294个进程睡眠</p>
<p>0 stopped：停止的进程数</p>
<p>0 zombie：僵死的进程数</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915111128.png" alt="image-20210915111128522"></p>
<ul>
<li><p>第三行</p>
<p>Cpu(s)：表示这一行显示CPU总体信息</p>
<p>2.7%us：用户态进程占用CPU时间百分比，不包含renice值为负的任务占用的CPU的时间。</p>
<p>0.7%sy：内核占用CPU时间百分比</p>
<p>ni：改变过优先级的进程占用CPU的百分比</p>
<p>96.6%id：空闲CPU时间百分比</p>
<p>wa：等待I/O的CPU时间百分比</p>
<p>hi：CPU硬中断时间百分比</p>
<p>si：CPU软中断时间百分比</p>
<p>注：这里显示数据是所有cpu的平均值，如果想看每一个cpu的处理情况，按1即可；折叠，再次按1；</p>
</li>
</ul>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915112109.png" alt="image-20210915112109665"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>1952.9 total</td>
<td>物理内存总量</td>
</tr>
<tr>
<td>409.0 used</td>
<td>使用的物理内存总量</td>
</tr>
<tr>
<td>409.0 free</td>
<td>空闲内存总量</td>
</tr>
<tr>
<td>681.1 buffers</td>
<td>用作内核缓存的内存量</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意：</strong></p>
<blockquote>
<p>系统中可用的物理内存最大值并不是 free 这个单一的值，而是 free + buffers + swap 中的 cached 的和。</p>
</blockquote>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915112325.png" alt="image-20210915112325499"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>total</td>
<td>交换区总量</td>
</tr>
<tr>
<td>used</td>
<td>使用的交换区总量</td>
</tr>
<tr>
<td>free</td>
<td>空闲交换区总量</td>
</tr>
<tr>
<td>cached</td>
<td>缓冲的交换区总量，内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖</td>
</tr>
</tbody>
</table>
</div>
<p><strong>交互命令</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常用交互命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>q</td>
<td>退出程序</td>
</tr>
<tr>
<td>I</td>
<td>切换显示平均负载和启动时间的信息</td>
</tr>
<tr>
<td>P</td>
<td>根据 CPU 使用百分比大小进行排序</td>
</tr>
<tr>
<td>M</td>
<td>根据驻留内存大小进行排序</td>
</tr>
<tr>
<td>i</td>
<td>忽略闲置和僵死的进程，这是一个开关式命令</td>
</tr>
<tr>
<td>k</td>
<td>终止一个进程，系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号，不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux</span><br></pre></td></tr></table></figure>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915112813.png" alt="image-20210915112813151"></p>
<ul>
<li><p>l 长格式输出；</p>
</li>
<li><p>u 按用户名和启动时间的顺序来显示进程；</p>
</li>
<li><p>j 用任务格式来显示进程；</p>
</li>
<li><p>f 用树形格式来显示进程；</p>
</li>
<li><p>a 显示所有用户的所有进程（包括其它用户）；</p>
</li>
<li><p>x 显示无控制终端的进程；</p>
</li>
<li><p>r 显示运行中的进程；</p>
</li>
<li><p>-e 显示所有进程,环境变量</p>
</li>
</ul>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915113104.png" alt="image-20210915113103961"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>F</code></td>
<td>进程的标志（process flags），当 flags 值为 1 则表示此子程序只是 fork 但没有执行 exec，为 4 表示此程序使用超级管理员 root 权限</td>
</tr>
<tr>
<td><code>USER</code></td>
<td>进程的拥有用户</td>
</tr>
<tr>
<td><code>PID</code></td>
<td>进程的 ID</td>
</tr>
<tr>
<td><code>PPID</code></td>
<td>其父进程的 PID</td>
</tr>
<tr>
<td><code>SID</code></td>
<td>session 的 ID</td>
</tr>
<tr>
<td><code>TPGID</code></td>
<td>前台进程组的 ID</td>
</tr>
<tr>
<td><code>%CPU</code></td>
<td>进程占用的 CPU 百分比</td>
</tr>
<tr>
<td><code>%MEM</code></td>
<td>占用内存的百分比</td>
</tr>
<tr>
<td><code>NI</code></td>
<td>进程的 NICE 值</td>
</tr>
<tr>
<td><code>VSZ</code></td>
<td>进程使用虚拟内存大小</td>
</tr>
<tr>
<td><code>RSS</code></td>
<td>驻留内存中页的大小</td>
</tr>
<tr>
<td><code>TTY</code></td>
<td>终端 ID</td>
</tr>
<tr>
<td><code>S or STAT</code></td>
<td>进程状态</td>
</tr>
<tr>
<td><code>WCHAN</code></td>
<td>正在等待的进程资源</td>
</tr>
<tr>
<td><code>START</code></td>
<td>启动进程的时间</td>
</tr>
<tr>
<td><code>TIME</code></td>
<td>进程消耗 CPU 的时间</td>
</tr>
<tr>
<td><code>COMMAND</code></td>
<td>命令的名称和参数</td>
</tr>
</tbody>
</table>
</div>
<p>查询正在运行的进程信息</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ps</span> -rf</span><br></pre></td></tr></table></figure>
<h4 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h4><p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915113749.png" alt="image-20210915113749274"></p>
<p>可以很直接的看到相同的进程数量，最主要的还是我们可以看到所有进程之间的相关性</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>内存管理</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free</span><br></pre></td></tr></table></figure>
<p>查看内存使用情况</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915114130.png" alt="image-20210915114130103"></p>
<p>进程组与Sessions</p>
<p>每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。</p>
<p>一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者，也就是领导进程，进程一般通过使用 <code>getpgrp()</code> 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的 PGID，直到进程组中最后一个进程终结。</p>
<p>与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的，</p>
<p>Session 主要是针对一个 tty 建立，Session 中的每个进程都称为一个工作(job)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。Session 意义在于将多个 jobs 囊括在一个终端，并取其中的一个 job 作为前台，来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。</p>
<blockquote>
<p><strong>前台</strong>（foreground）就是在终端中运行，能与你有交互的</p>
<p><strong>后台</strong>（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程</p>
</blockquote>
<p>被停止并放置在后台的工作我们可以使用这个命令来查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">jobs</span></span><br></pre></td></tr></table></figure>
<p>通过这样的一个命令将后台的工作拿到前台来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后面不加参数提取预设工作，加参数提取指定工作的编号</span></span><br><span class="line"><span class="comment"># ubuntu 在 zsh 中需要 %，在 bash 中不需要 %</span></span><br><span class="line"><span class="built_in">fg</span> [%jobnumber]</span><br></pre></td></tr></table></figure>
<h4 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h4><p>​    在Linux系统中，除了系统启动之后的第一个进程由系统来创建，其余的进程都必须由已存在的进程来创建，新创建的进程叫做子进程，而创建子进程的进程叫做父进程。那个在系统启动及完成初始化之后，Linux自动创建的进程叫做根进程。根进程是Linux中所有进程的祖宗，其余进程都是根进程的子孙。具有同一个父进程的进程叫做兄弟进程<br>​    关于父进程与子进程便会提及这两个系统调用 <code>fork()</code> 与 <code>exec()</code></p>
<p>子进程就是父进程通过系统调用 <code>fork()</code> 而产生的复制品，<code>fork()</code> 就是把父进程的 PCB 等进程的数据结构信息直接复制过来，只是修改了 PID，所以一模一样，只有在执行 <code>exec()</code> 之后才会不同。</p>
<p>为了在一个进程中分裂出子进程，Linux提供了一个系统调用fork()。这里所说的分裂，实际上是一种复制。因为在系统中表示一个进程的实体是进程控制块，创建新进程的主要工作就是要创建一个新控制块，而创建一个新控制块最简单的方法就是复制。</p>
<p>​    当然，这里的复制并不是完全复制，因为父进程控制块中某些项的内容必须按照子进程的特性来修改，例如进程的标识、状态等。另外，子进程控制块还必须要有表示自己父进程的域和私有空间，例如数据空间、用户堆栈等。</p>
<p>函数fork()分裂出了两个进程：因为自函数fork()之后执行了两遍之后的代码（先子进程一次，后父进程一次）。同时，这也证明了父进程和子进程运行的是同一个程序，也正是这个理由，系统并未在内存中给子进程配置独立的程序运行空间，而只是简单地将程序指针指向父进程的代码；<br>    两个进程具有各自的数据区和用户堆栈，在函数fork()生成子进程时，将父进程数据区和用户堆栈的内容分别复制给了子进程。同时，接下来的内容，父进程和子进程都是对自己的数据区和堆栈中的内容进行修改运算了。<br>父进程中调用fork()之后会产生两种结果：一种为分裂子进程失败，另一种就是分裂子进程成功。<strong>如果fork()失败，则返回-1,；否则会出现父进程和子进程两个进程，在子进程中fork()返回0，在父进程中fork()返回子进程的ID。</strong></p>
<p>​    <strong>在代码中获得当前进程pid的函数为：getpid()；</strong></p>
<p><strong>在代码中获得当前进程父进程pid的函数为：getppid()。</strong></p>
<p><strong>这里需要注明一点：</strong>父子进程的调度的顺序是由调度器决定的，与进程的创建顺序无关。</p>
<p>​    当一个子进程要正常的终止运行时，或者该进程结束时它的主函数 <code>main()</code> 会执行 <code>exit(n);</code> 或者 <code>return n</code>，这里的返回值 n 是一个信号，系统会把这个 SIGCHLD 信号传给其父进程，当然若是异常终止也往往是因为这个信号。</p>
<p>​    在将要结束时的子进程代码执行部分已经结束执行了，系统的资源也基本归还给系统了，但若是其进程的进程控制块（PCB）仍驻留在内存中，而它的 PCB 还在，代表这个进程还存在（因为 PCB 就是进程存在的唯一标志，里面有 PID 等消息），并没有消亡，这样的进程称之为僵尸进程（Zombie）</p>
<p>​    正常情况下，父进程会收到两个返回值：exit code（SIGCHLD 信号）与 <code>reason for termination</code> 。之后，父进程会使用 <code>wait(&amp;status)</code> 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB；而如若父进程没有这么做的话，子进程的 PCB 就会一直驻留在内存中，一直留在系统中成为僵尸进程（Zombie）。</p>
<p>虽然僵尸进程是已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，在进程列表中保留一个位置，记载该进程的退出状态等信息供其父进程收集，从而释放它。但是 Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程。</p>
<p>​    进程 0 是系统引导时创建的一个特殊进程，也称之为内核初始化，其最后一个动作就是调用 <code>fork()</code> 创建出一个子进程运行 <code>/sbin/init</code> 可执行文件，而该进程就是 PID=1 的进程 1，而进程 0 就转为交换进程（也被称为空闲进程），进程 1 （init 进程）是第一个用户态的进程，再由它不断调用 fork() 来创建系统里其他的进程，所以它是所有进程的父进程或者祖先进程。同时它是一个守护程序，直到计算机关机才会停止。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915121843.png" alt="image-20210915121843368"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> id = getpid();</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;my id is %d\n&quot;</span>,id);</span><br><span class="line"> <span class="keyword">int</span> num = fork();</span><br><span class="line"> <span class="keyword">if</span>(num==<span class="number">0</span>)</span><br><span class="line"> &#123;<span class="comment">//child</span></span><br><span class="line">         <span class="keyword">int</span> n = getpid();</span><br><span class="line">         <span class="keyword">int</span> pn = getppid();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child\nmy id is %d and my parent&#x27;s id is %d\n&quot;</span>,n,pn);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(num&gt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">        <span class="comment">//parent</span></span><br><span class="line">        <span class="keyword">int</span> n = getpid();</span><br><span class="line">        <span class="keyword">int</span> pn = getppid();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am parent\nmy id is %d\nmy parent&#x27;s id is %d\n&quot;</span>,n,pn);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fork函数调用一次，会返回两个函数值，对于父进程而言，返回的是子进程的PID（因为一个父进程可能有多个子进程，并且没有一个函数可以使父进程获取其所有的子进程ID），对于子进程返回值是0（这样就能区分父子进程，子进程是可以通过getppid来获取父进程的ID，如果进程创建失败，那么返回给父进程-1）。</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915125351.png" alt="image-20210915125351563"></p>
<h4 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span></span><br></pre></td></tr></table></figure>
<p>杀死指定PID的进程 (PID为Process ID)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kill</span> PID</span><br></pre></td></tr></table></figure>
<p>杀死相关进程</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 3434</span><br></pre></td></tr></table></figure>
<p>杀死job工作 (job为job number)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kill</span> %job</span><br></pre></td></tr></table></figure>
<p>可以先用 ps -aux查看进程</p>
<p>然后通过kill pid 杀死进程</p>
<h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><h4 id="查看磁盘和目录的容量"><a href="#查看磁盘和目录的容量" class="headerlink" title="查看磁盘和目录的容量"></a>查看磁盘和目录的容量</h4><ul>
<li>使用 <code>df</code> 命令查看磁盘的容量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df</span><br></pre></td></tr></table></figure>
<p>-h: human缩写，以易读的方式显示结果（即带单位：比如M/G，如果不加这个参数，显示的数字以B为单位）</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915221320.png" alt="image-20210915221319880"></p>
<p>物理主机上的 <code>/dev/sda2</code> 是对应着主机硬盘的分区，后面的数字表示分区号，数字前面的字母 a 表示第几块硬盘（也可能是可移动磁盘），你如果主机上有多块硬盘则可能还会出现 <code>/dev/sdb</code>，<code>/dev/sdc</code> 这些磁盘设备都会在 <code>/dev</code> 目录下以文件的存在形式</p>
<p>使用 <code>du</code> 命令查看目录的容量</p>
<p>-s 递归整个目录的大小</p>
<p>-h 对人可读 即显示M/GB</p>
<h3 id="磁盘挂载"><a href="#磁盘挂载" class="headerlink" title="磁盘挂载"></a>磁盘挂载</h3><p><img data-src="/images/70.png" alt="img"></p>
<p>lsblk</p>
<p>查看磁盘挂载情况</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915221448.png" alt="image-20210915221448745"></p>
<p>fdisk -l 查看系统所有识别到的磁盘</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915221545.png" alt="image-20210915221545182"></p>
<h4 id="mkfs-命令格式化磁盘"><a href="#mkfs-命令格式化磁盘" class="headerlink" title="mkfs 命令格式化磁盘"></a>mkfs 命令格式化磁盘</h4><p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915221611.png" alt="image-20210915200330145"></p>
<p>sudo mkfs.ext4 磁盘(也可以是虚拟软盘)</p>
<h4 id="mount-命令挂载磁盘到目录树"><a href="#mount-命令挂载磁盘到目录树" class="headerlink" title="mount 命令挂载磁盘到目录树"></a>mount 命令挂载磁盘到目录树</h4><p>用户要对该文件系统执行 <code>mount</code> 的指令以进行挂载。该指令通常是使用在 USB 或其他可移除存储设备上，而根目录则需要始终保持挂载的状态。又因为 Linux/UNIX 文件系统可以对应一个文件而不一定要是硬件设备，所以可以挂载一个包含文件系统的文件到目录树。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [options] [<span class="built_in">source</span>] [directory]</span><br></pre></td></tr></table></figure>
<h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><p>1.增加一块硬盘</p>
<p>可以在虚拟机下添加一个硬块</p>
<p>或者使用 dd命令制作软盘</p>
<p>dd if=/dev/zero of=virtual.img bs=1M count=256</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915222919.png" alt="image-20210915222919566" style="zoom:50%;" /></p>
<p>我这里添加了一个新硬盘</p>
<p>使用df -h 查看已挂载的磁盘</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915224038.png" alt="image-20210915224037960"></p>
<p>然后使用 fdisk -l 查看系统分区情况</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915224258.png" alt="image-20210915224258674"></p>
<p>发现 sda,也就是刚刚添加的5G硬盘没有挂载</p>
<p>继续使用lsblk还可以查看一些情况</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915224357.png" alt="image-20210915224357414"></p>
<p>发现  sda确实没有挂载点</p>
<p>就决定挂载它了!</p>
<p>如果是自己创建的软盘再使用mkfs格式化</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkfs.ext4 virtual.img</span><br></pre></td></tr></table></figure>
<p>2.分区</p>
<p>sudo fdisk virtual.img(软盘)</p>
<p>sudo fdisk /dev/sdb (添加的硬盘)</p>
<p>按照指示完成分区</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915224758.png" alt="image-20210915224757951" style="zoom:50%;" /></p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915224847.png" alt="image-20210915224847528"></p>
<p>这样就分好区了,分了一个主区</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915225032.png" alt="image-20210915225032272"></p>
<p>使用fdisk -l 发现有了标识符</p>
<p>3.格式化</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t ext4 /dev/sda1</span><br></pre></td></tr></table></figure>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915225208.png" alt="image-20210915225208889"></p>
<p>4.挂载 </p>
<p>先创建一个目录,使用</p>
<p>mount 设备名 目录名</p>
<p><strong>目录最好建立在/mnt下，这个目录是专门挂载的。</strong></p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915225335.png" alt="image-20210915225335936"></p>
<p>如果重启这种挂载关系就会消失</p>
<p>这是临时挂载</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210915225425.png" alt="image-20210915225425145"></p>
<p>df -h 发现挂载成功了</p>
<h4 id="设置开机挂载"><a href="#设置开机挂载" class="headerlink" title="设置开机挂载"></a>设置开机挂载</h4><ol>
<li>查看开机挂载fstab文件<br>系统开机时会主动读取/etc/fstab这个文件中的内容，根据文件里面的配置挂载磁盘。<br><code># cat /etc/fstab</code></li>
</ol>
<blockquote>
<p>每一列代表的含义：<br>第一列：磁盘的编号或者UUID //挂载点需要使用UUID来进行挂载<br>第二列：需要挂载到的目录<br>第三列：文件系统格式<br>第四列：系统的默认参数，一般填defaults<br>第五列：是否做dump备份，0表示不备份，1表示每天备份，2表示不定期备份<br>第六列：是否开机检查扇区：0表示不检查，1表示最早检验，2表示在1之后开始检验</p>
</blockquote>
<h4 id="解除挂载"><a href="#解除挂载" class="headerlink" title="解除挂载"></a>解除挂载</h4><p>umount 设备名</p>

      
    </div>

    
    
    
    <div>
	
   </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sekyoro.top/2021/09/21/%E5%91%BD%E4%BB%A4%E9%9B%86-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg">
      <meta itemprop="name" content="Sekyoro">
      <meta itemprop="description" content="什么也无法舍弃的人，什么也做不了.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sekyoro的博客小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/21/%E5%91%BD%E4%BB%A4%E9%9B%86-3/" class="post-title-link" itemprop="url">命令集_3</a>
        </h2>

        <div class="post-meta">
		
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-21 10:53:51 / 修改时间：10:56:18" itemprop="dateCreated datePublished" datetime="2021-09-21T10:53:51+08:00">2021-09-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux-study/" itemprop="url" rel="index"><span itemprop="name">Linux_study</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Linux用户与用户组管理"><a href="#Linux用户与用户组管理" class="headerlink" title="Linux用户与用户组管理"></a>Linux用户与用户组管理</h2><p>上一节已经提到了一些Linux用户的知识</p>
<p>大部分 Linux 系统在安装时都会建议用户新建一个用户而不是直接使用 root 用户进行登录，当然也有直接使用 root 登录的例如 Kali（基于 Debian 的 Linux 发行版，集成大量工具软件，主要用于数字取证的操作系统）。一般我们登录系统时都是以普通账户的身份登录的，要创建用户需要 root 权限，要用到 <code>sudo</code> 命令。</p>
<h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su &lt;user\&gt;</span><br></pre></td></tr></table></figure>
<p>使用户切换到user,需要输入目标用户的密码</p>
<p>sudo <cmd\>可以以特权级别运行 cmd 命令，需要当前用户属于 sudo 组，且需要输入当前用户的密码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - &lt;user\&gt;</span><br></pre></td></tr></table></figure>
<p>切换用户，但是同时用户的环境变量和工作目录也会跟着改变成目标用户所对应的</p>
<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser \&lt;user&gt;</span><br></pre></td></tr></table></figure>
<p>默认情况下，添加用户操作也会相应的增加一个同名的组，用户属于同名组</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914181917.png" alt="image-20210914162057186" style="zoom:50%;" /></p>
<p>这个命令不但可以添加用户到系统，同时也会默认为新用户在 /home 目录下创建一个工作目录</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914182113.png" alt="image-20210914162257824" style="zoom:50%;" /></p>
<h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><p>在 Linux 里面每个用户都有一个归属（用户组），用户组简单地理解就是一组用户的集合，它们共享一些资源和权限，同时拥有私有资源</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groups</span><br></pre></td></tr></table></figure>
<p>查看用户所属用户组</p>
<p>新建的用户 所属用户组即自身</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914182109.png" alt="image-20210914162603936"></p>
<p>一个用户可以属于多个组，将用户加入到组:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$usermod</span> -G groupName username</span><br></pre></td></tr></table></figure>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914182224.png" alt="image-20210914163504552"></p>
<p>这样stu就拥有sudo权限了</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914182227.png" alt="image-20210914164017539"></p>
<p>变更用户所属的根组(将用户加入到新的组，并从原有的组中除去）:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$usermod</span> -g groupName username</span><br></pre></td></tr></table></figure>
<h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p><code>sudo deluser lilei --remove-home</code></p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914182124.png" alt="image-20210914164438751"></p>
<p>系统的所有用户及所有组信息分别记录在两个文件中：/etc/passwd , /etc/group 默认情况下这两个文件对所有用户可读：</p>
<p>查看所有用户及权限:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$more</span> /etc/passwd</span><br></pre></td></tr></table></figure>
<p>查看所有的用户组及权限:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$more</span> /etc/group</span><br></pre></td></tr></table></figure>
<p>当然 less is better than more</p>
<h5 id="etc-group-文件格式说明"><a href="#etc-group-文件格式说明" class="headerlink" title="etc/group 文件格式说明"></a><code>etc/group</code> 文件格式说明</h5><p>/etc/group 的内容包括用户组（Group）、用户组口令、GID（组 ID） 及该用户组所包含的用户（User），每个用户组一条记录。格式如下：</p>
<blockquote>
<p>group_name:password:GID:user_list</p>
</blockquote>
<p>如果用户的 GID 等于用户组的 GID，那么最后一个字段 <code>user_list</code> 就是空的</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914182134.png" alt="image-20210914171348580"></p>
<p>x表示密码 不可见</p>
<p>利用查看文件命令可以知道有没有该用户</p>
<p>grep可以用于搜索</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914182140.png" alt="image-20210914164726095"></p>
<h3 id="添加用户组"><a href="#添加用户组" class="headerlink" title="添加用户组"></a>添加用户组</h3><p><code>groupadd</code>命令<br>功能：添加用户组<br>用法：groupadd [-g gid][-o][-r][-f] groupname<br>参数<br>-g gid：除非使用-o参数不然该值必须是唯一，不可相同。数值不可为负。<br>-o：允许设置相同组id的群组<br>-r：建立系统组<br>-f：强制执行，默认是不允许创建相同id的组的，使用此参数就可以，而且不用-o选项。</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914182145.png" alt="image-20210914165619148"></p>
<h3 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod</span><br></pre></td></tr></table></figure>
<p>命令<br>功能：修改用户组<br>用法：groupmod [-g gid [-o]] [-n group_name] group<br>参数：<br>-g gid：指定id<br>-o：与groupadd相同<br>-n group_name：修改用户组名为group_name</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914182149.png" alt="image-20210914165717338"></p>
<h3 id="删除用户组"><a href="#删除用户组" class="headerlink" title="删除用户组"></a>删除用户组</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delgroup  &lt;groupname\&gt;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914182154.png" alt="image-20210914165056709"></p>
<p>删除用户组可以使用 <code>groupdel</code> 命令，倘若该群组中仍包括某些用户，则必须先删除这些用户后，才能删除群组。</p>
<p>注意 adduser 与useradd都有,但是有差别</p>
<p><code>useradd</code> 只创建用户，不会创建用户密码和工作目录，创建完了需要使用 <code>passwd &lt;username&gt;</code> 去设置新用户的密码。<code>adduser</code> 在创建用户的同时，会创建工作目录和密码（提示你设置），做这一系列的操作</p>
<p>若使用useradd 则需要使用$passwd username修改密码</p>
<h3 id="批量添加-删除用户"><a href="#批量添加-删除用户" class="headerlink" title="批量添加(删除用户)"></a>批量添加(删除用户)</h3><p>我在网上搜到的办法基本都是用脚本执行,貌似没有这方面直接的命令</p>
<p>如果用脚本批量处理的话,这个问题也就不算问题了</p>
<p>前提是要会写shell脚本</p>
<p>关于vim以及shell脚本学习内容还是不少的</p>
<p>我后面会写一点</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914182159.png" alt="image-20210914172622881"></p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914182203.png" alt="image-20210914172610914"></p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914182207.png" alt="image-20210914172252606"></p>
<p>我在ubuntu上试了一下,发现会报错  stdin识别不了</p>
<p>这种方法只能在其他发行版用</p>
<p>所以换了一个方法</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> username:newpasswd | chpasswd</span><br></pre></td></tr></table></figure>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914190012.png" alt="image-20210914190012781"></p>
<p><strong>注意</strong>  useradd并不会添加主目录,需要加上参数</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$useradd</span> -m username</span><br></pre></td></tr></table></figure>
<p>该命令为用户创建相应的帐号和用户目录/home/username；</p>
<p>我加上-m参数后</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914190234.png" alt="image-20210914190234095"></p>
<p>但是!!!</p>
<p>我发现没有办法登录,输入原本的密码不行</p>
<p>于是查看了 shadow文件(存储用户密码的)</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914192729.png" alt="image-20210914192729556"></p>
<p>密码是 ！表示被锁了,然后我发现如果用 |就会报错</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914192817.png" alt="image-20210914192816986"></p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914192907.png" alt="image-20210914192907922" style="zoom:67%;" /></p>
<p>说是认证令牌错误,然后我将chpasswd提升到sudo,即</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914192959.png" alt="image-20210914192959814"></p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914193038.png" alt="image-20210914193038777"></p>
<p>修改成功了..所以说是权限不够…</p>
<p>并且我不清楚 | 与 &gt;的差别..</p>
<p>后面我再写一些重定向与管道..</p>
<p>批量删除用户  且删除用户目录 -r</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914191430.png" alt="image-20210914191430644"></p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914191500.png" alt="image-20210914191500303"></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chpasswd &lt; user.txt</span><br></pre></td></tr></table></figure>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>也可以利用newusers与chpasswd批量新建用户</p>
<p>一个user.txt内容如下：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user001:x600: 100:user:/home/user001:/bin/bashwin00: x:520:520::/home/win00:/sbin/nologin  通过这个属性让用户无法登录</span><br></pre></td></tr></table></figure>
<blockquote>
<p>字段含义：</p>
<p>Account：用户的名称，如例子中的root；</p>
<p>Password：用户密码，我们看到这里只显示x，不是指密码就为x，而是表示该密码已经被移动到shadow中去了。</p>
<p>UID：用户ID。</p>
<p>GID：组ID。指明用户所属组。</p>
<p>GECOS：一般说明用户信息的</p>
<p>Directory：即常说的家目录</p>
<p>Shell：用来指明用户登录时预设使用的bash</p>
</blockquote>
<p>（2）newusers &lt; user.txt</p>
<p>然后可以执行cat /etc/passwd检查/etc/passwd文件是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建。此时就会在/etc/shadow中对新增的用户产生密码</p>
<p>（3）编辑每个用户的密码对照文件，</p>
<p>范例文件passwd.txt内容如下:</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user001:密码user002:密码....</span><br></pre></td></tr></table></figure>
<p>（4）chpasswd &lt; passwd.txt</p>

      
    </div>

    
    
    
    <div>
	
   </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sekyoro.top/2021/09/21/%E5%91%BD%E4%BB%A4%E9%9B%86-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg">
      <meta itemprop="name" content="Sekyoro">
      <meta itemprop="description" content="什么也无法舍弃的人，什么也做不了.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sekyoro的博客小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/21/%E5%91%BD%E4%BB%A4%E9%9B%86-2/" class="post-title-link" itemprop="url">命令集_2</a>
        </h2>

        <div class="post-meta">
		
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-21 10:52:51 / 修改时间：10:55:17" itemprop="dateCreated datePublished" datetime="2021-09-21T10:52:51+08:00">2021-09-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux-study/" itemprop="url" rel="index"><span itemprop="name">Linux_study</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Linux-文件管理及目录与权限控制"><a href="#Linux-文件管理及目录与权限控制" class="headerlink" title="Linux 文件管理及目录与权限控制"></a>Linux 文件管理及目录与权限控制</h2><p><strong>前言</strong></p>
<p>事实上提到对文件及目录管理时,我认为无法避免会说到用户及用户组.所以在这个主题下先提及一下.</p>
<p>Linux可以实现多用户登陆,这些用户可以共享一些文件,但他们也都有自己的空间.实际上他们的文件都是放在同一个物理磁盘甚至同一个目录的.这就是因为<strong>用户管理</strong>与<strong>权限机制</strong>。</p>
<p>所以有些文件,我们可能无法进行更改,后面会提到.</p>
<p>输入</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who am i </span><br></pre></td></tr></table></figure>
<p>可以查看当前用户</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210913235127.png" alt="image-20210913235127244"></p>
<p>root账户权限最高,可以对其他用户文件进行删改</p>
<p>sudo 命令提升权限,否则一些命令可能无法执行</p>
<p>这个命令会常用</p>
<p>sudo  #使用这个命令需要知道当前登陆用户密码且该用户在sudo用户组内.</p>
<p>用户组就是若干个用户在一起的组合,其他用户就是既不是本身用户也不是这个用户组里的用户.</p>
<h3 id="文件及目录的管理"><a href="#文件及目录的管理" class="headerlink" title="文件及目录的管理"></a>文件及目录的管理</h3><p>有了些基本知识就可以对文件进行操作了</p>
<p>Linux目录结构与Windows不同,以目录为主.可以理解为树形目录是一个用户可操作系统的骨架。虽然本质上无论是目录结构还是操作系统内核都是存储在磁盘上的，但从逻辑上来说 Linux 的磁盘是挂载在目录上的，每一个目录不仅能使用本地磁盘分区的文件系统，也可以使用网络上的文件系统。</p>
<p>Linux目录配置依据 FHS。根据这个标准,Linux的目录该放那些文件是有规定的</p>
<p><img data-src="https://doc.shiyanlou.com/linux_base/4-1.png" alt="img" style="zoom:50%;" /></p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210913235143.png" alt="img"></p>
<p><strong>关于目录树</strong></p>
<p>绝对路径: 由根目录/开始写起的文件名或目录名称</p>
<p>相对路径:相对于目前路径的文件名写法</p>
<p># 绝对路径 </p>
<p>cd /usr/local/bin </p>
<h1 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h1><p>cd ../../usr/local/bin</p>
<p>cd    改变当前目录</p>
<ul>
<li>找到文件/目录位置：cd</li>
<li>切换到上一个工作目录： cd -</li>
<li>切换到home目录： cd or cd ~</li>
</ul>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000226.png" alt="image-20210913192130268" style="zoom:50%;"/></p>
<ul>
<li>显示当前路径: pwd</li>
</ul>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000213.png" alt="image-20210913192046022" style="zoom:50%;" /></p>
<ul>
<li><p>更改当前工作路径为</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path: <span class="variable">$cd</span> path</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000215.png" alt="image-20210913192304748" style="zoom:50%;" /></p>
<p>.. 表示上一级目录</p>
<p>.  表示当前目录</p>
<p>现在可以开始对文件的查看了</p>
<p>命令</p>
<ul>
<li>创建目录：mkdir</li>
<li>删除：rm</li>
<li>删除非空目录：rm -rf file目录</li>
<li>删除日志 rm <em>log (等价: $find ./ -name “</em>log” -exec rm {} ;)</li>
<li>移动：mv</li>
<li>复制：cp (复制目录：cp -r )</li>
<li>创建文件:touch</li>
</ul>
<h4 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h4><h5 id="touch-创建空白文件"><a href="#touch-创建空白文件" class="headerlink" title="touch 创建空白文件"></a>touch 创建空白文件</h5><p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000204.png" alt="image-20210913192915649" style="zoom:50%;" /></p>
<h5 id="mkdir-新建目录"><a href="#mkdir-新建目录" class="headerlink" title="mkdir 新建目录"></a>mkdir 新建目录</h5><p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000202.png" alt="image-20210913193233984" style="zoom:50%;" /></p>
<p>我们发现如果想创建多层的目录直接使用mkdir不行,需要 mkdir -p</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000200.png" alt="image-20210913193350560" style="zoom:50%;" /></p>
<p>同时一个目录下文件不能与文件夹同名</p>
<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>使用 cp命令（copy）复制一个文件到指定目录</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000157.png" alt="image-20210913193711075" style="zoom:50%;"/></p>
<p>文件的复制。默认复制文件的数据</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210913235351.png" alt="image-20210913200119663"></p>
<h5 id="复制目录"><a href="#复制目录" class="headerlink" title="复制目录"></a>复制目录</h5><p>直接使用cp复制目录会出错</p>
<p>加上参数 -r 递归复制</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cp</span> -r source_dir  dest_dir</span><br></pre></td></tr></table></figure>
<p>常用参数</p>
<p>-f ：为强制 (force) 的意思，若有重复或其它疑问时，不会询问使用者，而强制复制；<br>-i ：若目的文件(destination)已经存在时，在覆盖时会先询问是否真的动作！<br>-l ：进行硬链接 (hard link) 建立，而非复制档案本身；<br>-p ：连同档案的属性(权限,时间,用户)一起复制过去，而非使用预设属性；<br>-r ：递归持续复制，用于目录的复制行为；</p>
<p>-d:复制成为符号连接</p>
<p>默认情况下,cp后目标文件拥有者是命令执行者.如果想要连着这个属性更改需要加上-p</p>
<p>复制时需要考虑:</p>
<p>保留源文件完整信息?</p>
<p>源文件是否是符号链接</p>
<p>源文件是否是mulu</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>使用 <code>rm</code>（remove files or directories）命令删除一个文件</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000146.png" alt="image-20210913195612391" style="zoom:50%;" /></p>
<p>当然 不能删除本身不存在的文件</p>
<p>有时候你会遇到想要删除一些为只读权限的文件，直接使用 <code>rm</code> 删除会显示一个提示,加上 -f参数直接强制删除</p>
<p>-i  在删除前会询问</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000149.png" alt="image-20210913195758530" style="zoom:50%;" /></p>
<h5 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h5><p>同样的,需要加上-r参数才能删除目录</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000140.png" alt="image-20210913200839956" style="zoom:50%;" /></p>
<p>其实也可以使用rmdir,但只能删除空目录</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000130.png" alt="image-20210913201913643" style="zoom:50%;" /></p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000126.png" alt="image-20210913201926192" style="zoom:50%;" /></p>
<h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><p>使用mv命令移动文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv <span class="built_in">source</span> destination </span><br></pre></td></tr></table></figure>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000121.png" alt="image-20210913201207839" style="zoom:50%;" /></p>
<h5 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h5><p><code>mv</code> 命令除了能移动文件外，还能给文件重命名。命令格式为 <code>mv 旧的文件名 新的文件名</code>。</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000111.png" alt="image-20210913201430489" style="zoom:50%;" /></p>
<h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p>Unix/Linux 系统是一个典型的多用户系统，不同的用户处于不同的地位，对文件和目录有不同的访问权限。为了保护系统的安全性，Unix/Linux 系统除了对用户权限作了严格的界定外，还在用户身份认证、访问控制、传输安全、文件读写权限等方面作了周密的控制。</p>
<p>在 Unix/Linux 中的每一个文件或目录都包含有访问权限，这些访问权限决定了谁能访问和如何访问这些文件和目录。</p>
<h4 id="查看文件与目录"><a href="#查看文件与目录" class="headerlink" title="查看文件与目录"></a>查看文件与目录</h4><p>之前也用到很多次  ls命令</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000101.png" alt="image-20210913202256597" style="zoom:50%;" /></p>
<p>ls列出目录下的文件</p>
<p>-a  显示所有文件及目录（包含以“.”开头的隐藏文件）<br><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000108.png" alt="image-20210913202947310" style="zoom:50%;" />-l  显示详细文件内容,长格式</p>
<p>-h  与-l一起使用，输出易于阅读的文件大小。 Human-readable</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000057.png" alt="image-20210913202919245" style="zoom:50%;" /></p>
<p>-r  将文件以相反次序显示(原定以英文字母次序)</p>
<p>-d 若不加参数指定目录,ls会列出目录中的内容,若与-l结合则可以查看目录信息</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000055.png" alt="image-20210913202837994" style="zoom:50%;" /></p>
<p>-t 安修改日期排序输出</p>
<p>-S 按文件大小排序输出</p>
<p>我们会发现 在长格式下,文件前面会有一些东西</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000053.png" alt="image-20210913203233587" style="zoom:50%;" /></p>
<p>分别是 文件类型权限  链接数  文件所属用户组 文件大小Byte  文件最后修改时间  文件名 (当然后面可能会有软链接) </p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000050.png" alt="pic"></p>
<h4 id="关于权限"><a href="#关于权限" class="headerlink" title="关于权限"></a>关于权限</h4><p><img data-src="https://doc.shiyanlou.com/linux_base/3-10.png" alt="pic" style="zoom: 67%;" /></p>
<p>读权限，表示你可以使用 <code>cat &lt;file name&gt;</code> 命令来读取某个文件的内容；写权限，表示你可以编辑和修改某个文件的内容；</p>
<p>执行权限，通常指可以运行的二进制程序文件或者脚本文件，如同 Windows 上的 <code>exe</code> 后缀的文件，不过 Linux 上不是通过文件后缀名来区分文件的类型。你需要注意的一点是，<strong>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件</strong>，这是因为目录文件实际保存着该目录里面的文件的列表等信息。</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000046.png" alt="image-20210913203914866" style="zoom:50%;" /></p>
<p>可以分析一下,这是个目录(d) 拥有者与用户组权限都是rwx,即可读可写可执行. 但其他用户不能写,说明其他用户不能改写该目录.所有者与所属用户组为shiyanlou</p>
<h4 id="更改权限"><a href="#更改权限" class="headerlink" title="更改权限"></a>更改权限</h4><p>chgrp:修改文件所属用户组</p>
<p>chown:修改文件拥有者</p>
<p>-R 参数递归修改连通目录下的所有文件</p>
<p>chomd:修改文件的权限</p>
<ul>
<li>改变文件的拥有者 chown</li>
<li>改变文件读、写、执行等属性 chmod</li>
<li>递归子目录修改： chown -R tuxapp source/</li>
<li>增加脚本可执行权限： chmod a+x myscript</li>
</ul>
<p>注意 用户组在 etc/group里。用户在etc/passwd里</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000043.png" alt="image-20210913205052643" style="zoom:50%;" /></p>
<p>创建用户,在该用户目录下创建ipone文件。发现该文件所有者是lilei</p>
<p>现在切回root</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000041.png" alt="image-20210913205812323" style="zoom:50%;" /></p>
<p>发现该文件所有者变为shiyanlou</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000039.png" alt="image-20210913205912499"></p>
<p>现在是更改了文件的所有者,下面继续更改所属用户组</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000037.png" alt="image-20210913212151973"></p>
<p>这样的话lilei就只有rx的权限了,也就是说无法更改文件.我们试一试</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000035.png" alt="image-20210913212322183" style="zoom:33%;" /></p>
<p>会发现无法修改…</p>
<p>接下来进行修改权限</p>
<ol>
<li><p>二进制数字表示</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000033.png" alt="pic"></p>
</li>
</ol>
<p>第一位指定属主的权限，第二位指定组权限，第三位指定其他用户的权限，每位通过4(读)、2(写)、1(执行)三种数值的和来确定权限。如6(4+2)代表有读写权，7(4+2+1)有读、写和执行的权限。</p>
<p>例如<img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000030.png" alt="image-20210913211810594"></p>
<p>可以发现改为了拥有者可读可写</p>
<ol>
<li><p>符号操作</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$chmod</span> userMark(+|-)PermissionsMark</span></span><br></pre></td></tr></table></figure>
<p>userMark取值：</p>
<ul>
<li>u：用户</li>
<li>g：组</li>
<li>o：其它用户</li>
<li>a：所有用户</li>
</ul>
<p>PermissionsMark取值：</p>
<ul>
<li>r:读</li>
<li>w：写</li>
<li>x：执行</li>
</ul>
</li>
</ol>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000026.png" alt="image-20210913212537141" style="zoom:50%;" /></p>
<p><code>+</code> 和 <code>-</code> 分别表示增加和去掉相应的权限。</p>
<p>在shell中，要修改文件当前的用户必须具有管理员root的权限。可以通过su命令切换到root用户，也可以通过sudo获得root的权限</p>
<p><strong>注意</strong>:对于文件和文件夹来说。 rwx权限不太一样</p>
<p>文件:r 读取文件内容  w修改文件内容  x执行文件内容</p>
<p>目录:r 读到文件名  w修改文件名  x进入目录权限</p>
<p>也就是说若没有x权限,无法进入目录(不代表不能知道目录下的东西)</p>
<h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000024.png" alt="image-20210913213443471" style="zoom:50%;" /></p>
<p>创建一个目录 然后更改权限 使得用户组与其他用户只有r权限</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000022.png" alt="image-20210913213634417" style="zoom:50%;" /></p>
<p>使用groups查看当前用户的用户组。发现他加入了多个用户组</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000020.png" alt="image-20210913213536038"></p>
<p>然后想要进入该目录权限不够,因为只有r</p>
<p>sudo大法  更改权限进入文件</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000018.png" alt="image-20210913214229305"></p>
<p>添加一个文件</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000015.png" alt="image-20210913214622660" style="zoom:50%;" /></p>
<p>发现可以查询目录下的文件名列表但无法切换到目录内。甚至无法读取文件内容</p>
<h4 id="file确定文件类型"><a href="#file确定文件类型" class="headerlink" title="file确定文件类型"></a>file确定文件类型</h4><p>Linux下不要求文件名反应文件类型,使用file命令可以查看类型</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000012.png" alt="image-20210913215723013" style="zoom:50%;" /></p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000010.png" alt="image-20210913225537180"></p>
<h4 id="less查看文本文件"><a href="#less查看文本文件" class="headerlink" title="less查看文本文件"></a>less查看文本文件</h4><p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000008.png" alt="image-20210913215804478"></p>
<p>我们可以上下翻页。q退出</p>
<h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>cat命令用于连接文件并打印到标准输出设备上。</p>
<p>我写在这里是因为这些命令用的挺多的</p>
<p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure>
<p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure>
<h4 id="查看文件：cat-vi-head-tail-more"><a href="#查看文件：cat-vi-head-tail-more" class="headerlink" title="查看文件：cat vi head tail more"></a>查看文件：cat vi head tail more</h4><p>显示时同时显示行号:</p>
<figure class="highlight sh"><figcaption><span>l</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cat</span> -n</span><br></pre></td></tr></table></figure>
<p>按页显示列表内容:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">ls -al | more</span></span><br></pre></td></tr></table></figure>
<p>只看前10行:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">head - 10 **</span></span><br></pre></td></tr></table></figure>
<p>显示文件第一行:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">head -1 filename</span></span><br></pre></td></tr></table></figure>
<p>显示文件倒数第五行:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">tail -5 filename</span></span><br></pre></td></tr></table></figure>
<p>查看两个文件间的差别:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">diff file1 file2</span></span><br></pre></td></tr></table></figure>
<p>动态显示文本最新信息:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">tail -f crawler.log</span></span><br></pre></td></tr></table></figure>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>Linux链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，ln命令产生硬链接</p>
<p>在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的</p>
<h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>也叫符号链接</p>
<p>与Windows的快捷方式类似</p>
<p>在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s cc ccTo :符号链接(软链接)；删除源，另一个无法使用；（后面一个ccTo 为新建的文件）</span><br></pre></td></tr></table></figure>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000002.png" alt="image-20210913220642505"></p>
<p>ls -li   -i可以显示inode节点。通过这个判断链接。当然,符号链接inode不同且有箭头指向被链接的文件.</p>
<p>若源文件被删,则符号链接的文件也失效</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000001.png" alt="image-20210913221115358"></p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210913235959.png" alt="image-20210913221136588"></p>
<h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><p>它与软链接实现方式不同</p>
<p>硬链接指通过索引节点来进行连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的链接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000450.png" alt="image-20210913221552058"></p>
<p>硬链接f2到f1，将f1删掉.因为节点相同,发现原本软链接到f1的f3硬链接到了f2</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000445.png" alt="image-20210913221853123"></p>
<p>删除被软链接的文件,在创建同名文件,发现软链接的文件更新了</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210913235953.png" alt="image-20210913222100169"></p>
<h3 id="文件压缩与解压"><a href="#文件压缩与解压" class="headerlink" title="文件压缩与解压"></a>文件压缩与解压</h3><p>在 Windows 上最常见的不外乎这两种 <code>*.zip</code>，<code>*.7z</code> 后缀的压缩文件。而在 Linux 上面常见的格式除了以上两种外，还有 <code>.rar</code>，<code>*.gz</code>，<code>*.xz</code>，<code>*.bz2</code>，<code>*.tar</code>，<code>*.tar.gz</code>，<code>*.tar.xz</code>，<code>*.tar.bz2</code>，</p>
<p>Linux 常用的压缩与解压缩命令有：tar、gzip、gunzip、bzip2、bunzip2、compress 、uncompress、 zip、 unzip、rar、unrar 等</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文件后缀名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*.zip</code></td>
<td>zip 程序打包压缩的文件</td>
</tr>
<tr>
<td><code>*.rar</code></td>
<td>rar 程序压缩的文件</td>
</tr>
<tr>
<td><code>*.7z</code></td>
<td>7zip 程序压缩的文件</td>
</tr>
<tr>
<td><code>*.tar</code></td>
<td>tar 程序打包，未压缩的文件</td>
</tr>
<tr>
<td><code>*.gz</code></td>
<td>gzip 程序（GNU zip）压缩的文件</td>
</tr>
<tr>
<td><code>*.xz</code></td>
<td>xz 程序压缩的文件</td>
</tr>
<tr>
<td><code>*.bz2</code></td>
<td>bzip2 程序压缩的文件</td>
</tr>
<tr>
<td><code>*.tar.gz</code></td>
<td>tar 打包，gzip 程序压缩的文件</td>
</tr>
<tr>
<td><code>*.tar.xz</code></td>
<td>tar 打包，xz 程序压缩的文件</td>
</tr>
<tr>
<td><code>*tar.bz2</code></td>
<td>tar 打包，bzip2 程序压缩的文件</td>
</tr>
<tr>
<td><code>*.tar.7z</code></td>
<td>tar 打包，7z 程序压缩的文件</td>
</tr>
</tbody>
</table>
</div>
<p>简单来说,就是打包,压缩</p>
<h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><h5 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h5><p>最常用的打包命令是 tar，使用 tar 程序打出来的包我们常称为 tar 包，tar 包文件的命令通常都是以 .tar 结尾的。生成 tar 包后，就可以用其它的程序来进行压缩了</p>
<p>​    tar实现了对 7z、gzip、xz、bzip2 等工具的支持，这些压缩工具本身只能实现对文件或目录（单独压缩目录中的文件）的压缩，没有实现对文件的打包压缩.</p>
<p>下来来介绍参数</p>
<p>-c 创建一个tar包   -f指定文件名</p>
<p>-r 增加文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -cf mytar.tar file</span><br></pre></td></tr></table></figure>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210913235943.png" alt="image-20210913223434051"></p>
<p>创建了一个tar包</p>
<p>还可以加上 <code>-v</code> 参数以可视的的方式输出打包的文件。</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210913235941.png" alt="image-20210913223923573" style="zoom:50%;" /></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -uf all.tar logo.gif</span><br></pre></td></tr></table></figure>
<p>更新原来 tar 包 all.tar 中 logo.gif 文件，-u 是表示更新文件的意思</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tf all.tar</span><br></pre></td></tr></table></figure>
<p>列出 all.tar 包中所有文件，-t 是列出文件的意思</p>
<ul>
<li>保留文件属性和跟随链接（符号链接或软链接），有时候我们使用 tar 备份文件当你在其他主机还原时希望保留文件的属性（<code>-p</code> 参数）和备份链接指向的源文件而不是链接本身（<code>-h</code> 参数）：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cphf etc.tar /etc</span><br></pre></td></tr></table></figure>
<h5 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h5><p>解包一个文件（<code>-x</code> 参数）到指定路径的<strong>已存在</strong>目录（<code>-C</code> 参数）</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210913235939.png" alt="image-20210913225018181"></p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210913235934.png" alt="image-20210913224507056"></p>
<p>只查看不解包文件 <code>-t</code> 参数</p>
<h5 id="压缩与解压"><a href="#压缩与解压" class="headerlink" title="压缩与解压"></a>压缩与解压</h5><p>对于创建不同的压缩格式的文件，对于 tar 来说是相当简单的，需要的只是换一个参数</p>
<p>在创建 tar 文件的基础上添加 <code>-z</code> 参数</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -czf mytar.tar.gz file</span><br></pre></td></tr></table></figure>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210913235928.png" alt="image-20210913225228029"></p>
<p>解压文件使用 -xzf (对于gzip)</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210913235918.png" alt="image-20210913225338711"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>压缩文件格式</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*.tar.gz</code></td>
<td><code>-z</code></td>
</tr>
<tr>
<td><code>*.tar.xz</code></td>
<td><code>-J</code></td>
</tr>
<tr>
<td><code>*tar.bz2</code></td>
<td><code>-j</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h4><p>其实光tar已经够了,这里稍微写一下zip</p>
<p><code>-r</code> 参数表示递归打包包含子目录的全部内容</p>
<p><code>-q</code> 参数表示为安静模式，即不向屏幕输出信息</p>
<p><code>-o</code>，表示输出文件</p>
<p>还可以设置压缩等级</p>
<p>zip -r -o myzip.zip file</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210913235913.png" alt="image-20210913225914594"></p>
<p>du用于查看文件大小</p>
<p>-e设置密码</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210913235858.png" alt="image-20210913230218420"></p>
<p>-l 用于使LF转化为CR+LF. 也就是linux换行符为LF在windows上无法显示</p>
<p><strong>unzip用于解压</strong></p>
<p>-q 安静模式</p>
<p>-d  指定输出到的目录</p>
<p>-l  不解压只查看内容</p>
<p>中文压缩包 -O GBK 指定编码类型</p>
<p><strong>小结</strong></p>
<ul>
<li>zip：</li>
<li>打包 ：zip something.zip something （目录请加 -r 参数）</li>
<li>解包：unzip something.zip</li>
<li>指定路径：-d 参数</li>
<li>tar：</li>
<li>打包：tar -cf something.tar something</li>
<li>解包：tar -xf something.tar</li>
<li>指定路径：-C 参数</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>实时查找</p>
<p>搜寻文件或目录:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$find</span> ./ -name <span class="string">&quot;core*&quot;</span> | xargs file</span><br></pre></td></tr></table></figure>
<p>查找目标文件夹中是否有obj文件:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$find</span> ./ -name <span class="string">&#x27;*.o&#x27;</span></span><br></pre></td></tr></table></figure>
<p>指定目录  与 -name查找关键字(可用正则)</p>
<p>递归当前目录及子目录删除所有.o文件:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$find</span> ./ -name <span class="string">&quot;*.o&quot;</span> -<span class="built_in">exec</span> rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h3><p>locate会为文件系统建立索引数据库，如果有文件更新，需要定期执行更新命令来更新索引库。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$locate</span> string</span><br></pre></td></tr></table></figure>
<p>寻找包含有string的路径:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$updatedb</span></span><br></pre></td></tr></table></figure>
<p>与find不同，locate并不是实时查找。你需要更新数据库，以获得最新的文件索引信息。</p>

      
    </div>

    
    
    
    <div>
	
   </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sekyoro.top/2021/09/21/%E5%91%BD%E4%BB%A4%E9%9B%86-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg">
      <meta itemprop="name" content="Sekyoro">
      <meta itemprop="description" content="什么也无法舍弃的人，什么也做不了.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sekyoro的博客小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/21/%E5%91%BD%E4%BB%A4%E9%9B%86-1/" class="post-title-link" itemprop="url">命令集_1.md</a>
        </h2>

        <div class="post-meta">
		
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-21 10:52:01 / 修改时间：10:54:36" itemprop="dateCreated datePublished" datetime="2021-09-21T10:52:01+08:00">2021-09-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux-study/" itemprop="url" rel="index"><span itemprop="name">Linux_study</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-Linux软件部署及应用"><a href="#1-Linux软件部署及应用" class="headerlink" title="1.Linux软件部署及应用"></a>1.Linux软件部署及应用</h2><p>在Linux中,软件包分为</p>
<ul>
<li>源码包安装  提供了该软件所有程序源代码的发布形式，需要用户自己<strong>编译成可执行的二进制代码并进行安装</strong>，优点是<strong>配置灵活</strong>，可以随意去掉或保留某些功能或者模块，适应多种硬件/操作系统平台及编译环境，缺点就是<strong>难度比较大</strong>，一般不适合初学者使用。</li>
<li>二进制包安装  事先已经编译好的<strong>二进制</strong>形式的软件包，有点事<strong>安装方便</strong>，缺点是灵活性差，如果该软件包是为特定的硬件/操作系统平台编译的，那它就不能再另外的平台或者环境下正确执行</li>
</ul>
<p>注意,在不同linux发行版上软件安装机制不同</p>
<ul>
<li>DPKG Debian(ubuntu)   命令rpm   在线升级 yum </li>
<li>RPM  (Centos Fedora)   命令dpkg    在线apt(apt-get)</li>
</ul>
<h3 id="源码包安装"><a href="#源码包安装" class="headerlink" title="源码包安装"></a>源码包安装</h3><p>软件发布者将源代码先以tar打包,再进行压缩(如gzip,bzip2,xz)得到所谓<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/tarball/6505617">Tarball </a>文件.</p>
<p>解压该文件可以得到</p>
<ul>
<li>源代码文件</li>
<li>检测程序文件(configure或config文件)</li>
<li>本软件的建议安装说明(install或readme)</li>
</ul>
<p>通常的安装流程</p>
<ol>
<li>在厂商网站下载一个Tarball文件</li>
<li>将Tarball文件解开,产生很多源代码文件</li>
<li>利用gcc或make(与makefile)结合,产生目标文件</li>
<li>以gcc进行函数库与主,子程序进行链接,形成主要的二进制文件</li>
<li>将上述文件以及相关配置文件安装在主机上(install)</li>
</ol>
<h4 id="大概步骤"><a href="#大概步骤" class="headerlink" title="大概步骤"></a>大概步骤</h4><p>下载源代码软件包</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget url</span><br></pre></td></tr></table></figure>
<p>或者直接在一些网站上下载得到一个压缩包 wget功能下载url上的文件</p>
<p>解压缩</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -jxvf xx.tar.bz2</span><br><span class="line">tar -zxvf xx.tar.gz</span><br></pre></td></tr></table></figure>
<p>进入压缩目录</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure.   <span class="comment">#编译环境检查以及安装配置</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--prefix == 安装路径</span><br></pre></td></tr></table></figure>
<p>编译源代码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make   <span class="comment">#再修改configure后会有一个makefile。 make利用该文件(文件中有相关的配置条件)进行编译</span></span><br></pre></td></tr></table></figure>
<p>当然之前也可以make clean一下,目的是清除.o目标文件 </p>
<p>安装到本机器</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：查看安装说明,提前处理软件包依赖</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>之前我在虚拟机上装了一个bochs(开源IA-32(x86)电脑模拟器) 符合源代码安装,把这个过程记录下</p>
<ol>
<li><p>在官网下载软件包,会得到一个压缩包. tar.gz或类似后缀文件</p>
</li>
<li><p>解压该文件。tar -zxvf nasm.tar.gz</p>
<p>得到一个文件夹</p>
</li>
</ol>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210912223547.png" alt="image-20210912223547434"></p>
<ol>
<li><p>前两步其实很简单,现在是源码安装的重点:配置</p>
<p>在得到的文件中有许多程序文件,通常有configure,我们可以通过 ./configure -参数 来进行相关配置</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210912223807.png" alt="image-20210912223807497"></p>
<p>进行编译设置</p>
<p>当然,我门很可能根本不知道有哪些参数,可以在解压得到文件中找到相关配置说明(一定会有的,不过是英文)</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210912223955.png" alt="image-20210912223955416"></p>
</li>
</ol>
<p>   配置好后会有makefile(或类似的东西),然后直接make根据这个配置文件进行配置,配置好后就能直接安装了</p>
<p>   <img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210912224149.png" alt="image-20210912224149809" style="zoom:50%;" /></p>
<p>   因为我已经装好的,这里显示就会不一样</p>
<ol>
<li>安装。make install</li>
</ol>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210912224240.png" alt="image-20210912224240669"></p>
<h3 id="二进制安装"><a href="#二进制安装" class="headerlink" title="二进制安装"></a>二进制安装</h3><p>我们需要做的只是将从网络上下载的二进制包解压后放到合适的目录，然后将包含可执行的主程序文件的目录添加进<code>PATH</code>环境变量即可</p>
<p>优点：安装过程简单快速</p>
<p>缺点：无法查看源代码、选择功能不灵活、有依赖性（需要提前一些前置依赖包）</p>
<p>这就设计到刚才说的rpm与dpkg了.     <strong>注意srpm里面是源码,rpm与dpkg下载的是经过编译的二进制文件,不可修改参数</strong></p>
<p>我认为二进制安装难点是安装的路径以及相关的东西,它都给你默认了,灵活性小,但安装简单.</p>
<p>dpkg与rpm只是用在不同linux发行平台,因为我用的ubuntu,只写一下dpkg就行了.道理类似.</p>
<p>dpkg本身是一个底层工具,上层的工具如apt,用于远程获取安装包</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-i</td>
<td>安装指定deb包</td>
<td></td>
</tr>
<tr>
<td>-R</td>
<td>加上目录,安装目录下的所有deb包</td>
<td></td>
</tr>
<tr>
<td>-r</td>
<td>remove 移除安装的软件包</td>
<td></td>
</tr>
<tr>
<td>-s</td>
<td>显示已安装包的信息</td>
<td></td>
</tr>
<tr>
<td>-L</td>
<td>显示已安装的软件包的目录信息</td>
<td></td>
</tr>
<tr>
<td>-l</td>
<td>列出已安装的所有软件包</td>
</tr>
</tbody>
</table>
</div>
<h3 id="大概步骤-1"><a href="#大概步骤-1" class="headerlink" title="大概步骤"></a>大概步骤</h3><ol>
<li>下载(不安装)一个二进制文件(如何知道是否是一个二进制文件呢,要么自己甄别,要么利用apt或yum)一般 .rpm .deb 是二进制</li>
<li>利用dpkg(ubuntu)或rpm(Centos)安装,参数见上,列举不全,自行搜索</li>
<li>这样文件就在对应的目录</li>
</ol>
<p>过程确实比源码包安装简单</p>
<p>注意: apt-get install安装目录是包的维护者确定的，不是用户</p>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><p>我安装一个Emacs试一试</p>
<p>涉及到apt  后面会说</p>
<ol>
<li><p>利用apt在线下载一个软件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update  <span class="comment">#更新软件列表</span></span><br><span class="line">sudo apt -d install -y emacs <span class="comment">#只下载不安装 且回应安装选项时一律yes.</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210912231854.png" alt="image-20210912231853997"></p>
</li>
<li><p>利用dpkg安装</p>
<p>可以把安装包移动到一个路径下安装在那</p>
<p>我们发现不止下载了一个包,说有依赖关系,要一起安装</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210912232149.png" alt="image-20210912232149245"></p>
</li>
</ol>
<p>​                    如果出现一些依赖关系,安装时就要提前或一起安装</p>
<p>​                    这是可以利用apt的 -f参数修复依赖关系,相当于将没安装的都装上了</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210912232408.png" alt="image-20210912232408925"></p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>在线下载</p>
<p>apt与yum</p>
<p>我们用到了apt下载,这个东西其实很常用.yum是其他发行版的,同理</p>
<p>一般有人常用apt-get,事实上apt更常用,也更好(至少我认为)</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210912232716.png" alt="image-20210912232716641"></p>
<p>apt可以自动下载,配置安装二进制<strong>或源代码</strong>格式的软件包.</p>
<p>当执行安装时,会在本地的数据库中搜索关于软件的相关信息,根据信息在相关服务器上下载(你也许最好要换源).需要执行sudo apt update 使本地软件包列表与服务器保持一致.</p>
<p>好消息：apt可以很好的处理依赖关系</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>工具</th>
<th>说明</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>install</td>
<td>安装软件包</td>
<td></td>
</tr>
<tr>
<td>update</td>
<td>从服务器上更新用于更新本地软件的列表</td>
<td></td>
</tr>
<tr>
<td>upgrade</td>
<td>升级本地软件</td>
<td></td>
</tr>
<tr>
<td>remove</td>
<td>移除已安装的软件包与与其有关系的软件包(株连)</td>
<td></td>
</tr>
<tr>
<td>clean</td>
<td>移除下载到本地的软件包  路径 /var/cache/apt/archives/</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>只下载不安装</td>
<td></td>
</tr>
<tr>
<td>-y</td>
<td>自动回应是否安装软件包的选项  yes</td>
<td></td>
</tr>
<tr>
<td>-f</td>
<td>修复依赖关系</td>
</tr>
</tbody>
</table>
</div>
<p>可以使用sudo-cache search搜索本地有没有该软件</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210912233857.png" alt="image-20210912233857067"></p>
<h3 id="软件卸载-更新"><a href="#软件卸载-更新" class="headerlink" title="软件卸载 更新"></a>软件卸载 更新</h3><p>根据不同的安装方式进行</p>
<h4 id="源码卸载-更新"><a href="#源码卸载-更新" class="headerlink" title="源码卸载 更新"></a>源码卸载 更新</h4><p>我们已经知道源码安装比较麻烦了,卸载的话也有点小麻烦</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make uninstall <span class="comment">#可以卸载</span></span><br></pre></td></tr></table></figure>
<p>事实上有些源码包并未提供这样的卸载方式</p>
<p>可以在安装时指定安装路径   —prefix==路径</p>
<p>卸载时把那个目录删除就行 </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm  -rf 目录</span><br></pre></td></tr></table></figure>
<p>更新的话,如果是从网站上下载编译的只有重新下载再走一遍流程</p>
<h4 id="二进制卸载-更新"><a href="#二进制卸载-更新" class="headerlink" title="二进制卸载 更新"></a>二进制卸载 更新</h4><p>二进制代码如果在一个目录(比如是解压到一个目录的情况),直接</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf 目录</span><br></pre></td></tr></table></figure>
<p>我试一下,卸载源码安装的bochs,试一试 make uninstall</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210912234855.png" alt="image-20210912234855213"></p>
<p>成功了,我好不容易安装的软件没了</p>
<p>可以看出,安装的软件的路径不太好确定</p>
<p>更新的话同理,事实上如果从网站上下载的,不管是源码还是二进制,只能重新走一遍开始的流程了</p>
<p><strong>但是</strong></p>
<p>如果用apt或类似的软件管理就不一样了</p>
<p>更新软件包</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt update         <span class="comment"># 更新安装源(Source)apt upgrade         # 更新已安装的软件包apt dist-upgrade      # 更新已安装的软件包(识别并处理依赖关系的改变)</span></span><br></pre></td></tr></table></figure>
<p>卸载软件包</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt remove PackageName       <span class="comment"># 删除软件包, 保留配置文件apt purge PackageName        # 删除软件包, 同时删除配置文件apt autoremove PackageName     # 移除之前被其他软件依赖但不再被使用的软件</span></span><br></pre></td></tr></table></figure>
<p> 安装软件包</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install PackageName         <span class="comment"># 普通安装apt install PackageName=VersionName   # 安装指定包的指定版本apt --reinstall install PackageName   #重新安装apt build-dep PackageName        # 安装源码包所需要的编译环境apt -f install             # 修复依赖关系</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> 如果出现一些问题需要重新安装软件, —reinstall install很有用，</p>
<p>同时dpkg也可以处理软件的卸载</p>
<ol>
<li>dpkg -r package-name删除软件包（保留配置信息）</li>
<li>dpkg —configure package-name 配置软件包，如果加上<code>-a</code>表示配置所有未配置的软件包</li>
</ol>
<h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><p>1.更新软件列表</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210913000617.png" alt="image-20210913000617325"></p>
<p>2.更新本地软件</p>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210913000704.png" alt="image-20210913000704670"></p>
<p>这样就更新了</p>
<p>卸载的话 </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove</span><br></pre></td></tr></table></figure>
<p>就不示范了,懒得再装</p>
<h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><p>因为Linux命令太多了,学会使用帮助很重要</p>
<ul>
<li>在只记得部分命令关键字的场合，我们可通过man -k来搜索；</li>
<li>需要知道某个命令的简要说明，可以使用whatis；而更详细的介绍，则可用info命令；</li>
</ul>
<p><img data-src="https://gitee.com/the-helpless-beggar/mypics/raw/master/20210914000533.png" alt="image-20210913231211364"></p>
<ul>
<li>查看命令在哪个位置，我们需要使用which；</li>
<li>而对于命令的具体参数及使用方法，我们需要用到强大的man</li>
<li>help也可以查看内置命令(help不在zsh中,且ls不是内置命令）</li>
</ul>
<p>简要说明命令的作用（显示命令所处的man分类页面）:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$whatis</span> <span class="built_in">command</span></span><br></pre></td></tr></table></figure>
<p>查看程序的binary文件所在路径:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$which</span> <span class="built_in">command</span></span><br></pre></td></tr></table></figure>
<p>详细的说明文档:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$info</span> <span class="built_in">command</span></span><br></pre></td></tr></table></figure>
<p>eg:查找make程序安装路径:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$which</span> make/opt/app/openav/soft/bin/make install</span><br></pre></td></tr></table></figure>
<p>查看程序的搜索路径:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$whereis</span> <span class="built_in">command</span></span><br></pre></td></tr></table></figure>
<p>当系统中安装了同一软件的多个版本时，不确定使用的是哪个版本时，这个命令就能派上用场</p>

      
    </div>

    
    
    
    <div>
	
   </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sekyoro.top/2021/09/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg">
      <meta itemprop="name" content="Sekyoro">
      <meta itemprop="description" content="什么也无法舍弃的人，什么也做不了.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sekyoro的博客小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">微信小程序开发</a>
        </h2>

        <div class="post-meta">
		
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-06 12:32:30 / 修改时间：12:36:57" itemprop="dateCreated datePublished" datetime="2021-09-06T12:32:30+08:00">2021-09-06</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="微信小程序开发"><a href="#微信小程序开发" class="headerlink" title="微信小程序开发"></a>微信小程序开发</h1><p>开发文档挺齐全的,也是借着微信这个平台.</p>
<p>开发模式也挺好.</p>
<p>不过缺点也是只能局限在这个平台,要开发手机软件还要看其他的而且现在web比较好.</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/09/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
    <div>
	
   </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>
	
  <aside class="sidebar">
    <div class="sidebar-inner">
      	   
          <!-- canvas粒子时钟 -->
          <div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>
        
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.css">
	<div class="aplayer" data-id="1294924565" data-server="netease" data-type="song"></div>
	<script src="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script>

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>
	  
		
      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sekyoro"
      src="https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg">
  <p class="site-author-name" itemprop="name">Sekyoro</p>
  <div class="site-description" itemprop="description">什么也无法舍弃的人，什么也做不了.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/drowning-in-codes" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;drowning-in-codes" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/mailtobukalala174@gmail.com" title="E-Mail → mailtobukalala174@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>
  


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sekyoro</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">182k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:45</span>
</div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

<div>
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>
</div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>









<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




    <div id="pjax">
  

  

  


    </div>
</body>
</html>

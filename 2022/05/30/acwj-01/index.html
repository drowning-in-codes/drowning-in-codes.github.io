<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"0F9LEEVW82","apiKey":"78839e9f9be09d081c5c4da81975cd19","indexName":"sekyoblog_sec","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content=继续之前的写编译器. name=description><meta content=article property=og:type><meta content=acwj_01 property=og:title><meta content=https://www.sekyoro.top/2022/05/30/acwj-01/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content=继续之前的写编译器. property=og:description><meta content=zh_CN property=og:locale><meta content=http://cdn.sekyoro.top/imgs/if_stme.png property=og:image><meta content=2022-05-30T11:20:51.000Z property=article:published_time><meta content=2022-06-28T15:06:30.000Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content=compiler property=article:tag><meta content=summary name=twitter:card><meta content=http://cdn.sekyoro.top/imgs/if_stme.png name=twitter:image><link href=https://www.sekyoro.top/2022/05/30/acwj-01/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>acwj_01 | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2022/05/30/acwj-01/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>acwj_01</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2022-05-30 19:20:51" datetime=2022-05-30T19:20:51+08:00>2022-05-30</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2022-06-28 23:06:30" datetime=2022-06-28T23:06:30+08:00 itemprop=dateModified>2022-06-28</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>19k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>18 分钟</span> </span></div></header><div class=post-body itemprop=articleBody><p>继续之前的写编译器.<br><span id=more></span><p><a href=https://github.com/DoctorWkt/acwj rel=noopener target=_blank>教程地址</a><p>acwj意思是A Compiler Writing Journey.<p>之前写了scan和parser,简单的过了加减乘除的操作.<h3 id=操作符优先级><a class=headerlink href=#操作符优先级 title=操作符优先级></a>操作符优先级</h3><p>现在需要定一下操作符优先级.有两种办法,都是递归下降方法<ol><li><p>在语言语法中明确运算符优先级</p><li><p>使用运算符优先级表影响现有解析器</p></ol><p>这里采用改变语法的方法<figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line>expression: additive<span class=built_in>_</span>expression</span><br><span class=line>    ;</span><br><span class=line></span><br><span class=line>additive<span class=built_in>_</span>expression:</span><br><span class=line>      multiplicative<span class=built_in>_</span>expression</span><br><span class=line>    | additive<span class=built_in>_</span>expression '+' multiplicative<span class=built_in>_</span>expression</span><br><span class=line>    | additive<span class=built_in>_</span>expression '-' multiplicative<span class=built_in>_</span>expression</span><br><span class=line>    ;</span><br><span class=line></span><br><span class=line>multiplicative<span class=built_in>_</span>expression:</span><br><span class=line>      number</span><br><span class=line>    | number '*' multiplicative<span class=built_in>_</span>expression</span><br><span class=line>    | number '/' multiplicative<span class=built_in>_</span>expression</span><br><span class=line>    ;</span><br><span class=line></span><br><span class=line>number:  T<span class=built_in>_</span>INTLIT</span><br><span class=line>         ;</span><br></pre></table></figure><p>可以看到先进行乘再进行加.<p>在代码中,定义乘除函数与加减函数.<p>加减法优先级较低,所以在加减函数中需要调用乘除函数.而乘除函数自然需要调用primary,这里就是取字面量的意思.<p>乘除函数核心代码.<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line></span><br><span class=line>left = primary(); <span class=comment>//取值 primary中也有scan.</span></span><br><span class=line></span><br><span class=line>  tokentype = Token.token; <span class=comment>//更新tokentype</span></span><br><span class=line>  <span class=keyword>if</span> (tokentype == _EOF) <span class=comment>//若读到末尾则直接返回.</span></span><br><span class=line>  {</span><br><span class=line>    <span class=keyword>return</span> left;</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=comment>// * /</span></span><br><span class=line>	<span class=comment>//如果有乘除号 进入循环</span></span><br><span class=line>  <span class=keyword>while</span> (tokentype == STAR || tokentype == SLASH)</span><br><span class=line>  {</span><br><span class=line>      <span class=comment>//继续得到右边的值</span></span><br><span class=line>    scan(&Token);</span><br><span class=line>      </span><br><span class=line>    right = primary(); <span class=comment>//获取intlitnode,right是一个leaf node.</span></span><br><span class=line></span><br><span class=line>    <span class=comment>// e.g  * 2 6</span></span><br><span class=line>    left = mkastnode(tok2aop(tokentype), left, right, <span class=number>0</span>); <span class=comment>//e.g * 2 5</span></span><br><span class=line></span><br><span class=line>    <span class=comment>// Update the details of the current token.</span></span><br><span class=line>    <span class=comment>// If no tokens left, return just the left node</span></span><br><span class=line>    tokentype = Token.token; <span class=comment>//更新</span></span><br><span class=line>    <span class=keyword>if</span> (tokentype == _EOF)</span><br><span class=line>    {</span><br><span class=line>      <span class=keyword>break</span>;</span><br><span class=line>    } <span class=comment>//看是否读到文件末尾 否则继续读 直到不是乘除号</span></span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=keyword>return</span> left;</span><br></pre></table></figure><p>加减函数<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line>left = multiplicative_expr(); <span class=comment>//首先需要调用乘除 优先级问题</span></span><br><span class=line>  tokentype = Token.token;</span><br><span class=line>  <span class=keyword>if</span>(tokentype == _EOF)</span><br><span class=line>  {</span><br><span class=line>    <span class=keyword>return</span> left;</span><br><span class=line>  }</span><br><span class=line><span class=comment>//同上</span></span><br><span class=line></span><br><span class=line></span><br><span class=line>  <span class=keyword>while</span> (<span class=number>1</span>) <span class=comment>//进入循环</span></span><br><span class=line>  {</span><br><span class=line>    scan(&Token);</span><br><span class=line></span><br><span class=line>    right = multiplicative_expr();  <span class=comment>//同理 先调用乘除</span></span><br><span class=line></span><br><span class=line>    left = mkastnode(tok2aop(tokentype),left,right,<span class=number>0</span>); <span class=comment>// left = left + right</span></span><br><span class=line>    tokentype = Token.token;</span><br><span class=line>    <span class=keyword>if</span>(tokentype == _EOF)</span><br><span class=line>    {</span><br><span class=line>      <span class=keyword>break</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>  }  </span><br><span class=line>  <span class=keyword>return</span> left;</span><br><span class=line></span><br></pre></table></figure><p>这种方法缺点是需要为每种运算设置谁优先级高,比较麻烦.<p>还可以用Pratt Parsing.<p>也就是为每一种操作符设置一个优先级值.<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line>left = primary();</span><br><span class=line></span><br><span class=line>  <span class=comment>// If no tokens left, return just the left node</span></span><br><span class=line>  tokentype = Token.token;</span><br><span class=line>  <span class=keyword>if</span> (tokentype == T_EOF)</span><br><span class=line>    <span class=keyword>return</span> (left);</span><br><span class=line></span><br><span class=line>  <span class=comment>// While the precedence of this token is</span></span><br><span class=line>  <span class=comment>// more than that of the previous token precedence</span></span><br><span class=line>  <span class=keyword>while</span> (op_precedence(tokentype) > ptp) {</span><br><span class=line>    <span class=comment>// Fetch in the next integer literal</span></span><br><span class=line>    scan(&Token);</span><br><span class=line></span><br><span class=line>    <span class=comment>// Recursively call binexpr() with the</span></span><br><span class=line>    <span class=comment>// precedence of our token to build a sub-tree</span></span><br><span class=line>    right = binexpr(OpPrec[tokentype]);</span><br><span class=line></span><br><span class=line>    <span class=comment>// Join that sub-tree with ours. Convert the token</span></span><br><span class=line>    <span class=comment>// into an AST operation at the same time.</span></span><br><span class=line>    left = mkastnode(arithop(tokentype), left, right, <span class=number>0</span>);</span><br><span class=line></span><br><span class=line>    <span class=comment>// Update the details of the current token.</span></span><br><span class=line>    <span class=comment>// If no tokens left, return just the left node</span></span><br><span class=line>    tokentype = Token.token;</span><br><span class=line>    <span class=keyword>if</span> (tokentype == T_EOF)</span><br><span class=line>      <span class=keyword>return</span> (left);</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=comment>// Return the tree we have when the precedence</span></span><br><span class=line>  <span class=comment>// is the same or lower</span></span><br><span class=line>  <span class=keyword>return</span> (left);</span><br></pre></table></figure><h3 id=生成汇编><a class=headerlink href=#生成汇编 title=生成汇编></a>生成汇编</h3><p>尝试生成汇编代码.<p>生成汇编也是遍历AST.<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>void</span> <span class=title>generatecode</span><span class=params>(struct ASTnode *n)</span> </span>{</span><br><span class=line>  <span class=keyword>int</span> reg;</span><br><span class=line></span><br><span class=line>  cgpreamble();</span><br><span class=line>  reg= genAST(n);</span><br><span class=line>  cgprintint(reg);      <span class=comment>// Print the register with the result as an int</span></span><br><span class=line>  cgpostamble();</span><br><span class=line>}</span><br></pre></table></figure><p>pre和post是汇编进出main的一般语句.同时为了打印寄存器的值使用了printint函数也在汇编pre中声明了.<p>另外有free,allocate寄存器。先free使寄存器值为1,再allocate使用,由置为0.allocate后又能free.<p>当然还有一些运算的汇编代码,比如<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>cgmul</span><span class=params>(<span class=keyword>int</span> r1,<span class=keyword>int</span> r2)</span> </span>{</span><br><span class=line>  <span class=built_in>fprintf</span>(Outfile,<span class=string>"\timulq\t%s,%s\n"</span>,reglist[r1],reglist[r2]);</span><br><span class=line>  free_reg(r1);</span><br><span class=line>  <span class=keyword>return</span> r2;</span><br><span class=line>}</span><br></pre></table></figure><p>减法,除法需要注意顺序.<p>注意除法相对麻烦<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=built_in>fprintf</span>(Outfile, <span class=string>"\tmovq\t%s,%%rax\n"</span>, reglist[r1]);</span><br><span class=line>  <span class=built_in>fprintf</span>(Outfile, <span class=string>"\tcqo\n"</span>);</span><br><span class=line>  <span class=built_in>fprintf</span>(Outfile, <span class=string>"\tidivq\t%s\n"</span>, reglist[r2]);</span><br><span class=line>  <span class=built_in>fprintf</span>(Outfile, <span class=string>"\tmovq\t%%rax,%s\n"</span>, reglist[r1]);</span><br></pre></table></figure><blockquote><p>Division is also not commutative, so the previous notes apply. On the x86-64, it’s even more complicated. We need to load <code>%rax</code> with the <em>dividend</em> from <code>r1</code>. This needs to be extended to eight bytes with <code>cqo</code>. Then, <code>idivq</code> will divide <code>%rax</code> with the divisor in <code>r2</code>, leaving the <em>quotient</em> in <code>%rax</code>, so we need to copy it out to either <code>r1</code> or <code>r2</code>. Then we can free the other register.</blockquote><h3 id=增加一些语句><a class=headerlink href=#增加一些语句 title=增加一些语句></a>增加一些语句</h3><p>之前词法语法分析都是一些运算符,现在增加一些Statement.<figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>statements: statement</span><br><span class=line>     | statement statements</span><br><span class=line>     ;</span><br><span class=line></span><br><span class=line>statement: 'print' expression ';'</span><br><span class=line>     ;</span><br></pre></table></figure><p>先只有print语句<blockquote><p>An input file consists of several statements. They are either one statement, or a statement followed by more statements. Each statement starts with the keyword <code>print</code>, then one expression, then a semicolon.</blockquote><p>statement语句是print后接binexpr再有一个分号<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>ASTnode</span> *<span class=title>tree</span>;</span></span><br><span class=line></span><br><span class=line>  <span class=keyword>int</span> reg;</span><br><span class=line>  <span class=keyword>while</span> (<span class=number>1</span>)</span><br><span class=line>  {</span><br><span class=line>    <span class=comment>// match print</span></span><br><span class=line>    match(PRINT, <span class=string>"print"</span>);</span><br><span class=line></span><br><span class=line>    tree = binexpr(<span class=number>0</span>);  <span class=comment>// expr ast</span></span><br><span class=line>    reg = genAST(tree); <span class=comment>// return reg num</span></span><br><span class=line></span><br><span class=line>    <span class=comment>// print value</span></span><br><span class=line>    genprintint(reg);</span><br><span class=line>    genfreeregs();</span><br><span class=line></span><br><span class=line>    semi();</span><br><span class=line>    <span class=comment>// 之前卡在这 因为 == 写成了 = :(</span></span><br><span class=line>    <span class=comment>// 判断到达文件尾 </span></span><br><span class=line>    <span class=keyword>if</span> (Token.token == _EOF)</span><br><span class=line>    {</span><br><span class=line>      <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line>  }</span><br></pre></table></figure><p>之前写了binexpr,根据这个生成AST再遍历得到值.<p>此外还要判定identifier,以字母或_开头<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>if</span> (<span class=built_in>isalpha</span>(c) || <span class=string>'_'</span> == c)</span><br><span class=line>    {</span><br><span class=line>      <span class=comment>// read ident</span></span><br><span class=line>      scanident(c, Text, TEXTLEN);</span><br><span class=line></span><br><span class=line>      <span class=comment>// ! focus,it's =</span></span><br><span class=line>      <span class=keyword>if</span> (tokentype = keyword(Text))</span><br><span class=line>      {</span><br><span class=line>        t->token = tokentype;</span><br><span class=line>        <span class=keyword>break</span>;</span><br><span class=line>      }</span><br><span class=line>      <span class=comment>// if this is not keyword</span></span><br><span class=line>      <span class=built_in>printf</span>(<span class=string>"Unrecognised symbol %s on line %d\n"</span>, Text, Line);</span><br><span class=line>    }</span><br></pre></table></figure><p>如果是关键字,设置toke类型.<p>此外还要设置匹配关键字<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=comment>// 匹配</span></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>match</span><span class=params>(<span class=keyword>int</span> t, <span class=keyword>char</span> *what)</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>  <span class=keyword>if</span> (Token.token == t)</span><br><span class=line>  {</span><br><span class=line>    scan(&Token);</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>else</span></span><br><span class=line>  {</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"%s expected on line %d\n"</span>, what, Line);</span><br><span class=line>    <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>  }</span><br><span class=line>}</span><br></pre></table></figure><p>*what是需要匹配的关键字,t是token的类型,比如PRINT.<p>当匹配成功继续读入下一个字符.<p>读入ident<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=keyword>int</span> i = <span class=number>0</span>;</span><br><span class=line></span><br><span class=line>  <span class=keyword>while</span> (<span class=built_in>isalpha</span>(c) || <span class=built_in>isdigit</span>(c) || <span class=string>'_'</span> == c)</span><br><span class=line>  {</span><br><span class=line>    <span class=comment>// Error if we hit the identifier length limit,</span></span><br><span class=line>    <span class=comment>// else append to buf[] and get next character</span></span><br><span class=line></span><br><span class=line>    <span class=comment>// lim is the identifier max length that we defined</span></span><br><span class=line>    <span class=keyword>if</span> (lim - <span class=number>1</span> == i)</span><br><span class=line>    {</span><br><span class=line>      <span class=built_in>printf</span>(<span class=string>"identifier too long on line %d\n"</span>, Line);</span><br><span class=line>      <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>else</span> <span class=keyword>if</span> (i < lim - <span class=number>1</span>)</span><br><span class=line>    {</span><br><span class=line>      buf[i++] = c;</span><br><span class=line>    }</span><br><span class=line>    c = next();</span><br><span class=line>  }</span><br><span class=line>  <span class=comment>// c is not included in this ident so we trace back</span></span><br><span class=line>  putback(c);</span><br><span class=line>  buf[i] = <span class=string>'\0'</span>;</span><br><span class=line>  <span class=keyword>return</span> i;</span><br></pre></table></figure><p>当匹配首字符后,读入ident,限定ident大小.同时当读入的token不满足条件时跳出,并将其putback.方便下次读入.<p>同时在expr中改为遇到分号就结束,而不是文件尾.<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line>left = primary();</span><br><span class=line></span><br><span class=line> tokentype = Token.token;</span><br><span class=line> <span class=keyword>if</span> (tokentype == SEMI)</span><br><span class=line> {</span><br><span class=line>   <span class=keyword>return</span> left;</span><br><span class=line> }</span><br><span class=line></span><br><span class=line> <span class=comment>// While the precedence of this token is</span></span><br><span class=line> <span class=comment>// more than that of the previous token precedence</span></span><br><span class=line> <span class=keyword>while</span> (op_precedence(tokentype) > ptp)</span><br><span class=line> {</span><br><span class=line>   scan(&Token);</span><br><span class=line></span><br><span class=line>   right = binexpr(OpPrec[tokentype]);</span><br><span class=line></span><br><span class=line>   left = mkastnode(tok2aop(tokentype), left, right, <span class=number>0</span>);</span><br><span class=line></span><br><span class=line>   <span class=comment>// Update the details of the current token.</span></span><br><span class=line>   <span class=comment>// If no tokens left, return just the left node</span></span><br><span class=line>   tokentype = Token.token;</span><br><span class=line>   <span class=keyword>if</span> (tokentype == SEMI)</span><br><span class=line>     <span class=keyword>return</span> (left);</span><br><span class=line> }</span><br><span class=line></span><br><span class=line> <span class=keyword>return</span> left;</span><br></pre></table></figure><h3 id=变量><a class=headerlink href=#变量 title=变量></a>变量</h3><p>我们需要<ul><li>Declare variables<li>Use variables to get stored values<li>Assign to variables</ul><p>需要一个全局变量表<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>// Symbol table structure</span></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>symtable</span> {</span></span><br><span class=line>  <span class=keyword>char</span> *name;                   <span class=comment>// Name of a symbol</span></span><br><span class=line>};</span><br></pre></table></figure><p>变量表<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>define</span> NSYMBOLS        1024            <span class=comment>// Number of symbol table entries 最多几个变量</span></span></span><br><span class=line>extern_ <span class=class><span class=keyword>struct</span> <span class=title>symtable</span> <span class=title>Gsym</span>[<span class=title>NSYMBOLS</span>];</span> <span class=comment>// Global symbol table 变量表</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>int</span> Globs = <span class=number>0</span>;                   <span class=comment>// Position of next free global symbol slot 变量在变量表中位置</span></span><br></pre></table></figure><blockquote><ul><li><code>int findglob(char *s)</code>: Determine if the symbol s is in the global symbol table. Return its slot position or -1 if not found.<li><code>static int newglob(void)</code>: Get the position of a new global symbol slot, or die if we’ve run out of positions.<li><code>int addglob(char *name)</code>: Add a global symbol to the symbol table. Return the slot number in the symbol table</ul></blockquote><p>同时需要新的语法<figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>statements: statement</span><br><span class=line>     |      statement statements</span><br><span class=line>     ;</span><br><span class=line></span><br><span class=line>statement: 'print' expression ';'</span><br><span class=line>     |     'int'   identifier ';'</span><br><span class=line>     |     identifier '=' expression ';'</span><br><span class=line>     ;</span><br><span class=line></span><br><span class=line>identifier: T<span class=built_in>_</span>IDENT</span><br><span class=line>     ;</span><br></pre></table></figure><p>statementes需要更改<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=comment>// Parse one or more statements</span></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>statements</span><span class=params>(<span class=keyword>void</span>)</span> </span>{</span><br><span class=line></span><br><span class=line>  <span class=keyword>while</span> (<span class=number>1</span>) {</span><br><span class=line>    <span class=keyword>switch</span> (Token.token) {</span><br><span class=line>    <span class=keyword>case</span> T_PRINT:</span><br><span class=line>      print_statement();</span><br><span class=line>      <span class=keyword>break</span>;</span><br><span class=line>    <span class=keyword>case</span> T_INT:</span><br><span class=line>      var_declaration();</span><br><span class=line>      <span class=keyword>break</span>;</span><br><span class=line>    <span class=keyword>case</span> T_IDENT:</span><br><span class=line>      assignment_statement();</span><br><span class=line>      <span class=keyword>break</span>;</span><br><span class=line>    <span class=keyword>case</span> T_EOF:</span><br><span class=line>      <span class=keyword>return</span>;</span><br><span class=line>    <span class=keyword>default</span>:</span><br><span class=line>      fatald(<span class=string>"Syntax error, token"</span>, Token.token);</span><br><span class=line>    }</span><br><span class=line>  }</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>we will make the expression the left sub-tree of the A_ASSIGN node and save the A_LVIDENT details in the right sub-tree. Why? Because we need to evaluate the expression <em>before</em> we save it into the variable.<p>Note that we evaluate the left-hand AST child first, and we get back a register number that holds the left-hand sub-tree’s value. We now pass this register number to the right-hand sub-tree. We need to do this for A_LVIDENT nodes, so that the <code>cgstorglob()</code> function in <code>cg.c</code> knows which register holds the rvalue result of the assignment expression.</blockquote><p>这里左右是反的,由于我们是先序遍历AST,但又需要先计算右值,所以在赋值语句中,先读入identifier,创建LVIDENT节点赋值给rightreg,然后为leftreg创建expr,最后生成赋值节点.<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=comment>// identifier '=' expression ';'</span></span><br><span class=line> <span class=class><span class=keyword>struct</span> <span class=title>ASTnode</span> *<span class=title>left</span>, *<span class=title>right</span>, *<span class=title>tree</span>;</span></span><br><span class=line></span><br><span class=line> <span class=comment>// pos of reg</span></span><br><span class=line> <span class=keyword>int</span> id;</span><br><span class=line></span><br><span class=line> ident();</span><br><span class=line></span><br><span class=line> <span class=keyword>if</span> ((id = findglob(Text)) == <span class=number>-1</span>)</span><br><span class=line> {</span><br><span class=line>   fatals(<span class=string>"Undeclared variable"</span>, Text);</span><br><span class=line> }</span><br><span class=line></span><br><span class=line> right = mkastleaf(A_LVIDENT, id);</span><br><span class=line></span><br><span class=line> match(EQUAL, <span class=string>"="</span>);</span><br><span class=line></span><br><span class=line> <span class=comment>// Parse the following expression</span></span><br><span class=line> left = binexpr(<span class=number>0</span>);</span><br><span class=line></span><br><span class=line> <span class=comment>// Make an assignment AST tree</span></span><br><span class=line> tree = mkastnode(A_ASSIGN, left, right, <span class=number>0</span>);</span><br><span class=line></span><br><span class=line> <span class=comment>// Generate the assembly code for the assignment</span></span><br><span class=line> genAST(tree, <span class=number>-1</span>);</span><br><span class=line> genfreeregs();</span><br><span class=line></span><br><span class=line> semi();</span><br></pre></table></figure><blockquote><p>Also note that the AST leaf node that <em>retrieves</em> a variable’s value is an A_IDENT node. The leaf that saves into a variable is an A_LVIDENT node. This is the difference between <em>rvalues</em> and <em>lvalues</em>.</blockquote><h3 id=比较符><a class=headerlink href=#比较符 title=比较符></a>比较符</h3><p>增加词法分析,增加genAST操作.<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>case</span> A_EQ:</span><br><span class=line>    <span class=keyword>return</span> cgequal(leftreg,rightreg);</span><br><span class=line>  <span class=keyword>case</span> A_NE:</span><br><span class=line>    <span class=keyword>return</span> cgnotequal(leftreg,rightreg);</span><br><span class=line>  <span class=keyword>case</span> A_LT:</span><br><span class=line>    <span class=keyword>return</span> cglessthan(leftreg,rightreg);</span><br><span class=line>  <span class=keyword>case</span> A_GT:</span><br><span class=line>    <span class=keyword>return</span> cggreaterthan(leftreg,rightreg);</span><br><span class=line>  <span class=keyword>case</span> A_LE:</span><br><span class=line>    <span class=keyword>return</span> cglessequal(leftreg,rightreg);</span><br><span class=line>  <span class=keyword>case</span> A_GE:</span><br><span class=line>    <span class=keyword>return</span> cggreaterequal(leftreg,rightreg);</span><br><span class=line>  <span class=keyword>default</span>:</span><br><span class=line>    fatald(<span class=string>"Unknown AST operator"</span>,n->op);</span><br><span class=line>  }</span><br></pre></table></figure><p>遇到的问题<blockquote><p>There are six x86-64 instructions which set a register to 1 or 0 based on the two flag values: <code>sete</code>, <code>setne</code>, <code>setg</code>, <code>setl</code>, <code>setge</code> and <code>setle</code> in the order of the above table rows.<p>The problem is, these instructions only set the lowest byte of a register. If the register already has bits set outside of the lowest byte, they will stay set. So we might set a variable to 1, but if it already has the value 1000 (decimal), then it will now be 1001 which is not what we want.</blockquote><p>The solution is to <code>andq</code> the register after the <code>setX</code> instruction to get rid of the unwanted bits. In <code>cg.c</code> there is a general comparison function to do this:<p>核心代码<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=built_in>fprintf</span>(Outfile,<span class=string>"\tcmpq\t%s,%s\n"</span>,reglist[r2],reglist[r1]);</span><br><span class=line><span class=built_in>fprintf</span>(Outfile,<span class=string>"\t%s\t%s\n"</span>,how,breglist[r2]);</span><br><span class=line>  <span class=comment>// 低字节与1相与 全设置为1 因为setx指令只设置低字节 高字节不变,所以需要将高字节清除</span></span><br><span class=line><span class=built_in>fprintf</span>(Outfile, <span class=string>"\tandq\t$255,%s\n"</span>, reglist[r2]);</span><br><span class=line>  </span><br><span class=line>free_reg(r1);</span><br><span class=line><span class=keyword>return</span> r2;</span><br></pre></table></figure><blockquote><p>Note that we perform<figure class="highlight apache"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attribute>cmpq</span> reglist[r<span class=number>2</span>], reglist[r<span class=number>1</span>]</span><br></pre></table></figure><p>because this is actually <code>reglist[r1] - reglist[r2]</code> which is what we really want.</blockquote><h3 id=if语句><a class=headerlink href=#if语句 title=if语句></a>if语句</h3><figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>if (condition is true) </span><br><span class=line>    perform this first block of code</span><br><span class=line>  else</span><br><span class=line>    perform this other block of code</span><br></pre></table></figure><p>使用比较运算符<figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>       perform the opposite comparison</span><br><span class=line>       jump to L1 if true</span><br><span class=line>       perform the first block of code</span><br><span class=line>       jump to L2</span><br><span class=line>L1:</span><br><span class=line>       perform the other block of code</span><br><span class=line>L2:</span><br></pre></table></figure><p>举一个例子<p>Right now, we output code to set a register based on a comparison, e.g.<figure class="highlight apache"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attribute>int</span> x; x= <span class=number>7</span> < <span class=number>9</span>;         From input<span class=number>04</span></span><br></pre></table></figure><p>becomes<figure class="highlight apache"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=attribute>movq</span>    $<span class=number>7</span>, %r<span class=number>8</span></span><br><span class=line><span class=attribute>movq</span>    $<span class=number>9</span>, %r<span class=number>9</span></span><br><span class=line><span class=attribute>cmpq</span>    %r<span class=number>9</span>, %r<span class=number>8</span></span><br><span class=line><span class=attribute>setl</span>    %r<span class=number>9</span>b        Set if less than </span><br><span class=line><span class=attribute>andq</span>    $<span class=number>255</span>,%r<span class=number>9</span></span><br></pre></table></figure><p>But for an IF statement, we need to jump on the opposite comparison:<figure class="highlight apache"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attribute>if</span> (<span class=number>7</span> < <span class=number>9</span>) </span><br></pre></table></figure><p>should become:<figure class="highlight xquery"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>        movq    <span class=variable>$7</span>, <span class=meta>%r8</span></span><br><span class=line>        movq    <span class=variable>$9</span>, <span class=meta>%r9</span></span><br><span class=line>        cmpq    <span class=meta>%r9</span>, <span class=meta>%r8</span></span><br><span class=line>        jge     L1         Jump <span class=keyword>if</span> greater <span class=keyword>then</span> <span class=keyword>or</span> equal <span class=keyword>to</span></span><br><span class=line>        ....</span><br><span class=line>L1:</span><br></pre></table></figure><p>文法<figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line>compound<span class=built_in>_</span>statement: '{' '}'          // empty, i.e. no statement</span><br><span class=line>     |      '{' statement '}'</span><br><span class=line>     |      '{' statement statements '}'</span><br><span class=line>     ;</span><br><span class=line></span><br><span class=line>statement: print<span class=built_in>_</span>statement</span><br><span class=line>     |     declaration</span><br><span class=line>     |     assignment<span class=built_in>_</span>statement</span><br><span class=line>     |     if<span class=built_in>_</span>statement</span><br><span class=line>     ;</span><br><span class=line></span><br><span class=line>print<span class=built_in>_</span>statement: 'print' expression ';'  ;</span><br><span class=line></span><br><span class=line>declaration: 'int' identifier ';'  ;</span><br><span class=line></span><br><span class=line>assignment<span class=built_in>_</span>statement: identifier '=' expression ';'   ;</span><br><span class=line></span><br><span class=line>if<span class=built_in>_</span>statement: if<span class=built_in>_</span>head</span><br><span class=line>     |        if<span class=built_in>_</span>head 'else' compound<span class=built_in>_</span>statement</span><br><span class=line>     ;</span><br><span class=line></span><br><span class=line>if<span class=built_in>_</span>head: 'if' '(' true<span class=built_in>_</span>false<span class=built_in>_</span>expression ')' compound<span class=built_in>_</span>statement  ;</span><br><span class=line></span><br><span class=line>identifier: T<span class=built_in>_</span>IDENT ;</span><br></pre></table></figure><blockquote><p>Note the grammar for the IF statement: it’s either an <code>if_head</code> (with no ‘else’ clause), or an <code>if_head</code> followed by a ‘else’ and a <code>compound_statement</code>.</blockquote><p>解决悬挂else问题<p>if ast 修改ast结构以适应if<ul><li>the sub-tree that evaluates the condition<li>the compound statement immediately following<li>the optional compound statement after the ‘else’ keyword</ul><p><img alt=if_stme data-src=http://cdn.sekyoro.top/imgs/if_stme.png style=zoom:67%;><h3 id=实现while循环><a class=headerlink href=#实现while循环 title=实现while循环></a>实现while循环</h3><figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>Lstart: evaluate condition</span><br><span class=line>	jump to Lend if condition false</span><br><span class=line>	statements</span><br><span class=line>	jump to Lstart</span><br><span class=line>Lend:</span><br></pre></table></figure><p>while的BNF<figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>// while<span class=built_in>_</span>statement: 'while' '(' true<span class=built_in>_</span>false<span class=built_in>_</span>expression ')' compound<span class=built_in>_</span>statement  ;</span><br></pre></table></figure><p>说实话做起来要比if简单些,主要是在if中实现了添加label和跳转的x86汇编.后面直接做词法语法分析就行了.<p>词法分析<p>while_stmt<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=function>struct ASTnode *<span class=title>while_stmt</span><span class=params>(<span class=keyword>void</span>)</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>  <span class=class><span class=keyword>struct</span> <span class=title>ASTnode</span> *<span class=title>condAST</span>, *<span class=title>bodyAST</span>;</span></span><br><span class=line></span><br><span class=line>  <span class=comment>// match while(</span></span><br><span class=line>  match(WHILE, <span class=string>"while"</span>);</span><br><span class=line>  lparen();</span><br><span class=line></span><br><span class=line>  condAST = binexpr(<span class=number>0</span>);</span><br><span class=line>  <span class=keyword>if</span> (condAST->op < A_EQ || condAST->op > A_GE)</span><br><span class=line>  {</span><br><span class=line>    fatal(<span class=string>"Bad comparison operator"</span>);</span><br><span class=line>  }</span><br><span class=line>  rparen();</span><br><span class=line></span><br><span class=line>  <span class=comment>// get the ast for com_stmt</span></span><br><span class=line>  bodyAST = compound_stmt();</span><br><span class=line></span><br><span class=line>  <span class=keyword>return</span> mkastnode(A_WHILE, condAST, <span class=literal>NULL</span>, bodyAST, <span class=number>0</span>);</span><br><span class=line>}</span><br></pre></table></figure><p>gen.c<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>static</span> <span class=keyword>int</span>  <span class=title>genWHILE</span><span class=params>(struct ASTnode *n)</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>  <span class=keyword>int</span> Lstart, Lend;</span><br><span class=line></span><br><span class=line>  <span class=comment>// get label</span></span><br><span class=line>  Lstart = label();</span><br><span class=line>  Lend = label();</span><br><span class=line></span><br><span class=line>  <span class=comment>// generate label</span></span><br><span class=line>  cglabel(Lstart);</span><br><span class=line></span><br><span class=line>  <span class=comment>// 与if类似 计算n->left 满足条件跳转</span></span><br><span class=line>  genAST(n->left, Lend, n->op);</span><br><span class=line>  genfreeregs();</span><br><span class=line></span><br><span class=line>  <span class=comment>// compound stmt</span></span><br><span class=line>  genAST(n->right, NOREG, n->op);</span><br><span class=line>  genfreeregs();</span><br><span class=line></span><br><span class=line>  <span class=comment>// Finally output the jump back to the condition,</span></span><br><span class=line>  <span class=comment>// and the end label</span></span><br><span class=line>  <span class=comment>// 继续跳回去计算</span></span><br><span class=line>  cgjump(Lstart);</span><br><span class=line></span><br><span class=line>  cglabel(Lend);</span><br><span class=line></span><br><span class=line>  <span class=keyword>return</span> NOREG;</span><br><span class=line>}</span><br></pre></table></figure><h3 id=for循环><a class=headerlink href=#for循环 title=for循环></a>for循环</h3><p>BNF范式<figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>for<span class=built_in>_</span>statement: 'for' '(' preop<span class=built_in>_</span>statement ';'</span><br><span class=line>                          true<span class=built_in>_</span>false<span class=built_in>_</span>expression ';'</span><br><span class=line>                          postop<span class=built_in>_</span>statement ')' compound<span class=built_in>_</span>statement  ;</span><br><span class=line></span><br><span class=line> preop<span class=built_in>_</span>statement:  statement  ;        (for now)</span><br><span class=line> postop<span class=built_in>_</span>statement: statement  ;        (for now)</span><br></pre></table></figure><p>遇到的问题<blockquote><p>The wrinkle is that the <code>postop_statement</code> is parsed before the <code>compound_statement</code>, but we have to generate the code for the <code>postop_statement</code> <em>after</em> the code for the <code>compound_statement</code>.</blockquote><p>解决<blockquote><p>There are several ways to solve this problem. When I wrote a previous compiler, I chose to put the <code>compound_statement</code> assembly code in a temporary buffer, and “play back” the buffer once I’d generated the code for the <code>postop_statement</code>. In the SubC compiler, Nils makes clever use of labels and jumps to labels to “thread” the code’s execution to enforce the correct sequence.</blockquote><figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>preop<span class=built_in>_</span>statement;</span><br><span class=line> while ( true<span class=built_in>_</span>false<span class=built_in>_</span>expression ) {</span><br><span class=line>   compound<span class=built_in>_</span>statement;</span><br><span class=line>   postop<span class=built_in>_</span>statement;</span><br><span class=line> }</span><br></pre></table></figure><p>ast仍采用三节点<figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>    A<span class=built_in>_</span>GLUE</span><br><span class=line>     /     <span class=keyword>\</span></span><br><span class=line><span class=keyword></span>preop     A<span class=built_in>_</span>WHILE</span><br><span class=line>          /    <span class=keyword>\</span></span><br><span class=line><span class=keyword></span>     decision  A<span class=built_in>_</span>GLUE</span><br><span class=line>               /    <span class=keyword>\</span></span><br><span class=line><span class=keyword></span>         compound  postop</span><br></pre></table></figure><blockquote><p>For the FOR grammar, I only want a single statement as the <code>preop_statement</code> and the <code>postop_statement</code>. Right now, we have a <code>compound_statement()</code> function that simply loops until it hits a right curly bracket ‘}’. We need to separate this out so <code>compound_statement()</code> calls <code>single_statement()</code> to get one statement</blockquote><p>需要写一个single_stmt()<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>static</span> struct ASTnode *<span class=title>single_stmt</span><span class=params>(<span class=keyword>void</span>)</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line></span><br><span class=line>  <span class=keyword>switch</span> (Token.token)</span><br><span class=line>  {</span><br><span class=line>  <span class=keyword>case</span> PRINT:</span><br><span class=line>    <span class=keyword>return</span> print_stmt();</span><br><span class=line>    <span class=keyword>break</span>;</span><br><span class=line>  <span class=keyword>case</span> INT:</span><br><span class=line>    int_decl();</span><br><span class=line>    <span class=keyword>return</span> <span class=literal>NULL</span>;</span><br><span class=line>  <span class=keyword>case</span> IDENT:</span><br><span class=line>    <span class=keyword>return</span> assign_stmt();</span><br><span class=line>  <span class=keyword>case</span> IF:</span><br><span class=line>    <span class=keyword>return</span> if_stmt();</span><br><span class=line>  <span class=keyword>case</span> WHILE:</span><br><span class=line>    <span class=keyword>return</span> while_stmt();</span><br><span class=line>  <span class=keyword>case</span> FOR:</span><br><span class=line>    <span class=keyword>return</span> for_stmt();</span><br><span class=line>  <span class=keyword>default</span>:</span><br><span class=line>    fatald(<span class=string>"Syntax error, token"</span>, Token.token);</span><br><span class=line>  }</span><br><span class=line>}</span><br></pre></table></figure><p>这个不需要;<p>将assign和print语句的分号需求也去掉.<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br></pre><td class=code><pre><span class=line><span class=function>struct ASTnode *<span class=title>compound_stmt</span><span class=params>(<span class=keyword>void</span>)</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>  <span class=class><span class=keyword>struct</span> <span class=title>ASTnode</span> *<span class=title>left</span> =</span> <span class=literal>NULL</span>;</span><br><span class=line>  <span class=class><span class=keyword>struct</span> <span class=title>ASTnode</span> *<span class=title>tree</span>;</span></span><br><span class=line>  <span class=comment>// match {</span></span><br><span class=line>  lbrace();</span><br><span class=line></span><br><span class=line>  <span class=keyword>while</span> (<span class=number>1</span>)</span><br><span class=line>  {</span><br><span class=line></span><br><span class=line>    tree = single_stmt();</span><br><span class=line>    <span class=comment>// assign,print need simicon</span></span><br><span class=line>    <span class=keyword>if</span> (tree != <span class=literal>NULL</span> && (tree->op == A_PRINT || tree->op == A_ASSIGN))</span><br><span class=line>    {</span><br><span class=line>      semi();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// For each new tree, either save it in left</span></span><br><span class=line>    <span class=comment>// if left is empty, or glue the left and the</span></span><br><span class=line>    <span class=comment>// new tree together</span></span><br><span class=line>    <span class=keyword>if</span> (tree != <span class=literal>NULL</span>)</span><br><span class=line>    {</span><br><span class=line>      <span class=keyword>if</span> (left == <span class=literal>NULL</span>)</span><br><span class=line>      {</span><br><span class=line>        left = tree;</span><br><span class=line>      }</span><br><span class=line>      <span class=keyword>else</span></span><br><span class=line>      {</span><br><span class=line>        left = mkastnode(A_GLUE, left, <span class=literal>NULL</span>, tree, <span class=number>0</span>);</span><br><span class=line>      }</span><br><span class=line>    }</span><br><span class=line><span class=comment>// }</span></span><br><span class=line>    <span class=keyword>if</span> (Token.token == RBRACE)</span><br><span class=line>    {</span><br><span class=line>      rbrace();</span><br><span class=line>      <span class=keyword>return</span> left;</span><br><span class=line>    }</span><br><span class=line>  }</span><br><span class=line>}</span><br></pre></table></figure><p>在复合语句中对print和赋值语句的分号做要求.<blockquote><p>What we need is for the single statement parser <em>not</em> to scan in the semicolon, but to leave that up to the compound statement parser. And we scan in semicolons for some statements (e.g. between assignment statements) and not for other statements (e.g. not between successive IF statements).</blockquote><p>在生成ast时注意顺序<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment>// Glue the compound statement and the postop tree</span></span><br><span class=line>tree= mkastnode(A_GLUE, bodyAST, <span class=literal>NULL</span>, postopAST, <span class=number>0</span>);</span><br><span class=line></span><br><span class=line><span class=comment>// Make a WHILE loop with the condition and this new body</span></span><br><span class=line>tree= mkastnode(A_WHILE, condAST, <span class=literal>NULL</span>, tree, <span class=number>0</span>);</span><br><span class=line></span><br><span class=line><span class=comment>// And glue the preop tree to the A_WHILE tree</span></span><br><span class=line><span class=keyword>return</span>(mkastnode(A_GLUE, preopAST, <span class=literal>NULL</span>, tree, <span class=number>0</span>));</span><br></pre></table></figure><h3 id=实现函数><a class=headerlink href=#实现函数 title=实现函数></a>实现函数</h3><p>需要处理的部分<ul><li>Types of data: <code>char</code>, <code>int</code>, <code>long</code> etc.<li>The return type of each function<li>The number of arguments to each function<li>Variables local to a function versus global variables</ul><p>首先是简单部分<figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>function<span class=built_in>_</span>declaration: 'void' identifier '(' ')' compound<span class=built_in>_</span>statement   ;</span><br></pre></table></figure><p>即函数声明,与变量声明类似.<p>需要将函数名加入globsym.<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>match(T_VOID, <span class=string>"void"</span>);</span><br><span class=line>ident();</span><br><span class=line>nameslot= addglob(Text);</span><br><span class=line>lparen();</span><br><span class=line>rparen();</span><br><span class=line></span><br><span class=line><span class=comment>// Get the AST tree for the compound statement</span></span><br><span class=line>tree= compound_statement();</span><br><span class=line></span><br><span class=line><span class=comment>// Return an A_FUNCTION node which has the function's nameslot</span></span><br><span class=line><span class=comment>// and the compound statement sub-tree</span></span><br><span class=line><span class=keyword>return</span>(mkastunary(A_FUNCTION, tree, nameslot));</span><br></pre></table></figure><p>在main中修改<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>scan(&Token);                 <span class=comment>// Get the first token from the input</span></span><br><span class=line>genpreamble();                <span class=comment>// Output the preamble</span></span><br><span class=line><span class=keyword>while</span> (<span class=number>1</span>) {                   <span class=comment>// Parse a function and</span></span><br><span class=line>  tree = function_declaration();</span><br><span class=line>  genAST(tree, NOREG, <span class=number>0</span>);     <span class=comment>// generate the assembly code for it</span></span><br><span class=line>  <span class=keyword>if</span> (Token.token == T_EOF)   <span class=comment>// Stop when we have reached EOF</span></span><br><span class=line>    <span class=keyword>break</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>生成汇编<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>case</span> A_FUNCTION:</span><br><span class=line>    <span class=comment>// generate code</span></span><br><span class=line>    cgfuncpreamble(Gsym[n->v.id].name);</span><br><span class=line>    genAST(n->left, NOREG, n->op);</span><br><span class=line>    cgfuncpostamble();</span><br><span class=line>    <span class=keyword>return</span> NOREG;</span><br></pre></table></figure><h3 id=增加类型><a class=headerlink href=#增加类型 title=增加类型></a>增加类型</h3><p>增加char<p>every expression has a type. This includes:<ul><li>integer literals, e.g 56 is an <code>int</code><li>maths expressions, e.g. 45 - 12 is an <code>int</code><li>variables, e.g. if we declared <code>x</code> as a <code>char</code>, then it’s <em>rvalue</em> is a <code>char</code></ul><p>增加原型类型<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>// Primitive types</span></span><br><span class=line><span class=class><span class=keyword>enum</span> {</span></span><br><span class=line>  P_NONE, P_VOID, P_CHAR, P_INT</span><br><span class=line>};</span><br></pre></table></figure><p>现阶段,none修饰控制语句,void是函数符号,char,int是变量符号.<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>ASTnode</span> {</span></span><br><span class=line>  <span class=keyword>int</span> op;                       <span class=comment>// "Operation" to be performed on this tree</span></span><br><span class=line>  <span class=keyword>int</span> type;                     <span class=comment>// Type of any expression this tree generates</span></span><br><span class=line>  ...</span><br><span class=line>};</span><br></pre></table></figure><p>ast也有type,现在主要用于widen.<p>主要修改一些语句,比如primary<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br></pre><td class=code><pre><span class=line><span class=comment>// Parse a primary factor and return an</span></span><br><span class=line><span class=comment>// AST node representing it.</span></span><br><span class=line><span class=function><span class=keyword>static</span> struct ASTnode *<span class=title>primary</span><span class=params>(<span class=keyword>void</span>)</span> </span>{</span><br><span class=line>  <span class=class><span class=keyword>struct</span> <span class=title>ASTnode</span> *<span class=title>n</span>;</span></span><br><span class=line>  <span class=keyword>int</span> id;</span><br><span class=line></span><br><span class=line>  <span class=keyword>switch</span> (Token.token) {</span><br><span class=line>    <span class=keyword>case</span> T_INTLIT:</span><br><span class=line>      <span class=comment>// For an INTLIT token, make a leaf AST node for it.</span></span><br><span class=line>      <span class=comment>// Make it a P_CHAR if it's within the P_CHAR range</span></span><br><span class=line>      <span class=keyword>if</span> ((Token.intvalue) >= <span class=number>0</span> && (Token.intvalue < <span class=number>256</span>))</span><br><span class=line>        n = mkastleaf(A_INTLIT, P_CHAR, Token.intvalue);</span><br><span class=line>      <span class=keyword>else</span></span><br><span class=line>        n = mkastleaf(A_INTLIT, P_INT, Token.intvalue);</span><br><span class=line>      <span class=keyword>break</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>case</span> T_IDENT:</span><br><span class=line>      <span class=comment>// Check that this identifier exists</span></span><br><span class=line>      id = findglob(Text);</span><br><span class=line>      <span class=keyword>if</span> (id == <span class=number>-1</span>)</span><br><span class=line>        fatals(<span class=string>"Unknown variable"</span>, Text);</span><br><span class=line></span><br><span class=line>      <span class=comment>// Make a leaf AST node for it</span></span><br><span class=line>      n = mkastleaf(A_IDENT, Gsym[id].type, id);</span><br><span class=line>      <span class=keyword>break</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>default</span>:</span><br><span class=line>      fatald(<span class=string>"Syntax error, token"</span>, Token.token);</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=comment>// Scan in the next token and return the leaf node</span></span><br><span class=line>  scan(&Token);</span><br><span class=line>  <span class=keyword>return</span> (n);</span><br><span class=line>}</span><br></pre></table></figure><p>根据值看生成CHAR类型还是INT类型节点.<p>print语句<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>static</span> struct ASTnode *<span class=title>print_statement</span><span class=params>(<span class=keyword>void</span>)</span> </span>{</span><br><span class=line>  <span class=class><span class=keyword>struct</span> <span class=title>ASTnode</span> *<span class=title>tree</span>;</span></span><br><span class=line>  <span class=keyword>int</span> lefttype, righttype;</span><br><span class=line>  <span class=keyword>int</span> reg;</span><br><span class=line></span><br><span class=line>  ...</span><br><span class=line>  <span class=comment>// Parse the following expression</span></span><br><span class=line>  tree = binexpr(<span class=number>0</span>);</span><br><span class=line></span><br><span class=line>  <span class=comment>// Ensure the two types are compatible.</span></span><br><span class=line>  lefttype = P_INT; righttype = tree->type;</span><br><span class=line>  <span class=keyword>if</span> (!type_compatible(&lefttype, &righttype, <span class=number>0</span>))</span><br><span class=line>    fatal(<span class=string>"Incompatible types"</span>);</span><br><span class=line></span><br><span class=line>  <span class=comment>// Widen the tree if required. </span></span><br><span class=line>  <span class=keyword>if</span> (righttype) tree = mkastunary(righttype, P_INT, tree, <span class=number>0</span>);</span><br></pre></table></figure><p>print 后面要求是int(char其实也可以)<p>如果需要widen,则生成一个WIDEN节点,类型是int.<p>最后生成print节点,类型也是None.<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>tree = mkastunary(A_PRINT,P_NONE,tree,<span class=number>0</span>);</span><br></pre></table></figure><p>assign语句<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>static</span> struct ASTnode *<span class=title>assignment_statement</span><span class=params>(<span class=keyword>void</span>)</span> </span>{</span><br><span class=line>  <span class=class><span class=keyword>struct</span> <span class=title>ASTnode</span> *<span class=title>left</span>, *<span class=title>right</span>, *<span class=title>tree</span>;</span></span><br><span class=line>  <span class=keyword>int</span> lefttype, righttype;</span><br><span class=line>  <span class=keyword>int</span> id;</span><br><span class=line></span><br><span class=line>  ...</span><br><span class=line>  <span class=comment>// Make an lvalue node for the variable</span></span><br><span class=line>  right = mkastleaf(A_LVIDENT, Gsym[id].type, id);</span><br><span class=line></span><br><span class=line>  <span class=comment>// Parse the following expression</span></span><br><span class=line>  left = binexpr(<span class=number>0</span>);</span><br><span class=line></span><br><span class=line>  <span class=comment>// Ensure the two types are compatible.</span></span><br><span class=line>  lefttype = left->type;</span><br><span class=line>  righttype = right->type;</span><br><span class=line>  <span class=keyword>if</span> (!type_compatible(&lefttype, &righttype, <span class=number>1</span>))  <span class=comment>// Note the 1</span></span><br><span class=line>    fatal(<span class=string>"Incompatible types"</span>);</span><br><span class=line></span><br><span class=line>  <span class=comment>// Widen the left if required.</span></span><br><span class=line>  <span class=keyword>if</span> (lefttype)</span><br><span class=line>    left = mkastunary(lefttype, right->type, left, <span class=number>0</span>);</span><br></pre></table></figure><p>也是主要检查是否可以widen,而赋值语句只允许char widens to int.右值是char.<p>注意赋值语句中节点的right是左值,left是右值.所以onlyright设置为1<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>int</span> i;</span><br><span class=line>i = <span class=number>6</span>;</span><br></pre></table></figure><p>这里6其实是char类型,因为6处在char范围内,但是赋值语句生成widen节点,相当于<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>left = mkastunary(lefttype, right->type, left, <span class=number>0</span>);</span><br></pre></table></figure><p>op:WIDEN,type:int<p>最后返回赋值语句节点<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>tree = mkastnode(A_ASSIGN,P_INT,left,<span class=literal>NULL</span>,right,<span class=number>0</span>);</span><br></pre></table></figure><h3 id=更多函数><a class=headerlink href=#更多函数 title=更多函数></a>更多函数</h3><ul><li>define a function, which we already have,<li>call a function with a single value which for now cannot be used,<li>return a value from a function,<li>use a function call as both a statement and also an expression, and<li>ensure that void functions never return a value and non-void functions must return a value.</ul><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>function_call: identifier <span class=string>'('</span> expression <span class=string>')'</span>   ;</span><br></pre></table></figure><p>后面移植到了ARM下,在Linux上安装了gcc的arm版本,可以生成arm汇编生成可执行程序.安装qemu,执行arm程序.<h3 id=新的语法><a class=headerlink href=#新的语法 title=新的语法></a>新的语法</h3><figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line>global<span class=built_in>_</span>declarations : global<span class=built_in>_</span>declarations </span><br><span class=line>     | global<span class=built_in>_</span>declaration global<span class=built_in>_</span>declarations</span><br><span class=line>     ;</span><br><span class=line></span><br><span class=line>global<span class=built_in>_</span>declaration: function<span class=built_in>_</span>declaration | var<span class=built_in>_</span>declaration ;</span><br><span class=line></span><br><span class=line>function<span class=built_in>_</span>declaration: type identifier '(' ')' compound<span class=built_in>_</span>statement   ;</span><br><span class=line></span><br><span class=line>var<span class=built_in>_</span>declaration: type identifier<span class=built_in>_</span>list ';'  ;</span><br><span class=line></span><br><span class=line>type: type<span class=built_in>_</span>keyword opt<span class=built_in>_</span>pointer  ;</span><br><span class=line></span><br><span class=line>type<span class=built_in>_</span>keyword: 'void' | 'char' | 'int' | 'long'  ;</span><br><span class=line></span><br><span class=line>opt<span class=built_in>_</span>pointer: &LTempty> | '*' opt<span class=built_in>_</span>pointer  ;</span><br><span class=line></span><br><span class=line>identifier<span class=built_in>_</span>list: identifier | identifier ',' identifier<span class=built_in>_</span>list ;</span><br></pre></table></figure><p>Prefix Operators ‘*’ and ‘&’<p>With declarations out of the road, let’s now look at parsing expressions where ‘*’ and ‘&’ are operators that come before an expression. The BNF grammar looks like this:<figure class="highlight avrasm"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=symbol>prefix_expression:</span> primary</span><br><span class=line>    | <span class=string>'*'</span> prefix_expression</span><br><span class=line>    | <span class=string>'&'</span> prefix_expression</span><br><span class=line>    <span class=comment>;</span></span><br></pre></table></figure><h3 id=更多操作><a class=headerlink href=#更多操作 title=更多操作></a>更多操作</h3><div class=table-container><table><thead><tr><th>`<th><th>`<th>T_LOGOR<tbody><tr><td><code>&&</code><td>T_LOGAND<tr><td>`<td>`<td>T_OR<tr><td><code>^</code><td>T_XOR<tr><td><code><<</code><td>T_LSHIFT<tr><td><code>>></code><td>T_RSHIFT<tr><td><code>++</code><td>T_INC<tr><td><code>--</code><td>T_DEC<tr><td><code>~</code><td>T_INVERT<tr><td><code>!</code><td>T_LOGNO</table></div><p>增加全局变量与局部变量.<p>Type Checking and Pointer Offsets</p><link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script></div><div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div class=popular-posts-header>相关文章</div><ul class=popular-posts><li class=popular-posts-item><div class=popular-posts-title><a href=\2022\05\06\write-a-compiler-by-yourself\ rel=bookmark>write_a_compiler_by_yourself</a></div></ul><div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a href=https://www.sekyoro.top/2022/05/30/acwj-01/ title=acwj_01>https://www.sekyoro.top/2022/05/30/acwj-01/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div><footer class=post-footer><div class=post-tags><a href=/tags/compiler/ rel=tag><i class="fa fa-tag"></i> compiler</a></div><div class=post-nav><div class=post-nav-item><a href=/2022/05/06/write-a-compiler-by-yourself/ rel=prev title=write_a_compiler_by_yourself> <i class="fa fa-chevron-left"></i> write_a_compiler_by_yourself </a></div><div class=post-nav-item><a href=/2022/06/14/animeGAN/ rel=next title=animeGAN> animeGAN <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div><!-- 评论区 --><div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7><span class=nav-number>1.</span> <span class=nav-text>操作符优先级</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%94%9F%E6%88%90%E6%B1%87%E7%BC%96><span class=nav-number>2.</span> <span class=nav-text>生成汇编</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%BA%9B%E8%AF%AD%E5%8F%A5><span class=nav-number>3.</span> <span class=nav-text>增加一些语句</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8F%98%E9%87%8F><span class=nav-number>4.</span> <span class=nav-text>变量</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%AF%94%E8%BE%83%E7%AC%A6><span class=nav-number>5.</span> <span class=nav-text>比较符</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#if%E8%AF%AD%E5%8F%A5><span class=nav-number>6.</span> <span class=nav-text>if语句</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AE%9E%E7%8E%B0while%E5%BE%AA%E7%8E%AF><span class=nav-number>7.</span> <span class=nav-text>实现while循环</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#for%E5%BE%AA%E7%8E%AF><span class=nav-number>8.</span> <span class=nav-text>for循环</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0><span class=nav-number>9.</span> <span class=nav-text>实现函数</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A2%9E%E5%8A%A0%E7%B1%BB%E5%9E%8B><span class=nav-number>10.</span> <span class=nav-text>增加类型</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%9B%B4%E5%A4%9A%E5%87%BD%E6%95%B0><span class=nav-number>11.</span> <span class=nav-text>更多函数</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%96%B0%E7%9A%84%E8%AF%AD%E6%B3%95><span class=nav-number>12.</span> <span class=nav-text>新的语法</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%9B%B4%E5%A4%9A%E6%93%8D%E4%BD%9C><span class=nav-number>13.</span> <span class=nav-text>更多操作</span></a></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>251</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>16</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>218</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a><li class=links-of-blogroll-item><a href=https://www.lllomh.com/ rel=noopener target=_blank title=https://www.lllomh.com/>芈渡</a><li class=links-of-blogroll-item><a href=https://protool-ten.vercel.app/ rel=noopener target=_blank title=https://protool-ten.vercel.app/>protools</a></ul></div><div class="motion-element announcement"><div class=title></div><p class=content><p class=date></div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>文章词云</h3><div class="widget tagcloud" id=myCanvasContainer><canvas height=250 id=resCanvas style=width:100% width=250><ul class=tag-list itemprop=keywords><li class=tag-list-item><a class=tag-list-link href=/tags/compiler/ rel=tag>compiler</a><span class=tag-list-count>2</span></ul></canvas></div></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2025</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>3.6m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>54:15</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer></div><script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script><script src=/lib/anime.min.js></script><script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script><script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/pisces.js></script><script src=/js/next-boot.js></script><script src=/js/bookmark.js></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	'.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script><script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script><script src=/js/algolia-search.js></script><script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script><div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div><script charset=utf-8 defer src=/js/tagcanvas.js></script><script charset=utf-8 defer src=/js/tagcloud.js></script><script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script><script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script><script src=/js/src/activate-power-mode.min.js></script><script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script>
<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"0F9LEEVW82","apiKey":"78839e9f9be09d081c5c4da81975cd19","indexName":"sekyoblog_sec","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content=唉,很久没做做题了.这里记录一下每天刷题练习. name=description><meta content=article property=og:type><meta content=leetcode刷题记录 property=og:title><meta content=https://www.sekyoro.top/2022/11/11/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content=唉,很久没做做题了.这里记录一下每天刷题练习. property=og:description><meta content=zh_CN property=og:locale><meta content=http://cdn.sekyoro.top/imgs/26/1220221226173618.png property=og:image><meta content=https://s2.loli.net/2025/05/22/qgKPJS1vG8Br6WC.png property=og:image><meta content=https://noworneverev.github.io/leetcode_101/assets/images/13.1-8f62e3e9e89a8b86a7e3ded16599bba3.png property=og:image><meta content=2022-11-11T05:50:43.000Z property=article:published_time><meta content=2025-07-30T07:47:19.720Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content=leetcode property=article:tag><meta content=algorithm property=article:tag><meta content=summary name=twitter:card><meta content=http://cdn.sekyoro.top/imgs/26/1220221226173618.png name=twitter:image><link href=https://www.sekyoro.top/2022/11/11/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>leetcode刷题记录 | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2022/11/11/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>leetcode刷题记录</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2022-11-11 13:50:43" datetime=2022-11-11T13:50:43+08:00>2022-11-11</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-07-30 15:47:19" datetime=2025-07-30T15:47:19+08:00 itemprop=dateModified>2025-07-30</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>49k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>45 分钟</span> </span></div></header><div class=post-body itemprop=articleBody><div class=post-tags><a href=/tags/leetcode/ rel=tag># leetcode</a><a href=/tags/algorithm/ rel=tag># algorithm</a></div><p>唉,很久没做做题了.这里记录一下每天刷题练习.<br><span id=more></span><p>主要刷一些简单中等题,难了我也不会.<p>剑指Offer 启动<p><img style="zoom: 80%;" alt=image-20221226173618143 data-src=http://cdn.sekyoro.top/imgs/26/1220221226173618.png><p>09.用两个栈实现队列<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> 用两个栈实现队列;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.util.ArrayDeque;</span><br><span class=line><span class=keyword>import</span> java.util.Deque;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>CQueue2</span> </span>{</span><br><span class=line></span><br><span class=line>  Deque&LTInteger> inStack;</span><br><span class=line>  Deque&LTInteger> outStack;</span><br><span class=line></span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=title>CQueue2</span><span class=params>()</span> </span>{</span><br><span class=line>    inStack = <span class=keyword>new</span> ArrayDeque<>();</span><br><span class=line>    outStack = <span class=keyword>new</span> ArrayDeque<>();</span><br><span class=line></span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>appendTail</span><span class=params>(<span class=keyword>int</span> value)</span> </span>{</span><br><span class=line>    inStack.push(value);</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=keyword>int</span> <span class=title>deleteHead</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>if</span>(outStack.isEmpty())</span><br><span class=line>    {</span><br><span class=line>      <span class=keyword>if</span>(inStack.isEmpty())</span><br><span class=line>      {</span><br><span class=line>        <span class=keyword>return</span> -<span class=number>1</span>;</span><br><span class=line>      }</span><br><span class=line>      <span class=keyword>else</span></span><br><span class=line>      {</span><br><span class=line>        <span class=keyword>while</span>(!inStack.isEmpty())</span><br><span class=line>        {</span><br><span class=line>          outStack.push(inStack.pop());</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> outStack.pop();</span><br><span class=line>      }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> outStack.pop();</span><br><span class=line>  }</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><h3 id=设计一个有getMin功能的栈><a class=headerlink href=#设计一个有getMin功能的栈 title=设计一个有getMin功能的栈></a>设计一个有getMin功能的栈</h3><figure class=highlight><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。</span><br></pre></table></figure><p>【要求】<p>1.pop、push、getMin 操作的时间复杂度都是 <em>O</em>(1)。 2.设计的栈类型可以使用现成的栈结构<h4 id=设计方案><a class=headerlink href=#设计方案 title=设计方案></a>设计方案</h4><p>使用辅助栈,多一个存最小值的栈stackmin. 即有stackdata和stackmin<p><strong>第一种</strong><p>压入规则<p>压入数据时,stackdata直接压入;stackmin如果为空,直接压入,如果不为空,进行比较:将要压入的值和栈顶的值进行比较,如果栈顶值更小则不处理,否则压入.<p>弹出规则<p>stackdata弹出数据,将弹出的数据与stackmin顶数据比较,如果弹出数据等于stackmin栈顶数据,则同时弹出stackmin数据,否则不处理.<p>最小值即位stackmin中栈顶值<p><strong>第二种</strong><p>压入规则<p>压入数据时,stackdata直接压入;stackmin如果为空也直接压入,否则将栈顶数据与待压入数据比较,如果栈顶数据更小,则stackmin再压入一次栈顶数据,否则stackmin压入待压入数据.<p>弹出规则<p>两个栈都弹出<p>最小值也是stackmin的栈顶<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>MinStack</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    stack<<span class=keyword>int</span>>s,min_s;</span><br><span class=line></span><br><span class=line>    <span class=built_in>MinStack</span>() {</span><br><span class=line></span><br><span class=line>    }</span><br><span class=line>    </span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>push</span><span class=params>(<span class=keyword>int</span> val)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span>(s.<span class=built_in>empty</span>())</span><br><span class=line>        {</span><br><span class=line>            s.<span class=built_in>emplace</span>(val);</span><br><span class=line>            min_s.<span class=built_in>emplace</span>(val);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>else</span></span><br><span class=line>        {</span><br><span class=line>            <span class=keyword>int</span> topvalue = min_s.<span class=built_in>top</span>();</span><br><span class=line>            <span class=keyword>if</span>(topvalue>val)</span><br><span class=line>            {</span><br><span class=line>                min_s.<span class=built_in>emplace</span>(val);</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>else</span>{</span><br><span class=line>                min_s.<span class=built_in>emplace</span>(topvalue);</span><br><span class=line>            }</span><br><span class=line>            s.<span class=built_in>emplace</span>(val);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    </span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>pop</span><span class=params>()</span> </span>{</span><br><span class=line>        s.<span class=built_in>pop</span>();</span><br><span class=line>        min_s.<span class=built_in>pop</span>();</span><br><span class=line>    }</span><br><span class=line>    </span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>top</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> s.<span class=built_in>top</span>();</span><br><span class=line></span><br><span class=line>    }</span><br><span class=line>    </span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>min</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> min_s.<span class=built_in>top</span>();</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line></span><br></pre></table></figure><h3 id=从尾到头打印链表><a class=headerlink href=#从尾到头打印链表 title=从尾到头打印链表></a>从尾到头打印链表</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）<h4 id=设计方案-1><a class=headerlink href=#设计方案-1 title=设计方案></a>设计方案</h4><p>利用栈结构或者使用递归<p>这里使用递归<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>reversePrint</span><span class=params>(ListNode* head)</span> </span>{</span><br><span class=line>      </span><br><span class=line>        <span class=keyword>if</span>(!head)</span><br><span class=line>        {</span><br><span class=line>            <span class=keyword>return</span> {};</span><br><span class=line>        }</span><br><span class=line>        vector<<span class=keyword>int</span>> v =<span class=built_in>reversePrint</span>(head->next);</span><br><span class=line>        v.<span class=built_in>push_back</span>(head->val);</span><br><span class=line>        <span class=keyword>return</span> v;</span><br><span class=line>        }</span><br><span class=line>   }</span><br></pre></table></figure><p>使用辅助栈结构<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>reversePrint</span><span class=params>(ListNode* head)</span> </span>{</span><br><span class=line>        stack<<span class=keyword>int</span>> s;</span><br><span class=line></span><br><span class=line>        <span class=keyword>for</span>(ptr it=head;it!=<span class=literal>nullptr</span>;it=it->next)</span><br><span class=line>        {</span><br><span class=line>            s.<span class=built_in>push</span>(it->val);</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        vector<<span class=keyword>int</span>> v;</span><br><span class=line>        <span class=keyword>while</span>(!s.<span class=built_in>empty</span>())</span><br><span class=line>        {</span><br><span class=line>            <span class=keyword>int</span> val = s.<span class=built_in>top</span>();</span><br><span class=line>            s.<span class=built_in>pop</span>();</span><br><span class=line>            v.<span class=built_in>push_back</span>(val);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> v;</span><br><span class=line></span><br><span class=line>        </span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><h3><a title=" " class=headerlink href=#></a></h3><h3 id=反转链表><a class=headerlink href=#反转链表 title=反转链表></a>反转链表</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。<p><strong>示例:</strong><figure class="highlight clean"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>输入: <span class=number>1</span>-><span class=number>2</span>-><span class=number>3</span>-><span class=number>4</span>-><span class=number>5</span>->NULL</span><br><span class=line>输出: <span class=number>5</span>-><span class=number>4</span>-><span class=number>3</span>-><span class=number>2</span>-><span class=number>1</span>->NULL</span><br></pre></table></figure><h4 id=解决方案><a class=headerlink href=#解决方案 title=解决方案></a>解决方案</h4><figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Definition for singly-linked list.</span></span><br><span class=line><span class=comment> * struct ListNode {</span></span><br><span class=line><span class=comment> *     int val;</span></span><br><span class=line><span class=comment> *     ListNode *next;</span></span><br><span class=line><span class=comment>  ListNode(int x):val(x),next(NULL){}</span></span><br><span class=line><span class=comment> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class=line><span class=comment> * };</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>typedef</span> ListNode* LN;</span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>ListNode* <span class=title>reverseList</span><span class=params>(ListNode* head)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span>(!head)</span><br><span class=line>        {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>nullptr</span>;</span><br><span class=line>        }</span><br><span class=line>        LN nd = head->next;</span><br><span class=line>        LN pre = head;</span><br><span class=line>        pre->next = <span class=literal>nullptr</span>;</span><br><span class=line>        <span class=keyword>for</span>(LN it = nd;it!=<span class=literal>nullptr</span>;)</span><br><span class=line>        {</span><br><span class=line>            nd = it->next;</span><br><span class=line>            it->next = pre;</span><br><span class=line>            pre = it;</span><br><span class=line>            it = nd;</span><br><span class=line>            </span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> pre;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>使用递归方法<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>ListNode* <span class=title>reverseList</span><span class=params>(ListNode* head)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (!head || !head->next) {</span><br><span class=line>            <span class=keyword>return</span> head;</span><br><span class=line>        }</span><br><span class=line>        ListNode* newHead = <span class=built_in>reverseList</span>(head->next);</span><br><span class=line>        head->next->next = head;</span><br><span class=line>        head->next = <span class=literal>nullptr</span>;</span><br><span class=line>        <span class=keyword>return</span> newHead;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><h3 id=复杂链表的复制><a class=headerlink href=#复杂链表的复制 title=复杂链表的复制></a>复杂链表的复制</h3><p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。<h4 id=解题思路><a class=headerlink href=#解题思路 title=解题思路></a>解题思路</h4><ol><li>回溯和哈希表(或者单独使用哈希表)</ol><figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    unordered_map&LTNode *, Node *> cachedNode;</span><br><span class=line>    <span class=function>Node *<span class=title>copyRandomList</span><span class=params>(Node *head)</span></span></span><br><span class=line><span class=function>    </span>{</span><br><span class=line>        <span class=keyword>if</span> (!head)</span><br><span class=line>        {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>nullptr</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (!cachedNode.<span class=built_in>count</span>(head))</span><br><span class=line>        {</span><br><span class=line>            cachedNode[head] = <span class=keyword>new</span> <span class=built_in>Node</span>(head->val);</span><br><span class=line>            cachedNode[head]->next = <span class=built_in>copyRandomList</span>(head->next);</span><br><span class=line>            cachedNode[head]->random = <span class=built_in>copyRandomList</span>(head->random);</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=keyword>return</span> cachedNode[head];</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><ol><li><p>迭代+节点拆分</p> <figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>Node* <span class=title>copyRandomList</span><span class=params>(Node* head)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (head == <span class=literal>nullptr</span>) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>nullptr</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (Node* node = head; node != <span class=literal>nullptr</span>; node = node->next->next) {</span><br><span class=line>            Node* nodeNew = <span class=keyword>new</span> <span class=built_in>Node</span>(node->val);</span><br><span class=line>            nodeNew->next = node->next;</span><br><span class=line>            node->next = nodeNew;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (Node* node = head; node != <span class=literal>nullptr</span>; node = node->next->next) {</span><br><span class=line>            Node* nodeNew = node->next;</span><br><span class=line>            nodeNew->random = (node->random != <span class=literal>nullptr</span>) ? node->random->next : <span class=literal>nullptr</span>;</span><br><span class=line>        }</span><br><span class=line>        Node* headNew = head->next;</span><br><span class=line>        <span class=keyword>for</span> (Node* node = head; node != <span class=literal>nullptr</span>; node = node->next) {</span><br><span class=line>            Node* nodeNew = node->next;</span><br><span class=line>            node->next = node->next->next;</span><br><span class=line>            nodeNew->next = (nodeNew->next != <span class=literal>nullptr</span>) ? nodeNew->next->next : <span class=literal>nullptr</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> headNew;</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line></span><br></pre></table></figure></ol><h2 id=Update><a class=headerlink href=#Update title=Update></a>Update</h2><blockquote><p>Source:<ul><li><a href=https://noworneverev.github.io/leetcode_101/ rel=noopener target=_blank>LeetCode 101: 力扣刷题指南 (第二版) | LeetCode 101 - A Grinding Guide</a><li><a href=https://www.programmercarl.com/数组理论基础.html rel=noopener target=_blank>代码随想录</a><li><a href=https://labuladong.online/algo/home/ rel=noopener target=_blank>本站简介 | labuladong 的算法笔记</a><li>剑指Offer<li>leetcode hot 100</ul></blockquote><p>将题型按照算法类型和使用的数据结构进行分类.<h3 id=贪心算法><a class=headerlink href=#贪心算法 title=贪心算法></a>贪心算法</h3><p>顾名思义，贪心算法或贪心思想 区间问题 采用贪心的策略，保证每次操作都是局部 最优的，从而使最后得到的结果是全局最优的<blockquote><p>证明一道题能用贪心算法解决，有时远比用贪心算法解决该题更复杂。一般情况下，在简单 操作后，具有明显的从局部到整体的递推关系，或者可以通过数学归纳法推测结果时，我们才会 使用贪心算法。</blockquote><h4 id=121-买卖股票最佳时机><a title="121 买卖股票最佳时机" class=headerlink href=#121-买卖股票最佳时机></a>121 买卖股票最佳时机</h4><p>我们来假设自己来购买股票。随着时间的推移，每天我们都可以选择出售股票与否。那么，假设在第 i 天，如果我们要在今天卖股票，那么我们能赚多少钱呢？<p>显然，如果我们真的在买卖股票，我们肯定会想：如果我是在历史最低点买的股票就好了.在题目中，只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice。<p>因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。<blockquote><p>作者：力扣官方题解<br>链接：<a href=https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solutions/136684/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/ rel=noopener target=_blank>https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solutions/136684/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</blockquote><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>int</span> maxProfit = <span class=number>0</span>;</span><br><span class=line><span class=keyword>if</span> (prices.<span class=built_in>size</span>() < <span class=number>2</span>) {</span><br><span class=line>  <span class=keyword>return</span> maxProfit;</span><br><span class=line>}</span><br><span class=line><span class=keyword>int</span> sellDay = <span class=number>1</span>;</span><br><span class=line><span class=keyword>int</span> minPrice = prices[<span class=number>0</span>];</span><br><span class=line><span class=keyword>while</span> (sellDay < prices.<span class=built_in>size</span>()) {</span><br><span class=line>  minPrice = std::<span class=built_in>min</span>(minPrice, prices[sellDay - <span class=number>1</span>]);</span><br><span class=line>  <span class=keyword>int</span> profit = prices[sellDay] - minPrice;</span><br><span class=line>  <span class=keyword>if</span> (profit > maxProfit) {</span><br><span class=line>    maxProfit = profit;</span><br><span class=line>  }</span><br><span class=line>  ++sellDay;</span><br><span class=line>}</span><br><span class=line><span class=keyword>return</span> maxProfit;</span><br></pre></table></figure><h4 id=122-买卖股票的最佳时机-II><a title="122 买卖股票的最佳时机 II" class=headerlink href=#122-买卖股票的最佳时机-II></a>122 买卖股票的最佳时机 II</h4><p><a href=https://www.programmercarl.com/0122.买卖股票的最佳时机II.html#思路 rel=noopener target=_blank>代码随想录</a><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>int</span> maxProfit = <span class=number>0</span>;</span><br><span class=line>   <span class=keyword>if</span> (prices.<span class=built_in>size</span>() < <span class=number>2</span>) {</span><br><span class=line>     <span class=keyword>return</span> maxProfit;</span><br><span class=line>   }</span><br><span class=line>   <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i < prices.<span class=built_in>size</span>(); i++) {</span><br><span class=line>     maxProfit += std::<span class=built_in>max</span>(prices[i] - prices[i - <span class=number>1</span>], <span class=number>0</span>);</span><br><span class=line>   }</span><br><span class=line>   <span class=keyword>return</span> maxProfit;</span><br></pre></table></figure><p>只需要计算有利益的区间和即可.<h4 id=455分发饼干><a class=headerlink href=#455分发饼干 title=455分发饼干></a>455分发饼干</h4><p>因为饥饿度最小的孩子最容易吃饱，所以我们先考虑这个孩子。为了尽量使得剩下的饼干可 以满足饥饿度更大的孩子，所以我们应该把大于等于这个孩子饥饿度的、且大小最小的饼干给这个孩子。满足了这个孩子之后，我们采取同样的策略，考虑剩下孩子里饥饿度最小的孩子，直到 没有满足条件的饼干存在。 简而言之，这里的贪心策略是，<strong>给剩余孩子里最小饥饿度的孩子分配最小的能饱腹的饼干</strong><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>findContentChildren</span><span class=params>(vector<<span class=keyword>int</span>> &children, vector<<span class=keyword>int</span>> &cookies)</span> </span>{</span><br><span class=line> <span class=built_in>sort</span>(children.<span class=built_in>begin</span>(), children.<span class=built_in>end</span>());</span><br><span class=line> <span class=built_in>sort</span>(cookies.<span class=built_in>begin</span>(), cookies.<span class=built_in>end</span>());</span><br><span class=line> <span class=keyword>int</span> child_i = <span class=number>0</span>, cookie_i = <span class=number>0</span>;</span><br><span class=line> <span class=keyword>int</span> n_children = children.<span class=built_in>size</span>(), n_cookies = cookies.<span class=built_in>size</span>();</span><br><span class=line> <span class=keyword>while</span> (child_i < n_children && cookie_i < n_cookies) {</span><br><span class=line> <span class=keyword>if</span> (children[child_i] <= cookies[cookie_i]) {</span><br><span class=line> ++child_i;</span><br><span class=line> }</span><br><span class=line> ++cookie_i;</span><br><span class=line> }</span><br><span class=line> <span class=keyword>return</span> child_i;</span><br><span class=line> }</span><br></pre></table></figure><h4 id=135分发糖果><a class=headerlink href=#135分发糖果 title=135分发糖果></a>135分发糖果</h4><p>存在比较关系的贪心策略并不一定需要排序。虽然这一道题也是运用贪心策略，但我们只需 要简单的两次遍历即可：把所有孩子的糖果数初始化为；先从左往右遍历一遍，如果右边孩子 的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加；再从右往左遍历一遍， 如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加。通过这两次遍历，分配的糖果就可以满足题目要求了。 这里的贪心策略即为，在每次遍历中，只考虑并更新相邻一侧的大小关系<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>candy</span><span class=params>(std::vector<<span class=keyword>int</span>> &ratings)</span> </span>{</span><br><span class=line>   <span class=function>std::vector<<span class=keyword>int</span>> <span class=title>candies</span><span class=params>(ratings.size(), <span class=number>1</span>)</span></span>;</span><br><span class=line>   <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < candies.<span class=built_in>size</span>() - <span class=number>1</span>; i++) {</span><br><span class=line>     <span class=comment>// 从左到右遍历,如果右边比左边大,右边糖果比左边+1</span></span><br><span class=line>     <span class=keyword>if</span> (ratings[i] < ratings[i + <span class=number>1</span>]) {</span><br><span class=line>       candies[i + <span class=number>1</span>] = candies[i] + <span class=number>1</span>;</span><br><span class=line>     }</span><br><span class=line>     <span class=comment>// 如果左边与右边的相等,均不增加</span></span><br><span class=line>   }</span><br><span class=line>   <span class=keyword>for</span> (<span class=keyword>int</span> i = candies.<span class=built_in>size</span>() - <span class=number>1</span>; i > <span class=number>0</span>; i--) {</span><br><span class=line>     <span class=comment>// 从右到左遍历,如果左边比右边大,并且左边的糖果不大于右边的糖果,左边的糖果=右边的糖果+1</span></span><br><span class=line>     <span class=keyword>if</span> (ratings[i] < ratings[i - <span class=number>1</span>] && candies[i] >= candies[i - <span class=number>1</span>]) {</span><br><span class=line>       candies[i - <span class=number>1</span>] = candies[i] + <span class=number>1</span>;</span><br><span class=line>     }</span><br><span class=line>   }</span><br><span class=line>   <span class=keyword>return</span> std::<span class=built_in>accumulate</span>(candies.<span class=built_in>begin</span>(), candies.<span class=built_in>end</span>(), <span class=number>0</span>);</span><br><span class=line> }</span><br></pre></table></figure><h4 id=435无重叠区间><a class=headerlink href=#435无重叠区间 title=435无重叠区间></a>435无重叠区间</h4><p>求最少的移除区间个数，等价于尽量多保留不重叠的区间。<strong>在选择要保留区间时，区间的结尾十分重要：选择的区间结尾越小，余留给其它区间的空间就越大，就越能保留更多的区间。因此，我们采取的贪心策略为，优先保留结尾小且不相交的区间。</strong><p>具体实现方法为，先把区间按照结尾的大小进行增序排序（利用 lambda 函数），每次选择结尾最小且和前一个选择的区间不重叠的区间。<p>在样例中，排序后的数组为 [[1,2], [1,3], [2,4]]。按照我们的贪心策略，首先初始化为区间[1,2]；由于 [1,3] 与 [1,2] 相交，我们跳过该区间；由于 [2,4] 与 [1,2] 不相交，我们将其保留。因此最终保留的区间为 [[1,2], [2,4]]。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=keyword>if</span> (intervals.<span class=built_in>size</span>() <= <span class=number>1</span>) {</span><br><span class=line>  <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br><span class=line><span class=comment>// 排序,根据start</span></span><br><span class=line>std::<span class=built_in>sort</span>(intervals.<span class=built_in>begin</span>(), intervals.<span class=built_in>end</span>(),</span><br><span class=line>          [](<span class=keyword>const</span> std::vector<<span class=keyword>int</span>> &a, <span class=keyword>const</span> std::vector<<span class=keyword>int</span>> &b) {</span><br><span class=line>            <span class=keyword>return</span> a[<span class=number>1</span>] < b[<span class=number>1</span>];</span><br><span class=line>          });</span><br><span class=line><span class=keyword>int</span> count = <span class=number>0</span>;</span><br><span class=line><span class=comment>// 当根据开始时间排序后,下一个的开始时间必须大于等于当前结束时间</span></span><br><span class=line><span class=keyword>int</span> prevEnd = intervals[<span class=number>0</span>][<span class=number>1</span>];</span><br><span class=line><span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < intervals.<span class=built_in>size</span>() - <span class=number>1</span>; i++) {</span><br><span class=line>  <span class=keyword>if</span> (prevEnd > intervals[i + <span class=number>1</span>][<span class=number>0</span>]) {</span><br><span class=line>    count++;</span><br><span class=line>  }<span class=keyword>else</span>{</span><br><span class=line>    prevEnd = intervals[i + <span class=number>1</span>][<span class=number>1</span>];</span><br><span class=line>  }</span><br><span class=line>}</span><br><span class=line><span class=keyword>return</span> count;</span><br></pre></table></figure><h3 id=双指针><a class=headerlink href=#双指针 title=双指针></a>双指针</h3><p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多 个数组的多个指针。 <strong>若两个指针指向同一数组，遍历方向相同且不会相交，则也称为滑动窗口（两个指针包围的 区域即为当前的窗口），经常用于区间搜索</strong>。<p><strong>若两个指针指向同一数组，但是遍历方向相反，则可以用来进行搜索，待搜索的数组往往是 排好序的</strong>。<h4 id=167-两数之和><a title="167 两数之和" class=headerlink href=#167-两数之和></a>167 两数之和</h4><p>因为数组已经排好序，我们可以采用方向相反的双指针来寻找这两个数字，一个初始指向最 小的元素，即数组最左边，向右遍历；一个初始指向最大的元素，即数组最右边，向左遍历。 如果两个指针指向元素的和等于给定值，那么它们就是我们要的结果。如果两个指针指向元 素的和小于给定值，我们把左边的指针右移一位，使得当前的和增加一点。如果两个指针指向元 素的和大于给定值，我们把右边的指针左移一位，使得当前的和减少一点。 可以证明，对于排好序且有解的数组，双指针一定能遍历到最优解。证明方法如下：假设最 优解的两个数的位置分别是l和r。我们假设在左指针在l左边的时候，右指针已经移动到了r； 此时两个指针指向值的和小于给定值，因此左指针会一直右移直到到达l。同理，如果我们假设 在右指针在r右边的时候，左指针已经移动到了l；此时两个指针指向值的和大于给定值，因此 右指针会一直左移直到到达r。所以双指针在任何时候都不可能处于l,r之间，又因为不满足条 件时指针必须移动一个，所以最终一定会收敛在l和r。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=function>std::vector<<span class=keyword>int</span>> <span class=title>twoSum</span><span class=params>(std::vector<<span class=keyword>int</span>> &numbers, <span class=keyword>int</span> target)</span> </span>{</span><br><span class=line>  <span class=keyword>int</span> i = <span class=number>0</span>, j = numbers.<span class=built_in>size</span>() - <span class=number>1</span>;</span><br><span class=line>  <span class=keyword>while</span> (i < j) {</span><br><span class=line>    <span class=keyword>if</span> (numbers[i] + numbers[j] < target) {</span><br><span class=line>      i++;</span><br><span class=line>    } <span class=keyword>else</span> <span class=keyword>if</span> (numbers[i] + numbers[j] > target) {</span><br><span class=line>      j--;</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>      <span class=keyword>return</span> {i+<span class=number>1</span>, j+<span class=number>1</span>};</span><br><span class=line>    }</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>return</span> {};</span><br><span class=line>}</span><br></pre></table></figure><h4 id=88-归并有序数组><a title="88 归并有序数组" class=headerlink href=#88-归并有序数组></a>88 归并有序数组</h4><p>因为这两个数组已经排好序，我们可以把两个指针分别放在两个数组的末尾，即 nums1 的 m − 1 位和 nums2 的 n − 1 位。每次将较大的那个数字复制到 nums1 的后边，然后向前移动一位。 因为我们也要定位 nums1 的末尾，所以我们还需要第三个指针，以便复制。<p>在以下的代码里，我们直接利用 m 和 n 当作两个数组的指针，再额外创立一个 pos 指针，起始位置为 m +n − 1。每次向左移动 m 或 n 的时候，也要向左移动 pos。这里需要注意，如果 nums1 的数字已经复制完，不要忘记把 nums2 的数字继续复制；如果 nums2 的数字已经复制完，剩余 nums1 的数字不需要改变，因为它们已经被排好序。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>void</span> <span class=title>merge</span><span class=params>(std::vector<<span class=keyword>int</span>> &nums1, <span class=keyword>int</span> m, std::vector<<span class=keyword>int</span>> &nums2, <span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> pos = m + n - <span class=number>1</span>; <span class=comment>// 指向最后一个位置</span></span><br><span class=line>    <span class=comment>// 将最大的元素往后放</span></span><br><span class=line>    <span class=keyword>while</span> (m > <span class=number>0</span> && n > <span class=number>0</span>) {</span><br><span class=line>      <span class=keyword>if</span> (nums1[m - <span class=number>1</span>] > nums2[n - <span class=number>1</span>]) {</span><br><span class=line>        nums1[pos] = nums1[m - <span class=number>1</span>];</span><br><span class=line>        <span class=comment>// 指针后移</span></span><br><span class=line>        m--;</span><br><span class=line>      } <span class=keyword>else</span> {</span><br><span class=line>        nums1[pos] = nums2[n - <span class=number>1</span>];</span><br><span class=line>        n--;</span><br><span class=line>      }</span><br><span class=line>      pos--;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>while</span> (n) {</span><br><span class=line>      nums1[pos--] = nums2[n--];</span><br><span class=line>    }</span><br><span class=line>  }</span><br><span class=line></span><br></pre></table></figure><h3 id=二分查找><a class=headerlink href=#二分查找 title=二分查找></a>二分查找</h3><p>二分查找也常被称为二分法或者折半查找 ，每次查找时通过将待查找的单调区间分成两部分并只取一部分继续查找，将查找的复杂度大大减少。对于一个长度为On 的数组，二分查找的时间复杂度为Ologn。<blockquote><p>具体到代码上，二分查找时区间的<strong>左右端取开区间还是闭区间</strong>在绝大多数时候都可以，因此 有些初学者会容易搞不清楚如何定义区间开闭性。这里笔者提供两个小诀窍，第一是尝试熟练使用一种写法，比如左闭右开（满足、等语言的习惯）或左闭右闭（便于处理边界条 件），尽量只保持这一种写法；第二是在<strong>刷题时思考如果最后区间只剩下一个数或者两个数，自 己的写法是否会陷入死循环，如果某种写法无法跳出死循环，则考虑尝试另一种写法</strong>。</blockquote><p>此外在更新left和right时,使用left=mid+1还是left=mid有差别,如果是前者,在下一次更新mid时仍有可能为mid(下一轮循环仍可能考虑 <code>mid</code> 这个位置的值)<h4 id=旋转数组查找数字><a class=headerlink href=#旋转数组查找数字 title=旋转数组查找数字></a>旋转数组查找数字</h4><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br></pre><td class=code><pre><span class=line><span class=comment>/*</span></span><br><span class=line><span class=comment> * @lc app=leetcode.cn id=81 lang=cpp</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * [81] 搜索旋转排序数组 II</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line></span><br><span class=line><span class=comment>// @lc code=start</span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTvector></span></span></span><br><span class=line></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>  <span class=function><span class=keyword>bool</span> <span class=title>search</span><span class=params>(vector<<span class=keyword>int</span>> &nums, <span class=keyword>int</span> target)</span> </span>{</span><br><span class=line>    <span class=keyword>const</span> <span class=keyword>auto</span> size = nums.<span class=built_in>size</span>();</span><br><span class=line>    <span class=keyword>int</span> l = <span class=number>0</span>, r = size - <span class=number>1</span>;</span><br><span class=line>    <span class=keyword>while</span> (l <= r) {</span><br><span class=line>      <span class=keyword>int</span> mid = (r - l) / <span class=number>2</span> + l;</span><br><span class=line>      <span class=keyword>if</span> (nums.<span class=built_in>at</span>(mid) == target) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>      }</span><br><span class=line>      <span class=keyword>if</span> (nums.<span class=built_in>at</span>(mid) == nums.<span class=built_in>at</span>(l)) {</span><br><span class=line>        l += <span class=number>1</span>;</span><br><span class=line>      } <span class=keyword>else</span> <span class=keyword>if</span> (nums.<span class=built_in>at</span>(mid) == nums.<span class=built_in>at</span>(r)) {</span><br><span class=line>        r--;</span><br><span class=line>      } <span class=keyword>else</span> <span class=keyword>if</span> (nums.<span class=built_in>at</span>(mid) > nums.<span class=built_in>at</span>(r)) {</span><br><span class=line>        <span class=comment>// 如果大于右端,则左半区间为递增(非降) [l,mid]</span></span><br><span class=line>        <span class=comment>// 如果target在递增区间中,进行二分法搜索</span></span><br><span class=line>        <span class=keyword>if</span> (target >= nums.<span class=built_in>at</span>(l) && target <= nums.<span class=built_in>at</span>(mid)) {</span><br><span class=line>          r = mid - <span class=number>1</span>;</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>          <span class=comment>// 在另一个区间</span></span><br><span class=line>          l = mid + <span class=number>1</span>;</span><br><span class=line>        }</span><br><span class=line>      } <span class=keyword>else</span> {</span><br><span class=line>        <span class=comment>// 右半区间递增 [mid,r]</span></span><br><span class=line>        <span class=keyword>if</span> (target >= nums.<span class=built_in>at</span>(mid) && target <= nums.<span class=built_in>at</span>(r)) {</span><br><span class=line>          l = mid + <span class=number>1</span>;</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>          <span class=comment>// 在另一个区间</span></span><br><span class=line>          r = mid - <span class=number>1</span>;</span><br><span class=line>        }</span><br><span class=line>      }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>  }</span><br><span class=line>};</span><br><span class=line><span class=comment>// @lc code=end</span></span><br><span class=line></span><br></pre></table></figure><h4 id=查找峰值><a class=headerlink href=#查找峰值 title=查找峰值></a>查找峰值</h4><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br></pre><td class=code><pre><span class=line><span class=comment>/*</span></span><br><span class=line><span class=comment> * @lc app=leetcode.cn id=162 lang=cpp</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * [162] 寻找峰值</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line></span><br><span class=line><span class=comment>// @lc code=start</span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiterator></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTlimits></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTvector></span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>  <span class=function><span class=keyword>int</span> <span class=title>findPeakElement</span><span class=params>(vector<<span class=keyword>int</span>> &nums)</span> </span>{</span><br><span class=line>    <span class=keyword>auto</span> size = nums.<span class=built_in>size</span>();</span><br><span class=line>    <span class=keyword>if</span> (size == <span class=number>1</span>) {</span><br><span class=line>      <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 长度大于1,先判断两边</span></span><br><span class=line>    <span class=keyword>if</span> (nums.<span class=built_in>at</span>(<span class=number>0</span>) > nums.<span class=built_in>at</span>(<span class=number>1</span>)) {</span><br><span class=line>      <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>if</span> (nums.<span class=built_in>at</span>(size - <span class=number>1</span>) > nums.<span class=built_in>at</span>(size - <span class=number>2</span>)) {</span><br><span class=line>      <span class=keyword>return</span> size - <span class=number>1</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 判断两边后判断剩下位置</span></span><br><span class=line>    <span class=keyword>int</span> l = <span class=number>1</span>, r = size - <span class=number>2</span>;</span><br><span class=line>    <span class=keyword>while</span> (l <= r) {</span><br><span class=line>      <span class=keyword>int</span> mid = (r - l) / <span class=number>2</span> + l;</span><br><span class=line>      <span class=comment>// 判断是否是峰值</span></span><br><span class=line>      <span class=keyword>if</span> (nums.<span class=built_in>at</span>(mid) > nums.<span class=built_in>at</span>(mid + <span class=number>1</span>) && nums.<span class=built_in>at</span>(mid) > nums.<span class=built_in>at</span>(mid - <span class=number>1</span>)) {</span><br><span class=line>        <span class=keyword>return</span> mid;</span><br><span class=line>      }</span><br><span class=line>      <span class=comment>// 二分</span></span><br><span class=line>      <span class=keyword>if</span> (nums.<span class=built_in>at</span>(mid) <= nums.<span class=built_in>at</span>(mid + <span class=number>1</span>)) {</span><br><span class=line>        <span class=comment>// 如果后面值更大,则后面一定存在峰值</span></span><br><span class=line>        l = mid + <span class=number>1</span>;</span><br><span class=line>      } <span class=keyword>else</span> {</span><br><span class=line>        <span class=comment>// 同理</span></span><br><span class=line>        r = mid - <span class=number>1</span>;</span><br><span class=line>      }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>  }</span><br><span class=line>};</span><br><span class=line><span class=comment>// @lc code=end</span></span><br><span class=line></span><br></pre></table></figure><h3 id=排序算法><a class=headerlink href=#排序算法 title=排序算法></a>排序算法</h3><p>虽然在和里都可以通过sort函数排序，而且刷题时很少需要自己手写排序算 法，但是熟习各种排序算法可以加深自己对算法的基本理解，以及解出由这些排序算法引申出来 的题目。这里我们展示两种复杂度为Onlogn的排序算法：快速排序和归并排序，其中前者实 际速度较快，后者可以保证相同值的元素在数组中的相对位置不变（即“稳定排序”）<h4 id=快速排序><a class=headerlink href=#快速排序 title=快速排序></a>快速排序</h4><p>快速排序的原理并不复杂：对于当前一个未排序片段，我们先随机选择一个位置当作中枢点， 然后通过遍历操作，将所有比中枢点小的数字移动到其左侧，再将所有比中枢点大的数字移动到 其右侧。操作完成后，我们再次对中枢点左右侧的片段再次进行快速排序即可。可证明，如果中 枢点选取是随机的，那么该算法的平均复杂度可以达到Onlogn，最差情况下复杂度则为On2。 我们采用左闭右闭的二分写法，初始化条件为l=0，r=n 1。<h4 id=归并排序><a class=headerlink href=#归并排序 title=归并排序></a>归并排序</h4><p>归并排序是典型的分治法，简单来讲，对于一个未排序片段, 我们可以先分别排序其左半侧和右半侧，然后将两侧重新组合（“治”）；排序每个半侧时可以通 过递归再次把它切分成两侧（“分”）。 我们采用左闭右闭的二分写法，初始化条件为l=0，r =n 1，另外提前建立一个和 大小相同的数组，用来存储临时结果。<div class=table-container><table><thead><tr><th>排序算法<th>最好时间复杂度<th>最坏时间复杂度<th>平均时间复杂度<th>空间复杂度<th>稳定性<tbody><tr><td>冒泡排序<td>O(n)<td>O(n²)<td>O(n²)<td>O(1)<td>是<tr><td>插入排序<td>O(n)<td>O(n²)<td>O(n²)<td>O(1)<td>是<tr><td>选择排序<td>O(n²)<td>O(n²)<td>O(n²)<td>O(1)<td>否<tr><td>希尔排序<td>O(n)<td>O(n²)<td>O(nlogn)~O(n²)<td>O(1)<td>否<tr><td>归并排序<td>O(nlogn)<td>O(nlogn)<td>O(nlogn)<td>O(n)<td>是<tr><td>快速排序<td>O(nlogn)<td>O(n²)<td>O(nlogn)<td>O(logn)<td>否<tr><td>堆排序<td>O(nlogn)<td>O(nlogn)<td>O(nlogn)<td>O(1)<td>否<tr><td>计数排序<td>O(n+k)<td>O(n+k)<td>O(n+k)<td>O(k)<td>是<tr><td>桶排序<td>O(n+k)<td>O(n²)<td>O(n+k)<td>O(n+k)<td>是<tr><td>基数排序<td>O(n×k)<td>O(n×k)<td>O(n×k)<td>O(n+k)<td>是</table></div><p><strong>说明：</strong><ul><li><strong>稳定性</strong>：稳定的排序算法在排序过程中不会改变相等元素的相对顺序。<li><strong>空间复杂度</strong>：表示算法在运行过程中所需的额外空间。<li><strong>计数排序、桶排序、基数排序</strong>：适用于数据范围有限或特定场景，能达到线性时间复杂度。</ul><h4 id=快速选择><a class=headerlink href=#快速选择 title=快速选择></a>快速选择</h4><p>在一个未排序的数组中，找到第k大的数字。<p>快速选择一般用于求解k-th Element 问题，可以在平均On时间复杂度，O1空间复杂度完 成求解工作。快速选择的实现和快速排序相似，不过只需要找到第k大的枢即可，不需 要对其左右再进行排序。与快速排序一样，快速选择一般需要先打乱数组，否则最坏情况下时间 复杂度为On2。<h4 id=桶排序><a class=headerlink href=#桶排序 title=桶排序></a>桶排序</h4><p>给定一个数组，求前k个最频繁的数字。<h3 id=搜索><a class=headerlink href=#搜索 title=搜索></a>搜索</h3><p>深度优先搜索和广度优先搜索是两种最常见的优先搜索方法，它们被广泛地运用在图和树等 结构中进行搜索。<p>​ 深度优先搜索在搜索到一个新的节点时，立即对该新节点进行遍 历；因此遍历需要用先入后出的栈（）来实现，也可以通过与栈等价的递归来实现。对于树 结构而言，由于总是对新节点调用遍历，因此看起来是向着“深”的方向前进。<p>​ <strong>深度优先搜索也可以用来检测环路</strong>：记录每个遍历过的节点的父节点，若一个节点被再次遍 历且父节点不同，则说明有环。我们也可以用之后会讲到的拓扑排序判断是否有环路，若最后存 在入度不为零的点，则说明有环。<h4 id=最大岛屿面积><a class=headerlink href=#最大岛屿面积 title=最大岛屿面积></a>最大岛屿面积</h4><p>给定一个二维的矩阵，其中表示海洋，表示陆地。单独的或相邻的陆地可以形成岛 屿，每个格子只与其上下左右四个格子相邻。求最大的岛屿面积。<h4 id=城市数量><a class=headerlink href=#城市数量 title=城市数量></a>城市数量</h4><p>给定一个二维的矩阵，如果第位置是，则表示第个城市和第个城市处于同一 城市圈。已知城市的相邻关系是可以传递的，即如果a和b相邻，b和c相邻，那么a和c也相 邻，换言之这三个城市处于同一个城市圈之内。求一共有多少个城市圈。<h4 id=太平洋大西洋水流问题><a class=headerlink href=#太平洋大西洋水流问题 title=太平洋大西洋水流问题></a>太平洋大西洋水流问题</h4><p>给定一个二维的非负整数矩阵，每个位置的值表示海拔高度。假设左边和上边是太平洋，右 边和下边是大西洋，求从哪些位置向下流水，可以流到太平洋和大西洋。水只能从海拔高的位置 流到海拔低或相同的位置。<h3 id=回溯法><a class=headerlink href=#回溯法 title=回溯法></a>回溯法</h3><p>回溯法是优先搜索的一种特殊情况，又称为试探法，常用于需要记录节点状 态的深度优先搜索。通常来说，排列、组合、选择类问题使用回溯法比较方便<p>​ 。 顾名思义，回溯法的核心是回溯。在搜索到某一节点的时候，如果我们发现目前的节点（及 其子节点）并不是需求目标时，我们回退到原来的节点继续搜索，并且把在目前节点修改的状态 还原。这样的好处是我们可以<strong>始终只对图的总状态进行修改，而非每次遍历时新建一个图来储存 状态</strong>。<p>​ 在具体的写法上，<strong>它与普通的深度优先搜索一样，都有修改当前节点状态递归子节 点的步骤，只是多了回溯的步骤，变成了修改[当前节点状态]->[递归子节点]->[回改当前节点状态]。</strong><p>可以记住两个小诀窍，一是<strong>按引用传状态</strong>，二是<strong>所有的状态修 改在递归完成后回改</strong>。 回溯法修改一般有两种情况，一种是修改最后一位输出，比如排列组合；一种是修改访问标 记，比如矩阵里搜字符串。<h4 id=全排列><a class=headerlink href=#全排列 title=全排列></a>全排列</h4><p>给定一个无重复数字的整数数组，求其所有的排列方式。<h4 id=组合><a class=headerlink href=#组合 title=组合></a>组合</h4><p>给定一个整数n和一个整数k，求在到n中选取k个数字的所有组合方法。<h4 id=单词搜索><a class=headerlink href=#单词搜索 title=单词搜索></a>单词搜索</h4><p>给定一个字母矩阵，所有的字母都与上下左右四个方向上的字母相连。给定一个字符串，求 字符串能不能在字母矩阵中寻找到。<h4 id=K皇后><a class=headerlink href=#K皇后 title=K皇后></a>K皇后</h4><p>给定一个大小为n的正方形国际象棋棋盘，求有多少种方式可以放置n个皇后并使得她们互 不攻击，即每一行、列、左斜、右斜最多只有一个皇后。<h3 id=广度优先搜索><a class=headerlink href=#广度优先搜索 title=广度优先搜索></a>广度优先搜索</h3><p>广度优先搜索（ 此需要用先入先出的队列 ，）不同与深度优先搜索，它是一层层进行遍历的，因 而非先入后出的栈 进行遍历。由于是按层次进行遍历， <strong>广度优先搜索时按照“广”的方向进行遍历的，也常常用来处理最短路径等问题</strong>。<blockquote><p>这里要注意，深度优先搜索和广度优先搜索都可以处理可达性问题，即从一个节点开始是否 能达到另一个节点。因为深度优先搜索可以利用递归快速实现，很多人会习惯使用深度优先搜索 刷此类题目。实际软件工程中，笔者很少见到递归的写法，因为一方面难以理解，另一方面可能 产生栈溢出的情况；而用栈实现的深度优先搜索和用队列实现的广度优先搜索在写法上并没有太 大差异，因此使用哪一种搜索方式需要根据实际的功能需求来判断。另外，如果需要自定义搜索 优先级，我们可以利用优先队列，这个我们会在数据结构的章节讲到。—leetcode101</blockquote><h3 id=动态规划><a class=headerlink href=#动态规划 title=动态规划></a>动态规划</h3><p>​ 动态规划在查找有很多 重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问 题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划 保存递归时的结果，因而不会在解决同样的问题时花费时间 动态规划只能应用于有最优 子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能 完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决<p>​ 动态规划和其它遍历算法（如深广度优先搜索）都是将原问题拆成多个子问 题然后求解，他们之间最本质的区别是，动态规划保存子问题的解，避免重复计算。解决动态规 划问题的关键是找到状态转移方程，这样我们可以通过计算和储存子问题的解来求解最终问题。<p>​ 同时，<strong>也可以对动态规划进行空间压缩，起到节省空间消耗的效果</strong>。<p>​ 在一些情况下，动态规划可以看成是带有状态记录（ ）的优先搜索。状态记录的 意思为，如果一个子问题在优先搜索时已经计算过一次，我们可以把它的结果储存下来，之后遍 历到该子问题的时候可以直接返回储存的结果。<p>​ <strong>动态规划是自下而上的，即先解决子问题，再解 决父问题；而用带有状态记录的优先搜索是自上而下的，即从父问题搜索到子问题，若重复搜索 到同一个子问题则进行状态记录，防止重复计算</strong>。如果题目需求的是最终状态，那么使用动态搜 索比较方便；如果题目需要输出所有的路径，那么使用带有状态记录的优先搜索会比较方便<h4 id=一维><a class=headerlink href=#一维 title=一维></a>一维</h4><p>给定n节台阶，每次可以走一步或走两步，求一共有多少种方式可以走完这些台阶。<p>假如你是一个劫匪，并且决定抢劫一条街上的房子，每个房子内的钱财数量各不相同。如果 你抢了两栋相邻的房子，则会触发警报机关。求在不触发机关的情况下最多可以抢劫多少钱。<p>给定一个数组，求这个数组中连续且等差的子数组一共有多少个<h4 id=二维><a class=headerlink href=#二维 title=二维></a>二维</h4><p>给定一个m n大小的非负整数矩阵，求从左上角开始到右下角结束的、经过的数字的和最 小的路径。每次只能向右或者向下移动。<p>给定一个由和组成的二维矩阵，求每个位置到最近的的距离。<p>在一个由 <code>'0'</code> 和 <code>'1'</code> 组成的二维矩阵内，找到只包含 <code>'1'</code> 的最大正方形，并返回其面积<h4 id=分割类型><a class=headerlink href=#分割类型 title=分割类型></a>分割类型</h4><p>给定一个正整数，求其最少可以由几个完全平方数相加构成<p>已知字母可以表示成数字。给定一个数字串，求有多少种不同的字符串等价于这个 数字串<p>给定一个字符串和一个字符串集合，求是否存在一种分割方式，使得原字符串分割后的子字 符串都可以在集合内找到。<p>给定一个数组，每个元素代表一本书的厚度和高度。问对于一个固定宽度的书架，如果按照 数组中书的顺序从左到右、从上到下摆放，最小总高度是多少。<p>给定一个不重复数字的数组和一个目标数，求加起来是目标数的所有排列的总数量<h4 id=子序列问题><a class=headerlink href=#子序列问题 title=子序列问题></a>子序列问题</h4><p>​ 对于子序列问题，第一种动态规划方法是，<strong>定义一个数组,其中dp[i]表示以i结尾的子 序列的性质</strong>。<strong>在处理好每个位置后，统计一遍各个位置的结果</strong>即可得到题目要求的结果。<p>​ 对于子序列问题，第二种动态规划方法是，<strong>定义一个数组，其中表示dp[i]到位置i为止的子序列的性质，并不必须以结尾</strong>。这样<strong>数组的最后一位结果即为题目所求</strong>，不需要再对每 个位置进行统计。<h4 id=背包问题><a class=headerlink href=#背包问题 title=背包问题></a>背包问题</h4><p>背包问题是一种组合优化的完全问题：有n个物品和载重为w的背包和价值，求拿哪些物品可以使得背包所装下物品的总价值最大。如果限定每种物品只能选择0个或1个，则问题称为背包问题（ 如果不限定每种物品的数量，则问题称为无界背包问题或完全背包问题)<p>给定一个正整数数组，求是否可以把这个数组分成和相等的两部分<p>给定一些硬币的面额，求最少可以用多少颗硬币组成给定的金额。<p>给定m个数字和n个数字，以及一些由构成的字符串，求利用这些数字最多可以构 成多少个给定的字符串，字符串只可以构成一次。<h4 id=字符串编辑><a class=headerlink href=#字符串编辑 title=字符串编辑></a>字符串编辑</h4><p>给定两个字符串，已知你可以删除、替换和插入任意字符串的任意字符，求最少编辑几步可 以将两个字符串变成相同。<p>给定一个字母，已知你可以每次选择复制全部字符，或者粘贴之前复制的字符，求最少需 要几次操作可以把字符串延展到指定长度。<h4 id=股票交易><a class=headerlink href=#股票交易 title=股票交易></a>股票交易</h4><p>股票交易类问题通常可以用动态规划来解决。对于稍微复杂一些的股票交易类问题，比如需要<strong>冷却时间或者交易费用</strong>，则可以用通过<strong>动态规划实现的状态机</strong>来解决。<p>给定一段时间内每天某只股票的固定价格，已知你只可以买卖各k次，且每次只能拥有一支 股票，求最大的收益。<p>给定一段时间内每天某只股票的固定价格，已知每次卖出之后必须冷却一天，且每次只能拥 有一支股票，求最大的收益。<p><img alt=image-20250522171311869 data-src=https://s2.loli.net/2025/05/22/qgKPJS1vG8Br6WC.png><h3 id=分治法><a class=headerlink href=#分治法 title=分治法></a>分治法</h3><p>顾名思义，分治问题由“分”（）和“治”（ 表达式问题 ）两部分组成，通过把原问题分为子 问题，再将子问题进行处理合并，从而实现对原问题的求解。我们在排序章节展示的归并排序就 是典型的分治问题，其中“分”即为把大数组平均分成两个小数组，通过递归实现，最终我们会 得到多个长度为的子数组“治”即为把已经排好序的两个小数组合成为一个排好序的大数组， 从长度为的子数组开始，最终合成一个大数组<p>另外，自上而下的分治可以和memoization 结合，避免重复遍历相同的子问题。如果方便推 导，也可以换用自下而上的动态规划方法求解<h3 id=树><a class=headerlink href=#树 title=树></a>树</h3><p>作为（单）链表的升级版，我们通常接触的树都是二叉树, 两个子节点；且除非题目说明，默认树中不存在循环结构。<h4 id=树的递归><a class=headerlink href=#树的递归 title=树的递归></a>树的递归</h4><p>在很多时候，树递归的写法与深度优先搜索的递归写法相同<h4 id=层次遍历><a class=headerlink href=#层次遍历 title=层次遍历></a>层次遍历</h4><p>我们可以使用广度优先搜索进行层次遍历。注意，不需要使用两个队列来分别存储当前层的 节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点 数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。<p>广度优先搜索 BFS（队列） 层序遍历、最短路径<h4 id=前中后序遍历><a class=headerlink href=#前中后序遍历 title=前中后序遍历></a>前中后序遍历</h4><p>前序遍历、中序遍历和后序遍历是三种利用深度优先搜索遍历二叉树的方式。它们是在对节 点访问的顺序有一点不同，其它完全相同。<p>前序遍历先遍历父结点，再遍历左结点，最后遍历右节点<p>中序遍历先遍历左节点，再遍历父结点，最后遍历右节点<p>后序遍历先遍历左节点，再遍历右结点，最后遍历父节点<div class=table-container><table><thead><tr><th>类别<th>技术名称<th>适用场景<tbody><tr><td>递归遍历<td>前中后序、分治法<td>查找、修改、统计<tr><td>迭代遍历<td>栈、队列模拟<td>非递归遍历、层序<tr><td>深度优先搜索<td>DFS（递归/栈）<td>路径、计算、构造<tr><td>广度优先搜索<td>BFS（队列）<td>层序遍历、最短路径<tr><td>动态规划<td>树形DP（子问题依赖）<td>子树结构最优解<tr><td>二叉搜索树性质<td>有序性、剪枝<td>查找区间、最近公共祖先<tr><td>Morris 遍历<td>O(1) 空间中序遍历<td>面试高频，省空间遍历</table></div><h2 id=数学问题><a class=headerlink href=#数学问题 title=数学问题></a>数学问题</h2><h3 id=公倍数与公因数><a class=headerlink href=#公倍数与公因数 title=公倍数与公因数></a>公倍数与公因数</h3><h3 id=质数><a class=headerlink href=#质数 title=质数></a>质数</h3><h3 id=数字处理><a class=headerlink href=#数字处理 title=数字处理></a>数字处理</h3><h4 id=Base7><a class=headerlink href=#Base7 title=Base7></a>Base7</h4><p>给定一个十进制整数，求它在七进制下的表示。<h4 id=Factorial-Trailing-Zeroes><a title="Factorial Trailing Zeroes" class=headerlink href=#Factorial-Trailing-Zeroes></a>Factorial Trailing Zeroes</h4><p>给定一个非负整数，判断它的阶乘结果的结尾有几个 0。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>trailingZeroes</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> count = <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>while</span> (n > <span class=number>0</span>) {</span><br><span class=line>        n /= <span class=number>5</span>;</span><br><span class=line>        count += n;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> count;</span><br><span class=line>}</span><br></pre></table></figure><h4 id=字符串相加><a class=headerlink href=#字符串相加 title=字符串相加></a>字符串相加</h4><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回。<p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式。<h3 id=随机取样><a class=headerlink href=#随机取样 title=随机取样></a>随机取样</h3><h4 id=打乱数组><a class=headerlink href=#打乱数组 title=打乱数组></a>打乱数组</h4><p>给定一个数组，要求实现两个指令函数。第一个函数“shuﬄe”可以随机打乱这个数组，第二个函数“reset”可以恢复原来的顺序。打乱后，数组的所有排列应该是 <strong>等可能</strong> 的。<p>主要是洗牌时存在正向洗牌和反向洗牌。<blockquote><p>采用经典的 <code>Fisher-Yates 洗牌算法</code>，原理是通过随机交换位置来实现随机打乱，有正向和反向两种写法</blockquote><p>正向洗牌就是对每个位置i,随机生成[0,n-i)的值pos,交换i与i+pos,使得所有交换都是随机的<p>反向洗牌是从后向前,对于每个位置i,生成从[0,i]的值pos,交换i与pos.<h4 id=按权重随机选择><a class=headerlink href=#按权重随机选择 title=按权重随机选择></a>按权重随机选择</h4><p>给你一个 <strong>下标从 0 开始</strong> 的正整数数组 <code>w</code> ，其中 <code>w[i]</code> 代表第 <code>i</code> 个下标的权重。<p>请你实现一个函数 <code>pickIndex</code> ，它可以 <strong>随机地</strong> 从范围 <code>[0, w.length - 1]</code> 内（含 <code>0</code> 和 <code>w.length - 1</code>）选出并返回一个下标。选取下标 <code>i</code> 的 <strong>概率</strong> 为 <code>w[i] / sum(w)</code><blockquote><p>先使用 partial_sum求前缀和（即到每个位置为止之前所有数字的和），这个结果对于正整数数组是单调递增的。每当需要采样时，我们可以先随机产生一个数字，然后使用二分法查找其在前缀和中的位置，以模拟加权采样的过程。这里的二分法可以用 lower_bound 实现。</blockquote><h4 id=链表随机节点><a class=headerlink href=#链表随机节点 title=链表随机节点></a>链表随机节点</h4><p>给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 <strong>被选中的概率一样</strong> 。<p>水库算法: <strong>水库算法（Reservoir Sampling）</strong> 是一种经典的<strong>在线（在线流式）随机采样算法</strong>，用于从<strong>未知或过大长度的输入流中等概率地随机采样 <code>k</code> 个元素</strong>，而<strong>不需要事先知道数据总量，也无需将所有数据存入内存</strong>。<ul><li>数据量太大，不能一次性全部加载到内存中（如海量日志、传感器数据、数据库行）；<li>你想从中<strong>随机选出一个或多个元素（等概率）</strong>；<li>数据是<strong>流式输入</strong>，你无法提前知道数据总量。</ul><p>遍历一次链表，在遍历到第 m 个节点时，有$\frac{1}{m}$的概率选择这个节点覆盖掉之前的节点选择。<h3 id=位运算><a class=headerlink href=#位运算 title=位运算></a>位运算</h3><p>利用二进制的一些特性，我们可以把位运算使用到更多问题上。<p>例如，我们可以利用二进制和位运算输出一个数组的所有子集。假设我们有一个长度为 n的数组，我们可以生成长度为 n 的所有二进制，1 表示选取该数字，0 表示不选取。这样我们就获得了 2^n^个子集。<h4 id=最大单词长度乘积><a class=headerlink href=#最大单词长度乘积 title=最大单词长度乘积></a>最大单词长度乘积</h4><p>给你一个字符串数组 <code>words</code> ，找出并返回 <code>length(words[i]) * length(words[j])</code> 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 <code>0</code><h4 id=比特位计数><a class=headerlink href=#比特位计数 title=比特位计数></a>比特位计数</h4><p>给定一个非负整数 n，求从 0 到 n 的所有数字的二进制表达中，分别有多少个 1。<blockquote><p>本题可以利用动态规划和位运算进行快速的求解。定义一个数组 dp，其中 dp[i] 表示数字 i 的二进制含有 1 的个数。对于第 i 个数字，如果它二进制的最后一位为 1，那么它含有 1 的个数则为 dp[i-1] + 1；如果它二进制的最后一位为 0，那么它含有 1 的个数和其算术右移结果相同，即 dp[i>>1]。</blockquote><h2 id=数据结构><a class=headerlink href=#数据结构 title=数据结构></a>数据结构</h2><p>在刷题时，我们几乎一定会用到各种数据结构来辅助我们解决问题，因此我们必须熟悉各种数据结构的特点。C++ STL 提供的数据结构包括（实际底层细节可能因编译器而异）：<ol><li>Sequence Containers：维持顺序的容器。<ol><li>vector：<code>动态数组</code>，是我们最常使用的数据结构之一，用于 <em>O</em>(1) 的随机读取。因为大部分算法的时间复杂度都会大于<em>O</em>(<em>n</em>)，因此我们经常新建 vector 来存储各种数据或中间变量。因为在尾部增删的复杂度是 <em>O</em>(1)，我们也可以把它当作 stack 来用。<li>list：<code>双向链表</code>，也可以当作 stack 和 queue 来使用。由于 LeetCode 的题目多用 Node 来表示链表，且链表不支持快速随机读取，因此我们很少用到这个数据结构。一个例外是经典的 LRU 问题，我们需要利用链表的特性来解决，我们在后文会遇到这个问题。<li>deque：双端队列，这是一个非常强大的数据结构，既支持 <em>O</em>(1) 随机读取，又支持 O(1) 时间的头部增删和尾部增删（因此可以当作 stack 和 queue 来使用），不过有一定的额外开销。也可以用来近似一个双向链表来使用。<li>array：固定大小的数组，一般在刷题时我们不使用。<li>forward_list：单向链表，一般在刷题时我们不使用。</ol><li>Container Adaptors：基于其它容器实现的容器。<ol><li>stack：<code>后入先出（LIFO）的数据结构</code>，默认基于 deque 实现。stack 常用于深度优先搜索、一些字符串匹配问题以及单调栈问题。<li>queue:<code>先入先出（FIFO）的数据结构</code>，默认基于 deque 实现。queue 常用于广度优先搜索。<li>priority_queue：<code>优先队列（最大值先出的数据结构）</code>，默认基于 vector 实现堆结构。它可以在 O(nlog⁡n)<em>O</em>(<em>n</em>log<em>n</em>) 的时间排序数组，<em>O</em>(log<em>n</em>) 的时间插入任意值，O(1)的时间获得最大值，O(log⁡n)<em>O</em>(log<em>n</em>) 的时间删除最大值。priority_queue 常用于维护数据结构并快速获取最大值，并且可以自定义比较函数；比如通过存储负值或者更改比小函数为比大函数，即可实现最小值先出。</ol><li>Ordered Associative Containers：有序关联容器。<ol><li>set：有序集合，元素不可重复，底层实现默认为红黑树，即一种特殊的二叉查找树（BST）。它可以在 O(nlog⁡n)<em>O</em>(<em>n</em>log<em>n</em>) 的时间排序数组，O(log⁡n)<em>O</em>(log<em>n</em>) 的时间插入、删除、查找任意值，O(log⁡n)<em>O</em>(log<em>n</em>) 的时间获得最小或最大值。这里注意，set 和 priority_queue 都可以用于维护数据结构并快速获取最大最小值，但是它们的时间复杂度和功能略有区别，如 priority_queue 默认不支持删除任意值，而 set 获得最大或最小值的时间复杂度略高，具体使用哪个根据需求而定。<li>multiset：支持重复元素的 set。<li>map：<code>有序映射或有序表</code>，在 set 的基础上加上映射关系，可以对每个元素 key 存一个值 value。<li>multimap：支持重复元素的 map。</ol><li>Unordered Associative Containers：无序关联容器。<ol><li>unordered_set：<code>哈希集合</code>，可以在<em>O</em>(1) 的时间快速插入、查找、删除元素，常用于快速的查询一个元素是否在这个容器内。<li>unordered_multiset：支持重复元素的 unordered_set。<li>unordered_map：<code>哈希映射或哈希表</code>，在 unordered_set 的基础上加上映射关系，可以对每一个元素 key 存一个值 value。在某些情况下，如果 key 的范围已知且较小，我们也可以用 vector 代替 unordered_map，用位置表示 key，用每个位置的值表示 value。<li>unordered_multimap：支持重复元素的 unordered_map</ol></ol><h3 id=数组><a class=headerlink href=#数组 title=数组></a>数组</h3><h4 id=找到所有数组中消失的数字><a class=headerlink href=#找到所有数组中消失的数字 title=找到所有数组中消失的数字></a>找到所有数组中消失的数字</h4><p>给你一个含 <code>n</code> 个整数的数组 <code>nums</code> ，其中 <code>nums[i]</code> 在区间 <code>[1, n]</code> 内。请你找出所有在 <code>[1, n]</code> 范围内但没有出现在 <code>nums</code> 中的数字，并以数组的形式返回结果。<blockquote><p>利用数组这种数据结构建立 n 个桶，把所有重复出现的位置进行标记，然后再遍历一遍数组，即可找到没有出现过的数字。进一步地，我们可以直接对原数组进行标记：把重复出现的数字-1在原数组的位置设为负数（这里-1 的目的是把 1 到 n 的数字映射到 0 到 n-1 的位置），最后仍然为正数的位置 +1 即为没有出现过的数。</blockquote><h4 id=旋转图像><a class=headerlink href=#旋转图像 title=旋转图像></a>旋转图像</h4><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。<p>可以先对角线旋转再水平翻转.<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTvector></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTalgorithm></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>rotate</span><span class=params>(std::vector&LTstd::vector<<span class=keyword>int</span>>>& matrix)</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> n = matrix.<span class=built_in>size</span>();</span><br><span class=line></span><br><span class=line>    <span class=comment>// 1. 转置：对角线翻转</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < n; ++i) {</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> j = i + <span class=number>1</span>; j < n; ++j) {</span><br><span class=line>            std::<span class=built_in>swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 2. 每行翻转（水平翻转）</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < n; ++i) {</span><br><span class=line>        std::<span class=built_in>reverse</span>(matrix[i].<span class=built_in>begin</span>(), matrix[i].<span class=built_in>end</span>());</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><h4 id=769最多能完成排序的块><a class=headerlink href=#769最多能完成排序的块 title=769最多能完成排序的块></a>769最多能完成排序的块</h4><p>给定一个长度为 <code>n</code> 的整数数组 <code>arr</code> ，它表示在 <code>[0, n - 1]</code> 范围内的整数的排列。<p>我们将 <code>arr</code> 分割成若干 <strong>块</strong> (即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。<p>返回数组能分成的最多块数量。<h2 id=栈与队列><a class=headerlink href=#栈与队列 title=栈与队列></a>栈与队列</h2><h3 id=232-使用栈实现队列><a title="232 使用栈实现队列" class=headerlink href=#232-使用栈实现队列></a>232 使用栈实现队列</h3><p>可以用两个栈来实现一个队列：因为我们需要得到先入先出的结果，所以必定要通过一个额外栈翻转一次数组。这个翻转过程既可以在插入时完成，也可以在取值时完成。我们这里展示在取值时完成的写法。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>MyQueue</span> {</span></span><br><span class=line>   <span class=keyword>public</span>:</span><br><span class=line>    <span class=built_in>MyQueue</span>() {}</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>push</span><span class=params>(<span class=keyword>int</span> x)</span> </span>{ s_in_.<span class=built_in>push</span>(x); }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>pop</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=built_in>in2out</span>();</span><br><span class=line>        <span class=keyword>int</span> x = s_out_.<span class=built_in>top</span>();</span><br><span class=line>        s_out_.<span class=built_in>pop</span>();</span><br><span class=line>        <span class=keyword>return</span> x;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>peek</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=built_in>in2out</span>();</span><br><span class=line>        <span class=keyword>return</span> s_out_.<span class=built_in>top</span>();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>empty</span><span class=params>()</span> </span>{ <span class=keyword>return</span> s_in_.<span class=built_in>empty</span>() && s_out_.<span class=built_in>empty</span>(); }</span><br><span class=line></span><br><span class=line>   <span class=keyword>private</span>:</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>in2out</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (!s_out_.<span class=built_in>empty</span>()) {</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>while</span> (!s_in_.<span class=built_in>empty</span>()) {</span><br><span class=line>            <span class=keyword>int</span> x = s_in_.<span class=built_in>top</span>();</span><br><span class=line>            s_in_.<span class=built_in>pop</span>();</span><br><span class=line>            s_out_.<span class=built_in>push</span>(x);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    stack<<span class=keyword>int</span>> s_in_, s_out_;</span><br><span class=line>};</span><br></pre></table></figure><h3 id=155-最小栈><a title="155 最小栈" class=headerlink href=#155-最小栈></a>155 最小栈</h3><p>设计一个最小栈，除了需要支持常规栈的操作外，还需要支持在 <em>O</em>(1) 时间内查询栈内最小值的功能。<p>可以额外建立一个新栈，栈顶表示原栈里所有值的最小值。每当在原栈里插入一个数字时，若该数字小于等于新栈栈顶，则表示这个数字在原栈里是最小值，我们将其同时插入新栈内。每当从原栈里取出一个数字时，若该数字等于新栈栈顶，则表示这个数是原栈里的最小值之一，我们同时取出新栈栈顶的值。<p>一个写起来更简单但是时间复杂度略高的方法是，我们每次插入原栈时，都向新栈插入一次原栈里所有值的最小值（新栈栈顶和待插入值中小的那一个）；每次从原栈里取出数字时，同样取出新栈的栈顶。这样可以避免判断，但是每次都要插入和取出。我们这里只展示第一种写法。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br></pre><td class=code><pre><span class=line><span class=comment>/*</span></span><br><span class=line><span class=comment> * @lc app=leetcode.cn id=155 lang=cpp</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * [155] 最小栈</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTlimits></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTmap></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstack></span></span></span><br><span class=line></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line><span class=comment>// @lc code=start</span></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>MinStack</span> {</span></span><br><span class=line><span class=keyword>private</span>:</span><br><span class=line>  stack<<span class=keyword>int</span>> _nums;</span><br><span class=line>  stack<<span class=keyword>int</span>> _minNums;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>  <span class=built_in>MinStack</span>() {}</span><br><span class=line></span><br><span class=line>  <span class=function><span class=keyword>void</span> <span class=title>push</span><span class=params>(<span class=keyword>int</span> val)</span> </span>{</span><br><span class=line>    _nums.<span class=built_in>push</span>(val);</span><br><span class=line>    <span class=keyword>if</span> (_minNums.<span class=built_in>empty</span>() || val <= _minNums.<span class=built_in>top</span>()) {</span><br><span class=line>      _minNums.<span class=built_in>push</span>(val);</span><br><span class=line>    }</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=function><span class=keyword>void</span> <span class=title>pop</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>auto</span> n = _nums.<span class=built_in>top</span>();</span><br><span class=line>    _nums.<span class=built_in>pop</span>();</span><br><span class=line>    <span class=keyword>if</span> (!_minNums.<span class=built_in>empty</span>() && _minNums.<span class=built_in>top</span>() == n) {</span><br><span class=line>      _minNums.<span class=built_in>pop</span>();</span><br><span class=line>    }</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=function><span class=keyword>int</span> <span class=title>top</span><span class=params>()</span> </span>{ <span class=keyword>return</span> _nums.<span class=built_in>top</span>(); }</span><br><span class=line></span><br><span class=line>  <span class=function><span class=keyword>int</span> <span class=title>getMin</span><span class=params>()</span> </span>{ <span class=keyword>return</span> _minNums.<span class=built_in>top</span>(); }</span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Your MinStack object will be instantiated and called as such:</span></span><br><span class=line><span class=comment> * MinStack* obj = new MinStack();</span></span><br><span class=line><span class=comment> * obj->push(val);</span></span><br><span class=line><span class=comment> * obj->pop();</span></span><br><span class=line><span class=comment> * int param_3 = obj->top();</span></span><br><span class=line><span class=comment> * int param_4 = obj->getMin();</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=comment>// @lc code=end</span></span><br><span class=line></span><br></pre></table></figure><h3 id=20-有效的括号><a title="20 有效的括号" class=headerlink href=#20-有效的括号></a>20 有效的括号</h3><p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。<p>有效字符串需满足：<ol><li>左括号必须用相同类型的右括号闭合。<li>左括号必须以正确的顺序闭合。<li>每个右括号都有一个对应的相同类型的左括号。</ol><h3 id=739-每日温度><a title="739 每日温度" class=headerlink href=#739-每日温度></a>739 每日温度</h3><blockquote><p><code>单调栈</code>通过维持栈内值的单调递增（递减）性，在整体 <em>O</em>(<em>n</em>) 的时间内处理需要大小比较的问题。</blockquote><p>给定每天的温度，求对于每一天需要等几天才可以等到更暖和的一天。如果该天之后不存在更暖和的天气，则记为 0。<p>输入是一个一维整数数组，输出是同样长度的整数数组，表示对于每天需要等待多少天。<blockquote><p>可以维持一个单调递减的栈，表示每天的温度；为了方便计算天数差，我们这里存放位置（即日期）而非温度本身。我们从左向右遍历温度数组，对于每个日期 p，如果 p 的温度比栈顶存储位置 q 的温度高，则我们取出 q，并记录 q 需要等待的天数为 p − q；我们重复这一过程，<strong>直到 p 的温度小于等于栈顶存储位置的温度（或空栈）时，我们将 p 插入栈顶，然后考虑下一天。</strong>在这个过程中，栈内数组永远保持单调递减，避免了使用排序进行比较。最后若栈内剩余一些日期，则说明它们之后都没有出现更暖和的日期。</blockquote><h2 id=优先队列><a class=headerlink href=#优先队列 title=优先队列></a>优先队列</h2><p><code>优先队列</code>（priority queue）可以在 O(1)<em>O</em>(1) 时间内获得最大值，并且可以在 O(log n) 时间内取出最大值或插入任意值。<p>优先队列常常用堆（heap）来实现。堆是一个完全二叉树，其每个节点的值总是大于等于子节点的值。实际实现堆时，我们通常用一个数组而不是用指针建立一个树。这是因为堆是完全二叉树，所以用数组表示时，位置 i 的节点的父节点位置一定为 (i-1)/2，而它的两个子节点的位置又一定分别为 2i+1 和 2i+2。<p><strong>满二叉树 (Full Binary Tree):</strong> 所有叶子节点都在同一层，并且每个非叶子节点都有两个子节点。满二叉树<strong>一定是</strong>完全二叉树。<p>完全二叉树是在满足以下两个条件的情况下，对<strong>满二叉树</strong>概念的一种放宽：<ol><li><strong>除最后一层外，所有层都是完全充满的。</strong><li><strong>最后一层的节点都集中在最左边。</strong></ol><p>这意味着：<ul><li>如果一棵完全二叉树的深度为 <code>d</code>，那么在 <code>d-1</code> 层之前的每层（从第 1 层到第 <code>d-1</code> 层）都必须达到最大节点数（即 2^(层数−1) 个节点）。<li>在最后一层（第 <code>d</code> 层），节点可以不完全充满。但是，所有存在的节点都必须<strong>尽可能地靠左排列</strong>，不能出现中间有空缺的情况。换句话说，如果从左往右给最后一层的节点编号，那么所有编号小于等于实际节点总数的节点都必须存在，且不能有编号大于实际节点总数的节点。</ul><p>实现最大堆,核心是实现上浮和下沉操作<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Heap</span> {</span></span><br><span class=line>   <span class=keyword>public</span>:</span><br><span class=line>    <span class=built_in>Heap</span>() {}</span><br><span class=line>    <span class=comment>// 上浮。</span></span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>swim</span><span class=params>(<span class=keyword>int</span> pos)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> next_pos = (pos - <span class=number>1</span>) / <span class=number>2</span>;</span><br><span class=line>        <span class=keyword>while</span> (pos > <span class=number>0</span> && heap_[next_pos] < heap_[pos]) {</span><br><span class=line>            <span class=built_in>swap</span>(heap_[next_pos], heap_[pos]);</span><br><span class=line>            pos = next_pos;</span><br><span class=line>            next_pos = (pos - <span class=number>1</span>) / <span class=number>2</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 下沉。</span></span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>sink</span><span class=params>(<span class=keyword>int</span> pos)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> n = heap_.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> next_pos = <span class=number>2</span> * pos + <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>while</span> (next_pos < n) {</span><br><span class=line>            <span class=keyword>if</span> (next_pos < n - <span class=number>1</span> && heap_[next_pos] < heap_[next_pos + <span class=number>1</span>]) {</span><br><span class=line>                ++next_pos;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (heap_[pos] >= heap_[next_pos]) {</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=built_in>swap</span>(heap_[next_pos], heap_[pos]);</span><br><span class=line>            pos = next_pos;</span><br><span class=line>            next_pos = <span class=number>2</span> * pos + <span class=number>1</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 插入任意值：把新的数字放在最后一位，然后上浮。</span></span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>push</span><span class=params>(<span class=keyword>int</span> k)</span> </span>{</span><br><span class=line>        heap_.<span class=built_in>push_back</span>(k);</span><br><span class=line>        <span class=built_in>swim</span>(heap_.<span class=built_in>size</span>() - <span class=number>1</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 删除最大值：把最后一个数字挪到开头，然后下沉。</span></span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>pop</span><span class=params>()</span> </span>{</span><br><span class=line>        heap_[<span class=number>0</span>] = heap_.<span class=built_in>back</span>();</span><br><span class=line>        heap_.<span class=built_in>pop_back</span>();</span><br><span class=line>        <span class=built_in>sink</span>(<span class=number>0</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 获得最大值。</span></span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>top</span><span class=params>()</span> </span>{ <span class=keyword>return</span> heap_[<span class=number>0</span>]; }</span><br><span class=line></span><br><span class=line>   <span class=keyword>private</span>:</span><br><span class=line>    vector<<span class=keyword>int</span>> heap_;</span><br><span class=line>};</span><br></pre></table></figure><h4 id=23-merge-k-sorted-lists><a title="23 merge k sorted lists" class=headerlink href=#23-merge-k-sorted-lists></a>23 merge k sorted lists</h4><p>给定 k 个增序的链表，试将它们合并成一条增序链表。<p>输入是一个一维数组，每个位置存储链表的头节点；输出是一条链表。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=function>ListNode* <span class=title>mergeKLists</span><span class=params>(vector&LTListNode*>& lists)</span> </span>{</span><br><span class=line>    <span class=keyword>auto</span> comp = [](ListNode* l1, ListNode* l2) { <span class=keyword>return</span> l1->val > l2->val; };</span><br><span class=line>    priority_queue&LTListNode*, vector&LTListNode*>, <span class=keyword>decltype</span>(comp)> pq;</span><br><span class=line>    <span class=keyword>for</span> (ListNode* l : lists) {</span><br><span class=line>        <span class=keyword>if</span> (l) {</span><br><span class=line>            pq.<span class=built_in>push</span>(l);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    ListNode *dummy = <span class=keyword>new</span> <span class=built_in>ListNode</span>(<span class=number>0</span>), *cur = dummy;</span><br><span class=line>    <span class=keyword>while</span> (!pq.<span class=built_in>empty</span>()) {</span><br><span class=line>        cur->next = pq.<span class=built_in>top</span>();</span><br><span class=line>        pq.<span class=built_in>pop</span>();</span><br><span class=line>        cur = cur->next;</span><br><span class=line>        <span class=keyword>if</span> (cur->next) {</span><br><span class=line>            pq.<span class=built_in>push</span>(cur->next);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> dummy->next;</span><br><span class=line>}</span><br></pre></table></figure><h3 id=双端队列><a class=headerlink href=#双端队列 title=双端队列></a>双端队列</h3><h4 id=滑动窗口最大值><a class=headerlink href=#滑动窗口最大值 title=滑动窗口最大值></a>滑动窗口最大值</h4><p>给定一个整数数组和一个滑动窗口大小，求在这个窗口的滑动过程中，每个时刻其包含的最大值。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre><td class=code><pre><span class=line><span class=comment>/*</span></span><br><span class=line><span class=comment> * @lc app=leetcode.cn id=239 lang=cpp</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * [239] 滑动窗口最大值</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line></span><br><span class=line><span class=comment>// @lc code=start</span></span><br><span class=line>#include &LTalgorithm></span><br><span class=line>#include &LTlist></span><br><span class=line>#include &LTvector></span><br><span class=line></span><br><span class=line>using namespace std;</span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> </span>{</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>  <span class=function>vector<<span class=keyword>int</span>> <span class=title>maxSlidingWindow</span><span class=params>(vector<<span class=keyword>int</span>> &nums, <span class=keyword>int</span> k)</span> </span>{</span><br><span class=line>    list<<span class=keyword>int</span>> r;</span><br><span class=line>    vector<<span class=keyword>int</span>> result;</span><br><span class=line></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < nums.size() ; ++i) {</span><br><span class=line>      <span class=comment>// 如果被排除的索引等于双端队列最左端值</span></span><br><span class=line>      <span class=keyword>if</span> (!r.empty() && i - k == r.front()) {</span><br><span class=line>        r.pop_front();</span><br><span class=line>      }</span><br><span class=line>      <span class=comment>// 如果元素大于双端队列最右端对应索引的值</span></span><br><span class=line>      <span class=keyword>while</span> (!r.empty() && nums.at(i) > nums.at(r.back())) {</span><br><span class=line>        r.pop_back();</span><br><span class=line>      }</span><br><span class=line>      r.push_back(i);</span><br><span class=line>      <span class=keyword>if</span> (i >= k - <span class=number>1</span>) {</span><br><span class=line>        result.push_back(nums.at(r.front()));</span><br><span class=line>      }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> result;</span><br><span class=line>  }</span><br><span class=line>};</span><br><span class=line><span class=comment>// @lc code=end</span></span><br><span class=line></span><br></pre></table></figure><h3 id=哈希表><a class=headerlink href=#哈希表 title=哈希表></a>哈希表</h3><h4 id=149-最长连续序列><a title="149 最长连续序列" class=headerlink href=#149-最长连续序列></a>149 最长连续序列</h4><p>给定一个整数数组，求这个数组中的数字可以组成的最长连续序列有多长。<p>输入一个整数数组，输出一个整数，表示连续序列的长度。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>Input: [100, 4, 200, 1, 3, 2]</span><br><span class=line>Output: 4</span><br></pre></table></figure><p>在这个样例中，最长连续序列是 [1,2,3,4]。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>longestConsecutive</span><span class=params>(vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>    <span class=function>unordered_set<<span class=keyword>int</span>> <span class=title>cache</span><span class=params>(nums.begin(), nums.end())</span></span>;</span><br><span class=line>    <span class=keyword>int</span> max_len = <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>while</span> (!cache.<span class=built_in>empty</span>()) {</span><br><span class=line>        <span class=keyword>int</span> cur = *(cache.<span class=built_in>begin</span>());</span><br><span class=line>        cache.<span class=built_in>erase</span>(cur);</span><br><span class=line>        <span class=keyword>int</span> l = cur - <span class=number>1</span>, r = cur + <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>while</span> (cache.<span class=built_in>contains</span>(l)) {</span><br><span class=line>            cache.<span class=built_in>erase</span>(l--);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>while</span> (cache.<span class=built_in>contains</span>(r)) {</span><br><span class=line>            cache.<span class=built_in>erase</span>(r++);</span><br><span class=line>        }</span><br><span class=line>        max_len = <span class=built_in>max</span>(max_len, r - l - <span class=number>1</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> max_len;</span><br><span class=line>}</span><br></pre></table></figure><h4 id=线上最多有多少点><a class=headerlink href=#线上最多有多少点 title=线上最多有多少点></a>线上最多有多少点</h4><p>给定一些二维坐标中的点，求同一条线上最多有多少点。<p>对于每个点，我们对其它点建立哈希表，统计同一斜率的点一共有多少个。这里利用的原理是，一条线可以由一个点和斜率而唯一确定。另外也要考虑斜率不存在和重复坐标的情况。<p>本题也利用了一个小技巧：在遍历每个点时，对于数组中位置 i 的点，我们只需要考虑 i 之后的点即可，因为 i 之前的点已经考虑过 i 了。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>maxPoints</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& points)</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> max_count = <span class=number>0</span>, n = points.<span class=built_in>size</span>();</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < n; ++i) {</span><br><span class=line>        unordered_map<<span class=keyword>double</span>, <span class=keyword>int</span>> cache;  <span class=comment>// <斜率, 点个数></span></span><br><span class=line>        <span class=keyword>int</span> same_xy = <span class=number>1</span>, same_y = <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> j = i + <span class=number>1</span>; j < n; ++j) {</span><br><span class=line>            <span class=keyword>if</span> (points[i][<span class=number>1</span>] == points[j][<span class=number>1</span>]) {</span><br><span class=line>                ++same_y;</span><br><span class=line>                <span class=keyword>if</span> (points[i][<span class=number>0</span>] == points[j][<span class=number>0</span>]) {</span><br><span class=line>                    ++same_xy;</span><br><span class=line>                }</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=keyword>double</span> dx = points[i][<span class=number>0</span>] - points[j][<span class=number>0</span>],</span><br><span class=line>                       dy = points[i][<span class=number>1</span>] - points[j][<span class=number>1</span>];</span><br><span class=line>                ++cache[dx / dy];</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        max_count = <span class=built_in>max</span>(max_count, same_y);</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span> item : cache) {</span><br><span class=line>            max_count = <span class=built_in>max</span>(max_count, same_xy + item.second);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> max_count;</span><br><span class=line>}</span><br></pre></table></figure><h3 id=多重映射><a class=headerlink href=#多重映射 title=多重映射></a>多重映射</h3><p>给你一份航线列表 <code>tickets</code> ，其中 <code>tickets[i] = [fromi, toi]</code> 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。<p>所有这些机票都属于一个从 <code>JFK</code>（肯尼迪国际机场）出发的先生，所以该行程必须从 <code>JFK</code> 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。<ul><li>例如，行程 <code>["JFK", "LGA"]</code> 与 <code>["JFK", "LGB"]</code> 相比就更小，排序更靠前。</ul><p>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。<p>本题可以先用哈希表记录起止机场，其中键是起始机场，值是一个多重（有序）集合，表示对应的终止机场。因为一个人可能坐过重复的线路，所以我们需要使用多重集合储存重复值。储存完成之后，我们可以利用栈/DFS 来恢复从终点到起点飞行的顺序，再将结果逆序得到从起点到终点的顺序。<p>因为 Python 没有默认的多重（有序）集合实现，我们可以直接存储一个数组，然后进行排序。也可以使用 Counter 结构，每次查找下一个机场时，返回 key 值最小的那个。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br></pre><td class=code><pre><span class=line><span class=comment>/*</span></span><br><span class=line><span class=comment> * @lc app=leetcode.cn id=332 lang=cpp</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * [332] 重新安排行程</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line></span><br><span class=line><span class=comment>// @lc code=start</span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTalgorithm></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTset></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstack></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunordered_map></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTvector></span></span></span><br><span class=line></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>  <span class=function>vector&LTstring> <span class=title>findItinerary</span><span class=params>(vector&LTvector&LTstring>> &tickets)</span> </span>{</span><br><span class=line>    unordered_map&LTstring, multiset&LTstring>> m_tickets;</span><br><span class=line>    <span class=comment>// 建立多重映射</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>auto</span> &tick : tickets) {</span><br><span class=line>      m_tickets[tick[<span class=number>0</span>]].<span class=built_in>insert</span>(tick[<span class=number>1</span>]);</span><br><span class=line>    }</span><br><span class=line>    stack&LTstring> s;</span><br><span class=line>    s.<span class=built_in>push</span>(<span class=string>"JFK"</span>);</span><br><span class=line>    vector&LTstring> result;</span><br><span class=line>    <span class=keyword>while</span> (!s.<span class=built_in>empty</span>()) {</span><br><span class=line>      <span class=keyword>auto</span> t = s.<span class=built_in>top</span>();</span><br><span class=line>      <span class=keyword>if</span> (m_tickets[t].<span class=built_in>empty</span>()) {</span><br><span class=line>        <span class=comment>// 到达最后一个点</span></span><br><span class=line>        result.<span class=built_in>push_back</span>(t);</span><br><span class=line>        s.<span class=built_in>pop</span>();</span><br><span class=line>      } <span class=keyword>else</span> {</span><br><span class=line>        <span class=comment>// 继续向下一个点</span></span><br><span class=line>        <span class=keyword>auto</span> r = *m_tickets[t].<span class=built_in>begin</span>();</span><br><span class=line>        s.<span class=built_in>push</span>(r);</span><br><span class=line>        m_tickets[t].<span class=built_in>erase</span>(m_tickets[t].<span class=built_in>begin</span>());</span><br><span class=line>      }</span><br><span class=line>    }</span><br><span class=line>    <span class=built_in>reverse</span>(result.<span class=built_in>begin</span>(), result.<span class=built_in>end</span>());</span><br><span class=line>    <span class=keyword>return</span> result;</span><br><span class=line>  }</span><br><span class=line>};</span><br><span class=line><span class=comment>// @lc code=end</span></span><br><span class=line></span><br></pre></table></figure><h3 id=前缀二分和-二分图><a title="前缀二分和 二分图" class=headerlink href=#前缀二分和-二分图></a>前缀二分和 二分图</h3><h4 id=304-2D范围和查询><a title="304 2D范围和查询" class=headerlink href=#304-2D范围和查询></a>304 2D范围和查询</h4><p>设计一个数据结构，使得其能够快速查询给定矩阵中，任意两个位置包围的长方形中所有数字的和。<h4 id=和为k的子数组><a class=headerlink href=#和为k的子数组 title=和为k的子数组></a>和为k的子数组</h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。<p>子数组是数组中元素的连续非空序列。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>  <span class=function><span class=keyword>int</span> <span class=title>subarraySum</span><span class=params>(vector<<span class=keyword>int</span>> &nums, <span class=keyword>int</span> k)</span> </span>{</span><br><span class=line>    <span class=comment>// 前缀和</span></span><br><span class=line>    unordered_map<<span class=keyword>int</span>, <span class=keyword>int</span>> prefixSum; <span class=comment>// 前缀和与对应出现次数</span></span><br><span class=line>    <span class=keyword>int</span> cursum = <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>int</span> count{};</span><br><span class=line>    prefixSum[<span class=number>0</span>] = <span class=number>1</span>;</span><br><span class=line>    <span class=keyword>for</span>(<span class=keyword>auto</span> n:nums) {</span><br><span class=line>        cursum+=n;</span><br><span class=line>        count += prefixSum[cursum-k];</span><br><span class=line>        ++prefixSum[cursum];</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> count;</span><br><span class=line>  }</span><br><span class=line>};</span><br></pre></table></figure><h2 id=字符串><a class=headerlink href=#字符串 title=字符串></a>字符串</h2><h2 id=std-string-的常见操作><a title="std::string 的常见操作" class=headerlink href=#std-string-的常见操作></a><code>std::string</code> 的常见操作</h2><h3 id=1-创建和初始化><a title="1. 创建和初始化" class=headerlink href=#1-创建和初始化></a>1. 创建和初始化</h3><ul><li><p><strong>默认初始化：</strong> 创建一个空字符串。</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>std::string s1; <span class=comment>// s1 是一个空字符串 ""</span></span><br></pre></table></figure><li><p><strong>字面量初始化：</strong> 使用字符串字面量初始化。</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>std::string s2 = <span class=string>"Hello"</span>;</span><br><span class=line><span class=function>std::string <span class=title>s3</span><span class=params>(<span class=string>"World"</span>)</span></span>;</span><br></pre></table></figure><li><p><strong>拷贝初始化：</strong> 从另一个 <code>std::string</code> 对象或 C 风格字符串拷贝。</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>std::string s4 = s2; <span class=comment>// s4 是 "Hello"</span></span><br><span class=line><span class=function>std::string <span class=title>s5</span><span class=params>(s3)</span></span>; <span class=comment>// s5 是 "World"</span></span><br><span class=line><span class=function>std::string <span class=title>s6</span><span class=params>(<span class=string>"C-style string"</span>)</span></span>; <span class=comment>// 从 const char* 初始化</span></span><br></pre></table></figure><li><p><strong>重复字符初始化：</strong> 创建包含指定数量相同字符的字符串。</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function>std::string <span class=title>s7</span><span class=params>(<span class=number>5</span>, <span class=string>'A'</span>)</span></span>; <span class=comment>// s7 是 "AAAAA"</span></span><br></pre></table></figure><li><p><strong>子串初始化：</strong> 从另一个字符串的子串初始化。</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>std::string s8 = <span class=string>"programming"</span>;</span><br><span class=line><span class=function>std::string <span class=title>s9</span><span class=params>(s8, <span class=number>3</span>, <span class=number>4</span>)</span></span>; <span class=comment>// 从索引 3 开始，取 4 个字符，s9 是 "gram"</span></span><br></pre></table></figure></ul><h3 id=2-访问字符><a title="2. 访问字符" class=headerlink href=#2-访问字符></a>2. 访问字符</h3><p><code>std::string</code> 的字符可以通过多种方式访问，它们都提供了边界检查或者迭代器访问。<ul><li><p><strong><code>[]</code> 运算符：</strong> 像访问数组一样访问字符。<strong>不进行边界检查</strong>，越界访问会导致未定义行为。</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>std::string str = <span class=string>"example"</span>;</span><br><span class=line><span class=keyword>char</span> c = str[<span class=number>0</span>]; <span class=comment>// c 是 'e'</span></span><br><span class=line>str[<span class=number>1</span>] = <span class=string>'X'</span>;    <span class=comment>// str 变为 "eXample"</span></span><br><span class=line><span class=comment>// char invalid_c = str[100]; // 危险！越界访问</span></span><br></pre></table></figure><li><p><strong><code>at()</code> 方法：</strong> 通过索引访问字符，并提供<strong>边界检查</strong>。如果索引越界，会抛出 <code>std::out_of_range</code> 异常。</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>std::string str = <span class=string>"example"</span>;</span><br><span class=line><span class=keyword>char</span> c = str.<span class=built_in>at</span>(<span class=number>0</span>); <span class=comment>// c 是 'e'</span></span><br><span class=line><span class=keyword>try</span> {</span><br><span class=line>    <span class=keyword>char</span> invalid_c = str.<span class=built_in>at</span>(<span class=number>100</span>); <span class=comment>// 抛出 std::out_of_range 异常</span></span><br><span class=line>} <span class=built_in><span class=keyword>catch</span></span> (<span class=keyword>const</span> std::out_of_range& e) {</span><br><span class=line>    std::cerr << <span class=string>"Error: "</span> << e.<span class=built_in>what</span>() << std::endl;</span><br><span class=line>}</span><br></pre></table></figure><li><p><strong><code>front()</code> / <code>back()</code> 方法：</strong> 访问第一个和最后一个字符。</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>std::string str = <span class=string>"abc"</span>;</span><br><span class=line><span class=keyword>char</span> first = str.<span class=built_in>front</span>(); <span class=comment>// 'a'</span></span><br><span class=line><span class=keyword>char</span> last = str.<span class=built_in>back</span>();  <span class=comment>// 'c'</span></span><br></pre></table></figure><li><p><strong>迭代器：</strong> 使用迭代器遍历字符串。</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>std::string str = <span class=string>"hello"</span>;</span><br><span class=line><span class=keyword>for</span> (<span class=keyword>char</span> ch : str) { <span class=comment>// C++11 范围 for 循环</span></span><br><span class=line>    std::cout << ch << <span class=string>" "</span>;</span><br><span class=line>} <span class=comment>// Output: h e l l o</span></span><br></pre></table></figure></ul><h3 id=3-容量和大小><a title="3. 容量和大小" class=headerlink href=#3-容量和大小></a>3. 容量和大小</h3><ul><li><p><strong><code>length()</code> / <code>size()</code>：</strong> 返回字符串中字符的数量（不包括空终止符）。两者功能相同。</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>std::string s = <span class=string>"test"</span>;</span><br><span class=line><span class=keyword>size_t</span> len = s.<span class=built_in>length</span>(); <span class=comment>// len 是 4</span></span><br><span class=line><span class=keyword>size_t</span> sz = s.<span class=built_in>size</span>();   <span class=comment>// sz 也是 4</span></span><br></pre></table></figure><li><p><strong><code>empty()</code>：</strong> 检查字符串是否为空。</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>std::string s1 = <span class=string>""</span>;</span><br><span class=line>std::string s2 = <span class=string>"abc"</span>;</span><br><span class=line><span class=keyword>bool</span> b1 = s1.<span class=built_in>empty</span>(); <span class=comment>// true</span></span><br><span class=line><span class=keyword>bool</span> b2 = s2.<span class=built_in>empty</span>(); <span class=comment>// false</span></span><br></pre></table></figure><li><p><strong><code>capacity()</code>：</strong> 返回当前字符串能够存储的字符数量（不重新分配内存）。<code>capacity()</code> 可能大于 <code>size()</code>。</p><li><p><strong><code>reserve(n)</code>：</strong> 请求字符串预分配至少能容纳 <code>n</code> 个字符的内存空间。可以提高性能，避免频繁的重新分配。</p><li><p><strong><code>shrink_to_fit()</code> (C++11)：</strong> 请求减少字符串的容量以适应其当前大小。</p></ul><h3 id=4-字符串修改><a title="4. 字符串修改" class=headerlink href=#4-字符串修改></a>4. 字符串修改</h3><ul><li><p><strong><code>+=</code> 运算符 / <code>append()</code>：</strong> 在字符串末尾追加内容。</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>std::string s = <span class=string>"Hello"</span>;</span><br><span class=line>s += <span class=string>" World!"</span>; <span class=comment>// s 是 "Hello World!"</span></span><br><span class=line>s.<span class=built_in>append</span>(<span class=string>" C++"</span>); <span class=comment>// s 是 "Hello World! C++"</span></span><br></pre></table></figure><li><p><strong><code>push_back()</code> / <code>pop_back()</code> (C++11)：</strong> 在末尾添加或移除单个字符。</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>std::string s = <span class=string>"abc"</span>;</span><br><span class=line>s.<span class=built_in>push_back</span>(<span class=string>'d'</span>); <span class=comment>// s 是 "abcd"</span></span><br><span class=line>s.<span class=built_in>pop_back</span>();     <span class=comment>// s 是 "abc"</span></span><br></pre></table></figure><li><p><strong><code>insert()</code>：</strong> 在指定位置插入内容。</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>std::string s = <span class=string>"World"</span>;</span><br><span class=line>s.<span class=built_in>insert</span>(<span class=number>0</span>, <span class=string>"Hello "</span>); <span class=comment>// s 是 "Hello World"</span></span><br></pre></table></figure><li><p><strong><code>erase()</code>：</strong> 移除指定位置或范围的字符。</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>std::string s = <span class=string>"Hello World"</span>;</span><br><span class=line>s.<span class=built_in>erase</span>(<span class=number>5</span>, <span class=number>6</span>); <span class=comment>// 从索引 5 开始删除 6 个字符，s 变为 "Hello"</span></span><br></pre></table></figure><li><p><strong><code>replace()</code>：</strong> 替换指定范围的字符。</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>std::string s = <span class=string>"Hello World"</span>;</span><br><span class=line>s.<span class=built_in>replace</span>(<span class=number>6</span>, <span class=number>5</span>, <span class=string>"C++"</span>); <span class=comment>// 从索引 6 开始替换 5 个字符为 "C++"，s 变为 "Hello C++"</span></span><br></pre></table></figure><li><p><strong><code>clear()</code>：</strong> 清空字符串内容。</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>std::string s = <span class=string>"test"</span>;</span><br><span class=line>s.<span class=built_in>clear</span>(); <span class=comment>// s 变为空字符串 ""</span></span><br></pre></table></figure></ul><h3 id=5-查找和比较><a title="5. 查找和比较" class=headerlink href=#5-查找和比较></a>5. 查找和比较</h3><ul><li><p><strong><code>find()</code>：</strong> 查找子串或字符第一次出现的位置。返回 <code>std::string::npos</code> 表示未找到。</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>std::string s = <span class=string>"apple banana apple"</span>;</span><br><span class=line><span class=keyword>size_t</span> pos1 = s.<span class=built_in>find</span>(<span class=string>"apple"</span>);    <span class=comment>// pos1 是 0</span></span><br><span class=line><span class=keyword>size_t</span> pos2 = s.<span class=built_in>find</span>(<span class=string>"orange"</span>);   <span class=comment>// pos2 是 std::string::npos</span></span><br><span class=line><span class=keyword>size_t</span> pos3 = s.<span class=built_in>find</span>(<span class=string>"apple"</span>, <span class=number>1</span>); <span class=comment>// 从索引 1 开始查找，pos3 是 13</span></span><br></pre></table></figure><li><p><strong><code>rfind()</code>：</strong> 查找子串或字符最后一次出现的位置。</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>std::string s = <span class=string>"apple banana apple"</span>;</span><br><span class=line><span class=keyword>size_t</span> pos = s.<span class=built_in>rfind</span>(<span class=string>"apple"</span>); <span class=comment>// pos 是 13</span></span><br></pre></table></figure><li><p><strong><code>compare()</code>：</strong> 比较两个字符串或子串。</p> <ul><li>返回 0 表示相等。<li>返回负数表示当前字符串小于参数字符串。<li>返回正数表示当前字符串大于参数字符串。</ul> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>std::string s1 = <span class=string>"abc"</span>;</span><br><span class=line>std::string s2 = <span class=string>"abd"</span>;</span><br><span class=line><span class=keyword>int</span> result = s1.<span class=built_in>compare</span>(s2); <span class=comment>// result < 0</span></span><br></pre></table></figure><li><p><strong><code>==</code>, <code>!=</code>, <code><</code>, <code><=</code>, <code>></code>, <code>>=</code> 运算符：</strong> 进行字典序比较。</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>std::string s1 = <span class=string>"apple"</span>;</span><br><span class=line>std::string s2 = <span class=string>"banana"</span>;</span><br><span class=line><span class=keyword>bool</span> b = (s1 < s2); <span class=comment>// true</span></span><br></pre></table></figure></ul><h3 id=6-转换为-C-风格字符串><a title="6. 转换为 C 风格字符串" class=headerlink href=#6-转换为-C-风格字符串></a>6. 转换为 C 风格字符串</h3><ul><li><p><strong><code>c_str()</code>：</strong> 返回指向字符串内部 C 风格空终止字符数组的指针。<strong>不要修改返回的指针指向的内容，也不要存储它，因为 <code>std::string</code> 对象内部数据可能重新分配。</strong></p> <p>C++</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>std::string s = <span class=string>"Hello C++"</span>;</span><br><span class=line><span class=keyword>const</span> <span class=keyword>char</span>* c_str = s.<span class=built_in>c_str</span>(); <span class=comment>// 可以用于需要 const char* 的 C 函数</span></span><br><span class=line>std::cout << c_str << std::endl;</span><br></pre></table></figure><li><p><strong><code>data()</code> (C++11)：</strong> 返回指向字符串内部字符数组的指针。对于 C++11 之前的版本，<code>data()</code> 不保证空终止，但 C++11 及更高版本保证。同样，不应修改其内容。</p></ul><h3 id=7-子串提取><a title="7. 子串提取" class=headerlink href=#7-子串提取></a>7. 子串提取</h3><ul><li><p><strong><code>substr()</code>：</strong> 提取字符串的子串。</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>std::string s = <span class=string>"Hello World"</span>;</span><br><span class=line>std::string sub = s.<span class=built_in>substr</span>(<span class=number>6</span>, <span class=number>5</span>); <span class=comment>// 从索引 6 开始，提取 5 个字符，sub 是 "World"</span></span><br><span class=line>std::string rest = s.<span class=built_in>substr</span>(<span class=number>6</span>);   <span class=comment>// 从索引 6 到字符串末尾，rest 是 "World"</span></span><br></pre></table></figure></ul><h3 id=字符串比较><a class=headerlink href=#字符串比较 title=字符串比较></a>字符串比较</h3><h4 id=1249-移除无效括号><a title="1249 移除无效括号" class=headerlink href=#1249-移除无效括号></a>1249 移除无效括号</h4><p>给定一个包括字母和左右括号的字符串，求最少要移除多少个括号才能使其合法。<p>输入是一个字符串，输出是合法且长度最长的移除结果。<blockquote><p>因为只有一种括号，所以我们并不一定利用栈来统计，可以直接用一个临时变量统计在当前位置时，左括号比右括号多出现多少次。如果在遍历过程中出现负数，则需要移除多余的右括号。如果遍历结束时临时变量为正数，则需要从右到左移除多余的左括号。这里我们使用了一个小技巧，先标记待删除位置，最后一起移除。</blockquote><h3 id=字符串理解><a class=headerlink href=#字符串理解 title=字符串理解></a>字符串理解</h3><h4 id=227-基本计算器II><a title="227 基本计算器II" class=headerlink href=#227-基本计算器II></a>227 基本计算器II</h4><p>给定一个包含加减乘除整数运算的字符串，求其运算的整数值结果。如果除不尽则向 0 取整。<p>输入是一个合法的运算字符串，输出是一个整数，表示其运算结果。<blockquote><p>如果我们在字符串左边加上一个加号，可以证明其并不改变运算结果，且字符串可以分割成多个 < 一个运算符，一个数字 > 对子的形式；这样一来我们就可以从左往右处理了。由于乘除的优先级高于加减，因此我们需要使用一个中间变量来存储高优先度的运算结果。<p>例如 1+2<em>3/4-3,变为+1+2\</em>3/4-3 <+,1>,<+,2>,<*,3>…<p>此类型题也考察很多细节处理，如无运算符的情况，和多个空格的情况等等</blockquote><h2 id=链表><a class=headerlink href=#链表 title=链表></a>链表</h2><p>（单向）<code>链表</code>是由节点和指针构成的数据结构，每个节点存有一个值，和一个指向下一个节点的指针，因此很多链表问题可以用递归来处理。不同于数组，链表并不能直接获取任意节点的值，必须要通过指针找到该节点后才能获取其值。同理，在未遍历到链表结尾时，我们也无法知道链表的长度，除非依赖其他数据结构储存长度。LeetCode 默认的链表表示方法如下。<ul><li>C++<li>Python</ul><figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>ListNode</span> {</span></span><br><span class=line>    <span class=keyword>int</span> val;</span><br><span class=line>    ListNode *next;</span><br><span class=line>    <span class=built_in>ListNode</span>(<span class=keyword>int</span> x) : <span class=built_in>val</span>(x), <span class=built_in>next</span>(<span class=literal>nullptr</span>) {}</span><br><span class=line>};</span><br></pre></table></figure><p>由于在进行链表操作时，尤其是删除节点时，经常会因为对当前节点进行操作而导致内存或指针出现问题。有两个小技巧可以解决这个问题：一是尽量处理当前节点的下一个节点而非当前节点本身，二是建立一个虚拟节点 (dummy node)，使其指向当前链表的头节点，这样即使原链表所有节点全被删除，也会有一个 dummy 存在，返回 dummy->next 即可。<h4 id=206-翻转链表><a title="206 翻转链表" class=headerlink href=#206-翻转链表></a>206 翻转链表</h4><p>输入一个链表，输出该链表翻转后的结果。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>Input: 1->2->3->4->5->nullptr</span><br><span class=line>Output: 5->4->3->2->1->nullptr</span><br></pre></table></figure><p>链表翻转是非常基础也一定要掌握的技能。有两种写法——递归和非递归。建议同时掌握这两种写法。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>ListNode* <span class=title>reverseList</span><span class=params>(ListNode* head,ListNode* head_prev=<span class=literal>nullptr</span>)</span> </span>{</span><br><span class=line>        <span class=comment>//递归写法</span></span><br><span class=line>        <span class=keyword>if</span>(head == <span class=literal>nullptr</span>) {</span><br><span class=line>            <span class=keyword>return</span> head_prev;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 拿到下一个节点</span></span><br><span class=line>        ListNode* next = head->next;</span><br><span class=line>        <span class=comment>// 节点指向上一个节点 </span></span><br><span class=line>        head->next = head_prev;</span><br><span class=line>        <span class=keyword>return</span>  <span class=built_in>reverseList</span>(next,head);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=function>ListNode* <span class=title>reverseList</span><span class=params>(ListNode* head)</span> </span>{</span><br><span class=line>        <span class=comment>//非递归写法</span></span><br><span class=line>    ListNode* prev = <span class=literal>nullptr</span>;</span><br><span class=line>    <span class=keyword>while</span>(head) {</span><br><span class=line>        ListNode* next = head->next;</span><br><span class=line>        head->next = prev;</span><br><span class=line>        prev = head;</span><br><span class=line>        head = next;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> prev;</span><br><span class=line>    </span><br><span class=line>}</span><br></pre></table></figure><h4 id=21-合并有序链表><a title="21 合并有序链表" class=headerlink href=#21-合并有序链表></a>21 合并有序链表</h4><p>给定两个增序的链表，试将其合并成一个增序的链表。<p>输入两个链表，输出一个链表，表示两个链表合并的结果。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>Input: 1->2->4, 1->3->4</span><br><span class=line>Output: 1->1->2->3->4->4</span><br></pre></table></figure><p>递归和非递归，共两种写法。递归的写法为：<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre><td class=code><pre><span class=line><span class=comment>/*</span></span><br><span class=line><span class=comment> * @lc app=leetcode.cn id=21 lang=cpp</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * [21] 合并两个有序链表</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line></span><br><span class=line><span class=comment>// @lc code=start</span></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Definition for singly-linked list.</span></span><br><span class=line><span class=comment> * struct ListNode {</span></span><br><span class=line><span class=comment> *     int val;</span></span><br><span class=line><span class=comment> *     ListNode *next;</span></span><br><span class=line><span class=comment> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class=line><span class=comment> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class=line><span class=comment> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class=line><span class=comment> * };</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>ListNode* <span class=title>mergeTwoLists</span><span class=params>(ListNode* list1, ListNode* list2)</span> </span>{</span><br><span class=line>        <span class=comment>// 递归写法</span></span><br><span class=line>        <span class=keyword>if</span>(list1 == <span class=literal>nullptr</span>) {</span><br><span class=line>            <span class=keyword>return</span> list2;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span>(list2 == <span class=literal>nullptr</span>) {</span><br><span class=line>            <span class=keyword>return</span> list1;</span><br><span class=line>        }</span><br><span class=line>        </span><br><span class=line>        <span class=keyword>if</span>(list1->val&LTlist2->val) {</span><br><span class=line>            list1->next = <span class=built_in>mergeTwoLists</span>(list1->next, list2);</span><br><span class=line>            <span class=keyword>return</span> list1;</span><br><span class=line>        }</span><br><span class=line>        list2->next = <span class=built_in>mergeTwoLists</span>(list1, list2->next);</span><br><span class=line>        <span class=keyword>return</span> list2;</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line><span class=comment>// @lc code=end</span></span><br></pre></table></figure><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=function>ListNode *<span class=title>mergeTwoLists</span><span class=params>(ListNode *list1, ListNode *list2)</span> </span>{</span><br><span class=line>  <span class=comment>// 非递归写法</span></span><br><span class=line>  <span class=keyword>if</span> (list1 == <span class=literal>nullptr</span>) {</span><br><span class=line>    <span class=keyword>return</span> list2;</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>if</span> (list2 == <span class=literal>nullptr</span>) {</span><br><span class=line>    <span class=keyword>return</span> list1;</span><br><span class=line>  }</span><br><span class=line>  ListNode *root = <span class=keyword>new</span> <span class=built_in>ListNode</span>(<span class=number>0</span>);</span><br><span class=line>  ListNode *cur = root;</span><br><span class=line>  <span class=keyword>while</span> (list1 && list2) {</span><br><span class=line>    <span class=keyword>if</span> (list1->val < list2->val) {</span><br><span class=line>      cur->next = list1;</span><br><span class=line>      list1 = list1->next;</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>      cur->next = list2;</span><br><span class=line>      list2 = list2->next;</span><br><span class=line>    }</span><br><span class=line>    cur = cur->next;</span><br><span class=line>  }</span><br><span class=line>  cur->next = list1 ? list1 : list2;</span><br><span class=line>  <span class=keyword>return</span> root->next;</span><br><span class=line>}</span><br></pre></table></figure><h4 id=24-两两交换链表中的节点><a title="24 两两交换链表中的节点" class=headerlink href=#24-两两交换链表中的节点></a>24 两两交换链表中的节点</h4><p>给定一个矩阵，交换每个相邻的一对节点。<p>输入一个链表，输出该链表交换后的结果。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>Input: 1->2->3->4</span><br><span class=line>Output: 2->1->4->3</span><br></pre></table></figure><p>利用指针进行交换操作，没有太大难度，但一定要细心。<h4 id=160-相交链表><a title="160 相交链表" class=headerlink href=#160-相交链表></a>160 相交链表</h4><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。<p>假设链表 A 的头节点到相交点的距离是 a，链表 B 的头节点到相交点的距离是 b，相交点到链表终点的距离为 c。我们使用两个指针，分别指向两个链表的头节点，并以相同的速度前进，若到达链表结尾，则移动到另一条链表的头节点继续前进。按照这种前进方法，两个指针会在 a + b + c 次前进后同时到达相交节点<h4 id=234-回文链表><a title="234 回文链表" class=headerlink href=#234-回文链表></a>234 回文链表</h4><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。<p>先使用快慢指针找到链表中点，再把链表切成两半；然后把后半段翻转；最后比较两半是否相等。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br></pre><td class=code><pre><span class=line><span class=comment>/*</span></span><br><span class=line><span class=comment> * @lc app=leetcode.cn id=234 lang=cpp</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * [234] 回文链表</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line></span><br><span class=line><span class=comment>// @lc code=start</span></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Definition for singly-linked list.</span></span><br><span class=line><span class=comment> * struct ListNode {</span></span><br><span class=line><span class=comment> *     int val;</span></span><br><span class=line><span class=comment> *     ListNode *next;</span></span><br><span class=line><span class=comment> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class=line><span class=comment> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class=line><span class=comment> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class=line><span class=comment> * };</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>  <span class=function>ListNode *<span class=title>reverse</span><span class=params>(ListNode *list)</span> </span>{</span><br><span class=line>    <span class=keyword>if</span> (list == <span class=literal>nullptr</span>) {</span><br><span class=line>      <span class=keyword>return</span> <span class=literal>nullptr</span>;</span><br><span class=line>    }</span><br><span class=line>    ListNode *head_prev = <span class=literal>nullptr</span>;</span><br><span class=line>    <span class=keyword>while</span> (list) {</span><br><span class=line>      ListNode *head_next = list->next;</span><br><span class=line>      list->next = head_prev;</span><br><span class=line>      head_prev = list;</span><br><span class=line>      list = head_next;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> head_prev;</span><br><span class=line>  }</span><br><span class=line>  <span class=function><span class=keyword>bool</span> <span class=title>isPalindrome</span><span class=params>(ListNode *head)</span> </span>{</span><br><span class=line>    <span class=comment>// 快慢指针找中点</span></span><br><span class=line>    <span class=keyword>if</span> (head == <span class=literal>nullptr</span> || head->next == <span class=literal>nullptr</span>) {</span><br><span class=line>      <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>    ListNode* slowptr = head,*fastptr = head;</span><br><span class=line>    <span class=keyword>while</span>(fastptr->next!=<span class=literal>nullptr</span> && fastptr->next->next!=<span class=literal>nullptr</span>) {</span><br><span class=line>        fastptr = fastptr->next->next;</span><br><span class=line>        slowptr = slowptr->next;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 找到中点slowptr</span></span><br><span class=line>    slowptr->next = <span class=built_in>reverse</span>(slowptr->next);</span><br><span class=line>    slowptr = slowptr->next;</span><br><span class=line>    <span class=keyword>while</span>(slowptr) {</span><br><span class=line>        <span class=keyword>if</span>(head->val!=slowptr->val) {</span><br><span class=line>            <span class=keyword>return</span>  <span class=literal>false</span>;</span><br><span class=line>        }</span><br><span class=line>        head = head->next;</span><br><span class=line>        slowptr = slowptr->next;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>  }</span><br><span class=line>};</span><br><span class=line><span class=comment>// @lc code=end</span></span><br></pre></table></figure><h3 id=二叉树><a class=headerlink href=#二叉树 title=二叉树></a>二叉树</h3><h4 id=二叉树最大深度><a class=headerlink href=#二叉树最大深度 title=二叉树最大深度></a>二叉树最大深度</h4><p>递归,dfs,bfs<p>利用递归，我们可以很方便地求得最大深度。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>maxDepth</span><span class=params>(TreeNode* root)</span> </span>{</span><br><span class=line>    <span class=keyword>if</span> (root == <span class=literal>nullptr</span>) {</span><br><span class=line>        <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=built_in>max</span>(<span class=built_in>maxDepth</span>(root->left), <span class=built_in>maxDepth</span>(root->right)) + <span class=number>1</span>;</span><br><span class=line>}</span><br></pre></table></figure><h4 id=二叉平衡树><a class=headerlink href=#二叉平衡树 title=二叉平衡树></a>二叉平衡树</h4><p>判断一个二叉树是否平衡。树平衡的定义是，对于树上的任意节点，其两侧节点的最大深度的差值不得大于 1。<p>解法类似于求树的最大深度，但有两个不同的地方：一是我们需要先处理子树的深度再进行比较，二是如果我们在处理子树时发现其已经不平衡了，则可以返回一个-1，使得所有其长辈节点可以避免多余的判断（本题的判断比较简单，做差后取绝对值即可；但如果此处是一个开销较大的比较过程，则避免重复判断可以节省大量的计算时间）。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>  <span class=function><span class=keyword>int</span> <span class=title>MaxDepth</span><span class=params>(TreeNode *node)</span> </span>{</span><br><span class=line>    <span class=keyword>if</span> (node == <span class=literal>nullptr</span>) {</span><br><span class=line>      <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>int</span> l = <span class=built_in>MaxDepth</span>(node->left);</span><br><span class=line>    <span class=keyword>int</span> r = <span class=built_in>MaxDepth</span>(node->right);</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (<span class=built_in>abs</span>(r - l) > <span class=number>1</span> || r == <span class=number>-1</span> || l == <span class=number>-1</span>) {</span><br><span class=line>      <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=built_in>max</span>(l, r) + <span class=number>1</span>;</span><br><span class=line>  }</span><br><span class=line>  <span class=function><span class=keyword>bool</span> <span class=title>isBalanced</span><span class=params>(TreeNode *root)</span> </span>{ <span class=keyword>return</span> <span class=built_in>MaxDepth</span>(root) != <span class=number>-1</span>; }</span><br><span class=line>};</span><br></pre></table></figure><h4 id=二叉树最长直径><a class=headerlink href=#二叉树最长直径 title=二叉树最长直径></a>二叉树最长直径</h4><p>求一个二叉树的最长直径。直径的定义是二叉树上任意两节点之间的无向距离。<p>可以利用递归来处理树。解题时要注意，在我们处理某个子树时，我们更新的最长直径值和递归返回的值是不同的。这是因为待更新的最长直径值是经过该子树根节点的最长直径（即两侧长度）；而函数返回值是以该子树根节点为端点的最长直径值（即一侧长度），使用这样的返回值才可以通过递归更新父节点的最长直径值）。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>  <span class=function><span class=keyword>int</span> <span class=title>MaxDepth</span><span class=params>(TreeNode *node, <span class=keyword>int</span> &maxCount)</span> </span>{</span><br><span class=line>    <span class=keyword>if</span> (node == <span class=literal>nullptr</span>) {</span><br><span class=line>      <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>int</span> l = <span class=built_in>MaxDepth</span>(node->left,maxCount);</span><br><span class=line>    <span class=keyword>int</span> r = <span class=built_in>MaxDepth</span>(node->right,maxCount);</span><br><span class=line>    <span class=comment>// 更新最长直径,递归,从叶子节点到根节点,由下到上.</span></span><br><span class=line>    maxCount = <span class=built_in>max</span>(l + r, maxCount);</span><br><span class=line>    <span class=keyword>return</span> <span class=built_in>max</span>(l, r) + <span class=number>1</span>;</span><br><span class=line>  }</span><br><span class=line>  <span class=function><span class=keyword>int</span> <span class=title>diameterOfBinaryTree</span><span class=params>(TreeNode *root)</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> maxDiameter{};</span><br><span class=line>    <span class=built_in>MaxDepth</span>(root, maxDiameter);</span><br><span class=line>    <span class=keyword>return</span> maxDiameter;</span><br><span class=line>  }</span><br><span class=line>};</span><br></pre></table></figure><h4 id=路径和><a class=headerlink href=#路径和 title=路径和></a>路径和</h4><p>给定一个整数二叉树，求有多少条路径节点值的和等于给定值。<p>递归每个节点时，需要分情况考虑：（1）如果选取该节点加入路径，则之后必须继续加入连续节点，或停止加入节点（2）如果不选取该节点加入路径，则对其左右节点进行重新进行考虑。因此一个方便的方法是我们创建一个辅函数，专门用来计算连续加入节点的路径。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>  <span class=function><span class=keyword>int</span> <span class=title>pathStartWithNode</span><span class=params>(TreeNode *node, <span class=keyword>int</span> targetSum)</span> </span>{</span><br><span class=line>    <span class=comment>// 从node开始的和为targetSum的路径数目</span></span><br><span class=line>    <span class=keyword>if</span> (node == <span class=literal>nullptr</span>) {</span><br><span class=line>      <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 选择该节点 如果等于targetSum,则路径数+1.</span></span><br><span class=line>    <span class=keyword>return</span> node->val ==</span><br><span class=line>           targetSum + <span class=built_in>pathStartWithNode</span>(node->left, targetSum - node->val) +</span><br><span class=line>               <span class=built_in>pathStartWithNode</span>(node->right, targetSum - node->val);</span><br><span class=line>  }</span><br><span class=line>  <span class=function><span class=keyword>int</span> <span class=title>pathSum</span><span class=params>(TreeNode *root, <span class=keyword>int</span> targetSum)</span> </span>{</span><br><span class=line>    <span class=keyword>if</span> (root == <span class=literal>nullptr</span>) {</span><br><span class=line>      <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 从根节点开始,如果不选择根节点,则从左右节点开始</span></span><br><span class=line>    <span class=keyword>return</span> <span class=built_in>pathStartWithNode</span>(root, targetSum) + <span class=built_in>pathSum</span>(root->left, targetSum) +</span><br><span class=line>           <span class=built_in>pathSum</span>(root->right, targetSum);</span><br><span class=line>  }</span><br><span class=line>};</span><br></pre></table></figure><h4 id=判断一个二叉树是否对称><a class=headerlink href=#判断一个二叉树是否对称 title=判断一个二叉树是否对称></a>判断一个二叉树是否对称</h4><p>输入一个二叉树，输出一个布尔值，表示该树是否对称。<p>判断一个树是否对称等价于判断左右子树是否对称。一般习惯将判断两个子树是否相等或对称类型的题的解法叫做“四步法”：（1）如果两个子树都为空指针，则它们相等或对称（2）如果两个子树只有一个为空指针，则它们不相等或不对称（3）如果两个子树根节点的值不相等，则它们不相等或不对称（4）根据相等或对称要求，进行递归处理。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=comment>// 辅函数。</span></span><br><span class=line><span class=function><span class=keyword>bool</span> <span class=title>isLeftRightSymmetric</span><span class=params>(TreeNode* left, TreeNode* right)</span> </span>{</span><br><span class=line>    <span class=keyword>if</span> (left == <span class=literal>nullptr</span> && right == <span class=literal>nullptr</span>) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>if</span> (left == <span class=literal>nullptr</span> <span class=keyword>or</span> right == <span class=literal>nullptr</span>) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>if</span> (left->val != right->val) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=built_in>isLeftRightSymmetric</span>(left->left, right->right) &&</span><br><span class=line>           <span class=built_in>isLeftRightSymmetric</span>(left->right, right->left);</span><br><span class=line>}</span><br><span class=line><span class=comment>// 主函数。</span></span><br><span class=line><span class=function><span class=keyword>bool</span> <span class=title>isSymmetric</span><span class=params>(TreeNode* root)</span> </span>{</span><br><span class=line>    <span class=keyword>if</span> (root == <span class=literal>nullptr</span>) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=built_in>isLeftRightSymmetric</span>(root->left, root->right);</span><br><span class=line>}</span><br></pre></table></figure><h4 id=删点成林><a class=headerlink href=#删点成林 title=删点成林></a>删点成林</h4><p>给定一个整数二叉树和一些整数，求删掉这些整数对应的节点后，剩余的子树。<p>这道题最主要需要注意的细节是如果通过递归处理原树，以及需要在什么时候断开指针。同时，为了便于寻找待删除节点，可以建立一个哈希表方便查找。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre><td class=code><pre><span class=line><span class=comment>// 辅函数。</span></span><br><span class=line><span class=function>TreeNode* <span class=title>moveNodesToForest</span><span class=params>(TreeNode* root, unordered_set<<span class=keyword>int</span>>& undeleted,</span></span></span><br><span class=line><span class=params><span class=function>                            vector&LTTreeNode*>& forest)</span> </span>{</span><br><span class=line>    <span class=keyword>if</span> (root == <span class=literal>nullptr</span>) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>nullptr</span>;</span><br><span class=line>    }</span><br><span class=line>    root->left = <span class=built_in>moveNodesToForest</span>(root->left, undeleted, forest);</span><br><span class=line>    root->right = <span class=built_in>moveNodesToForest</span>(root->right, undeleted, forest);</span><br><span class=line>    <span class=keyword>if</span> (undeleted.<span class=built_in>contains</span>(root->val)) {</span><br><span class=line>        <span class=keyword>if</span> (root->left != <span class=literal>nullptr</span>) {</span><br><span class=line>            forest.<span class=built_in>push_back</span>(root->left);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (root->right != <span class=literal>nullptr</span>) {</span><br><span class=line>            forest.<span class=built_in>push_back</span>(root->right);</span><br><span class=line>        }</span><br><span class=line>        root = <span class=literal>nullptr</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> root;</span><br><span class=line>}</span><br><span class=line><span class=comment>// 主函数。</span></span><br><span class=line><span class=function>vector&LTTreeNode*> <span class=title>delNodes</span><span class=params>(TreeNode* root, vector<<span class=keyword>int</span>>& to_delete)</span> </span>{</span><br><span class=line>    vector&LTTreeNode*> forest;</span><br><span class=line>    <span class=function>unordered_set<<span class=keyword>int</span>> <span class=title>undeleted</span><span class=params>(to_delete.begin(), to_delete.end())</span></span>;</span><br><span class=line>    root = <span class=built_in>moveNodesToForest</span>(root, undeleted, forest);</span><br><span class=line>    <span class=keyword>if</span> (root != <span class=literal>nullptr</span>) {</span><br><span class=line>        forest.<span class=built_in>push_back</span>(root);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> forest;</span><br><span class=line>}</span><br></pre></table></figure><h3 id=层次遍历-1><a class=headerlink href=#层次遍历-1 title=层次遍历></a>层次遍历</h3><p>可以使用广度优先搜索进行层次遍历。注意，不需要使用两个队列来分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。<h4 id=二叉树每层平均值><a class=headerlink href=#二叉树每层平均值 title=二叉树每层平均值></a>二叉树每层平均值</h4><p>给定一个二叉树，求每一层的节点值的平均数。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=function>vector<<span class=keyword>double</span>> <span class=title>averageOfLevels</span><span class=params>(TreeNode* root)</span> </span>{</span><br><span class=line>    vector<<span class=keyword>double</span>> level_avg;</span><br><span class=line>    <span class=keyword>if</span> (root == <span class=literal>nullptr</span>) {</span><br><span class=line>        <span class=keyword>return</span> level_avg;</span><br><span class=line>    }</span><br><span class=line>    queue&LTTreeNode*> q;</span><br><span class=line>    q.<span class=built_in>push</span>(root);</span><br><span class=line>    <span class=keyword>int</span> count = q.<span class=built_in>size</span>();</span><br><span class=line>    <span class=keyword>while</span> (count > <span class=number>0</span>) {</span><br><span class=line>        <span class=keyword>double</span> level_sum = <span class=number>0</span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < count; ++i) {</span><br><span class=line>            TreeNode* node = q.<span class=built_in>front</span>();</span><br><span class=line>            q.<span class=built_in>pop</span>();</span><br><span class=line>            level_sum += node->val;</span><br><span class=line>            <span class=keyword>if</span> (node->left != <span class=literal>nullptr</span>) {</span><br><span class=line>                q.<span class=built_in>push</span>(node->left);</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (node->right != <span class=literal>nullptr</span>) {</span><br><span class=line>                q.<span class=built_in>push</span>(node->right);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        level_avg.<span class=built_in>push_back</span>(level_sum / count);</span><br><span class=line>        count = q.<span class=built_in>size</span>();</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> level_avg;</span><br><span class=line>}</span><br></pre></table></figure><h3 id=二叉树的前中后序遍历><a class=headerlink href=#二叉树的前中后序遍历 title=二叉树的前中后序遍历></a>二叉树的前中后序遍历</h3><p>前序遍历、中序遍历和后序遍历是三种利用深度优先搜索遍历二叉树的方式。它们是在对节点访问的顺序有一点不同，其它完全相同。<p>前序遍历<strong>先遍历父结点</strong>，再遍历左结点，最后遍历右节点<p>中序遍历先遍历左节点，<strong>再遍历父结点</strong>，最后遍历右节点<p>后序遍历先遍历左节点，再遍历右结点，<strong>最后遍历父节点</strong><h4 id=从先序和中序构建二叉树><a class=headerlink href=#从先序和中序构建二叉树 title=从先序和中序构建二叉树></a>从先序和中序构建二叉树</h4><p>给定一个二叉树的前序遍历和中序遍历结果，尝试复原这个树。已知树里不存在重复值的节点。<p>通过本题的样例讲解一下本题的思路。前序遍历的第一个节点是 4，意味着 4 是根节点。我们在中序遍历结果里找到 4 这个节点，根据中序遍历的性质可以得出，4 在中序遍历数组位置的左子数组为左子树，节点数为 1，对应的是前序排列数组里 4 之后的 1 个数字（9）；4 在中序遍历数组位置的右子数组为右子树，节点数为 3，对应的是前序排列数组里最后的 3 个数字。有了这些信息，我们就可以对左子树和右子树进行递归复原了。为了方便查找数字的位置，我们可以用哈希表预处理中序遍历的结果。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=comment>// 辅函数。</span></span><br><span class=line><span class=function>TreeNode* <span class=title>reconstruct</span><span class=params>(unordered_map<<span class=keyword>int</span>, <span class=keyword>int</span>>& io_map, vector<<span class=keyword>int</span>>& po, <span class=keyword>int</span> l,</span></span></span><br><span class=line><span class=params><span class=function>                      <span class=keyword>int</span> r, <span class=keyword>int</span> mid_po)</span> </span>{</span><br><span class=line>    <span class=keyword>if</span> (l > r) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>nullptr</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>int</span> mid_val = po[mid_po];</span><br><span class=line>    <span class=keyword>int</span> mid_io = io_map[mid_val];</span><br><span class=line>    <span class=keyword>int</span> left_len = mid_io - l + <span class=number>1</span>;</span><br><span class=line>    TreeNode* node = <span class=keyword>new</span> <span class=built_in>TreeNode</span>(mid_val);</span><br><span class=line>    <span class=comment>// 左子树的根节点如果存在,一定在当前节点在preorder的下一个位置</span></span><br><span class=line>    node->left = <span class=built_in>reconstruct</span>(io_map, po, l, mid_io - <span class=number>1</span>, mid_po + <span class=number>1</span>);</span><br><span class=line>    <span class=comment>// 通过left_len找到右子树节点开始的索引</span></span><br><span class=line>    node->right = <span class=built_in>reconstruct</span>(io_map, po, mid_io + <span class=number>1</span>, r, mid_po + left_len);</span><br><span class=line>    <span class=keyword>return</span> node;</span><br><span class=line>}</span><br><span class=line><span class=comment>// 主函数。</span></span><br><span class=line><span class=function>TreeNode* <span class=title>buildTree</span><span class=params>(vector<<span class=keyword>int</span>>& preorder, vector<<span class=keyword>int</span>>& inorder)</span> </span>{</span><br><span class=line>    unordered_map<<span class=keyword>int</span>, <span class=keyword>int</span>> io_map;</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < inorder.<span class=built_in>size</span>(); ++i) {</span><br><span class=line>        io_map[inorder[i]] = i;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=built_in>reconstruct</span>(io_map, preorder, <span class=number>0</span>, preorder.<span class=built_in>size</span>() - <span class=number>1</span>, <span class=number>0</span>);</span><br><span class=line>}</span><br></pre></table></figure><h4 id=先序遍历><a class=headerlink href=#先序遍历 title=先序遍历></a>先序遍历</h4><p>不使用递归，实现二叉树的前序遍历<p>因为递归的本质是栈调用，因此我们可以通过栈来实现前序遍历。注意入栈的顺序。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>private</span>:</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>  <span class=function>vector<<span class=keyword>int</span>> <span class=title>preorderTraversal</span><span class=params>(TreeNode *root)</span> </span>{</span><br><span class=line>    <span class=comment>// 先序遍历</span></span><br><span class=line>    <span class=comment>// 先求根节点 再找左子树 再找右子树</span></span><br><span class=line></span><br><span class=line>    <span class=comment>// 也可以使用栈模拟递归</span></span><br><span class=line>    std::stack&LTTreeNode *> s;</span><br><span class=line>    <span class=keyword>if</span> (root == <span class=literal>nullptr</span>) {</span><br><span class=line>      <span class=keyword>return</span> {};</span><br><span class=line>    }</span><br><span class=line>    vector<<span class=keyword>int</span>> r;</span><br><span class=line>    s.<span class=built_in>push</span>(root);</span><br><span class=line>    <span class=keyword>while</span> (!s.<span class=built_in>empty</span>()) {</span><br><span class=line>      <span class=keyword>auto</span> t = s.<span class=built_in>top</span>();</span><br><span class=line>      s.<span class=built_in>pop</span>();</span><br><span class=line>      r.<span class=built_in>push_back</span>(t->val);</span><br><span class=line>      <span class=keyword>if</span> (t->right) {</span><br><span class=line>        s.<span class=built_in>push</span>(t->right);</span><br><span class=line>      }</span><br><span class=line>      <span class=keyword>if</span> (t->left) {</span><br><span class=line>        s.<span class=built_in>push</span>(t->left);</span><br><span class=line>      }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> r;</span><br><span class=line>  }</span><br><span class=line>};</span><br></pre></table></figure><h3 id=二叉查找树><a class=headerlink href=#二叉查找树 title=二叉查找树></a>二叉查找树</h3><p><code>二叉查找树</code>（Binary Search Tree, BST）是一种特殊的二叉树：对于每个父节点，其左子树中所有节点的值小于等于父结点的值，其右子树中所有节点的值大于等于父结点的值。因此对于一个二叉查找树，我们可以在 O(log n) 的时间内查找一个值是否存在：从根节点开始，若当前节点的值大于查找值则向左下走，若当前节点的值小于查找值则向右下走。同时因为二叉查找树是有序的，对其中序遍历的结果即为排好序的数组。<h4 id=恢复二叉搜索树><a class=headerlink href=#恢复二叉搜索树 title=恢复二叉搜索树></a>恢复二叉搜索树</h4><p>给你二叉搜索树的根节点 <code>root</code> ，该树中的 <strong>恰好</strong> 两个节点的值被错误地交换。<em>请在不改变其结构的情况下，恢复这棵树</em> 。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>  <span class=function><span class=keyword>void</span> <span class=title>midTraverse</span><span class=params>(TreeNode *node, TreeNode *&prev, TreeNode *&firstNode,</span></span></span><br><span class=line><span class=params><span class=function>                   TreeNode *&secondNode)</span> </span>{</span><br><span class=line>    <span class=keyword>if</span> (node == <span class=literal>nullptr</span>) {</span><br><span class=line>      <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=built_in>midTraverse</span>(node->left, prev, firstNode, secondNode);</span><br><span class=line>    <span class=keyword>if</span> (prev != <span class=literal>nullptr</span>) {</span><br><span class=line>      <span class=keyword>auto</span> val = node->val;</span><br><span class=line>      <span class=keyword>if</span> (val < prev->val) {</span><br><span class=line>        <span class=keyword>if</span> (firstNode == <span class=literal>nullptr</span>) {</span><br><span class=line>          firstNode = prev;</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        secondNode = node;</span><br><span class=line>      }</span><br><span class=line>    }</span><br><span class=line>    prev = node;</span><br><span class=line>    <span class=built_in>midTraverse</span>(node->right, prev, firstNode, secondNode);</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=function><span class=keyword>void</span> <span class=title>recoverTree</span><span class=params>(TreeNode *root)</span> </span>{</span><br><span class=line>    <span class=comment>// 中序遍历 先找到第一个出问题的值的节点 也就是值比上一个值小</span></span><br><span class=line>    <span class=comment>// 然后找到最后一个出问题的节点 也就是值比上一个值大时,找到第二个错误节点</span></span><br><span class=line>    TreeNode *prev = <span class=literal>nullptr</span>, *firstNode = <span class=literal>nullptr</span>, *secondNode = <span class=literal>nullptr</span>;</span><br><span class=line>    <span class=built_in>midTraverse</span>(root, prev, firstNode, secondNode);</span><br><span class=line>    <span class=built_in>swap</span>(firstNode->val, secondNode->val);</span><br><span class=line>  }</span><br><span class=line>};</span><br><span class=line></span><br></pre></table></figure><p>可以使用中序遍历这个二叉查找树，同时设置一个 prev 指针，记录当前节点中序遍历时的前节点。如果当前节点大于 prev 节点的值，说明需要调整次序。有一个技巧是如果遍历整个序列过程中只出现了一次次序错误，说明就是这两个相邻节点需要被交换；如果出现了两次次序错误，那就需要交换这两个节点。<h4 id=修建二叉搜索树><a class=headerlink href=#修建二叉搜索树 title=修建二叉搜索树></a>修建二叉搜索树</h4><p>给定一个二叉查找树和两个整数 L 和 R，且 L < R，试修剪此二叉查找树，使得修剪后所有节点的值都在 [L, R] 的范围内。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>  <span class=function>TreeNode *<span class=title>trimNode</span><span class=params>(TreeNode *node, <span class=keyword>int</span> low, <span class=keyword>int</span> high)</span> </span>{</span><br><span class=line>    <span class=keyword>if</span> (node == <span class=literal>nullptr</span>) {</span><br><span class=line>      <span class=keyword>return</span> <span class=literal>nullptr</span>;</span><br><span class=line>    }</span><br><span class=line>    node->left = <span class=built_in>trimNode</span>(node->left, low, high);</span><br><span class=line>    node->right = <span class=built_in>trimNode</span>(node->right, low, high);</span><br><span class=line></span><br><span class=line>    <span class=keyword>auto</span> val = node->val;</span><br><span class=line>    <span class=keyword>if</span> (val < low) {</span><br><span class=line>      node = <span class=built_in>trimNode</span>(node->right, low, high);</span><br><span class=line>      <span class=keyword>return</span> node;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>if</span> (val > high) {</span><br><span class=line>      <span class=comment>//  节点的值若大于high,则其以及右子树 的值大于val</span></span><br><span class=line>      <span class=comment>// 都要剔除</span></span><br><span class=line>      node = <span class=built_in>trimNode</span>(node->left, low, high);</span><br><span class=line>      <span class=keyword>return</span> node;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> node;</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=function>TreeNode *<span class=title>trimBST</span><span class=params>(TreeNode *root, <span class=keyword>int</span> low, <span class=keyword>int</span> high)</span> </span>{</span><br><span class=line>    root = <span class=built_in>trimNode</span>(root, low, high);</span><br><span class=line>    <span class=keyword>return</span> root;</span><br><span class=line>  }</span><br><span class=line>};</span><br></pre></table></figure><h4 id=字典树><a class=headerlink href=#字典树 title=字典树></a>字典树</h4><p>判断字符串是否存在或者具有某种字符串前缀.<p><img alt=img data-src=https://noworneverev.github.io/leetcode_101/assets/images/13.1-8f62e3e9e89a8b86a7e3ded16599bba3.png><p>假如我们有一个储存了近万个单词的字典，即使我们使用哈希，在其中搜索一个单词的实际开销也是非常大的，且无法轻易支持搜索单词前缀。然而由于一个英文单词的长度 n 通常在 10 以内，如果我们使用字典树，则可以在O<em>(</em>n<em>)——近似 O(1)</em>O*(1) 的时间内完成搜索，且额外开销非常小。<h3 id=图><a class=headerlink href=#图 title=图></a>图</h3><p>作为指针三剑客之三，图是树的升级版。<code>图</code>通常分为有向（directed）或无向（undirected），有循环（cyclic）或无循环（acyclic），所有节点相连（connected）或不相连（disconnected）。树即是一个相连的无向无环图，而另一种很常见的图是<code>有向无环图</code>（Directed Acyclic Graph，DAG）。<p>图通常有两种表示方法。假设图中一共有 n 个节点、m 条边。第一种表示方法是<code>邻接矩阵</code>（adjacency matrix）：我们可以建立一个 n × n 的矩阵 G，如果第 i 个节点连向第 j 个节点，则 G[i][j] = 1，反之为 0；如果图是无向的，则这个矩阵一定是对称矩阵，即 G[i][j] = G[j][i]。第二种表示方法是<code>邻接链表</code>（adjacency list）：我们可以建立一个大小为 n 的数组，每个位置 i 储存一个数组或者链表，表示第 i 个节点连向的其它节点。邻接矩阵空间开销比邻接链表大，但是邻接链表不支持快速查找 i 和 j 是否相连，因此两种表示方法可以根据题目需要适当选择。除此之外，我们也可以直接用一个 m × 2 的矩阵储存所有的边。<h4 id=二分图><a class=headerlink href=#二分图 title=二分图></a>二分图</h4><p><strong>二分图</strong> 定义：如果能将一个图的节点集合分割成两个独立的子集 <code>A</code> 和 <code>B</code> ，并使图中的每一条边的两个节点一个来自 <code>A</code> 集合，一个来自 <code>B</code> 集合，就将这个图称为 <strong>二分图</strong> 。<p><code>二分图</code>算法也称为<code>染色法</code>，是一种广度优先搜索。如果可以用两种颜色对图中的节点进行着色，并且保证相邻的节点颜色不同，那么图为二分。<p>给定一个图，判断其是否可以二分。<h3 id=拓扑排序><a class=headerlink href=#拓扑排序 title=拓扑排序></a>拓扑排序</h3><p><code>拓扑排序</code>（topological sort）是一种常见的，对有向无环图排序的算法。给定有向无环图中的 N个节点，我们把它们排序成一个线性序列；若原图中节点 i 指向节点 j，则排序结果中 i 一定在 j 之前。拓扑排序的结果不是唯一的，只要满足以上条件即可。<p>可以先建立一个邻接矩阵表示图，方便进行直接查找。这里注意我们将所有的边反向，使得如果课程 i 指向课程 j，那么课程 i 需要在课程 j 前面先修完。这样更符合我们的直观理解。<p>拓扑排序也可以被看成是广度优先搜索的一种情况：我们先遍历一遍所有节点，把入度为 0 的节点（即没有前置课程要求）放在队列中。在每次从队列中获得节点时，我们将该节点放在目前排序的末尾，并且把它指向的课程的入度各减 1；如果在这个过程中有课程的所有前置必修课都已修完（即入度为 0），我们把这个节点加入队列中。当队列的节点都被处理完时，说明所有的节点都已排好序，或因图中存在循环而无法上完所有课程。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>  <span class=function>vector<<span class=keyword>int</span>> <span class=title>findOrder</span><span class=params>(<span class=keyword>int</span> numCourses, vector&LTvector<<span class=keyword>int</span>>> &prerequisites)</span> </span>{</span><br><span class=line>    vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>course</span>(numCourses);</span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>pres</span><span class=params>(numCourses, <span class=number>0</span>)</span></span>;</span><br><span class=line>    vector<<span class=keyword>int</span>> result;</span><br><span class=line>    queue<<span class=keyword>int</span>> q;</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>auto</span> p : prerequisites) {</span><br><span class=line>      course[p[<span class=number>1</span>]].<span class=built_in>push_back</span>(p[<span class=number>0</span>]);</span><br><span class=line>      pres[p[<span class=number>0</span>]]++;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < numCourses; ++i) {</span><br><span class=line>      <span class=comment>// 遍历所有课程 找到入度为0的课程</span></span><br><span class=line>      <span class=keyword>if</span> (pres[i] == <span class=number>0</span>) {</span><br><span class=line>        q.<span class=built_in>push</span>(i);</span><br><span class=line>      }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>while</span> (!q.<span class=built_in>empty</span>()) {</span><br><span class=line>      <span class=keyword>auto</span> r = q.<span class=built_in>front</span>();</span><br><span class=line>      q.<span class=built_in>pop</span>();</span><br><span class=line>      result.<span class=built_in>push_back</span>(r);</span><br><span class=line>      <span class=comment>// 获得指向的课程</span></span><br><span class=line>      <span class=keyword>for</span> (<span class=keyword>auto</span> c : course[r]) {</span><br><span class=line>        <span class=comment>// 更新入度</span></span><br><span class=line>        <span class=comment>// 其指向的课程 入度-1</span></span><br><span class=line>        pres[c]--;</span><br><span class=line>        <span class=keyword>if</span> (pres[c] == <span class=number>0</span>) {</span><br><span class=line>          q.<span class=built_in>push</span>(c);</span><br><span class=line>        }</span><br><span class=line>      }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < numCourses; ++i) {</span><br><span class=line>      <span class=keyword>if</span> (pres[i] != <span class=number>0</span>) {</span><br><span class=line>        <span class=keyword>return</span> {};</span><br><span class=line>      }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> result;</span><br><span class=line>  }</span><br><span class=line>};</span><br></pre></table></figure><h3 id=并查集><a class=headerlink href=#并查集 title=并查集></a>并查集</h3><p><code>并查集</code>（union-ﬁnd, disjoint set）可以<strong>动态地连通两个点，并且可以非常快速地判断两个点是否连通</strong>。假设存在 n 个节点，我们先将所有节点的父节点标为自己；每次要连接节点 i 和 j 时，我们可以将秩较小一方的父节点标为另一方（按秩合并）；每次要查询两个节点是否相连时，我们可以查找 i 和 j 的祖先是否最终为同一个人，并减少祖先层级（路径压缩）。<h3 id=LRUCache><a class=headerlink href=#LRUCache title=LRUCache></a>LRUCache</h3><p>采用一个链表来储存信息的 key 和 value，链表的链接顺序即为最近使用的新旧顺序，最新的信息在链表头节点。同时我们需要一个哈希表进行查找，键是信息的 key，值是其在链表中的对应指针/迭代器。每次查找成功（cache hit）时，需要把指针/迭代器对应的节点移动到链表的头节点。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>LRUCache</span> {</span></span><br><span class=line><span class=keyword>private</span>:</span><br><span class=line>  <span class=keyword>int</span> counter_{};</span><br><span class=line>  std::list&LTpair<<span class=keyword>int</span>, <span class=keyword>int</span>>> caches_;</span><br><span class=line>  std::unordered_map<<span class=keyword>int</span>, list&LTpair<<span class=keyword>int</span>, <span class=keyword>int</span>>>::iterator> key_to_cache_it_;</span><br><span class=line>  <span class=keyword>int</span> capacity_;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>  <span class=built_in>LRUCache</span>(<span class=keyword>int</span> capacity) : <span class=built_in>capacity_</span>(capacity) {}</span><br><span class=line></span><br><span class=line>  <span class=function><span class=keyword>int</span> <span class=title>get</span><span class=params>(<span class=keyword>int</span> key)</span> </span>{</span><br><span class=line>    <span class=keyword>if</span> (key_to_cache_it_.<span class=built_in>count</span>(key)) {</span><br><span class=line>      <span class=comment>// 更新访问时间</span></span><br><span class=line>      <span class=keyword>auto</span> it = key_to_cache_it_.<span class=built_in>at</span>(key);</span><br><span class=line>      <span class=keyword>auto</span> value = it->second;</span><br><span class=line>      caches_.<span class=built_in>erase</span>(it);</span><br><span class=line>      key_to_cache_it_.<span class=built_in>erase</span>(key);</span><br><span class=line></span><br><span class=line>      caches_.<span class=built_in>push_front</span>({key, value});</span><br><span class=line>      key_to_cache_it_[key] = caches_.<span class=built_in>begin</span>();</span><br><span class=line>      <span class=keyword>return</span> value;</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>      <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>    }</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=function><span class=keyword>void</span> <span class=title>put</span><span class=params>(<span class=keyword>int</span> key, <span class=keyword>int</span> value)</span> </span>{</span><br><span class=line>    <span class=keyword>if</span> (key_to_cache_it_.<span class=built_in>count</span>(key)) {</span><br><span class=line>      <span class=comment>// 如果存在,更新值与最近访问顺序</span></span><br><span class=line>      <span class=keyword>auto</span> it = key_to_cache_it_[key];</span><br><span class=line></span><br><span class=line>      caches_.<span class=built_in>erase</span>(it);</span><br><span class=line>      caches_.<span class=built_in>push_front</span>({key, value});</span><br><span class=line>      key_to_cache_it_[key] = caches_.<span class=built_in>begin</span>();</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>      <span class=comment>// 如果不存在,看是否超出容量</span></span><br><span class=line>      <span class=keyword>if</span> (key_to_cache_it_.<span class=built_in>size</span>() + <span class=number>1</span> > capacity_) {</span><br><span class=line>        <span class=comment>// 如果超出容量</span></span><br><span class=line>        <span class=comment>// 弹出最后一个值</span></span><br><span class=line>        <span class=keyword>auto</span> [poppedKey, _] = caches_.<span class=built_in>back</span>();</span><br><span class=line>        key_to_cache_it_.<span class=built_in>erase</span>(poppedKey);</span><br><span class=line>        caches_.<span class=built_in>pop_back</span>();</span><br><span class=line></span><br><span class=line>        caches_.<span class=built_in>push_front</span>({key, value});</span><br><span class=line>        key_to_cache_it_[key] = caches_.<span class=built_in>begin</span>();</span><br><span class=line>      } <span class=keyword>else</span> {</span><br><span class=line>        <span class=comment>// 未超出容量,直接插入</span></span><br><span class=line>        caches_.<span class=built_in>push_front</span>({key, value});</span><br><span class=line>        key_to_cache_it_[key] = caches_.<span class=built_in>begin</span>();</span><br><span class=line>      }</span><br><span class=line>    }</span><br><span class=line>  }</span><br><span class=line>};</span><br></pre></table></figure><p>双指针<p>滑动窗口<p>前缀和<p>动态规划 贪心 dfs bfs 回溯<p>使用数据结构 stack queue map set<h2 id=有用的资料><a class=headerlink href=#有用的资料 title=有用的资料></a>有用的资料</h2><ol><li><p><a href=https://www.programmercarl.com/ rel=noopener target=_blank>代码随想录</a></p><li><p><a href=https://github.com/changgyhub/leetcode_101 rel=noopener target=_blank>changgyhub/leetcode_101: LeetCode 101：力扣刷题指南</a></p><li><p><a href=https://leetcode.cn/problem-list/G25w0aD1/ rel=noopener target=_blank>剑指offer（专项突破） - 力扣（LeetCode）全球极客挚爱的技术成长平台</a></p><li><p><a href=https://codetop.cc/home rel=noopener target=_blank>CodeTop 面试题目总结</a></p><li><p><a href=https://noworneverev.github.io/leetcode_101/ rel=noopener target=_blank>LeetCode 101: 力扣刷题指南 (第二版) | LeetCode 101 - A Grinding Guide</a></p><li><p><a href="https://github.com/changgyhub/leetcode_101/blob/master/LeetCode 101 - A Grinding Guide.pdf" rel=noopener target=_blank>leetcode_101/LeetCode 101 - A Grinding Guide.pdf at master · changgyhub/leetcode_101</a></p><li><p><a href=https://labuladong.online/algo/home/ rel=noopener target=_blank>本站简介 | labuladong 的算法笔记</a></p> <p>代码随想录 codetop hot100 labuladong leetcode101</p></ol><link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script></div><div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div class=popular-posts-header>相关文章</div><ul class=popular-posts><li class=popular-posts-item><div class=popular-posts-title><a href=\2025\08\31\刷题总结篇\ rel=bookmark>刷题总结篇</a></div><li class=popular-posts-item><div class=popular-posts-title><a href=\2025\07\31\c-刷leetcode注意事项\ rel=bookmark>c++刷leetcode注意事项</a></div></ul><div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a href=https://www.sekyoro.top/2022/11/11/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ title=leetcode刷题记录>https://www.sekyoro.top/2022/11/11/leetcode刷题记录/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div><footer class=post-footer><div class=post-tags><a href=/tags/leetcode/ rel=tag><i class="fa fa-tag"></i> leetcode</a><a href=/tags/algorithm/ rel=tag><i class="fa fa-tag"></i> algorithm</a></div><div class=post-nav><div class=post-nav-item><a href=/2022/10/25/vue%E7%BD%91%E4%B8%8A%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/ rel=prev title=vue网上商城项目> <i class="fa fa-chevron-left"></i> vue网上商城项目 </a></div><div class=post-nav-item><a href=/2022/11/11/%E4%BD%BF%E7%94%A8overleaf%E4%BC%98%E9%9B%85%E5%9C%B0%E5%86%99%E6%96%87%E7%AB%A0/ rel=next title=使用overleaf优雅地写文章> 使用overleaf优雅地写文章 <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div><!-- 评论区 --><div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%9C%89getMin%E5%8A%9F%E8%83%BD%E7%9A%84%E6%A0%88><span class=nav-number>1.</span> <span class=nav-text>设计一个有getMin功能的栈</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88><span class=nav-number>1.1.</span> <span class=nav-text>设计方案</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8><span class=nav-number>2.</span> <span class=nav-text>从尾到头打印链表</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88-1><span class=nav-number>2.1.</span> <span class=nav-text>设计方案</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link><span class=nav-number>3.</span> <span class=nav-text> </span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8><span class=nav-number>4.</span> <span class=nav-text>反转链表</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88><span class=nav-number>4.1.</span> <span class=nav-text>解决方案</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6><span class=nav-number>5.</span> <span class=nav-text>复杂链表的复制</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF><span class=nav-number>5.1.</span> <span class=nav-text>解题思路</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Update><span class=nav-number></span> <span class=nav-text>Update</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95><span class=nav-number>1.</span> <span class=nav-text>贪心算法</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA><span class=nav-number>1.1.</span> <span class=nav-text>121 买卖股票最佳时机</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II><span class=nav-number>1.2.</span> <span class=nav-text>122 买卖股票的最佳时机 II</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#455%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2><span class=nav-number>1.3.</span> <span class=nav-text>455分发饼干</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#135%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C><span class=nav-number>1.4.</span> <span class=nav-text>135分发糖果</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#435%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4><span class=nav-number>1.5.</span> <span class=nav-text>435无重叠区间</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8F%8C%E6%8C%87%E9%92%88><span class=nav-number>2.</span> <span class=nav-text>双指针</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C><span class=nav-number>2.1.</span> <span class=nav-text>167 两数之和</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#88-%E5%BD%92%E5%B9%B6%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84><span class=nav-number>2.2.</span> <span class=nav-text>88 归并有序数组</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE><span class=nav-number>3.</span> <span class=nav-text>二分查找</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97><span class=nav-number>3.1.</span> <span class=nav-text>旋转数组查找数字</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%9F%A5%E6%89%BE%E5%B3%B0%E5%80%BC><span class=nav-number>3.2.</span> <span class=nav-text>查找峰值</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95><span class=nav-number>4.</span> <span class=nav-text>排序算法</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F><span class=nav-number>4.1.</span> <span class=nav-text>快速排序</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F><span class=nav-number>4.2.</span> <span class=nav-text>归并排序</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9><span class=nav-number>4.3.</span> <span class=nav-text>快速选择</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%A1%B6%E6%8E%92%E5%BA%8F><span class=nav-number>4.4.</span> <span class=nav-text>桶排序</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%90%9C%E7%B4%A2><span class=nav-number>5.</span> <span class=nav-text>搜索</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%9C%80%E5%A4%A7%E5%B2%9B%E5%B1%BF%E9%9D%A2%E7%A7%AF><span class=nav-number>5.1.</span> <span class=nav-text>最大岛屿面积</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%9F%8E%E5%B8%82%E6%95%B0%E9%87%8F><span class=nav-number>5.2.</span> <span class=nav-text>城市数量</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98><span class=nav-number>5.3.</span> <span class=nav-text>太平洋大西洋水流问题</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%9B%9E%E6%BA%AF%E6%B3%95><span class=nav-number>6.</span> <span class=nav-text>回溯法</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%85%A8%E6%8E%92%E5%88%97><span class=nav-number>6.1.</span> <span class=nav-text>全排列</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%BB%84%E5%90%88><span class=nav-number>6.2.</span> <span class=nav-text>组合</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2><span class=nav-number>6.3.</span> <span class=nav-text>单词搜索</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#K%E7%9A%87%E5%90%8E><span class=nav-number>6.4.</span> <span class=nav-text>K皇后</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2><span class=nav-number>7.</span> <span class=nav-text>广度优先搜索</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92><span class=nav-number>8.</span> <span class=nav-text>动态规划</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%B8%80%E7%BB%B4><span class=nav-number>8.1.</span> <span class=nav-text>一维</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BA%8C%E7%BB%B4><span class=nav-number>8.2.</span> <span class=nav-text>二维</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%88%86%E5%89%B2%E7%B1%BB%E5%9E%8B><span class=nav-number>8.3.</span> <span class=nav-text>分割类型</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98><span class=nav-number>8.4.</span> <span class=nav-text>子序列问题</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98><span class=nav-number>8.5.</span> <span class=nav-text>背包问题</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E8%BE%91><span class=nav-number>8.6.</span> <span class=nav-text>字符串编辑</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93><span class=nav-number>8.7.</span> <span class=nav-text>股票交易</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%88%86%E6%B2%BB%E6%B3%95><span class=nav-number>9.</span> <span class=nav-text>分治法</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%A0%91><span class=nav-number>10.</span> <span class=nav-text>树</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92><span class=nav-number>10.1.</span> <span class=nav-text>树的递归</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86><span class=nav-number>10.2.</span> <span class=nav-text>层次遍历</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86><span class=nav-number>10.3.</span> <span class=nav-text>前中后序遍历</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98><span class=nav-number></span> <span class=nav-text>数学问题</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%85%AC%E5%80%8D%E6%95%B0%E4%B8%8E%E5%85%AC%E5%9B%A0%E6%95%B0><span class=nav-number>1.</span> <span class=nav-text>公倍数与公因数</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%B4%A8%E6%95%B0><span class=nav-number>2.</span> <span class=nav-text>质数</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%95%B0%E5%AD%97%E5%A4%84%E7%90%86><span class=nav-number>3.</span> <span class=nav-text>数字处理</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#Base7><span class=nav-number>3.1.</span> <span class=nav-text>Base7</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Factorial-Trailing-Zeroes><span class=nav-number>3.2.</span> <span class=nav-text>Factorial Trailing Zeroes</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0><span class=nav-number>3.3.</span> <span class=nav-text>字符串相加</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%9A%8F%E6%9C%BA%E5%8F%96%E6%A0%B7><span class=nav-number>4.</span> <span class=nav-text>随机取样</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84><span class=nav-number>4.1.</span> <span class=nav-text>打乱数组</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%8C%89%E6%9D%83%E9%87%8D%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9><span class=nav-number>4.2.</span> <span class=nav-text>按权重随机选择</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%93%BE%E8%A1%A8%E9%9A%8F%E6%9C%BA%E8%8A%82%E7%82%B9><span class=nav-number>4.3.</span> <span class=nav-text>链表随机节点</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BD%8D%E8%BF%90%E7%AE%97><span class=nav-number>5.</span> <span class=nav-text>位运算</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF><span class=nav-number>5.1.</span> <span class=nav-text>最大单词长度乘积</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0><span class=nav-number>5.2.</span> <span class=nav-text>比特位计数</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84><span class=nav-number></span> <span class=nav-text>数据结构</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%95%B0%E7%BB%84><span class=nav-number>1.</span> <span class=nav-text>数组</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97><span class=nav-number>1.1.</span> <span class=nav-text>找到所有数组中消失的数字</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F><span class=nav-number>1.2.</span> <span class=nav-text>旋转图像</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#769%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97><span class=nav-number>1.3.</span> <span class=nav-text>769最多能完成排序的块</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97><span class=nav-number></span> <span class=nav-text>栈与队列</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#232-%E4%BD%BF%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97><span class=nav-number>1.</span> <span class=nav-text>232 使用栈实现队列</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#155-%E6%9C%80%E5%B0%8F%E6%A0%88><span class=nav-number>2.</span> <span class=nav-text>155 最小栈</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7><span class=nav-number>3.</span> <span class=nav-text>20 有效的括号</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6><span class=nav-number>4.</span> <span class=nav-text>739 每日温度</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97><span class=nav-number></span> <span class=nav-text>优先队列</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#23-merge-k-sorted-lists><span class=nav-number>0.1.</span> <span class=nav-text>23 merge k sorted lists</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97><span class=nav-number>1.</span> <span class=nav-text>双端队列</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC><span class=nav-number>1.1.</span> <span class=nav-text>滑动窗口最大值</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%93%88%E5%B8%8C%E8%A1%A8><span class=nav-number>2.</span> <span class=nav-text>哈希表</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#149-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97><span class=nav-number>2.1.</span> <span class=nav-text>149 最长连续序列</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E6%9C%89%E5%A4%9A%E5%B0%91%E7%82%B9><span class=nav-number>2.2.</span> <span class=nav-text>线上最多有多少点</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A4%9A%E9%87%8D%E6%98%A0%E5%B0%84><span class=nav-number>3.</span> <span class=nav-text>多重映射</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%89%8D%E7%BC%80%E4%BA%8C%E5%88%86%E5%92%8C-%E4%BA%8C%E5%88%86%E5%9B%BE><span class=nav-number>4.</span> <span class=nav-text>前缀二分和 二分图</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#304-2D%E8%8C%83%E5%9B%B4%E5%92%8C%E6%9F%A5%E8%AF%A2><span class=nav-number>4.1.</span> <span class=nav-text>304 2D范围和查询</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84><span class=nav-number>4.2.</span> <span class=nav-text>和为k的子数组</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%AD%97%E7%AC%A6%E4%B8%B2><span class=nav-number></span> <span class=nav-text>字符串</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#std-string-%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C><span class=nav-number></span> <span class=nav-text>std::string 的常见操作</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96><span class=nav-number>1.</span> <span class=nav-text>1. 创建和初始化</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-%E8%AE%BF%E9%97%AE%E5%AD%97%E7%AC%A6><span class=nav-number>2.</span> <span class=nav-text>2. 访问字符</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-%E5%AE%B9%E9%87%8F%E5%92%8C%E5%A4%A7%E5%B0%8F><span class=nav-number>3.</span> <span class=nav-text>3. 容量和大小</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BF%AE%E6%94%B9><span class=nav-number>4.</span> <span class=nav-text>4. 字符串修改</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#5-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%AF%94%E8%BE%83><span class=nav-number>5.</span> <span class=nav-text>5. 查找和比较</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#6-%E8%BD%AC%E6%8D%A2%E4%B8%BA-C-%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2><span class=nav-number>6.</span> <span class=nav-text>6. 转换为 C 风格字符串</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#7-%E5%AD%90%E4%B8%B2%E6%8F%90%E5%8F%96><span class=nav-number>7.</span> <span class=nav-text>7. 子串提取</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83><span class=nav-number>8.</span> <span class=nav-text>字符串比较</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1249-%E7%A7%BB%E9%99%A4%E6%97%A0%E6%95%88%E6%8B%AC%E5%8F%B7><span class=nav-number>8.1.</span> <span class=nav-text>1249 移除无效括号</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%90%86%E8%A7%A3><span class=nav-number>9.</span> <span class=nav-text>字符串理解</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#227-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8II><span class=nav-number>9.1.</span> <span class=nav-text>227 基本计算器II</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%93%BE%E8%A1%A8><span class=nav-number></span> <span class=nav-text>链表</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#206-%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8><span class=nav-number>0.1.</span> <span class=nav-text>206 翻转链表</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#21-%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8><span class=nav-number>0.2.</span> <span class=nav-text>21 合并有序链表</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9><span class=nav-number>0.3.</span> <span class=nav-text>24 两两交换链表中的节点</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8><span class=nav-number>0.4.</span> <span class=nav-text>160 相交链表</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8><span class=nav-number>0.5.</span> <span class=nav-text>234 回文链表</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BA%8C%E5%8F%89%E6%A0%91><span class=nav-number>1.</span> <span class=nav-text>二叉树</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6><span class=nav-number>1.1.</span> <span class=nav-text>二叉树最大深度</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91><span class=nav-number>1.2.</span> <span class=nav-text>二叉平衡树</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E9%95%BF%E7%9B%B4%E5%BE%84><span class=nav-number>1.3.</span> <span class=nav-text>二叉树最长直径</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%B7%AF%E5%BE%84%E5%92%8C><span class=nav-number>1.4.</span> <span class=nav-text>路径和</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%AF%B9%E7%A7%B0><span class=nav-number>1.5.</span> <span class=nav-text>判断一个二叉树是否对称</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%88%A0%E7%82%B9%E6%88%90%E6%9E%97><span class=nav-number>1.6.</span> <span class=nav-text>删点成林</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-1><span class=nav-number>2.</span> <span class=nav-text>层次遍历</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%AF%8F%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC><span class=nav-number>2.1.</span> <span class=nav-text>二叉树每层平均值</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86><span class=nav-number>3.</span> <span class=nav-text>二叉树的前中后序遍历</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BB%8E%E5%85%88%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91><span class=nav-number>3.1.</span> <span class=nav-text>从先序和中序构建二叉树</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86><span class=nav-number>3.2.</span> <span class=nav-text>先序遍历</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91><span class=nav-number>4.</span> <span class=nav-text>二叉查找树</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91><span class=nav-number>4.1.</span> <span class=nav-text>恢复二叉搜索树</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BF%AE%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91><span class=nav-number>4.2.</span> <span class=nav-text>修建二叉搜索树</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%AD%97%E5%85%B8%E6%A0%91><span class=nav-number>4.3.</span> <span class=nav-text>字典树</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%9B%BE><span class=nav-number>5.</span> <span class=nav-text>图</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BA%8C%E5%88%86%E5%9B%BE><span class=nav-number>5.1.</span> <span class=nav-text>二分图</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F><span class=nav-number>6.</span> <span class=nav-text>拓扑排序</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%B9%B6%E6%9F%A5%E9%9B%86><span class=nav-number>7.</span> <span class=nav-text>并查集</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#LRUCache><span class=nav-number>8.</span> <span class=nav-text>LRUCache</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%9C%89%E7%94%A8%E7%9A%84%E8%B5%84%E6%96%99><span class=nav-number></span> <span class=nav-text>有用的资料</span></a></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>263</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>16</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>224</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a><li class=links-of-blogroll-item><a href=https://www.lllomh.com/ rel=noopener target=_blank title=https://www.lllomh.com/>芈渡</a><li class=links-of-blogroll-item><a href=https://protool-ten.vercel.app/ rel=noopener target=_blank title=https://protool-ten.vercel.app/>protools</a></ul></div><div class="motion-element announcement"><div class=title></div><p class=content><p class=date></div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>文章词云</h3><div class="widget tagcloud" id=myCanvasContainer><canvas height=250 id=resCanvas style=width:100% width=250><ul class=tag-list itemprop=keywords><li class=tag-list-item><a class=tag-list-link href=/tags/algorithm/ rel=tag>algorithm</a><span class=tag-list-count>1</span><li class=tag-list-item><a class=tag-list-link href=/tags/leetcode/ rel=tag>leetcode</a><span class=tag-list-count>3</span></ul></canvas></div></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2026</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>4.4m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>66:09</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>document.addEventListener("DOMContentLoaded", function() {
    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {
        var pvContainer = document.getElementById("busuanzi_container_site_pv");
        if (pvContainer && pvContainer.style.display !== "none") {
            var pvElement = document.getElementById("busuanzi_value_site_pv");
            if (pvElement) {
                pvElement.innerHTML = parseInt(pvElement.innerHTML) + countOffset;
                clearInterval(int);
            }
        }
        
        var uvContainer = document.getElementById("busuanzi_container_site_uv");
        if (uvContainer && window.getComputedStyle(uvContainer).display !== "none")
        {
            var uvElement = document.getElementById("busuanzi_value_site_uv");
            if (uvElement) {
                uvElement.innerHTML = parseInt(uvElement.innerHTML) + countOffset; // 加上初始数据 
                clearInterval(int); // 停止检测
            }
        }
    }
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer></div><script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script><script src=/lib/anime.min.js></script><script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script><script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/pisces.js></script><script src=/js/next-boot.js></script><script src=/js/bookmark.js></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	 '.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
  
  // Reinitialize TagCanvas for tag cloud
  if (typeof TagCanvas !== 'undefined' && document.getElementById('resCanvas')) {
    try {
      TagCanvas.textFont = 'Trebuchet MS, Helvetica';
      TagCanvas.textColour = '#333';
      TagCanvas.textHeight = 20;
      TagCanvas.outlineColour = '#E2E1D1';
      TagCanvas.maxSpeed = 0.3;
      TagCanvas.freezeActive = true;
      TagCanvas.outlineMethod = 'block';
      TagCanvas.minBrightness = 0.2;
      TagCanvas.depth = 0.92;
      TagCanvas.pulsateTo = 0.6;
      TagCanvas.initial = [0.1,-0.1];
      TagCanvas.decel = 0.98;
      TagCanvas.reverse = true;
      TagCanvas.hideTags = false;
      TagCanvas.shadow = '#ccf';
      TagCanvas.shadowBlur = 3;
      TagCanvas.weight = false;
      TagCanvas.imageScale = null;
      TagCanvas.fadeIn = 1000;
      TagCanvas.clickToFront = 600;
      TagCanvas.lock = false;
      TagCanvas.Start('resCanvas');
      TagCanvas.tc['resCanvas'].Wheel(true);
    } catch(e) {
      console.log('TagCanvas initialization failed:', e);
    }
  }
});</script><script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script><script src=/js/algolia-search.js></script><script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script><div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div><script charset=utf-8 defer src=/js/tagcanvas.js></script><script charset=utf-8 defer src=/js/tagcloud.js></script><script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script><script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script><script src=/js/src/activate-power-mode.min.js></script><script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script>
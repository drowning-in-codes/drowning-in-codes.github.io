<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"0F9LEEVW82","apiKey":"78839e9f9be09d081c5c4da81975cd19","indexName":"sekyoblog_sec","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content=MySQL和Redis是项目中常用的中间件. name=description><meta content=article property=og:type><meta content=MySQL与Redis经典面经 property=og:title><meta content=https://www.sekyoro.top/2025/09/02/MySQL%E4%B8%8ERedis%E7%BB%8F%E5%85%B8%E9%9D%A2%E7%BB%8F/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content=MySQL和Redis是项目中常用的中间件. property=og:description><meta content=zh_CN property=og:locale><meta content=https://cdn.tobebetterjavaer.com/stutymore/redis-20250522100735.png property=og:image><meta content=https://cdn.tobebetterjavaer.com/stutymore/redis-20250522102052.png property=og:image><meta content=https://cdn.tobebetterjavaer.com/stutymore/redis-20240325225250.png property=og:image><meta content=https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-e4a61193-515a-409f-a436-2733abc3a86e.png property=og:image><meta content=https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-37c07418-9cd8-43d9-90e7-0cb43b329025.png property=og:image><meta content=https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-6d4ab7e6-8337-4576-bbf0-79202a1c3331.png property=og:image><meta content=https://cdn.tobebetterjavaer.com/stutymore/redis-20250527115004.png property=og:image><meta content=2025-09-02T11:28:51.000Z property=article:published_time><meta content=2025-10-23T15:05:06.364Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content=Redis property=article:tag><meta content=MySQL property=article:tag><meta content=summary name=twitter:card><meta content=https://cdn.tobebetterjavaer.com/stutymore/redis-20250522100735.png name=twitter:image><link href=https://www.sekyoro.top/2025/09/02/MySQL%E4%B8%8ERedis%E7%BB%8F%E5%85%B8%E9%9D%A2%E7%BB%8F/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>MySQL与Redis经典面经 | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2025/09/02/MySQL%E4%B8%8ERedis%E7%BB%8F%E5%85%B8%E9%9D%A2%E7%BB%8F/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>MySQL与Redis经典面经</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2025-09-02 19:28:51" datetime=2025-09-02T19:28:51+08:00>2025-09-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-10-23 23:05:06" datetime=2025-10-23T23:05:06+08:00 itemprop=dateModified>2025-10-23</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>14k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>13 分钟</span> </span></div></header><div class=post-body itemprop=articleBody><div class=post-tags><a href=/tags/Redis/ rel=tag># Redis</a><a href=/tags/MySQL/ rel=tag># MySQL</a></div><p>MySQL和Redis是项目中常用的中间件.<br><span id=more></span><h1 id=Redis><a class=headerlink href=#Redis title=Redis></a>Redis</h1><h2 id=数据类型、底层结构以及使用场景><a class=headerlink href=#数据类型、底层结构以及使用场景 title=数据类型、底层结构以及使用场景></a>数据类型、底层结构以及使用场景</h2><p>Redis 提供了丰富的数据类型，常见的有五种数据类型：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）</strong><p>随着 Redis 版本的更新，后面又支持了四种数据类型： <strong>BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）</strong>。<p>应用场景：<ul><li>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。<li>List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。<li>Hash 类型：缓存对象、购物车等。<li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。<li><p>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</p><li><p>BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；</p><li>HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；<li>GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；<li>Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。</ul><p>字符串是最基本的数据类型，可以存储文本、数字或者二进制数据，最大容量是 512 MB。适合缓存单个对象，比如验证码、token、计数器等。<p>列表是一个有序的元素集合，支持从头部或尾部插入/删除元素，常用于消息队列或任务列表<p>哈希是一个键值对集合，适合存储对象，如商品信息、用户信息等。比如说 <code>value = {name: '沉默王二', age: 18}</code>。<p>集合是无序且不重复的，支持交集、并集操作，查询效率能达到 <code>O(1)</code> 级别，主要用于去重、标签、共同好友等场景。<p>有序集合的元素按分数进行排序，支持范围查询，适用于排行榜或优先级队列。<p>Bitmap 可以把一组二进制位紧凑地存储在一块连续内存中，每一位代表一个对象的状态，比如是否签到、是否活跃等。<h2 id=Redis常用命令><a class=headerlink href=#Redis常用命令 title=Redis常用命令></a>Redis常用命令</h2><p>Redis 支持多种数据结构，常用的命令也比较多，比如说操作字符串可以用 <code>SET/GET/INCR</code>，操作哈希可以用 <code>HSET/HGET/HGETALL</code>，操作列表可以用 <code>LPUSH/LPOP/LRANGE</code>，操作集合可以用 <code>SADD/SISMEMBER</code>，操作有序集合可以用 <code>ZADD/ZRANGE/ZINCRBY</code>等，通用命令有 <code>EXPIRE/DEL/KEYS</code> 等。<h2 id=持久化><a class=headerlink href=#持久化 title=持久化></a>持久化</h2><p>为了保证内存中的数据不会丢失，Redis 实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据。Redis 共有三种数据持久化的方式：<ul><li><strong>AOF 日志</strong>：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；<li><strong>RDB 快照</strong>：将某一时刻的内存数据，以二进制的方式写入磁盘；</ul><h3 id=RDB><a class=headerlink href=#RDB title=RDB></a>RDB</h3><p>RDB 持久化机制可以在指定的时间间隔内将 Redis 某一时刻的数据保存到磁盘上的 RDB 文件中，当 Redis 重启时，可以通过加载这个 RDB 文件来恢复数据。<p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：<ul><li>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；<li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong></ul><p>也可以在 Redis 配置文件中设置 RDB 持久化参数 <code>save &LTseconds> &LTchanges></code>，表示在指定时间间隔内，如果有指定数量的键发生变化，就会自动触发 RDB 持久化。<p>第二种，主从复制时，当从节点第一次连接到主节点时，主节点会自动执行 bgsave 生成 RDB 文件，并将其发送给从节点<p>RDB 通过 fork 子进程在特定时间点对内存数据进行全量备份，生成二进制格式的快照文件。其最大优势在于<strong>备份恢复效率高，文件紧凑，恢复速度快</strong>，适合大规模数据的备份和迁移场景.<p>缺点是可能丢失两次快照期间的所有数据变更。<p>AOF 会记录每一条修改数据的写命令。这种日志追加的方式让 AOF 能够提供接近实时的数据备份，数据丢失风险可以控制在 1 秒内甚至完全避免。<p>缺点是文件体积较大，恢复速度慢。<h3 id=AOF><a class=headerlink href=#AOF title=AOF></a>AOF</h3><p>Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。<h4 id=AOF刷盘策略><a class=headerlink href=#AOF刷盘策略 title=AOF刷盘策略></a>AOF刷盘策略</h4><ul><li>写回硬盘的策略， 在 Redis.conf 配置文件中的 appendfsync 配置项可以有以下 3 种参数可填：<ul><li><strong>Always</strong>，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；<li><strong>Everysec</strong>，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；<li><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘</ul></ul><h4 id=AOF重写><a class=headerlink href=#AOF重写 title=AOF重写></a>AOF重写</h4><p>由于 AOF 文件会随着写操作的增加而不断增长，为了解决这个问题， Redis 提供了重写机制来对 AOF 文件进行压缩和优化<p>第二种是在 Redis 配置文件中设置自动重写参数，比如说 <code>auto-aof-rewrite-percentage</code> 和 <code>auto-aof-rewrite-min-size</code>，表示当 AOF 文件大小超过指定值时，自动触发重写。<figure class="highlight apache"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attribute>auto</span>-aof-rewrite-percentage <span class=number>100</span>  # 默认值<span class=number>100</span>，表示当前AOF文件大小相比上次重写后大小增长了多少百分比时触发重写</span><br><span class=line><span class=attribute>auto</span>-aof-rewrite-min-size <span class=number>64</span>mb  # 默认值<span class=number>64</span>MB，表示AOF文件至少要达到这个大小才会考虑重写</span><br></pre></table></figure><p>Redis 在收到重写指令后，会创建一个子进程，并 fork 一份与父进程完全相同的数据副本，然后遍历内存中的所有键值对，生成重建它们所需的最少命令。比如说多个 RPUSH 命令可以合并为一个带有多个参数的 RPUSH；<p>比如说一个键被设置后又被删除，这个键的所有操作都不会被写入新 AOF。<p>比如说使用 <code>SADD key member1 member2 member3</code> 代替多个单独的 <code>SADD key memberX</code>。<p>子进程在执行 AOF 重写的同时，主进程可以继续处理来自客户端的命令。<p>为了保证数据一致性，Redis 使用了 AOF 重写缓冲区机制，主进程在执行写操作时，会将命令同时写入旧的 AOF 文件和重写缓冲区。<p>等子进程完成重写后，会向主进程发送一个信号，主进程收到后将重写缓冲区中的命令追加到新的 AOF 文件中，然后调用操作系统的 rename，将旧的 AOF 文件替换为新的 AOF 文件。<p>AOF 文件存储的是什么类型的数据？<p>AOF 文件存储的是 Redis 服务器接收到的写命令数据，以 Redis 协议格式保存。<p>这种格式的特点是，每个命令以*开头，后跟参数的数量，每个参数前用<code>$</code>符号，后跟参数字节长度，然后是参数的实际内容。<h3 id=混合持久化><a class=headerlink href=#混合持久化 title=混合持久化></a>混合持久化</h3><p>混合持久化工作在 <strong>AOF 日志重写过程</strong>，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。<p>配置文件中设置 <code>aof-use-rdb-preamble yes</code><h2 id=高可用><a class=headerlink href=#高可用 title=高可用></a>高可用</h2><h3 id=主从复制><a class=headerlink href=#主从复制 title=主从复制></a>主从复制</h3><p>主从复制允许从节点维护主节点的数据副本。在这种架构中，一个主节点可以连接多个从节点，从而形成一主多从的结构。主节点负责处理写操作，从节点自动同步主节点的数据变更，并处理读请求，从而实现读写分离。<p>主从复制作用<p>第一，主节点负责处理写请求，从节点负责处理读请求，从而实现读写分离，减轻主节点压力的同时提升系统的并发能力<p>第二，从节点可以作为主节点的数据备份，当主节点发生故障时，可以快速将从节点提升为新的主节点，从而保证系统的高可用性。<p>主从复制数据不一致性<p>Redis 的主从复制是异步进行的，因此在主节点宕机、网络波动或复制延迟较高时会出现从节点数据不同步的情况。比如主节点写入数据后宕机，但从节点还未来得及复制，就会出现数据不一致。另一个容易被忽视的因素是主节点内存压力。当主节点内存接近上限并启用了淘汰策略时，某些键可能被自动删除，而这些删除操作如果未能及时同步，就会造成从节点保留了主节点已经不存在的数据。<p>主从复制不一致的解决方案<p>首先是网络层面的优化，理想情况下，主从节点应该部署在同一个网络区域内，避免跨区域的网络延迟。<p>其次是配置层面的调整，比如说适当增大复制积压缓冲区的大小和存活时间，以便从节点重连后进行增量同步而不是全量同步，以最大程度减少主从同步的延迟。<p>第三是引入监控和自动修复机制，定期检查主从节点的数据一致性。<p>比如说通过比较主从的 offset 差值判断从库是否落后。一旦超过设定阈值，就将从节点剔除，并重新进行全量同步。<h4 id=主从复制原理><a class=headerlink href=#主从复制原理 title=主从复制原理></a>主从复制原理</h4><h2 id=缓存设计><a class=headerlink href=#缓存设计 title=缓存设计></a>缓存设计</h2><h3 id=如何保证缓存和数据库的一致性><a class=headerlink href=#如何保证缓存和数据库的一致性 title=如何保证缓存和数据库的一致性></a>如何保证缓存和数据库的一致性</h3><p>对于允许短暂不一致性的数据，可以采用<strong>旁路缓存和TTL过期机制</strong>来保证缓存和数据库的一致性。<p>具体读取时先查Redis,未命中再查MySQL,同时给缓存设置一个过期时间；<p>更新时先更新MySQL,再删除Redis. <strong>适用于读多写少</strong>的场景,TTL 过期时间也能够保证即使更新操作失败，未能及时删除缓存，过期时间也能确保数据最终一致。<p><strong>为什么要删除缓存而不是更新缓存</strong><p>最初设计缓存策略时，我也考虑过直接更新缓存，但通过实践发现，删除缓存是更优的选择。<p>最主要的原因是在并发环境下，假设我们有两个并发的更新操作，如果采用更新缓存的策略，就可能出现这样的时序问题：<ul><li>操作 A 和操作 B 同时发生，A 先更新 MySQL 将值改为 10，B 后更新 MySQL 将值改为 11。但在缓存更新时，可能 B 先执行将缓存设为 11，然后 A 才执行将缓存设为10。这样就会造成 MySQL 是 11 但 Redis 是 10 的不一致状态。</ul><p>而采用删除策略，无论 A 和 B 谁先删除缓存，后续的读取操作都会从 MySQL 获取最新值。<p>另外，相对而言，删除缓存的速度比更新缓存的速度快得多。因为删除操作只是简单的 DEL 命令，而更新可能需要重新序列化整个对象再写入缓存<p><img alt="技术派：更新 Redis 而不是删除 Redis" data-src=https://cdn.tobebetterjavaer.com/stutymore/redis-20250522100735.png style=zoom:50%;><p><strong>为什么要先更新数据库,再删除缓存</strong><p>假设我们采用先删缓存再更新数据库的策略，在高并发场景下就可能出现这样的问题：<ul><li>线程 A 要更新用户信息，先删除了缓存<li>线程 B 恰好此时要读取该用户信息，发现缓存为空，于是查询数据库，此时还是旧值<li>线程 B 将查到的旧值重新放入缓存<li>线程 A 完成数据库更新</ul><p>结果就是数据库是新的值，但缓存中还是旧值。<p><img alt="技术派：先删 Redis 再更新 MySQL" data-src=https://cdn.tobebetterjavaer.com/stutymore/redis-20250522102052.png><p><strong>对缓存数据库一致性要求很高，该怎么办</strong><p>当业务对缓存与数据库的一致性要求很高时，比如支付系统、库存管理等场景，我会采用多种策略来保证强一致性。<p><img alt="二哥的 Java 进阶之路：缓存强一致性" data-src=https://cdn.tobebetterjavaer.com/stutymore/redis-20240325225250.png style=zoom:67%;><p>第一种，引入消息队列来保证缓存最终被删除，比如说在数据库更新的事务中插入一条本地消息记录，事务提交后异步发送给 MQ 进行缓存删除。<p><img alt=三分恶面渣逆袭：消息队列保证key被删除 data-src=https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-e4a61193-515a-409f-a436-2733abc3a86e.png style=zoom:50%;><p>第二种,使用Canal监听Mysql的binlog,在数据更新时,将数据变更记录到消息队列中,消费者消息监听到变更后去删除缓存.这种方案的优势是完全解耦了业务代码和缓存维护逻辑。<p><img alt=三分恶面渣逆袭：数据库订阅+消息队列保证key被删除 data-src=https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-37c07418-9cd8-43d9-90e7-0cb43b329025.png style=zoom:50%;><p>如果说业务比较简单，不需要上消息队列，可以<strong>通过延迟双删策略降低缓存和数据库不一致</strong>的时间窗口，在第一次删除缓存之后，过一段时间之后，再次尝试删除缓存。<p>最后，无论采用哪种策略，最好为缓存设置一个合理的过期时间作为最后的保障。即使所有的主动删除机制都失败了，TTL 也能确保数据最终达到一致：例如,关键数据，短TTL,不太重要数据缓存时间更长.<p>能确保即使出现极端情况，数据不一致的影响也是可控的<h3 id=如何保证本地缓存和分布式缓存的一致性><a class=headerlink href=#如何保证本地缓存和分布式缓存的一致性 title=如何保证本地缓存和分布式缓存的一致性></a>如何保证本地缓存和分布式缓存的一致性</h3><p>为了减轻 Redis 的负载压力，我又追加了一层<strong>本地缓存 Caffeine</strong><p><img alt=三分恶面渣逆袭：本地缓存+分布式缓存 data-src=https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-6d4ab7e6-8337-4576-bbf0-79202a1c3331.png style=zoom:67%;><p>为了保证 Caffeine 和 Redis 缓存的一致性，我采用的策略是当数据更新时，通过 <strong>Redis 的 pub/sub 机制向所有应用实例发送缓存更新通知，收到通知后的实例立即更新或者删除本地缓存</strong>。<p>考虑到消息可能丢失，我还会引入版本号机制作为补充。每次从 Redis 获取数据时添加一个最新的版本号。从本地缓存获取数据前，先检查自己的版本号是否是最新的，如果发现版本落后，就主动从 Redis 中获取最新数据。<h4 id=在项目中多个地方都要使用到二级缓存的逻辑，如何设计这一块？><a class=headerlink href=#在项目中多个地方都要使用到二级缓存的逻辑，如何设计这一块？ title=在项目中多个地方都要使用到二级缓存的逻辑，如何设计这一块？></a>在项目中多个地方都要使用到二级缓存的逻辑，如何设计这一块？</h4><p>将二级缓存抽象成一个统一的组件。设计一个 CacheManager 作为核心入口，提供 get、put、evict 等基本操作，执行先查本地缓存，再查分布式缓存，最后查数据库的完整流程。<p><strong>本地缓存和Redis的区别</strong><p>Redis 可以部署在多个节点上，<strong>支持数据分片、主从复制和集群</strong>。而<strong>本地缓存只能在单个服务器</strong>上使用。<p>对于<strong>读取频率极高、数据相对稳定、允许短暂不一致的数据，我优先选择本地缓存</strong>。比如<strong>系统配置信息、用户权限数据、商品分类信息</strong>等。<p>而对于<strong>需要实时同步、数据变化频繁、多个服务需要共享的数据，我会选择 Redis。比如用户会话信息、购物车数据、实时统计信息</strong>等。<h3 id=什么是热Key><a class=headerlink href=#什么是热Key title=什么是热Key></a>什么是热Key</h3><p>热 Key，就是指在很短时间内被频繁访问的键。比如电商大促期间爆款商品的详情信息，流量明星爆瓜时的个人资料、热门话题等，都可能成为热Key。<p>由于 Redis 是单线程模型，大量请求集中到同一个键会导致该 Redis 节点的 CPU 使用率飙升，响应时间变长。<strong>在 Redis 集群环境下，热Key 还会导致数据分布不均衡，某个节点承受的压力过大</strong>而其他节点相对空闲。更严重的情况是，当热Key 过期或被误删时，会引发缓存击穿问题。<p><strong>如何监控热key</strong><p>临时的方案可以使用 <code>redis-cli --hotkeys</code> 命令来监控 Redis 中的热 Key。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>redis-cli -h <span class=tag><<span class=name>address</span>></span> -p <span class=tag><<span class=name>port</span>></span> -a<span class=tag><<span class=name>password</span>></span> — hotkey</span><br></pre></table></figure><p>或者在访问缓存时，在<strong>本地维护一个计数器，当某个键的访问次数在一分钟内超过设定阈值，就将其标记为热Key。</strong><p><strong>如何处理热key</strong><p>最有效的解决方法是增加本地缓存，将热 Key 缓存到本地内存中，这样请求就不需要访问 Redis 了。<p><strong>对于一些特别热的 Key，可以将其拆分成多个子 Key，然后随机分布到不同的 Redis 节点上</strong>。比如将 <code>hot_product:12345</code> 拆分成 <code>hot_product:12345:1</code>、<code>hot_product:12345:2</code> 等多个副本，读取时随机选择其中一个。<h4 id=如何处理大Key><a class=headerlink href=#如何处理大Key title=如何处理大Key></a>如何处理大Key</h4><p>大Key 是指占用内存空间较大的缓存键，比如超过 10M 的键值对。常见的大Key 类型包括：包含大量元素的 List、Set、Hash 结构，存储大文件的 String 类型，以及包含复杂嵌套对象的 JSON 数据等。<p>在内存有限的情况下，可能导致 Redis 内存不足。另外，<strong>大Key 还会导致主从复制同步延迟，甚至引发网络拥塞。</strong>可以通过 <code>redis-cli --bigkeys</code> 命令来监控 Redis 中的大 Key。<p>或者编写脚本进行全量扫描,使用SCAN命令遍历所有键.<p><strong>对于大 Key 问题，最根本的解决方案是拆分大 Key，将其拆分成多个小 Key 存储</strong>。比如将一个包含大量用户信息的 Hash 拆分成多个小 Hash。<p>另外，对于 JSON 数据，可以进行 Gzip 压缩后再存储，虽然会增加一些 CPU 开销，但在内存敏感的场景在是值得的。<h4 id=缓存预热怎么做><a class=headerlink href=#缓存预热怎么做 title=缓存预热怎么做></a>缓存预热怎么做</h4><p>缓存预热是指在系统启动或者特定时间点，提前将热点数据加载到缓存中，避免冷启动时大量请求直接打到数据库。会在<strong>项目启动时将热门文章提前加载到 Redis 中，在每天凌晨定时将最新的站点地图更新到 Redis中，以确保用户在第一次访问时就能获取到缓存数据</strong>，从而减轻数据库的压力。<h3 id=无底洞问题是什么-如何解决><a title="无底洞问题是什么 如何解决" class=headerlink href=#无底洞问题是什么-如何解决></a>无底洞问题是什么 如何解决</h3><p>“Redis 无底洞问题”并非指 Redis 本身的漏洞，而是指在<strong>分布式缓存集群</strong>中，由于<strong>不当使用</strong>或<strong>配置失当</strong>，<strong>导致集群性能急剧下降，资源被耗尽，仿佛陷入了一个无法填满的无底洞</strong>。<p>无底洞问题的核心在于，随着缓存节点数量的增加，虽然总的存储容量和理论吞吐量都在增长，但是单个请求的响应时间反而变长了。<p>这个问题的根本原因是网络通信开销的增加。当<strong>节点数量从几十个增长到几千个时，客户端需要与更多的节点进行通信</strong>。其次就是<strong>数据分布的碎片化。随着节点增多，数据分散得更加细碎</strong>，原本可以在一个节点获取的相关数据，现在可能分散在多个节点上。<p>针对这个问题，可以采取以下几种解决方案：<p>第一，可以将同一节点的多个请求合并成一个批量请求，减少网络往返次数。<p>第二，可以使用一致性哈希算法来优化数据分布，减少数据迁移和重分布的开销。<h3 id=Redis运维><a class=headerlink href=#Redis运维 title=Redis运维></a>Redis运维</h3><h4 id=Redis报内存不足怎么处理><a class=headerlink href=#Redis报内存不足怎么处理 title=Redis报内存不足怎么处理></a>Redis报内存不足怎么处理</h4><p>Redis 报内存不足时，通常是因为 Redis 占用的物理内存已经接近或者超过了配置的最大内存限制。这时可以采取以下几种步骤来处理：<p>第一，使用 <code>INFO memory</code> 命令查看 Redis 的内存使用情况，看看是否真的达到了最大内存限制。<p>第二，如果服务器还有可用内存的话，修改 <code>redis.conf</code> 中的 <code>maxmemory</code> 参数，增加 Redis 的最大内存限制。比如将最大内存设置为 8GB<p>第三，修改 <code>maxmemory-policy</code> 参数来调整内存淘汰策略。比如可以选择 <code>allkeys-lru</code> 策略，让 Redis 自动删除最近最少使用的键<h4 id=redis-key过期策略有哪些><a title="redis key过期策略有哪些" class=headerlink href=#redis-key过期策略有哪些></a>redis key过期策略有哪些</h4><p>redis键值对过期删除策略:<strong>定期删除</strong>以及<strong>惰性删除</strong>.<p>惰性删除是最基本的策略，当客户端访问一个 key 时，Redis 会检查该 key 是否已过期，如果过期就会立即删除并返回 nil。这种策略的优点是不会有额外的 CPU 开销，只在访问 key 时才检查。但问题是如果一个过期的 key 永远不被访问，它就会一直占用内存。<p>于是就有了定期删除策略，Redis 会定期随机选择一些设置了过期时间的 key 进行检查，删除其中已过期的 key。这个过程默认每秒执行 10 次，每次随机选择 20 个 key 进行检查。<h4 id=redis有哪些内存淘汰策略><a class=headerlink href=#redis有哪些内存淘汰策略 title=redis有哪些内存淘汰策略></a>redis有哪些内存淘汰策略</h4><p>当内存使用接近 maxmemory 限制时，Redis 会依据内存淘汰策略来决定删除哪些 key 以缓解内存压力。<p><img alt=码哥字节：内存淘汰策略 data-src=https://cdn.tobebetterjavaer.com/stutymore/redis-20250527115004.png style=zoom:67%;><p>常用的内存淘汰策略有八种，分别是默认的 noeviction，<strong>内存不足时不会删除任何 key，直接返回错误信息</strong>，生产环境下基本上不会使用。<p>然后是针对所有 key 的 allkeys-lru、allkeys-lfu 和 allkeys-random。<strong>lru 会删除最近最少使用的 key，在纯缓存场景中最常用，能自动保留热点数据</strong>；<strong>lfu 会删除访问频率最低的 key，更适合长期运行的系统</strong>；random 会随机删除一些 key，一般不推荐使用。<p>其次是<strong>针对设置了过期时间的 key</strong>，有 volatile-lru、volatile-lfu、volatile-ttl 和 volatile-random。<p>重要数据不设置过期时间，在volatile-<em>策略下不会被淘汰,临时数据设置过期时间，可以被volatile-</em>策略淘汰.<h4 id=LRU和LFU的差别><a class=headerlink href=#LRU和LFU的差别 title=LRU和LFU的差别></a>LRU和LFU的差别</h4><p>LRU 是 Least Recently Used 的缩写，<strong>基于时间维度，淘汰最近最少访问的键</strong>。<p>LFU 是 Least Frequently Used 的缩写，<strong>基于次数维度，淘汰访问频率最低的键。</strong><p>假设缓存中有三个数据 A、B、C，在 LRU 场景下，如果访问顺序是 A→B→C→A，那么此时的 LRU 顺序是B→C→A，如果需要淘汰，会先删除 B。<p>但在 LFU 场景下，如果 A 被访问了 5 次，B 被访问了 2 次，C 被访问了 1 次，那么无论最近的访问顺序如何，都会优先淘汰 C，因为它的访问频率最低<p>LRU 更适合有明显时间局部性的场景，比如在新闻网站中，用户更关心最新的新闻，而昨天的新闻访问量会急剧下降。这种情况下，LRU 能很好地保留用户当前关心的热点内容。<p>LFU 则更适合有长期访问模式的场景，更强调“热度”，比如在电商平台中，某些商品可能长期保持热销状态，即使它们的访问时间间隔较长，但由于访问频率高，LFU 会优先保留这些商品的信息<h4 id=Redis发生了阻塞如何处理><a class=headerlink href=#Redis发生了阻塞如何处理 title=Redis发生了阻塞如何处理></a>Redis发生了阻塞如何处理</h4><p>Redis 发生阻塞在生产环境中是比较严重的问题，当发现 Redis 变慢时，我会<strong>先通过 monitor 命令查看当前正在执行的命令，或者使用 slowlog 命令查看慢查询日志。</strong><p>大Key 是导致 Redis 阻塞的主要原因之一。比如说直接 DEL 一个包含几百万个元素的 Set，就会导致 Redis 阻塞几秒钟甚至更久。<p>这时候可以用 UNLINK 命令替代 DEL 来异步删除，避免阻塞主线程。<figure class="highlight avrasm"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=meta># 使用 UNLINK 异步删除大 Key</span></span><br><span class=line>redis-<span class=keyword>cli</span> UNLINK big_key</span><br></pre></table></figure><p>对于<strong>非常大的集合，可以使用 SCAN 命令分批删除。</strong><figure class="highlight processing"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> safeBatchProcess(<span class=keyword>String</span> <span class=built_in>key</span>) {</span><br><span class=line>    ScanOptions options = ScanOptions.scanOptions().count(<span class=number>1000</span>).build();</span><br><span class=line>    Cursor<<span class=keyword>String</span>> <span class=built_in>cursor</span> = redisTemplate.opsForSet().scan(<span class=built_in>key</span>, options);</span><br><span class=line>    </span><br><span class=line>    <span class=keyword>while</span> (<span class=built_in>cursor</span>.hasNext()) {</span><br><span class=line>        <span class=keyword>String</span> member = <span class=built_in>cursor</span>.next();</span><br><span class=line>        <span class=comment>// 分批处理，避免阻塞</span></span><br><span class=line>        processElement(member);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>另外，当 <strong>Redis 使用的内存超过物理内存时，操作系统会将部分内存交换到磁盘，这时候会导致 Redis 响应变慢。</strong> <strong>可以使用 <code>free -h</code> 检查内存的使用情况 ；确认 Redis 的 maxmemory 设置是否合理；如果发生了内存交换，立即调整 maxmemory 并清理一些不重要的数据</strong>。<h2 id=Redis应用><a class=headerlink href=#Redis应用 title=Redis应用></a>Redis应用</h2><h3 id=Redis如何实现异步消息队列><a class=headerlink href=#Redis如何实现异步消息队列 title=Redis如何实现异步消息队列></a>Redis如何实现异步消息队列</h3><p>Redis 实现异步消息队列是一个很实用的技术方案，最简单的方式是使用 List 配合 LPUSH 和 RPOP 命令。另外就是用 Redis 的 Pub/Sub 来实现简单的消息广播和订阅。发布者将消息发布到指定的频道，订阅该频道的客户端就能收到消息。但是这两种方式都是不可靠的，因为没有 ACK 机制所以不能保证订阅者一定能收到消息，也不支持消息持久化。<h4 id=redis如何实现延迟消息队列><a class=headerlink href=#redis如何实现延迟消息队列 title=redis如何实现延迟消息队列></a>redis如何实现延迟消息队列</h4><p>延时消息队列在实际业务中很常见，比如订单超时取消、定时提醒等场景。Redis 虽然不是专业的消息队列，但可以很好地实现延时队列功能。<p>核心思路是利用 ZSet 的有序特性，<strong>将消息作为 member，把消息的执行时间作为 score</strong>。这样消息就会按照<strong>执行时间自动排序，我们只需要定期扫描当前时间之前的消息进行处理就可以了</strong><p>具体实现上，我会在生产者发送延时消息时，计算消息应该执行的时间戳，然后用 ZADD 命令将消息添加到 ZSet 中。<figure class="highlight apache"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attribute>ZADD</span> delay_queue <span class=number>1617024000</span> task<span class=number>1</span></span><br></pre></table></figure><p>消费者通过定时任务，使用 ZRANGEBYSCORE 命令获取当前时间之前的所有消息。<figure class="highlight apache"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attribute>ZREMRANGEBYSCORE</span> delay_queue -inf <span class=number>1617024000</span></span><br></pre></table></figure><p>处理完成后再用 ZREM 删除消息。<figure class="highlight apache"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attribute>ZREM</span> delay_queue task<span class=number>1</span></span><br></pre></table></figure><p>可以用这种方式<strong>实现文章定时发布的功能。作者在发布文章时，可以选择一个未来的时间节点，比如说 30 分钟后，系统就会向延时队列发送一条延时消息</strong>，然后定时任务就会在 30 分钟后将这条消息从延时队列中取出并发布文章。<h4 id=Redis支持事务吗><a class=headerlink href=#Redis支持事务吗 title=Redis支持事务吗></a>Redis支持事务吗</h4><p>Redis <strong>支持简单的事务</strong>，可以<strong>将 multi、exec、discard 和 watch 命令打包</strong>，然后一次性的按顺序执行。<p>基本流程是用 multi 开启事务，然后执行一系列命令，最后用 exec 提交。这些命令会被放入队列，在 exec 时批量执行。当客户端处于非事务状态时，所有发送给 Redis 服务的命令都会立即执行；但当客户端进入事务状态之后，这些命令会被放入一个事务队列中，然后立即返回 QUEUED，表示命令已入队。<p>当 exec 命令执行时，Redis 会将事务队列中的所有命令按先进先出的顺序执行。当事务队列里的命令全部执行完毕后，Redis 会返回一个数组，包含每个命令的执行结果。discard 命令用于取消一个事务，它会清空事务队列并退出事务状态。<strong>watch 命令用于监视一个或者多个 key</strong>，如果这个 key 在事务执行之前 被其他命令改动，那么事务将会被打断。但 <strong>Redis 的事务与 MySQL 的有很大不同，它并不支持回滚，也不支持隔离级别</strong>。<h4 id=Redis事务的原理><a class=headerlink href=#Redis事务的原理 title=Redis事务的原理></a>Redis事务的原理</h4><p>当执行 MULTI 命令时，Redis 会给这个客户端打一个事务的标记，<strong>表示这个客户端后面发送的命令不会被立即执行，而是被放到一个队列里排队等着</strong>。<strong>当 Redis 收到 EXEC 命令时，它会把队列里的命令一个个拿出来执行。因为 Redis 是单线程的，所以这个过程不会被其他命令打断</strong>，这就保证了Redis 事务的原子性。<p>当执行 WATCH 命令时，Redis 会将 key 添加到全局监视字典中；只要这些 key 在 EXEC 前被其他客户端修改，Redis 就会给相关客户端打上脏标记，<strong>EXEC 时发现事务已被干扰就会直接取消整个事务</strong>。DISCARD 做的事情很简单直接，首先检查客户端是否真的在事务状态，如果不在就报错；如果在事务状态，就清空事务队列并退出事务状态。<p>Redis <strong>事务不支持回滚，一旦 EXEC 命令被调用，所有命令都会被执行，即使有些命令可能执行失败</strong>。<p>Redis 的核心设计理念是简单、高效，而不是完整的 ACID 特性。而<strong>实现回滚需要在执行过程中保存大量的状态信息，并在发生错误时逆向执行命令以恢复原始状态</strong>。这会增加 Redis 的复杂性和性能开销。<h4 id=Redis的事务满足原子性吗-要怎么改进><a title="Redis的事务满足原子性吗 要怎么改进" class=headerlink href=#Redis的事务满足原子性吗-要怎么改进></a>Redis的事务满足原子性吗 要怎么改进</h4><p>Redis 的事务不能满足标准的原子性，因为它不支持事务回滚，也就是说，<strong>假如某个命令执行失败，整个事务并不会自动回滚到初始状态。</strong><p>可以<strong>使用 Lua 脚本来替代事务，脚本运行期间，Redis 不会处理其他命令</strong>，并且我们<strong>可以在脚本中处理整个业务逻辑，包括条件检查和错误处理，保证要么执行成功</strong>，要么保持最初的状态，不会出现一个命令执行失败、其他命令执行成功的情况。<h4 id=Redis事务的ACID特性><a class=headerlink href=#Redis事务的ACID特性 title=Redis事务的ACID特性></a>Redis事务的ACID特性</h4><p><strong>单个 Redis 命令的执行是原子性的</strong>，但 Redis 没有在事务上增加任何维持原子性的机制，所以 <strong>Redis 事务在执行过程中如果某个命令失败了，其他命令还是会继续执行，不会回滚</strong>。<p>一致性指的是，如果数据在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据也应该是一致的。但 <strong>Redis 事务并不保证一致性，因为如果事务中的某个命令失败了，其他命令仍然会执行，就会出现数据不一致的情况</strong>。<p><strong>Redis 是单线程执行事务的，并且不会中断，</strong>直到执行完所有事务队列中的命令为止。因此，我认为 Redis 的事务具有隔离性的特征。<p>Redis 事务的持久性完全依赖于 Redis 本身的持久化机制，如果开启了 AOF，那么事务中的命令会作为一个整体记录到 AOF 文件中，当然也要看 AOF 的 fsync 策略。如果只开启了 RDB，事务中的命令可能会在下次快照前丢失。如果两个都没有开启，肯定是不满足持久性的。<h4 id=Lua脚本操作Redis><a class=headerlink href=#Lua脚本操作Redis title=Lua脚本操作Redis></a>Lua脚本操作Redis</h4><p>Lua 脚本是处理 Redis 复杂操作的首选方案，比如说<strong>原子扣减库存</strong>、<strong>分布式锁</strong>、<strong>限流</strong>等业务场景，都可以通过 Lua 脚本来实现。<p>在秒杀场景下，可以用 Lua 脚本把所有检查逻辑都写在一起：先看库存够不够，再看用户有没有买过，所有条件都满足才扣减库存。因为整个脚本是原子执行的，Redis 在执行期间不会处理其他命令，所以可以彻底解决超卖问题。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>String luaScript = </span><br><span class=line>    <span class=string>"local stock = redis.call('GET', KEYS[1]) "</span> +</span><br><span class=line>    <span class=string>"if not stock or tonumber(stock) < tonumber(ARGV[2]) then "</span> +</span><br><span class=line>    <span class=string>"    return -1 "</span> +  <span class=comment>// 库存不足</span></span><br><span class=line>    <span class=string>"end "</span> +</span><br><span class=line>    <span class=string>"if redis.call('SISMEMBER', KEYS[2], ARGV[1]) == 1 then "</span> +</span><br><span class=line>    <span class=string>"    return -2 "</span> +  <span class=comment>// 重复购买</span></span><br><span class=line>    <span class=string>"end "</span> +</span><br><span class=line>    <span class=string>"redis.call('DECRBY', KEYS[1], ARGV[2]) "</span> +</span><br><span class=line>    <span class=string>"redis.call('SADD', KEYS[2], ARGV[1]) "</span> +</span><br><span class=line>    <span class=string>"return 1"</span>;</span><br></pre></table></figure><p>在分布式锁场景下，<strong>一开始用的 SETNX 命令来实现，结果发现如果程序异常退出，锁就死掉了。后来加了过期时间，但又发现可能误删其他线程的锁</strong>。最后还是用 Lua 脚本彻底解决了这个问题，确保只有锁的持有者才能释放锁。<figure class="highlight scilab"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>// 解锁脚本特别重要，必须验证是自己的锁才能删</span></span><br><span class=line>private final String UNLOCK_SCRIPT = </span><br><span class=line>    <span class=string>"if redis.call('</span>GET', KEYS[<span class=number>1</span>]) == ARGV[<span class=number>1</span>] <span class=keyword>then</span> <span class=string>" +</span></span><br><span class=line><span class=string>    "</span>    <span class=keyword>return</span> redis.call(<span class=string>'DEL'</span>, KEYS[<span class=number>1</span>]) <span class=string>" +</span></span><br><span class=line><span class=string>    "</span><span class=keyword>else</span> <span class=string>" +</span></span><br><span class=line><span class=string>    "</span>    <span class=keyword>return</span> <span class=number>0</span> <span class=string>" +</span></span><br><span class=line><span class=string>    "</span><span class=keyword>end</span><span class=string>";</span></span><br></pre></table></figure><p>甚至还可以<strong>用 Lua脚本实现滑动窗口限流器，一次性完成过期数据清理、计数检查、新记录添加</strong>三个操作，而且完全原子化。<figure class="highlight scilab"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=comment>// 滑动窗口限流，逻辑清晰，性能还好</span></span><br><span class=line>String luaScript = </span><br><span class=line>    <span class=string>"local key = KEYS[1] "</span> +</span><br><span class=line>    <span class=string>"local now = tonumber(ARGV[1]) "</span> +</span><br><span class=line>    <span class=string>"local window = tonumber(ARGV[2]) "</span> +</span><br><span class=line>    <span class=string>"local limit = tonumber(ARGV[3]) "</span> +</span><br><span class=line>    </span><br><span class=line>    <span class=comment>// 先清理过期记录</span></span><br><span class=line>    <span class=string>"redis.call('</span>ZREMRANGEBYSCORE', key, <span class=number>0</span>, now - window) <span class=string>" +</span></span><br><span class=line><span class=string>    </span></span><br><span class=line><span class=string>    // 检查当前请求数</span></span><br><span class=line><span class=string>    "</span>local current = redis.call(<span class=string>'ZCARD'</span>, key) <span class=string>" +</span></span><br><span class=line><span class=string>    "</span><span class=keyword>if</span> current < limit <span class=keyword>then</span> <span class=string>" +</span></span><br><span class=line><span class=string>    "</span>    redis.call(<span class=string>'ZADD'</span>, key, now, now) <span class=string>" +</span></span><br><span class=line><span class=string>    "</span>    <span class=keyword>return</span> <span class=number>1</span> <span class=string>" +</span></span><br><span class=line><span class=string>    "</span><span class=keyword>else</span> <span class=string>" +</span></span><br><span class=line><span class=string>    "</span>    <span class=keyword>return</span> <span class=number>0</span> <span class=string>" +</span></span><br><span class=line><span class=string>    "</span><span class=keyword>end</span><span class=string>";</span></span><br></pre></table></figure><h4 id=Redis的管道pipeline><a class=headerlink href=#Redis的管道pipeline title=Redis的管道pipeline></a>Redis的管道pipeline</h4><p><strong>Pipeline 允许客户端一次性向 Redis 服务器发送多个命令</strong>，而<strong>不必等待一个命令响应后才能发送下一个</strong>。Redis 服务器会按照命令的顺序依次执行，并将所有结果打包返回给客户端。<p>正常情况下，每执行一个 Redis 命令都需要一次网络往返：发送命令 -> 等待响应 -> 发送下一个命令。<p><strong>如果大量请求依次发送，网络延迟会显著增加请求的总执行时间</strong>，假如一次 RTT 的时间是 1 毫秒，3 个就是 3 毫秒。有了 Pipeline 后，可以一次性发送 3 个命令，总时间就只需要 1 毫秒。<p>当然了，Pipeline 不是越大越好，太大会占用过多内存，通常建议每个 Pipeline 包含 1000 到 5000 个命令。可以根据实际情况调整。<p>需要批量插入、更新或删除数据，或者需要执行大量相似的命令时。比如：<strong>系统启动时的缓存预热 -> 批量加载热点数据；比如统计数据的批量更新；比如大批量数据的导入导出</strong>；比如批量删除过期或无效的缓存。<h4 id=pipeline的底层原理><a class=headerlink href=#pipeline的底层原理 title=pipeline的底层原理></a>pipeline的底层原理</h4><p>缓冲的思想. 可以在RedisClient 类中封装了一个 PipelineAction 内部类，用来缓存命令。<p>add 方法将命令包装成 Runnable 对象，放入 List 中。当执行 execute 方法时，再调用 RedisTemplate 的 executePipelined 方法开启管道模式将多个命令发送到 Redis 服务端。<p>Redis <strong>服务端从输入缓冲区读到命令后，会按照 RESP 协议进行命令拆</strong>解，再依次执行这些命令。执行结果会写入到输出缓冲区，最后再将所有结果一次性返回给客户端。<figure class="highlight pgsql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line>@Service</span><br><span class=line><span class=built_in>public</span> <span class=keyword>class</span> RedisBatchService {</span><br><span class=line>    </span><br><span class=line>    <span class=built_in>public</span> <span class=type>void</span> batchInsertUsers(List<<span class=keyword>User</span>> users) {</span><br><span class=line>        // 不用Pipeline的错误做法 - 很慢</span><br><span class=line>        // <span class=keyword>for</span> (<span class=keyword>User</span> <span class=keyword>user</span> : users) {</span><br><span class=line>        //     redisTemplate.opsForValue().<span class=keyword>set</span>("user:" + <span class=keyword>user</span>.getId(), <span class=keyword>user</span>);</span><br><span class=line>        // }</span><br><span class=line>        </span><br><span class=line>        // 使用Pipeline的正确做法</span><br><span class=line>        redisTemplate.executePipelined(<span class=built_in>new</span> RedisCallback<<span class=keyword>Object</span>>() {</span><br><span class=line>            @Override</span><br><span class=line>            <span class=built_in>public</span> <span class=keyword>Object</span> doInRedis(RedisConnection <span class=keyword>connection</span>) throws DataAccessException {</span><br><span class=line>                <span class=keyword>for</span> (<span class=keyword>User</span> <span class=keyword>user</span> : users) {</span><br><span class=line>                    String key = "user:" + <span class=keyword>user</span>.getId();</span><br><span class=line>                    byte[] keyBytes = key.getBytes();</span><br><span class=line>                    byte[] valueBytes = serialize(<span class=keyword>user</span>);</span><br><span class=line>                    </span><br><span class=line>                    <span class=keyword>connection</span>.<span class=keyword>set</span>(keyBytes, valueBytes);</span><br><span class=line>                }</span><br><span class=line>                <span class=keyword>return</span> <span class=keyword>null</span>; // Pipeline不需要返回值</span><br><span class=line>            }</span><br><span class=line>        });</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=Redis实现分布式锁><a class=headerlink href=#Redis实现分布式锁 title=Redis实现分布式锁></a>Redis实现分布式锁</h3><p>分布式锁是一种用于控制多个不同进程在分布式系统中访问共享资源的锁机制。它能确保在同一时刻，只有一个节点可以对资源进行访问，从而避免分布式场景下的并发问题。<h2 id=过期删除与内存淘汰><a class=headerlink href=#过期删除与内存淘汰 title=过期删除与内存淘汰></a>过期删除与内存淘汰</h2><h2 id=线程模型><a class=headerlink href=#线程模型 title=线程模型></a>线程模型</h2><h2 id=Redis为什么这么快><a class=headerlink href=#Redis为什么这么快 title=Redis为什么这么快></a>Redis为什么这么快</h2><h1 id=MySQL><a class=headerlink href=#MySQL title=MySQL></a>MySQL</h1><h2 id=索引><a class=headerlink href=#索引 title=索引></a>索引</h2><link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script></div><div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div class=popular-posts-header>相关文章</div><ul class=popular-posts><li class=popular-posts-item><div class=popular-posts-title><a href=\2025\07\10\redis核心技术\ rel=bookmark>redis核心技术</a></div></ul><div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a href=https://www.sekyoro.top/2025/09/02/MySQL%E4%B8%8ERedis%E7%BB%8F%E5%85%B8%E9%9D%A2%E7%BB%8F/ title=MySQL与Redis经典面经>https://www.sekyoro.top/2025/09/02/MySQL与Redis经典面经/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div><footer class=post-footer><div class=post-tags><a href=/tags/Redis/ rel=tag><i class="fa fa-tag"></i> Redis</a><a href=/tags/MySQL/ rel=tag><i class="fa fa-tag"></i> MySQL</a></div><div class=post-nav><div class=post-nav-item><a href=/2025/08/31/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/ rel=prev title=刷题总结篇> <i class="fa fa-chevron-left"></i> 刷题总结篇 </a></div><div class=post-nav-item><a href=/2025/10/04/%E6%9E%84%E5%BB%BAAI%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/ rel=next title=构建AI应用程序的框架以及解决方案> 构建AI应用程序的框架以及解决方案 <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div><!-- 评论区 --><div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#Redis><span class=nav-number>1.</span> <span class=nav-text>Redis</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF><span class=nav-number>1.1.</span> <span class=nav-text>数据类型、底层结构以及使用场景</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4><span class=nav-number>1.2.</span> <span class=nav-text>Redis常用命令</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%8C%81%E4%B9%85%E5%8C%96><span class=nav-number>1.3.</span> <span class=nav-text>持久化</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#RDB><span class=nav-number>1.3.1.</span> <span class=nav-text>RDB</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#AOF><span class=nav-number>1.3.2.</span> <span class=nav-text>AOF</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#AOF%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5><span class=nav-number>1.3.2.1.</span> <span class=nav-text>AOF刷盘策略</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#AOF%E9%87%8D%E5%86%99><span class=nav-number>1.3.2.2.</span> <span class=nav-text>AOF重写</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96><span class=nav-number>1.3.3.</span> <span class=nav-text>混合持久化</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%AB%98%E5%8F%AF%E7%94%A8><span class=nav-number>1.4.</span> <span class=nav-text>高可用</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6><span class=nav-number>1.4.1.</span> <span class=nav-text>主从复制</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86><span class=nav-number>1.4.1.1.</span> <span class=nav-text>主从复制原理</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1><span class=nav-number>1.5.</span> <span class=nav-text>缓存设计</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7><span class=nav-number>1.5.1.</span> <span class=nav-text>如何保证缓存和数据库的一致性</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7><span class=nav-number>1.5.2.</span> <span class=nav-text>如何保证本地缓存和分布式缓存的一致性</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A4%9A%E4%B8%AA%E5%9C%B0%E6%96%B9%E9%83%BD%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%B0%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E9%80%BB%E8%BE%91%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E8%BF%99%E4%B8%80%E5%9D%97%EF%BC%9F><span class=nav-number>1.5.2.1.</span> <span class=nav-text>在项目中多个地方都要使用到二级缓存的逻辑，如何设计这一块？</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%80%E4%B9%88%E6%98%AF%E7%83%ADKey><span class=nav-number>1.5.3.</span> <span class=nav-text>什么是热Key</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%A4%A7Key><span class=nav-number>1.5.3.1.</span> <span class=nav-text>如何处理大Key</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E6%80%8E%E4%B9%88%E5%81%9A><span class=nav-number>1.5.3.2.</span> <span class=nav-text>缓存预热怎么做</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%97%A0%E5%BA%95%E6%B4%9E%E9%97%AE%E9%A2%98%E6%98%AF%E4%BB%80%E4%B9%88-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3><span class=nav-number>1.5.4.</span> <span class=nav-text>无底洞问题是什么 如何解决</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Redis%E8%BF%90%E7%BB%B4><span class=nav-number>1.5.5.</span> <span class=nav-text>Redis运维</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#Redis%E6%8A%A5%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86><span class=nav-number>1.5.5.1.</span> <span class=nav-text>Redis报内存不足怎么处理</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#redis-key%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B><span class=nav-number>1.5.5.2.</span> <span class=nav-text>redis key过期策略有哪些</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#redis%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5><span class=nav-number>1.5.5.3.</span> <span class=nav-text>redis有哪些内存淘汰策略</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#LRU%E5%92%8CLFU%E7%9A%84%E5%B7%AE%E5%88%AB><span class=nav-number>1.5.5.4.</span> <span class=nav-text>LRU和LFU的差别</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Redis%E5%8F%91%E7%94%9F%E4%BA%86%E9%98%BB%E5%A1%9E%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86><span class=nav-number>1.5.5.5.</span> <span class=nav-text>Redis发生了阻塞如何处理</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Redis%E5%BA%94%E7%94%A8><span class=nav-number>1.6.</span> <span class=nav-text>Redis应用</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#Redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97><span class=nav-number>1.6.1.</span> <span class=nav-text>Redis如何实现异步消息队列</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97><span class=nav-number>1.6.1.1.</span> <span class=nav-text>redis如何实现延迟消息队列</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Redis%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1%E5%90%97><span class=nav-number>1.6.1.2.</span> <span class=nav-text>Redis支持事务吗</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86><span class=nav-number>1.6.1.3.</span> <span class=nav-text>Redis事务的原理</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Redis%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%BB%A1%E8%B6%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97-%E8%A6%81%E6%80%8E%E4%B9%88%E6%94%B9%E8%BF%9B><span class=nav-number>1.6.1.4.</span> <span class=nav-text>Redis的事务满足原子性吗 要怎么改进</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Redis%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E6%80%A7><span class=nav-number>1.6.1.5.</span> <span class=nav-text>Redis事务的ACID特性</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Lua%E8%84%9A%E6%9C%AC%E6%93%8D%E4%BD%9CRedis><span class=nav-number>1.6.1.6.</span> <span class=nav-text>Lua脚本操作Redis</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Redis%E7%9A%84%E7%AE%A1%E9%81%93pipeline><span class=nav-number>1.6.1.7.</span> <span class=nav-text>Redis的管道pipeline</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#pipeline%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86><span class=nav-number>1.6.1.8.</span> <span class=nav-text>pipeline的底层原理</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81><span class=nav-number>1.6.2.</span> <span class=nav-text>Redis实现分布式锁</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0><span class=nav-number>1.7.</span> <span class=nav-text>过期删除与内存淘汰</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B><span class=nav-number>1.8.</span> <span class=nav-text>线程模型</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB><span class=nav-number>1.9.</span> <span class=nav-text>Redis为什么这么快</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#MySQL><span class=nav-number>2.</span> <span class=nav-text>MySQL</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%B4%A2%E5%BC%95><span class=nav-number>2.1.</span> <span class=nav-text>索引</span></a></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>256</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>16</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>219</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a><li class=links-of-blogroll-item><a href=https://www.lllomh.com/ rel=noopener target=_blank title=https://www.lllomh.com/>芈渡</a><li class=links-of-blogroll-item><a href=https://protool-ten.vercel.app/ rel=noopener target=_blank title=https://protool-ten.vercel.app/>protools</a></ul></div><div class="motion-element announcement"><div class=title></div><p class=content><p class=date></div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>文章词云</h3><div class="widget tagcloud" id=myCanvasContainer><canvas height=250 id=resCanvas style=width:100% width=250><ul class=tag-list itemprop=keywords><li class=tag-list-item><a class=tag-list-link href=/tags/MySQL/ rel=tag>MySQL</a><span class=tag-list-count>1</span><li class=tag-list-item><a class=tag-list-link href=/tags/Redis/ rel=tag>Redis</a><span class=tag-list-count>2</span></ul></canvas></div></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2026</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>4.4m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>66:06</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>document.addEventListener("DOMContentLoaded", function() {
    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {
        var pvContainer = document.getElementById("busuanzi_container_site_pv");
        if (pvContainer && pvContainer.style.display !== "none") {
            var pvElement = document.getElementById("busuanzi_value_site_pv");
            if (pvElement) {
                pvElement.innerHTML = parseInt(pvElement.innerHTML) + countOffset;
                clearInterval(int);
            }
        }
        
        var uvContainer = document.getElementById("busuanzi_container_site_uv");
        if (uvContainer && window.getComputedStyle(uvContainer).display !== "none")
        {
            var uvElement = document.getElementById("busuanzi_value_site_uv");
            if (uvElement) {
                uvElement.innerHTML = parseInt(uvElement.innerHTML) + countOffset; // 加上初始数据 
                clearInterval(int); // 停止检测
            }
        }
    }
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer></div><script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script><script src=/lib/anime.min.js></script><script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script><script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/pisces.js></script><script src=/js/next-boot.js></script><script src=/js/bookmark.js></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	 '.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
  
  // Reinitialize TagCanvas for tag cloud
  if (typeof TagCanvas !== 'undefined' && document.getElementById('resCanvas')) {
    try {
      TagCanvas.textFont = 'Trebuchet MS, Helvetica';
      TagCanvas.textColour = '#333';
      TagCanvas.textHeight = 20;
      TagCanvas.outlineColour = '#E2E1D1';
      TagCanvas.maxSpeed = 0.3;
      TagCanvas.freezeActive = true;
      TagCanvas.outlineMethod = 'block';
      TagCanvas.minBrightness = 0.2;
      TagCanvas.depth = 0.92;
      TagCanvas.pulsateTo = 0.6;
      TagCanvas.initial = [0.1,-0.1];
      TagCanvas.decel = 0.98;
      TagCanvas.reverse = true;
      TagCanvas.hideTags = false;
      TagCanvas.shadow = '#ccf';
      TagCanvas.shadowBlur = 3;
      TagCanvas.weight = false;
      TagCanvas.imageScale = null;
      TagCanvas.fadeIn = 1000;
      TagCanvas.clickToFront = 600;
      TagCanvas.lock = false;
      TagCanvas.Start('resCanvas');
      TagCanvas.tc['resCanvas'].Wheel(true);
    } catch(e) {
      console.log('TagCanvas initialization failed:', e);
    }
  }
});</script><script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script><script src=/js/algolia-search.js></script><script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script><div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div><script charset=utf-8 defer src=/js/tagcanvas.js></script><script charset=utf-8 defer src=/js/tagcloud.js></script><script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script><script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script><script src=/js/src/activate-power-mode.min.js></script><script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script>
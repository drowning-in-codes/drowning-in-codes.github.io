<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"0F9LEEVW82","apiKey":"78839e9f9be09d081c5c4da81975cd19","indexName":"sekyoblog_sec","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content="c++在网络编程中特别普及,特别是Linux服务器编程. 相关书籍也有很多,这里简单介绍一下(结合AI总结)." name=description><meta content=article property=og:type><meta content=Linux网络编程入门 property=og:title><meta content=https://www.sekyoro.top/2025/02/27/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content="c++在网络编程中特别普及,特别是Linux服务器编程. 相关书籍也有很多,这里简单介绍一下(结合AI总结)." property=og:description><meta content=zh_CN property=og:locale><meta content=https://s2.loli.net/2025/02/27/azvYs7B46VeOAfb.png property=og:image><meta content=2025-02-27T07:01:15.000Z property=article:published_time><meta content=2025-03-25T08:17:51.652Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content=c++ property=article:tag><meta content=Linux网络编程 property=article:tag><meta content=summary name=twitter:card><meta content=https://s2.loli.net/2025/02/27/azvYs7B46VeOAfb.png name=twitter:image><link href=https://www.sekyoro.top/2025/02/27/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>Linux网络编程入门 | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2025/02/27/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>Linux网络编程入门</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2025-02-27 15:01:15" datetime=2025-02-27T15:01:15+08:00>2025-02-27</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-03-25 16:17:51" datetime=2025-03-25T16:17:51+08:00 itemprop=dateModified>2025-03-25</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>30k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>27 分钟</span> </span></div></header><div class=post-body itemprop=articleBody><p>c++在网络编程中特别普及,特别是Linux服务器编程. 相关书籍也有很多,这里简单介绍一下(结合AI总结).<br><span id=more></span><h2 id=重要的数据结构><a class=headerlink href=#重要的数据结构 title=重要的数据结构></a>重要的数据结构</h2><h3 id=套接字地址><a class=headerlink href=#套接字地址 title=套接字地址></a>套接字地址</h3><blockquote><p><strong>PF_INET</strong>：指的是协议族（Protocol Family），强调的是协议相关的概念。<p><strong>AF_INET</strong>：指的是地址族（Address Family），关注的是地址格式。<p>虽然在许多实现中 <code>PF_INET</code> 和 <code>AF_INET</code> 可以互换使用，但理论上它们代表不同的概念。为了保持代码的清晰性和一致性，推荐的做法是在创建套接字时使用 <code>AF_INET</code> 来指代地址族，而保留 <code>PF_INET</code> 用于协议族相关的上下文。不过，由于历史原因和广泛接受的习惯，这种区别在实践中往往被忽略。</blockquote><p>在进行网络编程时，<code>sockaddr_in</code>、<code>sockaddr</code> 和 <code>addrinfo</code> 是三个不同的数据结构，它们各自有不同的用途和特点。<p><strong>sockaddr</strong><ul><li><p><strong>定义</strong>：</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>sockaddr</span> {</span></span><br><span class=line>    <span class=keyword>sa_family_t</span> sa_family; <span class=comment>// 地址族（如AF_INET, AF_INET6）</span></span><br><span class=line>    <span class=keyword>char</span>        sa_data[<span class=number>14</span>]; <span class=comment>// 地址信息，具体格式取决于地址族</span></span><br><span class=line>};</span><br></pre></table></figure><li><p><strong>用途</strong>：</p> <ul><li>这是一个<strong>通用的套接字地址结构体</strong>，用于表示任何类型的套接字地址。它不特定于任何一种协议或地址家族。<li>它通常作为函数参数传递，以便支持多种不同类型的地址族（例如IPv4、IPv6等）。</ul><li><p><strong>局限性</strong>：</p> <ul><li>因为它的<code>sa_data</code>字段是固定大小的字符数组，所以在处理复杂或长度不定的地址信息时不够灵活。</ul></ul><p><strong>sockaddr_in</strong><ul><li><p><strong>定义</strong>：</p> <figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>sockaddr_in</span> {</span></span><br><span class=line>    <span class=keyword>sa_family_t</span>    sin_family; <span class=comment>// 地址族，必须设置为AF_INET</span></span><br><span class=line>    <span class=keyword>in_port_t</span>      sin_port;   <span class=comment>// 端口号（使用htons()转换为网络字节序）</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>in_addr</span> <span class=title>sin_addr</span>;</span>   <span class=comment>// IPv4地址</span></span><br><span class=line>    <span class=keyword>unsigned</span> <span class=keyword>char</span>  sin_zero[<span class=number>8</span>]; <span class=comment>// 填充0以使结构体大小与sockaddr相同</span></span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>in_addr</span> {</span></span><br><span class=line>    <span class=keyword>in_addr_t</span> s_addr; <span class=comment>// 32位IPv4地址（网络字节序）</span></span><br><span class=line>};</span><br></pre></table></figure><li><p><strong>用途</strong>：</p> <ul><li><strong>专门用于IPv4地址的套接字地址结构体</strong>。<li>提供了明确的字段来存储端口号和IP地址，使得处理IPv4地址更加直观和方便。</ul><li><p><strong>优点</strong>：</p> <ul><li>相较于<code>sockaddr</code>，它提供了更具体的字段，便于操作IPv4地址和端口信息。</ul></ul><p><strong>sockaddr_in6</strong><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>sockaddr_in6</span></span></span><br><span class=line><span class=class>  {</span></span><br><span class=line>    __SOCKADDR_COMMON (sin6_);</span><br><span class=line>    <span class=keyword>in_port_t</span> sin6_port;	<span class=comment>/* Transport layer port # */</span></span><br><span class=line>    <span class=keyword>uint32_t</span> sin6_flowinfo;	<span class=comment>/* IPv6 flow information */</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>in6_addr</span> <span class=title>sin6_addr</span>;</span>	<span class=comment>/* IPv6 address */</span></span><br><span class=line>    <span class=keyword>uint32_t</span> sin6_scope_id;	<span class=comment>/* IPv6 scope-id */</span></span><br><span class=line>  };</span><br></pre></table></figure><p><strong>addrinfo</strong><ul><li><p><strong>定义</strong>：</p> <figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>addrinfo</span> {</span></span><br><span class=line>    <span class=keyword>int</span>              ai_flags;     <span class=comment>// AI_PASSIVE, AI_CANONNAME, etc.</span></span><br><span class=line>    <span class=keyword>int</span>              ai_family;    <span class=comment>// AF_INET, AF_INET6, AF_UNSPEC</span></span><br><span class=line>    <span class=keyword>int</span>              ai_socktype;  <span class=comment>// SOCK_STREAM, SOCK_DGRAM</span></span><br><span class=line>    <span class=keyword>int</span>              ai_protocol;  <span class=comment>// 使用的协议</span></span><br><span class=line>    <span class=keyword>socklen_t</span>        ai_addrlen;   <span class=comment>// 地址长度</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>sockaddr</span> *<span class=title>ai_addr</span>;</span>      <span class=comment>// 地址信息</span></span><br><span class=line>    <span class=keyword>char</span>            *ai_canonname; <span class=comment>// 主机规范名称</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>addrinfo</span> *<span class=title>ai_next</span>;</span>      <span class=comment>// 下一个addrinfo结构指针</span></span><br><span class=line>};</span><br></pre></table></figure> <p><img alt=image-20250227150905975 data-src=https://s2.loli.net/2025/02/27/azvYs7B46VeOAfb.png></p><li><p><strong>用途</strong>：</p> <ul><li><code>addrinfo</code> 结构体由 <code>getaddrinfo()</code> 函数返回，旨在<strong>提供一个统一的方式来处理不同类型的地址信息（包括IPv4和IPv6），并简化了主机名和服务名解析的过程</strong>。<li>它可以包含多个结果（通过<code>ai_next</code>链表连接），允许应用程序选择最适合其需求的结果。</ul><li><p><strong>优点</strong>：</p> <ul><li>支持现代互联网中常见的IPv4和IPv6地址。<li>能够处理复杂的配置需求，如指定被动监听（AI_PASSIVE）、获取规范主机名等。<li>更加灵活和强大，适合需要跨平台兼容性和灵活性的应用程序。</ul></ul><p><strong>sockaddr_storage</strong><p><code>sockaddr_storage</code> 是一个在 <code>&LTnetinet/in.h></code> 或 <code>&LTsys/socket.h></code> 头文件中定义的数据结构，旨在提供一个足够大的缓冲区来存储任何类型的套接字地址（包括 IPv4、IPv6 等）。它解决了由于不同协议族的地址结构大小不一致所带来的问题，例如 <code>sockaddr_in</code> 和 <code>sockaddr_in6</code> 分别用于 IPv4 和 IPv6 地址，它们有不同的大小。<p><strong>定义与用途</strong><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>sockaddr_storage</span> {</span></span><br><span class=line>    <span class=keyword>sa_family_t</span> ss_family; <span class=comment>// 地址族</span></span><br><span class=line>    <span class=comment>// 其余字段未指定，实现定义以确保足够的空间和对齐</span></span><br><span class=line>};</span><br></pre></table></figure><ul><li><strong>ss_family</strong>：这是唯一标准化的字段，表示地址族（如 <code>AF_INET</code> 对应 IPv4，<code>AF_INET6</code> 对应 IPv6）。<li><strong>其他字段</strong>：这些字段的具体定义依赖于实现，主要是为了确保 <code>sockaddr_storage</code> 能够容纳所有可能的套接字地址类型，并且保持正确的内存对齐。这意味着它的大小至少要能容纳最大的套接字地址结构（比如 <code>sockaddr_in6</code>）。</ul><p><strong>主要特点</strong><ol><li><strong>统一性</strong>：通过使用 <code>sockaddr_storage</code>,可以编写更加通用的代码，避免直接处理特定于协议的地址结构（如 <code>sockaddr_in</code> 或 <code>sockaddr_in6</code>），从而提高代码的可移植性和灵活性。<li><strong>大小保证</strong>：<code>sockaddr_storage</code> 的大小被设计为足以容纳系统支持的所有套接字地址结构，这使得它可以安全地转换为任何特定的套接字地址类型。<li><strong>对齐要求</strong>：除了大小之外，<code>sockaddr_storage</code> 还满足了所有套接字地址结构的对齐要求，这对于高效访问数据至关重要。</ol><p><strong>总结</strong><ul><li><strong><code>sockaddr</code></strong>：是一个通用的套接字地址结构体，适用于所有地址族。由于其设计较为通用，实际应用中常被特定于某种地址族的结构体替代，如<code>sockaddr_in</code>。<li><strong><code>sockaddr_in</code></strong>：专用于IPv4地址，提供了对IPv4地址和端口的具体支持，易于理解和使用。<li><strong><code>addrinfo</code></strong>：提供了一个更高级别的抽象，能够处理IPv4和IPv6地址，并且支持更多的选项和灵活性。它是推荐的方式来进行现代网络编程中的地址解析和套接字创建，特别是当你需要同时支持IPv4和IPv6时。</ul><p><strong>socketpair</strong><p><code>socketpair</code> 是一个用于创建一对互联的套接字描述符的系统调用，它允许在同一主机上的两个进程之间进行双向通信。通常，这些套接字被用于父子进程间的通信，但它们也可以用于任何需要双向（全双工）通信通道的场景<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/types.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/socket.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>socketpair</span><span class=params>(<span class=keyword>int</span> domain, <span class=keyword>int</span> type, <span class=keyword>int</span> protocol, <span class=keyword>int</span> sv[<span class=number>2</span>])</span></span>;</span><br></pre></table></figure><ul><li><strong>参数</strong>：<ul><li><code>domain</code>：指定协议族，通常是 <code>AF_UNIX</code> 或 <code>AF_LOCAL</code>（本地通信），但在某些实现中也可能支持其他域如 <code>AF_INET</code>。<li><code>type</code>：指定套接字类型，常见的有 <code>SOCK_STREAM</code>（提供有序、可靠、双向的连接）和 <code>SOCK_DGRAM</code>（数据报套接字）。<li><code>protocol</code>：指定使用的协议，通常为 <code>0</code>，表示使用默认协议。<li><code>sv</code>：指向一个包含两个整数元素的数组，这两个整数将作为返回的套接字描述符。</ul><li><strong>返回值</strong>：<ul><li>成功时，返回 <code>0</code> 并在 <code>sv</code> 数组中填充两个有效的套接字描述符。<li>失败时，返回 <code>-1</code> 并设置 <code>errno</code>。</ul></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdlib.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/socket.h></span></span></span><br><span class=line></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> MSG_SIZE 1024</span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> sv[<span class=number>2</span>]; <span class=comment>// 存储两个套接字描述符</span></span><br><span class=line>    <span class=keyword>char</span> buffer[MSG_SIZE];</span><br><span class=line></span><br><span class=line>    <span class=comment>// 创建一对套接字</span></span><br><span class=line>    <span class=keyword>if</span> (<span class=built_in>socketpair</span>(AF_UNIX, SOCK_STREAM, <span class=number>0</span>, sv) == <span class=number>-1</span>) {</span><br><span class=line>        <span class=built_in>perror</span>(<span class=string>"socketpair"</span>);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>pid_t</span> pid = fork();</span><br><span class=line>    <span class=keyword>if</span> (pid == <span class=number>-1</span>) {</span><br><span class=line>        <span class=built_in>perror</span>(<span class=string>"fork"</span>);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    } <span class=keyword>else</span> <span class=keyword>if</span> (pid == <span class=number>0</span>) { <span class=comment>// 子进程</span></span><br><span class=line>        <span class=built_in>close</span>(sv[<span class=number>0</span>]); <span class=comment>// 关闭不需要的套接字端</span></span><br><span class=line>        <span class=keyword>const</span> <span class=keyword>char</span> *msg = <span class=string>"Hello from child process!"</span>;</span><br><span class=line>        <span class=built_in>write</span>(sv[<span class=number>1</span>], msg, <span class=built_in>strlen</span>(msg) + <span class=number>1</span>); <span class=comment>// 发送消息给父进程</span></span><br><span class=line>        <span class=built_in>close</span>(sv[<span class=number>1</span>]);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_SUCCESS);</span><br><span class=line>    } <span class=keyword>else</span> { <span class=comment>// 父进程</span></span><br><span class=line>        <span class=built_in>close</span>(sv[<span class=number>1</span>]); <span class=comment>// 关闭不需要的套接字端</span></span><br><span class=line>        <span class=keyword>ssize_t</span> bytes_read = <span class=built_in>read</span>(sv[<span class=number>0</span>], buffer, MSG_SIZE); <span class=comment>// 从子进程接收消息</span></span><br><span class=line>        <span class=keyword>if</span> (bytes_read > <span class=number>0</span>) {</span><br><span class=line>            <span class=built_in>printf</span>(<span class=string>"Received message from child: %s\n"</span>, buffer);</span><br><span class=line>        }</span><br><span class=line>        <span class=built_in>close</span>(sv[<span class=number>0</span>]);</span><br><span class=line>        <span class=built_in>wait</span>(<span class=literal>NULL</span>); <span class=comment>// 等待子进程结束</span></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><h3 id=地址二进制与点分十进制转换><a class=headerlink href=#地址二进制与点分十进制转换 title=地址二进制与点分十进制转换></a>地址二进制与点分十进制转换</h3><p>在网络编程中，有时需要将点分十进制表示的IPv4地址（如<code>"192.168.1.1"</code>）转换成32位无符号整数形式以便于处理或计算。在C语言中，可以使用以下函数来实现这种转换：<ul><li><strong><code>inet_addr</code></strong>: 这是一个简单的函数，用于将点分十进制格式的IPv4地址转换为网络字节序的32位长整型值。然而，<strong>它不支持IPv6，并且如果输入无效，则返回<code>INADDR_NONE</code></strong><li><strong><code>inet_aton</code></strong>: 此函数不仅将点分十进制的IPv4地址转换为二进制形式，还会检查输入的有效性。它接受一个指向<code>in_addr</code>结构的指针作为第二个参数，并在此结构中填充相应的数值。<strong>如果转换成功，返回非零值；否则返回0</strong><li><strong><code>inet_pton</code></strong>: 这是一个更为现代和推荐使用的函数，支持IPv4和IPv6地址的转换。对于IPv4，它的第二个参数是一个指向<code>struct in_addr</code>类型的指针，对于IPv6，则是指向<code>struct in6_addr</code>类型的指针<strong>。如果转换成功，返回1</strong>；如果输入格式不正确，则返回0；如果遇到系统错误，则返回-1。</ul><div class=table-container><table><thead><tr><th>特性<th><code>inet_addr</code><th><code>inet_aton</code><tbody><tr><td><strong>输入格式</strong><td>点分十进制字符串<td>点分十进制字符串<tr><td><strong>输出格式</strong><td>返回 <code>in_addr_t</code>（32 位整数）<td>填充 <code>struct in_addr</code> 结构体<tr><td><strong>错误处理</strong><td>错误时返回 <code>INADDR_NONE</code><td>错误时返回 <code>0</code><tr><td><strong>线程安全性</strong><td>安全<td>安全<tr><td><strong>推荐程度</strong><td>不推荐（已过时）<td>推荐</table></div><div class=table-container><table><thead><tr><th>函数名<th>输入格式<th>输出格式<th>支持的地址类型<th>线程安全性<tbody><tr><td><code>inet_pton</code><td>字符串<td>二进制<td>IPv4 和 IPv6<td>安全<tr><td><code>inet_aton</code><td>字符串<td>二进制<td>仅 IPv4<td>安全<tr><td><code>inet_ntop</code><td>二进制<td>字符串<td>IPv4 和 IPv6<td>安全<tr><td><code>inet_ntoa</code><td>二进制<td>字符串<td>仅 IPv4<td>不安全</table></div><h3 id=端口字节序转换><a class=headerlink href=#端口字节序转换 title=端口字节序转换></a>端口字节序转换</h3><p>在网络编程中，处理不同系统间的数据传输时，经常需要将数据在主机字节序（Host Byte Order）和网络字节序（Network Byte Order）之间进行转换。这是因为不同的计算机架构可能使用不同的字节序来存储多字节数据类型，如整数。为了确保数据在网络上传输的一致性，通常采用大端字节序（Big Endian），也被称作网络字节序<p>针对这种需求，有几组常用的函数用于在主机字节序和网络字节序之间进行转换：<ol><li><strong><code>htonl</code> 和 <code>htons</code></strong>：这两个函数分别用于将32位整型（<code>long</code>）和16位整型（<code>short</code>）从主机字节序转换为网络字节序。<ul><li><code>htonl(uint32_t hostlong)</code>: Host to Network Long<li><code>htons(uint16_t hostshort)</code>: Host to Network Short</ul><li><strong><code>ntohl</code> 和 <code>ntohs</code></strong>：与上述相反，这两个函数用于将32位和16位整型从网络字节序转换为主机字节序。<ul><li><code>ntohl(uint32_t netlong)</code>: Network to Host Long<li><code>ntohs(uint16_t netshort)</code>: Network to Host Short</ul></ol><p>为了保证网络通信的兼容性，通常采用大端字节序（Big Endian），也称为网络字节序，来表示跨网络传输的数据。<p><strong>需要转换为网络字节序的数据类型</strong><ol><li><strong>端口号</strong>：端口号通常是16位的整数，在发送之前应该从主机字节序转换为网络字节序。<li><strong>IP地址</strong>：虽然IP地址通常以字符串形式表示（例如“192.168.0.1”），但在某些情况下，你可能会处理32位整型的IPv4地址或128位的IPv6地址。对于这些情况，如果需要直接操作整型值，则应确保它们是网络字节序。<li><strong>序列号、确认号等TCP头部字段</strong>：这些字段都是32位的整数，用于TCP协议中的状态跟踪和数据流控制，因此也需要转换为网络字节序。<li><strong>其他自定义协议中的多字节字段</strong>：如果你设计了一个自定义的应用层协议，并且该协议包含多字节整数字段（如长度指示符、版本号等），那么这些字段也应该按照网络字节序进行编码。</ol><h3 id=设置套接字等选项><a class=headerlink href=#设置套接字等选项 title=设置套接字等选项></a>设置套接字等选项</h3><p><code>setsockopt</code> 是一个用于设置套接字选项的函数，它允许开发者对套接字的行为进行精细控制。通过 <code>setsockopt</code>，可以调整套接字的各种属性，例如<strong>地址复用</strong>、<strong>接收/发送缓冲区大小</strong>、超时时间等。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/types.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/socket.h></span></span></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>setsockopt</span><span class=params>(<span class=keyword>int</span> sockfd, <span class=keyword>int</span> level, <span class=keyword>int</span> optname, <span class=keyword>const</span> <span class=keyword>void</span> *optval, <span class=keyword>socklen_t</span> optlen)</span></span>;</span><br></pre></table></figure><ol><li><strong><code>sockfd</code></strong>:<ul><li>套接字描述符。<li>指定要设置选项的目标套接字。</ul><li><strong><code>level</code></strong>:<ul><li>选项所属的协议层。<li>常见值包括：<ul><li><code>SOL_SOCKET</code>: 套接字通用选项（如地址复用、广播等）。<li><code>IPPROTO_TCP</code>: TCP 协议相关选项。<li><code>IPPROTO_IP</code>: IP 协议相关选项。<li><code>IPPROTO_IPV6</code>: IPv6 相关选项。</ul></ul><li><strong><code>optname</code></strong>:<ul><li>具体的选项名称。<li>根据 <code>level</code> 的不同，可以选择不同的选项。</ul><li><strong><code>optval</code></strong>:<ul><li>指向选项值的指针。<li>选项值的具体类型和格式取决于 <code>optname</code>。</ul><li><strong><code>optlen</code></strong>:<ul><li><code>optval</code> 缓冲区的大小（以字节为单位）</ul></ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>int</span> opt = <span class=number>1</span>;</span><br><span class=line><span class=built_in>setsockopt</span>(sockfd, SOL_SOCKET, SO_REUSEADDR, &opt, <span class=built_in><span class=keyword>sizeof</span></span>(opt));</span><br></pre></table></figure><p><strong>常用选项</strong><ol><li><strong><code>SO_REUSEADDR</code></strong></ol><ul><li><strong>作用</strong>: 允许绑定到已被占用的地址和端口。<li><strong>场景</strong>: 通常用于避免因端口被占用而导致服务器无法启动的问题。</ul><p><strong>2. <code>SO_REUSEPORT</code></strong><ul><li><strong>作用</strong>: 允许多个进程或线程绑定到同一个端口。<li><strong>场景</strong>: 适用于多线程或多进程服务器模型。<li><strong>注意</strong>: 需要与 <code>SO_REUSEADDR</code> 配合使用</ul><p><strong>3. <code>SO_RCVBUF</code> 和 <code>SO_SNDBUF</code></strong><ul><li><p>作用</p> <p>:</p> <ul><li><code>SO_RCVBUF</code>: 设置接收缓冲区大小。<li><code>SO_SNDBUF</code>: 设置发送缓冲区大小。</ul></ul><p><strong>4. <code>SO_BROADCAST</code></strong><ul><li><strong>作用</strong>: 启用广播功能。<li><strong>场景</strong>: 用于 UDP 广播通信</ul><p><strong>5. <code>SO_KEEPALIVE</code></strong><ul><li><strong>作用</strong>: 启用 TCP 的保活机制。<li><strong>场景</strong>: 检测长时间空闲的连接是否仍然有效。</ul><p><strong>6. <code>SO_LINGER</code></strong><ul><li><strong>作用</strong>: 控制关闭套接字时的行为。<li><strong>场景</strong>: 当需要确保所有数据在关闭前被发送时。</ul><p><strong>7. <code>TCP_NODELAY</code></strong><ul><li><strong>作用</strong>: 禁用 Nagle 算法，减少小数据包的延迟。<li><strong>场景</strong>: 对于实时性要求较高的应用（如在线游戏、实时聊天）。</ul><h3 id=设置文件描述符选项><a class=headerlink href=#设置文件描述符选项 title=设置文件描述符选项></a>设置文件描述符选项</h3><p>函数原型<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTfcntl.h></span></span></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>fcntl</span><span class=params>(<span class=keyword>int</span> fd, <span class=keyword>int</span> cmd, ... <span class=comment>/* arg */</span> )</span></span>;</span><br></pre></table></figure><ul><li><p><strong><code>fd</code></strong>：目标文件描述符。</p><li><p><code>cmd</code></p> <p>：指定要执行的操作类型，常见的命令包括：</p> <ul><li><strong><code>F_GETFL</code></strong>：获取文件描述符的状态标志。<li><strong><code>F_SETFL</code></strong>：设置文件描述符的状态标志。<li><strong><code>F_GETFD</code></strong>：获取文件描述符的文件描述符标志。<li><strong><code>F_SETFD</code></strong>：设置文件描述符的文件描述符标志。<li><strong><code>F_DUPFD</code></strong>：复制文件描述符。<li><strong><code>F_DUPFD_CLOEXEC</code></strong>：复制文件描述符并设置 <code>FD_CLOEXEC</code> 标志。</ul><li><p><strong><code>arg</code></strong>：可选参数，具体取决于 <code>cmd</code> 的值。例如，在使用 <code>F_SETFL</code> 时，<code>arg</code> 是新的状态标志</p></ul><p>在网络编程中，将套接字设置为非阻塞模式是一种常见的优化手段。非阻塞模式允许在尝试读取或写入数据时立即返回，而不会阻塞进程。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTfcntl.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line></span><br><span class=line><span class=comment>// 将文件描述符设置为非阻塞模式</span></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>set_nonblocking</span><span class=params>(<span class=keyword>int</span> fd)</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> flags = <span class=built_in>fcntl</span>(fd, F_GETFL, <span class=number>0</span>); <span class=comment>// 获取当前文件描述符的标志</span></span><br><span class=line>    <span class=keyword>if</span> (flags == <span class=number>-1</span>) {</span><br><span class=line>        <span class=built_in>perror</span>(<span class=string>"fcntl F_GETFL failed"</span>);</span><br><span class=line>        <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 添加 O_NONBLOCK 标志</span></span><br><span class=line>    <span class=keyword>if</span> (<span class=built_in>fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK) == <span class=number>-1</span>) {</span><br><span class=line>        <span class=built_in>perror</span>(<span class=string>"fcntl F_SETFL failed"</span>);</span><br><span class=line>        <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>在非阻塞模式下：<ul><li>如果没有数据可读，<code>read()</code> 或 <code>recv()</code> 会立即返回 <code>-1</code>，并设置 <code>errno</code> 为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。<li>如果无法立即写入数据，<code>write()</code> 或 <code>send()</code> 也会返回 <code>-1</code>，并设置 <code>errno</code> 为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</ul><p>文件状态标志可以通过 <code>fcntl(fd, F_GETFL)</code> 获取当前设置，并通过 <code>fcntl(fd, F_SETFL, flags)</code> 修改。<ul><li><strong><code>O_RDONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code></strong>：打开文件的模式（只读、只写、读写），通常在打开文件时确定，不能通过 <code>F_SETFL</code> 修改。<li><strong><code>O_APPEND</code></strong>：每次写入时将数据追加到文件末尾。<li><strong><code>O_NONBLOCK</code></strong>：设置非阻塞模式。对于文件或设备，这意味着尝试的操作（如读取或写入）如果无法立即完成，则会立即返回而不是阻塞等待。在网络编程中，这通常用于套接字以实现异步I/O。<li><strong><code>O_ASYNC</code></strong>：当I/O可用时发送信号（通常是 <code>SIGIO</code>）给进程。此功能允许进程异步地处理I/O事件。<li><strong><code>O_DSYNC</code> 和 <code>O_SYNC</code></strong>：要求同步写入。<code>O_DSYNC</code> 确保数据同步写入磁盘，而 <code>O_SYNC</code> 还包括文件元数据的同步写入。</ul><h2 id=信号机制><a class=headerlink href=#信号机制 title=信号机制></a>信号机制</h2><p>信号是操作系统向进程发送的一种异步通知机制，用于告知进程某个事件已经发生。信号可以被视为一种软件中断，它会打断进程的正常执行流程。<h3 id=signal><a class=headerlink href=#signal title=signal></a>signal</h3><p><strong><code>signal()</code> 函数</strong><p>这是最基本的信号处理函数，用于设置对指定信号的处理方式。然而，它不如 <code>sigaction</code> 灵活和可靠。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsignal.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>typedef</span> <span class=title>void</span> <span class=params>(*<span class=keyword>sighandler_t</span>)</span><span class=params>(<span class=keyword>int</span>)</span></span>;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>sighandler_t</span> <span class=title>signal</span><span class=params>(<span class=keyword>int</span> signum, <span class=keyword>sighandler_t</span> handler)</span></span>;</span><br></pre></table></figure><ul><li><code>signum</code>：要捕获或忽略的信号编号。<li><code>handler</code>：信号处理函数指针，或者 <code>SIG_DFL</code>（默认处理）、<code>SIG_IGN</code>（忽略）。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdlib.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsignal.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>handle_sigint</span><span class=params>(<span class=keyword>int</span> sig)</span> </span>{</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Caught signal %d\n"</span>, sig);</span><br><span class=line>    <span class=built_in>exit</span>(<span class=number>0</span>);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=comment>// 设置 SIGINT (Ctrl+C) 的处理程序</span></span><br><span class=line>    <span class=keyword>if</span> (<span class=built_in>signal</span>(SIGINT, handle_sigint) == SIG_ERR) {</span><br><span class=line>        <span class=built_in>fprintf</span>(stderr, <span class=string>"Unable to set handler for SIGINT\n"</span>);</span><br><span class=line>        <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>while</span>(<span class=number>1</span>) {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Process running...\n"</span>);</span><br><span class=line>        <span class=built_in>sleep</span>(<span class=number>1</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>Linux 定义了许多标准信号，例如：<ul><li><code>SIGINT</code>（2）：由用户按下 <code>Ctrl+C</code> 触发，通常用于终止进程。<li><code>SIGTERM</code>（15）：请求终止进程的信号。<li><code>SIGKILL</code>（9）：强制终止进程的信号，无法被捕获或忽略。<li><code>SIGSEGV</code>（11）：段错误（访问非法内存地址）。<li><code>SIGCHLD</code>（17）：子进程状态改变时发送给父进程的信号。<li><code>SIGUSR1</code> 和 <code>SIGUSR2</code>：用户自定义信号。</ul><p>信号可以通过以下几种方式触发：<p><strong>(1) 用户输入</strong><ul><li>按下 <code>Ctrl+C</code> 会向当前前台进程发送 <code>SIGINT</code> 信号。<li>按下 <code>Ctrl+\</code> 会向当前前台进程发送 <code>SIGQUIT</code> 信号。</ul><p><strong>(2) 系统调用</strong><p>通过系统调用 <code>kill</code> 或 <code>raise</code> 可以向进程发送信号：<ul><li><code>kill(pid_t pid, int sig)</code>：向指定进程 ID 的进程发送信号。<li><code>raise(int sig)</code>：向当前进程自身发送信号。</ul><p><strong>(3) 硬件异常</strong><p>当进程访问非法内存地址时，操作系统会发送 <code>SIGSEGV</code> 信号；当进行非法指令操作时，可能会发送 <code>SIGILL</code> 信号。<p><strong>(4) 软件触发</strong><p>通过调用 <code>alarm</code> 函数可以设置定时器，超时时会向进程发送 <code>SIGALRM</code> 信号。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsignal.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>handler</span><span class=params>(<span class=keyword>int</span> sig)</span> </span>{</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Received signal: %d\n"</span>, sig);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=built_in>signal</span>(SIGALRM, handler); <span class=comment>// 注册信号处理函数</span></span><br><span class=line>    <span class=built_in>alarm</span>(<span class=number>3</span>); <span class=comment>// 设置 3 秒后发送 SIGALRM 信号</span></span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Waiting for the alarm signal...\n"</span>);</span><br><span class=line>    <span class=built_in>pause</span>(); <span class=comment>// 挂起进程，等待信号</span></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><h3 id=sigaction><a class=headerlink href=#sigaction title=sigaction></a>sigaction</h3><p><code>sigaction</code> 是 POSIX 标准定义的一种机制，用于定义进程对特定信号的响应行为。它提供了一种比 <code>signal()</code> 更加灵活和强大的方式来处理信号。<code>sigaction</code> 结构体用于指定如何处理信号、信号处理程序的属性以及信号掩码等信息。<p><code>sigaction</code> 提供了比 <code>signal()</code> 更加精细和强大的信号处理功能。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsignal.h></span></span></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>sigaction</span><span class=params>(<span class=keyword>int</span> signum, <span class=keyword>const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br></pre></table></figure><ul><li>参数：<ul><li><code>signum</code>：信号编号。<li><code>act</code>：指向包含新动作的 <code>struct sigaction</code> 结构体的指针。<li><code>oldact</code>：如果非空，则保存旧的动作。</ul></ul><p><strong><code>struct sigaction</code> 结构体</strong><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>sigaction</span> {</span></span><br><span class=line>    <span class=built_in><span class=keyword>void</span></span>     (*sa_handler)(<span class=keyword>int</span>);             <span class=comment>// 信号处理函数</span></span><br><span class=line>    <span class=built_in><span class=keyword>void</span></span>     (*sa_sigaction)(<span class=keyword>int</span>, <span class=keyword>siginfo_t</span> *, <span class=keyword>void</span> *); <span class=comment>// 用于带有附加信息的信号处理函数</span></span><br><span class=line>    <span class=keyword>sigset_t</span>   sa_mask;                       <span class=comment>// 在执行信号处理器期间需要阻塞的信号集合</span></span><br><span class=line>    <span class=keyword>int</span>        sa_flags;                      <span class=comment>// 控制信号处理的行为标志</span></span><br><span class=line>    <span class=built_in><span class=keyword>void</span></span>     (*sa_restorer)(<span class=keyword>void</span>);           <span class=comment>// 已废弃，不应使用</span></span><br><span class=line>};</span><br></pre></table></figure><p><code>sigaction</code> 结构体用于指定如何处理信号、信号处理程序的属性以及信号掩码等信息。<p><strong>字段说明</strong><ul><li><strong><code>sa_handler</code></strong>：<ul><li>这是一个指向信号处理函数的指针，或者可以设置为 <code>SIG_DFL</code>（默认信号处理）或 <code>SIG_IGN</code>（忽略信号）。</ul><li><strong><code>sa_sigaction</code></strong>：<ul><li>当 <code>sa_flags</code> 中设置了 <code>SA_SIGINFO</code> 标志时，此字段将作为信号处理函数使用。与 <code>sa_handler</code> 不同，<code>sa_sigaction</code> 可以接收更多信息，包括一个指向 <code>siginfo_t</code> 结构的指针（包含有关信号的详细信息）和一个指向处理器上下文的指针（通常不使用）。</ul><li><strong><code>sa_mask</code></strong>：<ul><li>定义了一个信号集，在调用信号处理程序之前，这些信号会被加入到当前的信号屏蔽字中。这意味着在执行信号处理程序期间，这些信号会被暂时阻塞。</ul><li><strong><code>sa_flags</code></strong>：<ul><li>控制信号处理的行为。常见的标志包括：<ul><li><strong><code>SA_RESTART</code></strong>：如果信号中断了某个系统调用，则自动重启该系统调用（而不是返回错误）。<li><strong><code>SA_NOCLDSTOP</code></strong>：仅对 <code>SIGCHLD</code> 信号有效，如果设置了此标志，则子进程停止或恢复时不会发送 <code>SIGCHLD</code> 信号给父进程。<li><strong><code>SA_NOCLDWAIT</code></strong>：仅对 <code>SIGCHLD</code> 信号有效，阻止创建僵尸进程。<li><strong><code>SA_SIGINFO</code></strong>：指示使用 <code>sa_sigaction</code> 字段中的信号处理函数，而非 <code>sa_handler</code>。这允许访问扩展的信号信息。</ul></ul><li><strong><code>sa_restorer</code></strong>：<ul><li>这个字段已废弃，不应该被使用。</ul></ul><p><strong>使用示例</strong><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdlib.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsignal.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>handler</span><span class=params>(<span class=keyword>int</span> signum, <span class=keyword>siginfo_t</span> *info, <span class=keyword>void</span> *context)</span> </span>{</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Caught signal %d\n"</span>, signum);</span><br><span class=line>    <span class=comment>// 打印更多关于信号的信息</span></span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Signal code: %d\n"</span>, info->si_code);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>sigaction</span> <span class=title>act</span>;</span></span><br><span class=line></span><br><span class=line>    <span class=comment>// 初始化结构体</span></span><br><span class=line>    act.sa_sigaction = handler;</span><br><span class=line>    act.sa_flags = SA_SIGINFO; <span class=comment>// 使用带有额外参数的信号处理函数</span></span><br><span class=line></span><br><span class=line>    <span class=comment>// 填充信号掩码，这里我们不限制任何额外的信号</span></span><br><span class=line>    <span class=built_in>sigemptyset</span>(&act.sa_mask);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 设置 SIGINT 的信号处理程序</span></span><br><span class=line>    <span class=keyword>if</span> (<span class=built_in>sigaction</span>(SIGINT, &act, <span class=literal>NULL</span>) == <span class=number>-1</span>) {</span><br><span class=line>        <span class=built_in>perror</span>(<span class=string>"sigaction"</span>);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Waiting for SIGINT (Ctrl+C)...\n"</span>);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 挂起进程，等待信号</span></span><br><span class=line>    <span class=keyword>while</span> (<span class=number>1</span>) {</span><br><span class=line>        <span class=built_in>pause</span>(); <span class=comment>// 等待信号</span></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><h2 id=stat><a class=headerlink href=#stat title=stat></a>stat</h2><p><code>stat</code> 函数是 Unix 和类 Unix 操作系统（如 Linux）中的一个系统调用，用于获取文件或文件系统对象的相关信息。它通过填充一个 <code>struct stat</code> 结构体来提供文件的元数据，包括文件大小、权限、创建时间等<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/types.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/stat.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>stat</span><span class=params>(<span class=keyword>const</span> <span class=keyword>char</span> *pathname, struct stat *statbuf)</span></span>;</span><br></pre></table></figure><ul><li><strong>参数</strong>：<ul><li><code>pathname</code>：要查询的文件或目录的路径。<li><code>statbuf</code>：指向一个 <code>struct stat</code> 结构体的指针，该结构体将被用来存储文件的状态信息。</ul><li><strong>返回值</strong>：<ul><li>成功时返回 <code>0</code>。<li>失败时返回 <code>-1</code> 并设置 <code>errno</code> 来指示错误类型。</ul></ul><p>除了 <code>stat</code>，还有其他几个类似的函数可以用于不同的场景：<ul><li><p><strong><code>fstat</code></strong>：与 <code>stat</code> 类似，但它接受一个文件描述符而不是路径名作为第一个参数。</p> <figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>fstat</span><span class=params>(<span class=keyword>int</span> fd, struct stat *statbuf)</span></span>;</span><br></pre></table></figure><li><p><strong><code>lstat</code></strong>：与 <code>stat</code> 类似，但如果目标是一个符号链接（symlink），它会返回符号链接本身的信息，而不是它指向的目标文件的信息。</p> <figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>lstat</span><span class=params>(<span class=keyword>const</span> <span class=keyword>char</span> *pathname, struct stat *statbuf)</span></span>;</span><br></pre></table></figure></ul><p><code>struct stat</code> 包含了大量的关于文件的信息。以下是一些常用的字段：<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>stat</span> {</span></span><br><span class=line>    <span class=keyword>dev_t</span>     st_dev;         <span class=comment>// 文件所在设备的标识符</span></span><br><span class=line>    <span class=keyword>ino_t</span>     st_ino;         <span class=comment>// inode 编号</span></span><br><span class=line>    <span class=keyword>mode_t</span>    st_mode;        <span class=comment>// 文件类型和访问权限</span></span><br><span class=line>    <span class=keyword>nlink_t</span>   st_nlink;       <span class=comment>// 硬链接数量</span></span><br><span class=line>    <span class=keyword>uid_t</span>     st_uid;         <span class=comment>// 文件所有者的用户 ID</span></span><br><span class=line>    <span class=keyword>gid_t</span>     st_gid;         <span class=comment>// 文件所有者的组 ID</span></span><br><span class=line>    <span class=keyword>dev_t</span>     st_rdev;        <span class=comment>// 如果文件是一个设备文件，则为其设备编号</span></span><br><span class=line>    <span class=keyword>off_t</span>     st_size;        <span class=comment>// 文件大小（字节数）</span></span><br><span class=line>    <span class=keyword>blksize_t</span> st_blksize;     <span class=comment>// 文件系统的 I/O 块大小</span></span><br><span class=line>    <span class=keyword>blkcnt_t</span>  st_blocks;      <span class=comment>// 分配给文件的块数</span></span><br><span class=line>    <span class=keyword>time_t</span>    st_atime;       <span class=comment>// 最后访问时间</span></span><br><span class=line>    <span class=keyword>time_t</span>    st_mtime;       <span class=comment>// 最后修改时间</span></span><br><span class=line>    <span class=keyword>time_t</span>    st_ctime;       <span class=comment>// 最后状态改变时间（在 Unix 中通常为元数据更改时间）</span></span><br><span class=line>};</span><br></pre></table></figure><p>在 <code>struct stat</code> 的 <code>st_mode</code> 字段中，文件类型和权限信息被编码在一起。可以通过位操作提取这些信息：<ul><li><strong>文件类型</strong>：<ul><li><code>S_IFMT</code>：文件类型的掩码。<li><code>S_IFDIR</code>：目录。<li><code>S_IFCHR</code>：字符设备。<li><code>S_IFBLK</code>：块设备。<li><code>S_IFREG</code>：普通文件。<li><code>S_IFIFO</code>：命名管道（FIFO）。<li><code>S_IFLNK</code>：符号链接。<li><code>S_IFSOCK</code>：套接字。</ul><li><strong>权限</strong>：<ul><li><code>S_IRUSR</code>, <code>S_IWUSR</code>, <code>S_IXUSR</code>：用户（拥有者）的读、写、执行权限。<li><code>S_IRGRP</code>, <code>S_IWGRP</code>, <code>S_IXGRP</code>：组的读、写、执行权限。<li><code>S_IROTH</code>, <code>S_IWOTH</code>, <code>S_IXOTH</code>：其他人的读、写、执行权限。</ul></ul><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>if</span> ((sb.st_mode & S_IFMT) == S_IFREG && (sb.st_mode & S_IRUSR)) {</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"This is a regular file with read permission for the owner.\n"</span>);</span><br><span class=line>}</span><br></pre></table></figure><h2 id=mmap><a class=headerlink href=#mmap title=mmap></a>mmap</h2><p><code>mmap</code> 是 Unix 和类 Unix 系统（如 Linux）中的一个系统调用，用于<strong>将文件或设备的内存映射到进程的地址空间</strong>。这种机制允许程序以类似于访问内存的方式访问文件内容，从而简化了文件操作，并且可以提高性能，特别是在处理大文件时。<ul><li><strong>文件映射</strong>：将文件的内容映射到进程的虚拟内存中，使得可以通过指针直接访问文件的数据，而不需要通过常规的文件 I/O 操作（如 <code>read</code> 和 <code>write</code>）。<li><strong>共享内存</strong>：允许多个进程共享同一块内存区域，实现高效的进程间通信（IPC）。<li><strong>匿名映射</strong>：创建不与任何文件关联的内存映射，适用于需要动态分配大块内存的情况</ul><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/mman.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> *<span class=title>mmap</span><span class=params>(<span class=keyword>void</span> *addr, <span class=keyword>size_t</span> length, <span class=keyword>int</span> prot, <span class=keyword>int</span> flags, <span class=keyword>int</span> fd, <span class=keyword>off_t</span> offset)</span></span>;</span><br></pre></table></figure><ul><li><strong>参数</strong>：<ul><li><code>addr</code>：建议的映射起始地址（通常设为 <code>NULL</code>，让系统选择合适的地址）。<li><code>length</code>：映射区域的大小（字节数）。<li>prot：指定映射区域的保护标志（如可读、可写、可执行等）。<ul><li><code>PROT_READ</code>：映射区域可读。<li><code>PROT_WRITE</code>：映射区域可写。<li><code>PROT_EXEC</code>：映射区域可执行。</ul><li>flags：控制映射区域的行为。<ul><li><code>MAP_SHARED</code>：映射区域会被多个进程共享，修改会反映到文件中。<li><code>MAP_PRIVATE</code>：创建私有副本，修改不会影响原文件。<li><code>MAP_ANONYMOUS</code>：映射匿名内存（不与文件关联）。</ul><li><code>fd</code>：要映射的文件描述符（对于匿名映射，应设置为 <code>-1</code>）。<li><code>offset</code>：从文件开头开始的偏移量（必须是页面大小的倍数）。</ul><li><p><strong>返回值</strong>：</p> <ul><li>成功时返回指向映射区域的指针。<li>失败时返回 <code>MAP_FAILED</code>（通常定义为 <code>(void *) -1</code>），并设置 <code>errno</code>。</ul><li><p><strong><code>munmap</code></strong>：解除内存映射。</p> <figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>munmap</span><span class=params>(<span class=keyword>void</span> *addr, <span class=keyword>size_t</span> length)</span></span>;</span><br></pre></table></figure><li><p><strong><code>msync</code></strong>：同步内存映射区域到文件或设备。</p> <figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>msync</span><span class=params>(<span class=keyword>void</span> *addr, <span class=keyword>size_t</span> length, <span class=keyword>int</span> flags)</span></span>;</span><br></pre></table></figure></ul><h2 id=解析传入参数><a class=headerlink href=#解析传入参数 title=解析传入参数></a>解析传入参数</h2><p>Linux中<code>getopt</code> 是一个用于解析命令行选项的标准 C 库函数。它使得程序能够处理以短格式（如 <code>-a</code>, <code>-b value</code>）提供的命令行参数。<code>getopt</code> 函数及其扩展版本 <code>getopt_long</code> 为开发者提供了便捷的方式来解析和处理命令行选项。<h4 id=get-opt函数><a class=headerlink href=#get-opt函数 title=get_opt函数></a>get_opt函数</h4><figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>getopt</span><span class=params>(<span class=keyword>int</span> argc, <span class=keyword>char</span> * <span class=keyword>const</span> argv[], <span class=keyword>const</span> <span class=keyword>char</span> *optstring)</span></span>;</span><br></pre></table></figure><ul><li><p><strong>参数</strong>：</p> <ul><li><code>argc</code> 和 <code>argv</code>：分别是从 <code>main</code> 函数传递过来的参数计数和参数数组。<li><code>optstring</code>：包含程序所支持的选项字符组成的字符串。如果某个选项需要参数，则在该选项字符后加上冒号（<code>:</code>），表示该选项需要一个值。</ul><li><p><strong>返回值</strong>：</p> <ul><li>成功时，返回下一个选项字符。<li>当所有选项都已处理完毕，返回 <code>-1</code>。<li>如果遇到无效选项或缺少必需的参数，返回 <code>?</code> 并设置 <code>optopt</code> 变量为无效选项字符。</ul><li><p><strong>全局变量</strong>：</p> <ul><li><code>optind</code>：指向下一个要处理的 <code>argv</code> 元素的索引。<li><code>optarg</code>：<strong>指向当前选项的参数</strong>（如果有）。<li><code>opterr</code>：控制 <code>getopt</code> 是否打印错误消息，默认为 1（开启）。<li><code>optopt</code>：存储无效选项字符或缺失参数的选项字符。</ul> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>(<span class=keyword>int</span> argc, <span class=keyword>char</span> *argv[])</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> opt;</span><br><span class=line>    <span class=keyword>while</span> ((opt = <span class=built_in>getopt</span>(argc, argv, <span class=string>"ab:c"</span>)) != <span class=number>-1</span>) {</span><br><span class=line>        <span class=built_in><span class=keyword>switch</span></span> (opt) {</span><br><span class=line>            <span class=keyword>case</span> <span class=string>'a'</span>:</span><br><span class=line>                <span class=built_in>printf</span>(<span class=string>"Option -a\n"</span>);</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            <span class=keyword>case</span> <span class=string>'b'</span>:</span><br><span class=line>                <span class=built_in>printf</span>(<span class=string>"Option -b with value %s\n"</span>, optarg);</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            <span class=keyword>case</span> <span class=string>'c'</span>:</span><br><span class=line>                <span class=built_in>printf</span>(<span class=string>"Option -c\n"</span>);</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            <span class=keyword>case</span> <span class=string>'?'</span>:</span><br><span class=line>                <span class=keyword>if</span> (optopt == <span class=string>'b'</span>) {</span><br><span class=line>                    <span class=built_in>fprintf</span>(stderr, <span class=string>"Option -b requires an argument.\n"</span>);</span><br><span class=line>                } <span class=keyword>else</span> {</span><br><span class=line>                    <span class=built_in>fprintf</span>(stderr, <span class=string>"Unknown option character `\\x%x'.\n"</span>, optopt);</span><br><span class=line>                }</span><br><span class=line>                <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>            <span class=keyword>default</span>:</span><br><span class=line>                <span class=built_in>abort</span>();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 处理非选项参数</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> index = optind; index < argc; index++) {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Non-option argument: %s\n"</span>, argv[index]);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure></ul><h4 id=getopt-long-函数><a title="getopt_long 函数" class=headerlink href=#getopt-long-函数></a><code>getopt_long</code> 函数</h4><p>对于支持长格式选项（如 <code>--option</code>, <code>--option=value</code>）的应用程序，可以使用 <code>getopt_long</code> 函数。<h4 id=函数原型><a class=headerlink href=#函数原型 title=函数原型></a><strong>函数原型</strong></h4><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTgetopt.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>getopt_long</span><span class=params>(<span class=keyword>int</span> argc, <span class=keyword>char</span> * <span class=keyword>const</span> argv[], <span class=keyword>const</span> <span class=keyword>char</span> *shortopts, <span class=keyword>const</span> struct option *longopts, <span class=keyword>int</span> *longindex)</span></span>;</span><br></pre></table></figure><ul><li><p><strong>参数</strong>：</p> <ul><li><p><code>shortopts</code>：与 <code>getopt</code> 相同，定义短格式选项。</p><li><p>longopts指向描述长格式选项的struct option</p> <figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>option</span> {</span></span><br><span class=line>    <span class=keyword>const</span> <span class=keyword>char</span> *name;    <span class=comment>// 长格式选项名</span></span><br><span class=line>    <span class=keyword>int</span>         has_arg; <span class=comment>// 是否需要参数，可能值：no_argument, required_argument, optional_argument</span></span><br><span class=line>    <span class=keyword>int</span>        *flag;    <span class=comment>// 若不为 NULL，函数将此指针指向的变量设为 val；若为 NULL，函数返回 val</span></span><br><span class=line>    <span class=keyword>int</span>         val;     <span class=comment>// 返回给 `getopt_long` 的值或设置到 `flag` 指向的变量中</span></span><br><span class=line>};</span><br></pre></table></figure><li><p><code>longindex</code>：如果非 <code>NULL</code>，则指向一个变量，该变量接收匹配的长选项在 <code>longopts</code> 数组中的索引。</p></ul><li><p><strong>返回值</strong>：</p> <ul><li>成功时，返回匹配选项的字符（对于短选项）或 <code>val</code> 字段的值（对于长选项）。<li>当所有选项都已处理完毕，返回 <code>-1</code>。<li>对于无效选项或缺少必需的参数，返回 <code>?</code>。</ul><li><p><strong><code>getopt</code></strong>：适用于处理短格式选项的简单场景。通过指定一个选项字符串来定义允许的选项及是否需要参数。</p><li><strong><code>getopt_long</code></strong>：扩展了 <code>getopt</code>，支持长格式选项，并允许更灵活地配置每个选项的行为（是否需要参数、如何处理等）。</ul><h2 id=分散-聚集IO><a class=headerlink href=#分散-聚集IO title=分散/聚集IO></a>分散/聚集IO</h2><p>分散/聚集 I/O（Scatter/Gather I/O）是一种<strong>允许在单次系统调用中处理多个数据缓冲区的技术</strong>。它特别适用于需要处理多个不连续的数据块的应用场景，如网络通信、数据库操作等。通过分散/聚集 I/O，可以减少系统调用的次数，提高性能和效率。<h4 id=分散-I-O（Scatter-I-O）><a title="分散 I/O（Scatter I/O）" class=headerlink href=#分散-I-O（Scatter-I-O）></a>分散 I/O（Scatter I/O）</h4><p>分散读取（Scatter Read）指的是从一个输入源（例如文件或套接字）读取数据，并将这些数据分散到多个缓冲区中。这种技术通常用于接收长度未知的数据流，并将其分割成多个部分存储在不同的缓冲区中。<h4 id=聚集-I-O（Gather-I-O）><a title="聚集 I/O（Gather I/O）" class=headerlink href=#聚集-I-O（Gather-I-O）></a>聚集 I/O（Gather I/O）</h4><p>聚集写入（Gather Write）则是指将多个缓冲区中的数据收集起来，然后一次性写入到输出目标（例如文件或套接字）。这种方法可以简化编程模型，并且通过减少系统调用的数量来提高性能。<p>在 Unix 和类 Unix 系统（如 Linux）中，分散/聚集 I/O 主要通过 <code>readv</code> 和 <code>writev</code> 系统调用来实现。<p><strong><code>readv</code> 和 <code>writev</code> 函数</strong><ul><li><strong><code>readv</code></strong>：从文件描述符读取数据并分散到多个缓冲区。<li><strong><code>writev</code></strong>：从多个缓冲区收集数据并写入到文件描述符。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>iovec</span> {</span></span><br><span class=line>    <span class=keyword>void</span>  *iov_base;    <span class=comment>// 指向缓冲区的指针</span></span><br><span class=line>    <span class=keyword>size_t</span> iov_len;     <span class=comment>// 缓冲区长度（字节数）</span></span><br><span class=line>};</span><br></pre></table></figure><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTfcntl.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/uio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> fd = <span class=built_in>open</span>(<span class=string>"example.txt"</span>, O_RDONLY);</span><br><span class=line>    <span class=keyword>if</span> (fd == <span class=number>-1</span>) {</span><br><span class=line>        <span class=built_in>perror</span>(<span class=string>"open"</span>);</span><br><span class=line>        <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>char</span> buf1[<span class=number>6</span>]; <span class=comment>// 存储 "Hello,"</span></span><br><span class=line>    <span class=keyword>char</span> buf2[<span class=number>8</span>]; <span class=comment>// 存储 " World!\n"</span></span><br><span class=line>    </span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>iovec</span> <span class=title>iov</span>[2];</span></span><br><span class=line>    iov[<span class=number>0</span>].iov_base = buf1;</span><br><span class=line>    iov[<span class=number>0</span>].iov_len = <span class=built_in><span class=keyword>sizeof</span></span>(buf1);</span><br><span class=line>    iov[<span class=number>1</span>].iov_base = buf2;</span><br><span class=line>    iov[<span class=number>1</span>].iov_len = <span class=built_in><span class=keyword>sizeof</span></span>(buf2);</span><br><span class=line></span><br><span class=line>    <span class=keyword>ssize_t</span> read_bytes = <span class=built_in>readv</span>(fd, iov, <span class=number>2</span>);</span><br><span class=line>    <span class=keyword>if</span> (read_bytes == <span class=number>-1</span>) {</span><br><span class=line>        <span class=built_in>perror</span>(<span class=string>"readv"</span>);</span><br><span class=line>        <span class=built_in>close</span>(fd);</span><br><span class=line>        <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    buf1[<span class=built_in><span class=keyword>sizeof</span></span>(buf1)<span class=number>-1</span>] = <span class=string>'\0'</span>; <span class=comment>// 确保 buf1 是以 null 结尾的字符串</span></span><br><span class=line>    buf2[<span class=built_in><span class=keyword>sizeof</span></span>(buf2)<span class=number>-1</span>] = <span class=string>'\0'</span>; <span class=comment>// 确保 buf2 是以 null 结尾的字符串</span></span><br><span class=line></span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Read %zd bytes: '%s' and '%s'\n"</span>, read_bytes, buf1, buf2);</span><br><span class=line></span><br><span class=line>    <span class=built_in>close</span>(fd);</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><h2 id=TCP流程><a class=headerlink href=#TCP流程 title=TCP流程></a>TCP流程</h2><p><strong>TCP Server</strong><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdlib.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTarpa/inet.h></span></span></span><br><span class=line></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> PORT 8080</span></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> BUFFER_SIZE 1024</span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> server_fd, new_socket;</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>sockaddr_in</span> <span class=title>address</span>;</span></span><br><span class=line>    <span class=keyword>int</span> addrlen = <span class=keyword>sizeof</span>(address);</span><br><span class=line>    <span class=keyword>char</span> buffer[BUFFER_SIZE] = {<span class=number>0</span>};</span><br><span class=line>    <span class=keyword>const</span> <span class=keyword>char</span> *response = <span class=string>"Hello from server"</span>;</span><br><span class=line></span><br><span class=line>    <span class=comment>// 创建套接字</span></span><br><span class=line>    <span class=keyword>if</span> ((server_fd = socket(AF_INET, SOCK_STREAM, <span class=number>0</span>)) == <span class=number>0</span>) {</span><br><span class=line>        perror(<span class=string>"Socket creation failed"</span>);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 绑定地址和端口</span></span><br><span class=line>    address.sin_family = AF_INET;</span><br><span class=line>    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class=line>    address.sin_port = htons(PORT);</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (bind(server_fd, (struct sockaddr *)&address, <span class=keyword>sizeof</span>(address)) < <span class=number>0</span>) {</span><br><span class=line>        perror(<span class=string>"Bind failed"</span>);</span><br><span class=line>        close(server_fd);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 监听连接</span></span><br><span class=line>    <span class=keyword>if</span> (listen(server_fd, <span class=number>3</span>) < <span class=number>0</span>) {</span><br><span class=line>        perror(<span class=string>"Listen failed"</span>);</span><br><span class=line>        close(server_fd);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Server is listening on port %d...\n"</span>, PORT);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 接受客户端连接</span></span><br><span class=line>    <span class=keyword>if</span> ((new_socket = accept(server_fd, (struct sockaddr *)&address, (<span class=keyword>socklen_t</span> *)&addrlen)) < <span class=number>0</span>) {</span><br><span class=line>        perror(<span class=string>"Accept failed"</span>);</span><br><span class=line>        close(server_fd);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 读取客户端数据</span></span><br><span class=line>    <span class=keyword>int</span> valread = read(new_socket, buffer, BUFFER_SIZE);</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Client: %s\n"</span>, buffer);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 发送响应</span></span><br><span class=line>    send(new_socket, response, <span class=built_in>strlen</span>(response), <span class=number>0</span>);</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Response sent to client.\n"</span>);</span><br><span class=line></span><br><span class=line>    close(new_socket);</span><br><span class=line>    close(server_fd);</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><p><strong>TCP Client</strong><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdlib.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTarpa/inet.h></span></span></span><br><span class=line></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> PORT 8080</span></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> BUFFER_SIZE 1024</span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> sock = <span class=number>0</span>;</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>sockaddr_in</span> <span class=title>serv_addr</span>;</span></span><br><span class=line>    <span class=keyword>char</span> buffer[BUFFER_SIZE] = {<span class=number>0</span>};</span><br><span class=line>    <span class=keyword>const</span> <span class=keyword>char</span> *message = <span class=string>"Hello from client"</span>;</span><br><span class=line></span><br><span class=line>    <span class=comment>// 创建套接字</span></span><br><span class=line>    <span class=keyword>if</span> ((sock = socket(AF_INET, SOCK_STREAM, <span class=number>0</span>)) < <span class=number>0</span>) {</span><br><span class=line>        perror(<span class=string>"Socket creation failed"</span>);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    serv_addr.sin_family = AF_INET;</span><br><span class=line>    serv_addr.sin_port = htons(PORT);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 将 IP 地址转换为二进制形式</span></span><br><span class=line>    <span class=keyword>if</span> (inet_pton(AF_INET, <span class=string>"127.0.0.1"</span>, &serv_addr.sin_addr) <= <span class=number>0</span>) {</span><br><span class=line>        perror(<span class=string>"Invalid address/ Address not supported"</span>);</span><br><span class=line>        close(sock);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 连接到服务器</span></span><br><span class=line>    <span class=keyword>if</span> (connect(sock, (struct sockaddr *)&serv_addr, <span class=keyword>sizeof</span>(serv_addr)) < <span class=number>0</span>) {</span><br><span class=line>        perror(<span class=string>"Connection failed"</span>);</span><br><span class=line>        close(sock);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 发送消息</span></span><br><span class=line>    send(sock, message, <span class=built_in>strlen</span>(message), <span class=number>0</span>);</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Message sent to server.\n"</span>);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 接收响应</span></span><br><span class=line>    <span class=keyword>int</span> valread = read(sock, buffer, BUFFER_SIZE);</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Server: %s\n"</span>, buffer);</span><br><span class=line></span><br><span class=line>    close(sock);</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}<span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdlib.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTarpa/inet.h></span></span></span><br><span class=line></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> PORT 8080</span></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> BUFFER_SIZE 1024</span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> sock = <span class=number>0</span>;</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>sockaddr_in</span> <span class=title>serv_addr</span>;</span></span><br><span class=line>    <span class=keyword>char</span> buffer[BUFFER_SIZE] = {<span class=number>0</span>};</span><br><span class=line>    <span class=keyword>const</span> <span class=keyword>char</span> *message = <span class=string>"Hello from client"</span>;</span><br><span class=line></span><br><span class=line>    <span class=comment>// 创建套接字</span></span><br><span class=line>    <span class=keyword>if</span> ((sock = socket(AF_INET, SOCK_STREAM, <span class=number>0</span>)) < <span class=number>0</span>) {</span><br><span class=line>        perror(<span class=string>"Socket creation failed"</span>);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    serv_addr.sin_family = AF_INET;</span><br><span class=line>    serv_addr.sin_port = htons(PORT);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 将 IP 地址转换为二进制形式</span></span><br><span class=line>    <span class=keyword>if</span> (inet_pton(AF_INET, <span class=string>"127.0.0.1"</span>, &serv_addr.sin_addr) <= <span class=number>0</span>) {</span><br><span class=line>        perror(<span class=string>"Invalid address/ Address not supported"</span>);</span><br><span class=line>        close(sock);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 连接到服务器</span></span><br><span class=line>    <span class=keyword>if</span> (connect(sock, (struct sockaddr *)&serv_addr, <span class=keyword>sizeof</span>(serv_addr)) < <span class=number>0</span>) {</span><br><span class=line>        perror(<span class=string>"Connection failed"</span>);</span><br><span class=line>        close(sock);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 发送消息</span></span><br><span class=line>    send(sock, message, <span class=built_in>strlen</span>(message), <span class=number>0</span>);</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Message sent to server.\n"</span>);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 接收响应</span></span><br><span class=line>    <span class=keyword>int</span> valread = read(sock, buffer, BUFFER_SIZE);</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Server: %s\n"</span>, buffer);</span><br><span class=line></span><br><span class=line>    close(sock);</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><h2 id=UDP流程><a class=headerlink href=#UDP流程 title=UDP流程></a>UDP流程</h2><p><strong>UDP Server</strong><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br></pre><td class=code><pre><span class=line></span><br><span class=line></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTcstdio></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTcstdlib></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTcstring></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTnetinet/in.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line><span class=keyword>const</span> <span class=keyword>int</span> PORT = <span class=number>8080</span>;</span><br><span class=line><span class=keyword>const</span> <span class=keyword>int</span> BUFFER_SIZE = <span class=number>1024</span>;</span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>  <span class=keyword>int</span> sockfd;</span><br><span class=line>  <span class=keyword>char</span> buffer[BUFFER_SIZE];</span><br><span class=line>  sockaddr_in servaddr, cliaddr;</span><br><span class=line>  <span class=keyword>socklen_t</span> len = <span class=built_in><span class=keyword>sizeof</span></span>(cliaddr);</span><br><span class=line>  <span class=keyword>const</span> <span class=keyword>char</span> *response = <span class=string>"Hello from server"</span>;</span><br><span class=line>  <span class=comment>// 创建套接字 SOCK_DGRAM</span></span><br><span class=line>  <span class=keyword>if</span> ((sockfd = <span class=built_in>socket</span>(AF_INET, SOCK_DGRAM, <span class=number>0</span>)) < <span class=number>0</span>) {</span><br><span class=line>    <span class=built_in>perror</span>(<span class=string>"Socket creation failed"</span>);</span><br><span class=line>    <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=built_in>memset</span>(&servaddr, <span class=number>0</span>, <span class=built_in><span class=keyword>sizeof</span></span>(servaddr));</span><br><span class=line>  <span class=built_in>memset</span>(&cliaddr, <span class=number>0</span>, <span class=built_in><span class=keyword>sizeof</span></span>(cliaddr));</span><br><span class=line></span><br><span class=line>  <span class=comment>// 绑定地址和端口</span></span><br><span class=line>  servaddr.sin_family = AF_INET;</span><br><span class=line>  servaddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class=line>  servaddr.sin_port = <span class=built_in>htons</span>(PORT);</span><br><span class=line>  <span class=keyword>if</span> (<span class=built_in>bind</span>(sockfd, (<span class=keyword>const</span> struct sockaddr *)&servaddr, <span class=built_in><span class=keyword>sizeof</span></span>(servaddr)) < <span class=number>0</span>) {</span><br><span class=line>    <span class=built_in>perror</span>(<span class=string>"Bind failed"</span>);</span><br><span class=line>    <span class=built_in>close</span>(sockfd);</span><br><span class=line>    <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>  }</span><br><span class=line>  <span class=built_in>printf</span>(<span class=string>"Server is listening on port %d...\n"</span>, PORT);</span><br><span class=line></span><br><span class=line>  <span class=comment>// 服务端绑定套接字后 直接开始读了</span></span><br><span class=line>  <span class=comment>// 接收客户端数据</span></span><br><span class=line>  <span class=keyword>int</span> n = <span class=built_in>recvfrom</span>(sockfd, (<span class=keyword>char</span> *)buffer, BUFFER_SIZE, <span class=number>0</span>,</span><br><span class=line>                   (struct sockaddr *)&cliaddr, &len);</span><br><span class=line>  buffer[n] = <span class=string>'\0'</span>;</span><br><span class=line>  <span class=built_in>printf</span>(<span class=string>"Client: %s\n"</span>, buffer);</span><br><span class=line></span><br><span class=line>  <span class=comment>// 发送响应</span></span><br><span class=line>  <span class=built_in>sendto</span>(sockfd, (<span class=keyword>const</span> <span class=keyword>char</span> *)response, <span class=built_in>strlen</span>(response), <span class=number>0</span>,</span><br><span class=line>         (<span class=keyword>const</span> struct sockaddr *)&cliaddr, len);</span><br><span class=line>  <span class=built_in>printf</span>(<span class=string>"Response sent to client.\n"</span>);</span><br><span class=line></span><br><span class=line>  <span class=built_in>close</span>(sockfd);</span><br><span class=line>  <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><p><strong>UDP Client</strong><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTarpa/inet.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdlib.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> PORT 8080</span></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> BUFFER_SIZE 1024</span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>  <span class=keyword>int</span> sockfd;</span><br><span class=line>  <span class=keyword>char</span> buffer[BUFFER_SIZE];</span><br><span class=line>  <span class=class><span class=keyword>struct</span> <span class=title>sockaddr_in</span> <span class=title>servaddr</span>;</span></span><br><span class=line>  <span class=keyword>const</span> <span class=keyword>char</span> *message = <span class=string>"Hello from client"</span>;</span><br><span class=line></span><br><span class=line>  <span class=comment>// 创建套接字</span></span><br><span class=line>  <span class=keyword>if</span> ((sockfd = <span class=built_in>socket</span>(AF_INET, SOCK_DGRAM, <span class=number>0</span>)) < <span class=number>0</span>) {</span><br><span class=line>    <span class=built_in>perror</span>(<span class=string>"Socket creation failed"</span>);</span><br><span class=line>    <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=built_in>memset</span>(&servaddr, <span class=number>0</span>, <span class=built_in><span class=keyword>sizeof</span></span>(servaddr));</span><br><span class=line></span><br><span class=line>  <span class=comment>// 设置服务器地址</span></span><br><span class=line>  servaddr.sin_family = AF_INET;</span><br><span class=line>  servaddr.sin_port = <span class=built_in>htons</span>(PORT);</span><br><span class=line>  servaddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class=line></span><br><span class=line>  <span class=comment>// 将 IP 地址转换为二进制形式</span></span><br><span class=line>  <span class=keyword>if</span> (<span class=built_in>inet_pton</span>(AF_INET, <span class=string>"127.0.0.1"</span>, &servaddr.sin_addr) <= <span class=number>0</span>) {</span><br><span class=line>    <span class=built_in>perror</span>(<span class=string>"Invalid address/ Address not supported"</span>);</span><br><span class=line>    <span class=built_in>close</span>(sockfd);</span><br><span class=line>    <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=comment>// 创建套接字 后直接发送消息 需要连接的地址,不需要connect</span></span><br><span class=line>  <span class=comment>// 发送消息</span></span><br><span class=line>  <span class=built_in>sendto</span>(sockfd, (<span class=keyword>const</span> <span class=keyword>char</span> *)message, <span class=built_in>strlen</span>(message), <span class=number>0</span>,</span><br><span class=line>         (<span class=keyword>const</span> struct sockaddr *)&servaddr, <span class=built_in><span class=keyword>sizeof</span></span>(servaddr));</span><br><span class=line>  <span class=built_in>printf</span>(<span class=string>"Message sent to server.\n"</span>);</span><br><span class=line></span><br><span class=line>  <span class=comment>// 接收响应</span></span><br><span class=line>  <span class=keyword>socklen_t</span> len = <span class=built_in><span class=keyword>sizeof</span></span>(servaddr);</span><br><span class=line>  <span class=keyword>int</span> n = <span class=built_in>recvfrom</span>(sockfd, (<span class=keyword>char</span> *)buffer, BUFFER_SIZE, <span class=number>0</span>,</span><br><span class=line>                   (struct sockaddr *)&servaddr, &len);</span><br><span class=line>  buffer[n] = <span class=string>'\0'</span>;</span><br><span class=line>  <span class=built_in>printf</span>(<span class=string>"Server: %s\n"</span>, buffer);</span><br><span class=line></span><br><span class=line>  <span class=built_in>close</span>(sockfd);</span><br><span class=line>  <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><h2 id=其他><a class=headerlink href=#其他 title=其他></a>其他</h2><h3 id=在windows上的异步I-O机制><a class=headerlink href=#在windows上的异步I-O机制 title=在windows上的异步I/O机制></a>在windows上的异步I/O机制</h3><p>异步 I/O（Asynchronous I/O）是一种高效的机制，用于处理文件、网络套接字等设备的输入输出操作.Windows 提供了多种实现异步 I/O 的方式，包括 <strong>Overlapped I/O</strong> 和 <strong>I/O Completion Ports (IOCP)</strong>。<h4 id=Overlapped-I-O><a title="Overlapped I/O" class=headerlink href=#Overlapped-I-O></a><strong>Overlapped I/O</strong></h4><p><strong>概述</strong><p>Overlapped I/O 是 Windows 提供的一种异步 I/O 机制，它通过使用 <code>OVERLAPPED</code> 结构体来标记一个 I/O 操作是否为异步。这种机制适用于文件操作和套接字通信。<ul><li>如果一个文件句柄或套接字是以重叠（Overlapped）模式打开的，则可以对其进行异步操作。<li>异步操作完成后，可以通过以下方式通知应用程序：<ul><li>使用事件对象（Event Object）。<li>调用回调函数（Completion Routine）。<li>使用 I/O 完成端口（IOCP）。</ul></ul><p><strong>关键函数</strong><ul><li><strong><code>ReadFile</code> / <code>WriteFile</code></strong>：用于读写文件或套接字。<li><strong><code>GetOverlappedResult</code></strong>：检查异步操作的状态。<li><strong><code>CancelIoEx</code></strong>：取消挂起的异步 I/O 操作。</ul><p><strong>示例代码</strong><p>以下是一个使用 Overlapped I/O 进行异步文件读取的示例：<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTwindows.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>AsyncFileRead</span><span class=params>()</span> </span>{</span><br><span class=line>    HANDLE hFile = CreateFile(</span><br><span class=line>        <span class=string>"example.txt"</span>,                  <span class=comment>// 文件名</span></span><br><span class=line>        GENERIC_READ,                   <span class=comment>// 打开文件用于读取</span></span><br><span class=line>        <span class=number>0</span>,                              <span class=comment>// 不共享</span></span><br><span class=line>        <span class=literal>NULL</span>,                           <span class=comment>// 默认安全属性</span></span><br><span class=line>        OPEN_EXISTING,                  <span class=comment>// 打开已存在的文件</span></span><br><span class=line>        FILE_FLAG_OVERLAPPED,           <span class=comment>// 启用 Overlapped I/O</span></span><br><span class=line>        <span class=literal>NULL</span>                            <span class=comment>// 无模板文件</span></span><br><span class=line>    );</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (hFile == INVALID_HANDLE_VALUE) {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Failed to open file. Error: %d\n"</span>, GetLastError());</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>char</span> buffer[<span class=number>1024</span>];</span><br><span class=line>    OVERLAPPED overlapped = {<span class=number>0</span>};</span><br><span class=line>    overlapped.hEvent = CreateEvent(<span class=literal>NULL</span>, TRUE, FALSE, <span class=literal>NULL</span>); <span class=comment>// 创建事件对象</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (!ReadFile(hFile, buffer, <span class=keyword>sizeof</span>(buffer), <span class=literal>NULL</span>, &overlapped)) {</span><br><span class=line>        <span class=keyword>if</span> (GetLastError() != ERROR_IO_PENDING) {</span><br><span class=line>            <span class=built_in>printf</span>(<span class=string>"ReadFile failed. Error: %d\n"</span>, GetLastError());</span><br><span class=line>            CloseHandle(hFile);</span><br><span class=line>            CloseHandle(overlapped.hEvent);</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 等待异步操作完成</span></span><br><span class=line>    WaitForSingleObject(overlapped.hEvent, INFINITE);</span><br><span class=line></span><br><span class=line>    DWORD bytesRead;</span><br><span class=line>    <span class=keyword>if</span> (GetOverlappedResult(hFile, &overlapped, &bytesRead, FALSE)) {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Read %d bytes: %.*s\n"</span>, bytesRead, bytesRead, buffer);</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"GetOverlappedResult failed. Error: %d\n"</span>, GetLastError());</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    CloseHandle(hFile);</span><br><span class=line>    CloseHandle(overlapped.hEvent);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    AsyncFileRead();</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><ul><li>Overlapped I/O 是 Windows 中最基础的异步 I/O 实现方式之一。它通过 <code>OVERLAPPED</code> 结构体来标记一个 I/O 操作是否为异步。<li>当使用重叠模式打开文件或套接字时，可以发起异步操作，并且在操作完成前继续执行其他代码。</ul><p><strong>关键函数</strong><ul><li><strong><code>CreateFile</code></strong>：创建或打开文件时指定 <code>FILE_FLAG_OVERLAPPED</code> 标志以启用重叠模式。<li><strong><code>ReadFile</code> / <code>WriteFile</code></strong>：用于读取或写入数据。对于异步操作，最后一个参数应指向一个有效的 <code>OVERLAPPED</code> 结构体。<li><strong><code>GetOverlappedResult</code></strong>：获取异步操作的结果。<li><strong><code>WaitForSingleObject</code> 或 <code>WaitForMultipleObjects</code></strong>：等待异步操作完成。</ul><h4 id=回调函数><a class=headerlink href=#回调函数 title=回调函数></a>回调函数</h4><p>在 Windows 中，回调函数通常通过 <code>ReadFileEx</code> 或 <code>WriteFileEx</code> 函数注册，而不是直接使用 <code>ReadFile</code> 或 <code>WriteFile</code>。<p>回调函数的原型必须符合以下格式：<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=function>VOID CALLBACK <span class=title>CompletionRoutine</span><span class=params>(</span></span></span><br><span class=line><span class=params><span class=function>    DWORD dwErrorCode,       <span class=comment>// 错误码</span></span></span></span><br><span class=line><span class=params><span class=function>    DWORD dwNumberOfBytesTransfered, <span class=comment>// 转移的字节数</span></span></span></span><br><span class=line><span class=params><span class=function>    LPOVERLAPPED lpOverlapped        <span class=comment>// OVERLAPPED 结构体指针</span></span></span></span><br><span class=line><span class=params><span class=function>)</span></span>;</span><br></pre></table></figure><p><strong>使用 <code>ReadFileEx</code> 和 <code>WriteFileEx</code> 注册回调函数</strong><ul><li><code>ReadFileEx</code> 和 <code>WriteFileEx</code> 是专门用于异步 I/O 并支持回调函数的 API。<li>它们需要一个有效的 <code>OVERLAPPED</code> 结构体，并且文件句柄必须以重叠模式打开（即带有 <code>FILE_FLAG_OVERLAPPED</code> 标志）。<li><p>异步操作完成后，操作系统会调用指定的回调函数。</p><li><p>回调函数是一种轻量级的异步 I/O 处理方式，通过 <code>ReadFileEx</code> 和 <code>WriteFileEx</code> 函数注册回调函数，在操作完成后自动调用。</p><li>这种方式要求线程进入可提醒等待状态（Alertable Wait State），例如使用 <code>SleepEx</code> 函数。</ul><p><strong>关键函数</strong><ul><li><strong><code>ReadFileEx</code> / <code>WriteFileEx</code></strong>：用于启动异步 I/O 操作并注册回调函数。<li><strong><code>SleepEx</code></strong>：使当前线程进入可提醒等待状态，以便能够接收异步通知。</ul><p><strong>3. 示例代码</strong><p>以下是一个使用回调函数处理异步文件读取的完整示例：<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTwindows.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line></span><br><span class=line><span class=comment>// 回调函数定义</span></span><br><span class=line><span class=function>VOID CALLBACK <span class=title>FileIOCompletionRoutine</span><span class=params>(</span></span></span><br><span class=line><span class=params><span class=function>    DWORD dwErrorCode,</span></span></span><br><span class=line><span class=params><span class=function>    DWORD dwNumberOfBytesTransfered,</span></span></span><br><span class=line><span class=params><span class=function>    LPOVERLAPPED lpOverlapped)</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>    <span class=keyword>if</span> (dwErrorCode == <span class=number>0</span>) {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Asynchronous read completed successfully.\n"</span>);</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Number of bytes read: %d\n"</span>, dwNumberOfBytesTransfered);</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Asynchronous read failed with error code: %d\n"</span>, dwErrorCode);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>AsyncFileReadWithCallback</span><span class=params>()</span> </span>{</span><br><span class=line>    HANDLE hFile = CreateFile(</span><br><span class=line>        <span class=string>"example.txt"</span>,                  <span class=comment>// 文件名</span></span><br><span class=line>        GENERIC_READ,                   <span class=comment>// 打开文件用于读取</span></span><br><span class=line>        <span class=number>0</span>,                              <span class=comment>// 不共享</span></span><br><span class=line>        <span class=literal>NULL</span>,                           <span class=comment>// 默认安全属性</span></span><br><span class=line>        OPEN_EXISTING,                  <span class=comment>// 打开已存在的文件</span></span><br><span class=line>        FILE_FLAG_OVERLAPPED,           <span class=comment>// 启用 Overlapped I/O</span></span><br><span class=line>        <span class=literal>NULL</span>                            <span class=comment>// 无模板文件</span></span><br><span class=line>    );</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (hFile == INVALID_HANDLE_VALUE) {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Failed to open file. Error: %d\n"</span>, GetLastError());</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>char</span> buffer[<span class=number>1024</span>];</span><br><span class=line>    OVERLAPPED overlapped = {<span class=number>0</span>};</span><br><span class=line></span><br><span class=line>    <span class=comment>// 启动异步读取操作</span></span><br><span class=line>    BOOL result = ReadFileEx(</span><br><span class=line>        hFile,                          <span class=comment>// 文件句柄</span></span><br><span class=line>        buffer,                         <span class=comment>// 缓冲区</span></span><br><span class=line>        <span class=keyword>sizeof</span>(buffer),                 <span class=comment>// 要读取的字节数</span></span><br><span class=line>        &overlapped,                    <span class=comment>// OVERLAPPED 结构体</span></span><br><span class=line>        FileIOCompletionRoutine         <span class=comment>// 回调函数</span></span><br><span class=line>    );</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (!result) {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"ReadFileEx failed. Error: %d\n"</span>, GetLastError());</span><br><span class=line>        CloseHandle(hFile);</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 等待异步操作完成</span></span><br><span class=line>    SleepEx(INFINITE, TRUE); <span class=comment>// 进入可提醒等待状态，使回调函数得以执行</span></span><br><span class=line></span><br><span class=line>    CloseHandle(hFile);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    AsyncFileReadWithCallback();</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><h4 id=I-O-Completion-Ports-IOCP><a title="I/O Completion Ports (IOCP)" class=headerlink href=#I-O-Completion-Ports-IOCP></a>I/O Completion Ports (IOCP)</h4><p><strong>概述</strong><p>I/O Completion Ports（简称 IOCP）是 Windows 提供的一种高性能的异步 I/O 机制，特别适合于需要处理大量并发连接的服务器程序。IOCP 的核心思想是<strong>将多个 I/O 操作绑定到一个完成端口,并由一个线程池来处理完成的通知</strong>。<ul><li>IOCP 的优点：<ul><li>高效地管理多个并发 I/O 操作。<li>自动负载均衡，多个工作线程可以高效协作。<li>支持大规模并发连接。</ul></ul><p><strong>关键函数</strong><ul><li><strong><code>CreateIoCompletionPort</code></strong>：创建或关联一个完成端口。<li><strong><code>PostQueuedCompletionStatus</code></strong>：向完成端口队列提交自定义的完成包。<li><strong><code>GetQueuedCompletionStatus</code></strong>：从完成端口队列中获取完成通知。</ul><p><strong>示例代码</strong><p>以下是一个简单的 IOCP 示例，展示如何使用 IOCP 处理异步文件读取：<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTwindows.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line></span><br><span class=line><span class=keyword>typedef</span> <span class=class><span class=keyword>struct</span> {</span></span><br><span class=line>    OVERLAPPED overlapped;</span><br><span class=line>    <span class=keyword>char</span> buffer[<span class=number>1024</span>];</span><br><span class=line>} IO_CONTEXT;</span><br><span class=line></span><br><span class=line><span class=function>DWORD WINAPI <span class=title>WorkerThread</span><span class=params>(LPVOID lpParam)</span> </span>{</span><br><span class=line>    HANDLE hCompletionPort = (HANDLE)lpParam;</span><br><span class=line>    DWORD bytesTransferred;</span><br><span class=line>    ULONG_PTR completionKey;</span><br><span class=line>    LPOVERLAPPED pOverlapped;</span><br><span class=line></span><br><span class=line>    <span class=keyword>while</span> (<span class=literal>true</span>) {</span><br><span class=line>        BOOL result = GetQueuedCompletionStatus(</span><br><span class=line>            hCompletionPort, &bytesTransferred, &completionKey, &pOverlapped, INFINITE);</span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> (!result || bytesTransferred == <span class=number>0</span>) {</span><br><span class=line>            <span class=built_in>printf</span>(<span class=string>"Operation failed or completed.\n"</span>);</span><br><span class=line>            <span class=keyword>break</span>;</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        IO_CONTEXT *context = (IO_CONTEXT *)pOverlapped;</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Read %d bytes: %.*s\n"</span>, bytesTransferred, bytesTransferred, context->buffer);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>AsyncFileReadWithIOCP</span><span class=params>()</span> </span>{</span><br><span class=line>    HANDLE hFile = CreateFile(</span><br><span class=line>        <span class=string>"example.txt"</span>,</span><br><span class=line>        GENERIC_READ,</span><br><span class=line>        <span class=number>0</span>,</span><br><span class=line>        <span class=literal>NULL</span>,</span><br><span class=line>        OPEN_EXISTING,</span><br><span class=line>        FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,</span><br><span class=line>        <span class=literal>NULL</span></span><br><span class=line>    );</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (hFile == INVALID_HANDLE_VALUE) {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Failed to open file. Error: %d\n"</span>, GetLastError());</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    HANDLE hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, <span class=literal>NULL</span>, <span class=number>0</span>, <span class=number>0</span>);</span><br><span class=line>    <span class=keyword>if</span> (!hCompletionPort) {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Failed to create completion port. Error: %d\n"</span>, GetLastError());</span><br><span class=line>        CloseHandle(hFile);</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    CreateIoCompletionPort(hFile, hCompletionPort, (ULONG_PTR)hFile, <span class=number>0</span>);</span><br><span class=line></span><br><span class=line>    HANDLE hThread = CreateThread(<span class=literal>NULL</span>, <span class=number>0</span>, WorkerThread, hCompletionPort, <span class=number>0</span>, <span class=literal>NULL</span>);</span><br><span class=line>    <span class=keyword>if</span> (!hThread) {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Failed to create worker thread. Error: %d\n"</span>, GetLastError());</span><br><span class=line>        CloseHandle(hFile);</span><br><span class=line>        CloseHandle(hCompletionPort);</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    IO_CONTEXT context = {<span class=number>0</span>};</span><br><span class=line>    context.overlapped.Offset = <span class=number>0</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (!ReadFile(hFile, context.buffer, <span class=keyword>sizeof</span>(context.buffer), <span class=literal>NULL</span>, &context.overlapped)) {</span><br><span class=line>        <span class=keyword>if</span> (GetLastError() != ERROR_IO_PENDING) {</span><br><span class=line>            <span class=built_in>printf</span>(<span class=string>"ReadFile failed. Error: %d\n"</span>, GetLastError());</span><br><span class=line>            CloseHandle(hFile);</span><br><span class=line>            CloseHandle(hCompletionPort);</span><br><span class=line>            CloseHandle(hThread);</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    WaitForSingleObject(hThread, INFINITE);</span><br><span class=line></span><br><span class=line>    CloseHandle(hFile);</span><br><span class=line>    CloseHandle(hCompletionPort);</span><br><span class=line>    CloseHandle(hThread);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    AsyncFileReadWithIOCP();</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><p><strong>关键函数</strong><ul><li><strong><code>CreateIoCompletionPort</code></strong>：创建一个新的完成端口或将其与现有句柄关联。<li><strong><code>PostQueuedCompletionStatus</code></strong>：手动向完成端口队列中添加状态信息。<li><strong><code>GetQueuedCompletionStatus</code></strong>：从完成端口队列中检索下一个已完成的操作的状态。</ul><p><strong>3. 对比 Overlapped I/O 和 IOCP</strong><div class=table-container><table><thead><tr><th>特性<th>Overlapped I/O<th>IOCP<tbody><tr><td><strong>适用场景</strong><td>小规模异步操作<td>大规模并发 I/O 操作<tr><td><strong>性能</strong><td>较低<td>更高<tr><td><strong>复杂度</strong><td>较低<td>较高<tr><td><strong>线程管理</strong><td>需要手动管理线程<td>自动管理线程池<tr><td><strong>扩展性</strong><td>有限<td>非常强</table></div><p><strong>4. 总结</strong><ul><li><strong>Overlapped I/O</strong>：适合小型应用或需要简单异步 I/O 的场景，易于实现但扩展性较差。<li><p><strong>IOCP</strong>：适合高性能服务器程序，支持大规模并发连接，具有更高的效率和扩展性，但实现起来更复杂。</p><li><p><strong>简单场景</strong>：如果您的应用只需要简单的异步 I/O 操作，Overlapped I/O 可能是最容易实现的选择。</p><li><strong>高并发场景</strong>：如果您正在开发一个需要处理大量并发连接的应用程序（如 Web 服务器），那么 IOCP 是最佳选择，因为它提供了更好的性能和扩展性。<li><strong>轻量级需求</strong>：如果希望避免复杂的线程管理并且对性能的要求不是极高，可以考虑使用回调函数的方式。</ul><link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script></div><div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div class=popular-posts-header>相关文章</div><ul class=popular-posts><li class=popular-posts-item><div class=popular-posts-title><a href=\2025\03\20\TinyHttpServer项目学习\ rel=bookmark>TinyWebServer项目学习</a></div><li class=popular-posts-item><div class=popular-posts-title><a href=\2024\10\16\现代C-中的异常处理\ rel=bookmark>现代C++中的异常处理</a></div><li class=popular-posts-item><div class=popular-posts-title><a href=\2024\10\09\也许需要知道的c-概念\ rel=bookmark>也许需要知道的c++概念</a></div><li class=popular-posts-item><div class=popular-posts-title><a href=\2024\10\05\现代c-并发深入\ rel=bookmark>现代c++并发深入</a></div></ul><div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a href=https://www.sekyoro.top/2025/02/27/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ title=Linux网络编程入门>https://www.sekyoro.top/2025/02/27/Linux网络编程入门/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div><footer class=post-footer><div class=post-tags><a href=/tags/c/ rel=tag><i class="fa fa-tag"></i> c++</a><a href=/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/ rel=tag><i class="fa fa-tag"></i> Linux网络编程</a></div><div class=post-nav><div class=post-nav-item><a title="learn opengl(3)" href=/2025/01/26/learn-opengl-3/ rel=prev> <i class="fa fa-chevron-left"></i> learn opengl(3) </a></div><div class=post-nav-item><a href=/2025/03/09/mini-java-guide/ rel=next title=mini-java-guide> mini-java-guide <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div><!-- 评论区 --><div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%87%8D%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84><span class=nav-number>1.</span> <span class=nav-text>重要的数据结构</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80><span class=nav-number>1.1.</span> <span class=nav-text>套接字地址</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%9C%B0%E5%9D%80%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8E%E7%82%B9%E5%88%86%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2><span class=nav-number>1.2.</span> <span class=nav-text>地址二进制与点分十进制转换</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%AB%AF%E5%8F%A3%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E6%8D%A2><span class=nav-number>1.3.</span> <span class=nav-text>端口字节序转换</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AE%BE%E7%BD%AE%E5%A5%97%E6%8E%A5%E5%AD%97%E7%AD%89%E9%80%89%E9%A1%B9><span class=nav-number>1.4.</span> <span class=nav-text>设置套接字等选项</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%80%89%E9%A1%B9><span class=nav-number>1.5.</span> <span class=nav-text>设置文件描述符选项</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6><span class=nav-number>2.</span> <span class=nav-text>信号机制</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#signal><span class=nav-number>2.1.</span> <span class=nav-text>signal</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#sigaction><span class=nav-number>2.2.</span> <span class=nav-text>sigaction</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#stat><span class=nav-number>3.</span> <span class=nav-text>stat</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#mmap><span class=nav-number>4.</span> <span class=nav-text>mmap</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%A7%A3%E6%9E%90%E4%BC%A0%E5%85%A5%E5%8F%82%E6%95%B0><span class=nav-number>5.</span> <span class=nav-text>解析传入参数</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#get-opt%E5%87%BD%E6%95%B0><span class=nav-number>5.0.1.</span> <span class=nav-text>get_opt函数</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#getopt-long-%E5%87%BD%E6%95%B0><span class=nav-number>5.0.2.</span> <span class=nav-text>getopt_long 函数</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B><span class=nav-number>5.0.3.</span> <span class=nav-text>函数原型</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%88%86%E6%95%A3-%E8%81%9A%E9%9B%86IO><span class=nav-number>6.</span> <span class=nav-text>分散/聚集IO</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%88%86%E6%95%A3-I-O%EF%BC%88Scatter-I-O%EF%BC%89><span class=nav-number>6.0.1.</span> <span class=nav-text>分散 I/O（Scatter I/O）</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%81%9A%E9%9B%86-I-O%EF%BC%88Gather-I-O%EF%BC%89><span class=nav-number>6.0.2.</span> <span class=nav-text>聚集 I/O（Gather I/O）</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#TCP%E6%B5%81%E7%A8%8B><span class=nav-number>7.</span> <span class=nav-text>TCP流程</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#UDP%E6%B5%81%E7%A8%8B><span class=nav-number>8.</span> <span class=nav-text>UDP流程</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%85%B6%E4%BB%96><span class=nav-number>9.</span> <span class=nav-text>其他</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%9C%A8windows%E4%B8%8A%E7%9A%84%E5%BC%82%E6%AD%A5I-O%E6%9C%BA%E5%88%B6><span class=nav-number>9.1.</span> <span class=nav-text>在windows上的异步I/O机制</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#Overlapped-I-O><span class=nav-number>9.1.1.</span> <span class=nav-text>Overlapped I/O</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0><span class=nav-number>9.1.2.</span> <span class=nav-text>回调函数</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#I-O-Completion-Ports-IOCP><span class=nav-number>9.1.3.</span> <span class=nav-text>I/O Completion Ports (IOCP)</span></a></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>236</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>16</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>211</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a><li class=links-of-blogroll-item><a href=https://www.lllomh.com/ rel=noopener target=_blank title=https://www.lllomh.com/>芈渡</a><li class=links-of-blogroll-item><a href=https://protool-ten.vercel.app/ rel=noopener target=_blank title=https://protool-ten.vercel.app/>protools</a></ul></div><div class="motion-element announcement"><div class=title></div><p class=content><p class=date></div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>文章词云</h3><div class="widget tagcloud" id=myCanvasContainer><canvas height=250 id=resCanvas style=width:100% width=250><ul class=tag-list itemprop=keywords><li class=tag-list-item><a class=tag-list-link href=/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/ rel=tag>Linux网络编程</a><span class=tag-list-count>1</span><li class=tag-list-item><a class=tag-list-link href=/tags/c/ rel=tag>c++</a><span class=tag-list-count>5</span></ul></canvas></div></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2025</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>2.5m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>38:37</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer></div><script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script><script src=/lib/anime.min.js></script><script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script><script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/pisces.js></script><script src=/js/next-boot.js></script><script src=/js/bookmark.js></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	'.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script><script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script><script src=/js/algolia-search.js></script><script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script><div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div><script charset=utf-8 defer src=/js/tagcanvas.js></script><script charset=utf-8 defer src=/js/tagcloud.js></script><script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script><script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script><script src=/js/src/activate-power-mode.min.js></script><script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script>
<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"0F9LEEVW82","apiKey":"78839e9f9be09d081c5c4da81975cd19","indexName":"sekyoblog_sec","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content="c++在网络编程中特别普及,特别是Linux服务器编程. 相关书籍也有很多,这里简单介绍一下(结合AI总结)." name=description><meta content=article property=og:type><meta content=Linux网络编程入门 property=og:title><meta content=https://www.sekyoro.top/2025/02/27/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content="c++在网络编程中特别普及,特别是Linux服务器编程. 相关书籍也有很多,这里简单介绍一下(结合AI总结)." property=og:description><meta content=zh_CN property=og:locale><meta content=https://s2.loli.net/2025/02/27/azvYs7B46VeOAfb.png property=og:image><meta content=https://pic1.zhimg.com/v2-25903c3b11d19c9bbbc2f414665a435e_1440w.jpg property=og:image><meta content=https://pic4.zhimg.com/v2-c886c75a94b559d44aecfc17b97d898d_1440w.jpg property=og:image><meta content=https://cloud.cuterwrite.fun/blog/20230802172119.webp property=og:image><meta content=https://s2.loli.net/2025/04/26/Z5JHSabqlVtiUCG.png property=og:image><meta content=https://s2.loli.net/2025/04/27/7iDBW3cvdCEsyao.png property=og:image><meta content=https://s2.loli.net/2025/04/27/IcbnHVp9faBzWmP.png property=og:image><meta content=2025-02-27T07:01:15.000Z property=article:published_time><meta content=2025-05-02T06:03:41.435Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content=c++ property=article:tag><meta content=Linux网络编程 property=article:tag><meta content=summary name=twitter:card><meta content=https://s2.loli.net/2025/02/27/azvYs7B46VeOAfb.png name=twitter:image><link href=https://www.sekyoro.top/2025/02/27/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>Linux网络编程入门 | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2025/02/27/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>Linux网络编程入门</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2025-02-27 15:01:15" datetime=2025-02-27T15:01:15+08:00>2025-02-27</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-05-02 14:03:41" datetime=2025-05-02T14:03:41+08:00 itemprop=dateModified>2025-05-02</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>53k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>49 分钟</span> </span></div></header><div class=post-body itemprop=articleBody><p>c++在网络编程中特别普及,特别是Linux服务器编程. 相关书籍也有很多,这里简单介绍一下(结合AI总结).<br><span id=more></span><h2 id=重要的数据结构><a class=headerlink href=#重要的数据结构 title=重要的数据结构></a>重要的数据结构</h2><h3 id=套接字地址><a class=headerlink href=#套接字地址 title=套接字地址></a>套接字地址</h3><blockquote><p><strong>PF_INET</strong>：指的是协议族（Protocol Family），强调的是协议相关的概念。<p><strong>AF_INET</strong>：指的是地址族（Address Family），关注的是地址格式。<p>虽然在许多实现中 <code>PF_INET</code> 和 <code>AF_INET</code> 可以互换使用，但理论上它们代表不同的概念。为了保持代码的清晰性和一致性，推荐的做法是在创建套接字时使用 <code>AF_INET</code> 来指代地址族，而保留 <code>PF_INET</code> 用于协议族相关的上下文。不过，由于历史原因和广泛接受的习惯，这种区别在实践中往往被忽略。</blockquote><p>在进行网络编程时，<code>sockaddr_in</code>、<code>sockaddr</code> 和 <code>addrinfo</code> 是三个不同的数据结构，它们各自有不同的用途和特点。<p><strong>sockaddr</strong><ul><li><p><strong>定义</strong>：</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>sockaddr</span> {</span></span><br><span class=line>    <span class=keyword>sa_family_t</span> sa_family; <span class=comment>// 地址族（如AF_INET, AF_INET6）</span></span><br><span class=line>    <span class=keyword>char</span>        sa_data[<span class=number>14</span>]; <span class=comment>// 地址信息，具体格式取决于地址族</span></span><br><span class=line>};</span><br></pre></table></figure><li><p><strong>用途</strong>：</p> <ul><li>这是一个<strong>通用的套接字地址结构体</strong>，用于表示任何类型的套接字地址。它不特定于任何一种协议或地址家族。<li>它通常作为函数参数传递，以便支持多种不同类型的地址族（例如IPv4、IPv6等）。</ul><li><p><strong>局限性</strong>：</p> <ul><li>因为它的<code>sa_data</code>字段是固定大小的字符数组，所以在处理复杂或长度不定的地址信息时不够灵活。</ul></ul><p><strong>sockaddr_in</strong><ul><li><p><strong>定义</strong>：</p> <figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>sockaddr_in</span> {</span></span><br><span class=line>    <span class=keyword>sa_family_t</span>    sin_family; <span class=comment>// 地址族，必须设置为AF_INET</span></span><br><span class=line>    <span class=keyword>in_port_t</span>      sin_port;   <span class=comment>// 端口号（使用htons()转换为网络字节序）</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>in_addr</span> <span class=title>sin_addr</span>;</span>   <span class=comment>// IPv4地址</span></span><br><span class=line>    <span class=keyword>unsigned</span> <span class=keyword>char</span>  sin_zero[<span class=number>8</span>]; <span class=comment>// 填充0以使结构体大小与sockaddr相同</span></span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>in_addr</span> {</span></span><br><span class=line>    <span class=keyword>in_addr_t</span> s_addr; <span class=comment>// 32位IPv4地址（网络字节序）</span></span><br><span class=line>};</span><br></pre></table></figure><li><p><strong>用途</strong>：</p> <ul><li><strong>专门用于IPv4地址的套接字地址结构体</strong>。<li>提供了明确的字段来存储端口号和IP地址，使得处理IPv4地址更加直观和方便。</ul><li><p><strong>优点</strong>：</p> <ul><li>相较于<code>sockaddr</code>，它提供了更具体的字段，便于操作IPv4地址和端口信息。</ul></ul><p><strong>sockaddr_in6</strong><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>sockaddr_in6</span></span></span><br><span class=line><span class=class>  {</span></span><br><span class=line>    __SOCKADDR_COMMON (sin6_);</span><br><span class=line>    <span class=keyword>in_port_t</span> sin6_port;	<span class=comment>/* Transport layer port # */</span></span><br><span class=line>    <span class=keyword>uint32_t</span> sin6_flowinfo;	<span class=comment>/* IPv6 flow information */</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>in6_addr</span> <span class=title>sin6_addr</span>;</span>	<span class=comment>/* IPv6 address */</span></span><br><span class=line>    <span class=keyword>uint32_t</span> sin6_scope_id;	<span class=comment>/* IPv6 scope-id */</span></span><br><span class=line>  };</span><br></pre></table></figure><p><strong>addrinfo</strong><ul><li><p><strong>定义</strong>：</p> <figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>addrinfo</span> {</span></span><br><span class=line>    <span class=keyword>int</span>              ai_flags;     <span class=comment>// AI_PASSIVE, AI_CANONNAME, etc.</span></span><br><span class=line>    <span class=keyword>int</span>              ai_family;    <span class=comment>// AF_INET, AF_INET6, AF_UNSPEC</span></span><br><span class=line>    <span class=keyword>int</span>              ai_socktype;  <span class=comment>// SOCK_STREAM, SOCK_DGRAM</span></span><br><span class=line>    <span class=keyword>int</span>              ai_protocol;  <span class=comment>// 使用的协议</span></span><br><span class=line>    <span class=keyword>socklen_t</span>        ai_addrlen;   <span class=comment>// 地址长度</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>sockaddr</span> *<span class=title>ai_addr</span>;</span>      <span class=comment>// 地址信息</span></span><br><span class=line>    <span class=keyword>char</span>            *ai_canonname; <span class=comment>// 主机规范名称</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>addrinfo</span> *<span class=title>ai_next</span>;</span>      <span class=comment>// 下一个addrinfo结构指针</span></span><br><span class=line>};</span><br></pre></table></figure> <p><img alt=image-20250227150905975 data-src=https://s2.loli.net/2025/02/27/azvYs7B46VeOAfb.png></p><li><p><strong>用途</strong>：</p> <ul><li><code>addrinfo</code> 结构体由 <code>getaddrinfo()</code> 函数返回，旨在<strong>提供一个统一的方式来处理不同类型的地址信息（包括IPv4和IPv6），并简化了主机名和服务名解析的过程</strong>。<li>它可以包含多个结果（通过<code>ai_next</code>链表连接），允许应用程序选择最适合其需求的结果。</ul><li><p><strong>优点</strong>：</p> <ul><li>支持现代互联网中常见的IPv4和IPv6地址。<li>能够处理复杂的配置需求，如指定被动监听（AI_PASSIVE）、获取规范主机名等。<li>更加灵活和强大，适合需要跨平台兼容性和灵活性的应用程序。</ul></ul><p><strong>sockaddr_storage</strong><p><code>sockaddr_storage</code> 是一个在 <code>&LTnetinet/in.h></code> 或 <code>&LTsys/socket.h></code> 头文件中定义的数据结构，旨在提供一个足够大的缓冲区来存储任何类型的套接字地址（包括 IPv4、IPv6 等）。它解决了由于不同协议族的地址结构大小不一致所带来的问题，例如 <code>sockaddr_in</code> 和 <code>sockaddr_in6</code> 分别用于 IPv4 和 IPv6 地址，它们有不同的大小。<p><strong>定义与用途</strong><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>sockaddr_storage</span> {</span></span><br><span class=line>    <span class=keyword>sa_family_t</span> ss_family; <span class=comment>// 地址族</span></span><br><span class=line>    <span class=comment>// 其余字段未指定，实现定义以确保足够的空间和对齐</span></span><br><span class=line>};</span><br></pre></table></figure><ul><li><strong>ss_family</strong>：这是唯一标准化的字段，表示地址族（如 <code>AF_INET</code> 对应 IPv4，<code>AF_INET6</code> 对应 IPv6）。<li><strong>其他字段</strong>：这些字段的具体定义依赖于实现，主要是为了确保 <code>sockaddr_storage</code> 能够容纳所有可能的套接字地址类型，并且保持正确的内存对齐。这意味着它的大小至少要能容纳最大的套接字地址结构（比如 <code>sockaddr_in6</code>）。</ul><p><strong>主要特点</strong><ol><li><strong>统一性</strong>：通过使用 <code>sockaddr_storage</code>,可以编写更加通用的代码，避免直接处理特定于协议的地址结构（如 <code>sockaddr_in</code> 或 <code>sockaddr_in6</code>），从而提高代码的可移植性和灵活性。<li><strong>大小保证</strong>：<code>sockaddr_storage</code> 的大小被设计为足以容纳系统支持的所有套接字地址结构，这使得它可以安全地转换为任何特定的套接字地址类型。<li><strong>对齐要求</strong>：除了大小之外，<code>sockaddr_storage</code> 还满足了所有套接字地址结构的对齐要求，这对于高效访问数据至关重要。</ol><p><strong>总结</strong><ul><li><strong><code>sockaddr</code></strong>：是一个通用的套接字地址结构体，适用于所有地址族。由于其设计较为通用，实际应用中常被特定于某种地址族的结构体替代，如<code>sockaddr_in</code>。<li><strong><code>sockaddr_in</code></strong>：专用于IPv4地址，提供了对IPv4地址和端口的具体支持，易于理解和使用。<li><strong><code>addrinfo</code></strong>：提供了一个更高级别的抽象，能够处理IPv4和IPv6地址，并且支持更多的选项和灵活性。它是推荐的方式来进行现代网络编程中的地址解析和套接字创建，特别是当你需要同时支持IPv4和IPv6时。</ul><p><strong>socketpair</strong><p><code>socketpair</code> 是一个用于创建一对互联的套接字描述符的系统调用，它允许在同一主机上的两个进程之间进行双向通信。通常，这些套接字被用于父子进程间的通信，但它们也可以用于任何需要双向（全双工）通信通道的场景<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/types.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/socket.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>socketpair</span><span class=params>(<span class=keyword>int</span> domain, <span class=keyword>int</span> type, <span class=keyword>int</span> protocol, <span class=keyword>int</span> sv[<span class=number>2</span>])</span></span>;</span><br></pre></table></figure><ul><li><strong>参数</strong>：<ul><li><code>domain</code>：指定协议族，通常是 <code>AF_UNIX</code> 或 <code>AF_LOCAL</code>（本地通信），但在某些实现中也可能支持其他域如 <code>AF_INET</code>。<li><code>type</code>：指定套接字类型，常见的有 <code>SOCK_STREAM</code>（提供有序、可靠、双向的连接）和 <code>SOCK_DGRAM</code>（数据报套接字）。<li><code>protocol</code>：指定使用的协议，通常为 <code>0</code>，表示使用默认协议。<li><code>sv</code>：指向一个包含两个整数元素的数组，这两个整数将作为返回的套接字描述符。</ul><li><strong>返回值</strong>：<ul><li>成功时，返回 <code>0</code> 并在 <code>sv</code> 数组中填充两个有效的套接字描述符。<li>失败时，返回 <code>-1</code> 并设置 <code>errno</code>。</ul></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdlib.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/socket.h></span></span></span><br><span class=line></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> MSG_SIZE 1024</span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> sv[<span class=number>2</span>]; <span class=comment>// 存储两个套接字描述符</span></span><br><span class=line>    <span class=keyword>char</span> buffer[MSG_SIZE];</span><br><span class=line></span><br><span class=line>    <span class=comment>// 创建一对套接字</span></span><br><span class=line>    <span class=keyword>if</span> (<span class=built_in>socketpair</span>(AF_UNIX, SOCK_STREAM, <span class=number>0</span>, sv) == <span class=number>-1</span>) {</span><br><span class=line>        <span class=built_in>perror</span>(<span class=string>"socketpair"</span>);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>pid_t</span> pid = fork();</span><br><span class=line>    <span class=keyword>if</span> (pid == <span class=number>-1</span>) {</span><br><span class=line>        <span class=built_in>perror</span>(<span class=string>"fork"</span>);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    } <span class=keyword>else</span> <span class=keyword>if</span> (pid == <span class=number>0</span>) { <span class=comment>// 子进程</span></span><br><span class=line>        <span class=built_in>close</span>(sv[<span class=number>0</span>]); <span class=comment>// 关闭不需要的套接字端</span></span><br><span class=line>        <span class=keyword>const</span> <span class=keyword>char</span> *msg = <span class=string>"Hello from child process!"</span>;</span><br><span class=line>        <span class=built_in>write</span>(sv[<span class=number>1</span>], msg, <span class=built_in>strlen</span>(msg) + <span class=number>1</span>); <span class=comment>// 发送消息给父进程</span></span><br><span class=line>        <span class=built_in>close</span>(sv[<span class=number>1</span>]);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_SUCCESS);</span><br><span class=line>    } <span class=keyword>else</span> { <span class=comment>// 父进程</span></span><br><span class=line>        <span class=built_in>close</span>(sv[<span class=number>1</span>]); <span class=comment>// 关闭不需要的套接字端</span></span><br><span class=line>        <span class=keyword>ssize_t</span> bytes_read = <span class=built_in>read</span>(sv[<span class=number>0</span>], buffer, MSG_SIZE); <span class=comment>// 从子进程接收消息</span></span><br><span class=line>        <span class=keyword>if</span> (bytes_read > <span class=number>0</span>) {</span><br><span class=line>            <span class=built_in>printf</span>(<span class=string>"Received message from child: %s\n"</span>, buffer);</span><br><span class=line>        }</span><br><span class=line>        <span class=built_in>close</span>(sv[<span class=number>0</span>]);</span><br><span class=line>        <span class=built_in>wait</span>(<span class=literal>NULL</span>); <span class=comment>// 等待子进程结束</span></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><h3 id=地址二进制与点分十进制转换><a class=headerlink href=#地址二进制与点分十进制转换 title=地址二进制与点分十进制转换></a>地址二进制与点分十进制转换</h3><p>在网络编程中，有时需要将点分十进制表示的IPv4地址（如<code>"192.168.1.1"</code>）转换成32位无符号整数形式以便于处理或计算。在C语言中，可以使用以下函数来实现这种转换：<ul><li><strong><code>inet_addr</code></strong>: 这是一个简单的函数，用于将点分十进制格式的IPv4地址转换为网络字节序的32位长整型值。然而，<strong>它不支持IPv6，并且如果输入无效，则返回<code>INADDR_NONE</code></strong><li><strong><code>inet_aton</code></strong>: 此函数不仅将点分十进制的IPv4地址转换为二进制形式，还会检查输入的有效性。它接受一个指向<code>in_addr</code>结构的指针作为第二个参数，并在此结构中填充相应的数值。<strong>如果转换成功，返回非零值；否则返回0</strong><li><strong><code>inet_pton</code></strong>: 这是一个更为现代和推荐使用的函数，支持IPv4和IPv6地址的转换。对于IPv4，它的第二个参数是一个指向<code>struct in_addr</code>类型的指针，对于IPv6，则是指向<code>struct in6_addr</code>类型的指针<strong>。如果转换成功，返回1</strong>；如果输入格式不正确，则返回0；如果遇到系统错误，则返回-1。</ul><div class=table-container><table><thead><tr><th>特性<th><code>inet_addr</code><th><code>inet_aton</code><tbody><tr><td><strong>输入格式</strong><td>点分十进制字符串<td>点分十进制字符串<tr><td><strong>输出格式</strong><td>返回 <code>in_addr_t</code>（32 位整数）<td>填充 <code>struct in_addr</code> 结构体<tr><td><strong>错误处理</strong><td>错误时返回 <code>INADDR_NONE</code><td>错误时返回 <code>0</code><tr><td><strong>线程安全性</strong><td>安全<td>安全<tr><td><strong>推荐程度</strong><td>不推荐（已过时）<td>推荐</table></div><div class=table-container><table><thead><tr><th>函数名<th>输入格式<th>输出格式<th>支持的地址类型<th>线程安全性<tbody><tr><td><code>inet_pton</code><td>字符串<td>二进制<td>IPv4 和 IPv6<td>安全<tr><td><code>inet_aton</code><td>字符串<td>二进制<td>仅 IPv4<td>安全<tr><td><code>inet_ntop</code><td>二进制<td>字符串<td>IPv4 和 IPv6<td>安全<tr><td><code>inet_ntoa</code><td>二进制<td>字符串<td>仅 IPv4<td>不安全</table></div><h3 id=端口字节序转换><a class=headerlink href=#端口字节序转换 title=端口字节序转换></a>端口字节序转换</h3><p>在网络编程中，处理不同系统间的数据传输时，经常需要将数据在主机字节序（Host Byte Order）和网络字节序（Network Byte Order）之间进行转换。这是因为不同的计算机架构可能使用不同的字节序来存储多字节数据类型，如整数。为了确保数据在网络上传输的一致性，通常采用大端字节序（Big Endian），也被称作网络字节序<p>针对这种需求，有几组常用的函数用于在主机字节序和网络字节序之间进行转换：<ol><li><strong><code>htonl</code> 和 <code>htons</code></strong>：这两个函数分别用于将32位整型（<code>long</code>）和16位整型（<code>short</code>）从主机字节序转换为网络字节序。<ul><li><code>htonl(uint32_t hostlong)</code>: Host to Network Long<li><code>htons(uint16_t hostshort)</code>: Host to Network Short</ul><li><strong><code>ntohl</code> 和 <code>ntohs</code></strong>：与上述相反，这两个函数用于将32位和16位整型从网络字节序转换为主机字节序。<ul><li><code>ntohl(uint32_t netlong)</code>: Network to Host Long<li><code>ntohs(uint16_t netshort)</code>: Network to Host Short</ul></ol><p>为了保证网络通信的兼容性，通常采用大端字节序（Big Endian），也称为网络字节序，来表示跨网络传输的数据。<p><strong>需要转换为网络字节序的数据类型</strong><ol><li><strong>端口号</strong>：端口号通常是16位的整数，在发送之前应该从主机字节序转换为网络字节序。<li><strong>IP地址</strong>：虽然IP地址通常以字符串形式表示（例如“192.168.0.1”），但在某些情况下，你可能会处理32位整型的IPv4地址或128位的IPv6地址。对于这些情况，如果需要直接操作整型值，则应确保它们是网络字节序。<li><strong>序列号、确认号等TCP头部字段</strong>：这些字段都是32位的整数，用于TCP协议中的状态跟踪和数据流控制，因此也需要转换为网络字节序。<li><strong>其他自定义协议中的多字节字段</strong>：如果你设计了一个自定义的应用层协议，并且该协议包含多字节整数字段（如长度指示符、版本号等），那么这些字段也应该按照网络字节序进行编码。</ol><h3 id=设置套接字等选项><a class=headerlink href=#设置套接字等选项 title=设置套接字等选项></a>设置套接字等选项</h3><p><code>setsockopt</code> 是一个用于设置套接字选项的函数，它允许开发者对套接字的行为进行精细控制。通过 <code>setsockopt</code>，可以调整套接字的各种属性，例如<strong>地址复用</strong>、<strong>接收/发送缓冲区大小</strong>、超时时间等。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/types.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/socket.h></span></span></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>setsockopt</span><span class=params>(<span class=keyword>int</span> sockfd, <span class=keyword>int</span> level, <span class=keyword>int</span> optname, <span class=keyword>const</span> <span class=keyword>void</span> *optval, <span class=keyword>socklen_t</span> optlen)</span></span>;</span><br></pre></table></figure><ol><li><strong><code>sockfd</code></strong>:<ul><li>套接字描述符。<li>指定要设置选项的目标套接字。</ul><li><strong><code>level</code></strong>:<ul><li>选项所属的协议层。<li>常见值包括：<ul><li><code>SOL_SOCKET</code>: 套接字通用选项（如地址复用、广播等）。<li><code>IPPROTO_TCP</code>: TCP 协议相关选项。<li><code>IPPROTO_IP</code>: IP 协议相关选项。<li><code>IPPROTO_IPV6</code>: IPv6 相关选项。</ul></ul><li><strong><code>optname</code></strong>:<ul><li>具体的选项名称。<li>根据 <code>level</code> 的不同，可以选择不同的选项。</ul><li><strong><code>optval</code></strong>:<ul><li>指向选项值的指针。<li>选项值的具体类型和格式取决于 <code>optname</code>。</ul><li><strong><code>optlen</code></strong>:<ul><li><code>optval</code> 缓冲区的大小（以字节为单位）</ul></ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>int</span> opt = <span class=number>1</span>;</span><br><span class=line><span class=built_in>setsockopt</span>(sockfd, SOL_SOCKET, SO_REUSEADDR, &opt, <span class=built_in><span class=keyword>sizeof</span></span>(opt));</span><br></pre></table></figure><p><strong>常用选项</strong><ol><li><strong><code>SO_REUSEADDR</code></strong></ol><ul><li><strong>作用</strong>: 允许绑定到已被占用的地址和端口。<li><strong>场景</strong>: 通常用于避免因端口被占用而导致服务器无法启动的问题。</ul><p><strong>2. <code>SO_REUSEPORT</code></strong><ul><li><strong>作用</strong>: 允许多个进程或线程绑定到同一个端口。<li><strong>场景</strong>: 适用于多线程或多进程服务器模型。<li><strong>注意</strong>: 需要与 <code>SO_REUSEADDR</code> 配合使用</ul><p><strong>3. <code>SO_RCVBUF</code> 和 <code>SO_SNDBUF</code></strong><ul><li><p>作用</p> <p>:</p> <ul><li><code>SO_RCVBUF</code>: 设置接收缓冲区大小。<li><code>SO_SNDBUF</code>: 设置发送缓冲区大小。</ul></ul><p><strong>4. <code>SO_BROADCAST</code></strong><ul><li><strong>作用</strong>: 启用广播功能。<li><strong>场景</strong>: 用于 UDP 广播通信</ul><p><strong>5. <code>SO_KEEPALIVE</code></strong><ul><li><strong>作用</strong>: 启用 TCP 的保活机制。<li><strong>场景</strong>: 检测长时间空闲的连接是否仍然有效。</ul><p><strong>6. <code>SO_LINGER</code></strong><ul><li><strong>作用</strong>: 控制关闭套接字时的行为。<li><strong>场景</strong>: 当需要确保所有数据在关闭前被发送时。</ul><p><strong>7. <code>TCP_NODELAY</code></strong><ul><li><strong>作用</strong>: 禁用 Nagle 算法，减少小数据包的延迟。<li><strong>场景</strong>: 对于实时性要求较高的应用（如在线游戏、实时聊天）。</ul><h3 id=设置文件描述符选项><a class=headerlink href=#设置文件描述符选项 title=设置文件描述符选项></a>设置文件描述符选项</h3><p>函数原型<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTfcntl.h></span></span></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>fcntl</span><span class=params>(<span class=keyword>int</span> fd, <span class=keyword>int</span> cmd, ... <span class=comment>/* arg */</span> )</span></span>;</span><br></pre></table></figure><ul><li><p><strong><code>fd</code></strong>：目标文件描述符。</p><li><p><code>cmd</code></p> <p>：指定要执行的操作类型，常见的命令包括：</p> <ul><li><strong><code>F_GETFL</code></strong>：获取文件描述符的状态标志。<li><strong><code>F_SETFL</code></strong>：设置文件描述符的状态标志。<li><strong><code>F_GETFD</code></strong>：获取文件描述符的文件描述符标志。<li><strong><code>F_SETFD</code></strong>：设置文件描述符的文件描述符标志。<li><strong><code>F_DUPFD</code></strong>：复制文件描述符。<li><strong><code>F_DUPFD_CLOEXEC</code></strong>：复制文件描述符并设置 <code>FD_CLOEXEC</code> 标志。</ul><li><p><strong><code>arg</code></strong>：可选参数，具体取决于 <code>cmd</code> 的值。例如，在使用 <code>F_SETFL</code> 时，<code>arg</code> 是新的状态标志</p></ul><p>在网络编程中，将套接字设置为非阻塞模式是一种常见的优化手段。非阻塞模式允许在尝试读取或写入数据时立即返回，而不会阻塞进程。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTfcntl.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line></span><br><span class=line><span class=comment>// 将文件描述符设置为非阻塞模式</span></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>set_nonblocking</span><span class=params>(<span class=keyword>int</span> fd)</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> flags = <span class=built_in>fcntl</span>(fd, F_GETFL, <span class=number>0</span>); <span class=comment>// 获取当前文件描述符的标志</span></span><br><span class=line>    <span class=keyword>if</span> (flags == <span class=number>-1</span>) {</span><br><span class=line>        <span class=built_in>perror</span>(<span class=string>"fcntl F_GETFL failed"</span>);</span><br><span class=line>        <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 添加 O_NONBLOCK 标志</span></span><br><span class=line>    <span class=keyword>if</span> (<span class=built_in>fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK) == <span class=number>-1</span>) {</span><br><span class=line>        <span class=built_in>perror</span>(<span class=string>"fcntl F_SETFL failed"</span>);</span><br><span class=line>        <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>在非阻塞模式下：<ul><li>如果没有数据可读，<code>read()</code> 或 <code>recv()</code> 会立即返回 <code>-1</code>，并设置 <code>errno</code> 为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。<li>如果无法立即写入数据，<code>write()</code> 或 <code>send()</code> 也会返回 <code>-1</code>，并设置 <code>errno</code> 为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</ul><p>文件状态标志可以通过 <code>fcntl(fd, F_GETFL)</code> 获取当前设置，并通过 <code>fcntl(fd, F_SETFL, flags)</code> 修改。<ul><li><strong><code>O_RDONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code></strong>：打开文件的模式（只读、只写、读写），通常在打开文件时确定，不能通过 <code>F_SETFL</code> 修改。<li><strong><code>O_APPEND</code></strong>：每次写入时将数据追加到文件末尾。<li><strong><code>O_NONBLOCK</code></strong>：设置非阻塞模式。对于文件或设备，这意味着尝试的操作（如读取或写入）如果无法立即完成，则会立即返回而不是阻塞等待。在网络编程中，这通常用于套接字以实现异步I/O。<li><strong><code>O_ASYNC</code></strong>：当I/O可用时发送信号（通常是 <code>SIGIO</code>）给进程。此功能允许进程异步地处理I/O事件。<li><strong><code>O_DSYNC</code> 和 <code>O_SYNC</code></strong>：要求同步写入。<code>O_DSYNC</code> 确保数据同步写入磁盘，而 <code>O_SYNC</code> 还包括文件元数据的同步写入。</ul><blockquote><p>在 TCP 套接字中，<code>read()</code> 和 <code>recv()</code> 都无法保证一次调用就能读取完整的数据包。可能需要循环读取，直到接收到完整的数据。<p>如果套接字是非阻塞模式，且没有数据可读，<code>read()</code> 会立即返回 <code>-1</code>，并设置 <code>errno</code> 为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。<ul><li>如果套接字是阻塞模式，且没有数据可读，<code>read()</code> 会阻塞，直到有数据到达或发生错误。<li><code>read()</code> 不区分消息边界（特别是在 TCP 套接字中）。它只是简单地从流中读取尽可能多的数据。</ul><p><strong>非阻塞模式</strong><ul><li>在非阻塞模式下，如果没有数据可读，<code>read()</code> 和 <code>recv()</code> 都会立即返回 <code>-1</code>，并设置 <code>errno</code> 为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。<li>在这种情况下，通常需要结合事件通知机制（如 <code>select()</code>、<code>poll()</code> 或 <code>epoll()</code>）来监听可读事件。</ul><p><strong>错误处理</strong><ul><li>处理 <code>EINTR</code>（信号中断）：如果 <code>read()</code> 或 <code>recv()</code> 返回 <code>-1</code> 并且 <code>errno</code> 为 <code>EINTR</code>，通常需要重试。<li>处理 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>：说明当前没有更多数据可读，等待下次事件通知即可。</ul></blockquote><h2 id=信号机制><a class=headerlink href=#信号机制 title=信号机制></a>信号机制</h2><p>信号是操作系统向进程发送的一种异步通知机制，用于告知进程某个事件已经发生。信号可以被视为一种软件中断，它会打断进程的正常执行流程。<h3 id=signal><a class=headerlink href=#signal title=signal></a>signal</h3><p><strong><code>signal()</code> 函数</strong><p>这是最基本的信号处理函数，用于设置对指定信号的处理方式。然而，它不如 <code>sigaction</code> 灵活和可靠。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsignal.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>typedef</span> <span class=title>void</span> <span class=params>(*<span class=keyword>sighandler_t</span>)</span><span class=params>(<span class=keyword>int</span>)</span></span>;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>sighandler_t</span> <span class=title>signal</span><span class=params>(<span class=keyword>int</span> signum, <span class=keyword>sighandler_t</span> handler)</span></span>;</span><br></pre></table></figure><ul><li><code>signum</code>：要捕获或忽略的信号编号。<li><code>handler</code>：信号处理函数指针，或者 <code>SIG_DFL</code>（默认处理）、<code>SIG_IGN</code>（忽略）。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdlib.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsignal.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>handle_sigint</span><span class=params>(<span class=keyword>int</span> sig)</span> </span>{</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Caught signal %d\n"</span>, sig);</span><br><span class=line>    <span class=built_in>exit</span>(<span class=number>0</span>);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=comment>// 设置 SIGINT (Ctrl+C) 的处理程序</span></span><br><span class=line>    <span class=keyword>if</span> (<span class=built_in>signal</span>(SIGINT, handle_sigint) == SIG_ERR) {</span><br><span class=line>        <span class=built_in>fprintf</span>(stderr, <span class=string>"Unable to set handler for SIGINT\n"</span>);</span><br><span class=line>        <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>while</span>(<span class=number>1</span>) {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Process running...\n"</span>);</span><br><span class=line>        <span class=built_in>sleep</span>(<span class=number>1</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>Linux 定义了许多标准信号，例如：<ul><li><code>SIGINT</code>（2）：由用户按下 <code>Ctrl+C</code> 触发，通常用于终止进程。<li><code>SIGTERM</code>（15）：请求终止进程的信号。<li><code>SIGKILL</code>（9）：强制终止进程的信号，无法被捕获或忽略。<li><code>SIGSEGV</code>（11）：段错误（访问非法内存地址）。<li><code>SIGCHLD</code>（17）：子进程状态改变时发送给父进程的信号。<li><code>SIGUSR1</code> 和 <code>SIGUSR2</code>：用户自定义信号。</ul><p>信号可以通过以下几种方式触发：<p><strong>(1) 用户输入</strong><ul><li>按下 <code>Ctrl+C</code> 会向当前前台进程发送 <code>SIGINT</code> 信号。<li>按下 <code>Ctrl+\</code> 会向当前前台进程发送 <code>SIGQUIT</code> 信号。</ul><p><strong>(2) 系统调用</strong><p>通过系统调用 <code>kill</code> 或 <code>raise</code> 可以向进程发送信号：<ul><li><code>kill(pid_t pid, int sig)</code>：向指定进程 ID 的进程发送信号。<li><code>raise(int sig)</code>：向当前进程自身发送信号。</ul><p><strong>(3) 硬件异常</strong><p>当进程访问非法内存地址时，操作系统会发送 <code>SIGSEGV</code> 信号；当进行非法指令操作时，可能会发送 <code>SIGILL</code> 信号。<p><strong>(4) 软件触发</strong><p>通过调用 <code>alarm</code> 函数可以设置定时器，超时时会向进程发送 <code>SIGALRM</code> 信号。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsignal.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>handler</span><span class=params>(<span class=keyword>int</span> sig)</span> </span>{</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Received signal: %d\n"</span>, sig);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=built_in>signal</span>(SIGALRM, handler); <span class=comment>// 注册信号处理函数</span></span><br><span class=line>    <span class=built_in>alarm</span>(<span class=number>3</span>); <span class=comment>// 设置 3 秒后发送 SIGALRM 信号</span></span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Waiting for the alarm signal...\n"</span>);</span><br><span class=line>    <span class=built_in>pause</span>(); <span class=comment>// 挂起进程，等待信号</span></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><h3 id=sigaction><a class=headerlink href=#sigaction title=sigaction></a>sigaction</h3><p><code>sigaction</code> 是 POSIX 标准定义的一种机制，用于定义进程对特定信号的响应行为。它提供了一种比 <code>signal()</code> 更加灵活和强大的方式来处理信号。<code>sigaction</code> 结构体用于指定如何处理信号、信号处理程序的属性以及信号掩码等信息。<p><code>sigaction</code> 提供了比 <code>signal()</code> 更加精细和强大的信号处理功能。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsignal.h></span></span></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>sigaction</span><span class=params>(<span class=keyword>int</span> signum, <span class=keyword>const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br></pre></table></figure><ul><li>参数：<ul><li><code>signum</code>：信号编号。<li><code>act</code>：指向包含新动作的 <code>struct sigaction</code> 结构体的指针。<li><code>oldact</code>：如果非空，则保存旧的动作。</ul></ul><p><strong><code>struct sigaction</code> 结构体</strong><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>sigaction</span> {</span></span><br><span class=line>    <span class=built_in><span class=keyword>void</span></span>     (*sa_handler)(<span class=keyword>int</span>);             <span class=comment>// 信号处理函数</span></span><br><span class=line>    <span class=built_in><span class=keyword>void</span></span>     (*sa_sigaction)(<span class=keyword>int</span>, <span class=keyword>siginfo_t</span> *, <span class=keyword>void</span> *); <span class=comment>// 用于带有附加信息的信号处理函数</span></span><br><span class=line>    <span class=keyword>sigset_t</span>   sa_mask;                       <span class=comment>// 在执行信号处理器期间需要阻塞的信号集合</span></span><br><span class=line>    <span class=keyword>int</span>        sa_flags;                      <span class=comment>// 控制信号处理的行为标志</span></span><br><span class=line>    <span class=built_in><span class=keyword>void</span></span>     (*sa_restorer)(<span class=keyword>void</span>);           <span class=comment>// 已废弃，不应使用</span></span><br><span class=line>};</span><br></pre></table></figure><p><code>sigaction</code> 结构体用于指定如何处理信号、信号处理程序的属性以及信号掩码等信息。<p><strong>字段说明</strong><ul><li><strong><code>sa_handler</code></strong>：<ul><li>这是一个指向信号处理函数的指针，或者可以设置为 <code>SIG_DFL</code>（默认信号处理）或 <code>SIG_IGN</code>（忽略信号）。</ul><li><strong><code>sa_sigaction</code></strong>：<ul><li>当 <code>sa_flags</code> 中设置了 <code>SA_SIGINFO</code> 标志时，此字段将作为信号处理函数使用。与 <code>sa_handler</code> 不同，<code>sa_sigaction</code> 可以接收更多信息，包括一个指向 <code>siginfo_t</code> 结构的指针（包含有关信号的详细信息）和一个指向处理器上下文的指针（通常不使用）。</ul><li><strong><code>sa_mask</code></strong>：<ul><li>定义了一个信号集，在调用信号处理程序之前，这些信号会被加入到当前的信号屏蔽字中。这意味着在执行信号处理程序期间，这些信号会被暂时阻塞。</ul><li><strong><code>sa_flags</code></strong>：<ul><li>控制信号处理的行为。常见的标志包括：<ul><li><strong><code>SA_RESTART</code></strong>：如果信号中断了某个系统调用，则自动重启该系统调用（而不是返回错误）。<li><strong><code>SA_NOCLDSTOP</code></strong>：仅对 <code>SIGCHLD</code> 信号有效，如果设置了此标志，则子进程停止或恢复时不会发送 <code>SIGCHLD</code> 信号给父进程。<li><strong><code>SA_NOCLDWAIT</code></strong>：仅对 <code>SIGCHLD</code> 信号有效，阻止创建僵尸进程。<li><strong><code>SA_SIGINFO</code></strong>：指示使用 <code>sa_sigaction</code> 字段中的信号处理函数，而非 <code>sa_handler</code>。这允许访问扩展的信号信息。</ul></ul><li><strong><code>sa_restorer</code></strong>：<ul><li>这个字段已废弃，不应该被使用。</ul></ul><p><strong>使用示例</strong><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdlib.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsignal.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>handler</span><span class=params>(<span class=keyword>int</span> signum, <span class=keyword>siginfo_t</span> *info, <span class=keyword>void</span> *context)</span> </span>{</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Caught signal %d\n"</span>, signum);</span><br><span class=line>    <span class=comment>// 打印更多关于信号的信息</span></span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Signal code: %d\n"</span>, info->si_code);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>sigaction</span> <span class=title>act</span>;</span></span><br><span class=line></span><br><span class=line>    <span class=comment>// 初始化结构体</span></span><br><span class=line>    act.sa_sigaction = handler;</span><br><span class=line>    act.sa_flags = SA_SIGINFO; <span class=comment>// 使用带有额外参数的信号处理函数</span></span><br><span class=line></span><br><span class=line>    <span class=comment>// 填充信号掩码，这里我们不限制任何额外的信号</span></span><br><span class=line>    <span class=built_in>sigemptyset</span>(&act.sa_mask);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 设置 SIGINT 的信号处理程序</span></span><br><span class=line>    <span class=keyword>if</span> (<span class=built_in>sigaction</span>(SIGINT, &act, <span class=literal>NULL</span>) == <span class=number>-1</span>) {</span><br><span class=line>        <span class=built_in>perror</span>(<span class=string>"sigaction"</span>);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Waiting for SIGINT (Ctrl+C)...\n"</span>);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 挂起进程，等待信号</span></span><br><span class=line>    <span class=keyword>while</span> (<span class=number>1</span>) {</span><br><span class=line>        <span class=built_in>pause</span>(); <span class=comment>// 等待信号</span></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><h2 id=stat><a class=headerlink href=#stat title=stat></a>stat</h2><p><code>stat</code> 函数是 Unix 和类 Unix 操作系统（如 Linux）中的一个系统调用，用于获取文件或文件系统对象的相关信息。它通过填充一个 <code>struct stat</code> 结构体来提供文件的元数据，包括文件大小、权限、创建时间等<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/types.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/stat.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>stat</span><span class=params>(<span class=keyword>const</span> <span class=keyword>char</span> *pathname, struct stat *statbuf)</span></span>;</span><br></pre></table></figure><ul><li><strong>参数</strong>：<ul><li><code>pathname</code>：要查询的文件或目录的路径。<li><code>statbuf</code>：指向一个 <code>struct stat</code> 结构体的指针，该结构体将被用来存储文件的状态信息。</ul><li><strong>返回值</strong>：<ul><li>成功时返回 <code>0</code>。<li>失败时返回 <code>-1</code> 并设置 <code>errno</code> 来指示错误类型。</ul></ul><p>除了 <code>stat</code>，还有其他几个类似的函数可以用于不同的场景：<ul><li><p><strong><code>fstat</code></strong>：与 <code>stat</code> 类似，但它接受一个文件描述符而不是路径名作为第一个参数。</p> <figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>fstat</span><span class=params>(<span class=keyword>int</span> fd, struct stat *statbuf)</span></span>;</span><br></pre></table></figure><li><p><strong><code>lstat</code></strong>：与 <code>stat</code> 类似，但如果目标是一个符号链接（symlink），它会返回符号链接本身的信息，而不是它指向的目标文件的信息。</p> <figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>lstat</span><span class=params>(<span class=keyword>const</span> <span class=keyword>char</span> *pathname, struct stat *statbuf)</span></span>;</span><br></pre></table></figure></ul><p><code>struct stat</code> 包含了大量的关于文件的信息。以下是一些常用的字段：<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>stat</span> {</span></span><br><span class=line>    <span class=keyword>dev_t</span>     st_dev;         <span class=comment>// 文件所在设备的标识符</span></span><br><span class=line>    <span class=keyword>ino_t</span>     st_ino;         <span class=comment>// inode 编号</span></span><br><span class=line>    <span class=keyword>mode_t</span>    st_mode;        <span class=comment>// 文件类型和访问权限</span></span><br><span class=line>    <span class=keyword>nlink_t</span>   st_nlink;       <span class=comment>// 硬链接数量</span></span><br><span class=line>    <span class=keyword>uid_t</span>     st_uid;         <span class=comment>// 文件所有者的用户 ID</span></span><br><span class=line>    <span class=keyword>gid_t</span>     st_gid;         <span class=comment>// 文件所有者的组 ID</span></span><br><span class=line>    <span class=keyword>dev_t</span>     st_rdev;        <span class=comment>// 如果文件是一个设备文件，则为其设备编号</span></span><br><span class=line>    <span class=keyword>off_t</span>     st_size;        <span class=comment>// 文件大小（字节数）</span></span><br><span class=line>    <span class=keyword>blksize_t</span> st_blksize;     <span class=comment>// 文件系统的 I/O 块大小</span></span><br><span class=line>    <span class=keyword>blkcnt_t</span>  st_blocks;      <span class=comment>// 分配给文件的块数</span></span><br><span class=line>    <span class=keyword>time_t</span>    st_atime;       <span class=comment>// 最后访问时间</span></span><br><span class=line>    <span class=keyword>time_t</span>    st_mtime;       <span class=comment>// 最后修改时间</span></span><br><span class=line>    <span class=keyword>time_t</span>    st_ctime;       <span class=comment>// 最后状态改变时间（在 Unix 中通常为元数据更改时间）</span></span><br><span class=line>};</span><br></pre></table></figure><p>在 <code>struct stat</code> 的 <code>st_mode</code> 字段中，文件类型和权限信息被编码在一起。可以通过位操作提取这些信息：<ul><li><strong>文件类型</strong>：<ul><li><code>S_IFMT</code>：文件类型的掩码。<li><code>S_IFDIR</code>：目录。<li><code>S_IFCHR</code>：字符设备。<li><code>S_IFBLK</code>：块设备。<li><code>S_IFREG</code>：普通文件。<li><code>S_IFIFO</code>：命名管道（FIFO）。<li><code>S_IFLNK</code>：符号链接。<li><code>S_IFSOCK</code>：套接字。</ul><li><strong>权限</strong>：<ul><li><code>S_IRUSR</code>, <code>S_IWUSR</code>, <code>S_IXUSR</code>：用户（拥有者）的读、写、执行权限。<li><code>S_IRGRP</code>, <code>S_IWGRP</code>, <code>S_IXGRP</code>：组的读、写、执行权限。<li><code>S_IROTH</code>, <code>S_IWOTH</code>, <code>S_IXOTH</code>：其他人的读、写、执行权限。</ul></ul><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>if</span> ((sb.st_mode & S_IFMT) == S_IFREG && (sb.st_mode & S_IRUSR)) {</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"This is a regular file with read permission for the owner.\n"</span>);</span><br><span class=line>}</span><br></pre></table></figure><h2 id=mmap><a class=headerlink href=#mmap title=mmap></a>mmap</h2><p><code>mmap</code> 是 Unix 和类 Unix 系统（如 Linux）中的一个系统调用，用于<strong>将文件或设备的内存映射到进程的地址空间</strong>。这种机制允许程序以类似于访问内存的方式访问文件内容，从而简化了文件操作，并且可以提高性能，特别是在处理大文件时。<ul><li><strong>文件映射</strong>：将文件的内容映射到进程的虚拟内存中，使得可以通过指针直接访问文件的数据，而不需要通过常规的文件 I/O 操作（如 <code>read</code> 和 <code>write</code>）。<li><strong>共享内存</strong>：允许多个进程共享同一块内存区域，实现高效的进程间通信（IPC）。<li><strong>匿名映射</strong>：创建不与任何文件关联的内存映射，适用于需要动态分配大块内存的情况</ul><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/mman.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> *<span class=title>mmap</span><span class=params>(<span class=keyword>void</span> *addr, <span class=keyword>size_t</span> length, <span class=keyword>int</span> prot, <span class=keyword>int</span> flags, <span class=keyword>int</span> fd, <span class=keyword>off_t</span> offset)</span></span>;</span><br></pre></table></figure><ul><li><strong>参数</strong>：<ul><li><code>addr</code>：建议的映射起始地址（通常设为 <code>NULL</code>，让系统选择合适的地址）。<li><code>length</code>：映射区域的大小（字节数）。<li>prot：指定映射区域的保护标志（如可读、可写、可执行等）。<ul><li><code>PROT_READ</code>：映射区域可读。<li><code>PROT_WRITE</code>：映射区域可写。<li><code>PROT_EXEC</code>：映射区域可执行。</ul><li>flags：控制映射区域的行为。<ul><li><code>MAP_SHARED</code>：映射区域会被多个进程共享，修改会反映到文件中。<li><code>MAP_PRIVATE</code>：创建私有副本，修改不会影响原文件。<li><code>MAP_ANONYMOUS</code>：映射匿名内存（不与文件关联）。</ul><li><code>fd</code>：要映射的文件描述符（对于匿名映射，应设置为 <code>-1</code>）。<li><code>offset</code>：从文件开头开始的偏移量（必须是页面大小的倍数）。</ul><li><p><strong>返回值</strong>：</p> <ul><li>成功时返回指向映射区域的指针。<li>失败时返回 <code>MAP_FAILED</code>（通常定义为 <code>(void *) -1</code>），并设置 <code>errno</code>。</ul><li><p><strong><code>munmap</code></strong>：解除内存映射。</p> <figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>munmap</span><span class=params>(<span class=keyword>void</span> *addr, <span class=keyword>size_t</span> length)</span></span>;</span><br></pre></table></figure><li><p><strong><code>msync</code></strong>：同步内存映射区域到文件或设备。</p> <figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>msync</span><span class=params>(<span class=keyword>void</span> *addr, <span class=keyword>size_t</span> length, <span class=keyword>int</span> flags)</span></span>;</span><br></pre></table></figure></ul><h2 id=解析传入参数><a class=headerlink href=#解析传入参数 title=解析传入参数></a>解析传入参数</h2><p>Linux中<code>getopt</code> 是一个用于解析命令行选项的标准 C 库函数。它使得程序能够处理以短格式（如 <code>-a</code>, <code>-b value</code>）提供的命令行参数。<code>getopt</code> 函数及其扩展版本 <code>getopt_long</code> 为开发者提供了便捷的方式来解析和处理命令行选项。<h4 id=get-opt函数><a class=headerlink href=#get-opt函数 title=get_opt函数></a>get_opt函数</h4><figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>getopt</span><span class=params>(<span class=keyword>int</span> argc, <span class=keyword>char</span> * <span class=keyword>const</span> argv[], <span class=keyword>const</span> <span class=keyword>char</span> *optstring)</span></span>;</span><br></pre></table></figure><ul><li><p><strong>参数</strong>：</p> <ul><li><code>argc</code> 和 <code>argv</code>：分别是从 <code>main</code> 函数传递过来的参数计数和参数数组。<li><code>optstring</code>：包含程序所支持的选项字符组成的字符串。如果某个选项需要参数，则在该选项字符后加上冒号（<code>:</code>），表示该选项需要一个值。</ul><li><p><strong>返回值</strong>：</p> <ul><li>成功时，返回下一个选项字符。<li>当所有选项都已处理完毕，返回 <code>-1</code>。<li>如果遇到无效选项或缺少必需的参数，返回 <code>?</code> 并设置 <code>optopt</code> 变量为无效选项字符。</ul><li><p><strong>全局变量</strong>：</p> <ul><li><code>optind</code>：指向下一个要处理的 <code>argv</code> 元素的索引。<li><code>optarg</code>：<strong>指向当前选项的参数</strong>（如果有）。<li><code>opterr</code>：控制 <code>getopt</code> 是否打印错误消息，默认为 1（开启）。<li><code>optopt</code>：存储无效选项字符或缺失参数的选项字符。</ul> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>(<span class=keyword>int</span> argc, <span class=keyword>char</span> *argv[])</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> opt;</span><br><span class=line>    <span class=keyword>while</span> ((opt = <span class=built_in>getopt</span>(argc, argv, <span class=string>"ab:c"</span>)) != <span class=number>-1</span>) {</span><br><span class=line>        <span class=built_in><span class=keyword>switch</span></span> (opt) {</span><br><span class=line>            <span class=keyword>case</span> <span class=string>'a'</span>:</span><br><span class=line>                <span class=built_in>printf</span>(<span class=string>"Option -a\n"</span>);</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            <span class=keyword>case</span> <span class=string>'b'</span>:</span><br><span class=line>                <span class=built_in>printf</span>(<span class=string>"Option -b with value %s\n"</span>, optarg);</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            <span class=keyword>case</span> <span class=string>'c'</span>:</span><br><span class=line>                <span class=built_in>printf</span>(<span class=string>"Option -c\n"</span>);</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            <span class=keyword>case</span> <span class=string>'?'</span>:</span><br><span class=line>                <span class=keyword>if</span> (optopt == <span class=string>'b'</span>) {</span><br><span class=line>                    <span class=built_in>fprintf</span>(stderr, <span class=string>"Option -b requires an argument.\n"</span>);</span><br><span class=line>                } <span class=keyword>else</span> {</span><br><span class=line>                    <span class=built_in>fprintf</span>(stderr, <span class=string>"Unknown option character `\\x%x'.\n"</span>, optopt);</span><br><span class=line>                }</span><br><span class=line>                <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>            <span class=keyword>default</span>:</span><br><span class=line>                <span class=built_in>abort</span>();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 处理非选项参数</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> index = optind; index < argc; index++) {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Non-option argument: %s\n"</span>, argv[index]);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure></ul><h4 id=getopt-long-函数><a title="getopt_long 函数" class=headerlink href=#getopt-long-函数></a><code>getopt_long</code> 函数</h4><p>对于支持长格式选项（如 <code>--option</code>, <code>--option=value</code>）的应用程序，可以使用 <code>getopt_long</code> 函数。<h4 id=函数原型><a class=headerlink href=#函数原型 title=函数原型></a><strong>函数原型</strong></h4><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTgetopt.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>getopt_long</span><span class=params>(<span class=keyword>int</span> argc, <span class=keyword>char</span> * <span class=keyword>const</span> argv[], <span class=keyword>const</span> <span class=keyword>char</span> *shortopts, <span class=keyword>const</span> struct option *longopts, <span class=keyword>int</span> *longindex)</span></span>;</span><br></pre></table></figure><ul><li><p><strong>参数</strong>：</p> <ul><li><p><code>shortopts</code>：与 <code>getopt</code> 相同，定义短格式选项。</p><li><p>longopts指向描述长格式选项的struct option</p> <figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>option</span> {</span></span><br><span class=line>    <span class=keyword>const</span> <span class=keyword>char</span> *name;    <span class=comment>// 长格式选项名</span></span><br><span class=line>    <span class=keyword>int</span>         has_arg; <span class=comment>// 是否需要参数，可能值：no_argument, required_argument, optional_argument</span></span><br><span class=line>    <span class=keyword>int</span>        *flag;    <span class=comment>// 若不为 NULL，函数将此指针指向的变量设为 val；若为 NULL，函数返回 val</span></span><br><span class=line>    <span class=keyword>int</span>         val;     <span class=comment>// 返回给 `getopt_long` 的值或设置到 `flag` 指向的变量中</span></span><br><span class=line>};</span><br></pre></table></figure><li><p><code>longindex</code>：如果非 <code>NULL</code>，则指向一个变量，该变量接收匹配的长选项在 <code>longopts</code> 数组中的索引。</p></ul><li><p><strong>返回值</strong>：</p> <ul><li>成功时，返回匹配选项的字符（对于短选项）或 <code>val</code> 字段的值（对于长选项）。<li>当所有选项都已处理完毕，返回 <code>-1</code>。<li>对于无效选项或缺少必需的参数，返回 <code>?</code>。</ul><li><p><strong><code>getopt</code></strong>：适用于处理短格式选项的简单场景。通过指定一个选项字符串来定义允许的选项及是否需要参数。</p><li><strong><code>getopt_long</code></strong>：扩展了 <code>getopt</code>，支持长格式选项，并允许更灵活地配置每个选项的行为（是否需要参数、如何处理等）。</ul><h2 id=分散-聚集IO><a class=headerlink href=#分散-聚集IO title=分散/聚集IO></a>分散/聚集IO</h2><p>分散/聚集 I/O（Scatter/Gather I/O）是一种<strong>允许在单次系统调用中处理多个数据缓冲区的技术</strong>。它特别适用于需要处理多个不连续的数据块的应用场景，如网络通信、数据库操作等。通过分散/聚集 I/O，可以减少系统调用的次数，提高性能和效率。<h4 id=分散-I-O（Scatter-I-O）><a title="分散 I/O（Scatter I/O）" class=headerlink href=#分散-I-O（Scatter-I-O）></a>分散 I/O（Scatter I/O）</h4><p>分散读取（Scatter Read）指的是从一个输入源（例如文件或套接字）读取数据，并将这些数据分散到多个缓冲区中。这种技术通常用于接收长度未知的数据流，并将其分割成多个部分存储在不同的缓冲区中。<h4 id=聚集-I-O（Gather-I-O）><a title="聚集 I/O（Gather I/O）" class=headerlink href=#聚集-I-O（Gather-I-O）></a>聚集 I/O（Gather I/O）</h4><p>聚集写入（Gather Write）则是指将多个缓冲区中的数据收集起来，然后一次性写入到输出目标（例如文件或套接字）。这种方法可以简化编程模型，并且通过减少系统调用的数量来提高性能。<p>在 Unix 和类 Unix 系统（如 Linux）中，分散/聚集 I/O 主要通过 <code>readv</code> 和 <code>writev</code> 系统调用来实现。<p><strong><code>readv</code> 和 <code>writev</code> 函数</strong><ul><li><strong><code>readv</code></strong>：从文件描述符读取数据并分散到多个缓冲区。<li><strong><code>writev</code></strong>：从多个缓冲区收集数据并写入到文件描述符。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>iovec</span> {</span></span><br><span class=line>    <span class=keyword>void</span>  *iov_base;    <span class=comment>// 指向缓冲区的指针</span></span><br><span class=line>    <span class=keyword>size_t</span> iov_len;     <span class=comment>// 缓冲区长度（字节数）</span></span><br><span class=line>};</span><br></pre></table></figure><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTfcntl.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/uio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> fd = <span class=built_in>open</span>(<span class=string>"example.txt"</span>, O_RDONLY);</span><br><span class=line>    <span class=keyword>if</span> (fd == <span class=number>-1</span>) {</span><br><span class=line>        <span class=built_in>perror</span>(<span class=string>"open"</span>);</span><br><span class=line>        <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>char</span> buf1[<span class=number>6</span>]; <span class=comment>// 存储 "Hello,"</span></span><br><span class=line>    <span class=keyword>char</span> buf2[<span class=number>8</span>]; <span class=comment>// 存储 " World!\n"</span></span><br><span class=line>    </span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>iovec</span> <span class=title>iov</span>[2];</span></span><br><span class=line>    iov[<span class=number>0</span>].iov_base = buf1;</span><br><span class=line>    iov[<span class=number>0</span>].iov_len = <span class=built_in><span class=keyword>sizeof</span></span>(buf1);</span><br><span class=line>    iov[<span class=number>1</span>].iov_base = buf2;</span><br><span class=line>    iov[<span class=number>1</span>].iov_len = <span class=built_in><span class=keyword>sizeof</span></span>(buf2);</span><br><span class=line></span><br><span class=line>    <span class=keyword>ssize_t</span> read_bytes = <span class=built_in>readv</span>(fd, iov, <span class=number>2</span>);</span><br><span class=line>    <span class=keyword>if</span> (read_bytes == <span class=number>-1</span>) {</span><br><span class=line>        <span class=built_in>perror</span>(<span class=string>"readv"</span>);</span><br><span class=line>        <span class=built_in>close</span>(fd);</span><br><span class=line>        <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    buf1[<span class=built_in><span class=keyword>sizeof</span></span>(buf1)<span class=number>-1</span>] = <span class=string>'\0'</span>; <span class=comment>// 确保 buf1 是以 null 结尾的字符串</span></span><br><span class=line>    buf2[<span class=built_in><span class=keyword>sizeof</span></span>(buf2)<span class=number>-1</span>] = <span class=string>'\0'</span>; <span class=comment>// 确保 buf2 是以 null 结尾的字符串</span></span><br><span class=line></span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Read %zd bytes: '%s' and '%s'\n"</span>, read_bytes, buf1, buf2);</span><br><span class=line></span><br><span class=line>    <span class=built_in>close</span>(fd);</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><h2 id=TCP流程><a class=headerlink href=#TCP流程 title=TCP流程></a>TCP流程</h2><p><strong>TCP Server</strong><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdlib.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTarpa/inet.h></span></span></span><br><span class=line></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> PORT 8080</span></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> BUFFER_SIZE 1024</span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> server_fd, new_socket;</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>sockaddr_in</span> <span class=title>address</span>;</span></span><br><span class=line>    <span class=keyword>int</span> addrlen = <span class=keyword>sizeof</span>(address);</span><br><span class=line>    <span class=keyword>char</span> buffer[BUFFER_SIZE] = {<span class=number>0</span>};</span><br><span class=line>    <span class=keyword>const</span> <span class=keyword>char</span> *response = <span class=string>"Hello from server"</span>;</span><br><span class=line></span><br><span class=line>    <span class=comment>// 创建套接字</span></span><br><span class=line>    <span class=keyword>if</span> ((server_fd = socket(AF_INET, SOCK_STREAM, <span class=number>0</span>)) == <span class=number>0</span>) {</span><br><span class=line>        perror(<span class=string>"Socket creation failed"</span>);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 绑定地址和端口</span></span><br><span class=line>    address.sin_family = AF_INET;</span><br><span class=line>    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class=line>    address.sin_port = htons(PORT);</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (bind(server_fd, (struct sockaddr *)&address, <span class=keyword>sizeof</span>(address)) < <span class=number>0</span>) {</span><br><span class=line>        perror(<span class=string>"Bind failed"</span>);</span><br><span class=line>        close(server_fd);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 监听连接</span></span><br><span class=line>    <span class=keyword>if</span> (listen(server_fd, <span class=number>3</span>) < <span class=number>0</span>) {</span><br><span class=line>        perror(<span class=string>"Listen failed"</span>);</span><br><span class=line>        close(server_fd);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Server is listening on port %d...\n"</span>, PORT);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 接受客户端连接</span></span><br><span class=line>    <span class=keyword>if</span> ((new_socket = accept(server_fd, (struct sockaddr *)&address, (<span class=keyword>socklen_t</span> *)&addrlen)) < <span class=number>0</span>) {</span><br><span class=line>        perror(<span class=string>"Accept failed"</span>);</span><br><span class=line>        close(server_fd);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 读取客户端数据</span></span><br><span class=line>    <span class=keyword>int</span> valread = read(new_socket, buffer, BUFFER_SIZE);</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Client: %s\n"</span>, buffer);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 发送响应</span></span><br><span class=line>    send(new_socket, response, <span class=built_in>strlen</span>(response), <span class=number>0</span>);</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Response sent to client.\n"</span>);</span><br><span class=line></span><br><span class=line>    close(new_socket);</span><br><span class=line>    close(server_fd);</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><p><strong>TCP Client</strong><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdlib.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTarpa/inet.h></span></span></span><br><span class=line></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> PORT 8080</span></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> BUFFER_SIZE 1024</span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> sock = <span class=number>0</span>;</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>sockaddr_in</span> <span class=title>serv_addr</span>;</span></span><br><span class=line>    <span class=keyword>char</span> buffer[BUFFER_SIZE] = {<span class=number>0</span>};</span><br><span class=line>    <span class=keyword>const</span> <span class=keyword>char</span> *message = <span class=string>"Hello from client"</span>;</span><br><span class=line></span><br><span class=line>    <span class=comment>// 创建套接字</span></span><br><span class=line>    <span class=keyword>if</span> ((sock = socket(AF_INET, SOCK_STREAM, <span class=number>0</span>)) < <span class=number>0</span>) {</span><br><span class=line>        perror(<span class=string>"Socket creation failed"</span>);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    serv_addr.sin_family = AF_INET;</span><br><span class=line>    serv_addr.sin_port = htons(PORT);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 将 IP 地址转换为二进制形式</span></span><br><span class=line>    <span class=keyword>if</span> (inet_pton(AF_INET, <span class=string>"127.0.0.1"</span>, &serv_addr.sin_addr) <= <span class=number>0</span>) {</span><br><span class=line>        perror(<span class=string>"Invalid address/ Address not supported"</span>);</span><br><span class=line>        close(sock);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 连接到服务器</span></span><br><span class=line>    <span class=keyword>if</span> (connect(sock, (struct sockaddr *)&serv_addr, <span class=keyword>sizeof</span>(serv_addr)) < <span class=number>0</span>) {</span><br><span class=line>        perror(<span class=string>"Connection failed"</span>);</span><br><span class=line>        close(sock);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 发送消息</span></span><br><span class=line>    send(sock, message, <span class=built_in>strlen</span>(message), <span class=number>0</span>);</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Message sent to server.\n"</span>);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 接收响应</span></span><br><span class=line>    <span class=keyword>int</span> valread = read(sock, buffer, BUFFER_SIZE);</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Server: %s\n"</span>, buffer);</span><br><span class=line></span><br><span class=line>    close(sock);</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}<span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdlib.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTarpa/inet.h></span></span></span><br><span class=line></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> PORT 8080</span></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> BUFFER_SIZE 1024</span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> sock = <span class=number>0</span>;</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>sockaddr_in</span> <span class=title>serv_addr</span>;</span></span><br><span class=line>    <span class=keyword>char</span> buffer[BUFFER_SIZE] = {<span class=number>0</span>};</span><br><span class=line>    <span class=keyword>const</span> <span class=keyword>char</span> *message = <span class=string>"Hello from client"</span>;</span><br><span class=line></span><br><span class=line>    <span class=comment>// 创建套接字</span></span><br><span class=line>    <span class=keyword>if</span> ((sock = socket(AF_INET, SOCK_STREAM, <span class=number>0</span>)) < <span class=number>0</span>) {</span><br><span class=line>        perror(<span class=string>"Socket creation failed"</span>);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    serv_addr.sin_family = AF_INET;</span><br><span class=line>    serv_addr.sin_port = htons(PORT);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 将 IP 地址转换为二进制形式</span></span><br><span class=line>    <span class=keyword>if</span> (inet_pton(AF_INET, <span class=string>"127.0.0.1"</span>, &serv_addr.sin_addr) <= <span class=number>0</span>) {</span><br><span class=line>        perror(<span class=string>"Invalid address/ Address not supported"</span>);</span><br><span class=line>        close(sock);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 连接到服务器</span></span><br><span class=line>    <span class=keyword>if</span> (connect(sock, (struct sockaddr *)&serv_addr, <span class=keyword>sizeof</span>(serv_addr)) < <span class=number>0</span>) {</span><br><span class=line>        perror(<span class=string>"Connection failed"</span>);</span><br><span class=line>        close(sock);</span><br><span class=line>        <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 发送消息</span></span><br><span class=line>    send(sock, message, <span class=built_in>strlen</span>(message), <span class=number>0</span>);</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Message sent to server.\n"</span>);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 接收响应</span></span><br><span class=line>    <span class=keyword>int</span> valread = read(sock, buffer, BUFFER_SIZE);</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Server: %s\n"</span>, buffer);</span><br><span class=line></span><br><span class=line>    close(sock);</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><h2 id=UDP流程><a class=headerlink href=#UDP流程 title=UDP流程></a>UDP流程</h2><p><strong>UDP Server</strong><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br></pre><td class=code><pre><span class=line></span><br><span class=line></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTcstdio></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTcstdlib></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTcstring></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTnetinet/in.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line><span class=keyword>const</span> <span class=keyword>int</span> PORT = <span class=number>8080</span>;</span><br><span class=line><span class=keyword>const</span> <span class=keyword>int</span> BUFFER_SIZE = <span class=number>1024</span>;</span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>  <span class=keyword>int</span> sockfd;</span><br><span class=line>  <span class=keyword>char</span> buffer[BUFFER_SIZE];</span><br><span class=line>  sockaddr_in servaddr, cliaddr;</span><br><span class=line>  <span class=keyword>socklen_t</span> len = <span class=built_in><span class=keyword>sizeof</span></span>(cliaddr);</span><br><span class=line>  <span class=keyword>const</span> <span class=keyword>char</span> *response = <span class=string>"Hello from server"</span>;</span><br><span class=line>  <span class=comment>// 创建套接字 SOCK_DGRAM</span></span><br><span class=line>  <span class=keyword>if</span> ((sockfd = <span class=built_in>socket</span>(AF_INET, SOCK_DGRAM, <span class=number>0</span>)) < <span class=number>0</span>) {</span><br><span class=line>    <span class=built_in>perror</span>(<span class=string>"Socket creation failed"</span>);</span><br><span class=line>    <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=built_in>memset</span>(&servaddr, <span class=number>0</span>, <span class=built_in><span class=keyword>sizeof</span></span>(servaddr));</span><br><span class=line>  <span class=built_in>memset</span>(&cliaddr, <span class=number>0</span>, <span class=built_in><span class=keyword>sizeof</span></span>(cliaddr));</span><br><span class=line></span><br><span class=line>  <span class=comment>// 绑定地址和端口</span></span><br><span class=line>  servaddr.sin_family = AF_INET;</span><br><span class=line>  servaddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class=line>  servaddr.sin_port = <span class=built_in>htons</span>(PORT);</span><br><span class=line>  <span class=keyword>if</span> (<span class=built_in>bind</span>(sockfd, (<span class=keyword>const</span> struct sockaddr *)&servaddr, <span class=built_in><span class=keyword>sizeof</span></span>(servaddr)) < <span class=number>0</span>) {</span><br><span class=line>    <span class=built_in>perror</span>(<span class=string>"Bind failed"</span>);</span><br><span class=line>    <span class=built_in>close</span>(sockfd);</span><br><span class=line>    <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>  }</span><br><span class=line>  <span class=built_in>printf</span>(<span class=string>"Server is listening on port %d...\n"</span>, PORT);</span><br><span class=line></span><br><span class=line>  <span class=comment>// 服务端绑定套接字后 直接开始读了</span></span><br><span class=line>  <span class=comment>// 接收客户端数据</span></span><br><span class=line>  <span class=keyword>int</span> n = <span class=built_in>recvfrom</span>(sockfd, (<span class=keyword>char</span> *)buffer, BUFFER_SIZE, <span class=number>0</span>,</span><br><span class=line>                   (struct sockaddr *)&cliaddr, &len);</span><br><span class=line>  buffer[n] = <span class=string>'\0'</span>;</span><br><span class=line>  <span class=built_in>printf</span>(<span class=string>"Client: %s\n"</span>, buffer);</span><br><span class=line></span><br><span class=line>  <span class=comment>// 发送响应</span></span><br><span class=line>  <span class=built_in>sendto</span>(sockfd, (<span class=keyword>const</span> <span class=keyword>char</span> *)response, <span class=built_in>strlen</span>(response), <span class=number>0</span>,</span><br><span class=line>         (<span class=keyword>const</span> struct sockaddr *)&cliaddr, len);</span><br><span class=line>  <span class=built_in>printf</span>(<span class=string>"Response sent to client.\n"</span>);</span><br><span class=line></span><br><span class=line>  <span class=built_in>close</span>(sockfd);</span><br><span class=line>  <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><p><strong>UDP Client</strong><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTarpa/inet.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdlib.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> PORT 8080</span></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> BUFFER_SIZE 1024</span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>  <span class=keyword>int</span> sockfd;</span><br><span class=line>  <span class=keyword>char</span> buffer[BUFFER_SIZE];</span><br><span class=line>  <span class=class><span class=keyword>struct</span> <span class=title>sockaddr_in</span> <span class=title>servaddr</span>;</span></span><br><span class=line>  <span class=keyword>const</span> <span class=keyword>char</span> *message = <span class=string>"Hello from client"</span>;</span><br><span class=line></span><br><span class=line>  <span class=comment>// 创建套接字</span></span><br><span class=line>  <span class=keyword>if</span> ((sockfd = <span class=built_in>socket</span>(AF_INET, SOCK_DGRAM, <span class=number>0</span>)) < <span class=number>0</span>) {</span><br><span class=line>    <span class=built_in>perror</span>(<span class=string>"Socket creation failed"</span>);</span><br><span class=line>    <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=built_in>memset</span>(&servaddr, <span class=number>0</span>, <span class=built_in><span class=keyword>sizeof</span></span>(servaddr));</span><br><span class=line></span><br><span class=line>  <span class=comment>// 设置服务器地址</span></span><br><span class=line>  servaddr.sin_family = AF_INET;</span><br><span class=line>  servaddr.sin_port = <span class=built_in>htons</span>(PORT);</span><br><span class=line>  servaddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class=line></span><br><span class=line>  <span class=comment>// 将 IP 地址转换为二进制形式</span></span><br><span class=line>  <span class=keyword>if</span> (<span class=built_in>inet_pton</span>(AF_INET, <span class=string>"127.0.0.1"</span>, &servaddr.sin_addr) <= <span class=number>0</span>) {</span><br><span class=line>    <span class=built_in>perror</span>(<span class=string>"Invalid address/ Address not supported"</span>);</span><br><span class=line>    <span class=built_in>close</span>(sockfd);</span><br><span class=line>    <span class=built_in>exit</span>(EXIT_FAILURE);</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=comment>// 创建套接字 后直接发送消息 需要连接的地址,不需要connect</span></span><br><span class=line>  <span class=comment>// 发送消息</span></span><br><span class=line>  <span class=built_in>sendto</span>(sockfd, (<span class=keyword>const</span> <span class=keyword>char</span> *)message, <span class=built_in>strlen</span>(message), <span class=number>0</span>,</span><br><span class=line>         (<span class=keyword>const</span> struct sockaddr *)&servaddr, <span class=built_in><span class=keyword>sizeof</span></span>(servaddr));</span><br><span class=line>  <span class=built_in>printf</span>(<span class=string>"Message sent to server.\n"</span>);</span><br><span class=line></span><br><span class=line>  <span class=comment>// 接收响应</span></span><br><span class=line>  <span class=keyword>socklen_t</span> len = <span class=built_in><span class=keyword>sizeof</span></span>(servaddr);</span><br><span class=line>  <span class=keyword>int</span> n = <span class=built_in>recvfrom</span>(sockfd, (<span class=keyword>char</span> *)buffer, BUFFER_SIZE, <span class=number>0</span>,</span><br><span class=line>                   (struct sockaddr *)&servaddr, &len);</span><br><span class=line>  buffer[n] = <span class=string>'\0'</span>;</span><br><span class=line>  <span class=built_in>printf</span>(<span class=string>"Server: %s\n"</span>, buffer);</span><br><span class=line></span><br><span class=line>  <span class=built_in>close</span>(sockfd);</span><br><span class=line>  <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><h2 id=异步IO机制><a class=headerlink href=#异步IO机制 title=异步IO机制></a>异步IO机制</h2><p><img alt=img data-src=https://pic1.zhimg.com/v2-25903c3b11d19c9bbbc2f414665a435e_1440w.jpg><p><a href=https://arthurchiao.art/blog/intro-to-io-uring-zh/#24-三种工作模式 rel=noopener target=_blank>[译] Linux 异步 I/O 框架 io_uring：基本原理、程序示例与性能压测（2020）</a><p><a href=https://www.cnblogs.com/schips/p/12575933.html rel=noopener target=_blank>Linux 网络编程的5种IO模型：异步IO模型 - schips - 博客园</a><p><a href=https://zhuanlan.zhihu.com/p/577599879 rel=noopener target=_blank>一篇文章彻底搞懂linux的异步IO - 知乎</a><h3 id=POSIX异步IO><a class=headerlink href=#POSIX异步IO title=POSIX异步IO></a>POSIX异步IO</h3><p>POSIX异步I/O提供了一种机制，允许应用程序在执行I/O操作时不会被阻塞，这意味着程序可以在I/O操作完成的同时继续执行其他任务。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line>/* Asynchronous I/O control block.  */</span><br><span class=line>struct aiocb</span><br><span class=line>{</span><br><span class=line>  int aio_fildes;		/* File descriptor.  */</span><br><span class=line>  int aio_lio_opcode;		/* Operation to be performed.  */</span><br><span class=line>  int aio_reqprio;		/* Request priority offset.  */</span><br><span class=line>  volatile void *aio_buf;	/* Location of buffer.  */</span><br><span class=line>  size_t aio_nbytes;		/* Length of transfer.  */</span><br><span class=line>  struct sigevent aio_sigevent;	/* Signal number and value.  */</span><br><span class=line></span><br><span class=line>  /* Internal members.  */</span><br><span class=line>  struct aiocb *__next_prio;</span><br><span class=line>  int __abs_prio;</span><br><span class=line>  int __policy;</span><br><span class=line>  int __error_code;</span><br><span class=line>  __ssize_t __return_value;</span><br><span class=line></span><br><span class=line>#ifndef __USE_FILE_OFFSET64</span><br><span class=line>  __off_t aio_offset;		/* File offset.  */</span><br><span class=line>  char __pad[sizeof (__off64_t) - sizeof (__off_t)];</span><br><span class=line>#else</span><br><span class=line>  __off64_t aio_offset;		/* File offset.  */</span><br><span class=line>#endif</span><br><span class=line>  char __glibc_reserved[32];</span><br><span class=line>};</span><br></pre></table></figure><ul><li><p><strong><code>struct aiocb</code></strong>：这是异步I/O控制块，包含了关于异步I/O操作的所有信息。包括但不限于<strong>文件描述符、缓冲区地址、请求的状态</strong>等。</p> <p>通知方式有<strong>不通知</strong>,<strong>信号通知</strong>,在新线程中<strong>调用指定函数</strong>等</p></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=keyword>typedef</span> <span class=class><span class=keyword>struct</span> <span class=title>sigevent</span></span></span><br><span class=line><span class=class>  {</span></span><br><span class=line>    <span class=keyword>__sigval_t</span> sigev_value;</span><br><span class=line>    <span class=keyword>int</span> sigev_signo;</span><br><span class=line>    <span class=keyword>int</span> sigev_notify;</span><br><span class=line></span><br><span class=line>    <span class=class><span class=keyword>union</span></span></span><br><span class=line><span class=class>      {</span></span><br><span class=line>	<span class=keyword>int</span> _pad[__SIGEV_PAD_SIZE];</span><br><span class=line></span><br><span class=line>	<span class=comment>/* When SIGEV_SIGNAL and SIGEV_THREAD_ID set, LWP ID of the</span></span><br><span class=line><span class=comment>	   thread to receive the signal.  */</span></span><br><span class=line>	<span class=keyword>__pid_t</span> _tid;</span><br><span class=line></span><br><span class=line>	<span class=class><span class=keyword>struct</span></span></span><br><span class=line><span class=class>	  {</span></span><br><span class=line>	    <span class=built_in><span class=keyword>void</span></span> (*_function) (<span class=keyword>__sigval_t</span>);	<span class=comment>/* Function to start.  */</span></span><br><span class=line>	    <span class=keyword>pthread_attr_t</span> *_attribute;		<span class=comment>/* Thread attributes.  */</span></span><br><span class=line>	  } _sigev_thread;</span><br><span class=line>      } _sigev_un;</span><br><span class=line>  } <span class=keyword>sigevent_t</span>;</span><br></pre></table></figure><ul><li><p><strong><code>sigev_notify</code></strong>：指定通知的方式。常见的选项包括：</p> <ul><li><code>SIGEV_NONE</code>：不发送任何通知。<li><code>SIGEV_SIGNAL</code>：当异步事件发生时，向进程发送指定的信号。<li><code>SIGEV_THREAD</code>：当异步事件发生时，在新线程中调用指定的函数。<li><code>SIGEV_THREAD_ID</code>：特定于Linux的一个扩展，允许向特定线程发送信号。</ul> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>enum</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>  SIGEV_SIGNAL = <span class=number>0</span>,		<span class=comment>/* Notify via signal.  */</span></span><br><span class=line><span class=meta># <span class=meta-keyword>define</span> SIGEV_SIGNAL	SIGEV_SIGNAL</span></span><br><span class=line>  SIGEV_NONE,			<span class=comment>/* Other notification: meaningless.  */</span></span><br><span class=line><span class=meta># <span class=meta-keyword>define</span> SIGEV_NONE	SIGEV_NONE</span></span><br><span class=line>  SIGEV_THREAD,			<span class=comment>/* Deliver via thread creation.  */</span></span><br><span class=line><span class=meta># <span class=meta-keyword>define</span> SIGEV_THREAD	SIGEV_THREAD</span></span><br><span class=line></span><br><span class=line>  SIGEV_THREAD_ID = <span class=number>4</span>		<span class=comment>/* Send signal to specific thread.</span></span><br><span class=line><span class=comment>				   This is a Linux extension.  */</span></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> SIGEV_THREAD_ID	SIGEV_THREAD_ID</span></span><br><span class=line>};</span><br><span class=line></span><br></pre></table></figure><li><p><strong><code>sigev_signo</code></strong>：如果选择了 <code>SIGEV_SIGNAL</code> 作为通知方式，则此字段应设置为希望发送的信号编号（例如 <code>SIGIO</code>）。</p><li><p><strong><code>sigev_value</code></strong>：这是一个联合体，可用于将数据传递给信号处理器或回调函数。这可以是任意数据，通常用于标识哪个异步I/O操作触发了通知。</p><li><p><strong><code>sigev_notify_function</code></strong>：当选择 <code>SIGEV_THREAD</code> 作为通知方式时，此字段应指向一个函数，该函数将在新线程中被调用来处理事件。</p><li><p><strong><code>sigev_notify_attributes</code></strong>：如果选择了 <code>SIGEV_THREAD</code> 作为通知方式，可以通过此字段提供线程属性对象，以定制创建的新线程的特性。</p></ul><ol><li><strong><code>aio_read()</code></strong><ul><li>发起一个异步读操作。它接受一个指向 <code>aiocb</code> 结构的指针作为参数，并返回一个整数值。如果成功，则返回0；如果失败，则返回-1，并设置相应的错误码。</ul><li><strong><code>aio_write()</code></strong><ul><li>发起一个异步写操作。与 <code>aio_read()</code> 类似，它也接受一个指向 <code>aiocb</code> 结构的指针，并根据是否成功返回0或-1。</ul><li><strong><code>aio_error()</code></strong><ul><li>检查指定的异步I/O操作的状态。如果操作还在进行中，它将返回 <code>EINPROGRESS</code>；如果操作已经完成，但发生了错误，它会返回相应的错误码；如果操作成功完成，它会返回0。</ul><li><strong><code>aio_return()</code></strong><ul><li>获取已完成的异步I/O操作的返回状态。只有当 <code>aio_error()</code> 对特定的 <code>aiocb</code> 结构返回除了 <code>EINPROGRESS</code> 之外的值时，调用 <code>aio_return()</code> 才有意义。</ul><li><strong><code>aio_cancel()</code></strong><ul><li>尝试取消一个或多个尚未完成的异步I/O请求。可以针对特定的 <code>aiocb</code> 取消，也可以尝试取消某个文件描述符上的所有异步I/O请求。</ul><li><strong><code>aio_suspend()</code></strong><ul><li>挂起调用进程或线程，直到指定的一个或多个异步I/O请求完成或者发生超时（如果提供了超时参数）。这对于等待一组异步I/O操作完成特别有用。</ul><li><strong><code>lio_listio()</code></strong><ul><li>同时发起一系列的读写操作。这可以是一个列表的读操作、写操作或是两者的组合。此函数支持两种模式：同步和异步。在异步模式下，即使I/O操作未完成，该函数也会立即返回。</ul></ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTaio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTcsignal></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTcstring></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTfcntl.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTlibaio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTnetinet/in.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdlib.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstrings.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/types.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> BUFFER_SIZE 1024</span></span><br><span class=line><span class=keyword>int</span> MAX_LSIT = <span class=number>2</span>;</span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>handler</span><span class=params>(<span class=keyword>int</span> sig, <span class=keyword>siginfo_t</span> *si, <span class=keyword>void</span> *unused)</span> </span>{</span><br><span class=line>  <span class=built_in>printf</span>(<span class=string>"Async I/O completed.\n"</span>);</span><br><span class=line>}</span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>  <span class=class><span class=keyword>struct</span> <span class=title>aiocb</span> <span class=title>cb</span>;</span></span><br><span class=line>  <span class=keyword>int</span> fd, ret, counter;</span><br><span class=line>  fd = <span class=built_in>open</span>(<span class=string>"test.txt"</span>, O_RDWR);</span><br><span class=line>  <span class=keyword>if</span> (fd == <span class=number>-1</span>) {</span><br><span class=line>    std::cout << <span class=string>"open file error"</span> << std::endl;</span><br><span class=line>    <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>char</span> buf[<span class=number>1024</span>];</span><br><span class=line>  <span class=comment>// 设置信号处理</span></span><br><span class=line>  <span class=class><span class=keyword>struct</span> <span class=title>sigaction</span> <span class=title>sa</span>;</span></span><br><span class=line>  sa.sa_flags = SA_SIGINFO;</span><br><span class=line>  sa.sa_sigaction = handler;</span><br><span class=line>  <span class=built_in>sigemptyset</span>(&sa.sa_mask);</span><br><span class=line>  <span class=built_in>sigaction</span>(SIGUSR1, &sa, <span class=literal>NULL</span>);</span><br><span class=line></span><br><span class=line>  <span class=comment>// 设置异步I/O控制块</span></span><br><span class=line>  cb.aio_fildes = fd;</span><br><span class=line>  cb.aio_lio_opcode = LIO_READ;</span><br><span class=line>  cb.aio_buf = buf;</span><br><span class=line>  cb.aio_nbytes = BUFFER_SIZE;</span><br><span class=line>  cb.aio_offset = <span class=number>0</span>;</span><br><span class=line>  <span class=comment>//   设置通知方式</span></span><br><span class=line>  cb.aio_sigevent.sigev_notify = SIGEV_SIGNAL;</span><br><span class=line>  <span class=comment>//   当使用信号通知,设置信号值等参数</span></span><br><span class=line>  cb.aio_sigevent.sigev_signo = SIGUSR1;</span><br><span class=line>  <span class=comment>//   如果使用在SIGEV_THREAD 作为通知方式时，此字段应指向一个函数</span></span><br><span class=line><span class=comment>//   cb.aio_sigevent.sigev_notify_function = NULL;</span></span><br><span class=line>  <span class=comment>// 传递字符串</span></span><br><span class=line></span><br><span class=line>  <span class=keyword>if</span> (<span class=built_in>aio_read</span>(&cb) == <span class=number>-1</span>) {</span><br><span class=line>    std::cout << <span class=string>"aio_read error"</span> << std::endl;</span><br><span class=line>    <span class=built_in>perror</span>(<span class=string>"aio_read"</span>);</span><br><span class=line>    </span><br><span class=line>    <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>int</span> couter = <span class=number>0</span>;</span><br><span class=line>  <span class=keyword>while</span> (<span class=built_in>aio_error</span>(&cb) == EINPROGRESS) {</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"第%d次\n"</span>,++couter);</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=keyword>int</span> bytesRead = <span class=built_in>aio_return</span>(&cb);</span><br><span class=line>  <span class=built_in>printf</span>(<span class=string>"Read %d bytes\n"</span>, bytesRead);</span><br><span class=line>  std::cout << buf << std::endl;</span><br><span class=line>  <span class=built_in>close</span>(fd);</span><br><span class=line>  <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdlib.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTfcntl.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTaio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTerrno.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> fd;</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>aiocb</span> <span class=title>my_aiocb</span>;</span></span><br><span class=line></span><br><span class=line>    <span class=comment>// 打开文件</span></span><br><span class=line>    fd = <span class=built_in>open</span>(<span class=string>"output.txt"</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class=number>0644</span>);</span><br><span class=line>    <span class=keyword>if</span> (fd == <span class=number>-1</span>) {</span><br><span class=line>        <span class=built_in>perror</span>(<span class=string>"open"</span>);</span><br><span class=line>        <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 动态分配缓冲区</span></span><br><span class=line>    <span class=keyword>size_t</span> buffer_size = <span class=number>4096</span>; <span class=comment>// 假设缓冲区大小为 4KB</span></span><br><span class=line>    <span class=keyword>char</span> *buffer = (<span class=keyword>char</span> *)<span class=built_in>malloc</span>(buffer_size);</span><br><span class=line>    <span class=keyword>if</span> (!buffer) {</span><br><span class=line>        <span class=built_in>perror</span>(<span class=string>"malloc"</span>);</span><br><span class=line>        <span class=built_in>close</span>(fd);</span><br><span class=line>        <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=built_in>memset</span>(buffer, <span class=string>'A'</span>, buffer_size); <span class=comment>// 初始化缓冲区内容</span></span><br><span class=line></span><br><span class=line>    <span class=comment>// 初始化 aiocb 结构体</span></span><br><span class=line>    <span class=built_in>memset</span>(&my_aiocb, <span class=number>0</span>, <span class=built_in><span class=keyword>sizeof</span></span>(struct aiocb));</span><br><span class=line>    my_aiocb.aio_fildes = fd;              <span class=comment>// 文件描述符</span></span><br><span class=line>    my_aiocb.aio_buf = buffer;             <span class=comment>// 缓冲区指针</span></span><br><span class=line>    my_aiocb.aio_nbytes = buffer_size;     <span class=comment>// 写入的字节数</span></span><br><span class=line>    my_aiocb.aio_offset = <span class=number>0</span>;               <span class=comment>// 写入的偏移量</span></span><br><span class=line></span><br><span class=line>    <span class=comment>// 发起异步写操作</span></span><br><span class=line>    <span class=keyword>if</span> (<span class=built_in>aio_write</span>(&my_aiocb) == <span class=number>-1</span>) {</span><br><span class=line>        <span class=built_in>perror</span>(<span class=string>"aio_write"</span>);</span><br><span class=line>        <span class=built_in>free</span>(buffer); <span class=comment>// 释放缓冲区</span></span><br><span class=line>        <span class=built_in>close</span>(fd);</span><br><span class=line>        <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Asynchronous write operation initiated.\n"</span>);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 等待异步操作完成</span></span><br><span class=line>    <span class=keyword>int</span> err;</span><br><span class=line>    <span class=keyword>while</span> ((err = <span class=built_in>aio_error</span>(&my_aiocb)) == EINPROGRESS) {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Write operation still in progress...\n"</span>);</span><br><span class=line>        <span class=built_in>sleep</span>(<span class=number>1</span>); <span class=comment>// 等待一段时间</span></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 检查异步操作的状态</span></span><br><span class=line>    <span class=keyword>if</span> (err == <span class=number>0</span>) {</span><br><span class=line>        <span class=keyword>ssize_t</span> bytes_written = <span class=built_in>aio_return</span>(&my_aiocb);</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Asynchronous write completed successfully. Bytes written: %zd\n"</span>, bytes_written);</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>        <span class=built_in>fprintf</span>(stderr, <span class=string>"Asynchronous write failed with error: %s\n"</span>, <span class=built_in>strerror</span>(err));</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 释放缓冲区</span></span><br><span class=line>    <span class=built_in>free</span>(buffer);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 关闭文件</span></span><br><span class=line>    <span class=built_in>close</span>(fd);</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>上述aio其实是<strong>用户层使用线程模拟的异步io</strong>，缺点是占用线程资源而且受可用线程的数量限制。Linux2.6版本后有了libaio，这完全是内核级别的异步IO，IO请求完全由底层自由调度<h3 id=Linux原生AIO><a class=headerlink href=#Linux原生AIO title=Linux原生AIO></a>Linux原生AIO</h3><blockquote><p>Linux Native AIO 是 Linux 支持的原生 AIO，为什么要加原生这个词呢？因为Linux存在很多第三方的异步 IO 库，如 libeio 和 glibc AIO。所以为了加以区别，Linux 的内核提供的异步 IO 就称为原生异步 IO。很多第三方的异步 IO 库都不是真正的异步 IO，而是使用多线程来模拟异步 IO，如 libeio 就是使用多线程来模拟异步 IO 的。</blockquote><p>一般来说，使用 Linux 原生 AIO 需要 3 个步骤：<ul><li>1) 调用 io_setup 函数创建一个一般 IO 上下文。<li>2) 调用 io_submit 函数向内核提交一个异步 IO 操作。<li>3) 调用 io_getevents 函数获取异步 IO 操作结果。</ul><blockquote><p>可以通过libaio库调用原生系统调用</blockquote><ol><li><strong><code>io_setup()</code></strong><ul><li>初始化一个AIO上下文，返回一个上下文标识符供后续操作使用。</ul><li><strong><code>io_submit()</code></strong><ul><li>提交一个或多个异步I/O请求到指定的AIO上下文中。</ul><li><strong><code>io_getevents()</code></strong><ul><li>获取已完成的异步I/O操作的结果。可以通过此函数查询已提交的I/O请求的状态。</ul><li><strong><code>io_destroy()</code></strong><ul><li>销毁一个AIO上下文，释放相关资源。</ul><li><strong><code>struct iocb</code></strong><ul><li>这个结构用于描述单个I/O操作的信息，包括操作类型（读、写等）、文件描述符、缓冲区地址及大小等。</ul></ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>iocb</span> {</span></span><br><span class=line>	<span class=built_in>PADDEDptr</span>(<span class=keyword>void</span> *data, __pad1);	<span class=comment>/* Return in the io completion event */</span></span><br><span class=line>	<span class=comment>/* key: For use in identifying io requests */</span></span><br><span class=line>	<span class=comment>/* aio_rw_flags: RWF_* flags (such as RWF_NOWAIT) */</span></span><br><span class=line>	<span class=built_in>PADDED</span>(<span class=keyword>unsigned</span> key, aio_rw_flags);</span><br><span class=line></span><br><span class=line>	<span class=keyword>short</span>		aio_lio_opcode;	</span><br><span class=line>	<span class=keyword>short</span>		aio_reqprio;</span><br><span class=line>	<span class=keyword>int</span>		aio_fildes;</span><br><span class=line></span><br><span class=line>	<span class=class><span class=keyword>union</span> {</span></span><br><span class=line>		<span class=class><span class=keyword>struct</span> <span class=title>io_iocb_common</span>		<span class=title>c</span>;</span></span><br><span class=line>		<span class=class><span class=keyword>struct</span> <span class=title>io_iocb_vector</span>		<span class=title>v</span>;</span></span><br><span class=line>		<span class=class><span class=keyword>struct</span> <span class=title>io_iocb_poll</span>		<span class=title>poll</span>;</span></span><br><span class=line>		<span class=class><span class=keyword>struct</span> <span class=title>io_iocb_sockaddr</span>	<span class=title>saddr</span>;</span></span><br><span class=line>	} u;</span><br><span class=line>}; <span class=comment>//描述一个异步 I/O 请求</span></span><br></pre></table></figure><ul><li><code>data</code>：用户可以设置一个指针，用于在回调或完成事件中标识这个请求。<li><code>aio_lio_opcode</code>：指定操作类型，例如读取 (<code>IO_CMD_PREAD</code>) 或写入 (<code>IO_CMD_PWRITE</code>)。<li><code>aio_fildes</code>：目标文件的文件描述符。<li><code>u.c</code>：包含具体操作的参数（如缓冲区地址、偏移量、字节数等）。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>io_event</span> {</span></span><br><span class=line>	<span class=built_in>PADDEDptr</span>(<span class=keyword>void</span> *data, __pad1);</span><br><span class=line>	<span class=built_in>PADDEDptr</span>(struct iocb *obj,  __pad2);</span><br><span class=line>	<span class=built_in>PADDEDul</span>(res,  __pad3);</span><br><span class=line>	<span class=built_in>PADDEDul</span>(res2, __pad4);</span><br><span class=line>}; <span class=comment>//描述一个已完成的异步 I/O 操作的结果</span></span><br></pre></table></figure><ul><li><code>data</code> 和 <code>obj</code>：用于匹配完成事件和原始请求。<li><code>res</code>：表示操作的结果。如果大于等于 0，则表示成功完成的字节数；如果小于 0，则表示发生错误，其值为负的错误码（如 <code>-EIO</code>）。<li><code>res2</code>：通常不使用，但在某些情况下可能包含额外的信息。</ul><p><strong><code>`io_context_t</code></strong><ul><li><p><strong>作用</strong>：表示一个异步 I/O 上下文，用于管理一组异步 I/O 请求。</p><li><p>定义</p> <figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>typedef</span> <span class=class><span class=keyword>struct</span> <span class=title>io_context</span> *<span class=title>io_context_t</span>;</span></span><br></pre></table></figure><li><p>说明</p> <ul><li>一个 <code>io_context_t</code> 可以管理多个异步 I/O 请求。</ul></ul><p>注意添加链接库<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>sudo apt install libaio-dev </span><br></pre></table></figure><figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>target_link_libraries</span>(linux_aio</span><br><span class=line>    PRIVATE</span><br><span class=line>    -laio</span><br><span class=line>)</span><br></pre></table></figure><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTfcntl.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTlibaio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>  <span class=keyword>io_context_t</span> ctx;</span><br><span class=line>  <span class=class><span class=keyword>struct</span> <span class=title>iocb</span> <span class=title>cb</span>;</span></span><br><span class=line>  <span class=class><span class=keyword>struct</span> <span class=title>iocb</span> *<span class=title>cbs</span>[1];</span></span><br><span class=line>  <span class=keyword>int</span> fd;</span><br><span class=line>  <span class=keyword>char</span> buf[] = <span class=string>"Hello,world"</span>;</span><br><span class=line>  fd = <span class=built_in>open</span>(<span class=string>"test1.txt"</span>, O_RDWR | O_CREAT | O_DIRECT, <span class=number>0644</span>);</span><br><span class=line>  <span class=keyword>if</span> (fd < <span class=number>0</span>) {</span><br><span class=line>    <span class=built_in>perror</span>(<span class=string>"open:"</span>);</span><br><span class=line>    <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>  }</span><br><span class=line>  <span class=built_in>memset</span>(&ctx, <span class=number>0</span>, <span class=built_in><span class=keyword>sizeof</span></span>(<span class=keyword>io_context_t</span>));</span><br><span class=line></span><br><span class=line>  <span class=comment>//   io事件的初始化</span></span><br><span class=line>  <span class=keyword>if</span> (<span class=built_in>io_setup</span>(<span class=number>1</span>, &ctx) < <span class=number>0</span>) {</span><br><span class=line>    <span class=built_in>perror</span>(<span class=string>"io_setup:"</span>);</span><br><span class=line>    <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=comment>// 提交io事件</span></span><br><span class=line>  <span class=built_in>memset</span>(&cb, <span class=number>0</span>, <span class=built_in><span class=keyword>sizeof</span></span>(struct iocb));</span><br><span class=line>  cb.aio_fildes = fd;</span><br><span class=line>  cb.aio_lio_opcode = IO_CMD_PWRITE;</span><br><span class=line>  <span class=keyword>char</span> msg[] = <span class=string>"aio query"</span>;</span><br><span class=line>  cb.data = msg;</span><br><span class=line>  cb.u.c.buf = buf;</span><br><span class=line>  cb.u.c.nbytes = <span class=built_in>strlen</span>(buf);</span><br><span class=line>  cb.u.c.offset = <span class=number>0</span>;</span><br><span class=line></span><br><span class=line>  cbs[<span class=number>0</span>] = &cb;</span><br><span class=line>  <span class=keyword>if</span> (<span class=built_in>io_submit</span>(ctx, <span class=number>1</span>, cbs) < <span class=number>0</span>) {</span><br><span class=line>    <span class=built_in>perror</span>(<span class=string>"io_submit:"</span>);</span><br><span class=line>    <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>  }</span><br><span class=line>  <span class=class><span class=keyword>struct</span> <span class=title>io_event</span> <span class=title>events</span>[1];</span></span><br><span class=line>  <span class=keyword>if</span> (<span class=built_in>io_getevents</span>(ctx, <span class=number>1</span>, <span class=number>1</span>, events, <span class=literal>nullptr</span>) < <span class=number>0</span>) {</span><br><span class=line>    <span class=built_in>perror</span>(<span class=string>"io_getevents:"</span>);</span><br><span class=line>    <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>if</span> (events[<span class=number>0</span>].res < <span class=number>0</span>) {</span><br><span class=line>    <span class=built_in>perror</span>(<span class=string>"io_getevents:"</span>);</span><br><span class=line>    <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>  }</span><br><span class=line>  std::cout << <span class=string>"aio getevents:"</span> << (<span class=keyword>char</span> *)events[<span class=number>0</span>].data << std::endl;</span><br><span class=line>  std::cout << <span class=string>"aio getevents:"</span> << events[<span class=number>0</span>].res << std::endl;</span><br><span class=line>  std::cout << <span class=string>"aio getevents:"</span> << events[<span class=number>0</span>].res2 << std::endl;</span><br><span class=line></span><br><span class=line>  <span class=built_in>io_destroy</span>(ctx);</span><br><span class=line>  <span class=built_in>close</span>(fd);</span><br><span class=line>  <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>注意,如果使用<code>O_DIRECT</code>标志打开有限制.<code>O_DIRECT</code> 是一种特殊的文件打开模式，它绕过操作系统的页缓存，直接与磁盘设备交互。<p><strong>(1) 缓冲区对齐</strong><ul><li><strong>地址对齐</strong>：缓冲区的起始地址必须是对齐的，通常是硬件块大小的倍数（通常是 512 字节或 4KB）。<li><strong>大小对齐</strong>：缓冲区的大小也必须是硬件块大小的倍数。<li><strong>偏移量对齐</strong>：文件读写的偏移量也必须是对齐的。</ul><p>如果不满足这些对齐要求，<code>open()</code> 或 <code>read()</code>/<code>write()</code> 调用可能会失败。<p><strong>(2) 文件系统支持</strong><ul><li>并非所有文件系统都支持 <code>O_DIRECT</code>。例如，某些网络文件系统（如 NFS）可能不支持直接 I/O。</ul><p><strong>(3) 性能权衡</strong><ul><li>直接 I/O 绕过了页缓存，因此对于小文件或频繁的小 I/O 操作，性能可能不如普通缓存 I/O。</ul><p><strong>关键修改点</strong><p><strong>(1) 使用 <code>posix_memalign()</code> 分配对齐内存</strong><p>posix_memalign()<figure class="highlight sas"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>if</span> (posix_memali<span class=meta>gn(</span><span class=variable>&buffer</span>, 4096, BUFFER_SIZE)) {</span><br><span class=line>    perror(<span class=string>"posix_memalign"</span>);</span><br><span class=line>    <span class=meta>return</span> 1;</span><br><span class=line>}</span><br></pre></table></figure><ul><li>第二个参数指定对齐边界（这里是 4KB）。<li>第三个参数指定分配的大小。</ul><blockquote><p><code>posix_memalign</code> 是一个 POSIX 标准的函数，用于分配对齐的内存。它允许用户指定内存块的起始地址对齐边界.<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>><span class=function><span class=keyword>int</span> <span class=title>posix_memalign</span><span class=params>(<span class=keyword>void</span> **memptr, <span class=keyword>size_t</span> alignment, <span class=keyword>size_t</span> size)</span></span>;</span><br></pre></table></figure><p><strong>参数说明</strong><ul><li><code>memptr</code><ul><li>输出参数，指向一个指针变量。<li>如果分配成功，<code>*memptr</code> 将存储分配的内存块的地址。</ul><li><code>alignment</code><ul><li>内存块的对齐边界，以字节为单位。<li>必须是 2 的幂次方，并且至少为 <code>sizeof(void *)</code>（通常是 8 字节或更大）。</ul><li><code>size</code><ul><li>要分配的内存大小，以字节为单位。</ul></ul></blockquote><p><strong>(2) 添加 <code>O_DIRECT</code> 标志</strong><ul><li><p>在open()中添加<code>O_DIRECT</code></p> <figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>int</span> fd = open(<span class=string>"output.txt"</span>, O_WRONLY | O_CREAT | O_TRUNC | O_DIRECT, <span class=number>0644</span>);</span><br></pre></table></figure></ul><p><strong>(3) 确保缓冲区大小和偏移量对齐</strong><ul><li>缓冲区大小设置为 4KB（<code>BUFFER_SIZE</code>）。<li>文件偏移量设置为 0（默认对齐）</ul><p><a href=https://www.quora.com/Why-does-O_DIRECT-require-I-O-to-be-512-byte-aligned rel=noopener target=_blank>Why does O_DIRECT require I/O to be 512-byte aligned? - Quora</a><p>要求缓存大小和对齐都需要512及其倍数字节.<p>libaio的缺点是，(1)想要使用该种方式的文件必须支持以O_DIRECT标志打开，然而并不是所有的文件系统都支持。如果你没有使用O_DIRECT打开文件，它可能仍然“工作”，但它可能不是异步完成的，而是变为了阻塞的。<p>(2)仍然可能被阻塞。即使应用层主观上，希望系统层采用异步 IO，但是客观上，有时候还是可能会被阻塞。<p>(3) 拷贝开销大。每个 IO 提交需要拷贝 64+8 字节，每个 IO 完成需要拷贝 32 字节，总共 104 字节的拷贝。这个拷贝开销是否可以承受，和单次 IO 大小有关：如果需要发送的 IO 本身就很大，相较之下，这点消耗可以忽略，而在大量小 IO 的场景下，这样的拷贝影响比较大。<img alt=img data-src=https://pic4.zhimg.com/v2-c886c75a94b559d44aecfc17b97d898d_1440w.jpg><h3 id=io-uring><a class=headerlink href=#io-uring title=io_uring></a>io_uring</h3><ul><li><a href=https://zhuanlan.zhihu.com/p/389978597 rel=noopener target=_blank>存储大师班 | Linux IO 模式之 io_uring - 知乎</a><li><a href=https://blog.csdn.net/crazymakercircle/article/details/129190222 rel=noopener target=_blank>（图解+史上最全）_iouring-CSDN博客</a><li><a href=https://cuterwrite.top/p/efficient-liburing/ rel=noopener target=_blank>高性能异步 I/O 框架：io_uring</a></ul><p><code>io_uring</code> 是 Linux 内核5.1版本引入的一种高性能异步I/O框架。与传统的 POSIX AIO 相比，<code>io_uring</code> 提供了更高效的零拷贝I/O操作，减少了上下文切换和系统调用开销。<blockquote><p>io_uring 围绕高效进行设计，其设计了一对共享的 ring buffer 用于应用和内核之间的通信，通过该设计实现了如下的三个好处：<p>（1）避免在提交和完成事件中存在内存拷贝；<p>（2）避免了 libaio 中在提交和完成任务的时候系统调用过程；<p>（3）该队列采用了无锁的访问模式，通过内存屏障减少了竞争；<p>在共享的 ring buffer 设计中，针对提交队列（SQ），应用是 IO 提交的生产者（producer），内核是消费者（consumer）；反过来，针对完成队列（CQ），内核是完成事件的生产者，应用是消费者。<p>另外，io_uring 还存在如下的优势：<p>（1）提交和完成不需要经过系统调用，而且减少了对用户态线程的阻塞；该部分的支持主要通过共享的 ring buffer 和设置 polling 模式来实现。<p>（2）支持 Block 层的 polling 模式<p>（3）支持 buffered IO，充分利用缓存，减少数据碰盘产生的系统延迟；</blockquote><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>sudo apt install liburing-dev</span><br></pre></table></figure><figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>target_link_libraries</span>(io_uring</span><br><span class=line>    -luring</span><br><span class=line>)</span><br></pre></table></figure><blockquote><p>liburing 是一个基于 io_uring 接口的用户空间库，它是 Linux 内核开发者 Axboe 于 2019 年发布的一个开源项目。io_uring 是一种新的 Linux 异步 I/O 接口，<strong>它通过使用一对环形缓冲区（ring buffer）来实现用户空间和内核空间之间的通信，从而避免了传统异步 I/O 接口（如 AIO）所需的系统调用、信号、回调等机制。</strong>这样，用户空间可以直接向内核提交 I/O 请求，并从内核获取 I/O 结果，而无需等待或切换上下文。这大大提高了异步 I/O 操作的效率和性能。</blockquote><p><img alt=20230802172119 data-src=https://cloud.cuterwrite.fun/blog/20230802172119.webp><p>每个 io_uring 实例都有两个环形队列(称为 ring)，在内核和应用程序之间共享：<ol><li>提交队列：submission queue( SQ )<li>完成队列：completion queue( CQ )</ol><p>这两个队列：<ol><li>都是单生产者、单消费者的队列，size 为 2 的幂次方。<li>提供无锁接口，内部使用内存屏障来进行同步。</ol><p>请求时：<ol><li>应用创建 SQ Entries (SQE)，更新 SQ tail<li>内核消费 SQE，更新 SQ head</ol><p>完成后：<ol><li>内核为完成的一个或多个请求创建 CQ Entries (CQE)，更新 CQ tail<li>应用消费 CQE，更新 CQ head<li>完成事件可能以任意顺序到达，到总是与特定的 SQE 相关联的<li>消费 CQE 过程无需切换内核态</ol><p>这样做的好处在于：<ol><li>原本需要多次系统调用，现在变成批处理一次提交<li>此外，io_uring 使异步 I/O 的使用场景也不再仅限于数据库应用， 普通的非数据库应用也能用</ol><p>io_uring 的三种工作模式：<ol><li>中断驱动模式 (interrupt-driven)<ul><li>默认模式, 可通过 io_uring_enter()提交 I/O 请求，然后直接检查 CQ 状态判断是否完成。</ul><li>轮询模式 (polling)<ul><li>Busy waiting for I/O completion，而不是通过异步 IRQ(Interrupt Request)来接收通知<li>这种模式需要文件系统和块设备支持轮询功能。相比中断驱动模式，这种方式延迟更低，但是 CPU 占用率可能会更高。<li>目前，只有指定了 O_DIRECT 标志打开的文件描述符才能使用这种模式。当一个读或写请求提交给轮询上下文之后，应用必须调用 io_uring_enter()来轮询 CQ 队列，判断请求是否完成。<li>对于一个 io_uring 实例来说，不支持混合使用轮询和非轮询模式。</ul><li>内核轮询模式 (kernel polling)<ul><li>这种模式会创建一个内核线程来执行 SQ 的轮询工作。<li>使用这种模式的 io_uring 实例，应用无需切到内核态就能触发 I/O 操作。通过 SQ 来提交 SQE，以及监控 CQ 的完成状态，应用无需任何系统调用，就能提交和收割 I/O。<li>如果内核线程的空闲事件超过了用户的配置值，它会通知应用，然后进入 idle 状态。这种情况下，应用必须调用 io_uring_enter()来唤醒内核线程。如果 I/O 一直很繁忙，内核线程是不会 sleep 的。</ul></ol><p>（1）io_uring_setup：初始化一个新的 io_uring 上下文，内核通过一块和用户共享的内存区域进行消息的传递。<p>（2）io_uring_enter：提交任务以及收割任务。<p>（3）io_uring_register：注册用户态和内核态的共享 buffer。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTcstdio></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTcstring></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTfcntl.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTliburing.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTliburing/io_uring.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>  <span class=keyword>constexpr</span> <span class=keyword>int</span> BUFFER_SIZE = <span class=number>4096</span>;</span><br><span class=line>  <span class=comment>// 初始化io_uring实例</span></span><br><span class=line>  <span class=class><span class=keyword>struct</span> <span class=title>io_uring</span> <span class=title>ring</span>;</span></span><br><span class=line>  <span class=keyword>char</span> buffer[BUFFER_SIZE];</span><br><span class=line>  <span class=keyword>int</span> fd;</span><br><span class=line>  <span class=keyword>if</span> (<span class=built_in>io_uring_queue_init</span>(<span class=number>8</span>, &ring, <span class=number>0</span>) < <span class=number>0</span>) {</span><br><span class=line>    <span class=built_in>perror</span>(<span class=string>"io_uring_queue_init"</span>);</span><br><span class=line>    <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  fd = <span class=built_in>open</span>(<span class=string>"output.txt"</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class=number>0644</span>);</span><br><span class=line>  <span class=keyword>if</span> (fd < <span class=number>0</span>) {</span><br><span class=line>    <span class=built_in>perror</span>(<span class=string>"open"</span>);</span><br><span class=line>    <span class=built_in>io_uring_queue_exit</span>(&ring);</span><br><span class=line>    <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>  }</span><br><span class=line>  <span class=built_in>memset</span>(buffer, <span class=string>'A'</span>, BUFFER_SIZE); <span class=comment>// 填充缓冲区为字符 'A'</span></span><br><span class=line>  <span class=class><span class=keyword>struct</span> <span class=title>io_uring_sqe</span> *<span class=title>sqe</span> =</span> <span class=built_in>io_uring_get_sqe</span>(&ring);</span><br><span class=line>  <span class=keyword>if</span> (!sqe) {</span><br><span class=line>    <span class=built_in>perror</span>(<span class=string>"io_uring_get_sqe"</span>);</span><br><span class=line>    <span class=built_in>close</span>(fd);</span><br><span class=line>    <span class=built_in>io_uring_queue_exit</span>(&ring);</span><br><span class=line>    <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>  }</span><br><span class=line>  <span class=comment>// 准备写入请求</span></span><br><span class=line>  <span class=built_in>io_uring_prep_write</span>(sqe, fd, buffer, BUFFER_SIZE, <span class=number>0</span>);</span><br><span class=line>  sqe->user_data = <span class=number>1</span>; <span class=comment>// 设置用户数据</span></span><br><span class=line>  <span class=comment>// 提交请求</span></span><br><span class=line>  <span class=keyword>if</span> (<span class=built_in>io_uring_submit</span>(&ring) < <span class=number>0</span>) {</span><br><span class=line>    <span class=built_in>perror</span>(<span class=string>"io_uring_submit"</span>);</span><br><span class=line>    <span class=built_in>close</span>(fd);</span><br><span class=line>    <span class=built_in>io_uring_queue_exit</span>(&ring);</span><br><span class=line>    <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>  }</span><br><span class=line>  <span class=built_in>printf</span>(<span class=string>"Asynchronous write operation initiated.\n"</span>);</span><br><span class=line></span><br><span class=line>  <span class=class><span class=keyword>struct</span> <span class=title>io_uring_cqe</span> *<span class=title>cqe</span>;</span></span><br><span class=line>  <span class=keyword>if</span> (<span class=built_in>io_uring_wait_cqe</span>(&ring, &cqe) < <span class=number>0</span>) {</span><br><span class=line>    <span class=built_in>perror</span>(<span class=string>"io_uring_wait_cqe"</span>);</span><br><span class=line>    <span class=built_in>close</span>(fd);</span><br><span class=line>    <span class=built_in>io_uring_queue_exit</span>(&ring);</span><br><span class=line>    <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>if</span> (cqe->res < <span class=number>0</span>) {</span><br><span class=line>    <span class=built_in>fprintf</span>(stderr, <span class=string>"Error: %s\n"</span>, <span class=built_in>strerror</span>(-cqe->res));</span><br><span class=line>  } <span class=keyword>else</span> {</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Write completed successfully.\n"</span>);</span><br><span class=line>  }</span><br><span class=line>  <span class=built_in>io_uring_cqe_seen</span>(&ring, cqe); <span class=comment>// 标记完成事件为已处理</span></span><br><span class=line>  <span class=built_in>close</span>(fd);</span><br><span class=line>  <span class=built_in>io_uring_queue_exit</span>(&ring); <span class=comment>// 清理io_uring实例</span></span><br><span class=line>  <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>每一个io_uring实例，都会被分配一个fd，该过程是通过io_uring_setup()系统调用实现的。<p>io_uring_setup()调用会根据用户提供的参数，分配一块共享内存。<p>这块共享内存中，包含了一个SQ（提交队列）、一个CQ（完成队列）和一个SQE（提交实体）数组。<p>其中，SQ和CQ是两个环形队列，队列中的元素是SQE在SQE数组中的偏移量，使用这种方式可以使得提交实体能够被随机访问，提高灵活性。<p>io_uring_setup()调用返回的fd，该内存可以通过mmap()的方式映射到用户态<p>用户从CQ的头部获取SEQ，将想要执行的操作（如文件的读写）初始化到其中，并添加到SQ队列的尾部，然后使用io_uring_enter()系统调用来进行提交队列的处理。<p>用户态和内核态共享 提交队列（submission queue）和 完成队列（completion queue），这两条队列通过mmap共享，高效且安全。<p>提交队列（SQ）给内核源源不断的布置任务，然后从另外一条队列完成队列（CQ）获取结果；<p>内核则按需进行 epoll()，并在一个线程池中执行就绪的任务。<p>用户态支持Polling模式，不会发生中断，也就没有系统调用，通过轮询即可消费事件；<p>内核态也支持Polling模式，同样不会发生上下文切换。<p>可以看出关键的设计在于，内核通过一块和用户共享的内存区域进行消息的传递，可以绕过Linux 的 syscall 机制。<p>内核会从SQ中依次取出对应的io request 提交实体，并根据io request 提交实体中定义的动作来执行对应的操作。由于用户只操作SQ尾部，而内核只操作头部，因此两者对于共享队列的访问并不会产生冲突，节省了锁的开销。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>io_uring</span> {</span></span><br><span class=line>	<span class=class><span class=keyword>struct</span> <span class=title>io_uring_sq</span> <span class=title>sq</span>;</span></span><br><span class=line>	<span class=class><span class=keyword>struct</span> <span class=title>io_uring_cq</span> <span class=title>cq</span>;</span></span><br><span class=line>	<span class=keyword>unsigned</span> flags;</span><br><span class=line>	<span class=keyword>int</span> ring_fd; <span class=comment>// id</span></span><br><span class=line></span><br><span class=line>	<span class=keyword>unsigned</span> features;</span><br><span class=line>	<span class=keyword>unsigned</span> pad[<span class=number>3</span>];</span><br><span class=line>}; <span class=comment>// io_uring结构</span></span><br></pre></table></figure><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>io_uring_sq</span> {</span> <span class=comment>// 提交队列</span></span><br><span class=line>	<span class=keyword>unsigned</span> *khead;</span><br><span class=line>	<span class=keyword>unsigned</span> *ktail;</span><br><span class=line>	<span class=keyword>unsigned</span> *kring_mask;</span><br><span class=line>	<span class=keyword>unsigned</span> *kring_entries;</span><br><span class=line>	<span class=keyword>unsigned</span> *kflags;</span><br><span class=line>	<span class=keyword>unsigned</span> *kdropped;</span><br><span class=line>	<span class=keyword>unsigned</span> *array;</span><br><span class=line>	<span class=class><span class=keyword>struct</span> <span class=title>io_uring_sqe</span> *<span class=title>sqes</span>;</span></span><br><span class=line></span><br><span class=line>	<span class=keyword>unsigned</span> sqe_head;</span><br><span class=line>	<span class=keyword>unsigned</span> sqe_tail;</span><br><span class=line></span><br><span class=line>	<span class=keyword>size_t</span> ring_sz;</span><br><span class=line>	<span class=keyword>void</span> *ring_ptr;</span><br><span class=line></span><br><span class=line>	<span class=keyword>unsigned</span> pad[<span class=number>4</span>];</span><br><span class=line>};</span><br></pre></table></figure><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>io_uring_sqe</span> {</span> <span class=comment>// 提交队列entry</span></span><br><span class=line>	__u8	opcode;		<span class=comment>/* type of operation for this sqe */</span></span><br><span class=line>	__u8	flags;		<span class=comment>/* IOSQE_ flags */</span></span><br><span class=line>	__u16	ioprio;		<span class=comment>/* ioprio for the request */</span></span><br><span class=line>	__s32	fd;		<span class=comment>/* file descriptor to do IO on */</span></span><br><span class=line>	<span class=class><span class=keyword>union</span> {</span></span><br><span class=line>		__u64	off;	<span class=comment>/* offset into file */</span></span><br><span class=line>		__u64	addr2;</span><br><span class=line>	};</span><br><span class=line>	<span class=class><span class=keyword>union</span> {</span></span><br><span class=line>		__u64	addr;	<span class=comment>/* pointer to buffer or iovecs */</span></span><br><span class=line>		__u64	splice_off_in;</span><br><span class=line>	};</span><br><span class=line>	__u32	len;		<span class=comment>/* buffer size or number of iovecs */</span></span><br><span class=line>	<span class=class><span class=keyword>union</span> {</span></span><br><span class=line>		<span class=keyword>__kernel_rwf_t</span>	rw_flags;</span><br><span class=line>		__u32		fsync_flags;</span><br><span class=line>		__u16		poll_events;	<span class=comment>/* compatibility */</span></span><br><span class=line>		__u32		poll32_events;	<span class=comment>/* word-reversed for BE */</span></span><br><span class=line>		__u32		sync_range_flags;</span><br><span class=line>		__u32		msg_flags;</span><br><span class=line>		__u32		timeout_flags;</span><br><span class=line>		__u32		accept_flags;</span><br><span class=line>		__u32		cancel_flags;</span><br><span class=line>		__u32		open_flags;</span><br><span class=line>		__u32		statx_flags;</span><br><span class=line>		__u32		fadvise_advice;</span><br><span class=line>		__u32		splice_flags;</span><br><span class=line>		__u32		rename_flags;</span><br><span class=line>		__u32		unlink_flags;</span><br><span class=line>		__u32		hardlink_flags;</span><br><span class=line>	};</span><br><span class=line>	__u64	user_data;	<span class=comment>/* data to be passed back at completion time */</span></span><br><span class=line>	<span class=comment>/* pack this to avoid bogus arm OABI complaints */</span></span><br><span class=line>	<span class=class><span class=keyword>union</span> {</span></span><br><span class=line>		<span class=comment>/* index into fixed buffers, if used */</span></span><br><span class=line>		__u16	buf_index;</span><br><span class=line>		<span class=comment>/* for grouped buffer selection */</span></span><br><span class=line>		__u16	buf_group;</span><br><span class=line>	} __attribute__((packed));</span><br><span class=line>	<span class=comment>/* personality to use, if used */</span></span><br><span class=line>	__u16	personality;</span><br><span class=line>	<span class=class><span class=keyword>union</span> {</span></span><br><span class=line>		__s32	splice_fd_in;</span><br><span class=line>		__u32	file_index;</span><br><span class=line>	};</span><br><span class=line>	__u64	__pad2[<span class=number>2</span>];</span><br><span class=line>};</span><br></pre></table></figure><h2 id=Epoll事件的Channel类><a class=headerlink href=#Epoll事件的Channel类 title=Epoll事件的Channel类></a>Epoll事件的Channel类</h2><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>typedef</span> <span class=class><span class=keyword>union</span> <span class=title>epoll_data</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>  <span class=keyword>void</span> *ptr;</span><br><span class=line>  <span class=keyword>int</span> fd;</span><br><span class=line>  <span class=keyword>uint32_t</span> u32;</span><br><span class=line>  <span class=keyword>uint64_t</span> u64;</span><br><span class=line>} <span class=keyword>epoll_data_t</span>;</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>epoll_event</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>  <span class=keyword>uint32_t</span> events;	<span class=comment>/* Epoll events */</span></span><br><span class=line>  <span class=keyword>epoll_data_t</span> data;	<span class=comment>/* User data variable */</span></span><br><span class=line>} __EPOLL_PACKED;</span><br></pre></table></figure><p>epoll时间和数据如上,events为要监听的事件,比如EPOLLIN,EPOLLLT等.<p>绪状态。<code>enum EPOLL_EVENTS</code> 定义了一系列的标志位，用于指定感兴趣的事件类型或报告发生的事件。下面是一些常用的 <code>EPOLL_EVENTS</code> 常量及其用途：<ul><li><strong><code>EPOLLIN (0x001)</code></strong>：表示对应的文件描述符可以读取（即有数据可读）。<li><strong><code>EPOLLOUT (0x004)</code></strong>：表示对应的文件描述符可以写入（即准备好接受数据写入）。<li><strong><code>EPOLLPRI (0x002)</code></strong>：表示对应文件描述符有紧急数据可读（带外数据）。这在处理 TCP 紧急指针时有用。<li><strong><code>EPOLLERR (0x008)</code></strong>：表示对应的文件描述符发生了错误。这个事件总是会被监控，无需显式地将其加入到感兴趣的事件集合中。<li><strong><code>EPOLLHUP (0x010)</code></strong>：表示对应的文件描述符被挂起（即连接被关闭）。与 <code>EPOLLERR</code> 类似，此事件也会自动被监控。<li><strong><code>EPOLLRDHUP (0x2000)</code></strong>：自 Linux 2.6.17 起可用，表示对端关闭了连接或者关闭了写入一半的连接。这对于检测对等方关闭连接特别有用。</ul><p>此外，还有一些不太常用但同样重要的事件：<ul><li><strong><code>EPOLLET (1u << 31)</code></strong>：设置边缘触发模式。默认情况下，<code>epoll</code> 使用水平触发模式；当启用边缘触发模式后，只有在文件描述符的状态发生变化时才会触发事件通知，而不是每次轮询都可能返回就绪状态。<li><strong><code>EPOLLONESHOT (1u << 30)</code></strong>：一旦被指定的文件描述符上的事件发生并被处理后，相应的文件描述符将不再处于监听状态。要再次监听该文件描述符上的事件，需要重新添加到 <code>epoll</code> 实例中。<li><strong><code>EPOLLEXCLUSIVE (1u << 28)</code></strong>：从 Linux 内核 4.5 开始支持，允许多个 <code>epoll</code> 实例独立地监听同一个文件描述符。这样可以避免多个进程同时收到相同的事件通知，从而减少竞争条件。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>enum</span> <span class=title>EPOLL_EVENTS</span></span></span><br><span class=line><span class=class>  {</span></span><br><span class=line>    EPOLLIN = <span class=number>0x001</span>,</span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> EPOLLIN EPOLLIN</span></span><br><span class=line>    EPOLLPRI = <span class=number>0x002</span>,</span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> EPOLLPRI EPOLLPRI</span></span><br><span class=line>    EPOLLOUT = <span class=number>0x004</span>,</span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> EPOLLOUT EPOLLOUT</span></span><br><span class=line>    EPOLLRDNORM = <span class=number>0x040</span>,</span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> EPOLLRDNORM EPOLLRDNORM</span></span><br><span class=line>    EPOLLRDBAND = <span class=number>0x080</span>,</span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> EPOLLRDBAND EPOLLRDBAND</span></span><br><span class=line>    EPOLLWRNORM = <span class=number>0x100</span>,</span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> EPOLLWRNORM EPOLLWRNORM</span></span><br><span class=line>    EPOLLWRBAND = <span class=number>0x200</span>,</span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> EPOLLWRBAND EPOLLWRBAND</span></span><br><span class=line>    EPOLLMSG = <span class=number>0x400</span>,</span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> EPOLLMSG EPOLLMSG</span></span><br><span class=line>    EPOLLERR = <span class=number>0x008</span>,</span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> EPOLLERR EPOLLERR</span></span><br><span class=line>    EPOLLHUP = <span class=number>0x010</span>,</span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> EPOLLHUP EPOLLHUP</span></span><br><span class=line>    EPOLLRDHUP = <span class=number>0x2000</span>,</span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> EPOLLRDHUP EPOLLRDHUP</span></span><br><span class=line>    EPOLLEXCLUSIVE = <span class=number>1u</span> << <span class=number>28</span>,</span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> EPOLLEXCLUSIVE EPOLLEXCLUSIVE</span></span><br><span class=line>    EPOLLWAKEUP = <span class=number>1u</span> << <span class=number>29</span>,</span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> EPOLLWAKEUP EPOLLWAKEUP</span></span><br><span class=line>    EPOLLONESHOT = <span class=number>1u</span> << <span class=number>30</span>,</span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> EPOLLONESHOT EPOLLONESHOT</span></span><br><span class=line>    EPOLLET = <span class=number>1u</span> << <span class=number>31</span></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> EPOLLET EPOLLET</span></span><br><span class=line>  };</span><br><span class=line></span><br></pre></table></figure><p>既然可以传一个void*指针,那么可以设计一个Channel类,这个类可以包含监听的fd以及对应的事件等信息. 同时可以设计回调方法,对于server_fd,回调方法可以为接收客户端fd,客户端channel回调方法为读取数据.<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Channel</span>{</span></span><br><span class=line><span class=keyword>private</span>:</span><br><span class=line>    Epoll *ep;</span><br><span class=line>    <span class=keyword>int</span> fd;</span><br><span class=line>    <span class=keyword>uint32_t</span> events;</span><br><span class=line>    <span class=keyword>uint32_t</span> revents;</span><br><span class=line>    <span class=keyword>bool</span> inEpoll;</span><br><span class=line>};</span><br></pre></table></figure><blockquote><p>显然每个文件描述符会被分发到一个<code>Epoll</code>类，用一个<code>ep</code>指针来指向。类中还有这个<code>Channel</code>负责的文件描述符。另外是两个事件变量，<code>events</code>表示希望监听这个文件描述符的哪些事件，因为不同事件的处理方式不一样。<code>revents</code>表示在<code>epoll</code>返回该<code>Channel</code>时文件描述符正在发生的事件。<code>inEpoll</code>表示当前<code>Channel</code>是否已经在<code>epoll</code>红黑树中，为了注册<code>Channel</code>的时候方便区分使用<code>EPOLL_CTL_ADD</code>还是<code>EPOLL_CTL_MOD</code>。</blockquote><h2 id=服务器与事件驱动核心类><a class=headerlink href=#服务器与事件驱动核心类 title=服务器与事件驱动核心类></a>服务器与事件驱动核心类</h2><p><a href=https://github.com/yuesong-feng/30dayMakeCppServer/blob/main/day06-服务器与事件驱动核心类登场.md rel=noopener target=_blank>30dayMakeCppServer/day06-服务器与事件驱动核心类登场.md at main · yuesong-feng/30dayMakeCppServer</a><blockquote><p>目前从新建socket、接受客户端连接到处理客户端事件，整个程序结构是顺序化、流程化的，我们甚至可以使用一个单一的流程图来表示整个程序。而流程化程序设计的缺点之一是不够抽象，<strong>当我们的服务器结构越来越庞大、功能越来越复杂、模块越来越多，这种顺序程序设计的思想显然是不能满足需求的。</strong><p>对于服务器开发，我们需要用到更抽象的设计模式。从代码中我们可以看到，不管是接受客户端连接还是处理客户端事件，都是围绕epoll来编程，可以说epoll是整个程序的核心，服务器做的事情就是监听epoll上的事件，然后对不同事件类型进行不同的处理。这种以事件为核心的模式又叫事件驱动，事实上几乎所有的现代服务器都是事件驱动的。和传统的请求驱动模型有很大不同，事件的捕获、通信、处理和持久保留是解决方案的核心结构。libevent就是一个著名的C语言事件驱动库。</blockquote><p><img alt=image-20250426144343174 data-src=https://s2.loli.net/2025/04/26/Z5JHSabqlVtiUCG.png><h3 id=Acceptor类><a class=headerlink href=#Acceptor类 title=Acceptor类></a>Acceptor类</h3><p>当server socket监听到事件时,需要做的就是通过accept函数创建新连接,这需要server的socket.<blockquote><p>对于每一个事件，不管提供什么样的服务，首先需要做的事都是调用<code>accept()</code>函数接受这个TCP连接，然后将socket文件描述符添加到epoll。当这个IO口有事件发生的时候，再对此TCP连接提供相应的服务。</blockquote><p>Acceptor可以设置回调函数.在Server中设置Acceptor回调函数为接收客户端连接并将fd加入epoll中,并设置相关回调函数.<p>Acceptor设置回调函数就是为channel设置回调<p><code>Acceptor</code>类最主要的三个特点：<ul><li>类存在于事件驱动<code>EventLoop</code>类中，也就是Reactor模式的main-Reactor<li>类中的socket fd就是服务器监听的socket fd，每一个Acceptor对应一个socket fd<li>这个类也通过一个独有的<code>Channel</code>负责分发到epoll，该Channel的事件处理函数<code>handleEvent()</code>会调用Acceptor中的接受连接函数来新建一个TCP连接</ul><h3 id=Connection连接类><a class=headerlink href=#Connection连接类 title=Connection连接类></a>Connection连接类</h3><p>对于TCP协议，三次握手新建连接后，这个连接将会一直存在，直到我们四次挥手断开连接。因此，我们也可以把TCP连接抽象成一个<code>Connection</code>类，这个类也有以下几个特点：<ul><li>类存在于事件驱动<code>EventLoop</code>类中，也就是Reactor模式的main-Reactor<li>类中的socket fd就是客户端的socket fd，每一个Connection对应一个socket fd<li>每一个类的实例通过一个独有的<code>Channel</code>负责分发到epoll，该Channel的事件处理函数<code>handleEvent()</code>会调用Connection中的事件处理函数来响应客户端请求</ul><p>可以看到，<code>Connection</code>类和<code>Acceptor</code>类是平行关系、十分相似，他们都直接由<code>Server</code>管理，由一个<code>Channel</code>分发到epoll，通过回调函数处理相应事件。唯一的不同在于，<code>Acceptor</code>类的处理事件函数（也就是新建连接功能）被放到了<code>Server</code>类中，而<code>Connection</code>类则没有必要这么做，处理事件的逻辑应该由<code>Connection</code>类本身来完成。<h3 id=Buffer类><a class=headerlink href=#Buffer类 title=Buffer类></a>Buffer类</h3><p>之前的读数据部分,都是读取之后立即写入.但是在ET模式下,当errno=EAGAIN才表示没有数据可读取,这时将之间读取的数据进行写入.<br>可以封装一个buffer类,每次读取数据<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>pragma</span> once</span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring></span></span></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Buffer</span> {</span></span><br><span class=line></span><br><span class=line><span class=keyword>private</span>:</span><br><span class=line>  std::string buffer;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>  <span class=function><span class=keyword>const</span> <span class=keyword>char</span> *<span class=title>data</span><span class=params>()</span> </span>{ <span class=keyword>return</span> buffer.<span class=built_in>c_str</span>(); }</span><br><span class=line>  <span class=function><span class=keyword>size_t</span> <span class=title>size</span><span class=params>()</span> </span>{ <span class=keyword>return</span> buffer.<span class=built_in>size</span>(); }</span><br><span class=line>  <span class=function><span class=keyword>void</span> <span class=title>append</span><span class=params>(<span class=keyword>const</span> <span class=keyword>char</span> *data, <span class=keyword>size_t</span> size)</span> </span>{ buffer.<span class=built_in>append</span>(data, size); }</span><br><span class=line>  <span class=function><span class=keyword>void</span> <span class=title>append</span><span class=params>(<span class=keyword>const</span> std::string &buf, <span class=keyword>size_t</span> size)</span> </span>{ buffer.<span class=built_in>append</span>(buf); }</span><br><span class=line>  <span class=function><span class=keyword>void</span> <span class=title>clear</span><span class=params>()</span> </span>{ buffer.<span class=built_in>clear</span>(); }</span><br><span class=line>  <span class=function><span class=keyword>void</span> <span class=title>resize</span><span class=params>(<span class=keyword>size_t</span> size)</span> </span>{ buffer.<span class=built_in>resize</span>(size); }</span><br><span class=line>};</span><br></pre></table></figure><h3 id=增加线程池><a class=headerlink href=#增加线程池 title=增加线程池></a>增加线程池</h3><blockquote><p>观察当前的服务器架构，不难发现我们的Reactor模型少了最关键、最重要的一个模块：线程池。当发现socket fd有事件时，我们应该分发给一个工作线程，由这个工作线程处理fd上面的事件。而当前我们的代码是单线程模式，所有fd上的事件都由主线程（也就是EventLoop线程）处理，这是大错特错的，试想如果每一个事件相应需要1秒时间，那么当1000个事件同时到来，EventLoop线程将会至少花费1000秒来传输数据，还有函数调用等其他开销，服务器将直接宕机。</blockquote><p>线程池需要一个任务队列,工作线程,以及线程同步机制.<p>任务队列是一个生产者-消费者队列,通过mutex,condition_variable进行线程同步与通信. 工作线程不断地从队列中取出任务并执行.<p>这个线程池只是为了满足我们的需要构建出的最简单的线程池，存在很多问题。比如，<strong>由于任务队列的添加、取出都存在拷贝操作，线程池不会有太好的性能</strong>，只能用来学习，正确做法是<strong>使用右值移动、完美转发等阻止拷贝</strong>。另外线程池只能接受<code>std::function&LTvoid()></code>类型的参数，所以函数参数需要事先使用<code>std::bind()</code>，并且<strong>无法得到返回值</strong>。<p>对于<code>Acceptor</code>，接受连接的处理时间较短、报文数据极小，并且一般不会有特别多的新连接在同一时间到达，所以<code>Acceptor</code>没有必要采用epoll ET模式，也没有必要用线程池。由于不会成为性能瓶颈，为了简单最好使用阻塞式socket，故今天的源代码中做了以下改变：<ol><li>Acceptor socket fd（服务器监听socket）使用阻塞式<li>Acceptor使用LT模式，建立好连接后处理事件fd读写用ET模式<li>Acceptor建立连接不使用线程池，建立好连接后处理事件用线程池</ol><h3 id=多线程Reactor模式><a class=headerlink href=#多线程Reactor模式 title=多线程Reactor模式></a>多线程Reactor模式</h3><p><img alt=image-20250427174511232 data-src=https://s2.loli.net/2025/04/27/7iDBW3cvdCEsyao.png><h3 id=主从Reactor多线程模式><a class=headerlink href=#主从Reactor多线程模式 title=主从Reactor多线程模式></a>主从Reactor多线程模式</h3><p><img alt=image-20250427225106232 data-src=https://s2.loli.net/2025/04/27/IcbnHVp9faBzWmP.png><h3 id=增加多平台支持><a class=headerlink href=#增加多平台支持 title=增加多平台支持></a>增加多平台支持</h3><p>BSD系列操作系统提供了<code>kqueue</code>. <code>kqueue</code> 是一种高性能的事件通知接口，主要用于 BSD 系列操作系统（如 FreeBSD、macOS 和 OpenBSD）中。它提供了一种机制来高效地监视多个文件描述符上的 I/O 事件（例如可读、可写等），以及异步 I/O 操作的状态变化。<ul><li><strong>kqueue</strong>：核心对象，用于注册感兴趣的事件，并从内核获取事件通知。<li><p><strong>kevent</strong>：表示一个事件或事件类型。可以用来指定你感兴趣的事件（如文件描述符变为可读），也可以用来报告已发生的事件。</p> <p>主要用途</p></ul><p><strong>(1) 监视文件描述符</strong><ul><li>可以监视文件描述符上的各种事件，比如：<ul><li>文件描述符是否可读 (<code>EVFILT_READ</code>)<li>文件描述符是否可写 (<code>EVFILT_WRITE</code>)<li>文件元数据改变 (<code>EVFILT_VNODE</code>)<li>进程信号 (<code>EVFILT_PROC</code>)</ul></ul><p><strong>(2) 异步 I/O 通知</strong><ul><li>支持异步 I/O 操作的通知机制，允许应用程序在非阻塞模式下更高效地管理大量并发连接。</ul><p><strong>(3) 高效的事件分发</strong><ul><li>对比传统的轮询方式（如 <code>select()</code> 和 <code>poll()</code>），<code>kqueue</code> 提供了更高的性能和更好的扩展性，特别是在处理大量的文件描述符时。</ul><p><strong>(1) 创建 kqueue</strong><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>int</span> kq = kqueue();</span><br><span class=line><span class=keyword>if</span> (kq == <span class=number>-1</span>) {</span><br><span class=line>    perror(<span class=string>"kqueue"</span>);</span><br><span class=line>    <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>}</span><br></pre></table></figure><p><strong>(2) 设置 kevent</strong><p>定义感兴趣的事件，并将其添加到 <code>kqueue</code> 中。例如，监视一个套接字是否可读：<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>kevent</span> <span class=title>change</span>;</span></span><br><span class=line>EV_SET(&change, sockfd, EVFILT_READ, EV_ADD, <span class=number>0</span>, <span class=number>0</span>, <span class=literal>NULL</span>);</span><br><span class=line></span><br><span class=line><span class=keyword>if</span> (kevent(kq, &change, <span class=number>1</span>, <span class=literal>NULL</span>, <span class=number>0</span>, <span class=literal>NULL</span>) == <span class=number>-1</span>) {</span><br><span class=line>    perror(<span class=string>"kevent register"</span>);</span><br><span class=line>    close(kq);</span><br><span class=line>    <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>}</span><br></pre></table></figure><p><strong>(3) 等待事件发生</strong><p>调用 <code>kevent()</code> 来等待事件的发生并处理它们：<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>kevent</span> <span class=title>event</span>;</span></span><br><span class=line><span class=keyword>int</span> nev = kevent(kq, <span class=literal>NULL</span>, <span class=number>0</span>, &event, <span class=number>1</span>, <span class=literal>NULL</span>);</span><br><span class=line><span class=keyword>if</span> (nev == <span class=number>-1</span>) {</span><br><span class=line>    perror(<span class=string>"kevent wait"</span>);</span><br><span class=line>    close(kq);</span><br><span class=line>    <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>} <span class=keyword>else</span> <span class=keyword>if</span> (nev > <span class=number>0</span>) {</span><br><span class=line>    <span class=keyword>if</span> (event.filter == EVFILT_READ) {</span><br><span class=line>        <span class=comment>// 处理可读事件</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=解决Connection生命周期问题><a class=headerlink href=#解决Connection生命周期问题 title=解决Connection生命周期问题></a>解决Connection生命周期问题</h3><p>当在处理connection连接关闭时,会在回调中移除connnection,这样会调用对应析构函数,但此时仍然在connection的channel的<code>handleEvent</code>方法中.<blockquote><p>在当前状态下，在创建<code>TcpConnection</code>会将其加入到<code>connectionsMap_</code>使其引用计数变成了<code>1</code>，之后当<code>TcpConnection</code>处理<code>HandleEvent</code>受到关闭信号时，会直接调用<code>HandleClose</code>，这时会将<code>TcpConnection</code>从<code>connectionsMaps_</code>释放，引用计数变成<code>0</code>，直接销毁，但是<code>HandleEvent</code>并没有处理结束，从而导致了内存泄漏。</blockquote><p>增加的两点处理: 在处理事件之前,增加connection的引用计数,这样即使在connectionMap中移除连接,也不会直接释放内存. 此外在每次轮询epoll并处理完事件之后,统一执行一系列回调方法,这样就保证在channel的方法之外进行处理. 在handclose时向eventloop的toDoList中添加一个后处理方法,方法中可以将fd从epoll中移除<p>除了解决上面析构的生命周期、内存问题,此外如果mainReactor正要加入connection,而此时相同的eventloop中另一个连接要断开. 由于此时线程不同,存在不同线程读写问题,std::map不安全. 可以考虑在增删时加锁,或者将移除操作放在mainReactor的eventloop的toDoList中,相当于将移除connectionMap操作放在了最后. 如果处理的线程与mainReactor相同(主线程),就可以直接移除.<p>另外存在一个问题,由于移除连接交给了mainReacotr(避免connectionMap线程冲突操作),当有多个连接关闭任务放在mainReacotor的toDoList时,如果其阻塞在epoll_wait就会对性能造成影响,因此可以使用<code>eventfd</code>进行事件通知,类似一个文件描述符,可以加入epoll中并进行读写操作,这可以实现异步唤醒. 每当有Connection进行关闭时,由mainReactor执行,将回调加入toDoList后同时向mainReactor的对应eventfd写入,此时主线程(监听serverfd的EventLoop)就会执行eventfd的channel设置的都操作进行唤醒,然后执行toDoList.<h2 id=第三方库><a class=headerlink href=#第三方库 title=第三方库></a>第三方库</h2><p><a href=https://zhuanlan.zhihu.com/p/611847234 rel=noopener target=_blank>网络I/O库总结（libevent,libuv,libev,libeio） - 知乎</a><ul><li><a href=https://github.com/libuv/libuv rel=noopener target=_blank>libuv/libuv: Cross-platform asynchronous I/O</a><a href=https://github.com/enki/libev rel=noopener target=_blank>enki/libev: Full-featured high-performance event loop loosely modelled after libevent</a><li><a href=https://github.com/libevent/libevent rel=noopener target=_blank>libevent/libevent: Event notification library</a><li><a href=https://think-async.com/Asio/ rel=noopener target=_blank>Asio C++ Library</a></ul><h2 id=其他><a class=headerlink href=#其他 title=其他></a>其他</h2><h3 id=在windows上的异步I-O机制><a class=headerlink href=#在windows上的异步I-O机制 title=在windows上的异步I/O机制></a>在windows上的异步I/O机制</h3><p>异步 I/O（Asynchronous I/O）是一种高效的机制，用于处理文件、网络套接字等设备的输入输出操作.Windows 提供了多种实现异步 I/O 的方式，包括 <strong>Overlapped I/O</strong> 和 <strong>I/O Completion Ports (IOCP)</strong>。<h4 id=Overlapped-I-O><a title="Overlapped I/O" class=headerlink href=#Overlapped-I-O></a><strong>Overlapped I/O</strong></h4><p><strong>概述</strong><p>Overlapped I/O 是 Windows 提供的一种异步 I/O 机制，它通过使用 <code>OVERLAPPED</code> 结构体来标记一个 I/O 操作是否为异步。这种机制适用于文件操作和套接字通信。<ul><li>如果一个文件句柄或套接字是以重叠（Overlapped）模式打开的，则可以对其进行异步操作。<li>异步操作完成后，可以通过以下方式通知应用程序：<ul><li>使用事件对象（Event Object）。<li>调用回调函数（Completion Routine）。<li>使用 I/O 完成端口（IOCP）。</ul></ul><p><strong>关键函数</strong><ul><li><strong><code>ReadFile</code> / <code>WriteFile</code></strong>：用于读写文件或套接字。<li><strong><code>GetOverlappedResult</code></strong>：检查异步操作的状态。<li><strong><code>CancelIoEx</code></strong>：取消挂起的异步 I/O 操作。</ul><p><strong>示例代码</strong><p>以下是一个使用 Overlapped I/O 进行异步文件读取的示例：<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTwindows.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>AsyncFileRead</span><span class=params>()</span> </span>{</span><br><span class=line>    HANDLE hFile = CreateFile(</span><br><span class=line>        <span class=string>"example.txt"</span>,                  <span class=comment>// 文件名</span></span><br><span class=line>        GENERIC_READ,                   <span class=comment>// 打开文件用于读取</span></span><br><span class=line>        <span class=number>0</span>,                              <span class=comment>// 不共享</span></span><br><span class=line>        <span class=literal>NULL</span>,                           <span class=comment>// 默认安全属性</span></span><br><span class=line>        OPEN_EXISTING,                  <span class=comment>// 打开已存在的文件</span></span><br><span class=line>        FILE_FLAG_OVERLAPPED,           <span class=comment>// 启用 Overlapped I/O</span></span><br><span class=line>        <span class=literal>NULL</span>                            <span class=comment>// 无模板文件</span></span><br><span class=line>    );</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (hFile == INVALID_HANDLE_VALUE) {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Failed to open file. Error: %d\n"</span>, GetLastError());</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>char</span> buffer[<span class=number>1024</span>];</span><br><span class=line>    OVERLAPPED overlapped = {<span class=number>0</span>};</span><br><span class=line>    overlapped.hEvent = CreateEvent(<span class=literal>NULL</span>, TRUE, FALSE, <span class=literal>NULL</span>); <span class=comment>// 创建事件对象</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (!ReadFile(hFile, buffer, <span class=keyword>sizeof</span>(buffer), <span class=literal>NULL</span>, &overlapped)) {</span><br><span class=line>        <span class=keyword>if</span> (GetLastError() != ERROR_IO_PENDING) {</span><br><span class=line>            <span class=built_in>printf</span>(<span class=string>"ReadFile failed. Error: %d\n"</span>, GetLastError());</span><br><span class=line>            CloseHandle(hFile);</span><br><span class=line>            CloseHandle(overlapped.hEvent);</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 等待异步操作完成</span></span><br><span class=line>    WaitForSingleObject(overlapped.hEvent, INFINITE);</span><br><span class=line></span><br><span class=line>    DWORD bytesRead;</span><br><span class=line>    <span class=keyword>if</span> (GetOverlappedResult(hFile, &overlapped, &bytesRead, FALSE)) {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Read %d bytes: %.*s\n"</span>, bytesRead, bytesRead, buffer);</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"GetOverlappedResult failed. Error: %d\n"</span>, GetLastError());</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    CloseHandle(hFile);</span><br><span class=line>    CloseHandle(overlapped.hEvent);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    AsyncFileRead();</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><ul><li>Overlapped I/O 是 Windows 中最基础的异步 I/O 实现方式之一。它通过 <code>OVERLAPPED</code> 结构体来标记一个 I/O 操作是否为异步。<li>当使用重叠模式打开文件或套接字时，可以发起异步操作，并且在操作完成前继续执行其他代码。</ul><p><strong>关键函数</strong><ul><li><strong><code>CreateFile</code></strong>：创建或打开文件时指定 <code>FILE_FLAG_OVERLAPPED</code> 标志以启用重叠模式。<li><strong><code>ReadFile</code> / <code>WriteFile</code></strong>：用于读取或写入数据。对于异步操作，最后一个参数应指向一个有效的 <code>OVERLAPPED</code> 结构体。<li><strong><code>GetOverlappedResult</code></strong>：获取异步操作的结果。<li><strong><code>WaitForSingleObject</code> 或 <code>WaitForMultipleObjects</code></strong>：等待异步操作完成。</ul><h4 id=回调函数><a class=headerlink href=#回调函数 title=回调函数></a>回调函数</h4><p>在 Windows 中，回调函数通常通过 <code>ReadFileEx</code> 或 <code>WriteFileEx</code> 函数注册，而不是直接使用 <code>ReadFile</code> 或 <code>WriteFile</code>。<p>回调函数的原型必须符合以下格式：<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=function>VOID CALLBACK <span class=title>CompletionRoutine</span><span class=params>(</span></span></span><br><span class=line><span class=params><span class=function>    DWORD dwErrorCode,       <span class=comment>// 错误码</span></span></span></span><br><span class=line><span class=params><span class=function>    DWORD dwNumberOfBytesTransfered, <span class=comment>// 转移的字节数</span></span></span></span><br><span class=line><span class=params><span class=function>    LPOVERLAPPED lpOverlapped        <span class=comment>// OVERLAPPED 结构体指针</span></span></span></span><br><span class=line><span class=params><span class=function>)</span></span>;</span><br></pre></table></figure><p><strong>使用 <code>ReadFileEx</code> 和 <code>WriteFileEx</code> 注册回调函数</strong><ul><li><code>ReadFileEx</code> 和 <code>WriteFileEx</code> 是专门用于异步 I/O 并支持回调函数的 API。<li>它们需要一个有效的 <code>OVERLAPPED</code> 结构体，并且文件句柄必须以重叠模式打开（即带有 <code>FILE_FLAG_OVERLAPPED</code> 标志）。<li><p>异步操作完成后，操作系统会调用指定的回调函数。</p><li><p>回调函数是一种轻量级的异步 I/O 处理方式，通过 <code>ReadFileEx</code> 和 <code>WriteFileEx</code> 函数注册回调函数，在操作完成后自动调用。</p><li>这种方式要求线程进入可提醒等待状态（Alertable Wait State），例如使用 <code>SleepEx</code> 函数。</ul><p><strong>关键函数</strong><ul><li><strong><code>ReadFileEx</code> / <code>WriteFileEx</code></strong>：用于启动异步 I/O 操作并注册回调函数。<li><strong><code>SleepEx</code></strong>：使当前线程进入可提醒等待状态，以便能够接收异步通知。</ul><p><strong>3. 示例代码</strong><p>以下是一个使用回调函数处理异步文件读取的完整示例：<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTwindows.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line></span><br><span class=line><span class=comment>// 回调函数定义</span></span><br><span class=line><span class=function>VOID CALLBACK <span class=title>FileIOCompletionRoutine</span><span class=params>(</span></span></span><br><span class=line><span class=params><span class=function>    DWORD dwErrorCode,</span></span></span><br><span class=line><span class=params><span class=function>    DWORD dwNumberOfBytesTransfered,</span></span></span><br><span class=line><span class=params><span class=function>    LPOVERLAPPED lpOverlapped)</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>    <span class=keyword>if</span> (dwErrorCode == <span class=number>0</span>) {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Asynchronous read completed successfully.\n"</span>);</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Number of bytes read: %d\n"</span>, dwNumberOfBytesTransfered);</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Asynchronous read failed with error code: %d\n"</span>, dwErrorCode);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>AsyncFileReadWithCallback</span><span class=params>()</span> </span>{</span><br><span class=line>    HANDLE hFile = CreateFile(</span><br><span class=line>        <span class=string>"example.txt"</span>,                  <span class=comment>// 文件名</span></span><br><span class=line>        GENERIC_READ,                   <span class=comment>// 打开文件用于读取</span></span><br><span class=line>        <span class=number>0</span>,                              <span class=comment>// 不共享</span></span><br><span class=line>        <span class=literal>NULL</span>,                           <span class=comment>// 默认安全属性</span></span><br><span class=line>        OPEN_EXISTING,                  <span class=comment>// 打开已存在的文件</span></span><br><span class=line>        FILE_FLAG_OVERLAPPED,           <span class=comment>// 启用 Overlapped I/O</span></span><br><span class=line>        <span class=literal>NULL</span>                            <span class=comment>// 无模板文件</span></span><br><span class=line>    );</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (hFile == INVALID_HANDLE_VALUE) {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Failed to open file. Error: %d\n"</span>, GetLastError());</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>char</span> buffer[<span class=number>1024</span>];</span><br><span class=line>    OVERLAPPED overlapped = {<span class=number>0</span>};</span><br><span class=line></span><br><span class=line>    <span class=comment>// 启动异步读取操作</span></span><br><span class=line>    BOOL result = ReadFileEx(</span><br><span class=line>        hFile,                          <span class=comment>// 文件句柄</span></span><br><span class=line>        buffer,                         <span class=comment>// 缓冲区</span></span><br><span class=line>        <span class=keyword>sizeof</span>(buffer),                 <span class=comment>// 要读取的字节数</span></span><br><span class=line>        &overlapped,                    <span class=comment>// OVERLAPPED 结构体</span></span><br><span class=line>        FileIOCompletionRoutine         <span class=comment>// 回调函数</span></span><br><span class=line>    );</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (!result) {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"ReadFileEx failed. Error: %d\n"</span>, GetLastError());</span><br><span class=line>        CloseHandle(hFile);</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 等待异步操作完成</span></span><br><span class=line>    SleepEx(INFINITE, TRUE); <span class=comment>// 进入可提醒等待状态，使回调函数得以执行</span></span><br><span class=line></span><br><span class=line>    CloseHandle(hFile);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    AsyncFileReadWithCallback();</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><h4 id=I-O-Completion-Ports-IOCP><a title="I/O Completion Ports (IOCP)" class=headerlink href=#I-O-Completion-Ports-IOCP></a>I/O Completion Ports (IOCP)</h4><p><strong>概述</strong><p>I/O Completion Ports（简称 IOCP）是 Windows 提供的一种高性能的异步 I/O 机制，特别适合于需要处理大量并发连接的服务器程序。IOCP 的核心思想是<strong>将多个 I/O 操作绑定到一个完成端口,并由一个线程池来处理完成的通知</strong>。<ul><li>IOCP 的优点：<ul><li>高效地管理多个并发 I/O 操作。<li>自动负载均衡，多个工作线程可以高效协作。<li>支持大规模并发连接。</ul></ul><p><strong>关键函数</strong><ul><li><strong><code>CreateIoCompletionPort</code></strong>：创建或关联一个完成端口。<li><strong><code>PostQueuedCompletionStatus</code></strong>：向完成端口队列提交自定义的完成包。<li><strong><code>GetQueuedCompletionStatus</code></strong>：从完成端口队列中获取完成通知。</ul><p><strong>示例代码</strong><p>以下是一个简单的 IOCP 示例，展示如何使用 IOCP 处理异步文件读取：<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTwindows.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line></span><br><span class=line><span class=keyword>typedef</span> <span class=class><span class=keyword>struct</span> {</span></span><br><span class=line>    OVERLAPPED overlapped;</span><br><span class=line>    <span class=keyword>char</span> buffer[<span class=number>1024</span>];</span><br><span class=line>} IO_CONTEXT;</span><br><span class=line></span><br><span class=line><span class=function>DWORD WINAPI <span class=title>WorkerThread</span><span class=params>(LPVOID lpParam)</span> </span>{</span><br><span class=line>    HANDLE hCompletionPort = (HANDLE)lpParam;</span><br><span class=line>    DWORD bytesTransferred;</span><br><span class=line>    ULONG_PTR completionKey;</span><br><span class=line>    LPOVERLAPPED pOverlapped;</span><br><span class=line></span><br><span class=line>    <span class=keyword>while</span> (<span class=literal>true</span>) {</span><br><span class=line>        BOOL result = GetQueuedCompletionStatus(</span><br><span class=line>            hCompletionPort, &bytesTransferred, &completionKey, &pOverlapped, INFINITE);</span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> (!result || bytesTransferred == <span class=number>0</span>) {</span><br><span class=line>            <span class=built_in>printf</span>(<span class=string>"Operation failed or completed.\n"</span>);</span><br><span class=line>            <span class=keyword>break</span>;</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        IO_CONTEXT *context = (IO_CONTEXT *)pOverlapped;</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Read %d bytes: %.*s\n"</span>, bytesTransferred, bytesTransferred, context->buffer);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>AsyncFileReadWithIOCP</span><span class=params>()</span> </span>{</span><br><span class=line>    HANDLE hFile = CreateFile(</span><br><span class=line>        <span class=string>"example.txt"</span>,</span><br><span class=line>        GENERIC_READ,</span><br><span class=line>        <span class=number>0</span>,</span><br><span class=line>        <span class=literal>NULL</span>,</span><br><span class=line>        OPEN_EXISTING,</span><br><span class=line>        FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,</span><br><span class=line>        <span class=literal>NULL</span></span><br><span class=line>    );</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (hFile == INVALID_HANDLE_VALUE) {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Failed to open file. Error: %d\n"</span>, GetLastError());</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    HANDLE hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, <span class=literal>NULL</span>, <span class=number>0</span>, <span class=number>0</span>);</span><br><span class=line>    <span class=keyword>if</span> (!hCompletionPort) {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Failed to create completion port. Error: %d\n"</span>, GetLastError());</span><br><span class=line>        CloseHandle(hFile);</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    CreateIoCompletionPort(hFile, hCompletionPort, (ULONG_PTR)hFile, <span class=number>0</span>);</span><br><span class=line></span><br><span class=line>    HANDLE hThread = CreateThread(<span class=literal>NULL</span>, <span class=number>0</span>, WorkerThread, hCompletionPort, <span class=number>0</span>, <span class=literal>NULL</span>);</span><br><span class=line>    <span class=keyword>if</span> (!hThread) {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Failed to create worker thread. Error: %d\n"</span>, GetLastError());</span><br><span class=line>        CloseHandle(hFile);</span><br><span class=line>        CloseHandle(hCompletionPort);</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    IO_CONTEXT context = {<span class=number>0</span>};</span><br><span class=line>    context.overlapped.Offset = <span class=number>0</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (!ReadFile(hFile, context.buffer, <span class=keyword>sizeof</span>(context.buffer), <span class=literal>NULL</span>, &context.overlapped)) {</span><br><span class=line>        <span class=keyword>if</span> (GetLastError() != ERROR_IO_PENDING) {</span><br><span class=line>            <span class=built_in>printf</span>(<span class=string>"ReadFile failed. Error: %d\n"</span>, GetLastError());</span><br><span class=line>            CloseHandle(hFile);</span><br><span class=line>            CloseHandle(hCompletionPort);</span><br><span class=line>            CloseHandle(hThread);</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    WaitForSingleObject(hThread, INFINITE);</span><br><span class=line></span><br><span class=line>    CloseHandle(hFile);</span><br><span class=line>    CloseHandle(hCompletionPort);</span><br><span class=line>    CloseHandle(hThread);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    AsyncFileReadWithIOCP();</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><p><strong>关键函数</strong><ul><li><strong><code>CreateIoCompletionPort</code></strong>：创建一个新的完成端口或将其与现有句柄关联。<li><strong><code>PostQueuedCompletionStatus</code></strong>：手动向完成端口队列中添加状态信息。<li><strong><code>GetQueuedCompletionStatus</code></strong>：从完成端口队列中检索下一个已完成的操作的状态。</ul><p><strong>3. 对比 Overlapped I/O 和 IOCP</strong><div class=table-container><table><thead><tr><th>特性<th>Overlapped I/O<th>IOCP<tbody><tr><td><strong>适用场景</strong><td>小规模异步操作<td>大规模并发 I/O 操作<tr><td><strong>性能</strong><td>较低<td>更高<tr><td><strong>复杂度</strong><td>较低<td>较高<tr><td><strong>线程管理</strong><td>需要手动管理线程<td>自动管理线程池<tr><td><strong>扩展性</strong><td>有限<td>非常强</table></div><p><strong>4. 总结</strong><ul><li><strong>Overlapped I/O</strong>：适合小型应用或需要简单异步 I/O 的场景，易于实现但扩展性较差。<li><p><strong>IOCP</strong>：适合高性能服务器程序，支持大规模并发连接，具有更高的效率和扩展性，但实现起来更复杂。</p><li><p><strong>简单场景</strong>：如果您的应用只需要简单的异步 I/O 操作，Overlapped I/O 可能是最容易实现的选择。</p><li><strong>高并发场景</strong>：如果您正在开发一个需要处理大量并发连接的应用程序（如 Web 服务器），那么 IOCP 是最佳选择，因为它提供了更好的性能和扩展性。<li><strong>轻量级需求</strong>：如果希望避免复杂的线程管理并且对性能的要求不是极高，可以考虑使用回调函数的方式。</ul><link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script></div><div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div class=popular-posts-header>相关文章</div><ul class=popular-posts><li class=popular-posts-item><div class=popular-posts-title><a href=\2025\07\31\c-刷leetcode注意事项\ rel=bookmark>c++刷leetcode注意事项</a></div><li class=popular-posts-item><div class=popular-posts-title><a href=\2025\03\20\TinyHttpServer项目学习\ rel=bookmark>TinyWebServer项目学习</a></div><li class=popular-posts-item><div class=popular-posts-title><a href=\2024\10\16\现代C-中的异常处理\ rel=bookmark>现代C++中的异常处理</a></div><li class=popular-posts-item><div class=popular-posts-title><a href=\2024\10\09\也许需要知道的c-概念\ rel=bookmark>也许需要知道的c++概念</a></div><li class=popular-posts-item><div class=popular-posts-title><a href=\2024\10\05\现代c-并发深入\ rel=bookmark>现代c++并发深入</a></div></ul><div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a href=https://www.sekyoro.top/2025/02/27/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ title=Linux网络编程入门>https://www.sekyoro.top/2025/02/27/Linux网络编程入门/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div><footer class=post-footer><div class=post-tags><a href=/tags/c/ rel=tag><i class="fa fa-tag"></i> c++</a><a href=/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/ rel=tag><i class="fa fa-tag"></i> Linux网络编程</a></div><div class=post-nav><div class=post-nav-item><a title="learn opengl(3)" href=/2025/01/26/learn-opengl-3/ rel=prev> <i class="fa fa-chevron-left"></i> learn opengl(3) </a></div><div class=post-nav-item><a href=/2025/03/09/mini-java-guide/ rel=next title=mini-java-guide> mini-java-guide <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div><!-- 评论区 --><div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%87%8D%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84><span class=nav-number>1.</span> <span class=nav-text>重要的数据结构</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80><span class=nav-number>1.1.</span> <span class=nav-text>套接字地址</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%9C%B0%E5%9D%80%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8E%E7%82%B9%E5%88%86%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2><span class=nav-number>1.2.</span> <span class=nav-text>地址二进制与点分十进制转换</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%AB%AF%E5%8F%A3%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E6%8D%A2><span class=nav-number>1.3.</span> <span class=nav-text>端口字节序转换</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AE%BE%E7%BD%AE%E5%A5%97%E6%8E%A5%E5%AD%97%E7%AD%89%E9%80%89%E9%A1%B9><span class=nav-number>1.4.</span> <span class=nav-text>设置套接字等选项</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%80%89%E9%A1%B9><span class=nav-number>1.5.</span> <span class=nav-text>设置文件描述符选项</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6><span class=nav-number>2.</span> <span class=nav-text>信号机制</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#signal><span class=nav-number>2.1.</span> <span class=nav-text>signal</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#sigaction><span class=nav-number>2.2.</span> <span class=nav-text>sigaction</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#stat><span class=nav-number>3.</span> <span class=nav-text>stat</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#mmap><span class=nav-number>4.</span> <span class=nav-text>mmap</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%A7%A3%E6%9E%90%E4%BC%A0%E5%85%A5%E5%8F%82%E6%95%B0><span class=nav-number>5.</span> <span class=nav-text>解析传入参数</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#get-opt%E5%87%BD%E6%95%B0><span class=nav-number>5.0.1.</span> <span class=nav-text>get_opt函数</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#getopt-long-%E5%87%BD%E6%95%B0><span class=nav-number>5.0.2.</span> <span class=nav-text>getopt_long 函数</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B><span class=nav-number>5.0.3.</span> <span class=nav-text>函数原型</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%88%86%E6%95%A3-%E8%81%9A%E9%9B%86IO><span class=nav-number>6.</span> <span class=nav-text>分散/聚集IO</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%88%86%E6%95%A3-I-O%EF%BC%88Scatter-I-O%EF%BC%89><span class=nav-number>6.0.1.</span> <span class=nav-text>分散 I/O（Scatter I/O）</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%81%9A%E9%9B%86-I-O%EF%BC%88Gather-I-O%EF%BC%89><span class=nav-number>6.0.2.</span> <span class=nav-text>聚集 I/O（Gather I/O）</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#TCP%E6%B5%81%E7%A8%8B><span class=nav-number>7.</span> <span class=nav-text>TCP流程</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#UDP%E6%B5%81%E7%A8%8B><span class=nav-number>8.</span> <span class=nav-text>UDP流程</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%BC%82%E6%AD%A5IO%E6%9C%BA%E5%88%B6><span class=nav-number>9.</span> <span class=nav-text>异步IO机制</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#POSIX%E5%BC%82%E6%AD%A5IO><span class=nav-number>9.1.</span> <span class=nav-text>POSIX异步IO</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Linux%E5%8E%9F%E7%94%9FAIO><span class=nav-number>9.2.</span> <span class=nav-text>Linux原生AIO</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#io-uring><span class=nav-number>9.3.</span> <span class=nav-text>io_uring</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Epoll%E4%BA%8B%E4%BB%B6%E7%9A%84Channel%E7%B1%BB><span class=nav-number>10.</span> <span class=nav-text>Epoll事件的Channel类</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A0%B8%E5%BF%83%E7%B1%BB><span class=nav-number>11.</span> <span class=nav-text>服务器与事件驱动核心类</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#Acceptor%E7%B1%BB><span class=nav-number>11.1.</span> <span class=nav-text>Acceptor类</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Connection%E8%BF%9E%E6%8E%A5%E7%B1%BB><span class=nav-number>11.2.</span> <span class=nav-text>Connection连接类</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Buffer%E7%B1%BB><span class=nav-number>11.3.</span> <span class=nav-text>Buffer类</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A2%9E%E5%8A%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0><span class=nav-number>11.4.</span> <span class=nav-text>增加线程池</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A4%9A%E7%BA%BF%E7%A8%8BReactor%E6%A8%A1%E5%BC%8F><span class=nav-number>11.5.</span> <span class=nav-text>多线程Reactor模式</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%BC%8F><span class=nav-number>11.6.</span> <span class=nav-text>主从Reactor多线程模式</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A2%9E%E5%8A%A0%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%94%AF%E6%8C%81><span class=nav-number>11.7.</span> <span class=nav-text>增加多平台支持</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%A7%A3%E5%86%B3Connection%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%97%AE%E9%A2%98><span class=nav-number>11.8.</span> <span class=nav-text>解决Connection生命周期问题</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93><span class=nav-number>12.</span> <span class=nav-text>第三方库</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%85%B6%E4%BB%96><span class=nav-number>13.</span> <span class=nav-text>其他</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%9C%A8windows%E4%B8%8A%E7%9A%84%E5%BC%82%E6%AD%A5I-O%E6%9C%BA%E5%88%B6><span class=nav-number>13.1.</span> <span class=nav-text>在windows上的异步I/O机制</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#Overlapped-I-O><span class=nav-number>13.1.1.</span> <span class=nav-text>Overlapped I/O</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0><span class=nav-number>13.1.2.</span> <span class=nav-text>回调函数</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#I-O-Completion-Ports-IOCP><span class=nav-number>13.1.3.</span> <span class=nav-text>I/O Completion Ports (IOCP)</span></a></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>245</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>16</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>215</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a><li class=links-of-blogroll-item><a href=https://www.lllomh.com/ rel=noopener target=_blank title=https://www.lllomh.com/>芈渡</a><li class=links-of-blogroll-item><a href=https://protool-ten.vercel.app/ rel=noopener target=_blank title=https://protool-ten.vercel.app/>protools</a></ul></div><div class="motion-element announcement"><div class=title></div><p class=content><p class=date></div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>文章词云</h3><div class="widget tagcloud" id=myCanvasContainer><canvas height=250 id=resCanvas style=width:100% width=250><ul class=tag-list itemprop=keywords><li class=tag-list-item><a class=tag-list-link href=/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/ rel=tag>Linux网络编程</a><span class=tag-list-count>1</span><li class=tag-list-item><a class=tag-list-link href=/tags/c/ rel=tag>c++</a><span class=tag-list-count>6</span></ul></canvas></div></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2025</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>3m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>45:40</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer></div><script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script><script src=/lib/anime.min.js></script><script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script><script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/pisces.js></script><script src=/js/next-boot.js></script><script src=/js/bookmark.js></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	'.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script><script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script><script src=/js/algolia-search.js></script><script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script><div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div><script charset=utf-8 defer src=/js/tagcanvas.js></script><script charset=utf-8 defer src=/js/tagcloud.js></script><script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script><script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script><script src=/js/src/activate-power-mode.min.js></script><script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script>
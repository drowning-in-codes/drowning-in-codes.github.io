<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"0F9LEEVW82","apiKey":"78839e9f9be09d081c5c4da81975cd19","indexName":"sekyoblog_sec","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content="消息队列功能很强大,它能使业务降低耦合,异步调用无需等待,下游服务故障不影响上游业务,缓存消息起到流量削峰填谷的作用. 这里介绍其中的RabbitMQ,此外在说一下Elastic Search和MongoDB." name=description><meta content=article property=og:type><meta content=rabbit-mq初探 property=og:title><meta content=https://www.sekyoro.top/2025/07/21/rabbit-mq%E5%88%9D%E6%8E%A2/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content="消息队列功能很强大,它能使业务降低耦合,异步调用无需等待,下游服务故障不影响上游业务,缓存消息起到流量削峰填谷的作用. 这里介绍其中的RabbitMQ,此外在说一下Elastic Search和MongoDB." property=og:description><meta content=zh_CN property=og:locale><meta content=https://s2.loli.net/2025/07/23/aSBLvYT564eHXyq.png property=og:image><meta content=https://s2.loli.net/2025/07/23/uvOSniRI79KlHjZ.png property=og:image><meta content=https://s2.loli.net/2025/07/23/Vi4tCgzQxNeEsGl.png property=og:image><meta content=https://s2.loli.net/2025/07/23/V12oSsUWA6M47c3.png property=og:image><meta content=https://s2.loli.net/2025/07/23/y1GN8qE5B9toWRc.png property=og:image><meta content=https://s2.loli.net/2025/07/23/HCNPY9af2AxcIi4.png property=og:image><meta content=https://s2.loli.net/2025/07/23/fvJXcjB8t7Y1QIN.png property=og:image><meta content=https://s2.loli.net/2025/07/23/V6L9IWvfeUYTdrN.png property=og:image><meta content=https://s2.loli.net/2025/07/23/XGb3OVvExu6Jmt8.png property=og:image><meta content=https://s2.loli.net/2025/07/23/GEYShOIwDZ9KnCQ.png property=og:image><meta content=https://s2.loli.net/2025/07/24/KHnvIaoRCrUVsYz.png property=og:image><meta content=https://s2.loli.net/2025/07/24/GHoW2eD1jNFbUQ4.png property=og:image><meta content=https://s2.loli.net/2025/07/24/OJGYiMmEP45eaXA.png property=og:image><meta content=https://s2.loli.net/2025/07/24/d1XV3agFZuc2EpU.png property=og:image><meta content=https://s2.loli.net/2025/07/24/QqeEXnDsPTHOYrk.png property=og:image><meta content=https://s2.loli.net/2025/07/24/q4FaG2AV5BWoXxD.png property=og:image><meta content=https://s2.loli.net/2025/07/23/3ANVlJm2jqtbDvh.png property=og:image><meta content=https://s2.loli.net/2025/07/23/qDZUVliadH42pku.png property=og:image><meta content=https://s2.loli.net/2025/07/24/fde7GAnb34KDgUp.png property=og:image><meta content=https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/elasticsearch/rumen-ad2b2f8c-5a19-4c5e-9bc7-cf7ba17830bf.jpg property=og:image><meta content=2025-07-21T12:36:01.000Z property=article:published_time><meta content=2025-07-24T09:39:36.400Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content="个人博客 技术学习 计算机 互联网 人工智能" property=article:tag><meta content=summary name=twitter:card><meta content=https://s2.loli.net/2025/07/23/aSBLvYT564eHXyq.png name=twitter:image><link href=https://www.sekyoro.top/2025/07/21/rabbit-mq%E5%88%9D%E6%8E%A2/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>rabbit-mq初探 | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2025/07/21/rabbit-mq%E5%88%9D%E6%8E%A2/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>rabbit-mq初探</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2025-07-21 20:36:01" datetime=2025-07-21T20:36:01+08:00>2025-07-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-07-24 17:39:36" datetime=2025-07-24T17:39:36+08:00 itemprop=dateModified>2025-07-24</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>53k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>48 分钟</span> </span></div></header><div class=post-body itemprop=articleBody><p>消息队列功能很强大,它能使业务降低耦合,异步调用无需等待,下游服务故障不影响上游业务,缓存消息起到流量削峰填谷的作用. 这里介绍其中的RabbitMQ,此外在说一下Elastic Search和MongoDB.<br><span id=more></span><h1 id=RabbitMQ><a class=headerlink href=#RabbitMQ title=RabbitMQ></a>RabbitMQ</h1><p><img alt=image-20250723102231391 data-src=https://s2.loli.net/2025/07/23/aSBLvYT564eHXyq.png><p>消息队列:<strong>分布式应用必定涉及到各个系统之间的通信问题</strong>，这个时候消息队列也应运而生了。可以说分布式的产生是消息队列的基础<p>为什么使用消息队列?异步、解耦、削峰<p>引入消息队列带来的问题: 消息顺序消息 重复消费消息 分布式事务问题等<p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想象成：当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ 就好比由邮局、邮箱和邮递员组成的一个系统。从计算机术语层面来说，RabbitMQ 模型更像是一种交换机模型。<p><strong>可靠性</strong>: RabbitMQ 使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。<p><strong>灵活的路由</strong> : 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。<p><strong>扩展性</strong>: 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。<p><strong>高可用性</strong> : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。<p><strong>多种协议</strong>: RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP， MQTT 等多种消息 中间件协议。<p><strong>多语言客户端</strong> :RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。<p><strong>管理界面</strong> : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。<p><strong>插件机制</strong> : RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。<h2 id=安装><a class=headerlink href=#安装 title=安装></a>安装</h2><p>安装Erlang和Rabbit-mq,<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>rabbitmqctl.bat status</span><br><span class=line>rabbitmq-plugins <span class=built_in>enable</span> rabbitmq-management</span><br></pre></table></figure><p>然后访问15672端口可视化管理.<h2 id=队列类型><a class=headerlink href=#队列类型 title=队列类型></a>队列类型</h2><p>RabbitMQ 提供了三种主要的队列类型，它们在数据存储、性能、特性和使用场景上有所不同：<h3 id=经典队列><a class=headerlink href=#经典队列 title=经典队列></a>经典队列</h3><ul><li><strong>默认和最常见：</strong> 这是 RabbitMQ 最早支持的队列类型，也是如果你不显式指定队列类型时创建的默认类型。<li><strong>灵活的持久性：</strong> 可以配置为<strong>持久化 (durable)</strong> 或<strong>非持久化 (transient)</strong>。<ul><li><strong>持久化队列：</strong> 队列的元数据（队列名称、配置等）和消息都会被写入磁盘。即使 RabbitMQ 服务重启，队列及其消息也不会丢失。<li><strong>非持久化队列：</strong> 队列的元数据和消息只存在于内存中。RabbitMQ 服务重启后，队列及其消息会丢失。</ul><li><strong>支持镜像 (Mirrored Queues)：</strong> 经典队列可以通过配置<strong>镜像模式</strong>来提高可用性。这意味着队列的主副本存在于一个节点，同时在其他节点上也有同步的副本。当主节点故障时，一个镜像副本可以被提升为新的主副本。<ul><li><strong>优点：</strong> 提高了高可用性。<li><strong>缺点：</strong> 镜像队列在写入时需要进行同步复制，这会增加网络开销和延迟，影响吞吐量。消费者从主副本消费，如果主副本故障，需要选举新的主副本。</ul><li><strong>性能：</strong> 在单节点或非镜像模式下性能较高，但在高可用（镜像）模式下，由于同步复制开销，吞吐量可能会下降。<li><strong>内部实现：</strong> 消息通常存储在内存中，并根据需要（如持久化消息或内存不足时）溢出到磁盘。</ul><p><strong>使用场景：</strong><ul><li>大多数通用消息传递场景。<li>对消息持久性和可靠性有要求，但对吞吐量要求不是极致的场景（特别是在镜像模式下）。<li>需要简单高可用的应用。</ul><h3 id=仲裁队列-Quorum-Queue><a title="仲裁队列(Quorum Queue)" class=headerlink href=#仲裁队列-Quorum-Queue></a>仲裁队列(Quorum Queue)</h3><p><strong>特点：</strong><ul><li><strong>Raft 共识算法：</strong> 仲裁队列是 RabbitMQ 3.8 版本引入的新队列类型，它基于 <strong>Raft 一致性算法</strong>实现。Raft 算法确保了分布式系统中的强一致性，比经典队列的镜像机制更健壮。<li><strong>自动高可用：</strong> 仲裁队列天生就是分布式的，不需要像经典队列那样手动配置镜像。它会自动在集群中的大多数节点上复制消息。<li><strong>多数派机制 (Quorum)：</strong> 任何操作（如消息的发布、消费确认）都需要集群中<strong>大多数节点</strong>的确认才能被视为成功。例如，一个有 3 个节点的仲裁队列，需要 2 个节点的确认。这保证了即使有节点故障，只要多数派存活，数据就不会丢失，并且服务可以继续。<li><strong>更好的数据安全性：</strong> Raft 算法确保了消息的强一致性，理论上比经典队列的镜像模式更能避免脑裂 (split-brain) 等问题，提供更高的数据安全性。<li><strong>写入性能：</strong> 由于需要多数派确认，写入性能通常会比非镜像的经典队列低，但比镜像的经典队列在某些情况下可能更好，因为它优化了复制过程。<li><strong>消费者行为：</strong> 消费者可以从任何副本消费消息，并且消费确认也会通过 Raft 算法进行同步，确保消费的顺序和一致性。<li><strong>只支持持久化：</strong> 仲裁队列的消息总是持久化的。</ul><p><strong>使用场景：</strong><ul><li>对数据一致性和高可用性有极高要求的场景。<li>需要避免数据丢失和脑裂问题的关键业务消息。<li>替代经典队列的镜像模式，提供更健壮的集群行为。</ul><h3 id=流式队列-Stream-Queue><a title="流式队列(Stream Queue)" class=headerlink href=#流式队列-Stream-Queue></a>流式队列(Stream Queue)</h3><p><strong>特点：</strong><ul><li><strong>专为大数据流设计：</strong> 流式队列是 RabbitMQ 3.9 版本引入的最新队列类型，其设计目标是处理<strong>海量的、连续的、高吞吐量</strong>的消息流。<li><strong>类似 Kafka 的特性：</strong> 它吸收了 Kafka 等流处理系统的概念，例如：<ul><li><strong>追加日志 (Append-only Log)：</strong> 消息以追加的方式写入，像一个不可变的日志。<li><strong>多消费者并行消费：</strong> 多个消费者可以独立地追踪自己的消费进度（偏移量），从流的不同位置并行消费。<li><strong>消息保留策略：</strong> 消息可以被长期保留（例如，保留几天或直到达到某个大小限制），即使它们已经被消费者确认，也可以重新消费。这对于回溯、重放或处理慢速消费者非常有用。</ul><li><strong>高吞吐量：</strong> 通过优化内部存储和消费模型，流式队列可以提供比经典队列和仲裁队列更高的吞吐量，尤其是在大量消息的场景下。<li><strong>磁盘友好：</strong> 消息主要存储在磁盘上，但通过优化读写性能，依然能保持高吞吐。<li><strong>适用于历史数据回溯：</strong> 消费者可以从流的任意位置开始消费，或重新消费已处理过的消息。<li><strong>高可用：</strong> 流式队列也有其自身的复制机制来保证高可用性，但其细节与仲裁队列和经典镜像队列有所不同。</ul><p><strong>使用场景：</strong><ul><li>日志收集和分析。<li>IoT (物联网) 数据流处理。<li>事件溯源 (Event Sourcing)。<li>实时数据管道。<li>任何需要处理海量、连续、可回溯消息流的场景。</ul><p><strong>三种队列类型的比较总结</strong><div class=table-container><table><thead><tr><th>特性<th>经典队列 (Classic Queues)<th>仲裁队列 (Quorum Queues)<th>流式队列 (Stream Queues)<tbody><tr><td><strong>设计目标</strong><td>通用消息，灵活配置<td>强一致性，高可用<td>大数据流，高吞吐，可回溯<tr><td><strong>高可用</strong><td>需手动配置镜像（同步复制）<td>基于 Raft 算法，自动高可用（多数派）<td>自身复制机制，高可用<tr><td><strong>一致性</strong><td>最终一致性（镜像）<td>强一致性<td>强一致性（内部实现）<tr><td><strong>消息持久性</strong><td>可选（持久化/非持久化）<td>总是持久化<td>总是持久化，支持长期保留<tr><td><strong>吞吐量</strong><td>单节点高，镜像模式有开销<td>比非镜像经典低，比镜像经典好（某些场景）<td>极高，尤其适合大数据流<tr><td><strong>消费模型</strong><td>传统消息队列模型，消息一旦消费即移除<td>传统模型，但消费确认更强一致<td>类似 Kafka，支持多消费者独立追踪偏移量，可回溯<tr><td><strong>内部实现</strong><td>基于内存/磁盘混合，分段存储<td>基于 Raft 日志，强一致性日志<td>追加日志，磁盘优化<tr><td><strong>版本</strong><td>早期版本支持，默认<td>RabbitMQ 3.8+<td>RabbitMQ 3.9+</table></div><h3 id=队列设置><a class=headerlink href=#队列设置 title=队列设置></a>队列设置</h3><h4 id=优先级队列><a class=headerlink href=#优先级队列 title=优先级队列></a>优先级队列</h4><p>设置队列属性max-priority,发送消息时设置priority属性排序.<h2 id=交换机类型><a class=headerlink href=#交换机类型 title=交换机类型></a>交换机类型</h2><p><strong>交换机 (Exchange)</strong> 是消息路由的核心组件。生产者发送消息到交换机，而不是直接发送到队列。交换机接收到消息后，根据其类型和绑定的路由规则，将消息转发到一个或多个队列。<p>可以把交换机想象成一个邮局的分拣中心。当一封信（消息）到达邮局时，分拣中心（交换机）不会直接把它投递到某个邮箱（队列），而是会根据信封上的地址信息（路由键）和分拣规则（交换机类型及绑定），决定把这封信投递到哪些信箱。<p><strong>接收消息：</strong> 接收来自生产者的消息。<p><strong>路由消息：</strong> 根据自身类型和消息的<strong>路由键 (Routing Key)</strong>，以及与队列之间的<strong>绑定 (Binding)</strong> 规则，将消息转发到对应的队列。<p><strong>不存储消息：</strong> 交换机本身不存储消息，它只是一个消息转发器。如果一条消息到达交换机，但没有匹配到任何队列，那么这条消息就会被丢弃（除非配置了<strong>备份交换机</strong>）。<h3 id=直连交换机-Direct-Exchange><a title="直连交换机 (Direct Exchange)" class=headerlink href=#直连交换机-Direct-Exchange></a>直连交换机 (Direct Exchange)</h3><p><strong>路由规则：</strong> 直连交换机根据消息的<strong>路由键（Routing Key)</strong>与<strong>队列和交换机之间的绑定键（Binding Key）</strong>进行精确匹配。<p><strong>工作方式：</strong> 只有当消息的路由键与队列的绑定键<strong>完全一致</strong>时，消息才会被转发到该队列。<p><strong>使用场景：</strong><ul><li><strong>点对点消息传递：</strong> 当你需要将消息发送到特定队列时。<li><strong>日志系统：</strong> 根据日志级别（如 <code>info</code>, <code>warning</code>, <code>error</code>）路由到不同的处理队列。</ul><p><strong>路由键</strong>和<strong>绑定键（Binding Key）\</strong>需要*<em>精确匹配*</em>。<p><strong>如何工作：</strong> 当一个队列与直连交换机绑定时，它会提供一个绑定键。如果消息的路由键与这个绑定键完全相同，交换机就会将消息转发到这个队列。<p><strong>示例：</strong><ul><li>队列 Q1 绑定到直连交换机 E1，绑定键是 <code>error</code>。<li>队列 Q2 绑定到直连交换机 E1，绑定键是 <code>info</code>。<li>生产者发送消息到 E1，路由键为 <code>error</code>。只有 Q1 会收到消息。<li>生产者发送消息到 E1，路由键为 <code>warning</code>。没有队列会收到消息（除非有备份交换机）。</ul><p><img alt=image-20250723152920972 data-src=https://s2.loli.net/2025/07/23/uvOSniRI79KlHjZ.png><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>void</span> <span class=title>directQueue</span><span class=params>()</span> </span>{</span><br><span class=line>String exchangeName = <span class=string>"amq.direct"</span>;</span><br><span class=line>rabbitTemplate.convertAndSend(exchangeName,<span class=string>"queue1"</span>, <span class=string>"hello,this is direct1 exhange"</span>);</span><br><span class=line>rabbitTemplate.convertAndSend(exchangeName,<span class=string>"queue2"</span>, <span class=string>"hello,this is direct2 exhange"</span>);</span><br><span class=line>}</span><br></pre></table></figure><h3 id=主题交换机-Topic-Exchange><a title="主题交换机 (Topic Exchange)" class=headerlink href=#主题交换机-Topic-Exchange></a>主题交换机 (Topic Exchange)</h3><p><strong>路由规则：</strong> 主题交换机通过<strong>模式匹配</strong>的方式来路由消息，它也依赖于消息的路由键和绑定键。绑定键可以使用通配符：<ul><li><code>*</code> (星号)：匹配一个单词。<li><code>#</code> (井号)：匹配零个或多个单词。</ul><p><strong>示例：</strong><ul><li>队列 Q1 绑定到主题交换机 E2，绑定键是 <code>*.critical</code>。<li>队列 Q2 绑定到主题交换机 E2，绑定键是 <code>audit.#</code>。<li>生产者发送消息到 E2，路由键为 <code>log.critical</code>。Q1 会收到。<li>生产者发送消息到 E2，路由键为 <code>audit.user.login</code>。Q2 会收到。<li>生产者发送消息到 E2，路由键为 <code>report.summary</code>。都没有收到。</ul><p><img alt=image-20250723154158270 data-src=https://s2.loli.net/2025/07/23/Vi4tCgzQxNeEsGl.png><p><strong>工作方式：</strong><ul><li>路由键和绑定键都是由句点 <code>.</code> 分隔的字符串（例如 <code>stock.usd.ny</code>）。<li>当消息的路由键与绑定键的模式匹配时，消息会被转发到对应的队列。</ul><p><strong>使用场景：</strong><ul><li><strong>日志订阅：</strong> 灵活地订阅不同来源、不同级别的日志。<li><strong>股票行情：</strong> 根据股票代码、货币类型等进行多维度的消息订阅。<li><strong>复杂事件处理：</strong> 需要根据事件类型或来源的层级结构进行路由</ul><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>void</span> <span class=title>topicQueue</span><span class=params>()</span> </span>{</span><br><span class=line>    String exchangeName = <span class=string>"amq.topic"</span>;</span><br><span class=line>    rabbitTemplate.convertAndSend(exchangeName,<span class=string>"china.weather"</span>, <span class=string>"hello,this is topic exhange"</span>);</span><br><span class=line>    rabbitTemplate.convertAndSend(exchangeName,<span class=string>"china.news"</span>, <span class=string>"hello,this is topic exhange"</span>);</span><br><span class=line>}</span><br></pre></table></figure><h3 id=广播-扇形交换机-Fanout-Exchange><a title="广播/扇形交换机 (Fanout Exchange)" class=headerlink href=#广播-扇形交换机-Fanout-Exchange></a>广播/扇形交换机 (Fanout Exchange)</h3><p>将接收到的消息广播到每一个跟其绑定的队列<p><strong>路由规则：</strong> 扇形交换机最简单，它会<strong>忽略</strong>消息的路由键。<p><strong>工作方式：</strong> 它会将接收到的所有消息广播到<strong>所有与它绑定的队列</strong>。<p><strong>关系：</strong> 扇形交换机<strong>完全忽略路由键</strong>, 无论消息的路由键是什么，扇形交换机都会将所有收到的消息广播到所有与它绑定的队列。路由键的存在只是为了符合协议要求，但其值没有任何路由意义。<p><strong>示例：</strong><ul><li>队列 Q1、Q2、Q3 都绑定到扇形交换机 E3。<li>生产者发送消息到 E3，路由键为任何值（例如 <code>my.key</code> 或 <code>whatever</code>）。Q1、Q2、Q3 都会收到消息。</ul><p><strong>使用场景：</strong><ul><li><strong>广播消息：</strong> 例如，通知所有在线用户某个系统维护消息。<li><strong>多任务处理：</strong> 一个任务触发后，需要多个不同的服务并行处理该任务的不同方面。<li><strong>缓存更新：</strong> 当数据更新时，通知所有需要更新缓存的服务。</ul><p><img alt=image-20250723141958629 data-src=https://s2.loli.net/2025/07/23/V12oSsUWA6M47c3.png><p><img alt=image-20250723151942617 data-src=https://s2.loli.net/2025/07/23/y1GN8qE5B9toWRc.png><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Test</span></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>fanoutQueue</span><span class=params>()</span> </span>{</span><br><span class=line>    String exchangeName = <span class=string>"amq.fanout"</span>;</span><br><span class=line>    rabbitTemplate.convertAndSend(exchangeName,<span class=keyword>null</span>, <span class=string>"hello,this is fanout exhange"</span>);}</span><br></pre></table></figure><h3 id=头交换机-Headers-Exchange><a title="头交换机 (Headers Exchange)" class=headerlink href=#头交换机-Headers-Exchange></a>头交换机 (Headers Exchange)</h3><p><strong>路由规则：</strong> 头交换机是<strong>最不常用</strong>的一种。它根据消息的<strong>头部属性（Headers）</strong>而不是路由键来路由消息。<p><strong>工作方式：</strong> 绑定时，你可以指定一系列的键值对（<code>x-match</code> 参数决定匹配规则：<code>any</code> 匹配任一，<code>all</code> 匹配所有）。消息的头部如果包含匹配的键值对，则会被转发。<p><strong>使用场景：</strong><ul><li>非常特殊的、基于复杂消息元数据的路由需求。<li>当路由键不足以表达所有路由逻辑时。</ul><p><strong>交换机的核心作用：</strong><ul><li>它是消息路由的<strong>第一站</strong>，解耦了生产者和队列。<li>不存储消息，只负责转发。</ul><p><strong>四种交换机类型及其路由规则：</strong><ul><li><strong>Direct (直连)：</strong> 精确匹配路由键。<li><strong>Topic (主题)：</strong> 模式匹配（<code>*</code>, <code>#</code> 通配符）。<li><strong>Fanout (扇形)：</strong> 广播到所有绑定队列，忽略路由键。<li><strong>Headers (头)：</strong> 根据消息头属性匹配（较少用）。<li><strong>面试时，能够清晰地解释每种类型的路由机制和适用场景是关键。</strong></ul><p><strong>路由键 (Routing Key) 和绑定键 (Binding Key) 的区别和联系：</strong><ul><li><strong>Routing Key：</strong> 生产者发送消息时附带的，描述消息的属性。<li><strong>Binding Key：</strong> 队列与交换机绑定时定义的，描述队列希望接收哪类消息。<li><strong>关系：</strong> 交换机根据这两者进行匹配，将消息路由到队列。它们的匹配规则取决于交换机的类型。</ul><h3 id=交换机设置><a class=headerlink href=#交换机设置 title=交换机设置></a>交换机设置</h3><h4 id=持久化交换机><a class=headerlink href=#持久化交换机 title=持久化交换机></a>持久化交换机</h4><p><strong>保证交换机本身的元数据不会因为 RabbitMQ 服务重启而丢失。</strong><p>持久化交换机的作用和重要性<p>当你声明一个交换机时，你可以将其设置为<strong>持久化（<code>durable = true</code>）\</strong>或*<em>非持久化（<code>durable = false</code>）*</em>。<ol><li><strong>保证交换机定义不丢失：</strong><ul><li><strong>作用：</strong> 当一个交换机被声明为持久化时，它的配置信息（名称、类型、是否是持久化等）会被 RabbitMQ 写入磁盘。<li><strong>重要性：</strong> 这意味着即使 RabbitMQ 服务器崩溃或被意外关闭，当它重新启动时，这个持久化交换机依然会自动被创建并恢复，无需应用程序重新声明它。这对于系统的稳定性和自恢复能力至关重要。</ul><li><strong>配合持久化队列和持久化消息，实现端到端的可靠性：</strong><ul><li><strong>作用：</strong> 持久化交换机本身并不能保证消息的持久性。它只是保证了“通道”的存在。要实现消息在 Broker 重启后不丢失，需要<strong>三者协同工作</strong>：<ol><li><strong>持久化交换机：</strong> 确保交换机定义不丢失。<li><strong>持久化队列：</strong> 确保队列定义及其内部存储的消息不丢失。<li><strong>持久化消息：</strong> 生产者发送消息时，将 <code>delivery_mode</code> 设置为 <code>2</code> (Persistent)，这样消息内容本身才会被写入磁盘。</ol><li><strong>重要性：</strong> 只有这三者都配置为持久化，才能在 RabbitMQ 服务器重启后，确保消息从生产者到达消费者前的整个传递路径上的数据都不会丢失，从而实现端到端的消息可靠性。</ul></ol><h4 id=死信交换机><a class=headerlink href=#死信交换机 title=死信交换机></a>死信交换机</h4><p><strong>死信机制</strong>是 RabbitMQ 提供的一种处理无法被正常投递或消费的消息的机制，是消息可靠性设计的重要组成部分。<p>虽然 DLX/DLQ 不是交换机类型，但它是一个非常重要的概念，涉及到消息无法被消费时的处理。当消息出现以下情况时，会被转发到死信交换机：<ul><li>消息被消费者拒收 (rejected)，并且 <code>requeue</code> 参数设置为 <code>false</code>。<li>消息 TTL (Time-To-Live) 过期。<li>队列达到最大长度 (max-length)。</ul><h2 id=消息属性与投递属性><a class=headerlink href=#消息属性与投递属性 title=消息属性与投递属性></a>消息属性与投递属性</h2><p>消息属性是<strong>生产者在发布消息时设置的</strong>元数据，随消息一起传递。它们通常用于描述消息的特性或提供额外的处理信息。 常见的消息属性包括：<ul><li><strong><code>content_type</code>：</strong> 消息体的数据类型（例如 <code>application/json</code>）。<li><strong><code>content_encoding</code>：</strong> 消息体的编码方式（例如 <code>gzip</code>）。<li><strong><code>headers</code>：</strong> 一个自定义的键值对映射，可以包含应用程序定义的任意元数据。<li><strong><code>delivery_mode</code>：</strong> 消息的持久性。<ul><li><code>1</code> (Non-persistent): 消息不会写入磁盘，Broker 重启后会丢失。<li><code>2</code> (Persistent): 消息会写入磁盘，Broker 重启后会保留（但还需要队列是持久化的）。</ul><li><strong><code>priority</code>：</strong> 消息的优先级（如果队列支持优先级）。<li><strong><code>correlation_id</code>：</strong> 用于关联请求和响应消息，常用于 RPC 模式。<li><strong><code>reply_to</code>：</strong> 用于指定响应消息应该发送到哪个队列，常用于 RPC 模式。<li><strong><code>expiration</code>：</strong> 消息的过期时间（TTL），过期后消息会成为死信。<li><strong><code>message_id</code>：</strong> 消息的唯一标识符，由生产者设置。<li><strong><code>timestamp</code>：</strong> 消息发布时的时间戳。<li><strong><code>type</code>：</strong> 消息类型（应用程序定义）。<li><strong><code>user_id</code>：</strong> 发布消息的用户 ID。<li><strong><code>app_id</code>：</strong> 发布消息的应用程序 ID。</ul><p>投递属性是 RabbitMQ <strong>在将消息投递给消费者时添加的</strong>元数据，它们不属于原始消息本身，而是描述了消息的投递状态。<p><code>requeue</code> 和 <code>redelivered</code> 并不是消息本身的属性，而是与<strong>消息处理和确认机制</strong>相关的<strong>行为参数或状态标志</strong>。<ul><li><strong><code>requeue</code> (行为参数)</strong><ul><li><code>requeue</code> 是在消费者向 RabbitMQ 发送<strong>否定确认 (Negative Acknowledgment - <code>basic.reject</code> 或 <code>basic.nack</code>)</strong> 时使用的一个<strong>布尔参数</strong>。<li>当 <code>requeue</code> 设置为 <code>true</code> 时，表示消费者要求 RabbitMQ 将此消息<strong>重新放回队列</strong>。消息会通常被放回队列的头部或按优先级排序。<li>当 <code>requeue</code> 设置为 <code>false</code> 时，表示消费者拒绝此消息，并且<strong>不希望它重新入队</strong>。此时，如果队列配置了死信交换机（DLX），消息就会被路由到 DLX；否则，消息会被直接丢弃。</ul><li><strong><code>redelivered</code> (状态标志)</strong><ul><li><code>redelivered</code> 是一个<strong>布尔型的投递属性</strong>。<li>当 RabbitMQ 第一次将消息投递给某个消费者时，<code>redelivered</code> 标志为 <code>false</code>。<li>如果消息被<strong>重新入队</strong>（例如，消费者 <code>nack</code> 并 <code>requeue=true</code>，或者连接断开导致消息自动重新入队），那么当这条消息<strong>再次</strong>被投递给任何消费者时，它的 <code>redelivered</code> 标志就会被设置为 <code>true</code>。<li><strong>作用：</strong> 这个标志告诉消费者：“这条消息不是第一次被投递了，你可能已经处理过它或者它之前未能成功处理。”消费者可以根据这个标志来识别重复投递的消息，并采取相应的处理策略（例如，幂等处理、记录警告、发送到死信队列等）。</ul></ul><h2 id=消息可靠性><a class=headerlink href=#消息可靠性 title=消息可靠性></a>消息可靠性</h2><hr><p>消息可靠性在分布式系统中是一个至关重要的概念，它指的是<strong>确保消息在从生产者到消费者的整个生命周期中不会丢失、不被重复处理，并且能够按照预期的顺序被处理</strong>。消息不丢失,消息不重复,消息有序性<h3 id=生产者可靠性><a class=headerlink href=#生产者可靠性 title=生产者可靠性></a>生产者可靠性</h3><h4 id=生产者重连><a class=headerlink href=#生产者重连 title=生产者重连></a>生产者重连</h4><p>由于网络波动,生产者可能出现连接mq失败的情况,可以设置连接超时和重试时间.<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment># 生产者超时重连</span></span><br><span class=line><span class=meta>spring.rabbitmq.connection-timeout</span>= <span class=string>1s</span></span><br><span class=line><span class=meta>spring.rabbitmq.template.retry.enabled</span>=<span class=string>true</span></span><br><span class=line><span class=meta>spring.rabbitmq.template.retry.initial-interval</span>=<span class=string>1000ms</span></span><br><span class=line><span class=meta>spring.rabbitmq.template.retry.max-attempts</span>=<span class=string>3</span></span><br></pre></table></figure><h4 id=生产者确认><a class=headerlink href=#生产者确认 title=生产者确认></a>生产者确认</h4><p>如果路由失败,通过PublisherReturen返回路由异常原因,返回ACK.告知投递成功.<p>如果消息投递到了MQ并且入队成功,返回ACK,告知投递成功,其他情况发送nack.<p>RabbitMQ 提供了两种主要的生产者确认机制：<ol><li><strong>事务 (Transactions)</strong><li><strong>发布者确认 (Publisher Confirms)</strong></ol><p>RabbitMQ 的事务机制允许将一组消息的发送操作包装成一个原子单元。在事务中，要么所有消息都被 Broker 接收并处理，要么所有消息的操作都被回滚。<p>它涉及三个基本的 AMQP 命令：<ul><li><strong><code>Tx.Select</code></strong>: 声明当前通道进入事务模式。<li><strong><code>Tx.Commit</code></strong>: 提交事务。一旦提交，所有在事务期间发送的消息都被 Broker 确认接收。<li><strong><code>Tx.Rollback</code></strong>: 回滚事务。事务期间发送的所有消息都会被丢弃。</ul><p>优点<ul><li><strong>强一致性保证：</strong> 提供了严格的原子性，确保事务内的所有消息要么都成功，要么都失败。</ul><p>缺点<ul><li><strong>性能开销大：</strong> 每个 <code>Tx.Commit</code> 命令都会阻塞生产者，直到 Broker 响应。这意味着 Broker 需要对每个事务进行磁盘同步（如果消息是持久化的），这会大大<strong>降低消息的吞吐量</strong>。<li><strong>不适合高并发场景：</strong> 由于其阻塞特性，事务机制不适用于需要高吞吐量或低延迟的场景。</ul><p>发布者确认是 RabbitMQ 推荐的、更高效的生产者确认机制。它允许生产者异步地接收 Broker 的确认，而无需阻塞发送线程。<p>启用发布者确认后，Broker 会在以下两种情况下向生产者发送确认：<ul><li><strong><code>basic.ack</code> (肯定确认)：</strong><ul><li>表示消息已成功接收并<strong>持久化到磁盘</strong>（如果消息和队列都是持久化的），或者已成功<strong>路由到至少一个队列</strong>（如果消息是非持久化的）。<li>每个 <code>basic.ack</code> 都带有一个 <code>deliveryTag</code>（通道内递增的唯一标识符），可以确认单条消息或一批消息。</ul><li><strong><code>basic.nack</code> (否定确认)：</strong><ul><li>表示消息已被 Broker 接收，但由于某种原因<strong>未能被处理</strong>（例如，Broker 内部错误）。<li>这并不意味着消息丢失，而是 Broker 告诉生产者消息可能需要重新发送或进行其他处理</ul></ul><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment># 生产者确认机制</span></span><br><span class=line><span class=comment># 异步回调方式并且会返回deliveryId</span></span><br><span class=line><span class=meta>spring.rabbitmq.publisher-confirm-type</span>=<span class=string>correlated </span></span><br><span class=line><span class=comment># simple 同步阻塞等待broker回执消息</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment># 开启publisher return 机制 返回路由失败消息</span></span><br><span class=line><span class=meta>spring.rabbitmq.publisher-returns</span>=<span class=string>true  </span></span><br></pre></table></figure><p><strong>退回机制</strong><p>当publisher-returns属性设置为 <code>true</code> 时，如果生产者发送的消息<strong>无法被路由到任何队列</strong>（例如，因为路由键不匹配任何绑定，或者队列不存在），RabbitMQ Broker 会将这条消息”退回”给生产者<p>需要为 <code>RabbitTemplate</code> 设置一个 <code>ReturnsCallback</code>。<p>当消息被退回时，<code>ReturnsCallback</code> 会被异步调用，并接收一个 <code>ReturnedMessage</code> 对象作为参数。<p><code>ReturnedMessage</code> 对象包含了被退回的<strong>原始消息</strong>、<strong>退回的原因</strong>（<code>replyCode</code> 和 <code>replyText</code>，例如 <code>312 NO_ROUTE</code> 表示无路由）、<strong>发送时使用的交换机</strong>和<strong>路由键</strong>等信息。<p>退回回调是rabbitTemplate在初始化后设置的,因此可以在postConstrcut中,以及aware接口,BeanPostProcessor接口等实现.<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@Slf4j</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>CommonConfig</span> <span class=keyword>implements</span> <span class=title>ApplicationContextAware</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>setApplicationContext</span><span class=params>(ApplicationContext applicationContext)</span> <span class=keyword>throws</span> BeansException </span>{</span><br><span class=line>        RabbitTemplate rabbitTemplate = applicationContext.getBean(RabbitTemplate.class);</span><br><span class=line>        rabbitTemplate.setReturnsCallback(<span class=keyword>new</span> RabbitTemplate.ReturnsCallback() {</span><br><span class=line>            <span class=meta>@Override</span></span><br><span class=line>            <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>returnedMessage</span><span class=params>(ReturnedMessage returnedMessage)</span> </span>{</span><br><span class=line>                Message message = returnedMessage.getMessage();</span><br><span class=line>                String exchange = returnedMessage.getExchange();<span class=comment>//发送的交换机</span></span><br><span class=line>                <span class=keyword>int</span> replyCode = returnedMessage.getReplyCode();</span><br><span class=line>                String replyText = returnedMessage.getReplyText();</span><br><span class=line>                log.info(<span class=string>"message:{},exchange:{},replyCode:{},replyText:{}"</span>,message,exchange,replyCode,replyText);</span><br><span class=line>            }</span><br><span class=line>        });</span><br><span class=line></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>确认机制</strong><p>当设置为 <code>CORRELATED</code> 时，Spring AMQP 启用了发布者确认机制，并提供了<strong>更细粒度、更强大的确认方式</strong>。这是<strong>推荐</strong>用于生产环境的配置。<ul><li><strong>确认方式：</strong> 允许你为每条发送的消息提供一个<strong>唯一的 <code>CorrelationData</code> 对象</strong>（通常包含一个消息 ID）。当 Broker 返回确认（<code>basic.ack</code> 或 <code>basic.nack</code>）时，这个 <code>CorrelationData</code> 对象会作为参数传递给 <code>RabbitTemplate</code> 的 <code>ConfirmCallback</code>。<li><strong>关联性：</strong> 这是核心优势。通过 <code>CorrelationData</code>，你可以<strong>精确地将 Broker 返回的确认与你发送的特定消息关联起来</strong>。这对于跟踪消息状态、实现重试逻辑、确保幂等性等非常关键。<li><strong>回调：</strong> 你必须设置 <code>RabbitTemplate</code> 的 <code>ConfirmCallback</code>。当 Broker 返回确认时，该回调会被异步调用。<code>ConfirmCallback</code> 会接收 <code>CorrelationData</code>、<code>ack</code>（是否成功确认）和 <code>cause</code>（如果 <code>ack</code> 为 <code>false</code>，表示原因）作为参数。<li><strong>异步性：</strong> 生产者可以持续发送消息，而无需等待 Broker 的确认。确认的回调是异步发生的，大大提高了吞吐量。</ul><p>必须设置 <code>RabbitTemplate</code> 的 <code>ConfirmCallback</code>。当 Broker 返回确认时，该回调会被异步调用。<code>ConfirmCallback</code> 会接收 <code>CorrelationData</code>、<code>ack</code>（是否成功确认）和 <code>cause</code>（如果 <code>ack</code> 为 <code>false</code>，表示原因）作为参数。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line>   <span class=meta>@Test</span></span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>testPublisherConfirm</span><span class=params>()</span> <span class=keyword>throws</span> InterruptedException </span>{</span><br><span class=line>        CorrelationData correlationData = <span class=keyword>new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class=line>        correlationData.getFuture().toCompletableFuture().thenAccept(<span class=keyword>new</span> Consumer&LTCorrelationData.Confirm>() {</span><br><span class=line>            <span class=meta>@Override</span></span><br><span class=line>            <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>accept</span><span class=params>(CorrelationData.Confirm confirm)</span> </span>{</span><br><span class=line>                <span class=keyword>if</span> (confirm.isAck()) {</span><br><span class=line><span class=comment>//                    ack成功,接收到ack</span></span><br><span class=line>                    log.info(<span class=string>"消息成功,收到broker ack"</span>);</span><br><span class=line>                } <span class=keyword>else</span> {</span><br><span class=line><span class=comment>//                    发送者确认机制,如果没有收到ack</span></span><br><span class=line>                    log.info(<span class=string>"消息失败,收到broker nack,发送者没有收到ack:{}"</span>,confirm.getReason());</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }).exceptionally(<span class=keyword>new</span> Function&LTThrowable, Void>() {</span><br><span class=line>            <span class=meta>@Override</span></span><br><span class=line>            <span class=function><span class=keyword>public</span> Void <span class=title>apply</span><span class=params>(Throwable throwable)</span> </span>{</span><br><span class=line>                log.error(throwable.getMessage(),throwable);</span><br><span class=line>                <span class=keyword>return</span> <span class=keyword>null</span>;</span><br><span class=line>            }</span><br><span class=line>        });</span><br><span class=line></span><br><span class=line>        String exchangeName = <span class=string>"amq.direct"</span>;</span><br><span class=line>        rabbitTemplate.convertAndSend(exchangeName,<span class=string>"queue1"</span>, <span class=string>"hello,this is topic exhange"</span>,correlationData);</span><br><span class=line>    }</span><br></pre></table></figure><p><img alt=image-20250723215959341 data-src=https://s2.loli.net/2025/07/23/HCNPY9af2AxcIi4.png><h3 id=消息队列可靠性><a class=headerlink href=#消息队列可靠性 title=消息队列可靠性></a>消息队列可靠性</h3><p>默认情况下,会将接收到的消息保存在内存中,但:<ol><li>如果mq宕机,内存中的消息会丢失<li>内存空间有限,如果消费者故障或者处理过慢会导致消息堆积,引发mq阻塞</ol><h4 id=数据持久化><a class=headerlink href=#数据持久化 title=数据持久化></a>数据持久化</h4><p>RabbitMQ实现数据持久化包括三个方面:<p>消息队列设置durable,发送消息设置delivery_mode为持久化(2)),交换机设置为持久.<p>持久化使得存储在磁盘避免崩溃数据丢失,同时当消息堆积过多时避免page out(也就是当 Broker 中的消息堆积过多，导致内存压力过大时，RabbitMQ 会将内存中一部分<strong>非活跃</strong>（未被消费者拉取）的消息<strong>暂时从内存中移除并写入到磁盘上</strong>，以释放内存资源)<p>注意在RabbitTemplate中(来自spring-boot-starter-amqp),消息的delivery_mode是2<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>static</span> {</span><br><span class=line>    DEFAULT_DELIVERY_MODE = MessageDeliveryMode.PERSISTENT;</span><br><span class=line>    DEFAULT_PRIORITY = <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>public</span> <span class=title>Queue</span><span class=params>(String name)</span> </span>{</span><br><span class=line>    <span class=keyword>this</span>(name, <span class=keyword>true</span>, <span class=keyword>false</span>, <span class=keyword>false</span>);</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=class><span class=keyword>class</span> <span class=title>BaseExchangeBuilder</span><<span class=title>B</span> <span class=keyword>extends</span> <span class=title>BaseExchangeBuilder</span><<span class=title>B</span>>> <span class=keyword>extends</span> <span class=title>AbstractBuilder</span> </span>{</span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>final</span> String name;</span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>final</span> String type;</span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>boolean</span> durable = <span class=keyword>true</span>;</span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>boolean</span> autoDelete;</span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>boolean</span> internal;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>boolean</span> delayed;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>boolean</span> ignoreDeclarationExceptions;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>boolean</span> declare = <span class=keyword>true</span>;</span><br><span class=line>    <span class=keyword>private</span> Object[] declaringAdmins;}</span><br></pre></table></figure><h4 id=Lazy-Queue><a title="Lazy Queue" class=headerlink href=#Lazy-Queue></a>Lazy Queue</h4><p>惰性队列收到消息后直接存入磁盘而非内存,内存只保留最近消息.<p>消费者要消费消息时才会从磁盘中读取并加载到内存,支持数百万跳的消息存储.<p><strong>新版本都是惰性队列</strong><p>标准队列（非惰性队列）在消息堆积时的行为：<ul><li><strong>内存优先：</strong> 默认情况下，标准队列会尽可能地将消息保留在内存中，以提高消息的投递速度。只有当 Broker 的内存达到高水位线时，才会将消息 Page-out (从内存交换到磁盘)。<li><strong>内存峰值：</strong> 当消息生产者发送速度远超消费者，导致大量消息在队列中堆积时，这些消息会全部加载到内存中。这可能导致 Broker 内存急剧增长，甚至达到内存限制，触发流控或崩溃。<li><strong>频繁 Page-out/Page-in：</strong> 如果消息持续堆积，Broker 会频繁地进行 Page-out 和 Page-in 操作，这会导致大量的磁盘 I/O，严重影响系统性能和消息延迟。</ul><p>惰性队列的核心思想是<strong>“消息总是尽可能地写入磁盘，只有在需要投递时才加载到内存”</strong>。<p>它通过调整消息在队列中的存储策略来达到减少内存占用的目的：<ol><li><strong>主动写入磁盘：</strong> 与标准队列不同，惰性队列在接收到消息后，会<strong>立即或很快地将消息内容写入到磁盘</strong>，只在内存中保留少量消息元数据（如消息索引）。<li><strong>延迟加载：</strong> 只有当消息即将被消费者拉取时（例如，消费者连接并准备接收消息），惰性队列才会将这些消息从磁盘读取到内存中进行投递。<li><strong>内存占用低：</strong> 即使有大量消息堆积，内存中的实际消息内容非常少，从而大大降低了 Broker 的内存使用。</ol><p><img alt=image-20250723230903068 data-src=https://s2.loli.net/2025/07/23/fvJXcjB8t7Y1QIN.png><h3 id=消费者可靠性><a class=headerlink href=#消费者可靠性 title=消费者可靠性></a>消费者可靠性</h3><p>如果没有确认机制，当消息被投递给消费者后，即使消费者未能成功处理（例如，程序崩溃、网络中断、业务逻辑出错），Broker 也会认为消息已经发送，并将其从队列中删除。这就会导致<strong>消息丢失</strong>。<p>消费者确认机制正是为了解决这个问题，它在消费者和 Broker 之间建立了一种“消息处理状态”的反馈机制<h4 id=消费者确认机制><a class=headerlink href=#消费者确认机制 title=消费者确认机制></a>消费者确认机制</h4><p>当消费者处理消息结束后,应该向RabbitMQ发送一个回执,告知MQ消息处理状态.<p>消费者处理结束后可以向MQ发送一个回执,告知自己消息的处理状态.<ul><li>ack:成功处理消息,MQ从队列中删除消息<li>nack:消息处理失败,MQ需要再次投递消息<li>reject:消息处理失败并拒绝该消息,从队列中删除.</ul><p><img alt=image-20250723231753038 data-src=https://s2.loli.net/2025/07/23/V6L9IWvfeUYTdrN.png><p>SpringAMQP已经实现了消息确认功能,可以通过配置文件选择ACK处理方式.<p>none,manual,auto<p><img alt=image-20250723232046254 data-src=https://s2.loli.net/2025/07/23/XGb3OVvExu6Jmt8.png><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># 消费者确认机制</span></span><br><span class=line><span class=meta>spring.rabbitmq.listener.simple.acknowledge-mode</span>=<span class=string>auto</span></span><br></pre></table></figure><h4 id=消息失败><a class=headerlink href=#消息失败 title=消息失败></a>消息失败</h4><p>当消费者出现异常后,消息会不断requeue到队列,再重新发送给消费者,然后再次异常,再次requeue,无限循环,导致mq消息处理飙升.<p>配置retry机制,设置最大尝试次数<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=meta>spring.rabbitmq.listener.simple.acknowledge-mode</span>=<span class=string>auto</span></span><br><span class=line><span class=meta>spring.rabbitmq.listener.simple.retry.enabled</span>=<span class=string>true</span></span><br><span class=line><span class=meta>spring.rabbitmq.listener.simple.retry.initial-interval</span>=<span class=string>1000ms</span></span><br><span class=line><span class=meta>spring.rabbitmq.listener.simple.retry.max-attempts</span>=<span class=string>3</span></span><br><span class=line><span class=meta>spring.rabbitmq.listener.simple.retry.multiplier</span>=<span class=string>2</span></span><br><span class=line><span class=meta>spring.rabbitmq.listener.simple.retry.stateless</span>=<span class=string>true</span></span><br></pre></table></figure><p>当重试次数达到后直接抛弃消息,可以通过MessageRecoverer接口来处理,包括三种实现,可以直接reject并丢弃消息,也可以返回nack,重新入队,也可以将失败消息投递到指定的交换机.<p><img alt=image-20250723234838816 data-src=https://s2.loli.net/2025/07/23/GEYShOIwDZ9KnCQ.png><p><img alt=image-20250724003504963 data-src=https://s2.loli.net/2025/07/24/KHnvIaoRCrUVsYz.png><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=function><span class=keyword>public</span> MessageRecoverer <span class=title>messageRecoverer</span><span class=params>(RabbitTemplate rabbitTemplate)</span> </span>{</span><br><span class=line>    <span class=keyword>return</span> <span class=keyword>new</span> RepublishMessageRecoverer(rabbitTemplate, <span class=string>"error.direct"</span>, <span class=string>"error"</span>);</span><br><span class=line>}</span><br></pre></table></figure><h4 id=业务幂等性><a class=headerlink href=#业务幂等性 title=业务幂等性></a>业务幂等性</h4><p>同一个业务执行一次或多次对业务状态的影响是一致的.<p>设置唯一消息id,可以直接设置消息属性,然后在消费者处将处理后的消息保存到数据库,当新消息<p><img alt=image-20250724104054206 data-src=https://s2.loli.net/2025/07/24/GHoW2eD1jNFbUQ4.png><p>或者基于业务判断,例如在支付后修改订单状态,可以在修改订单状态后先查询订单状态判断状态是否是未支付,未支付才需要修改.<p><img alt=image-20250724105630177 data-src=https://s2.loli.net/2025/07/24/OJGYiMmEP45eaXA.png><h3 id=延迟消息><a class=headerlink href=#延迟消息 title=延迟消息></a>延迟消息</h3><p>生产者发送消息时指定一个时间,消费者不会立刻收到消息,而是在指定时刻之后才收到消息.<p>假设在交易之后还未付费,需要发送一个延时消息,在指定时间之后收到检查用户是否已经付费,如果付费则修改订单状态,如果没有付费,商品数量和订单状态都修改.<p><img alt=image-20250724110445201 data-src=https://s2.loli.net/2025/07/24/d1XV3agFZuc2EpU.png><h4 id=死信交换机-1><a class=headerlink href=#死信交换机-1 title=死信交换机></a>死信交换机</h4><p>当一个队列的消息满足以下情况之一时,就会成为死信:<ol><li>消费者使用basic.reject或者basic.nack,并且消息requeue参数为false.<li>消息达到了设置的expiration或者队列的x-max-ttl过期时间但无人消费.<li>队列消息堆积满了,最早的消息成为死信</ol><p>如果队列通过x-dead-letter-exchange指定交换了交换机,该队列中的死信就会投递到这个交换机.这个交换机就是DLX.<p><img alt=image-20250724112010554 data-src=https://s2.loli.net/2025/07/24/QqeEXnDsPTHOYrk.png><p>也就是给一个交换机发送消息,然后一个队列接受,给这个队列设置超时时间和死信队列,当超时后到指定的队列中,消费者监听这个队列并进行处理.<h4 id=延迟消息插件><a class=headerlink href=#延迟消息插件 title=延迟消息插件></a>延迟消息插件</h4><p>官方提供插件原生支持延迟消息功能. 插件的原理是设计一种支持延迟消息功能的交换机,当消息投递到交换机后可以延迟一段时间然后再投递到队列.<p>安装并启用插件,使用delayed交换机,同时设置消息头<code>x-delay</code>设置过期时间.<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=line><span class=meta>        exchange = @Exchange(value = "direct.delayExchange", delayed = "true"),</span></span><br><span class=line><span class=meta>        value = @Queue(value = "direct.delayQueue"),</span></span><br><span class=line><span class=meta>        key = "delay"</span></span><br><span class=line><span class=meta></span></span><br><span class=line><span class=meta>))</span></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>listenMessage15</span><span class=params>(Message msg)</span> </span>{</span><br><span class=line>    log.info(<span class=string>"direct2, Spring接收到消费消息"</span> + msg);</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>rabbitTemplate.convertAndSend(exchangeName,<span class=string>"queue1"</span>, <span class=string>"hihihi"</span>,(msg)->{</span><br><span class=line>    msg.getMessageProperties().setHeader(<span class=string>"x-delay"</span>, <span class=number>10000</span>);</span><br><span class=line>    <span class=comment>//   msg.getMessageProperties().setDelayLong(1000L);</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> msg;</span><br><span class=line>});</span><br></pre></table></figure><p>实现原理是,有一个时钟,当达到超时时间进行任务,因此对cpu压力较大. 适合延时时间较短的场景.<p>应用:取消超时订单<p><img alt=image-20250724154804554 data-src=https://s2.loli.net/2025/07/24/q4FaG2AV5BWoXxD.png><p>订单完成后,发送延迟消息,进行延迟消息处理,监听对应的延迟消息队列,接收到消息id,查看订单是否已支付,如果支付,则return. 否则继续向延迟交换机发送消息,延迟时间可以设置更长一点.当延迟时间达到最大时间后,取消该订单并恢复库存(事务).<h2 id=代码案例><a class=headerlink href=#代码案例 title=代码案例></a>代码案例</h2><p>最简单的消息发送,直接根据队列名字发送,不通过交换机<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Test</span></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>contextLoads</span><span class=params>()</span> </span>{</span><br><span class=line>    String queueName = <span class=string>"hello.queue1"</span>;</span><br><span class=line>    rabbitTemplate.convertAndSend(queueName, <span class=string>"hello"</span>);</span><br><span class=line>}</span><br></pre></table></figure><p>在接受消息上,spring-amqp提供声明式的消息监听,通过注解在方法上声明要监听的队列名称<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Slf4j</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>MqListener</span> </span>{</span><br><span class=line>    <span class=meta>@RabbitListener(queues = "hello.queue1")</span></span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>listenMessage</span><span class=params>(String msg)</span> </span>{</span><br><span class=line>        log.info(<span class=string>"Spring接收到消费消息"</span>+ msg);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>多个消费者绑定到同一个队列时,同一个消息只能被一个消费者消费,默认情况下将消息一次轮询投递给绑定在队列上的每一个消费者,没有考虑消费者是否已经处理完消息(消费者处理能力),可能出现消息堆积.<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># 每次只能获取一条消息,处理完后再取</span></span><br><span class=line><span class=meta>spring.rabbitmq.listener.simple.prefetch</span>=<span class=string>1</span></span><br></pre></table></figure><p><img alt=image-20250723141413063 data-src=https://s2.loli.net/2025/07/23/3ANVlJm2jqtbDvh.png><p>创建队列,交换机以及绑定关系<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>FanOutConfig</span> </span>{</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> FanoutExchange  <span class=title>exchange</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> ExchangeBuilder.fanoutExchange(<span class=string>"exchange"</span>).build();</span><br><span class=line><span class=comment>//        return new FanoutExchange("exchange");</span></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> Queue <span class=title>fanoutQueue1</span><span class=params>()</span> </span>{</span><br><span class=line><span class=comment>//        return QueueBuilder.durable("queue").build();</span></span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> Queue(<span class=string>"queue"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> Queue <span class=title>fanoutQueue2</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> Queue(<span class=string>"queue2"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> Binding <span class=title>binding</span><span class=params>(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> Binding <span class=title>bindingQueue2</span><span class=params>(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>除了创建@Bean的方式,还可以通过注解方式.<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=line><span class=meta>        value = @Queue(value = "queue1", durable = "true"),</span></span><br><span class=line><span class=meta>        exchange = @Exchange(value = "exchange1", type = "direct"),</span></span><br><span class=line><span class=meta>        key = "test1"</span></span><br><span class=line><span class=meta>))</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>listenQueue1</span><span class=params>(String msg)</span> </span>{</span><br><span class=line>    log.info(<span class=string>"msg"</span>);</span><br><span class=line>}</span><br></pre></table></figure><p><img alt=image-20250723165130608 data-src=https://s2.loli.net/2025/07/23/qDZUVliadH42pku.png><div class=table-container><table><thead><tr><th>元素<th>默认持久化属性 (<code>durable</code>)<th>默认 <code>delivery_mode</code><th>行为解释<tbody><tr><td><strong>消息</strong><td><strong>否</strong> (<code>delivery_mode=1</code>)<td><code>1</code> (非持久化)<td>Broker 重启会丢失，即使队列持久化。<tr><td><strong>队列</strong><td><strong>是</strong> (<code>durable=true</code>)<td>N/A<td>Broker 重启后队列元数据不会丢失。<tr><td><strong>交换机</strong><td><strong>是</strong> (<code>durable=true</code>)<td>N/A<td>Broker 重启后交换机元数据不会丢失。</table></div><p>导出到 Google 表格<h2 id=消息转换器><a class=headerlink href=#消息转换器 title=消息转换器></a>消息转换器</h2><p>如果发送的不是提供的Message对象或者字符串等,而是直接的pojo或者map,会通过消息转换器进行转换. 对消息对象的处理默认实现是SimpleMessageConverter,基于JDK的ObjectOutputStream完成序列化. 存在问题:JDK序列化消息可读性差,消息太大,有安全风险.<p>采用json序列化替代默认的JDK序列化<h2 id=面试重点><a class=headerlink href=#面试重点 title=面试重点></a>面试重点</h2><h3 id=交换机（Exchange）的面试重点><a class=headerlink href=#交换机（Exchange）的面试重点 title=交换机（Exchange）的面试重点></a>交换机（Exchange）的面试重点</h3><ol><li><p><strong>交换机的核心作用：</strong></p> <ul><li>它是消息路由的<strong>第一站</strong>，解耦了生产者和队列。<li>不存储消息，只负责转发。</ul><li><p><strong>四种交换机类型及其路由规则：</strong></p> <ul><li><strong>Direct (直连)：</strong> 精确匹配路由键。<li><strong>Topic (主题)：</strong> 模式匹配（<code>*</code>, <code>#</code> 通配符）。<li><strong>Fanout (扇形)：</strong> 广播到所有绑定队列，忽略路由键。<li><strong>Headers (头)：</strong> 根据消息头属性匹配（较少用）。<li><strong>面试时，能够清晰地解释每种类型的路由机制和适用场景是关键。</strong></ul><li><p><strong>路由键 (Routing Key) 和绑定键 (Binding Key) 的区别和联系：</strong></p> <ul><li><strong>Routing Key：</strong> 生产者发送消息时附带的，描述消息的属性。<li><strong>Binding Key：</strong> 队列与交换机绑定时定义的，描述队列希望接收哪类消息。<li><strong>关系：</strong> 交换机根据这两者进行匹配，将消息路由到队列。它们的匹配规则取决于交换机的类型。</ul><li><p><strong>绑定 (Binding) 的概念：</strong></p> <ul><li>它是交换机和队列之间的<strong>关联关系</strong>，定义了消息如何从交换机流向队列。</ul><li><p><strong>死信交换机 (Dead Letter Exchange, DLX) 和死信队列 (Dead Letter Queue, DLQ)：</strong></p> <ul><li>虽然 DLX/DLQ 不是交换机类型，但它是一个非常重要的概念，涉及到消息无法被消费时的处理。当消息出现以下情况时，会被转发到死信交换机：<ul><li>消息被消费者拒收 (rejected)，并且 <code>requeue</code> 参数设置为 <code>false</code>。<li>消息 TTL (Time-To-Live) 过期。<li>队列达到最大长度 (max-length)。</ul><li>面试中常与消息可靠性、异常处理等话题结合考察。</ul><li><p><strong>持久化 (Durable) 交换机：</strong></p> <ul><li>和队列一样，交换机也可以被声明为持久化的。这意味着即使 RabbitMQ 服务重启，交换机本身（及其类型、名称、配置）也不会丢失。<li><strong>注意：</strong> 持久化交换机只保证交换机的元数据不丢失，不保证消息本身。消息的持久化取决于消息的 <code>delivery_mode</code> 和队列的持久化配置。</ul><li><p><strong>消息丢失场景：</strong></p> <ul><li>消息到达交换机，但没有匹配到任何队列（除非有备份交换机）。<li>消息被发送到非持久化交换机，且 RabbitMQ 服务重启。</ul><li><p><strong>备份交换机 (Alternate Exchange, AE)：</strong></p> <p>当消息无法被路由到任何队列时，交换机可以将这些消息发送到预先配置的备份交换机。这对于捕获和处理那些未能成功路由的消息非常有用，防止消息静默丢失。</p> <p>如果交换机收到的消息路由键没有匹配到任何队列，消息默认会被丢弃。这会引出<strong>备份交换机 (Alternate Exchange)</strong> 的概念，它可以在消息无法被路由时捕获这些消息。</p></ol><p><strong>死信交换机 (Dead Letter Exchange, DLX) 和死信队列 (Dead Letter Queue, DLQ)：</strong><ul><li>虽然 DLX/DLQ 不是交换机类型，但它是一个非常重要的概念，涉及到消息无法被消费时的处理。当消息出现以下情况时，会被转发到死信交换机：<ul><li>消息被消费者拒收 (rejected)，并且 <code>requeue</code> 参数设置为 <code>false</code>。<li>消息 TTL (Time-To-Live) 过期。<li>队列达到最大长度 (max-length)。</ul><li>面试中常与消息可靠性、异常处理等话题结合考察。</ul><h2 id=遇到的问题><a class=headerlink href=#遇到的问题 title=遇到的问题></a>遇到的问题</h2><h3 id=使用Jackson2json转化器报错><a class=headerlink href=#使用Jackson2json转化器报错 title=使用Jackson2json转化器报错></a>使用Jackson2json转化器报错</h3><p>如果在使用convertAndSend发送消息时可以发现,如果传输的本身就是Message,会直接传输,不做特别处理.但如果在RabbitListener中参数设置为Message,会报conversion异常,这是为什么呢. 核心原因是,在接受消息时,MessagingMessageConverter会调用Jackson2jsonConverter的fromMessage方法,它会根据消息的属性和头部进行推断类型,如果是没有,则会默认将Message的body二进制数据json反序列化为Object,如果转化失败就报错(比如是string的二进制数据).<p>下面是具体分析:<p>使用jacksonmessageconverter消息序列化机制<p>如果是传入对象,首先是Message直接返回,否则进行转换,调用这个converter的toMessage<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>protected</span> Message <span class=title>convertMessageIfNecessary</span><span class=params>(Object object)</span> </span>{</span><br><span class=line>    <span class=keyword>if</span> (object <span class=keyword>instanceof</span> Message msg) {</span><br><span class=line>        <span class=keyword>return</span> msg;</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>this</span>.getRequiredMessageConverter().toMessage(object, <span class=keyword>new</span> MessageProperties());</span><br><span class=line>    }</span><br><span class=line>} <span class=comment>// RabbitTemplate类中</span></span><br></pre></table></figure><p>然后会在AbstactMessageConverter中调用toMessage方法,jackson2json本身没有toMessage方法,<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>final</span> Message <span class=title>toMessage</span><span class=params>(Object object, <span class=meta>@Nullable</span> MessageProperties messagePropertiesArg, <span class=meta>@Nullable</span> Type genericType)</span> <span class=keyword>throws</span> MessageConversionException </span>{</span><br><span class=line>    MessageProperties messageProperties = messagePropertiesArg;</span><br><span class=line>    <span class=keyword>if</span> (messagePropertiesArg == <span class=keyword>null</span>) {</span><br><span class=line>        messageProperties = <span class=keyword>new</span> MessageProperties();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    Message message = <span class=keyword>this</span>.createMessage(object, messageProperties, genericType);</span><br><span class=line>    messageProperties = message.getMessageProperties();</span><br><span class=line>    <span class=keyword>if</span> (<span class=keyword>this</span>.createMessageIds && messageProperties.getMessageId() == <span class=keyword>null</span>) {</span><br><span class=line>        messageProperties.setMessageId(UUID.randomUUID().toString());</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> message;</span><br><span class=line>}</span><br></pre></table></figure><p>注意new MessageProperties得到的消息content-type默认是<code>application/octet-stream</code>,然后通过AbstractJackson2MessageConverter的createMessage创建消息,这里就是关键了,这个converter的this.supportedContentType只有<code>application/json</code>,所以这里创建消息,并根据数据设置了长度的属性<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line>messageProperties.setContentType(<span class=keyword>this</span>.supportedContentType.toString());</span><br><span class=line><span class=keyword>if</span> (<span class=keyword>this</span>.supportedCTCharset == <span class=keyword>null</span>) {</span><br><span class=line>    messageProperties.setContentEncoding(<span class=keyword>this</span>.getDefaultCharset());</span><br><span class=line>}</span><br><span class=line></span><br><span class=line>messageProperties.setContentLength((<span class=keyword>long</span>)bytes.length);</span><br><span class=line><span class=keyword>if</span> (<span class=keyword>this</span>.getClassMapper() == <span class=keyword>null</span>) {</span><br><span class=line>    JavaType type = <span class=keyword>this</span>.objectMapper.constructType((Type)(genericType == <span class=keyword>null</span> ? objectToConvert.getClass() : genericType));</span><br><span class=line>    <span class=keyword>if</span> (genericType != <span class=keyword>null</span> && !type.isContainerType() && Modifier.isAbstract(type.getRawClass().getModifiers())) {</span><br><span class=line>        type = <span class=keyword>this</span>.objectMapper.constructType(objectToConvert.getClass());</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>this</span>.getJavaTypeMapper().fromJavaType(type, messageProperties);</span><br><span class=line>} <span class=keyword>else</span> {</span><br><span class=line>    <span class=keyword>this</span>.getClassMapper().fromClass(objectToConvert.getClass(), messageProperties);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>return</span> <span class=keyword>new</span> Message(bytes, messageProperties);</span><br></pre></table></figure><p>到此,toMessage结束.<p>而在接受消息时,在AbstactMessageListenerContainer中,接收到消息后调用onMessage方法,它会调用messagingMessageListenerAdapter中的toMessage方法,在这个方法中又调用toMessagingMessage方法,然后在其中调用fromMessage方法,在这里就是MessagingMessageConverter的fromMessage方法,<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>protected</span> Message&LT?> toMessagingMessage(org.springframework.amqp.core.Message amqpMessage) {</span><br><span class=line>    <span class=keyword>return</span> (Message)<span class=keyword>this</span>.getMessagingMessageConverter().fromMessage(amqpMessage);</span><br><span class=line>}</span><br></pre></table></figure><p>其中有一个extractPayload调用了extractMessage方法<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>protected</span> Object <span class=title>extractPayload</span><span class=params>(org.springframework.amqp.core.Message message)</span> </span>{</span><br><span class=line>    MessageProperties messageProperties = message.getMessageProperties();</span><br><span class=line>    <span class=keyword>if</span> (<span class=keyword>this</span>.bean != <span class=keyword>null</span>) {</span><br><span class=line>        messageProperties.setTargetBean(<span class=keyword>this</span>.bean);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (<span class=keyword>this</span>.method != <span class=keyword>null</span>) {</span><br><span class=line>        messageProperties.setTargetMethod(<span class=keyword>this</span>.method);</span><br><span class=line>        <span class=keyword>if</span> (<span class=keyword>this</span>.inferredArgumentType != <span class=keyword>null</span>) {</span><br><span class=line>            messageProperties.setInferredArgumentType(<span class=keyword>this</span>.inferredArgumentType);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> MessagingMessageListenerAdapter.<span class=keyword>this</span>.extractMessage(message);</span><br><span class=line>}</span><br></pre></table></figure><p>在extractMessage中获取了jackson2jsonMessageConverter,然后调用其fromMessage方法.<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>protected</span> Object <span class=title>extractMessage</span><span class=params>(Message message)</span> </span>{</span><br><span class=line>    MessageConverter converter = <span class=keyword>this</span>.getMessageConverter();</span><br><span class=line>    <span class=keyword>return</span> converter != <span class=keyword>null</span> ? converter.fromMessage(message) : message;</span><br><span class=line>}</span><br></pre></table></figure><p>其中会进行判断,如果不是octet-stream或者application/json以及null等,会报不支持<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>public</span> Object <span class=title>fromMessage</span><span class=params>(Message message, <span class=meta>@Nullable</span> Object conversionHint)</span> <span class=keyword>throws</span> MessageConversionException </span>{</span><br><span class=line>    Object content = <span class=keyword>null</span>;</span><br><span class=line>    MessageProperties properties = message.getMessageProperties();</span><br><span class=line>    <span class=keyword>if</span> (properties != <span class=keyword>null</span>) {</span><br><span class=line>        String contentType = properties.getContentType();</span><br><span class=line>        <span class=keyword>if</span> ((!<span class=keyword>this</span>.assumeSupportedContentType || contentType != <span class=keyword>null</span> && !contentType.equals(<span class=string>"application/octet-stream"</span>)) && (contentType == <span class=keyword>null</span> || !contentType.contains(<span class=keyword>this</span>.supportedContentType.getSubtype()))) {</span><br><span class=line>            <span class=keyword>if</span> (<span class=keyword>this</span>.log.isWarnEnabled()) {</span><br><span class=line>                <span class=keyword>this</span>.log.warn(<span class=string>"Could not convert incoming message with content-type ["</span> + contentType + <span class=string>"], '"</span> + <span class=keyword>this</span>.supportedContentType.getSubtype() + <span class=string>"' keyword missing."</span>);</span><br><span class=line>            }</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            String encoding = <span class=keyword>this</span>.determineEncoding(properties, contentType);</span><br><span class=line>            content = <span class=keyword>this</span>.doFromMessage(message, conversionHint, properties, encoding);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (content == <span class=keyword>null</span>) {</span><br><span class=line>        <span class=keyword>if</span> (<span class=keyword>this</span>.nullAsOptionalEmpty) {</span><br><span class=line>            content = Optional.empty();</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            content = message.getBody();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> content;</span><br><span class=line>}</span><br></pre></table></figure><p>然后会在convertContent中进行转换得到目标对象<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>private</span> Object <span class=title>doFromMessage</span><span class=params>(Message message, Object conversionHint, MessageProperties properties, String encoding)</span> </span>{</span><br><span class=line>    Object content = <span class=keyword>null</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>        content = <span class=keyword>this</span>.convertContent(message, conversionHint, properties, encoding);</span><br><span class=line>        <span class=keyword>return</span> content;</span><br><span class=line>    } <span class=keyword>catch</span> (IOException e) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> MessageConversionException(<span class=string>"Failed to convert Message content"</span>, e);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>private</span> Object <span class=title>convertContent</span><span class=params>(Message message, Object conversionHint, MessageProperties properties, String encoding)</span> <span class=keyword>throws</span> IOException </span>{</span><br><span class=line>    Object content = <span class=keyword>null</span>;</span><br><span class=line>    JavaType inferredType = <span class=keyword>this</span>.javaTypeMapper.getInferredType(properties);</span><br><span class=line>    <span class=keyword>if</span> (inferredType != <span class=keyword>null</span> && <span class=keyword>this</span>.useProjectionForInterfaces && inferredType.isInterface() && !inferredType.getRawClass().getPackage().getName().startsWith(<span class=string>"java.util"</span>)) {</span><br><span class=line>        content = <span class=keyword>this</span>.projectingConverter.convert(message, inferredType.getRawClass());</span><br><span class=line>        properties.setProjectionUsed(<span class=keyword>true</span>);</span><br><span class=line>    } <span class=keyword>else</span> <span class=keyword>if</span> (inferredType != <span class=keyword>null</span> && <span class=keyword>this</span>.alwaysConvertToInferredType) {</span><br><span class=line>        content = <span class=keyword>this</span>.tryConverType(message, encoding, inferredType);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (content == <span class=keyword>null</span>) {</span><br><span class=line>        <span class=keyword>if</span> (conversionHint <span class=keyword>instanceof</span> ParameterizedTypeReference) {</span><br><span class=line>            ParameterizedTypeReference&LT?> parameterizedTypeReference = (ParameterizedTypeReference)conversionHint;</span><br><span class=line>            content = <span class=keyword>this</span>.convertBytesToObject(message.getBody(), encoding, <span class=keyword>this</span>.objectMapper.getTypeFactory().constructType(parameterizedTypeReference.getType()));</span><br><span class=line>        } <span class=keyword>else</span> <span class=keyword>if</span> (<span class=keyword>this</span>.getClassMapper() == <span class=keyword>null</span>) {</span><br><span class=line>            JavaType targetJavaType = <span class=keyword>this</span>.getJavaTypeMapper().toJavaType(message.getMessageProperties());</span><br><span class=line>            content = <span class=keyword>this</span>.convertBytesToObject(message.getBody(), encoding, targetJavaType);</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            Class&LT?> targetClass = <span class=keyword>this</span>.getClassMapper().toClass(message.getMessageProperties());</span><br><span class=line>            content = <span class=keyword>this</span>.convertBytesToObject(message.getBody(), encoding, targetClass);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> content;</span><br><span class=line>}</span><br></pre></table></figure><p>得到content,如果为null,则取message.body,然后将该对象包装为message<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>if</span> (content == <span class=keyword>null</span>) {</span><br><span class=line>    <span class=keyword>if</span> (<span class=keyword>this</span>.nullAsOptionalEmpty) {</span><br><span class=line>        content = Optional.empty();</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>        content = message.getBody();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>Object convertedObject = <span class=keyword>this</span>.extractPayload(message);</span><br><span class=line><span class=keyword>if</span> (convertedObject == <span class=keyword>null</span>) {</span><br><span class=line>    <span class=keyword>throw</span> <span class=keyword>new</span> MessageConversionException(<span class=string>"Message converter returned null"</span>);</span><br><span class=line>} <span class=keyword>else</span> {</span><br><span class=line>    MessageBuilder&LTObject> builder = convertedObject <span class=keyword>instanceof</span> Message ? MessageBuilder.fromMessage((Message)convertedObject) : MessageBuilder.withPayload(convertedObject);</span><br><span class=line>    <span class=keyword>return</span> builder.copyHeadersIfAbsent(mappedHeaders).build();</span><br><span class=line>}</span><br></pre></table></figure><p>出现的问题是,如果send发送Message,在convertMessageIfNecessary会直接返回Message,<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>Message build = MessageBuilder.withBody(<span class=string>"Helloaa aa "</span>.getBytes(StandardCharsets.UTF_8)).build();</span><br><span class=line>rabbitTemplate.convertAndSend(exchangeName,<span class=string>"queue1"</span>, build);</span><br></pre></table></figure><p>其content-type默认是octet-stream,其中的关键就是,这里根据消息属性判断targetJavaType是Object,<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>if</span> (content == <span class=keyword>null</span>) {</span><br><span class=line> <span class=comment>/// ....</span></span><br><span class=line>    } <span class=keyword>else</span> <span class=keyword>if</span> (<span class=keyword>this</span>.getClassMapper() == <span class=keyword>null</span>) {</span><br><span class=line>        JavaType targetJavaType = <span class=keyword>this</span>.getJavaTypeMapper().toJavaType(message.getMessageProperties());</span><br><span class=line>        content = <span class=keyword>this</span>.convertBytesToObject(message.getBody(), encoding, targetJavaType);</span><br><span class=line>}</span><br></pre></table></figure><p>具体判断如下,首先根据属性判断,如果为空再根据”_<em>TypeId_</em>“头判断,如果还为空,就默认object了<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>public</span> JavaType <span class=title>toJavaType</span><span class=params>(MessageProperties properties)</span> </span>{</span><br><span class=line>    JavaType inferredType = <span class=keyword>this</span>.getInferredType(properties);</span><br><span class=line>    <span class=keyword>if</span> (inferredType != <span class=keyword>null</span> && <span class=keyword>this</span>.canConvert(inferredType)) {</span><br><span class=line>        <span class=keyword>return</span> inferredType;</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>        String typeIdHeader = <span class=keyword>this</span>.retrieveHeaderAsString(properties, <span class=keyword>this</span>.getClassIdFieldName());</span><br><span class=line>        <span class=keyword>if</span> (typeIdHeader != <span class=keyword>null</span>) {</span><br><span class=line>            <span class=keyword>return</span> <span class=keyword>this</span>.fromTypeHeader(properties, typeIdHeader);</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=keyword>return</span> <span class=keyword>this</span>.hasInferredTypeHeader(properties) ? <span class=keyword>this</span>.fromInferredTypeHeader(properties) : TypeFactory.defaultInstance().constructType(Object.class);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>content在进行convertBytesToObject转化过程中报异常,因为byte[]内容是字符串,但转为了Object,而且是通过jackson反序列化转的<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> &LTT> <span class=function>T <span class=title>readValue</span><span class=params>(String content, JavaType valueType)</span> <span class=keyword>throws</span> JsonProcessingException, JsonMappingException </span>{</span><br><span class=line>    <span class=keyword>this</span>._assertNotNull(<span class=string>"content"</span>, content);</span><br><span class=line></span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>        <span class=keyword>return</span> (T)<span class=keyword>this</span>._readMapAndClose(<span class=keyword>this</span>._jsonFactory.createParser(content), valueType);</span><br><span class=line>    } <span class=keyword>catch</span> (JsonProcessingException e) {</span><br><span class=line>        <span class=keyword>throw</span> e;</span><br><span class=line>    } <span class=keyword>catch</span> (IOException e) {</span><br><span class=line>        <span class=keyword>throw</span> JsonMappingException.fromUnexpectedIOE(e);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>在<code>return (T)this._readMapAndClose(this._jsonFactory.createParser(content), valueType);</code>出错. 所以核心原因还是类型设置为octet-stream会被认为是可以json反序列化的对象.如果直接传字符串,jackon会帮我们序列化为字符串,并在消息属性的头部headers设置<code>__TypeId__</code>类型为String. 但我们自己 手动序列化的数据并填充到Message显然不会有这些机制.<p><img alt=image-20250724144930607 data-src=https://s2.loli.net/2025/07/24/fde7GAnb34KDgUp.png><p>这时什么时候设置的呢? 其实就是在AbstractJackson2MessageConverter的createMessage时,<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>if</span> (<span class=keyword>this</span>.getClassMapper() == <span class=keyword>null</span>) {</span><br><span class=line>    JavaType type = <span class=keyword>this</span>.objectMapper.constructType((Type)(genericType == <span class=keyword>null</span> ? objectToConvert.getClass() : genericType));</span><br><span class=line>    <span class=keyword>if</span> (genericType != <span class=keyword>null</span> && !type.isContainerType() && Modifier.isAbstract(type.getRawClass().getModifiers())) {</span><br><span class=line>        type = <span class=keyword>this</span>.objectMapper.constructType(objectToConvert.getClass());</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>this</span>.getJavaTypeMapper().fromJavaType(type, messageProperties);</span><br><span class=line>} <span class=keyword>else</span> {</span><br><span class=line>    <span class=keyword>this</span>.getClassMapper().fromClass(objectToConvert.getClass(), messageProperties);</span><br><span class=line>}</span><br></pre></table></figure><p>将对应的类型写入头部<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>fromJavaType</span><span class=params>(JavaType javaType, MessageProperties properties)</span> </span>{</span><br><span class=line>    <span class=keyword>this</span>.addHeader(properties, <span class=keyword>this</span>.getClassIdFieldName(), javaType.getRawClass());</span><br><span class=line>    <span class=keyword>if</span> (javaType.isContainerType() && !javaType.isArrayType()) {</span><br><span class=line>        <span class=keyword>this</span>.addHeader(properties, <span class=keyword>this</span>.getContentClassIdFieldName(), javaType.getContentType().getRawClass());</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (javaType.getKeyType() != <span class=keyword>null</span>) {</span><br><span class=line>        <span class=keyword>this</span>.addHeader(properties, <span class=keyword>this</span>.getKeyClassIdFieldName(), javaType.getKeyType().getRawClass());</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><h1 id=Netty><a class=headerlink href=#Netty title=Netty></a>Netty</h1><p>Netty 是一个高性能、事件驱动的异步网络应用框架，广泛用于构建可扩展的服务器和客户端程序.<p>基于 Java NIO(同步非阻塞IO)，但对其进行了封装和增强，使其更易于使用和性能更优。<h2 id=关键概念><a class=headerlink href=#关键概念 title=关键概念></a>关键概念</h2><h4 id=NIO><a class=headerlink href=#NIO title=NIO></a>NIO</h4><p>NIO是Netty 的基石。传统的 I/O（BIO）是阻塞的，每个连接都需要一个线程处理。NIO 允许单个线程处理多个 I/O 操作，通过 <strong>Selector</strong> 机制监听多个 Channel 上的事件，从而实现高并发。Netty 在 NIO 之上进行了抽象和优化，使其使用起来更加简单和高效。<h3 id=IO多路复用><a class=headerlink href=#IO多路复用 title=IO多路复用></a>IO多路复用</h3><div class=table-container><table><thead><tr><th>特性<th><code>select</code><th><code>poll</code><th><code>epoll</code><tbody><tr><td><strong>FD 数量限制</strong><td>默认 1024/2048 (固定位图)<td>无限制 (受限于内存)<td>无限制 (受限于内存)<tr><td><strong>FD 传递</strong><td>每次调用完整复制 (<code>fd_set</code>)<td>每次调用完整复制 (<code>pollfd[]</code>)<td>一次注册，之后只返回就绪 FD<tr><td><strong>效率</strong><td>O(N) (遍历所有 FD)<td>O(N) (遍历所有 FD)<td>O(K) (只遍历就绪 FD, K << N)<tr><td><strong>通知机制</strong><td>遍历查找<td>遍历查找<td>回调机制，内核通知就绪<tr><td><strong>工作模式</strong><td>水平触发 (LT)<td>水平触发 (LT)<td>水平触发 (LT) / 边缘触发 (ET)<tr><td><strong>“惊群”问题</strong><td>存在<td>存在<td>已优化，通常避免<tr><td><strong>API 使用</strong><td>相对复杂<td>相对简单 (比 <code>select</code>)<td>需要三个系统调用 (<code>create</code>, <code>ctl</code>, <code>wait</code>)<tr><td><strong>出现时间</strong><td>最早<td>较早<td>Linux 2.5.44+ (最新)</table></div><p>“惊群”问题：<strong>当一个事件发生时，所有等待该事件的进程或线程都被唤醒，但实际上只有其中一个能够处理该事件，导致其他被唤醒的进程/线程做了无用功，并产生不必要的上下文切换开销，从而降低了系统效率和性能。</strong><p>FD传递指的是用户空间每次调用<code>select</code>或 <code>poll</code> 时，需要将 <code>fd_set</code>或<code>pollfd</code> 数组从用户空间<strong>完整地复制到内核空间</strong>, FD 就绪时，内核会修改对应 <code>pollfd</code> 结构体中的 <code>revents</code> 字段，并将其<strong>完整地复制回用户空间</strong>。<p>而在epoll中用户程序通过 <code>epoll_create()</code> 创建一个 <code>epoll</code> 实例。然后通过 <code>epoll_ctl()</code> <strong>一次性地将所有要监控的 FD 注册到内核的 <code>epoll</code> 事件表中</strong>，并指定感兴趣的事件。这个过程只需要将 FD 及其事件类型从用户空间复制到内核空间一次.<p><code>epoll_wait()</code> 调用时，内核<strong>只将就绪列表中的 FD 复制到用户空间</strong>。用户程序只需要遍历这些就绪的 FD 即可。<p>通知机制指的是内核修改了fd_set位图的值并完整返回,<code>fd_set</code> 仍然是一个<strong>位图 (bitmap)</strong>。它不像一个列表或数组那样直接给出就绪的 FD 列表。它只是在对应 FD 的位上设置为 1，而其他未就绪的 FD 的位仍为 0。为了知道具体是哪个文件描述符就绪了，用户程序必须遍历逐个检查,poll<code>也是类似的，它返回一个</code>pollfd<code>数组，你需要遍历这个数组来检查每个元素的</code>revents` 字段，找出就绪的 FD。<p>而 <code>epoll</code> 则不同，<code>epoll_wait</code> 会直接返回一个<strong>已就绪文件描述符的列表或数组</strong>，用户程序只需要遍历这个较小的就绪列表即可，因此效率更高，时间复杂度是 O(K)。<h3 id=Netty相比NIO改进><a class=headerlink href=#Netty相比NIO改进 title=Netty相比NIO改进></a>Netty相比NIO改进</h3><p>Channel->NioSocketChannel/NioServerSocketChannel<p>Selector->EventLoop/EventLoppGroup<p>Buffer->ByteBuf<p>此外通过ChannelPipeline和ChannelHanlder来处理自定义事件.<h3 id=EventLoop-amp-EventLoopGroup-事件循环与事件循环组><a title="EventLoop & EventLoopGroup 事件循环与事件循环组" class=headerlink href=#EventLoop-amp-EventLoopGroup-事件循环与事件循环组></a>EventLoop & EventLoopGroup 事件循环与事件循环组</h3><ul><li><strong>EventLoop:</strong> Netty 的核心线程模型。每个 <code>EventLoop</code> 是一个单线程，负责处理一个或多个 <strong>Channel</strong> 上的所有 I/O 事件（如连接建立、数据读写、断开连接），并执行关联的 <strong>ChannelHandler</strong>。它以事件驱动的方式运行，通过一个循环不断地从任务队列中获取事件并执行。<li><strong>EventLoopGroup:</strong> 包含一个或多个 <code>EventLoop</code> 的组。通常有两个 <code>EventLoopGroup</code>：<ul><li><strong>BossGroup (或 AcceptorGroup):</strong> 负责处理客户端的连接请求。一旦接受到连接，就会将连接注册到 WorkerGroup 中的某个 <code>EventLoop</code> 上。通常只有一个 <code>EventLoop</code> 或少量 <code>EventLoop</code>。<li><strong>WorkerGroup:</strong> 负责处理已建立连接的 I/O 读写事件和业务逻辑。包含多个 <code>EventLoop</code>，以实现并发处理。</ul></ul><p><strong>Channel 通道</strong> Netty 对网络连接的抽象。可以看作是连接双方进行数据传输的“通道”。所有的 I/O 操作都在 Channel 上进行。不同类型的 Channel 对应不同的传输协议（如 <code>NioSocketChannel</code> 用于 TCP/IP，<code>NioDatagramChannel</code> 用于 UDP）。<h3 id=ChannelHandler-amp-ChannelPipeline-处理器与处理器链><a title="ChannelHandler & ChannelPipeline 处理器与处理器链" class=headerlink href=#ChannelHandler-amp-ChannelPipeline-处理器与处理器链></a>ChannelHandler & ChannelPipeline 处理器与处理器链</h3><ul><li><strong>ChannelHandler:</strong> 消息处理的核心组件。它是一个接口，定义了处理入站 (Inbound) 或出站 (Outbound) 事件的方法。<ul><li><strong>ChannelInboundHandler:</strong> 处理从网络读入的数据（入站事件），例如接收到连接、读取数据、处理异常等。<li><strong>ChannelOutboundHandler:</strong> 处理向网络写入的数据（出站事件），例如发送数据、连接断开等。<li>你可以自定义 <code>ChannelHandler</code> 来实现协议编解码、业务逻辑处理、日志记录、流量控制等功能。</ul><li><strong>ChannelPipeline:</strong> <code>ChannelHandler</code> 的链表。每个 <code>Channel</code> 都有一个 <code>ChannelPipeline</code>。当 I/O 事件发生时，数据会沿着 <code>ChannelPipeline</code> 在不同的 <code>ChannelHandler</code> 之间流动，形成一个责任链模式。<ul><li><strong>入站事件 (Inbound Event):</strong> 数据从网络流入，从 <code>ChannelPipeline</code> 的头部（第一个 <code>ChannelHandler</code>）开始，依次向后传递，直到链的尾部。<li><strong>出站事件 (Outbound Event):</strong> 数据从应用程序流出到网络，从 <code>ChannelPipeline</code> 的尾部（通常是触发写入操作的地方）开始，依次向前传递，直到链的头部。</ul></ul><h3 id=ByteBuf-字节缓冲区><a title="ByteBuf 字节缓冲区" class=headerlink href=#ByteBuf-字节缓冲区></a>ByteBuf 字节缓冲区</h3><p>Netty 自己的高性能字节缓冲区，用于替换 Java NIO 的 <code>ByteBuffer</code>。<code>ByteBuf</code> 提供了许多优化和改进，使其更易于使用，例如：<ul><li><strong>读写指针分离：</strong> 独立的 <code>readerIndex</code> 和 <code>writerIndex</code>，避免了 <code>ByteBuffer</code> 复杂的 <code>flip()</code> 操作。<li><strong>动态扩容：</strong> 当容量不足时，可以自动扩容。<li><strong>零拷贝 (Zero-Copy)：</strong> 通过复合缓冲区（CompositeByteBuf）和切片（Slice）等机制，尽量减少数据在内存中的拷贝，提高性能。<li><strong>引用计数：</strong> 自动管理内存，防止内存泄漏。</ul><h3 id=Future-amp-Promise-异步结果与承诺><a title="Future & Promise 异步结果与承诺" class=headerlink href=#Future-amp-Promise-异步结果与承诺></a>Future & Promise 异步结果与承诺</h3><ul><li><strong>Future:</strong> Java 并发包中的 <code>Future</code> 增强版。在 Netty 中，所有的 I/O 操作都是异步的，它们会立即返回一个 <code>ChannelFuture</code> 对象。你可以通过监听 <code>ChannelFuture</code> 来获取操作的最终结果（成功、失败或取消）。<li><strong>Promise:</strong> <code>Future</code> 的子接口，允许在某个点设置 <code>Future</code> 的结果，从而完成异步操作。</ul><h3 id=编解码器-Encoders-amp-Decoders><a title="编解码器 (Encoders & Decoders)" class=headerlink href=#编解码器-Encoders-amp-Decoders></a>编解码器 (Encoders & Decoders)</h3><p><code>ChannelHandler</code> 的特殊形式，用于将原始字节数据转换为特定协议的消息对象，以及将消息对象转换回字节数据。<ul><li><strong>Decoder (入站):</strong> 将字节流解码成 Java 对象。<li><strong>Encoder (出站):</strong> 将 Java 对象编码成字节流。<li>Netty 提供了许多内置的编解码器（如 <code>StringEncoder</code>/<code>StringDecoder</code>、HTTP 编解码器），也支持自定义协议编解码。</ul><h2 id=关键问题><a class=headerlink href=#关键问题 title=关键问题></a>关键问题</h2><p>关于 Netty 的问题通常会围绕其高性能、异步特性和核心组件展开。<p><strong>Netty 的优势和使用场景</strong><ul><li><strong>为什么用 Netty？</strong> 高性能、高并发、异步非阻塞、易于开发、稳定可靠、社区活跃。<li><strong>能用来做什么？</strong> RPC 框架（Dubbo、gRPC）、IM 系统、游戏服务器、大数据传输、消息中间件、HTTP 服务器、WebSocket 服务器、代理服务器等。</ul><ol><li><p><strong>Netty 的线程模型</strong></p> <ul><li><strong>EventLoopGroup (Boss/Worker) 的作用？</strong><li><strong>BossGroup (或 AcceptorGroup)</strong>：主要负责<strong>处理客户端的连接请求</strong>。当有新的客户端连接到来时，BossGroup 中的一个 <code>EventLoop</code> 会接受这个连接，并将其注册到 WorkerGroup 中的一个 <code>EventLoop</code> 上。BossGroup 通常只需要一个或少数 <code>EventLoop</code>。<li><strong>WorkerGroup</strong>：负责处理<strong>已建立连接的 I/O 读写事件和业务逻辑</strong>。WorkerGroup 包含多个 <code>EventLoop</code>，每个 <code>EventLoop</code> 都可以处理多个 <code>Channel</code>（连接）上的事件。</ul> <p><strong>Channel 分配机制：</strong> 当 BossGroup 接受一个新连接后，它会使用一个<strong>轮询（Round-Robin）或其他策略，将这个新连接（<code>Channel</code>）注册到 WorkerGroup 中一个特定的 EventLoop</strong> 上。一旦一个 <code>Channel</code> 被分配给某个 <code>EventLoop</code>，该 <code>Channel</code> 的所有后续 I/O 事件（读、写、关闭等）都将由这个 <code>EventLoop</code> 线程负责处理，从而保证了单个 <code>Channel</code> 的事件处理是<strong>线程安全的和有序的</strong></p> <ul><li><p><strong>为什么是单线程 EventLoop？</strong></p> <p>避免了多线程并发访问 <code>Channel</code> 带来的同步开销和复杂性，简化了并发编程模型。一个 <code>Channel</code> 上的所有事件都由同一个 <code>EventLoop</code> 线程顺序处理，保证了事件的顺序性。</p><li><p><strong>I/O 线程和业务线程分离：</strong> 业务逻辑如果在 <code>ChannelHandler</code> 中耗时过长，会阻塞 <code>EventLoop</code> 线程，影响其他 Channel 的 I/O 处理。如何解决？（使用 <code>EventLoop.execute()</code> 提交任务到 EventLoop 线程，或使用 <code>EventLoopGroup</code> 的 <code>next().submit()</code> 提交到另一个线程池）。</p></ul> <p>如果 <code>ChannelHandler</code> 中的业务逻辑执行时间过长，确实会阻塞 <code>EventLoop</code> 线程，导致该 <code>EventLoop</code> 负责的其他 <code>Channel</code> 的 I/O 事件无法及时处理，影响系统的响应性和吞吐量。解决这个问题通常有两种方法：</p> <ol><li><strong>提交任务到 EventLoop 线程：</strong> 对于一些轻量级但又不希望立即执行的任务，可以通过 <code>EventLoop.execute(Runnable task)</code> 或 <code>EventLoop.submit(Callable&LTT> task)</code> 将任务提交到 <code>EventLoop</code> 自身维护的任务队列中。这些任务会在 I/O 操作空闲时被 <code>EventLoop</code> 线程顺序执行，但如果任务依然耗时，仍可能阻塞。<li><strong>使用独立的业务线程池：</strong> 这是更常用的方法，适用于耗时长的业务逻辑。在 <code>ChannelHandler</code> 中，当接收到消息并需要进行耗时操作时，不直接在 <code>EventLoop</code> 线程中执行，而是将该业务逻辑<strong>提交到一个独立的业务线程池（例如 <code>ThreadPoolExecutor</code>）</strong>中执行。当业务逻辑处理完成后，再将结果通过 <code>ChannelHandlerContext</code> 写回 <code>Channel</code>。</ol><li><p><strong>ChannelPipeline 和 ChannelHandler</strong></p> <ul><li><strong>ChannelPipeline 是什么？</strong></ul> <p><strong>ChannelPipeline</strong> 是一个 <code>ChannelHandler</code> 的有序链表。每个 <code>Channel</code> 都有且只有一个 <code>ChannelPipeline</code>。它扮演着事件处理的<strong>责任链</strong>角色，负责协调和管理 <code>ChannelHandler</code> 的执行顺序。</p> <p>双向链表的设计是为了支持消息流的<strong>双向性</strong>：</p> <ul><li><strong>入站事件 (Inbound Event)</strong>：数据从网络流入应用程序（例如客户端发送数据到服务器），事件从 <code>ChannelPipeline</code> 的<strong>头部</strong>（第一个 <code>ChannelHandler</code>）开始，依次向后传递。<li><p><strong>出站事件 (Outbound Event)</strong>：数据从应用程序流出到网络（例如服务器向客户端发送响应），事件从 <code>ChannelPipeline</code> 的<strong>尾部</strong>（通常是业务逻辑触发 <code>write</code> 操作）开始，依次向前传递</p><li><p><strong><code>ChannelInboundHandler</code> 和 <code>ChannelOutboundHandler</code> 的区别？</strong></p></ul> <p><strong><code>ChannelInboundHandler</code> (入站处理器)：</strong></p> <ul><li><strong>职责：</strong> 主要处理从网络端流入到应用程序的事件，例如：连接激活 (<code>channelActive()</code>)、读取数据 (<code>channelRead()</code>)、连接断开 (<code>channelInactive()</code>)、处理异常 (<code>exceptionCaught()</code>) 等。<li><strong>处理顺序：</strong> 在 <code>ChannelPipeline</code> 中，入站事件从<strong>头部向尾部</strong>流动，依次经过每个 <code>ChannelInboundHandler</code>。</ul> <p><strong><code>ChannelOutboundHandler</code> (出站处理器)：</strong></p> <ul><li><strong>职责：</strong> 主要处理从应用程序流出到网络端的事件，例如：写入数据 (<code>write()</code>)、连接 (<code>connect()</code>)、绑定 (<code>bind()</code>)、关闭 (<code>close()</code>) 等。<li><p><strong>处理顺序：</strong> 在 <code>ChannelPipeline</code> 中，出站事件从<strong>尾部向头部</strong>流动，依次经过每个 <code>ChannelOutboundHandler</code>。</p><li><p><strong>如何自定义 Handler？</strong> 常见的 <code>SimpleChannelInboundHandler</code> 和 <code>ChannelDuplexHandler</code>。</p><li><strong><code>ChannelHandlerContext</code> 的作用？</strong> 用于与 Pipeline 中的其他 Handler 交互，以及触发事件。</ul> <p><strong>ChannelHandlerContext</strong> 是 <code>ChannelHandler</code> 与 <code>ChannelPipeline</code> 以及其他 <code>ChannelHandler</code> 之间交互的桥梁。每个 <code>ChannelHandler</code> 被添加到 <code>ChannelPipeline</code> 时，都会创建一个对应的 <code>ChannelHandlerContext</code> 实例。</p> <ul><li><strong>消息在 Pipeline 中传递的机制？</strong> <code>fireChannelRead()</code>、<code>write()</code> 等方法。</ul><li><p><strong>ByteBuf 内存管理</strong></p> <ul><li><strong>为什么不用 <code>ByteBuffer</code> 而用 <code>ByteBuf</code>？</strong> 读写指针分离、动态扩容、引用计数、零拷贝。<li><strong><code>readerIndex</code> 和 <code>writerIndex</code>？</strong> 如何操作数据？<li><strong><code>ByteBuf</code> 的引用计数？</strong> 为什么重要？如何避免内存泄漏？（<code>retain()</code> 和 <code>release()</code>）<li><strong>堆内存 (Heap ByteBuf) 和直接内存 (Direct ByteBuf) 的区别？</strong> 优缺点？什么时候用哪个？（Direct ByteBuf 减少一次拷贝，适用于大文件传输；Heap ByteBuf 更易于 GC）。</ul><li><p><strong>零拷贝 (Zero-Copy)</strong></p> <ul><li><strong>Netty 如何实现零拷贝？</strong> 概念、<code>FileRegion</code>、<code>CompositeByteBuf</code>、<code>ByteBuf.slice()</code>。<li><strong>零拷贝的优势？</strong> 减少 CPU 拷贝，提高 I/O 性能。</ul> <h4 id=什么是-TCP-粘包-拆包？Netty-是如何解决的？><a title="什么是 TCP 粘包/拆包？Netty 是如何解决的？" class=headerlink href=#什么是-TCP-粘包-拆包？Netty-是如何解决的？></a>什么是 TCP 粘包/拆包？Netty 是如何解决的？</h4><p><strong>回答要点：</strong></p> <ul><li><strong>什么是粘包/拆包？</strong><ul><li>TCP 是一个<strong>流式协议</strong>，它不保证每次 <code>read()</code> 或 <code>write()</code> 系统调用对应一个完整的应用层消息。它会把应用层发送的数据看作一个字节流，可能会将小的消息合并（<strong>粘包</strong>）成一个大的 TCP 包发送，也可能将一个大的应用层消息拆分成多个小的 TCP 包（<strong>拆包</strong>）发送。<li><strong>粘包：</strong> 发送方发送了两个独立的小消息 A 和 B，TCP 层可能将它们合并成一个数据包发送，接收方一次性收到 A+B。<li><strong>拆包：</strong> 发送方发送一个大的消息 C，TCP 层可能将其拆分成多个数据包发送，接收方需要多次读取才能得到完整的 C。</ul><li><strong>为什么会发生？</strong><ul><li>TCP 缓冲区机制。<li>Nagle 算法（小数据包合并）。<li>发送方每次发送的数据量与接收方每次读取的数据量不一致。</ul><li><strong>Netty 如何解决？</strong><ul><li>Netty 不直接在 TCP 层解决，而是在<strong>应用层</strong>通过<strong>编解码器（Decoder）</strong>来解决。它提供了多种开箱即用的 <code>ChannelInboundHandler</code>（解码器），用于根据特定的应用层协议规则来解析字节流，将原始字节数据正确地分割成完整的、逻辑上的消息帧：<ul><li><strong><code>FixedLengthFrameDecoder</code>：</strong> 固定长度帧解码器，按照预设的固定长度切分消息。<li><strong><code>LineBasedFrameDecoder</code>：</strong> 行解码器，根据换行符（<code>\n</code> 或 <code>\r\n</code>）切分消息。<li><strong><code>DelimiterBasedFrameDecoder</code>：</strong> 分隔符解码器，根据用户指定的特殊分隔符切分消息。<li><strong><code>LengthFieldBasedFrameDecoder</code>：</strong> <strong>基于长度字段的帧解码器</strong>（最常用和推荐），在消息的头部包含一个表示消息体长度的字段。解码器会先读取这个长度字段，然后等待足够的数据到达，再截取对应长度的消息体。</ul></ul></ul><li><p><strong>编解码器 (Encoders/Decoders)</strong></p> <ul><li><strong>编解码器的作用？</strong> 为什么需要它们？<li><strong>与 <code>ChannelHandler</code> 的关系？</strong></ul><li><p><strong>Netty 的异步特性</strong></p> <ul><li><strong>I/O 操作都是异步的，如何获取结果？</strong> <code>ChannelFuture</code> 和 <code>ChannelFutureListener</code>。<li><strong><code>Promise</code> 和 <code>Future</code> 的区别？</strong></ul><li><p><strong>与 Java NIO 的关系和区别</strong></p> <ul><li><strong>Netty 是对 Java NIO 的封装和增强，解决了哪些 NIO 的痛点？</strong> (API 复杂、Selector Bug、缓冲区管理困难、多线程处理等)。</ul><li><p><strong>Netty 的连接管理和心跳机制</strong></p> <ul><li><strong>IdleStateHandler：</strong> 如何检测连接空闲？<li><strong>心跳消息：</strong> 如何实现客户端和服务端的心跳？</ul> <p><strong><code>IdleStateHandler</code></strong> 是 Netty 提供的一个 <code>ChannelHandler</code>，用于检测连接的空闲状态（即在指定时间内没有读或写操作发生）。</p> <ul><li><strong>原理：</strong> <code>IdleStateHandler</code> 会在 <code>ChannelPipeline</code> 中维护一个定时任务。当连接在指定的 <code>readerIdleTime</code>（读空闲时间）、<code>writerIdleTime</code>（写空闲时间）或 <code>allIdleTime</code>（总空闲时间）内没有相应的 I/O 操作时，它会触发一个 <strong><code>IdleStateEvent</code></strong> 事件，并将其传递到 <code>ChannelPipeline</code> 的下一个 <code>ChannelInboundHandler</code>。<li><strong>使用方式：</strong> 通常，你需要在 <code>IdleStateHandler</code> 之后再添加一个自定义的 <code>ChannelInboundHandler</code>（例如继承 <code>ChannelInboundHandlerAdapter</code>），并重写其 <code>userEventTriggered(ChannelHandlerContext ctx, Object evt)</code> 方法来捕获并处理 <code>IdleStateEvent</code>。</ul> <p>心跳消息是利用 <code>IdleStateHandler</code> 检测到的空闲状态，在客户端或服务端发送的周期性短消息，用于维持连接的活性、检测连接的可用性以及防止因长时间空闲而被防火墙或路由器关闭。</p> <p><strong>实现步骤：</strong></p> <ol><li><strong>添加 <code>IdleStateHandler</code>：</strong> 在客户端和服务器端的 <code>ChannelPipeline</code> 中都添加 <code>IdleStateHandler</code>，配置合适的读/写/总空闲时间。<li><strong>自定义 <code>HeartbeatHandler</code>：</strong> 在 <code>IdleStateHandler</code> 之后添加一个自定义的 <code>ChannelInboundHandler</code>。<li><strong>处理 <code>IdleStateEvent</code>：</strong><ul><li><strong>客户端：</strong> 当检测到<strong>写空闲（<code>IdleState.WRITER_IDLE</code>）</strong>时，客户端发送一个心跳请求消息给服务器。<li><strong>服务端：</strong> 当检测到<strong>读空闲（<code>IdleState.READER_IDLE</code>）</strong>时，表示客户端可能已经断开或处于异常状态。此时，服务器可以发送一个心跳响应消息，或直接关闭连接。如果服务器也发送了心跳请求，它会期望客户端在指定时间内返回响应。</ul><li><strong>心跳消息的响应：</strong><ul><li>服务端收到心跳请求后，应该立即回复一个心跳响应消息。<li>客户端收到心跳响应后，确认连接正常。</ul><li><strong>超时处理：</strong><ul><li>如果在发送心跳请求后，在规定时间内没有收到心跳响应，则认为连接已断开，可以主动关闭连接。这通常在 <code>HeartbeatHandler</code> 中通过计数器实现。</ul></ol></ol><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>MyServer</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> Exception </span>{</span><br><span class=line>        <span class=comment>//创建两个线程组 boosGroup、workerGroup</span></span><br><span class=line>        EventLoopGroup bossGroup = <span class=keyword>new</span> NioEventLoopGroup();</span><br><span class=line>        EventLoopGroup workerGroup = <span class=keyword>new</span> NioEventLoopGroup();</span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            <span class=comment>//创建服务端的启动对象，设置参数</span></span><br><span class=line>            ServerBootstrap bootstrap = <span class=keyword>new</span> ServerBootstrap();</span><br><span class=line>            <span class=comment>//设置两个线程组boosGroup和workerGroup</span></span><br><span class=line>            bootstrap.group(bossGroup, workerGroup)</span><br><span class=line>                <span class=comment>//设置服务端通道实现类型    </span></span><br><span class=line>                .channel(NioServerSocketChannel.class)</span><br><span class=line>                <span class=comment>//设置线程队列得到连接个数    </span></span><br><span class=line>                .option(ChannelOption.SO_BACKLOG, <span class=number>128</span>)</span><br><span class=line>                <span class=comment>//设置保持活动连接状态    </span></span><br><span class=line>                .childOption(ChannelOption.SO_KEEPALIVE, <span class=keyword>true</span>)</span><br><span class=line>                <span class=comment>//使用匿名内部类的形式初始化通道对象    </span></span><br><span class=line>                .childHandler(<span class=keyword>new</span> ChannelInitializer&LTSocketChannel>() {</span><br><span class=line>                        <span class=meta>@Override</span></span><br><span class=line>                        <span class=function><span class=keyword>protected</span> <span class=keyword>void</span> <span class=title>initChannel</span><span class=params>(SocketChannel socketChannel)</span> <span class=keyword>throws</span> Exception </span>{</span><br><span class=line>                            <span class=comment>//给pipeline管道设置处理器</span></span><br><span class=line>                            socketChannel.pipeline().addLast(<span class=keyword>new</span> MyServerHandler());</span><br><span class=line>                        }</span><br><span class=line>                    });<span class=comment>//给workerGroup的EventLoop对应的管道设置处理器</span></span><br><span class=line>            System.out.println(<span class=string>"java技术爱好者的服务端已经准备就绪..."</span>);</span><br><span class=line>            <span class=comment>//绑定端口号，启动服务端</span></span><br><span class=line>            ChannelFuture channelFuture = bootstrap.bind(<span class=number>6666</span>).sync();</span><br><span class=line>            <span class=comment>//对关闭通道进行监听</span></span><br><span class=line>            channelFuture.channel().closeFuture().sync();</span><br><span class=line>        } <span class=keyword>finally</span> {</span><br><span class=line>            bossGroup.shutdownGracefully();</span><br><span class=line>            workerGroup.shutdownGracefully();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h1 id=MongoDB><a class=headerlink href=#MongoDB title=MongoDB></a>MongoDB</h1><p>MongoDB 是一款流行的<strong>NoSQL 文档型数据库</strong>，以其<strong>灵活的数据模型、可伸缩性和高性能</strong>而闻名。它广泛应用于需要处理大量非结构化或半结构化数据、以及需要快速迭代的应用场景。在面试中，MongoDB 经常作为后端数据存储、大数据或微服务架构中的组件被提及。<h2 id=关键概念-1><a class=headerlink href=#关键概念-1 title=关键概念></a>关键概念</h2><p><strong>Document (文档)</strong><ul><li><strong>核心单位：</strong> 文档是 MongoDB 中数据的基本单位，类似于关系型数据库中的<strong>行 (row)</strong>。<li><strong>JSON-like 格式：</strong> 文档以类似 JSON 的 BSON (Binary JSON) 格式存储。BSON 支持更多的数据类型（如日期、二进制数据）并且是二进制编码，这使得存储和传输更高效。<li><strong>无模式 (Schemaless/Schema-less)：</strong> 这是 MongoDB 最重要的特性之一。同一个集合中的文档可以拥有不同的字段，字段的类型也可以不同。这提供了极大的灵活性，方便快速迭代和适应变化的需求。<li><strong>面试点：</strong> 理解文档是 MongoDB 的核心，其无模式特性提供了灵活性</ul><p><strong>Collection (集合)</strong><ul><li><strong>逻辑分组：</strong> 集合是文档的逻辑分组，类似于关系型数据库中的<strong>表 (table)</strong>。<li><strong>无固定结构：</strong> 集合不强制文档的结构，但通常同一集合中的文档会包含类似或相关的数据。<li><strong>面试点：</strong> 知道集合是文档的容器，其无模式特性与集合的关系。</ul><p><strong>Database (数据库)</strong><ul><li><strong>容器：</strong> 数据库是集合的物理容器，类似于关系型数据库中的<strong>数据库 (database)</strong>。<li><strong>多数据库：</strong> 一个 MongoDB 实例可以承载多个数据库。<li><strong>面试点：</strong> 数据库是组织集合的单元。</ul><p><strong>_id 字段</strong><ul><li><strong>主键：</strong> 每个文档在创建时都会自动生成一个唯一的 <code>_id</code> 字段作为其主键，除非你手动指定。<li><strong>ObjectID：</strong> 默认情况下，<code>_id</code> 的类型是 <code>ObjectID</code>，它是一个 12 字节的 BSON 类型，结合了时间戳、机器标识符、进程 ID 和计数器，以确保全局唯一性。<li><strong>面试点：</strong> 了解 <code>_id</code> 的作用和 <code>ObjectID</code> 的组成。</ul><p><strong>Index (索引)</strong><ul><li><strong>提高查询效率：</strong> 索引是 MongoDB 提高查询性能的关键。它允许数据库快速定位数据，而无需扫描整个集合。<li><strong>种类：</strong> 支持单字段索引、复合索引、多键索引（用于数组字段）、文本索引（用于全文搜索）、地理空间索引等。<li><strong>面试点：</strong> 索引的重要性，以及不同类型索引的适用场景。<strong>复合索引</strong>和<strong>多键索引</strong>是常考点。</ul><p><strong>Aggregation (聚合)</strong><ul><li><strong>数据处理：</strong> 聚合操作允许你对数据进行复杂的处理，如分组、筛选、转换、计算等，以生成汇总报告或分析结果。<li><strong>聚合管道 (Aggregation Pipeline)：</strong> 这是 MongoDB 最强大的聚合工具。它由一系列阶段 (stages) 组成，数据在这些阶段中依次处理，每个阶段的输出作为下一个阶段的输入。<li><strong>面试点：</strong> 理解聚合管道的工作原理，常用阶段（<code>$match</code>, <code>$group</code>, <code>$project</code>, <code>$sort</code>, <code>$limit</code>, <code>$unwind</code>）及其用途。</ul><p><strong>Replication (副本集)</strong><ul><li><strong>高可用性与数据冗余：</strong> 副本集是 MongoDB 提供<strong>高可用性</strong>和<strong>数据冗余</strong>的机制。它是一组维护相同数据集的 MongoDB 实例。<li><strong>Primary-Secondary 架构：</strong> 副本集中有一个主节点 (Primary)，负责处理所有写入操作和读操作。其他是从节点 (Secondary)，它们复制主节点的数据，并可以处理读操作（如果配置允许）。<li><strong>自动故障转移：</strong> 当主节点发生故障时，副本集会自动选举一个从节点成为新的主节点，从而保证服务持续可用。<li><strong>面试点：</strong> <strong>高频考点。</strong> 理解副本集的工作原理，主从节点的作用，以及自动故障转移过程。</ul><p><strong>Sharding (分片)</strong><ul><li><strong>水平扩展：</strong> 分片是 MongoDB 提供<strong>水平扩展</strong>的方式，用于处理大量数据和高吞吐量操作。它将数据分布在多个独立的服务器（称为分片或 Shard）上。<li><strong>组成：</strong><ul><li><strong>Shard (分片)：</strong> 存储部分数据的独立副本集。<li><strong>Config Server (配置服务器)：</strong> 存储集群的元数据（分片信息、数据分布规则）。<li><strong>Mongos (路由进程)：</strong> 负责处理客户端请求，将请求路由到正确的分片，并聚合结果。</ul><li><strong>面试点：</strong> <strong>高频考点。</strong> 理解分片解决的问题（海量数据存储和高并发），以及分片集群的各个组件及其职责。</ul><p><strong>CRUD 操作 (Create, Read, Update, Delete)</strong><ul><li>MongoDB 提供了丰富的操作来对文档进行增删改查。<li><strong><code>insertOne()</code>, <code>insertMany()</code></strong>: 插入文档。<li><strong><code>find()</code>, <code>findOne()</code></strong>: 查询文档（支持强大的查询语言，包括嵌套文档查询、数组查询、聚合查询等）。<li><strong><code>updateOne()</code>, <code>updateMany()</code>, <code>replaceOne()</code></strong>: 更新文档。<li><strong><code>deleteOne()</code>, <code>deleteMany()</code></strong>: 删除文档。<li><strong>面试点：</strong> 熟悉基本的 CRUD 操作语法和常用查询方法。</ul><h2 id=关键问题-1><a class=headerlink href=#关键问题-1 title=关键问题></a>关键问题</h2><h3 id=什么是-NoSQL-数据库？MongoDB-属于哪种-NoSQL-类型？><a title="什么是 NoSQL 数据库？MongoDB 属于哪种 NoSQL 类型？" class=headerlink href=#什么是-NoSQL-数据库？MongoDB-属于哪种-NoSQL-类型？></a>什么是 NoSQL 数据库？MongoDB 属于哪种 NoSQL 类型？</h3><ul><li><p><strong>NoSQL 定义：</strong> Not Only SQL。它是一类不使用传统关系型数据库的表格模型存储数据的数据存储系统。NoSQL 数据库通常为了特定的数据模型和访问模式而优化，牺牲了部分关系型数据库的特性（如强 ACID 事务和 JOIN 操作）来换取更高的可伸缩性、灵活性和性能。</p><li><p><strong>MongoDB 类型：</strong> <strong>文档型数据库</strong>。数据以类似 JSON 的 BSON（Binary JSON）格式的文档形式存储</p> <h3 id=MongoDB-的核心特点是什么？><a title="MongoDB 的核心特点是什么？" class=headerlink href=#MongoDB-的核心特点是什么？></a>MongoDB 的核心特点是什么？</h3><ul><li><strong>文档模型：</strong> 数据以 BSON 格式的文档存储，结构灵活，无模式 (Schema-less)，易于开发迭代。<li><strong>高可用性：</strong> 通过<strong>副本集（Replica Set）</strong>实现自动故障转移和数据冗余。<li><strong>水平扩展：</strong> 通过<strong>分片（Sharding）</strong>技术将数据分布到多个服务器，处理海量数据和高并发。<li><strong>高性能：</strong> 文档模型、索引、内存映射文件等优化手段提供了出色的读写性能。<li><strong>丰富的查询语言：</strong> 支持强大的查询语言，包括嵌套文档查询、聚合框架等。</ul></ul><h3 id=MongoDB-的-id-字段有什么特殊之处？><a title="MongoDB 的 _id 字段有什么特殊之处？" class=headerlink href=#MongoDB-的-id-字段有什么特殊之处？></a>MongoDB 的 <code>_id</code> 字段有什么特殊之处？</h3><ul><li><strong>主键：</strong> 每个 MongoDB 文档都必须包含一个 <code>_id</code> 字段，作为其在集合中的<strong>唯一主键</strong>。<li><strong>自动生成：</strong> 如果插入文档时未指定 <code>_id</code>，MongoDB 会自动生成一个 <code>ObjectID</code> 作为其值。<li><strong>ObjectID 组成：</strong> <code>ObjectID</code> 是一个 12 字节的 BSON 类型，它包含时间戳、机器标识符、进程 ID 和一个计数器，确保了全局唯一性。<li><strong>不可变性：</strong> <code>_id</code> 字段的值一旦创建就不可更改。</ul><h3 id=什么是副本集（Replica-Set）？它有什么作用？><a title="什么是副本集（Replica Set）？它有什么作用？" class=headerlink href=#什么是副本集（Replica-Set）？它有什么作用？></a>什么是副本集（Replica Set）？它有什么作用？</h3><ul><li><strong>定义：</strong> 副本集是一组维护相同数据集的 MongoDB 实例。它由一个<strong>主节点 (Primary)</strong> 和一个或多个<strong>从节点 (Secondary)</strong> 组成。<li><strong>作用：</strong><ul><li><strong>高可用性：</strong> 当主节点发生故障时，副本集会自动选举一个健康的从节点成为新的主节点，确保服务持续可用，避免单点故障。<li><strong>数据冗余：</strong> 从节点复制主节点的数据，提供数据的多份副本，防止数据丢失。<li><strong>读扩展：</strong> 可以配置从节点处理读请求（但要注意读的最终一致性），从而分散主节点的读负载。</ul><li><strong>工作原理简述：</strong> 所有写入操作都在主节点上进行，然后通过<strong>操作日志 (Oplog)</strong> 异步复制到所有从节点。</ul><h3 id=什么是分片（Sharding）？为什么要使用分片？><a class=headerlink href=#什么是分片（Sharding）？为什么要使用分片？ title=什么是分片（Sharding）？为什么要使用分片？></a>什么是分片（Sharding）？为什么要使用分片？</h3><ul><li><strong>定义：</strong> 分片是一种<strong>水平扩展（Horizontal Scaling）\</strong>的技术。它将大型数据集分布存储到多个独立的数据库实例（即*<em>分片/Shard*</em>）上。<li><strong>为什么要用：</strong><ul><li><strong>处理海量数据：</strong> 单个服务器的存储容量和内存有限，分片可以突破这些限制。<li><strong>高并发和吞吐量：</strong> 将查询和写入负载分散到多个分片上，提高系统的整体吞吐量。<li><strong>降低成本：</strong> 可以使用更多的廉价服务器替代少数昂贵的高配服务器。</ul><li><strong>分片集群的组成：</strong><ul><li><strong>Shards (分片)：</strong> 存储部分数据的独立副本集。<li><strong>Config Servers (配置服务器)：</strong> 存储集群的元数据（分片信息、数据分布规则）。<li><strong>Mongos (路由进程)：</strong> 处理客户端请求，将请求路由到正确的分片，并聚合结果。</ul></ul><h3 id=解释-MongoDB-的数据模型设计：嵌入式文档（Embedded-Documents）与引用（References）的区别和选择。><a title="解释 MongoDB 的数据模型设计：嵌入式文档（Embedded Documents）与引用（References）的区别和选择。" class=headerlink href=#解释-MongoDB-的数据模型设计：嵌入式文档（Embedded-Documents）与引用（References）的区别和选择。></a>解释 MongoDB 的数据模型设计：嵌入式文档（Embedded Documents）与引用（References）的区别和选择。</h3><ul><li><strong>嵌入式文档：</strong> 将相关数据直接嵌套存储在同一个文档中。<ul><li><strong>优点：</strong> 单次查询即可获取所有数据，读性能好；原子性操作（对单个文档的更新）。<li><strong>缺点：</strong> 单文档大小限制（16MB）；数据冗余（如果子文档被多处引用）；更新复杂性（大文档更新或增长）。<li><strong>适用场景：</strong> 一对一、一对多关系（子文档数量有限且不常变），数据紧密耦合且经常一起查询。</ul><li><strong>引用：</strong> 通过存储另一个文档的 <code>_id</code> 来建立文档间的关联，类似关系型数据库的外键。需要使用 <code>$lookup</code> 或在应用层进行多次查询来获取关联数据。<ul><li><strong>优点：</strong> 减少数据冗余；突破文档大小限制；灵活处理多对多关系。<li><strong>缺点：</strong> 需要多次查询或使用 <code>$lookup</code>，性能可能不如嵌入式文档；查询逻辑可能更复杂。<li><strong>适用场景：</strong> 多对多关系；一对多关系（子文档数量多且动态增长）；数据独立性强，不总是与父文档一起查询。</ul><li><strong>选择策略：</strong> 核心原则是<strong>“应用程序如何使用数据”</strong>。优先考虑将那些原子性高、总是被一起查询的数据<strong>嵌入</strong>到文档中。对于那些独立存在、会被大量引用或可能变得很大的数据，使用<strong>引用</strong>。</ul><h3 id=什么是-MongoDB-的索引？有哪些常用的索引类型？><a title="什么是 MongoDB 的索引？有哪些常用的索引类型？" class=headerlink href=#什么是-MongoDB-的索引？有哪些常用的索引类型？></a>什么是 MongoDB 的索引？有哪些常用的索引类型？</h3><ul><li><strong>作用：</strong> 索引是提高查询性能的关键。它允许数据库快速定位到匹配查询条件的文档，而无需扫描整个集合。<li><strong>常用类型：</strong><ul><li><strong>单字段索引：</strong> 在单个字段上创建。<li><strong>复合索引 (Compound Index)：</strong> 在多个字段上创建，字段顺序很重要（最左前缀原则），支持多字段查询和排序。<li><strong>多键索引 (Multikey Index)：</strong> 自动为包含<strong>数组</strong>的字段创建，为数组中每个元素创建索引条目，支持对数组内容的查询。<li><strong>文本索引 (Text Index)：</strong> 支持对字符串内容进行全文搜索。<li><strong>地理空间索引 (Geospatial Index)：</strong> 支持地理位置数据（如点、线、多边形）的查询。<li><strong>TTL 索引 (Time-to-Live Index)：</strong> 自动删除特定时间后过期的文档。</ul></ul><h3 id=什么是聚合框架（Aggregation-Framework）？常用的聚合阶段有哪些？><a title="什么是聚合框架（Aggregation Framework）？常用的聚合阶段有哪些？" class=headerlink href=#什么是聚合框架（Aggregation-Framework）？常用的聚合阶段有哪些？></a>什么是聚合框架（Aggregation Framework）？常用的聚合阶段有哪些？</h3><ul><li><strong>定义：</strong> 聚合框架是 MongoDB 中进行数据处理和分析的强大工具。它允许你通过一系列的<strong>管道阶段 (Pipeline Stages)</strong> 来转换和组合文档，生成聚合结果。<li><strong>常用阶段：</strong><ul><li><strong><code>$match</code>：</strong> 过滤文档，只将符合条件的文档传递到下一个阶段。<li><strong><code>$group</code>：</strong> 按指定字段对文档进行分组，并对每个组执行聚合操作（如 <code>$sum</code>, <code>$avg</code>, <code>$count</code>）。<li><strong><code>$project</code>：</strong> 重构文档的形状，可以选择、排除或添加新字段。<li><strong><code>$sort</code>：</strong> 对文档进行排序。<li><strong><code>$limit</code>：</strong> 限制通过管道的文档数量。<li><strong><code>$skip</code>：</strong> 跳过指定数量的文档。<li><strong><code>$unwind</code>：</strong> 将文档中的数组字段“解构”，为数组中的每个元素生成一个单独的文档。<li><strong><code>$lookup</code>：</strong> 执行左外连接，从另一个集合中获取关联文档。</ul></ul><h3 id=MongoDB-如何保证数据一致性（特别是事务）？><a title="MongoDB 如何保证数据一致性（特别是事务）？" class=headerlink href=#MongoDB-如何保证数据一致性（特别是事务）？></a>MongoDB 如何保证数据一致性（特别是事务）？</h3><ul><li><strong>原子性：</strong> MongoDB 的写入操作（如 <code>insertOne()</code>, <code>updateOne()</code>）在<strong>单个文档级别</strong>是原子性的。<li><strong>事务（MongoDB 4.0+）：</strong> 从 MongoDB 4.0 开始，引入了<strong>多文档事务（Multi-Document Transactions）</strong>。这意味着你可以在多个文档、多个集合乃至多个分片上执行符合 ACID 的事务。<ul><li><strong>隔离级别：</strong> 通常提供快照隔离，确保事务期间的数据一致性。<li><strong>限制：</strong> 相较于关系型数据库的事务，仍有一些限制（如性能开销、超时）。</ul><li><strong>副本集的一致性：</strong> 副本集通过 Oplog 复制实现最终一致性。你可以通过<strong>读偏好（Read Preference）</strong>和<strong>写关注（Write Concern）</strong>来调整一致性级别。<ul><li><strong>读偏好：</strong> 决定从主节点还是从节点读取数据（如 <code>primary</code>, <code>primaryPreferred</code>, <code>secondary</code>, <code>secondaryPreferred</code>, <code>nearest</code>）。<li><strong>写关注：</strong> 决定写入操作成功需要多少个节点的确认（如 <code>w:1</code> 写入主节点，<code>w:majority</code> 写入多数节点）。</ul></ul><h3 id=MongoDB-的缺点或局限性是什么？><a title="MongoDB 的缺点或局限性是什么？" class=headerlink href=#MongoDB-的缺点或局限性是什么？></a>MongoDB 的缺点或局限性是什么？</h3><ul><li><strong>Join 操作：</strong> 虽然有 <code>$lookup</code>，但其功能和性能不如关系型数据库的 JOIN 强大和灵活。复杂的跨集合查询可能需要多次 <code>$lookup</code> 或在应用层处理。<li><strong>事务复杂性：</strong> 4.0+ 虽引入了多文档事务，但相较于关系型数据库，仍有学习成本和性能考量。<li><strong>模式缺失：</strong> 虽然是优势，但有时也可能导致数据混乱，需要应用层严格管理数据结构。<li><strong>数据冗余：</strong> 为了查询性能，可能需要牺牲范式化，导致数据冗余。<li><strong>内存使用：</strong> 有些操作（如排序、聚合）可能需要大量内存。</ul><h3 id=什么时候会选择-MongoDB-而不是关系型数据库？什么时候不选择？><a title="什么时候会选择 MongoDB 而不是关系型数据库？什么时候不选择？" class=headerlink href=#什么时候会选择-MongoDB-而不是关系型数据库？什么时候不选择？></a>什么时候会选择 MongoDB 而不是关系型数据库？什么时候不选择？</h3><ul><li><strong>选择 MongoDB 的场景：</strong><ul><li>数据结构不固定，需要灵活的模式（Schema-less）。<li>高并发写入和大数据量存储。<li>需要水平扩展来应对业务增长。<li>对读性能要求高，且数据关联性不复杂。<li>需要存储非结构化或半结构化数据（如日志、用户画像、IoT 数据）。</ul><li><strong>不选择 MongoDB 的场景：</strong><ul><li>需要复杂的、跨多表的 JOIN 查询。<li>需要强事务一致性，尤其是有复杂的、跨多文档的 ACID 事务。<li>严格的范式化数据结构。<li>传统的 OLTP 业务，数据模型稳定且关联复杂。</ul></ul><h3 id=如何进行-MongoDB-的性能优化？><a title="如何进行 MongoDB 的性能优化？" class=headerlink href=#如何进行-MongoDB-的性能优化？></a>如何进行 MongoDB 的性能优化？</h3><ul><li><strong>创建合适的索引：</strong> 根据查询模式创建单字段、复合、多键、文本等索引。<li><strong>优化查询：</strong> 避免全表扫描，使用 <code>$explain</code> 分析查询性能。<li><strong>数据模型设计：</strong> 合理选择嵌入式文档或引用，避免深层嵌套。<li><strong>读写分离：</strong> 利用副本集实现读写分离。<li><strong>分片：</strong> 针对大规模数据和高并发场景。<li><strong>硬件优化：</strong> 足够的内存（MongoDB 尽可能将数据放在内存中）、SSD 硬盘。<li><strong>聚合管道优化：</strong> 将 <code>$match</code> 放在管道前面尽可能过滤数据。</ul><h3 id=嵌入式文档与lookup操作><a class=headerlink href=#嵌入式文档与lookup操作 title=嵌入式文档与lookup操作></a>嵌入式文档与lookup操作</h3><p>嵌入式文档是指一个文档内部包含另一个文档（或多个文档）。这意味着相关的子数据直接存储在父文档中，而不是作为单独的文档存储在另一个集合中并通过引用关联。<p><code>$lookup</code> 是 MongoDB 聚合管道（Aggregation Pipeline）中的一个阶段，它允许你执行<strong>左外连接（Left Outer Join）</strong>，从一个集合中的文档获取相关数据，并将其合并到另一个集合的文档中。<p>面试时，面试官通常会考察你如何根据业务场景和数据访问模式来选择嵌入式文档或引用加 <code>$lookup</code>。<ol><li><strong>数据的关联性/紧密性：</strong><ul><li>如果数据是<strong>强关联且总是被一起访问</strong>（例如，用户的地址和用户一起读取），优先考虑<strong>嵌入式文档</strong>。<li>如果数据是<strong>弱关联，或者不总是被一起访问</strong>（例如，订单中的商品详情，用户可能只看订单列表不看详情），考虑<strong>引用 + <code>$lookup</code></strong>。</ul><li><strong>读写模式：</strong><ul><li><strong>读多写少，且一起读：</strong> <strong>嵌入式文档</strong>通常性能更优。<li><strong>写入频繁，且子文档会被重复引用：</strong> <strong>引用 + <code>$lookup</code></strong> 可以减少数据冗余和更新复杂性。</ul><li><strong>数据大小和增长：</strong><ul><li>如果嵌入的子文档会<strong>变得非常大</strong>或者<strong>数量无限增长</strong>（接近 16MB 限制），使用<strong>引用 + <code>$lookup</code></strong>。<li>如果子文档<strong>相对较小且数量有限</strong>，可以考虑<strong>嵌入式文档</strong>。</ul><li><strong>一致性和原子性要求：</strong><ul><li>对<strong>强一致性要求高且需要原子操作</strong>的内部数据，<strong>嵌入式文档</strong>更安全。<li>涉及到<strong>多个集合的关联数据</strong>，通常需要应用层或 MongoDB 4.0+ 的多文档事务来保证一致性（如果使用引用）。</ul><li><strong>业务逻辑复杂性：</strong><ul><li>简单的聚合或联接，<code>$lookup</code> 也可以接受。<li>非常复杂的联接或需要跨集合的多次查询，可能需要重新评估数据模型或考虑将部分处理逻辑放到应用层。</ul></ol><h1 id=Elastic-Search><a title="Elastic Search" class=headerlink href=#Elastic-Search></a>Elastic Search</h1><p>Elasticsearch 是一个基于 Apache Lucene 的分布式、RESTful 风格的搜索和分析引擎。它以其<strong>速度快、可伸缩性强</strong>以及能够处理<strong>海量数据</strong>而闻名。在面试中，Elasticsearch 经常作为大数据、搜索或微服务架构中的关键组件被问到。<p>ELK Stack (Elasticsearch, Logstash, Kibana) 技术栈核心<h2 id=关键概念-2><a class=headerlink href=#关键概念-2 title=关键概念></a>关键概念</h2><p><img alt=img data-src=https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/elasticsearch/rumen-ad2b2f8c-5a19-4c5e-9bc7-cf7ba17830bf.jpg><p><strong>节点</strong><p>一个 Elasticsearch 实例就是一个节点。每个节点都有一个名称。<p>主要节点类型：<ul><li><strong>Master Node (主节点)</strong>：负责集群的管理任务，如创建/删除索引、跟踪节点状态、分片分配等。一个集群中只能有一个主节点，但可以有多个符合主节点条件的节点（master-eligible node）。<li><strong>Data Node (数据节点)</strong>：存储数据（分片）并执行数据相关操作（CRUD、搜索、聚合）。<li><strong>Ingest Node (摄入节点)</strong>：执行预处理管道，转换文档。<li><strong>Coordinating Node (协调节点)</strong>：默认所有节点都是协调节点，负责接收客户端请求，将请求路由到正确的数据节点，并汇集各数据节点的结果返回给客户端。</ul><p><strong>Cluster (集群)</strong><ul><li>一个集群由一个或多个<strong>节点 (Node)</strong> 组成，它们共同存储数据并提供索引和搜索能力。<li><strong>目的：</strong> 提供高可用性、可伸缩性和容错性。<li><strong>面试点：</strong> 知道集群如何协同工作，以及其分布式特性。</ul><p><strong>Document (文档)</strong><ul><li>类似关系数据库中的<strong>行 (row)</strong>。它是可被索引的最小单位。<li><strong>JSON 格式：</strong> 文档以 JSON (JavaScript Object Notation) 格式表示。<li><strong>唯一 ID：</strong> 每个文档在它所属的索引中都有一个唯一的 ID。<li><strong>面试点：</strong> 理解文档是 Elasticsearch 存储和搜索的原子单元。</ul><p><strong>Index (索引)</strong><ul><li>类似关系数据库中的<strong>数据库 (database)</strong>。它是拥有相似特性的文档的集合。<li><strong>逻辑概念：</strong> 一个索引实际上在物理上分布在多个<strong>分片 (Shard)</strong> 上。<li><strong>面试点：</strong> 理解索引是逻辑上的分组，是可搜索的最高层级。</ul><p><strong>Type (类型)</strong> - <strong>在 Elasticsearch 7.x 及更高版本中已废弃！</strong><ul><li>在 6.x 及以前版本中，一个索引可以包含多个类型，类似关系数据库中的<strong>表 (table)</strong>。<li><strong>面试点：</strong> <strong>强调它已被废弃，并解释原因</strong>（Mapping 冲突、性能问题）。对于 7.x+ 版本，一个索引通常只对应一个类型或根本没有显式类型。</ul><p><strong>Field (字段)</strong><ul><li>类似关系数据库中的<strong>列 (column)</strong>。文档由多个字段组成。<li><strong>面试点：</strong> 字段是文档中的基本数据单元</ul><p><strong>Mapping (映射)</strong><ul><li>类似关系数据库中的<strong>表结构 (schema)</strong>。它定义了文档及其字段的类型、如何存储以及如何被索引。<li><strong>动态映射：</strong> Elasticsearch 默认支持动态映射，即当你索引一个新文档时，如果其中包含新的字段，Elasticsearch 会尝试猜测其数据类型并自动创建映射。<li><strong>显式映射：</strong> 最佳实践是显式定义映射，特别是对于文本字段，以控制它们的分析方式。<li><strong>面试点：</strong> 理解 Mapping 的作用，以及动态映射和显式映射的区别。<code>keyword</code> 和 <code>text</code> 类型字段的区别是高频考点。<ul><li><strong><code>text</code> 类型：</strong> 用于全文本字段，会被分词器处理（例如，”Hello World” 可能被分成 “hello” 和 “world”）。可用于全文搜索。<li><strong><code>keyword</code> 类型：</strong> 用于结构化数据（如 ID、标签、国家代码），不会被分词。适用于过滤、聚合、排序。</ul></ul><p><strong>Shard (分片)</strong><ul><li><strong>物理存储单元：</strong> 一个索引的数据被分成多个分片。每个分片都是一个独立的 Lucene 索引。<li><strong>目的：</strong><ul><li><strong>横向扩展：</strong> 允许你水平扩展存储容量和吞吐量。<li><strong>并行处理：</strong> 允许在多个节点上并行执行搜索和聚合操作，提高性能。</ul><li><strong>主分片 (Primary Shard)：</strong> 存储原始数据。<li><strong>副本分片 (Replica Shard)：</strong> 主分片的副本，用于提供高可用性（当主分片失效时可以提升为新主分片）和提升搜索吞吐量。<li><strong>面试点：</strong> <strong>高频考点</strong>。理解分片是 Elasticsearch 可伸缩和高可用的基石。区分主分片和副本分片的作用，以及它们如何分布在集群中</ul><p><strong>Replicas (副本)</strong><ul><li><strong>作用：</strong> 副本分片是主分片的精确拷贝。<li><strong>目的：</strong><ul><li><strong>高可用性：</strong> 当某个节点上的主分片失败时，副本可以立即提升为新的主分片，确保数据不丢失和服务的连续性。<li><strong>提高查询性能：</strong> 搜索请求可以同时在主分片和其副本分片上执行，分散负载，提高吞吐量。</ul><li><strong>面试点：</strong> 理解副本如何保障高可用和提升查询性能，以及副本数量的设置对存储和查询性能的影响。</ul><p><strong>Analysers (分析器)</strong><ul><li><strong>作用：</strong> 在索引文本数据时，将原始文本转换为可搜索的<strong>词项 (terms)</strong> 的过程。<li><strong>组成：</strong> 由一个<strong>字符过滤器 (character filters)</strong>、一个<strong>分词器 (tokenizer)</strong> 和零个或多个<strong>词项过滤器 (token filters)</strong> 组成。<li><strong>面试点：</strong> 理解分析器在全文搜索中的重要性。常见的分析器如 <code>standard</code> 分析器。能解释分词（tokenization）和词项过滤（如小写转换、停用词移除、同义词处理）的概念。</ul><p><strong>Query DSL (查询领域特定语言)</strong><ul><li>Elasticsearch 强大的查询语言，基于 JSON。<li><strong>面试点：</strong> 知道如何使用 Query DSL 进行各种复杂的搜索，如全文搜索、词语匹配、范围查询、布尔组合查询等。</ul><p><strong>Aggregations (聚合)</strong><ul><li>Elasticsearch 强大的统计分析功能。允许你从数据中提取和计算出复杂的统计信息，例如分组、求和、平均值、最大/最小值等。<li><strong>面试点：</strong> 了解聚合的用途，例如用于仪表盘、统计报表等。</ul><h2 id=关键问题-2><a class=headerlink href=#关键问题-2 title=关键问题></a>关键问题</h2><h3 id=什么是-Elasticsearch？它的核心特点是什么？><a title="什么是 Elasticsearch？它的核心特点是什么？" class=headerlink href=#什么是-Elasticsearch？它的核心特点是什么？></a>什么是 Elasticsearch？它的核心特点是什么？</h3><ul><li><strong>定义：</strong> Elasticsearch 是一个基于 Apache Lucene 的<strong>分布式、RESTful 风格的搜索和分析引擎</strong>。<li><strong>核心特点：</strong><ul><li><strong>分布式：</strong> 能够横向扩展，处理海量数据。<li><strong>近实时（Near Real-time）：</strong> 数据从索引到可搜索只有毫秒级的延迟。<li><strong>高可用和可伸缩：</strong> 通过集群、分片和副本机制提供。<li><strong>RESTful API：</strong> 通过 HTTP 和 JSON 进行交互，易于使用。<li><strong>全文搜索：</strong> 强大的全文搜索能力，支持复杂查询。<li><strong>聚合分析：</strong> 强大的聚合功能，用于数据分析和报表。</ul></ul><h3 id=请解释-Elasticsearch-中的集群（Cluster）、节点（Node）、索引（Index）、类型（Type-已废弃）、文档（Document）和字段（Field）之间的关系和作用。><a title="请解释 Elasticsearch 中的集群（Cluster）、节点（Node）、索引（Index）、类型（Type - 已废弃）、文档（Document）和字段（Field）之间的关系和作用。" class=headerlink href=#请解释-Elasticsearch-中的集群（Cluster）、节点（Node）、索引（Index）、类型（Type-已废弃）、文档（Document）和字段（Field）之间的关系和作用。></a>请解释 Elasticsearch 中的集群（Cluster）、节点（Node）、索引（Index）、类型（Type - 已废弃）、文档（Document）和字段（Field）之间的关系和作用。</h3><ul><li><strong>集群 (Cluster)：</strong> 一个或多个节点的集合，共同存储数据并提供搜索和分析功能。是 Elasticsearch 的最高逻辑单位。<li><strong>节点 (Node)：</strong> 一个 Elasticsearch 实例。每个节点在集群中扮演不同角色（如 Master 节点、Data 节点、Ingest 节点、Coordinating 节点）。<li><strong>索引 (Index)：</strong> 逻辑上相关文档的集合，类似关系型数据库的<strong>数据库</strong>。物理上，一个索引由一个或多个<strong>分片 (Shard)</strong> 组成。<li><strong>类型 (Type)：</strong> <strong>在 Elasticsearch 7.x 及更高版本中已废弃！</strong> 在 6.x 及以前版本中，类型是索引下的逻辑分组，类似关系型数据库的<strong>表</strong>。面试时务必强调其已废弃。<li><strong>文档 (Document)：</strong> 可被索引的最小数据单元，以 JSON 格式表示，类似关系型数据库的<strong>行</strong>。每个文档都有一个唯一的 ID。<li><strong>字段 (Field)：</strong> 文档中的数据单元，类似关系型数据库的<strong>列</strong>。</ul><h3 id=Elasticsearch-中的分片（Shard）和副本（Replica）有什么作用？它们如何实现高可用和可伸缩？><a title="Elasticsearch 中的分片（Shard）和副本（Replica）有什么作用？它们如何实现高可用和可伸缩？" class=headerlink href=#Elasticsearch-中的分片（Shard）和副本（Replica）有什么作用？它们如何实现高可用和可伸缩？></a>Elasticsearch 中的<strong>分片（Shard）</strong>和<strong>副本（Replica）</strong>有什么作用？它们如何实现高可用和可伸缩？</h3><ul><li><strong>分片 (Shard)：</strong><ul><li><strong>作用：</strong> 是一个索引的<strong>物理存储单元</strong>，一个 Lucene 索引。一个索引被分成多个分片，这些分片可以分布在集群的不同节点上。<li><strong>目的：</strong> 实现<strong>横向扩展</strong>（存储容量和吞吐量），并支持<strong>并行处理</strong>查询。</ul><li><strong>副本 (Replica)：</strong><ul><li><strong>作用：</strong> 是主分片的一个<strong>完整副本</strong>。<li><strong>目的：</strong> 实现<strong>高可用性</strong>（当主分片所在的节点故障时，副本可以提升为新的主分片，防止数据丢失和中断服务）和<strong>提高查询吞吐量</strong>（搜索请求可以在主分片和副本上并行执行，分摊负载）。</ul><li><strong>高可用和可伸缩：</strong><ul><li><strong>高可用：</strong> 通过副本机制，即使部分节点或分片失效，数据仍然可用，服务不会中断。<li><strong>可伸缩性：</strong> 通过增加分片数量和节点数量，可以将数据和查询负载分布到更多机器上，实现线性扩展。</ul></ul><h3 id=什么是倒排索引（Inverted-Index）？Elasticsearch-为什么用它？><a title="什么是倒排索引（Inverted Index）？Elasticsearch 为什么用它？" class=headerlink href=#什么是倒排索引（Inverted-Index）？Elasticsearch-为什么用它？></a>什么是<strong>倒排索引（Inverted Index）</strong>？Elasticsearch 为什么用它？</h3><ul><li><strong>定义：</strong> 倒排索引是 Elasticsearch 实现<strong>快速全文搜索</strong>的核心数据结构。<ul><li>传统数据库的“正向索引”是从文档（行）到关键词（列）。<li>倒排索引则是从<strong>关键词 (Term)</strong> 到包含该关键词的<strong>文档 ID 列表</strong>。</ul><li><strong>示例：</strong><ul><li>文档1: “The quick brown fox”<li>文档2: “Quick foxes are quick”<li><strong>倒排索引：</strong><ul><li><code>the</code>: [文档1]<li><code>quick</code>: [文档1, 文档2]<li><code>brown</code>: [文档1]<li><code>fox</code>: [文档1]<li><code>foxes</code>: [文档2]<li><code>are</code>: [文档2]</ul></ul><li><strong>为什么用它：</strong><ul><li><strong>极快的全文搜索：</strong> 当你搜索一个或多个关键词时，可以直接在倒排索引中找到包含这些关键词的所有文档 ID，而无需扫描所有文档。<li><strong>高效过滤和聚合：</strong> 也是实现高效过滤和聚合的基础。</ul></ul><h3 id=Elasticsearch-中的-Mapping（映射）是什么？text-类型和-keyword-类型有什么区别？><a title="Elasticsearch 中的 Mapping（映射）是什么？text 类型和 keyword 类型有什么区别？" class=headerlink href=#Elasticsearch-中的-Mapping（映射）是什么？text-类型和-keyword-类型有什么区别？></a>Elasticsearch 中的 <strong>Mapping（映射）</strong>是什么？<code>text</code> 类型和 <code>keyword</code> 类型有什么区别？</h3><ul><li><strong>Mapping 定义：</strong> Mapping 类似于关系型数据库中的<strong>表结构（Schema）</strong>。它定义了文档及其字段的数据类型、如何存储以及如何被索引和查询。<li><strong>作用：</strong> 控制字段如何被分析（分词）、如何被索引以及是否可以被搜索、聚合和排序。<li><strong><code>text</code> 类型 vs <code>keyword</code> 类型：</strong> 这是最常考的区别！<ul><li><strong><code>text</code> 类型：</strong><ul><li>用于<strong>全文文本</strong>字段，例如文章内容、产品描述。<li>在索引时会被<strong>分词器 (Analyzer)</strong> 处理，将文本分解为独立的<strong>词项 (Terms)</strong>。<li>适用于<strong>全文搜索</strong>（例如，搜索 “quick brown fox”，即使只搜 “quick” 也能找到）。<li><strong>不适用于精确匹配、排序或聚合</strong>（因为已经被分词）。</ul><li><strong><code>keyword</code> 类型：</strong><ul><li>用于<strong>精确值</strong>的字段，例如 ID、邮箱地址、标签、国家代码。<li><strong>不会被分词器处理</strong>，整个值被视为一个单一的词项。<li>适用于<strong>精确匹配、过滤、排序和聚合</strong>。<li><strong>不适用于全文搜索</strong>。</ul></ul><li><strong>面试重点：</strong> 能够清晰解释这两种类型的区别和适用场景。例如，一个商品标题字段，可能同时需要 <code>text</code> 类型用于搜索，<code>keyword</code> 类型用于精确过滤或聚合。</ul><h3 id=什么是分析器（Analyzer）？它由哪些部分组成？><a class=headerlink href=#什么是分析器（Analyzer）？它由哪些部分组成？ title=什么是分析器（Analyzer）？它由哪些部分组成？></a>什么是<strong>分析器（Analyzer）</strong>？它由哪些部分组成？</h3><ul><li><strong>定义：</strong> 分析器是 Elasticsearch 在索引和搜索<strong>文本数据</strong>时，将原始文本转换为可搜索的<strong>词项 (Terms)</strong> 的过程。<li><strong>组成：</strong> 一个分析器由以下三部分组成：<ol><li><strong>字符过滤器 (Character Filters)：</strong> 在文本被分词前，进行预处理，例如移除 HTML 标签、替换特殊字符。<li><strong>分词器 (Tokenizer)：</strong> 将文本分解为独立的词项（tokens）。例如，<code>standard</code> 分词器按空格和标点符号分词。<li><strong>词项过滤器 (Token Filters)：</strong> 对分词器生成的词项进行进一步处理，例如转换为小写、移除停用词 (stop words)、添加同义词、词干提取等。</ol><li><strong>面试重点：</strong> 理解分析器在全文搜索中的核心作用，以及其三部分的职能。例如，搜索“Running Shoes”，分析器可能将其处理成“run”、“shoe”，这样搜索“run”也能找到。</ul><h3 id=Elasticsearch-的写入（索引）流程是怎样的？><a title="Elasticsearch 的写入（索引）流程是怎样的？" class=headerlink href=#Elasticsearch-的写入（索引）流程是怎样的？></a>Elasticsearch 的写入（索引）流程是怎样的？</h3><ol><li>客户端发送写入请求（<code>PUT</code> 或 <code>POST</code> 文档）到集群中的<strong>任一节点</strong>（通常是协调节点）。<li>协调节点根据文档的 ID 和索引的路由规则计算出该文档应属于的<strong>主分片</strong>。<li>协调节点将请求转发到<strong>主分片所在的 Data 节点</strong>。<li>主分片所在节点将文档写入主分片，并将其写入<strong>事务日志 (Translog)</strong>。<li>主分片将请求并行转发到所有<strong>副本分片所在的 Data 节点</strong>。<li>副本分片所在节点将文档写入副本分片，并写入其自己的 Translog。<li>所有副本分片成功写入后，向主分片返回确认。<li>主分片收到所有副本确认后，向协调节点返回确认。<li>协调节点向客户端返回成功响应。</ol><p><strong>面试重点：</strong> 强调写入操作首先在主分片上进行，然后同步到副本分片，并涉及 Translog 的持久化来保证数据安全性。<h3 id=Elasticsearch-的查询（搜索）流程是怎样的？><a title="Elasticsearch 的查询（搜索）流程是怎样的？" class=headerlink href=#Elasticsearch-的查询（搜索）流程是怎样的？></a>Elasticsearch 的查询（搜索）流程是怎样的？</h3><ol><li>客户端发送搜索请求到集群中的<strong>任一节点</strong>（协调节点）。<li>协调节点将请求广播到<strong>索引的所有主分片和副本分片</strong>（协调节点会随机选择一个分片来处理请求，通常是主分片或其一个副本）。<li>每个分片执行搜索请求的两个阶段：<ul><li><strong>Query Phase (查询阶段 / Scatter)：</strong> 每个分片执行查询，找到匹配的文档，并返回文档 ID 和得分（Score）到协调节点。<li><strong>Fetch Phase (取回阶段 / Gather)：</strong> 协调节点将所有分片返回的文档 ID 和得分进行合并、排序，选出最终需要的文档 ID。然后，协调节点再次向相应分片请求这些完整文档的内容。</ul><li>协调节点收集所有完整文档，并根据排序要求返回给客户端。</ol><p><strong>面试重点：</strong> 强调查询是“分而治之”的思想，分为查询和取回两个阶段，涉及协调节点的分发和结果聚合。<h3 id=如何保证-Elasticsearch-的数据一致性？><a title="如何保证 Elasticsearch 的数据一致性？" class=headerlink href=#如何保证-Elasticsearch-的数据一致性？></a>如何保证 Elasticsearch 的数据一致性？</h3><ul><li><strong>写关注 (Write Consistency)：</strong> 在写入操作时，可以通过 <code>replication</code> 参数设置写关注：<ul><li><code>quorum</code> (默认)：需要主分片和大多数副本分片写入成功才返回。<li><code>one</code>：只需主分片写入成功。<li><code>all</code>：所有分片（主分片和所有副本分片）写入成功。<li><strong>面试重点：</strong> 了解不同的写关注级别对写入性能和数据安全性的影响。</ul><li><strong>Translog (事务日志)：</strong> 每个分片都有一个 Translog，所有操作在被 Lucene 写入磁盘前都会先写入 Translog，确保即使发生宕机，也能从 Translog 恢复未持久化的操作。<li><strong>刷新 (Refresh) 和提交 (Commit)：</strong><ul><li><strong>Refresh (刷新)：</strong> Translog 中的数据会定期刷新到 Lucene 的文件系统缓存中，此时数据变得<strong>可搜索</strong>（默认 1 秒刷新一次）。<li><strong>Commit (提交)：</strong> Lucene 会定期进行 fsync 操作，将数据<strong>持久化</strong>到磁盘。</ul><li><strong>最终一致性：</strong> Elasticsearch 追求的是<strong>最终一致性</strong>。这意味着写入数据后，可能在极短的时间内（通常是 Refresh 间隔）无法立即被搜索到，但最终会达到一致状态。</ul><h3 id=常见的-Elasticsearch-性能优化策略有哪些？><a title="常见的 Elasticsearch 性能优化策略有哪些？" class=headerlink href=#常见的-Elasticsearch-性能优化策略有哪些？></a>常见的 Elasticsearch 性能优化策略有哪些？</h3><ul><li><strong>索引优化：</strong><ul><li><strong>合理设计 Mapping：</strong> 选择正确的数据类型（尤其是 <code>text</code> vs <code>keyword</code>），避免不必要的字段索引（<code>"index": false</code>）。<li><strong>分片数量：</strong> 合理设置主分片数量，通常建议一个分片大小在 20GB-50GB 左右。过多的分片会增加管理开销，过少则限制扩展性。<li><strong>副本数量：</strong> 增加副本可以提高读吞吐量和高可用性，但会增加写入开销和存储成本。</ul><li><strong>查询优化：</strong><ul><li><strong>使用合适的查询类型：</strong> 优先使用 <code>term</code>、<code>match</code> 等简单查询，避免复杂的正则或通配符查询。<li><strong>避免深分页：</strong> 使用 <code>search_after</code> 或 <code>scroll</code> API 代替 <code>from</code>/<code>size</code> 进行深分页。<li><strong>缓存：</strong> 利用 Elasticsearch 的查询缓存和字段数据缓存。<li><strong>聚合优化：</strong> 将 <code>_source</code> 字段设置为 <code>false</code>（如果不需要返回原始文档），只返回聚合结果。</ul><li><strong>硬件优化：</strong><ul><li><strong>内存：</strong> 分配足够的 JVM 堆内存（通常是物理内存的一半，不超过 32GB）。<li><strong>SSD 硬盘：</strong> 对于 I/O 密集型操作至关重要。<li><strong>CPU：</strong> 足够的核数来处理查询和索引操作。</ul><li><strong>JVM 优化：</strong> 合理配置 JVM 堆内存大小和垃圾回收器。<li><strong>慢查询日志：</strong> 开启并分析慢查询日志，找出性能瓶颈。</ul><h3 id=Elasticsearch-集群可能遇到哪些问题？如何解决？><a title="Elasticsearch 集群可能遇到哪些问题？如何解决？" class=headerlink href=#Elasticsearch-集群可能遇到哪些问题？如何解决？></a>Elasticsearch 集群可能遇到哪些问题？如何解决？</h3><ul><li><strong>脑裂 (Split-Brain)：</strong> 当网络分区时，集群可能分裂成多个子集群，每个子集群都选举出自己的 Master 节点，导致数据不一致。<ul><li><strong>解决方案：</strong> 配置 <code>discovery.zen.minimum_master_nodes</code> 参数（投票节点数的一半加一），确保只有多数节点存活的子集群才能选举出 Master。</ul><li><strong>集群健康状态 (Cluster Health)：</strong><ul><li><strong>Red (红色)：</strong> 至少一个主分片不可用，数据丢失或部分索引不可用，集群处于危险状态。<li><strong>Yellow (黄色)：</strong> 所有主分片可用，但至少一个副本分片不可用。数据仍然完整，但冗余性降低，高可用性受损。<li><strong>Green (绿色)：</strong> 所有主分片和副本分片都可用，集群健康。<li><strong>面试重点：</strong> 能够解释不同颜色的含义和应对措施。</ul><li><strong>磁盘空间不足：</strong> 索引拒绝写入，集群可能变红。<ul><li><strong>解决方案：</strong> 增加磁盘空间、删除旧数据、使用索引生命周期管理 (ILM)。</ul><li><strong>内存溢出 / JVM 垃圾回收频繁：</strong> 导致节点无响应或重启。<ul><li><strong>解决方案：</strong> 合理配置 JVM 堆内存，优化查询和索引操作。</ul></ul><h1 id=PostgreSql><a class=headerlink href=#PostgreSql title=PostgreSql></a>PostgreSql</h1><p>PostgreSQL 是一款功能强大、高度稳定且遵循 SQL 标准的<strong>开源对象关系型数据库管理系统 (ORDBMS)</strong>。它以其高级特性、严格的 ACID 兼容性和出色的可扩展性而闻名，常被认为是比 MySQL 更适合处理复杂业务逻辑和数据一致性要求高的场景。<h2 id=关键概念-3><a class=headerlink href=#关键概念-3 title=关键概念></a>关键概念</h2><p>以下是 PostgreSQL 的一些核心概念，理解它们是掌握 PostgreSQL 的基础：<p>对象关系型数据库 (ORDBMS)<ul><li><strong>定义：</strong> PostgreSQL 不仅仅是一个传统的关系型数据库 (RDBMS)，它还是一个<strong>对象关系型数据库 (ORDBMS)</strong>。这意味着它融合了关系型数据库的优点和面向对象数据库的一些特性。<li><strong>特点：</strong><ul><li><strong>支持对象概念：</strong> 允许定义复杂的数据类型、函数重载和继承。<li><strong>丰富的内置数据类型：</strong> 除了标准的关系型数据类型（如整数、字符串、日期）外，PostgreSQL 还原生支持许多高级数据类型，如 <strong>JSONB</strong> (二进制 JSON)、<strong>数组 (Arrays)</strong>、<strong>XML</strong>、<strong>几何数据类型</strong>、<strong>范围类型</strong>、<strong>网络地址</strong>等。<li><strong>用户自定义类型：</strong> 你可以定义自己的数据类型和操作符，极大地扩展了数据库的功能。</ul><li><strong>重要性：</strong> 这是 PostgreSQL 与 MySQL 等纯 RDBMS 的一个显著区别，使其在处理半结构化数据、复杂业务逻辑和需要高度自定义的场景中更具优势。</ul><p>索引 (Index)<ul><li><strong>作用：</strong> 索引是提高数据检索效率的数据库对象。通过创建索引，数据库可以快速定位到满足查询条件的行，而无需扫描整个表。<li><strong>类型丰富：</strong> PostgreSQL 支持多种索引类型，包括：<ul><li><strong>B-tree：</strong> 最常用，适用于各种等值查询和范围查询。<li><strong>Hash：</strong> 适用于等值查询（较少用，因为不能保证 Crash-safe）。<li><strong>GIN (Generalized Inverted Index)：</strong> 适用于处理多值数据类型（如数组、JSONB）的包含查询。<li><strong>GiST (Generalized Search Tree)：</strong> 适用于复杂数据类型（如几何数据、全文搜索）和范围查询。<li><strong>BRIN (Block Range Index)：</strong> 适用于大型表，数据自然排序的场景，非常紧凑。</ul><li><strong>重要性：</strong> 合理地设计和使用索引是优化 PostgreSQL 查询性能的关键。</ul><p>事务 (Transaction) 和 ACID<ul><li><strong>事务：</strong> 事务是一组逻辑上相关的数据库操作，它们被视为一个单一的、不可分割的工作单元。<li><strong>ACID 特性：</strong> PostgreSQL 严格遵守 <strong>ACID</strong> (Atomicity, Consistency, Isolation, Durability) 原则。<ul><li><strong>原子性 (Atomicity)：</strong> 事务中的所有操作要么全部成功，要么全部失败回滚。<li><strong>一致性 (Consistency)：</strong> 事务完成后，数据库必须从一个一致状态转换到另一个一致状态。<li><strong>隔离性 (Isolation)：</strong> 并发执行的事务彼此独立，互不影响。<li><strong>持久性 (Durability)：</strong> 一旦事务提交，其所做的修改是永久性的，即使系统崩溃也不会丢失。</ul><li><strong>重要性：</strong> 严格的 ACID 兼容性是 PostgreSQL 可靠性和数据完整性的基石，尤其适用于金融、电商等对数据一致性要求极高的应用。</ul><p>多版本并发控制 (MVCC)<ul><li><strong>定义：</strong> PostgreSQL 实现并发控制的关键机制是 <strong>MVCC (Multi-Version Concurrency Control)</strong>。<li><strong>工作原理：</strong> 当一个事务修改数据时，PostgreSQL 不会直接覆盖旧数据，而是创建一个新的数据版本。读操作总是读取数据的旧版本，写操作则创建新版本。<li><strong>优势：</strong><ul><li><strong>读写不阻塞：</strong> 读操作和写操作通常不会相互阻塞，大大提高了并发性能。<li><strong>快照隔离：</strong> 每个事务都有一个“快照”，看到的是事务开始时的数据状态，避免了脏读、不可重复读和幻读（取决于隔离级别）。</ul><li><strong>重要性：</strong> MVCC 是 PostgreSQL 在高并发读写场景下表现出色的核心原因之一，也是其与 MySQL 等数据库在并发处理上差异较大的地方。</ul><h1 id=相关资料><a class=headerlink href=#相关资料 title=相关资料></a>相关资料</h1><ol><li><a href=https://javaguide.cn/high-performance/message-queue/rabbitmq-questions.html rel=noopener target=_blank>https://javaguide.cn/high-performance/message-queue/rabbitmq-questions.html</a><li><a href=https://javabetter.cn/netty/rumen.html rel=noopener target=_blank>https://javabetter.cn/netty/rumen.html</a><li><a href=https://javabetter.cn/mq/rabbitmq-rumen.html rel=noopener target=_blank>https://javabetter.cn/mq/rabbitmq-rumen.html</a></ol><link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script></div><div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a href=https://www.sekyoro.top/2025/07/21/rabbit-mq%E5%88%9D%E6%8E%A2/ title=rabbit-mq初探>https://www.sekyoro.top/2025/07/21/rabbit-mq初探/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div><footer class=post-footer><div class=post-nav><div class=post-nav-item><a href=/2025/07/10/redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/ rel=prev title=redis核心技术> <i class="fa fa-chevron-left"></i> redis核心技术 </a></div><div class=post-nav-item></div></div></footer></article></div><!-- 评论区 --><div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#RabbitMQ><span class=nav-number>1.</span> <span class=nav-text>RabbitMQ</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%AE%89%E8%A3%85><span class=nav-number>1.1.</span> <span class=nav-text>安装</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%98%9F%E5%88%97%E7%B1%BB%E5%9E%8B><span class=nav-number>1.2.</span> <span class=nav-text>队列类型</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%BB%8F%E5%85%B8%E9%98%9F%E5%88%97><span class=nav-number>1.2.1.</span> <span class=nav-text>经典队列</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%B2%E8%A3%81%E9%98%9F%E5%88%97-Quorum-Queue><span class=nav-number>1.2.2.</span> <span class=nav-text>仲裁队列(Quorum Queue)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%B5%81%E5%BC%8F%E9%98%9F%E5%88%97-Stream-Queue><span class=nav-number>1.2.3.</span> <span class=nav-text>流式队列(Stream Queue)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%98%9F%E5%88%97%E8%AE%BE%E7%BD%AE><span class=nav-number>1.2.4.</span> <span class=nav-text>队列设置</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97><span class=nav-number>1.2.4.1.</span> <span class=nav-text>优先级队列</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B><span class=nav-number>1.3.</span> <span class=nav-text>交换机类型</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%9B%B4%E8%BF%9E%E4%BA%A4%E6%8D%A2%E6%9C%BA-Direct-Exchange><span class=nav-number>1.3.1.</span> <span class=nav-text>直连交换机 (Direct Exchange)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%B8%BB%E9%A2%98%E4%BA%A4%E6%8D%A2%E6%9C%BA-Topic-Exchange><span class=nav-number>1.3.2.</span> <span class=nav-text>主题交换机 (Topic Exchange)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%B9%BF%E6%92%AD-%E6%89%87%E5%BD%A2%E4%BA%A4%E6%8D%A2%E6%9C%BA-Fanout-Exchange><span class=nav-number>1.3.3.</span> <span class=nav-text>广播/扇形交换机 (Fanout Exchange)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A4%B4%E4%BA%A4%E6%8D%A2%E6%9C%BA-Headers-Exchange><span class=nav-number>1.3.4.</span> <span class=nav-text>头交换机 (Headers Exchange)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%AE%BE%E7%BD%AE><span class=nav-number>1.3.5.</span> <span class=nav-text>交换机设置</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%8C%81%E4%B9%85%E5%8C%96%E4%BA%A4%E6%8D%A2%E6%9C%BA><span class=nav-number>1.3.5.1.</span> <span class=nav-text>持久化交换机</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA><span class=nav-number>1.3.5.2.</span> <span class=nav-text>死信交换机</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%B6%88%E6%81%AF%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%8A%95%E9%80%92%E5%B1%9E%E6%80%A7><span class=nav-number>1.4.</span> <span class=nav-text>消息属性与投递属性</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7><span class=nav-number>1.5.</span> <span class=nav-text>消息可靠性</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%AF%E9%9D%A0%E6%80%A7><span class=nav-number>1.5.1.</span> <span class=nav-text>生产者可靠性</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%94%9F%E4%BA%A7%E8%80%85%E9%87%8D%E8%BF%9E><span class=nav-number>1.5.1.1.</span> <span class=nav-text>生产者重连</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%94%9F%E4%BA%A7%E8%80%85%E7%A1%AE%E8%AE%A4><span class=nav-number>1.5.1.2.</span> <span class=nav-text>生产者确认</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%AF%E9%9D%A0%E6%80%A7><span class=nav-number>1.5.2.</span> <span class=nav-text>消息队列可靠性</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96><span class=nav-number>1.5.2.1.</span> <span class=nav-text>数据持久化</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Lazy-Queue><span class=nav-number>1.5.2.2.</span> <span class=nav-text>Lazy Queue</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%B6%88%E8%B4%B9%E8%80%85%E5%8F%AF%E9%9D%A0%E6%80%A7><span class=nav-number>1.5.3.</span> <span class=nav-text>消费者可靠性</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%B6%88%E8%B4%B9%E8%80%85%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6><span class=nav-number>1.5.3.1.</span> <span class=nav-text>消费者确认机制</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%B6%88%E6%81%AF%E5%A4%B1%E8%B4%A5><span class=nav-number>1.5.3.2.</span> <span class=nav-text>消息失败</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%B8%9A%E5%8A%A1%E5%B9%82%E7%AD%89%E6%80%A7><span class=nav-number>1.5.3.3.</span> <span class=nav-text>业务幂等性</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF><span class=nav-number>1.5.4.</span> <span class=nav-text>延迟消息</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA-1><span class=nav-number>1.5.4.1.</span> <span class=nav-text>死信交换机</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E6%8F%92%E4%BB%B6><span class=nav-number>1.5.4.2.</span> <span class=nav-text>延迟消息插件</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B><span class=nav-number>1.6.</span> <span class=nav-text>代码案例</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8><span class=nav-number>1.7.</span> <span class=nav-text>消息转换器</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9><span class=nav-number>1.8.</span> <span class=nav-text>面试重点</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BA%A4%E6%8D%A2%E6%9C%BA%EF%BC%88Exchange%EF%BC%89%E7%9A%84%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9><span class=nav-number>1.8.1.</span> <span class=nav-text>交换机（Exchange）的面试重点</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98><span class=nav-number>1.9.</span> <span class=nav-text>遇到的问题</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BD%BF%E7%94%A8Jackson2json%E8%BD%AC%E5%8C%96%E5%99%A8%E6%8A%A5%E9%94%99><span class=nav-number>1.9.1.</span> <span class=nav-text>使用Jackson2json转化器报错</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#Netty><span class=nav-number>2.</span> <span class=nav-text>Netty</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5><span class=nav-number>2.1.</span> <span class=nav-text>关键概念</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#NIO><span class=nav-number>2.1.0.1.</span> <span class=nav-text>NIO</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8><span class=nav-number>2.1.1.</span> <span class=nav-text>IO多路复用</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Netty%E7%9B%B8%E6%AF%94NIO%E6%94%B9%E8%BF%9B><span class=nav-number>2.1.2.</span> <span class=nav-text>Netty相比NIO改进</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#EventLoop-amp-EventLoopGroup-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%BB%84><span class=nav-number>2.1.3.</span> <span class=nav-text>EventLoop & EventLoopGroup 事件循环与事件循环组</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#ChannelHandler-amp-ChannelPipeline-%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%8E%E5%A4%84%E7%90%86%E5%99%A8%E9%93%BE><span class=nav-number>2.1.4.</span> <span class=nav-text>ChannelHandler & ChannelPipeline 处理器与处理器链</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#ByteBuf-%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E5%8C%BA><span class=nav-number>2.1.5.</span> <span class=nav-text>ByteBuf 字节缓冲区</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Future-amp-Promise-%E5%BC%82%E6%AD%A5%E7%BB%93%E6%9E%9C%E4%B8%8E%E6%89%BF%E8%AF%BA><span class=nav-number>2.1.6.</span> <span class=nav-text>Future & Promise 异步结果与承诺</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8-Encoders-amp-Decoders><span class=nav-number>2.1.7.</span> <span class=nav-text>编解码器 (Encoders & Decoders)</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98><span class=nav-number>2.2.</span> <span class=nav-text>关键问题</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BB%80%E4%B9%88%E6%98%AF-TCP-%E7%B2%98%E5%8C%85-%E6%8B%86%E5%8C%85%EF%BC%9FNetty-%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F><span class=nav-number>2.2.0.1.</span> <span class=nav-text>什么是 TCP 粘包/拆包？Netty 是如何解决的？</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#MongoDB><span class=nav-number>3.</span> <span class=nav-text>MongoDB</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5-1><span class=nav-number>3.1.</span> <span class=nav-text>关键概念</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98-1><span class=nav-number>3.2.</span> <span class=nav-text>关键问题</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%80%E4%B9%88%E6%98%AF-NoSQL-%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9FMongoDB-%E5%B1%9E%E4%BA%8E%E5%93%AA%E7%A7%8D-NoSQL-%E7%B1%BB%E5%9E%8B%EF%BC%9F><span class=nav-number>3.2.1.</span> <span class=nav-text>什么是 NoSQL 数据库？MongoDB 属于哪种 NoSQL 类型？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#MongoDB-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F><span class=nav-number>3.2.2.</span> <span class=nav-text>MongoDB 的核心特点是什么？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#MongoDB-%E7%9A%84-id-%E5%AD%97%E6%AE%B5%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%AE%8A%E4%B9%8B%E5%A4%84%EF%BC%9F><span class=nav-number>3.2.3.</span> <span class=nav-text>MongoDB 的 _id 字段有什么特殊之处？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%AF%E6%9C%AC%E9%9B%86%EF%BC%88Replica-Set%EF%BC%89%EF%BC%9F%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F><span class=nav-number>3.2.4.</span> <span class=nav-text>什么是副本集（Replica Set）？它有什么作用？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E7%89%87%EF%BC%88Sharding%EF%BC%89%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E7%89%87%EF%BC%9F><span class=nav-number>3.2.5.</span> <span class=nav-text>什么是分片（Sharding）？为什么要使用分片？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%A7%A3%E9%87%8A-MongoDB-%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%96%87%E6%A1%A3%EF%BC%88Embedded-Documents%EF%BC%89%E4%B8%8E%E5%BC%95%E7%94%A8%EF%BC%88References%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E9%80%89%E6%8B%A9%E3%80%82><span class=nav-number>3.2.6.</span> <span class=nav-text>解释 MongoDB 的数据模型设计：嵌入式文档（Embedded Documents）与引用（References）的区别和选择。</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%80%E4%B9%88%E6%98%AF-MongoDB-%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%EF%BC%9F><span class=nav-number>3.2.7.</span> <span class=nav-text>什么是 MongoDB 的索引？有哪些常用的索引类型？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%9A%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%88Aggregation-Framework%EF%BC%89%EF%BC%9F%E5%B8%B8%E7%94%A8%E7%9A%84%E8%81%9A%E5%90%88%E9%98%B6%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F><span class=nav-number>3.2.8.</span> <span class=nav-text>什么是聚合框架（Aggregation Framework）？常用的聚合阶段有哪些？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#MongoDB-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E7%89%B9%E5%88%AB%E6%98%AF%E4%BA%8B%E5%8A%A1%EF%BC%89%EF%BC%9F><span class=nav-number>3.2.9.</span> <span class=nav-text>MongoDB 如何保证数据一致性（特别是事务）？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#MongoDB-%E7%9A%84%E7%BC%BA%E7%82%B9%E6%88%96%E5%B1%80%E9%99%90%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F><span class=nav-number>3.2.10.</span> <span class=nav-text>MongoDB 的缺点或局限性是什么？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E9%80%89%E6%8B%A9-MongoDB-%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E9%80%89%E6%8B%A9%EF%BC%9F><span class=nav-number>3.2.11.</span> <span class=nav-text>什么时候会选择 MongoDB 而不是关系型数据库？什么时候不选择？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C-MongoDB-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F><span class=nav-number>3.2.12.</span> <span class=nav-text>如何进行 MongoDB 的性能优化？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%96%87%E6%A1%A3%E4%B8%8Elookup%E6%93%8D%E4%BD%9C><span class=nav-number>3.2.13.</span> <span class=nav-text>嵌入式文档与lookup操作</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#Elastic-Search><span class=nav-number>4.</span> <span class=nav-text>Elastic Search</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5-2><span class=nav-number>4.1.</span> <span class=nav-text>关键概念</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98-2><span class=nav-number>4.2.</span> <span class=nav-text>关键问题</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%80%E4%B9%88%E6%98%AF-Elasticsearch%EF%BC%9F%E5%AE%83%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F><span class=nav-number>4.2.1.</span> <span class=nav-text>什么是 Elasticsearch？它的核心特点是什么？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AF%B7%E8%A7%A3%E9%87%8A-Elasticsearch-%E4%B8%AD%E7%9A%84%E9%9B%86%E7%BE%A4%EF%BC%88Cluster%EF%BC%89%E3%80%81%E8%8A%82%E7%82%B9%EF%BC%88Node%EF%BC%89%E3%80%81%E7%B4%A2%E5%BC%95%EF%BC%88Index%EF%BC%89%E3%80%81%E7%B1%BB%E5%9E%8B%EF%BC%88Type-%E5%B7%B2%E5%BA%9F%E5%BC%83%EF%BC%89%E3%80%81%E6%96%87%E6%A1%A3%EF%BC%88Document%EF%BC%89%E5%92%8C%E5%AD%97%E6%AE%B5%EF%BC%88Field%EF%BC%89%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E4%BD%9C%E7%94%A8%E3%80%82><span class=nav-number>4.2.2.</span> <span class=nav-text>请解释 Elasticsearch 中的集群（Cluster）、节点（Node）、索引（Index）、类型（Type - 已废弃）、文档（Document）和字段（Field）之间的关系和作用。</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Elasticsearch-%E4%B8%AD%E7%9A%84%E5%88%86%E7%89%87%EF%BC%88Shard%EF%BC%89%E5%92%8C%E5%89%AF%E6%9C%AC%EF%BC%88Replica%EF%BC%89%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%AE%83%E4%BB%AC%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E5%92%8C%E5%8F%AF%E4%BC%B8%E7%BC%A9%EF%BC%9F><span class=nav-number>4.2.3.</span> <span class=nav-text>Elasticsearch 中的分片（Shard）和副本（Replica）有什么作用？它们如何实现高可用和可伸缩？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%80%E4%B9%88%E6%98%AF%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%EF%BC%88Inverted-Index%EF%BC%89%EF%BC%9FElasticsearch-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E5%AE%83%EF%BC%9F><span class=nav-number>4.2.4.</span> <span class=nav-text>什么是倒排索引（Inverted Index）？Elasticsearch 为什么用它？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Elasticsearch-%E4%B8%AD%E7%9A%84-Mapping%EF%BC%88%E6%98%A0%E5%B0%84%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9Ftext-%E7%B1%BB%E5%9E%8B%E5%92%8C-keyword-%E7%B1%BB%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F><span class=nav-number>4.2.5.</span> <span class=nav-text>Elasticsearch 中的 Mapping（映射）是什么？text 类型和 keyword 类型有什么区别？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E6%9E%90%E5%99%A8%EF%BC%88Analyzer%EF%BC%89%EF%BC%9F%E5%AE%83%E7%94%B1%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90%EF%BC%9F><span class=nav-number>4.2.6.</span> <span class=nav-text>什么是分析器（Analyzer）？它由哪些部分组成？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Elasticsearch-%E7%9A%84%E5%86%99%E5%85%A5%EF%BC%88%E7%B4%A2%E5%BC%95%EF%BC%89%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F><span class=nav-number>4.2.7.</span> <span class=nav-text>Elasticsearch 的写入（索引）流程是怎样的？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Elasticsearch-%E7%9A%84%E6%9F%A5%E8%AF%A2%EF%BC%88%E6%90%9C%E7%B4%A2%EF%BC%89%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F><span class=nav-number>4.2.8.</span> <span class=nav-text>Elasticsearch 的查询（搜索）流程是怎样的？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-Elasticsearch-%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F><span class=nav-number>4.2.9.</span> <span class=nav-text>如何保证 Elasticsearch 的数据一致性？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%B8%B8%E8%A7%81%E7%9A%84-Elasticsearch-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F><span class=nav-number>4.2.10.</span> <span class=nav-text>常见的 Elasticsearch 性能优化策略有哪些？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Elasticsearch-%E9%9B%86%E7%BE%A4%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F><span class=nav-number>4.2.11.</span> <span class=nav-text>Elasticsearch 集群可能遇到哪些问题？如何解决？</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#PostgreSql><span class=nav-number>5.</span> <span class=nav-text>PostgreSql</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5-3><span class=nav-number>5.1.</span> <span class=nav-text>关键概念</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99><span class=nav-number>6.</span> <span class=nav-text>相关资料</span></a></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>242</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>16</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>214</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a><li class=links-of-blogroll-item><a href=https://www.lllomh.com/ rel=noopener target=_blank title=https://www.lllomh.com/>芈渡</a><li class=links-of-blogroll-item><a href=https://protool-ten.vercel.app/ rel=noopener target=_blank title=https://protool-ten.vercel.app/>protools</a></ul></div><div class="motion-element announcement"><div class=title></div><p class=content><p class=date></div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>此文章目前无词云</h3></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2025</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>2.7m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>41:31</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer></div><script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script><script src=/lib/anime.min.js></script><script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script><script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/pisces.js></script><script src=/js/next-boot.js></script><script src=/js/bookmark.js></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	'.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script><script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script><script src=/js/algolia-search.js></script><script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script><div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div><script charset=utf-8 defer src=/js/tagcanvas.js></script><script charset=utf-8 defer src=/js/tagcloud.js></script><script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script><script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script><script src=/js/src/activate-power-mode.min.js></script><script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script>
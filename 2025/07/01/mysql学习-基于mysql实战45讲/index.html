<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"0F9LEEVW82","apiKey":"78839e9f9be09d081c5c4da81975cd19","indexName":"sekyoblog_sec","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content="基于极客时间中的MySQL实战45讲以及小林coding,可以查看极客时间文档,相关github仓库it-ebooks-0/geektime-books: :books: 极客时间电子书和zkep/my-geektime: 👏 极客时间下载器 & 在线文档" name=description><meta content=article property=og:type><meta content=mysql学习:基于mysql实战45讲 property=og:title><meta content=https://www.sekyoro.top/2025/07/01/mysql%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E4%BA%8Emysql%E5%AE%9E%E6%88%9845%E8%AE%B2/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content="基于极客时间中的MySQL实战45讲以及小林coding,可以查看极客时间文档,相关github仓库it-ebooks-0/geektime-books: :books: 极客时间电子书和zkep/my-geektime: 👏 极客时间下载器 & 在线文档" property=og:description><meta content=zh_CN property=og:locale><meta content=https://s2.loli.net/2025/07/01/UnhSHTDM9sx8F3W.png property=og:image><meta content=https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png property=og:image><meta content=https://cdn.xiaolincoding.com//mysql/other/243b1466779a9e107ae3ef0155604a17.png property=og:image><meta content=https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png property=og:image><meta content=https://s2.loli.net/2025/08/04/bXDK2qPA9J4NxCW.png property=og:image><meta content=https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/wal.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0 property=og:image><meta content=https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%B4%A9%E6%BA%83%E7%82%B9.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0 property=og:image><meta content=https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png property=og:image><meta content=https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/ReadView.drawio.png property=og:image><meta content=https://cdn.xiaolincoding.com//mysql/other/7c635d682bd3cdc421bb9eea33a5a413.png property=og:image><meta content=https://cdn.xiaolincoding.com//mysql/other/3104c8c3adf36e8931862fe8a0520f5d.png property=og:image><meta content=https://cdn.xiaolincoding.com//mysql/other/243b1466779a9e107ae3ef0155604a17.png property=og:image><meta content=https://cdn.xiaolincoding.com//mysql/other/261011d237bec993821aa198b97ae8ce.png property=og:image><meta content=https://cdn.xiaolincoding.com//mysql/other/c296c1889f0101d335699311b4ef20a8.png property=og:image><meta content=https://cdn.xiaolincoding.com//mysql/other/f380ef357d065498d8d54ad07f145e09.png property=og:image><meta content=2025-07-01T04:12:54.000Z property=article:published_time><meta content=2025-08-05T15:24:51.867Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content=mysql property=article:tag><meta content=summary name=twitter:card><meta content=https://s2.loli.net/2025/07/01/UnhSHTDM9sx8F3W.png name=twitter:image><link href=https://www.sekyoro.top/2025/07/01/mysql%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E4%BA%8Emysql%E5%AE%9E%E6%88%9845%E8%AE%B2/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>mysql学习:基于mysql实战45讲 | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2025/07/01/mysql%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E4%BA%8Emysql%E5%AE%9E%E6%88%9845%E8%AE%B2/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>mysql学习:基于mysql实战45讲</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2025-07-01 12:12:54" datetime=2025-07-01T12:12:54+08:00>2025-07-01</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-08-05 23:24:51" datetime=2025-08-05T23:24:51+08:00 itemprop=dateModified>2025-08-05</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>74k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>1:07</span> </span></div></header><div class=post-body itemprop=articleBody><p>基于极客时间中的MySQL实战45讲以及小林coding,可以查看<a href=https://uaxe.github.io/geektime-docs/ rel=noopener target=_blank>极客时间文档</a>,相关github仓库<a href=https://github.com/it-ebooks-0/geektime-books rel=noopener target=_blank>it-ebooks-0/geektime-books: :books: 极客时间电子书</a>和<a href=https://github.com/zkep/my-geektime rel=noopener target=_blank>zkep/my-geektime: 👏 极客时间下载器 & 在线文档</a></p><span id=more></span><h1 id=基础><a class=headerlink href=#基础 title=基础></a>基础</h1><h2 id=基础架构><a class=headerlink href=#基础架构 title=基础架构></a>基础架构</h2><p><img alt=image-20250701121849232 data-src=https://s2.loli.net/2025/07/01/UnhSHTDM9sx8F3W.png><p>目前mysql版本基本大于8.0,而经典老版本5.7一些功能在新版本中已经移除(比如查询缓存).<p>MySQL 的架构共分为两层：<strong>Server 层和存储引擎层</strong>，<ul><li><strong>Server 层负责建立连接、分析和执行 SQL</strong>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。<li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。</ul><h3 id=连接器><a class=headerlink href=#连接器 title=连接器></a>连接器</h3><p>连接器用于客户端建立连接,获取权限,维持和管理连接.<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时。<p>数据库里面，<strong>长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接</strong>。<strong>短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个</strong>。<p>建立连接的过程通常是比较复杂的，所以建议在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。<p>但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，<strong>这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM）</strong>，从现象看就是MySQL异常重启了。<p>怎么解决这个问题呢？你可以考虑以下两种方案。<ol><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。<li>如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</ol><h4 id=查询缓存><a class=headerlink href=#查询缓存 title=查询缓存></a>查询缓存</h4><p>连接建立完成后,就可以执行语句了。执行逻辑就会来到第二步：查询缓存。<p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端.<p><strong>对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空</strong>。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。<blockquote><p>需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。</blockquote><h3 id=分析器><a class=headerlink href=#分析器 title=分析器></a>分析器</h3><p>进行词法分析,语法、语义解析<p>如果输入的 SQL 语句语法不对，就会在分析器这个阶段报错<p>经过分析器后，接着就要进入执行 SQL 查询语句的流程了，每条<code>SELECT</code> 查询语句流程主要可以分为下面这三个阶段：<ul><li>prepare 阶段，也就是预处理阶段；<li>optimize 阶段，也就是优化阶段；<li>execute 阶段，也就是执行阶段；</ul><p>在优化器之前会有个有预处理阶段,会检查表不存在或者字段不存在的情况<ul><li>检查 SQL 查询语句中的表或者字段是否存在；<li>将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列；</ul><h3 id=优化器><a class=headerlink href=#优化器 title=优化器></a>优化器</h3><p><strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。<h3 id=执行器><a class=headerlink href=#执行器 title=执行器></a>执行器</h3><p>执行器与存储引擎交互得到多条记录.<p>以下面查询语句为例，看看执行器是怎么工作的。<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>select</span> <span class=operator>*</span> <span class=keyword>from</span> product <span class=keyword>where</span> id <span class=operator>=</span> <span class=number>1</span>;</span><br></pre></table></figure><p>这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为 const 进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：<ul><li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 <code>id = 1</code> 交给存储引擎，<strong>让存储引擎定位符合条件的第一条记录</strong>。<li>存储引擎通过主键索引的 B+ 树结构定位到 id = 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；<li>执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。<li>执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。</ul><p>索引下推能够减少<strong>二级索引</strong>在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。<h2 id=执行查询语句流程><a class=headerlink href=#执行查询语句流程 title=执行查询语句流程></a>执行查询语句流程</h2><p>执行一条 SQL 查询语句，期间发生了什么？<ul><li>连接器：建立连接，管理连接、校验用户身份；<li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；<li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；<li>执行 SQL：执行 SQL 共有三个阶段：<ul><li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。<li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；<li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</ul></ul><h2 id=一行记录是如何存储的><a class=headerlink href=#一行记录是如何存储的 title=一行记录是如何存储的></a>一行记录是如何存储的</h2><p>MySQL 存储的行为是由存储引擎实现的，MySQL 支持多种存储引擎，不同的存储引擎保存的文件自然也不同。<p>一个数据库database包含哪些文件?假设包含一个表t_order<p>共有三个文件，这三个文件分别代表着：<ul><li>db.opt，用来存储当前数据库的默认字符集和字符校验规则。<li>t_order.frm ，t_order 的<strong>表结构</strong>会保存在这个文件。<strong>在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义</strong>。<li>t_order.ibd，t_order 的<strong>表数据</strong>会保存在这个文件。<strong>表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件</strong>（文件名：表名字.<strong>ibd</strong>）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。</ul><p>一张数据库表的数据是保存在” 表名字.ibd “的文件里的，这个文件也称为独占表空间文件<p><strong>表空间由段（segment）、区（extent）、页（page）、行（row）组成</strong>，InnoDB存储引擎的逻辑存储结构<p><img alt=img data-src=https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png><p><strong>数据库表中的记录都是按行（row）进行存放的</strong>，每行记录根据不同的行格式，有不同的存储结构.<p>记录是按照行来存储的，但是<strong>数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据</strong>，效率会非常低。<p>因此，<strong>InnoDB 的数据是按「页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。<strong>默认每个页的大小为 16KB</strong>，也就是最多能保证 16KB 的连续存储空间。<p>页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。<p>页的类型有很多，常见的有数据页、undo 日志页、溢出页等等。<strong>数据表中的行记录是用「数据页」来管理的</strong><p><img alt=图片 data-src=https://cdn.xiaolincoding.com//mysql/other/243b1466779a9e107ae3ef0155604a17.png style=zoom:67%;><p>B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机 I/O 是非常慢的。<p>解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I/O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。<p>那具体怎么解决呢？<p><strong>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了</strong>。<p>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。<ul><li>索引段：存放 B + 树的非叶子节点的区的集合；<li>数据段：存放 B + 树的叶子节点的区的集合；<li>回滚段：存放的是回滚数据的区的集合，之前讲事务隔离时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。</ul><h3 id=行格式><a class=headerlink href=#行格式 title=行格式></a>行格式</h3><p>InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。<ul><li>Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。<li>由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，<strong>Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录</strong>，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。<li>Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默<strong>认使用 Dynamic 行格式。</strong></ul><p><img alt=img data-src=https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png>一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分。<p>记录的额外信息包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息。<p>varchar(n) 和 char(n) 的区别是什么，相信大家都非常清楚，char 是定长的，varchar 是变长的，变长字段实际存储的数据的长度（大小）不固定的。<p>所以，在存储数据的时候，也要把数据占用的大小存起来，存到「变长字段长度列表」里面，读取数据的时候才能根据这个「变长字段长度列表」去读取对应长度的数据。其他 TEXT、BLOB 等变长字段也是这么实现的。<h3 id=记录的额外信息><a class=headerlink href=#记录的额外信息 title=记录的额外信息></a>记录的额外信息</h3><h4 id=变长字段列表><a class=headerlink href=#变长字段列表 title=变长字段列表></a>变长字段列表</h4><p>变长字段长度列表存储变长字段的真实数据占用的字节数会按照列的顺序<strong>逆序存放</strong><p>这部分专门用于存储变长字段（如 <code>VARCHAR</code>, <code>VARBINARY</code>, <code>TEXT</code>, <code>BLOB</code>）的实际长度。<ul><li><p><strong>顺序：</strong> 这些长度值是按照字段在表中定义的<strong>逆序</strong>存储的。例如，如果表有 <code>c1 VARCHAR(10), c2 VARCHAR(20)</code>，那么长度列表会先存储 <code>c2</code> 的长度，再存储 <code>c1</code> 的长度。</p><li><p><strong>大小：</strong> 每个长度值根据字段实际长度的不同，可能占用 1 字节或 2 字节。</p><li><p>变长字段字节数列表不是必须的。</p> <p><strong>当数据表没有变长字段的时候，比如全部都是 int 类型的字段，这时候表里的行格式就不会有「变长字段长度列表」了</strong>，因为没必要，不如去掉以节省空间。</p> <p>所以「变长字段长度列表」只出现在数据表有变长字段的时候。</p></ul><p><strong>逆序存储原因</strong><p>主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。<p>「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率</strong>。<p>同样的道理， NULL 值列表的信息也需要逆序存放。<h4 id=空值列表><a class=headerlink href=#空值列表 title=空值列表></a>空值列表</h4><p>这部分用于标记哪些列的值为 NULL。<ul><li><strong>按位表示：</strong> 它是一个位图，每个位对应一个允许为 NULL 的列。如果某个位是 1，则表示对应的列值为 NULL；如果是 0，则表示不为 NULL。<li><strong>节省空间：</strong> 这样可以节省存储 NULL 值的实际空间。如果列不允许为 NULL（<code>NOT NULL</code>），则不会在这个位图中占用空间。<li><strong>顺序：</strong> 同样是按照列在表中定义的<strong>逆序</strong>存储，但只包含允许为 NULL 的列</ul><p>表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中。<p>如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。<ul><li>二进制位的值为<code>1</code>时，代表该列的值为NULL。<li>二进制位的值为<code>0</code>时，代表该列的值不为NULL。</ul><p>另外，NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 <code>0</code>。<p>NULL 值列表也不是必须的。<p><strong>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了</strong>。<p>所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。<h4 id=记录头信息><a class=headerlink href=#记录头信息 title=记录头信息></a>记录头信息</h4><p>比较重要的：<ul><li>delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。<li>next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。<li>record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</ul><h3 id=记录的真实数据><a class=headerlink href=#记录的真实数据 title=记录的真实数据></a>记录的真实数据</h3><p>这是存储所有列的实际值的地方。<ul><li><strong>定长字段：</strong> 定长字段（如 <code>INT</code>, <code>CHAR(N)</code>）会直接存储其固定长度的值。<li><strong>变长字段：</strong> 变长字段则存储其真实的数据内容。<li><strong>溢出页存储 (Off-page Storage)：</strong> 对于 <code>TEXT</code> 和 <code>BLOB</code> 这种非常大的变长字段，如果其数据超过了数据页的存储限制（大约 8KB），InnoDB 会将其<strong>部分或全部数据存储到独立的溢出页（Overflow Pages）中</strong>。在实际数据区，只存储指向这些溢出页的 20 字节指针。这就是 <code>DYNAMIC</code> 和 <code>COMPRESSED</code> 行格式的主要优化之处，它们对于溢出数据的存储方式更灵活。<code>COMPACT</code> 和 <code>REDUNDANT</code> 会尽可能将数据存储在行内，只有在无法存储时才溢出。</ul><p>还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer.<ul><li><p>row_id 如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。</p><li><p>trx_id事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。</p><li>roll_pointer<strong>记录上一个版本的指针</strong>。roll_pointer 是必需的，占用 7 个字节。</ul><h3 id=varchar-n-含义以及n最大取值><a class=headerlink href=#varchar-n-含义以及n最大取值 title=varchar(n)含义以及n最大取值></a>varchar(n)含义以及n最大取值</h3><p><code>VARCHAR(n)</code> 的存储空间由以下两部分组成：<ul><li><p><strong>实际数据长度：</strong> 存储字符串的实际字节数。</p><li><p><strong>长度前缀：</strong> 用于记录字符串实际长度的字节数。</p> <ul><li><p>如果字符串的实际长度小于或等于 255 字节，需要 1 个字节来存储长度。</p><li><p>如果字符串的实际长度大于 255 字节，但小于或等于 65535 字节，需要 2 个字节来存储长度。</p> <p><strong>NULL 标识</strong>，如果不允许为NULL，这部分不需要</p> <p><code>n</code> 代表的是该 <code>VARCHAR</code> 列能够存储的<strong>最大字符数</strong>。</p></ul> <p>例如，<code>VARCHAR(255)</code> 表示这个列最多可以存储 255 个字符。</p></ul><p><strong>MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节</strong>。<p>也就是说，一行记录除了 TEXT、BLOBs 类型的列，限制最大为 65535 字节，注意是一行的总长度，不是一列。varchar(n) 字段类型的 n 代表的是最多存储的字符数量,因此,要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占用多少字节，比如 ascii 字符集， 1 个字符占用 1 字节，那么 varchar(100) 意味着最大能允许存储 100 字节的数据。<p><strong>一行数据的最大字节数 65535，其实是包含「变长字段长度列表」和 「NULL 值列表」所占用的字节数的</strong>。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去 storage overhead 占用的字节数。<p>因为我们存储字段类型为 varchar(n) 的数据时，其实分成了三个部分来存储：<ul><li>真实数据<li>真实数据占用的字节数<li><p>NULL 标识，如果不允许为NULL，这部分不需要</p> <p>varchar(n) 中 n 最大值时，需要减去 <strong>变长字段长度列表</strong>和 <strong>NULL 值列表</strong>所占用的字节数的。所以，<strong>在数据库表只有一个 varchar(n) 字段且字符集是 ascii 的情况下，varchar(n) 中 n 最大值 = 65535 - 2 - 1 = 65532</strong>。</p></ul><h3 id=行溢出问题><a class=headerlink href=#行溢出问题 title=行溢出问题></a>行溢出问题</h3><p>一个页默认16KB,也就16384字节,如果包含的一条记录行总大小超过了16KB会怎样.<p>这时一个页可能就存不了一条记录。这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong>。<p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到溢出页中。在一般情况下，<strong>InnoDB 的数据都是存放在 数据页中。但是当发生行溢出时，溢出的数据会存放到溢出页中</strong>。<p>在compact行格式中,当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在“溢出页”中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。<p>Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。这<strong>两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中</strong><h2 id=执行更新语句流程><a class=headerlink href=#执行更新语句流程 title=执行更新语句流程></a>执行更新语句流程</h2><p>查询语句的那一套流程，更新语句也是同样会走一遍：<ul><li>客户端先通过连接器建立连接，连接器自会判断用户身份；<li>因为这是一条 update 语句，所以不需要经过查询缓存，但是表上有更新语句，是会把整个表的查询缓存清空的，所以说查询缓存很鸡肋，在 MySQL 8.0 就被移除这个功能了；<li>解析器会通过词法分析识别出关键字 update，表名等等，构建出语法树，接着还会做语法分析，判断输入的语句是否符合 MySQL 语法；<li>预处理器会判断表和字段是否存在；<li>优化器确定执行计划，因为 where 条件中的 id 是主键索引，所以决定要使用 id 这个索引；<li>执行器负责具体执行，找到这一行，然后更新。</ul><p>不过，更新语句的流程会涉及到 undo log（回滚日志）、redo log（重做日志） 、binlog （归档日志）这三种日志：<ul><li><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；<li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；<li><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</ul><p>具体更新一条记录 <code>UPDATE t_user SET name = 'xiaolin' WHERE id = 1;</code> 的流程如下:<ol><li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：<ul><li>如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；<li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</ul><li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：<ul><li>如果一样的话就不进行后续更新流程；<li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</ul><li>开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。<li>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 <strong>WAL 技术</strong>，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。<li>至此，一条记录更新完了。<li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。<li>事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：<ul><li><strong>prepare 阶段</strong>：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；<li><strong>commit 阶段</strong>：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</ul><li>至此，一条更新语句执行完成。</ol><h3 id=日志模块><a class=headerlink href=#日志模块 title=日志模块></a>日志模块</h3><h4 id=Undo-log><a title="Undo log" class=headerlink href=#Undo-log></a>Undo log</h4><p><strong><code>Undo Log</code> 是一种逻辑日志，它记录了数据在被修改前的样子。</strong> 简单来说，它记录的是“如何撤销一个操作”的信息。当事务对数据进行修改时，InnoDB 不会直接覆盖旧数据，而是会把旧数据的版本写入到 <code>Undo Log</code> 中。<p>undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。<p>当一个事务执行过程中遇到错误，或者用户显式地发出 <code>ROLLBACK</code> 命令时，InnoDB 会利用 <code>Undo Log</code> 中记录的信息，将所有对数据库的修改<strong>撤销</strong>，使数据回到事务开始之前的状态。<p>这确保了事务的“要么全部成功，要么全部失败”的特性。<p>它记录了回滚（Undo）操作所需的信息,每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里。如果你执行了一个 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 操作：<ul><li>对于 <strong><code>INSERT</code> 操作</strong>：<code>Undo Log</code> 记录的是该行数据的 <strong>主键信息</strong>，当需要回滚时，通过主键将新插入的行删除。<li>对于 <strong><code>DELETE</code> 操作</strong>：<code>Undo Log</code> 记录的是被删除行的 <strong>完整数据</strong>，当需要回滚时，通过这些数据将行重新插入。<li>对于 <strong><code>UPDATE</code> 操作</strong>：<code>Undo Log</code> 记录的是被更新行的 <strong>旧值</strong>（修改前的数据），当需要回滚时，通过这些旧值将数据恢复。</ul><p>这些 <code>Undo Log</code> 存储在回滚段（Rollback Segment）中，位于共享表空间（System Tablespace）或单独的 <code>undo tablespace</code> 文件中。<p>在发生回滚时，就读取 undo log 里的数据，然后做原先相反操作。比如当 delete 一条记录时，undo log 中会把记录中的内容都记下来，然后执行回滚操作的时候，就读取 undo log 里的数据，然后进行 insert 操作。<p>针对 delete 操作和 update 操作会有一些特殊的处理：<ul><li>delete操作实际上不会立即直接删除，而是将delete对象打上delete flag，标记为删除，最终的删除操作是purge线程完成的。<li>update分为两种情况：update的列是否是主键列。<ul><li>如果不是主键列，在undo log中直接反向记录是如何update的。即update是直接进行的。<li>如果是主键列，update分两部执行：先删除该行，再插入一行目标行。</ul></ul><p>一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务id：<ul><li>通过 trx_id 可以知道该记录是被哪个事务修改的；<li>通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链</ul><p><img alt=image-20250804232535302 data-src=https://s2.loli.net/2025/08/04/bXDK2qPA9J4NxCW.png><p>对于「读提交」和「可重复读」隔离级别的事务来说，它们的<strong>快照读（普通 select 语句）是通过 Read View + undo log 来实现的</strong>，它们的区别在于创建 Read View 的时机不同：<ul><li>「读提交」隔离级别是在<strong>每个 select 都会生成一个新的 Read View</strong>，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。<li>「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。</ul><p>这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列（trx_id 和 roll_pointer）」的比对，如果不满足可见行，就会顺着 undo log 版本链里找到满足其可见性的记录，从而控制并发事务访问同一个记录时的行为，这就叫 MVCC(多版本并发控制).<p>undo log 两大作用：<ul><li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。<li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</ul><blockquote><p>undo log 是如何刷盘（持久化到磁盘）的？<p>undo log 和数据页的刷盘策略是一样的，都需要通过 redo log 保证持久化。<p>buffer pool 中有 undo 页，对 undo 页的修改也都会记录到 redo log。redo log 会每秒刷盘，提交事务时也会刷盘，数据页和 undo 页都是靠这个机制保证持久化的</blockquote><p>1.什么是 Undo Log？它的主要作用是什么？<ul><li><strong>回答要点：</strong> 逻辑日志，记录数据修改前的状态。两大作用是实现事务的<strong>原子性（回滚）</strong> 和 <strong>隔离性（MVCC）</strong>。</ul><ol><li>Undo Log 是如何实现事务回滚的？请举例说明。</ol><ul><li><strong>回答要点：</strong><ul><li><strong>Insert 回滚：</strong> 记录主键，回滚时删除新插入的行。<li><strong>Delete 回滚：</strong> 记录被删除的完整行数据，回滚时重新插入。<li><strong>Update 回滚：</strong> 记录更新前的旧值，回滚时用旧值覆盖新值。</ul></ul><ol><li>Undo Log 和 Redo Log 有什么区别和联系？</ol><ul><li><strong>回答要点：</strong><ul><li><strong>Undo Log：</strong> <strong>逻辑日志</strong>，记录<strong>修改前</strong>的数据（旧版本），用于<strong>回滚</strong>和<strong>MVCC</strong>。保证原子性和隔离性。<li><strong>Redo Log：</strong> <strong>物理日志</strong>，记录<strong>修改后</strong>的数据（新版本）以及操作类型，用于<strong>崩溃恢复</strong>（Crash Recovery）和<strong>持久性</strong>。保证持久性。<li><strong>联系：</strong> 它们都是事务日志，都是为了保证事务的 ACID 特性。Redo Log 保证已提交事务的持久性（即使系统崩溃也能恢复），Undo Log 保证未提交事务的原子性（回滚到事务开始前）。</ul></ul><ol><li>Undo Log 是如何实现 MVCC 的？（核心问题）</ol><ul><li><strong>回答要点：</strong><ul><li><strong>隐藏列：</strong> 每行数据都有两个隐藏列：<code>DB_TRX_ID</code>（最近一次修改该行的事务 ID）和 <code>DB_ROLL_PTR</code>（指向该行在 <code>Undo Log</code> 中上一个版本的指针）。<li><strong>Read View：</strong> 每个事务开始时，会生成一个 <code>Read View</code>（视图），其中包含当前活跃的事务 ID 列表。<li><strong>版本链：</strong> 当数据被修改时，旧版本的数据会记录在 <code>Undo Log</code> 中，并通过 <code>DB_ROLL_PTR</code> 形成一个版本链。<li><strong>可见性判断：</strong> 事务查询数据时，会根据 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断当前版本是否可见。如果不可见，就沿着 <code>DB_ROLL_PTR</code> 链回溯到 <code>Undo Log</code> 中查找更早的版本，直到找到对当前事务可见的那个版本。<li><strong>快照读：</strong> MVCC 主要支持<strong>快照读（Snapshot Read）</strong>。</ul></ul><ol><li>Undo Log 会被清除吗？什么时候清除？</ol><ul><li><strong>回答要点：</strong><ul><li><strong>会清除。</strong> <code>Undo Log</code> 并不是永久保存的。<li>当<strong>所有活跃事务</strong>都不再需要某个 <code>Undo Log</code> 版本时，这个 <code>Undo Log</code> 就会被<strong>标记为可清除</strong>。<li>InnoDB 有一个后台线程会定期回收这些不再需要的 <code>Undo Log</code> 空间。<li>如果存在<strong>长时间运行的事务</strong>（例如一个很大的查询或一个未提交的事务），它可能会长时间持有 <code>Read View</code>，导致大量的 <code>Undo Log</code> 无法被及时清除，从而占用大量磁盘空间，甚至导致数据库性能问题（例如 <code>history list length</code> 过长）。</ul></ul><ol><li>为什么长事务会导致数据库性能问题？</ol><ul><li><strong>回答要点：</strong><ul><li><strong>Undo Log 无法回收：</strong> 长事务会长时间持有 <code>Read View</code>，导致它所开启之前的 <code>Undo Log</code> 记录都无法被清理，占用大量磁盘空间。<li><strong>查询性能下降：</strong> 其他事务查询旧版本数据时，需要回溯更长的 <code>Undo Log</code> 链，增加 I/O 和 CPU 开销。<li><strong>刷新脏页受阻：</strong> <code>Undo Log</code> 过多也会影响脏页的刷新，导致内存中的脏页无法及时写入磁盘。</ul></ul><p><code>Undo Log</code> 的数据存储在 <strong>回滚段（Rollback Segment）</strong> 中。<ul><li><strong>文件类型：</strong><ul><li>在 MySQL 5.7 之前，回滚段位于<strong>共享表空间</strong>（<code>ibdata1</code>）中。<li>在 MySQL 5.7 及以后的版本，推荐将 <code>Undo Log</code> 独立出来，存储在单独的 <strong>Undo 表空间文件</strong>中，通常命名为 <code>undo001</code>, <code>undo002</code> 等。这个配置由 <code>innodb_undo_tablespaces</code> 参数控制。</ul></ul><p><strong>关键点：</strong> * 默认情况下在 <code>ibdata1</code> 中。<ul><li>推荐配置为独立文件，便于管理和回收空间。</ul><h4 id=Redo-log><a title="Redo log" class=headerlink href=#Redo-log></a>Redo log</h4><p><strong>Redo Log 是一种物理日志，它记录了对数据页的修改。</strong> 简单来说，它记录的是“数据被修改成了什么样子”。当事务对数据进行修改时，InnoDB 会先将修改操作写入到 Redo Log 中，而不是直接写入数据文件.Redo Log 记录的是数据页的物理修改，例如“对页号 X 的偏移量 Y 处的数据从 A 变为 B”。它不关心业务逻辑，只关心数据块的字节变化。<p>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，<strong>这个时候更新就算完成了</strong>。<p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。<p>InnoDB 遵循 <strong>WAL (Write-Ahead Logging)</strong> 策略，即“先写日志，再写磁盘”。<ol><li>当一个事务需要修改数据时，InnoDB 会先将这些修改操作（比如“将数据页 X 的偏移量 Y 处的值从 A 改为 B”）写入到 <strong>Redo Log Buffer</strong> (内存中的一块区域)。<li>Redo Log Buffer 中的数据会根据一定策略（比如事务提交、Buffer Pool 刷盘等）刷入到磁盘上的 <strong>Redo Log 文件</strong> (通常是 <code>ib_logfile0</code>, <code>ib_logfile1</code> 等)。<li>只有当 Redo Log 记录成功写入到磁盘（或至少同步到操作系统的文件缓存）后，事务才会被确认为“提交成功”。<li>实际的数据页的修改（从 Buffer Pool 刷写到数据文件）可以稍后进行，即使系统在数据页刷盘前崩溃，也可以通过 Redo Log 来恢复。</ol><p><img alt=img data-src=https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/wal.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0 style=zoom:67%;><blockquote><p>被修改 Undo 页面，需要记录对应 redo log 吗？</blockquote><p>需要。开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。<p>不过，<strong>在内存修改该 Undo 页面后，也是需要记录对应的 redo log，因为undo log也要实现持久性的保护</strong>。<p>写入 redo log 的方式使用了追加操作， 所以磁盘操作是<strong>顺序写</strong>，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是<strong>随机写</strong>。<p>磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。<p>针对「顺序写」为什么比「随机写」更快这个问题，可以比喻为你有一个本子，按照顺序一页一页写肯定比写一个字都要找到对应页写快得多。<p>可以说这是 WAL 技术的另外一个优点：<strong>MySQL 的写操作从磁盘的「随机写」变成了「顺序写」</strong>，提升语句的执行性能。这是因为 MySQL 的写操作并不是立刻更新到磁盘上，而是先记录在日志上，然后在合适的时间再更新到磁盘上 。<p>至此， 针对为什么需要 redo log 这个问题我们有两个答案：<ul><li><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；<li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</ul><blockquote><p>产生的 redo log 是直接写入磁盘的吗？</blockquote><p>不是的。<p>实际上， 执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I/O 操作，而且磁盘的运行速度远慢于内存。<p>所以，redo log 也有自己的缓存—— <strong>redo log buffer</strong>，每当产生一条 redo log 时，会先写入到 redo log buffer.redo log buffer 默认大小 16 MB，可以通过 <code>innodb_log_Buffer_size</code> 参数动态的调整大小，增大它的大小可以让 MySQL 处理「大事务」是不必写入磁盘，进而提升写 IO 性能。<h4 id=redo-log刷盘时机><a title="redo log刷盘时机" class=headerlink href=#redo-log刷盘时机></a>redo log刷盘时机</h4><p>缓存在 redo log buffer 里的 redo log 还是在内存中，它什么时候刷新到磁盘？<p>主要有下面几个时机：<ul><li>MySQL 正常关闭时；<li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；<li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。<li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘.这个策略可由 innodb_flush_log_at_trx_commit 参数控制</ul><ol><li>什么是 Redo Log？它的主要作用是什么？</ol><ul><li><strong>回答要点：</strong> 物理日志，记录数据页的修改（新版本）。核心作用是实现事务的<strong>持久性</strong>，用于<strong>崩溃恢复</strong>。</ul><ol><li>Redo Log 和 Undo Log 有什么区别和联系？</ol><ul><li><strong>回答要点：</strong><ul><li><strong>Redo Log：</strong> <strong>物理日志</strong>，记录<strong>修改后</strong>的数据状态，用于<strong>崩溃恢复</strong>，保证<strong>持久性</strong>。<li><strong>Undo Log：</strong> <strong>逻辑日志</strong>，记录<strong>修改前</strong>的数据状态，用于<strong>事务回滚</strong>和 <strong>MVCC</strong>，保证<strong>原子性</strong>和<strong>隔离性</strong>。<li><strong>联系：</strong> 它们都是事务日志，都是为了保证事务的 ACID 特性。Redo Log 保证已提交事务的持久性，Undo Log 保证未提交事务的原子性。两者配合，构成了 InnoDB 事务处理的核心机制。</ul></ul><ol><li>为什么 Redo Log 可以实现崩溃恢复？</ol><ul><li><strong>回答要点：</strong> 基于 <strong>WAL (Write-Ahead Logging)</strong> 策略。事务提交时，只需确保 Redo Log 写入磁盘，而无需等待数据页真正写入磁盘。即使系统崩溃，重启时可以通过 Redo Log 重放那些已经提交但未刷盘的操作，确保数据不丢失。</ul><ol><li>Redo Log 是如何保证事务提交的“快速性”和“持久性”的？</ol><ul><li><strong>回答要点：</strong><ul><li><strong>快速性（缓冲）：</strong> 事务提交时，不需要立即将脏页从 Buffer Pool 刷到磁盘，而是先将操作记录到 Redo Log Buffer，然后刷到 Redo Log 文件。由于 Redo Log 是<strong>顺序写入</strong>的，效率很高。<li><strong>持久性（同步）：</strong> 通过 <code>innodb_flush_log_at_trx_commit</code> 参数控制 Redo Log 刷盘策略，可以保证在事务提交时，Redo Log 记录已经同步到磁盘，从而确保持久性。<ul><li><code>1</code>：每次事务提交时，Redo Log 都写入文件并同步到磁盘，最安全，但性能开销大。<li><code>0</code>：每秒将 Redo Log 写入文件并同步到磁盘，性能高，但可能丢失 1 秒的数据。<li><code>2</code>：每次事务提交时，Redo Log 写入文件但不立即同步到磁盘，由操作系统负责同步，性能和安全折中。</ul></ul></ul><ol><li>Redo Log 文件的大小和数量对性能有什么影响？</ol><ul><li><strong>回答要点：</strong><ul><li><strong>文件大小（<code>innodb_log_file_size</code>）：</strong> 越大，<code>checkpoint</code> 刷脏的频率越低，可以减少磁盘 I/O，提高写入性能。但恢复时间会变长。<li><strong>文件数量（<code>innodb_log_files_in_group</code>）：</strong> 通常为 2 个或更多，形成一个环形缓冲区。数量通常不影响性能太多，主要受大小影响。<li><strong>环形写入：</strong> Redo Log 是以循环覆盖的方式写入的，当写到最后一个文件末尾时，会回到第一个文件开头继续写。</ul></ul><ol><li>什么是 Checkpoint？它与 Redo Log 有何关系？</ol><ul><li><strong>回答要点：</strong><ul><li><strong>Checkpoint (检查点)：</strong> 是一个时间点或位置，表示在某个时间点之前，所有已记录在 Redo Log 中的数据页修改，都已经被成功写入到磁盘上的数据文件了。<li><strong>关系：</strong> Checkpoint 的作用是<strong>缩短恢复时间</strong>和<strong>刷新脏页</strong>。在崩溃恢复时，InnoDB 只需从最近的 Checkpoint 开始重放 Redo Log，而不需要从 Redo Log 的最开始。Checkpoint 机制通过将脏页刷到磁盘，使得 Redo Log 中对应的那部分空间可以被重用。</ul></ul><ol><li>Redo Log 是物理日志还是逻辑日志？为什么？</ol><ul><li><strong>回答要点：</strong><ul><li><strong>物理日志：</strong> Redo Log 记录的是数据页的物理修改，例如“对页号 X 的偏移量 Y 处的数据从 A 变为 B”。它不关心业务逻辑，只关心数据块的字节变化。<li><strong>为什么是物理日志：</strong> 因为恢复时直接根据这些物理修改信息操作数据页，效率更高。而 Undo Log 记录的是逻辑操作（如 INSERT 了一行，DELETE 了一行），恢复时需要逆向执行逻辑操作。</ul></ul><p><strong>存储位置：</strong> <code>Redo Log</code> 存储在 MySQL 数据目录下的两个或多个文件中。<ul><li><strong>文件类型：</strong> 这些文件通常以 <code>ib_logfile</code> 开头，例如 <code>ib_logfile0</code>, <code>ib_logfile1</code>。<li><strong>工作方式：</strong> <code>Redo Log</code> 文件构成一个<strong>环形写入</strong>的日志组。当一个文件写满后，会切换到下一个文件，写到最后一个文件末尾后，再回到第一个文件开头继续写入，循环覆盖。</ul><p><strong>关键点：</strong> * 文件名固定，通常为 <code>ib_logfileX</code>。<ul><li>以循环方式写入，所以文件数量和大小是固定的。</ul><h4 id=Bin-log><a title="Bin log" class=headerlink href=#Bin-log></a>Bin log</h4><p>undo log 和 redo log 这两个日志都是 Innodb 存储引擎生成的。MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。<ul><li>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：<ul><li>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；<li>ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；<li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</ul><li><p>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；</p><li><p>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</p><li>redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志</ul><p><strong>存储位置：</strong> <code>Binlog</code> 存储在 MySQL 数据目录下。<p><strong>文件类型：</strong><ul><li>索引文件：<code>binlog.index</code>，记录所有 Binlog 文件的列表。<li>数据文件：<code>binlog.000001</code>, <code>binlog.000002</code> 等，每个文件记录一段时期的 Binlog 事件。</ul><p><strong>工作方式：</strong> 当 Binlog 文件达到一定大小（由 <code>max_binlog_size</code> 控制）或者重启 MySQL 服务时，会进行<strong>日志切换（Rotate）</strong>，生成一个新的 Binlog 文件。<p>Bin Log 主要用于以下两个核心功能：<ol><li>数据库复制 (Replication)</ol><p>这是 Bin Log 最主要的作用。<ul><li><strong>原理：</strong> 在主从复制架构中，主服务器会将 Bin Log 的内容实时同步给所有从服务器。<li><strong>作用：</strong> 从服务器接收到 Bin Log 的事件后，会按顺序<strong>重放 (Replay)</strong> 这些事件，从而保证主从数据库的数据最终是一致的。这使得主从架构成为可能，为高可用和读写分离提供了基础。</ul><ol><li>数据恢复 (Point-in-Time Recovery)</ol><ul><li><strong>原理：</strong> 当数据库发生意外，比如误删数据后，可以通过 Bin Log 将数据恢复到指定的时间点。<li><strong>作用：</strong> 你可以先用全量备份文件将数据库恢复到某个备份点，然后再利用备份时间点之后的 Bin Log 事件，将数据逐一重放，直到恢复到误操作发生前的状态。</ul><h4 id=主从复制><a class=headerlink href=#主从复制 title=主从复制></a>主从复制</h4><p>MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。<p>MySQL 主从复制是一个异步过程，核心是<strong>二进制日志（Binlog）</strong>。整个过程可以分为三个关键步骤：<ul><li><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。<li><strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。<li><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据</ul><p>这个过程一般是<strong>异步</strong>的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。<ol><li><strong>主库记录（Binlog Dump）</strong><ul><li>当主库上的数据发生任何修改（<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>DDL</code> 等），这些操作都会被记录到主库的<strong>二进制日志（Binlog）</strong> 中。<li>从库启动复制后，会连接到主库。主库会为每个从库创建一个<strong>Binlog Dump 线程</strong>，该线程负责将 Binlog 中的事件（Events）发送给从库。</ul><li><strong>从库接收（I/O Thread）</strong><ul><li>从库有一个<strong>I/O 线程</strong>，它负责连接主库，并请求主库的 Binlog Dump 线程发送 Binlog。<li>从库的 I/O 线程接收到 Binlog 事件后，会将这些事件顺序地写入到本地的一个文件，这个文件被称为<strong>中继日志（Relay Log）</strong>。</ul><li><strong>从库应用（SQL Thread）</strong><ul><li>从库还有一个<strong>SQL 线程</strong>，它负责读取中继日志中的事件。<li>SQL 线程会按顺序<strong>重放（Replay）</strong> 这些事件，将主库上执行过的操作，在从库上也重新执行一遍，从而保证主从数据的一致性</ul></ol><p>事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。<p>在事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 文件中，并清空 binlog cache.<p><code>sync_binlog</code> 参数用于控制 MySQL 在事务提交时，将 Binlog 从内存缓存（Binlog Cache）同步到磁盘文件的频率。它有三个可选值：<ul><li><strong><code>sync_binlog = 0</code> (默认值，不推荐)</strong><ul><li><strong>时机：</strong> 事务提交后，MySQL 仅仅将 Binlog <strong>写入文件系统缓存</strong>。至于什么时候从缓存刷到磁盘，完全依赖于操作系统自身的调度。<li><strong>性能：</strong> <strong>最高</strong>。因为减少了磁盘 I/O，写入操作非常快。<li><strong>风险：</strong> <strong>最高</strong>。一旦数据库服务器或操作系统崩溃，内存缓存中的 Binlog 数据会全部丢失。如果主从复制依赖这些 Binlog，就会导致主从数据不一致，甚至数据丢失。</ul><li><strong><code>sync_binlog = 1</code></strong><ul><li><strong>时机：</strong> <strong>每次事务提交</strong>时，MySQL 都会立即将 Binlog 从缓存写入文件，并<strong>强制同步到磁盘</strong>。<li><strong>性能：</strong> <strong>最低</strong>。因为每次提交都伴随着一次昂贵的磁盘 I/O 操作，在高并发场景下性能开销非常大。<li><strong>风险：</strong> <strong>最低</strong>。这是最安全、最可靠的设置，能够保证 Binlog 的持久性，确保在任何情况下（包括操作系统崩溃或断电）都不会丢失已提交的事务数据。这也是实现<strong>半同步复制</strong>和<strong>数据恢复</strong>的基础。</ul><li><strong><code>sync_binlog = N</code> (N > 1)</strong><ul><li><strong>时机：</strong> 每提交 <strong>N 次事务</strong>后，MySQL 才将 Binlog 刷入磁盘。<li><strong>性能：</strong> 介于 <code>0</code> 和 <code>1</code> 之间，是性能与安全性的折中方案。<li><strong>风险：</strong> 如果在第 N 次刷盘前发生崩溃，可能会丢失最多 N-1 次事务的 Binlog 数据</ul></ul><p>在MySQL中系统默认的设置是 sync_binlog = 0，也就是不做任何强制性的磁盘刷新指令，这时候的性能是最好的，但是风险也是最大的。因为<strong>一旦主机发生异常重启，还没持久化到磁盘的数据就会丢失</strong>。而当 sync_binlog 设置为 1 的时候，是最安全但是性能损耗最大的设置。因为当设置为 1 的时候，即使主机发生异常重启，最多丢失一个事务的 binlog，而已经持久化到磁盘的数据就不会有影响，不过就是对写入性能影响太大。<p>如果能容少量事务的 binlog 日志丢失的风险，为了提高写入的性能，一般会 sync_binlog 设置为 100~1000 中的某个数值。<h3 id=Buffer-Pool><a title="Buffer Pool" class=headerlink href=#Buffer-Pool></a>Buffer Pool</h3><p>Innodb引擎设计了缓冲池,当需要读取的数据不在缓冲池中,就从磁盘中加入到缓冲池,当修改的数据在缓冲池中,就直接修改并标记为脏页.<p>有了 Buffer Poo 后：<ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。<li>当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），<strong>为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘</strong></ul><p>InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。<p>在 MySQL 启动的时候，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的<code>16KB</code>的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页</strong>。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。<p>所以，MySQL 刚启动的时候，你会观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小，这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，申请物理内存，接着将虚拟地址和物理地址建立映射关系。<p>Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 Undo 页，修改缓存、自适应哈希索引、锁信息等等。<h3 id=两阶段提交><a class=headerlink href=#两阶段提交 title=两阶段提交></a>两阶段提交</h3><h4 id=redo-log与bin-log数据不一致性><a title="redo log与bin log数据不一致性" class=headerlink href=#redo-log与bin-log数据不一致性></a>redo log与bin log数据不一致性</h4><p>假设一个事务对数据进行了修改。<ul><li><strong>如果先写 Redo Log，再写 Binlog</strong>：<ol><li>Redo Log 写入成功，事务提交，但 Binlog 写入失败（例如 MySQL 崩溃）。<li>此时，数据库会认为事务已提交，恢复后数据会存在。<li>但 Binlog 中没有这条记录。如果这是一个主从架构，从库将不会收到这条修改，导致<strong>主从数据不一致</strong>。</ol><li><strong>如果先写 Binlog，再写 Redo Log</strong>：<ol><li>Binlog 写入成功，但 Redo Log 写入失败（例如 MySQL 崩溃）。<li>此时，Binlog 中有这条记录，从库会执行这个操作，数据存在。<li>但主库 Redo Log 没提交，恢复后会进行回滚，数据丢失。同样导致<strong>主从数据不一致</strong>。</ol></ul><p><strong>MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决</strong>，两阶段提交其实是<strong>分布式事务一致性协议</strong>，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。<h4 id=两阶段提交过程><a class=headerlink href=#两阶段提交过程 title=两阶段提交过程></a>两阶段提交过程</h4><p><strong>两阶段提交把单个事务的提交拆分成了 2 个阶段，分别是「准备（Prepare）阶段」和「提交（Commit）阶段」</strong>，每个阶段都由协调者（Coordinator）和参与者（Participant）共同完成。注意，不要把提交（Commit）阶段和 commit 语句混淆了，commit 语句执行的时候，会包含提交（Commit）阶段。<p>在 MySQL 的 InnoDB 存储引擎中，开启 binlog 的情况下，MySQL 会同时维护 binlog 日志与 InnoDB 的 redo log，为了保证这两个日志的一致性，MySQL 使用了<strong>内部 XA 事务</strong>，内部 XA 事务<strong>由 binlog 作为协调者，存储引擎是参与者</strong>。<p>当客户端执行 commit 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务，<strong>分两阶段来完成 XA 事务的提交</strong>.<p>事务的提交过程有两个阶段，就是<strong>将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog</strong>，具体如下：<ul><li><strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit = 1 的作用）；<li><strong>commit 阶段</strong>：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog = 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；</ul><p><img alt="时刻 A 与时刻 B" data-src=https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%B4%A9%E6%BA%83%E7%82%B9.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0><p>不管是时刻 A（redo log 已经写入磁盘， binlog 还没写入磁盘），还是时刻 B （redo log 和 binlog 都已经写入磁盘，还没写入 commit 标识）崩溃，<strong>此时的 redo log 都处于 prepare 状态</strong>。<p>在 MySQL 重启后会按顺序扫描 redo log 文件，碰到处于 prepare 状态的 redo log，就拿着 redo log 中的 XID 去 binlog 查看是否存在此 XID：<ul><li><strong>如果 binlog 中没有当前内部 XA 事务的 XID，说明 redolog 完成刷盘，但是 binlog 还没有刷盘，则回滚事务</strong>。对应时刻 A 崩溃恢复的情况。<li><strong>如果 binlog 中有当前内部 XA 事务的 XID，说明 redolog 和 binlog 都已经完成了刷盘，则提交事务</strong>。对应时刻 B 崩溃恢复的情况。</ul><p>可以看到，<strong>对于处于 prepare 阶段的 redo log，即可以提交事务，也可以回滚事务，这取决于是否能在 binlog 中查找到与 redo log 相同的 XID</strong>，如果有就提交事务，如果没有就回滚事务。这样就可以保证 redo log 和 binlog 这两份日志的一致性了。<p>所以说，<strong>两阶段提交是以 binlog 写成功为事务提交成功的标识</strong>，因为 binlog 写成功了，就意味着能在 binlog 中查找到与 redo log 相同的 XID。<blockquote><p>处于 prepare 阶段的 redo log 加上完整 binlog，重启就提交事务，MySQL 为什么要这么设计?</blockquote><p>binlog 已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。<p>所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。<blockquote><p>事务没提交的时候，redo log 会被持久化到磁盘吗？</blockquote><p>会,事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些缓存在 redo log buffer 里的 redo log 也会被「后台线程」每隔一秒一起持久化到磁盘。<p>也就是说，<strong>事务没提交的时候，redo log 也是可能被持久化到磁盘的</strong>。<p>有的同学可能会问，如果 mysql 崩溃了，还没提交事务的 redo log 已经被持久化磁盘了，mysql 重启后，数据不就不一致了？<p>放心，这种情况 mysql 重启会进行回滚操作，因为事务没提交的时候，binlog 是还没持久化到磁盘的。<p>所以， redo log 可以在事务没提交之前持久化到磁盘，但是 binlog 必须在事务提交之后，才可以持久化到磁盘<h4 id=两阶段提交问题><a class=headerlink href=#两阶段提交问题 title=两阶段提交问题></a>两阶段提交问题</h4><p>两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差，主要有两个方面的影响：<ul><li><strong>磁盘 I/O 次数高</strong>：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。<li><strong>锁竞争激烈</strong>：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。</ul><p><strong>磁盘I/O次数高原因</strong><p>binlog 和 redo log 在内存中都对应的缓存空间，binlog 会缓存在 binlog cache，redo log 会缓存在 redo log buffer，它们持久化到磁盘的时机分别由下面这两个参数控制。一般我们为了避免日志丢失的风险，会将这两个参数设置为 1：<ul><li>当 sync_binlog = 1 的时候，表示每次<strong>提交事务都会将 binlog cache 里的 binlog 直接持久到磁盘</strong>；<li>当 innodb_flush_log_at_trx_commit = 1 时，表<strong>示每次事务提交时，都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</strong>；</ul><p>可以看到，如果 sync_binlog 和 当 innodb_flush_log_at_trx_commit 都设置为 1，那么在每个事务提交过程中， 都会<strong>至少调用 2 次刷盘操作</strong>，一次是 redo log 刷盘，一次是 binlog 落盘，所以这会成为性能瓶颈。<p><strong>MySQL 引入了 binlog 组提交（group commit）机制，当有多个事务提交的时候，会将多个 binlog 刷盘操作合并成一个，从而减少磁盘 I/O 的次数</strong>，如果说 10 个事务<blockquote><p><strong>组提交</strong>是一种优化技术，它旨在将多个事务的提交操作<strong>批量化处理</strong>。在没有组提交的情况下，每个事务的提交都可能需要独立的磁盘 I/O，这在高并发场景下会成为严重的性能瓶颈。</blockquote><p>通过组提交，MySQL 将多个事务的提交请求收集在一起，然后用一次磁盘 I/O 操作完成所有这些事务的日志写入，从而有效地减少了磁盘的等待时间。依次排队刷盘的时间成本是 10，那么将这 10 个事务一次性一起刷盘的时间成本则近似于 1。<p>引入了<strong>组提交机制</strong>后，prepare 阶段不变，只针对 commit 阶段，将 commit 阶段拆分为三个过程：<ul><li><strong>flush 阶段</strong>：多个事务按进入的顺序将 binlog 从 cache 写入文件（不刷盘）；<li><strong>sync 阶段</strong>：对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）；<li><strong>commit 阶段</strong>：各个事务按顺序做 InnoDB commit 操作；</ul><p><strong>每个阶段都有一个队列</strong>，<strong>每个阶段有锁进行保护，因此保证了事务写入的顺序，第一个进入队列的事务会成为 leader，leader领导所在队列的所有事务</strong>，全权负责整队的操作，完成后通知队内其他事务操作结束。<p>对每个阶段引入了队列后，锁就只针对每个队列进行保护，不再锁住提交事务的整个过程，可以看的出来，<strong>锁粒度减小了，这样就使得多个阶段可以并发执行，从而提升效率</strong>。<h5 id=prepare阶段><a class=headerlink href=#prepare阶段 title=prepare阶段></a>prepare阶段</h5><p>prepare阶段主要做的是设置redo log 的XID(事务id)与prepare状态,然后进行redo log的刷盘.<p>在 MySQL 5.6 的组提交逻辑中，每个事务各自执行 prepare 阶段，也就是各自将 redo log 刷盘，这样就没办法对 redo log 进行组提交。<p>所以在 MySQL 5.7 版本中，做了个改进，<strong>在 prepare 阶段不再让事务各自执行 redo log 刷盘操作，而是推迟到组提交的 flush 阶段，也就是说 prepare 阶段融合在了 flush 阶段</strong>。<p>这个优化是将 redo log 的刷盘延迟到了 flush 阶段之中，sync 阶段之前。通过延迟写 redo log 的方式，为 redolog 做了一次组写入，这样 binlog 和 redo log 都进行了优化。<h5 id=flush阶段><a class=headerlink href=#flush阶段 title=flush阶段></a>flush阶段</h5><p>第一个事务会成为 flush 阶段的 Leader，此时后面到来的事务都是 Follower. 在redo log组提交下,获取队列中的事务组，由事务组的 Leader 对 redo log 做一次 write + fsync，即一次将同组事务的 redolog 刷盘。<p>完成了 prepare 阶段后，将这一组事务执行过程中产生的 binlog 写入 binlog 文件（调用 write，不会调用 fsync，所以不会刷盘，binlog 缓存在操作系统的文件系统中）。flush 阶段队列的作用是<strong>用于支撑 redo log 的组提交</strong>。如果在这一步完成后数据库崩溃，由于 binlog 中没有该组事务的记录，所以 MySQL 会在重启后回滚该组事务。<h5 id=sync阶段><a class=headerlink href=#sync阶段 title=sync阶段></a>sync阶段</h5><p>一组事务的 binlog 写入到 binlog 文件后，并不会马上执行刷盘的操作，而是<strong>会等待一段时间</strong>，这个等待的时长由 <code>Binlog_group_commit，_sync_delay</code> 参数控制，<strong>目的是为了组合更多事务的 binlog，然后再一起刷盘</strong>，在等待的过程中，如果事务的数量提前达到了 <code>Binlog_group_commit_sync_no_delay_count</code> 参数设置的值，就不用继续等待了，就马上将 binlog 刷盘。可以知道 sync 阶段队列的作用是<strong>用于支持 binlog 的组提交</strong>。<p>如果想提升 binlog 组提交的效果，可以通过设置下面这两个参数来实现：<ul><li><code>binlog_group_commit_sync_delay= N</code>，表示在等待 N 微妙后，直接调用 fsync，将处于文件系统中 page cache 中的 binlog 刷盘，也就是将「 binlog 文件」持久化到磁盘。<li><code>binlog_group_commit_sync_no_delay_count = N</code>，表示如果队列中的事务数达到 N 个，就忽视binlog_group_commit_sync_delay 的设置，直接调用 fsync，将处于文件系统中 page cache 中的 binlog 刷盘。</ul><h5 id=commit阶段><a class=headerlink href=#commit阶段 title=commit阶段></a>commit阶段</h5><p>进入 commit 阶段，调用引擎的提交事务接口，将 redo log 状态设置为 commit。commit 阶段队列的作用是承接 sync 阶段的事务，完成最后的引擎提交，使得 sync 可以尽早的处理下一组事务，最大化组提交的效率。<p>在早期的 MySQL 版本中，通过使用 prepare_commit_mutex 锁来保证事务提交的顺序，在一个事务获取到锁时才能进入 prepare 阶段，一直到 commit 阶段结束才能释放锁，下个事务才可以继续进行 prepare 操作。<p>通过加锁虽然完美地解决了顺序一致性的问题，但在并发量较大的时候，就会导致对锁的争用，性能不佳。<div class=table-container><table><thead><tr><th>特性<th><strong>老版本 (5.6 之前)</strong><th><strong>新版本 (5.7 / 8.0)</strong><tbody><tr><td><strong>并发策略</strong><td>使用全局互斥锁 <code>prepare_commit_mutex</code> 将提交过程<strong>串行化</strong><td>使用队列和组提交机制,减小了锁粒度，实现了<strong>并行提交</strong><tr><td><strong>Binlog 写入</strong><td>每个事务独立竞争锁，然后写入 Binlog，导致频繁 I/O<td>多个事务排队，由专门线程<strong>批量写入</strong> Binlog，减少 I/O<tr><td><strong>性能</strong><td>高并发写入场景下，<code>prepare_commit_mutex</code> 成为<strong>瓶颈</strong><td>显著提高了并发提交的性能，<code>prepare_commit_mutex</code> 不再是瓶颈</table></div><p>事务在提交的时候，需要将 binlog 和 redo log 持久化到磁盘，那么如果出现 MySQL 磁盘 I/O 很高的现象，可以通过控制以下参数，来 “延迟” binlog 和 redo log 刷盘的时机，从而降低磁盘 I/O 的频率：<ul><li>设置组提交的两个参数： binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，延迟 binlog 刷盘的时机，从而减少 binlog 的刷盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但即使 MySQL 进程中途挂了，也没有丢失数据的风险，因为 binlog 早被写入到 page cache 了，只要系统没有宕机，缓存在 page cache 里的 binlog 就会被持久化到磁盘。<li>将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000），表示每次提交事务都 write，但累积 N 个事务后才 fsync，相当于延迟了 binlog 刷盘的时机。但是这样做的风险是，主机掉电时会丢 N 个事务的 binlog 日志。<li>将 innodb_flush_log_at_trx_commit 设置为 2。表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache，专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存，然后交由操作系统控制持久化到磁盘的时机。但是这样做的风险是，主机掉电的时候会丢数据。</ul><h1 id=事务><a class=headerlink href=#事务 title=事务></a>事务</h1><h2 id=事务特性><a class=headerlink href=#事务特性 title=事务特性></a>事务特性</h2><ul><li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。<li><strong>一致性（Consistency）</strong>：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。<li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。<li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</ul><p>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？<ul><li>持久性是通过 redo log （重做日志）来保证的；<li>原子性是通过 undo log（回滚日志） 来保证的；<li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；<li>一致性则是通过持久性+原子性+隔离性来保证；</ul><h2 id=并行事务遇到的问题><a class=headerlink href=#并行事务遇到的问题 title=并行事务遇到的问题></a>并行事务遇到的问题</h2><p>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。<p>那么在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题。<p>脏读:如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。<p>不可重复读:在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了现象<p>幻读:在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了幻读现象.<h2 id=事务隔离级别><a class=headerlink href=#事务隔离级别 title=事务隔离级别></a>事务隔离级别</h2><p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低<p>第一种是<strong>读取未提交</strong>（READ UNCOMMITTED），在这个隔离级别下，事务可以读取其他事务尚未提交的数据，可能会发生脏读、不可重复读、幻读。当你在执行一个查询时，如果一个事务正在修改数据，但尚未提交，其他事务仍然可以看到这个未提交的数据。这虽然提供了最高的并发性，但也带来了数据一致性的风险，比如读取到不一致的数据。<p>第二种是<strong>读取已提交</strong>（READ COMMITTED），在这个隔离级别下，事务只能读取其他事务已提交的数据，可能会发生不可重复读、幻读。当你在执行一个查询时，只有那些已经提交的事务对当前事务可见。然而，不可重复读问题依然存在：如果在同一个事务中多次查询相同的数据，可能会得到不同的结果，因为其他事务可能在查询间修改了数据。<p>第三种是<strong>可重复读</strong>（REPEATABLE READ），在这个隔离级别下，事务在执行期间会锁定查询的数据行，确保该数据在事务完成前不会被其他事务修改。当你在执行一个查询时，同一事务中的查询结果不会变化，即使其他事务修改了数据，当前事务也看不到变化的数据。然而，这个级别仍然存在幻读问题，即在查询过程中，其他事务可能会插入新的数据行，导致当前事务查询的数据集发生变化。<p>第四种是<strong>可串行化</strong>（SERIALIZABLE），在这个隔离级别下，事务的执行会像是串行执行的，即一个事务执行完成后，另一个事务才能开始。当你在执行一个查询时，不仅当前查询的数据不会被修改，其他事务也不能插入新的数据行。这个级别提供了最高的数据一致性，但代价是性能的显著下降，因为它限制了并发操作。<p>MySQL 在<strong>可重复读隔离级别</strong>下，可以很大程度上避免幻读现象的发生（注意是很大程度避免，并不是彻底避免），所以 MySQL 并不会使用串行化隔离级别来避免幻读现象的发生，因为使用串行化隔离级别会影响性能。<p>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象，解决的方案有两种：<ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。<li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</ul><p>这四种隔离级别具体是如何实现的呢？<ul><li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；<li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；<li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 <strong>Read View \</strong>来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。*<em>「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View*</em>。</ul><p>执行「开始事务」命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，分别是：<ul><li>第一种：begin/start transaction 命令；<li>第二种：start transaction with consistent snapshot 命令；</ul><p>这两种开启事务的命令，事务的启动时机是不同的：<ul><li>执行了 begin/start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了第一条 select 语句，才是事务真正启动的时机；<li>执行了 start transaction with consistent snapshot 命令，就会马上启动事务。</ul><h2 id=MVCC如何实现><a class=headerlink href=#MVCC如何实现 title=MVCC如何实现></a>MVCC如何实现</h2><p><strong>MVCC 的核心思想</strong>是：<ol><li><strong>读不阻塞写，写不阻塞读：</strong> 允许多个事务同时读写数据，而不会因为读写操作相互加锁而产生阻塞。<li><strong>多版本：</strong> 当一个事务修改一行数据时，InnoDB 不会直接覆盖旧数据，而是会创建该行的一个新版本。旧版本的数据会通过 <strong>Undo Log</strong> 链表连接起来，形成一个历史版本链。<li><strong>快照读（Snapshot Read）：</strong> 普通的 <code>SELECT</code> 语句（不加锁的读）会读取一个基于事务开始时的快照，从而看到一致性的数据。<li><strong>当前读（Current Read）：</strong> <code>SELECT ... FOR SHARE</code> 或 <code>SELECT ... FOR UPDATE</code> 这样的语句会读取最新的数据版本，并对数据加锁。</ol><p><code>Read View</code> 本质上是一个<strong>事务在某一刻开启时，所有活跃（未提交）事务的列表</strong>。它记录了“<strong>我（当前事务）开始时，世界上有哪些事务还在跑</strong>”。这个视图是用来判断查询到的数据版本是否对当前事务可见的关键。<p>当你执行一个普通的 <code>SELECT</code> 语句时，InnoDB 会检查该行数据（的某个版本）的事务 ID（<code>DB_TRX_ID</code>）以及其他信息，并与 <code>Read View</code> 中的活跃事务列表进行比较，从而判断这个版本的数据是否应该被当前事务看到。<h3 id=Read-View是什么><a title="Read View是什么" class=headerlink href=#Read-View是什么></a>Read View是什么</h3><p>一个 <code>Read View</code> 主要包含以下几个核心组成部分：<ol><li><strong><code>m_ids</code> (活跃事务 ID 列表)：</strong> 一个列表中，包含了在创建 <code>Read View</code> 时，所有当前活跃（即已启动但尚未提交或回滚）的事务的 ID。<li><strong><code>min_trx_id</code> (最小活跃事务 ID)：</strong> <code>m_ids</code> 列表中最小的事务 ID。比这个 ID 小的所有事务都已经提交了。<li><strong><code>max_trx_id</code> (下一个可分配的事务 ID)：</strong> 一个未来的值，表示系统<strong>即将</strong>分配给下一个新事务的 ID。比这个 ID 大的事务（或者说，<code>max_trx_id</code> 及之后的所有事务）都是在 <code>Read View</code> 创建之后才启动的。 这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1；<li><strong><code>creator_trx_id</code> (创建者事务 ID)：</strong> 创建这个 <code>Read View</code> 的事务本身的 ID</ol><p><img alt=img data-src=https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png><p>此外,使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：<ul><li><p>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</p><li><p>roll_pointer，每次对某条聚簇索引记录进行改动时，都<strong>会把旧版本的记录写入到 undo 日志中</strong>，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</p> <p>因此通过min_trx_id,m_ids以及max_trx_id将read view分成不同情况.</p></ul><p><img alt=img data-src=https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/ReadView.drawio.png style=zoom:67%;><p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：<ul><li><p>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</p><li><p>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</p><li><p>如果记录的 trx_id 值在 Read View 的min_trx_id和max_trx_id</p> <p>之间，需要判断 trx_id 是否在 m_ids 列表中：</p> <ul><li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。<li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</ul></ul><p>这种<strong>通过版本链来控制并发事务访问</strong>同一个记录时的行为就叫 MVCC（多版本并发控制）<h2 id=可重复读如何工作><a class=headerlink href=#可重复读如何工作 title=可重复读如何工作></a>可重复读如何工作</h2><p>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View。<p>MVCC 是实现可重复读的核心。当一个事务（我们称之为 T1）开启并执行第一次快照读（<code>SELECT</code> 语句，不加锁的读）时，InnoDB 会为这个事务创建一个 <strong>Read View（读视图）</strong>。<p>这个 <code>Read View</code> 就像一个<strong>时间戳</strong>，记录了 T1 事务开始时，数据库中所有活跃（未提交）事务的 ID 列表。<p><strong><code>Read View</code> 的生命周期：</strong><p>在 <code>Repeatable Read</code> 隔离级别下，一个事务的 <code>Read View</code> 是在<strong>该事务第一次执行快照读时创建，并贯穿该事务的整个生命周期，直到事务提交或回滚</strong>。<p><strong>查询可见性判断：</strong><p>当 T1 事务执行后续的 <code>SELECT</code> 查询时，它会拿着这个固定的 <code>Read View</code> 去判断每个数据行版本是否可见。判断规则如下：<ul><li><strong>如果一个数据版本是由比 <code>Read View</code> 中最小活跃事务 ID（<code>min_trx_id</code>）更小的事务 ID 创建的（也就是说，这个版本在 T1 事务开始前就已存在并提交），那么这个版本对 T1 可见。</strong><li><strong>如果一个数据版本是由 <code>Read View</code> 中活跃事务 ID 列表（<code>m_ids</code>）中的任何一个事务创建的（也就是说，这个版本在 T1 事务开始时正在被修改，且未提交），那么这个版本对 T1 不可见。</strong><li><strong>如果一个数据版本是由比 <code>Read View</code> 中最大事务 ID（<code>max_trx_id</code>）更大的事务 ID 创建的（也就是说，这个版本是在 T1 事务开始之后才创建的），那么这个版本对 T1 不可见。</strong><li><strong>如果数据版本是由 T1 事务自己创建的，则可见。</strong></ul><p><strong>通过这种机制，T1 事务在整个过程中，每次查询都会看到一个固定的、一致的数据快照，即使其他事务在这期间修改或删除了数据并提交，T1 也看不到这些变更。</strong><p><strong>例子：</strong><ol><li><p>事务 A 启动。</p><li><p>事务 A 第一次执行 <code>SELECT * FROM accounts WHERE id = 10;</code> (假设读到 balance = 100)。此时，事务 A 的 <code>Read View</code> 被创建。</p><li><p>事务 B 启动，将 <code>id = 10</code> 的 <code>balance</code> 修改为 50，并提交。</p><li><p>事务 A 第二次执行 <code>SELECT * FROM accounts WHERE id = 10;</code>。</p> <ul><li>因为事务 A 的 <code>Read View</code> 在第一次查询时就已经固定了，事务 B 的修改发生在事务 A 的 <code>Read View</code> 创建之后且事务 B 事务 ID 大于<code>min_trx_id</code>，所以事务 A 依然看到的是 <code>balance = 100</code>。事务 B 的修改对事务 A 是不可见的。</ul> <p>也就是说可重复读会沿着undo log链中数据行的roll_pointer找到合适的trx_id进行读取.</p></ol><p>在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select .. for update 语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。<p><strong>读提交隔离级别</strong>是在每次读取数据时，都会生成一个新的 Read View,这个read view中的m_ids以及min_trx_id等记录跟同一个事务之前的read view很可能不同.<p>也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。<h2 id=幻读如何解决><a class=headerlink href=#幻读如何解决 title=幻读如何解决></a>幻读如何解决</h2><p>幻读指的是在同一个事务中，两次执行相同的范围查询（例如 <code>SELECT ... WHERE condition</code>），但第二次查询的结果集显示，满足查询条件的行数增加了或减少了。<p>同一个查询在不同的时间产生不同的结果集时，事务中就会出现所谓的幻象问题。例如，如果 SELECT 执行了两次，但第二次返回了第一次没有返回的行<p>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：<ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。<li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</ul><h3 id=快照读情况下><a class=headerlink href=#快照读情况下 title=快照读情况下></a>快照读情况下</h3><p>普通select进行快照读,也就是按照隔离级别读取对应版本数据.<p>可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是开始事务后（执行 begin 语句后），在执行第一个查询语句后，会创建一个 Read View，<strong>后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的</strong>，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题<h3 id=当前读情况下><a class=headerlink href=#当前读情况下 title=当前读情况下></a>当前读情况下</h3><p>MySQL 里除了普通查询是快照读，其他都是<strong>当前读</strong>，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。<p>另外，<code>select ... for update</code> 这种查询语句是当前读，每次执行的时候都是读取最新的数据。<p><strong>Innodb 引擎为了解决「可重复读」隔离级别使用「当前读」而造成的幻读问题，就引出了间隙锁</strong>。<p>可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读<p>例如,在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id = 5 的记录并提交。接着，事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。<p>除了上面这一种场景会发生幻读现象之外，还有下面这个场景也会发生幻读现象。<ul><li>T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id > 100 得到了 3 条记录。<li>T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；<li>T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id > 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</ul><p><strong>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句</strong>，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录<h1 id=索引><a class=headerlink href=#索引 title=索引></a>索引</h1><h2 id=索引原理><a class=headerlink href=#索引原理 title=索引原理></a>索引原理</h2><p>索引（Index）是一种用于加速数据库查询操作的数据结构，它的核心作用是提升查询的速度。从本质上来说，索引的作用就是帮助快速定位有序双向链表中的元素，从而减少数据扫描的范围，提高查询效率。接下来，我会详细讲述索引的基本概念和原理。<p>第一个是<strong>索引的基本概念</strong>，<p>索引是数据库中一种独特的数据结构，它并不直接存储表中的数据，而是通过创建一个新的数据结构来指向数据表中的具体记录。可以把它类比为字典的目录：当我们查字典时，首先会根据单词的起始字母找到目录页，然后通过目录页中的页码快速定位到具体的单词位置。在这个过程中，目录页就相当于索引表，而目录项就是索引本身。<p>然而，索引比字典目录更加复杂，因为数据库需要处理动态的数据操作，比如插入、删除和更新等操作。这些操作会导致索引发生变化，因此数据库需要维护索引的一致性和高效性。<p>第二个是<strong>索引的原理</strong>，<p>当你在MySQL中创建一个索引时， 首先，MySQL会选择一种数据结构来存储索引，最常见的结构是B+树。B+树是一种自平衡的树形结构，叶子节点存储所有数据，而非叶子节点存储索引信息。它的每个节点包含多个键值对，每个键值对指向一个数据块。 然后，索引会根据数据列的值进行排序，将相应的数据行指向叶子节点。<p>当你执行一个查询时， 首先，MySQL会利用索引的树结构，根据查询条件快速定位到数据的范围，而无需扫描全表。通过从根节点开始，逐层向下遍历B+树，最终可以找到符合条件的数据。 其次，如果索引指向的列已经包含查询条件，MySQL可以直接从索引中获取数据，避免了全表扫描，提高了查询速度。 最后，如果查询条件涉及多个列，MySQL会使用复合索引来进一步提高查找效率，通过联合多个列的索引来加速多条件查询。<p>按照四个角度来分类索引。<ul><li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。<li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。<li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。<li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</ul><p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：<ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；<li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；<li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</ul><p>主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：<ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；<li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</ul><p><strong>回表查询</strong><p>回表查询是指数据库在执行查询时，<strong>先通过索引找到对应的“行 ID”（例如 InnoDB 的主键值）</strong>，<strong>然后再根据这个行 ID 到原始数据表中（聚簇索引/B+树的叶子节点）获取所有完整的行数据</strong>。<p>简单来说，就是查询所需的所有列数据<strong>不在索引本身</strong>中，需要“回到”数据表（或叫<strong>聚簇索引</strong>的叶子节点）去取。<p><strong>覆盖索引</strong><p>覆盖索引是指查询语句所需要的所有数据列（包括 <code>SELECT</code> 子句中的列和 <code>WHERE</code>、<code>ORDER BY</code>、<code>GROUP BY</code> 子句中使用的列）<strong>都可以在索引中直接找到，而无需再回到数据表（聚簇索引）进行回表查询</strong>。<p><strong>索引下推</strong><p>现在我们知道，对于联合索引（a, b），在执行 <code>select * from table where a > 1 and b = 2</code> 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？<ul><li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。<li>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</ul><p>当你的查询语句的执行计划里，出现了 Extra 为 <code>Using index condition</code>，那么说明使用了索引下推的优化<p><strong>索引区分度</strong><p>另外，建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中<strong>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到</strong>。<p>区分度就是某个字段 column 不同值的个数「除以」表的总行数.性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 UUID 这类字段就比较适合做索引或排在联合索引列的靠前的位置。<p>因为如果索引的区分度很小，假设字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是”30%”）很高的时候，它一般会忽略索引，进行全表扫描。<h2 id=聚簇索引与二级索引><a class=headerlink href=#聚簇索引与二级索引 title=聚簇索引与二级索引></a>聚簇索引与二级索引</h2><p>索引又可以分成聚簇索引和非聚簇索引（二级索引），它们区别就在于叶子节点存放的是什么数据：<ul><li>聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；<li>二级索引的叶子节点存放的是主键值，而不是实际数据。</ul><p>因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。<p><img style="zoom: 80%;" alt=图片 data-src=https://cdn.xiaolincoding.com//mysql/other/7c635d682bd3cdc421bb9eea33a5a413.png><p>InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：<ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键；<li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；<li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键；</ul><p>一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引/辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。<p><img alt=图片 data-src=https://cdn.xiaolincoding.com//mysql/other/3104c8c3adf36e8931862fe8a0520f5d.png style=zoom:80%;><h2 id=什么时候需要索引><a class=headerlink href=#什么时候需要索引 title=什么时候需要索引></a>什么时候需要索引</h2><p>索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：<ul><li>需要占用物理空间，数量越大，占用空间越大；<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；<li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护</ul><h3 id=什么时候适用索引？><a class=headerlink href=#什么时候适用索引？ title=什么时候适用索引？></a>什么时候适用索引？</h3><ul><li>字段有唯一性限制的，比如商品编码；<li>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。<li>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</ul><h3 id=什么时候不需要创建索引？><a class=headerlink href=#什么时候不需要创建索引？ title=什么时候不需要创建索引？></a>什么时候不需要创建索引？</h3><ul><li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。<li>字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。<li>表数据太少的时候，不需要创建索引；<li>经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</ul><h2 id=InnoDB如何存储数据><a class=headerlink href=#InnoDB如何存储数据 title=InnoDB如何存储数据></a>InnoDB如何存储数据</h2><p><strong>InnoDB 的数据是按「数据页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。<p>数据页包括文件头,文件尾,页头以及页目录等信息<p><img alt=图片 data-src=https://cdn.xiaolincoding.com//mysql/other/243b1466779a9e107ae3ef0155604a17.png style=zoom:67%;><p><strong>数据页中的用户记录按照「主键」顺序组成单向链表</strong>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。<p>因此，数据页中有一个<strong>页目录</strong>，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。<p><img alt=图片 data-src=https://cdn.xiaolincoding.com//mysql/other/261011d237bec993821aa198b97ae8ce.png style=zoom:50%;><p>页目录创建的过程如下：<ol><li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；<li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）<li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），<strong>每个槽相当于指针指向了不同组的最后一个记录</strong>。</ol><p>从图可以看到，<strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表。<h3 id=如何使用B-树进行查询><a class=headerlink href=#如何使用B-树进行查询 title=如何使用B+树进行查询></a>如何使用B+树进行查询</h3><p><strong>InnoDB 采用了 B+ 树作为索引</strong>。磁盘的 I/O 操作次数对索引的使用效率至关重要，因此在构造索引的时候，我们更倾向于采用“矮胖”的 B+ 树数据结构，这样所需要进行的磁盘 I/O 次数更少，而且 B+ 树 更适合进行关键字的范围查询。InnoDB 里的 B+ 树中的<strong>每个节点都是一个数据页</strong>.<ul><li>只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。<li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；<li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</ul><p>再看看 B+ 树如何实现快速查找主键为 6 的记录，以上图为例子：<ul><li>从根节点开始，通过二分法快速定位到符合页内范围包含查询值的页，因为查询的主键值为 6，在[1, 7)范围之间，所以到页 30 中查找更详细的目录项；<li>在非叶子节点（页30）中，继续通过二分法快速定位到符合页内范围包含查询值的页，主键值大于 5，所以就到叶子节点（页16）查找记录；<li>接着，在叶子节点（页16）中，通过槽查找记录时，使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到主键为 6 的记录。</ul><p>可以看到，在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。定位到该页后，又会在该页内进行二分法快速定位记录所在的分组（槽号），最后在分组内进行遍历查找<h2 id=为什么使用B-树作为索引的数据类型><a class=headerlink href=#为什么使用B-树作为索引的数据类型 title=为什么使用B+树作为索引的数据类型></a>为什么使用B+树作为索引的数据类型</h2><p>B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。<p>另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。<p>对于有 N 个叶子节点的 B+Tree，其搜索复杂度为<code>O(logdN)</code>，其中 d 表示节点允许的最大子节点个数为 d 个。<p>在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据。<p>而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 <code>O(logN)</code>，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。<p>Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。<p>但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。<h3 id=B树-红黑树与B-树的特别点以及区别><a class=headerlink href=#B树-红黑树与B-树的特别点以及区别 title=B树,红黑树与B+树的特别点以及区别></a>B树,红黑树与B+树的特别点以及区别</h3><p>B+树、B树和红黑树是常见的平衡树数据结构，尤其在数据库、文件系统和内存中应用的十分广泛。<p>第一个方面是<strong>数据存储位置</strong>。B+树将所有数据存储在叶子节点，非叶子节点只存储索引键；B树则将数据存储在叶子节点和非叶子节点中，所有节点都存储数据；而红黑树则在每个节点中都存储数据。<p>第二个方面是<strong>叶子节点结构</strong>。B+树通过链表连接叶子节点，这使得范围查询和顺序遍历非常高效；B树的叶子节点不一定通过链表连接，缺乏直接支持范围查询的结构；红黑树没有专门的叶子节点结构，所有节点通过指针连接。<p>第三个方面是<strong>索引查找效率</strong>。B+树的查找操作最终都在叶子节点完成，查找路径统一，效率较高；B树的查找操作可能在非叶子节点完成，查找路径不统一，效率稍低；红黑树的查找路径统一，时间复杂度为O(log n)，每次操作通过旋转和重新染色来保持平衡。<p>第四个方面是<strong>树的高度</strong>。B+树由于扇出较高（每个节点存储多个键），树的高度通常较低，查询效率较高；B树由于非叶子节点也存储数据，扇出较小，树的高度较高；红黑树作为二叉查找树，树的高度较高，每个节点最多有两个子节点，树的深度较大。<p>第五个方面是<strong>顺序访问效率</strong>。B+树通过链表连接叶子节点，支持高效的顺序访问，尤其在范围查询时表现出色；B树没有直接的顺序访问机制，顺序访问效率较低；红黑树也缺乏顺序访问机制，顺序遍历效率较低。<p>第六个方面是<strong>磁盘I/O效率</strong>。B+树由于非叶子节点只存储索引，扇出高，可以减少磁盘访问次数，因此磁盘I/O效率非常优秀；B树稍逊于B+树，因为非叶子节点也存储数据，导致扇出较小，磁盘访问次数略多；红黑树的磁盘I/O效率较差，因为树的高度较高，每次查找可能需要频繁访问磁盘。<p>第七个方面是<strong>适用场景</strong>。B+树常用于数据库索引、文件系统索引，适合大规模数据的存储和检索，尤其在需要高效范围查询时；B树适用于数据库索引和文件系统索引，但相比B+树，查找效率稍低；红黑树适用于内存中的数据结构，如Java中的TreeMap和TreeSet，适合存储符号表、集合、关联数组等内存数据。<p>第八个方面是<strong>平衡性</strong>。B+树将所有叶子节点置于同一层，平衡性非常好；B树平衡性较好，但查找路径不统一，效率稍逊；红黑树通过旋转和染色来保持平衡，查找路径统一，操作保持平衡。<p>第九个方面是<strong>插入/删除操作</strong>。B+树的插入和删除操作可能会引发节点分裂和合并，操作较复杂；B树的插入和删除操作也可能引发节点分裂和合并，操作较复杂；红黑树通过旋转和染色保持平衡，操作相对简单。<p>第十个方面是<strong>实现复杂度</strong>。B+树的实现较复杂，尤其是在处理链表结构和节点分裂/合并时；B树的实现也较复杂，涉及节点分裂/合并，但相对较为简单；红黑树的实现相对简单，通过旋转和染色来保持平衡。<p>第十一个方面是<strong>空间利用率</strong>。B+树的空间利用率较高，非叶子节点只存储索引，存储效率较好；B树的空间利用率较低，非叶子节点存储数据和索引，存储效率较低；红黑树的空间利用率较高，所有节点都存储数据，且由于树的平衡性，内存利用效率较好。<p>MySQL 是会将数据持久化在硬盘，而存储功能是由 MySQL 存储引擎实现的，所以讨论 MySQL 使用哪种数据结构作为索引，实际上是在讨论存储引使用哪种数据结构作为索引，InnoDB 是 MySQL 默认的存储引擎，它就是采用了 B+ 树作为索引的数据结构。<p>要设计一个 MySQL 的索引数据结构，<strong>不仅仅考虑数据结构增删改的时间复杂度，更重要的是要考虑磁盘 I/O 的操作次数。因为索引和记录都是存放在硬盘</strong>，硬盘是一个非常慢的存储设备，我们在查询数据的时候，最好能在尽可能少的磁盘 I/O的操作次数内完成。<p><strong>二分查找树虽然是一个天然的二分结构，能很好的利用二分查找快速定位数据，但是它存在一种极端的情况，每当插入的元素都是树内最大的元素，就会导致二分查找树退化成一个链表</strong>，此时查询复杂度就会从 O(logn)降低为 O(n)。<p>为了解决二分查找树退化成链表的问题，就出现了<strong>自平衡二叉树，保证了查询操作的时间复杂度就会一直维持在 O(logn) 。但是它本质上还是一个二叉树，每个节点只能有 2 个子节点，随着元素的增多，树的高度会越来越高。</strong><p>而树的高度决定于磁盘 I/O 操作的次数，因为树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作，也就是说树的高度就等于每次查询数据时磁盘 IO 操作的次数，所以树的高度越高，就会影响查询性能。<p>B 树和 B+ 都是通过多叉树的方式，会将树的高度变矮，所以这两个数据结构非常适合检索存于磁盘中的数据。<p>但是 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：<ul><li>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。<li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；<li>B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。</ul><h2 id=优化索引方法><a class=headerlink href=#优化索引方法 title=优化索引方法></a>优化索引方法</h2><p>常见优化索引的方法：<ul><li>前缀索引优化；</ul><p>使用某个字段中字符串的前几个字符建立索引，那我们为什么需要使用前缀来建立索引呢？<p>使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。<p>不过，前缀索引有一定的局限性，例如：order by 就无法使用前缀索引；无法把前缀索引用作覆盖索引<ul><li>覆盖索引优化；</ul><p>覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。<p>使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。<ul><li>主键索引最好是自增的；</ul><p>InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。<p><strong>如果我们使用自增主键</strong>，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。<p><strong>如果我们使用非自增主键</strong>，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。<strong>页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</strong>。<p>因此，在使用 InnoDB 存储引擎时，如果没有特别的业务需求，建议使用自增字段作为主键。<p>另外，主键字段的长度不要太大，因为<strong>主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小</strong><ul><li>防止索引失效</ul><h2 id=索引失效情况><a class=headerlink href=#索引失效情况 title=索引失效情况></a>索引失效情况</h2><p>发生索引失效的情况：<ul><li>当使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；<li>当我们在查询条件中<strong>对索引列做了计算、函数、类型转换操作</strong>，这些情况下都会造成索引失效；<li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。<li>在 WHERE 子句中，<strong>如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列</strong>，那么索引会失效。<li>当查询中使用了 NOT 或 != 操作符时，索引可能会失效。例如，WHERE column != ‘value’ 或 WHERE NOT column = ‘value’ 这样的查询条件通常会导致数据库放弃使用索引，因为这类操作需要扫描大量数据来排除不符合条件的记录</ul><p>当 MySQL 使用复合索引时，它会从左到右匹配索引列。<p>一旦遇到一个<strong>范围查询（<code>></code>、<code><</code>、<code>BETWEEN</code>、<code>LIKE '前缀%'</code> 等）</strong>的列，索引的<strong>查找功能（Index Seek）</strong>就会停止在这个列上。<p>范围查询后面的索引列，虽然在物理上依然存在于索引中，但它们无法再用于进一步的<strong>索引匹配</strong>来缩小扫描范围。它们可能仍然用于<strong>索引覆盖</strong>（避免回表）或帮助进行 <code>filesort</code> 优化，但不再是查询优化器选择的索引查找路径的一部分。<h3 id=索引使用左或左右模糊匹配><a class=headerlink href=#索引使用左或左右模糊匹配 title=索引使用左或左右模糊匹配></a>索引使用左或左右模糊匹配</h3><p>具体来说,当使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效。<strong>因为索引 B+ 树是按照”索引值”有序排列存储的，只能根据前缀进行比较</strong>。<h3 id=对索引使用函数、表达式、隐式类型转换><a class=headerlink href=#对索引使用函数、表达式、隐式类型转换 title=对索引使用函数、表达式、隐式类型转换></a>对索引使用函数、表达式、隐式类型转换</h3><p>因为<strong>索引保存的是索引字段的原始值，而不是经过函数计算后的值</strong>，自然就没办法走索引了。<p>不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。<p>举个例子，对 length(name) 的计算结果建立一个名为 idx_name_length 的索引。<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>alter</span> <span class=keyword>table</span> t_user <span class=keyword>add</span> key idx_name_length ((length(name)));</span><br></pre></table></figure><p>然后再用下面这条查询语句，这时候就会走索引了。<p>mysql的隐式类型转换规则:在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较.<h3 id=联合索引非最左前缀匹配><a class=headerlink href=#联合索引非最左前缀匹配 title=联合索引非最左前缀匹配></a>联合索引非最左前缀匹配</h3><p>对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。<p>那么<strong>多个普通字段组合在一起创建的索引就叫做联合索引</strong>，也叫组合索引。<p>创建联合索引时，需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。联合索引要能正确使用需要遵循<strong>最左匹配原则</strong><p>如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：<ul><li>where a=1；<li>where a=1 and b=2 and c=3；<li>where a=1 and b=2；</ul><p>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。<p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:<ul><li>where b=2；<li>where c=3；<li>where b=2 and c=3；</ul><p>有一个比较特殊的查询条件：where a = 1 and c = 3 ，符合最左匹配吗？<p>这种其实严格意义上来说是属于索引截断，不同版本处理方式也不一样。<p>MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。<p>从 MySQL 5.6 之后，有一个<strong>索引下推功能</strong>，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。<p>索引下推的大概原理是：截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 <code>(a, b, c)</code> 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。<h3 id=where字句中的OR><a class=headerlink href=#where字句中的OR title=where字句中的OR></a>where字句中的OR</h3><p>在 WHERE 子句中，如果<strong>在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列</strong>，那么索引会失效。<p>这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。<p>这里介绍的六种索引失效情况:<ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；<li>当我们在查询条件中对索引列使用函数，就会导致索引失效。<li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。<li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。<li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。<li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</ul><h3 id=explain执行计划><a class=headerlink href=#explain执行计划 title=explain执行计划></a>explain执行计划</h3><p>explain查看执行计划<p>对于执行计划，参数有：<ul><li>possible_keys 字段表示可能用到的索引；<li>key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；<li>key_len 表示索引的长度；<li>rows 表示扫描的数据行数。<li>type 表示数据扫描类型，我们需要重点看这个</ul><p>type 字段就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的<strong>执行效率从低到高的顺序为</strong>：<ul><li>All（全表扫描）；<li>index（全索引扫描）；<li>range（索引范围扫描）；<li>ref（非唯一索引扫描）；<li>eq_ref（唯一索引扫描）；<li>const（结果只有一条的主键或唯一索引扫描）。</ul><p>all 是最坏的情况，因为采用了全表扫描的方式。index 和 all 差不多，只不过 index 对索引表进行全扫描，<strong>这样做的好处是不再需要对数据进行排序</strong>，但是开销依然很大。所以，要尽量避免全表扫描和全索引扫描。<p>range 表示采用了索引范围扫描，一般在 where 子句中使用 < 、>、in、between 等关键词，只检索给定范围的行，属于范围查找。<strong>从这一级别开始，索引的作用会越来越明显，因此我们需要尽量让 SQL 查询可以使用到 range 这一级别及以上的 type 访问方式</strong>。<p>ref 类型表示采用了非唯一索引，或者是唯一索引的非唯一性前缀，返回数据返回可能是多条。因为虽然使用了索引，<strong>但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描</strong>。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描。<p>eq_ref 类型是<strong>使用主键或唯一索引时产生的访问方式，通常使用在多表联查中。比如，对两张表进行联查，关联条件是两张表的 user_id 相等</strong>，且 user_id 是唯一索引，那么使用 EXPLAIN 进行执行计划查看的时候，type 就会显示 eq_ref。<p>const 类型表示<strong>使用了主键或者唯一索引与常量值进行比较</strong>，比如 select name from product where id=1。<p>需要说明的是 const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，<strong>const 是与常量进行比较，查询效率会更快，而 eq_ref 通常用于多表联查中</strong>。<blockquote><p>除了关注 type，也要关注 extra 显示的结果。</blockquote><p>这里说几个重要的参考指标：<ul><li>Using filesort ：当查询语句中包含 ORDER BY 操作，而且<strong>无法利用索引完成排序操作的时候</strong>， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。<li>Using temporary：使了用临时表保存中间结果，MySQL <strong>在对查询结果排序时使用临时表</strong>，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。<li>Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。</ul><h2 id=count-和-count-1-有什么区别？哪个性能最好？><a title="count(*) 和 count(1) 有什么区别？哪个性能最好？" class=headerlink href=#count-和-count-1-有什么区别？哪个性能最好？></a>count(*) 和 count(1) 有什么区别？哪个性能最好？</h2><p>count() 是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是<strong>统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个</strong>。<h3 id=count作用原理><a class=headerlink href=#count作用原理 title=count作用原理></a>count作用原理</h3><p>count() 是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是<strong>统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个</strong>。<p>使用 MyISAM 引擎时，执行 count 函数只需要 O(1 )复杂度，这是因为每张 MyISAM 的数据表都有一个 meta 信息有存储了row_count值，由表级锁保证一致性，所以直接读取 row_count 值就是 count 函数的执行结果。<p>InnoDB <strong>不像 MyISAM 那样维护一个精确的行数计数器</strong>。这是因为 InnoDB 遵循 <strong>MVCC（多版本并发控制）</strong> 机制。<ul><li>在 MVCC 下，同一个表在不同事务中可能看到不同的行数（因为有些行可能只对当前事务可见，而对其他事务不可见）。<li>维护一个精确的实时计数器会与 MVCC 冲突，并导致非常高的并发开销，因为每次查询都需要在不同事务版本之间进行复杂的判断。</ul><p><strong>没有 <code>WHERE</code> 条件的 <code>COUNT(\*)</code>：</strong> InnoDB 会选择一个<strong>最小的非聚簇索引（二级索引）</strong> 来进行<strong>全索引扫描</strong>，只遍历索引的叶子节点来计数。如果表上没有二级索引，它就会遍历<strong>聚簇索引（主键索引）</strong>。这个过程仍然需要扫描 B+Tree 的部分或全部叶子节点。<p><strong>有 <code>WHERE</code> 条件的 <code>COUNT(\*)</code>：</strong> MySQL 会根据 <code>WHERE</code> 条件选择最合适的索引（或者进行全表扫描）来定位符合条件的行，然后逐一计数。<p><code>COUNT()</code> 主要有以下几种用法：<ol><li><strong><code>COUNT(*)</code>：</strong><ul><li>统计表中<strong>所有行的数量</strong>，无论行中的列是否包含 <code>NULL</code> 值。<li>这是最常见的用法，也是 SQL 标准中推荐的计算行数的方法。</ul><li><strong><code>COUNT(expression)</code>：</strong><ul><li>统计 <code>expression</code>（通常是一个列名，例如 <code>COUNT(column_name)</code>）<strong>不为 <code>NULL</code> 的行数量</strong>。<li>如果 <code>expression</code> 是一个具体的列名，且该列允许 <code>NULL</code> 值，那么包含 <code>NULL</code> 值的行将不会被计数。<li>如果 <code>expression</code> 是一个常量（例如 <code>COUNT(1)</code>），则它的作用与 <code>COUNT(*)</code> 相同，都会统计所有行。</ul><li><strong><code>COUNT(DISTINCT expression)</code>：</strong><ul><li>统计 <code>expression</code> <strong>不为 <code>NULL</code> 且唯一的值的数量</strong>。</ul></ol><h3 id=count-1-count-count-主键-count-字段><a title="count(1) count(*) count(主键) count(字段)" class=headerlink href=#count-1-count-count-主键-count-字段></a>count(1) count(*) count(主键) count(字段)</h3><h4 id=count-主键><a class=headerlink href=#count-主键 title=count(主键)></a>count(主键)</h4><p>在通过 count 函数统计有多少个记录时，MySQL 的 server 层会维护一个名叫 count 的变量。<p>server 层会循环向 InnoDB 读取一条记录，如果 count 函数指定的参数不为 NULL，那么就会将变量 count 加 1，直到符合查询的全部记录被读完，就退出循环。最后将 count 变量的值发送给客户端。InnoDB 是通过 B+ 树来保存记录的，根据索引的类型又分为聚簇索引和二级索引，它们区别在于，聚簇索引的叶子节点存放的是实际数据，而二级索引的叶子节点存放的是主键值，而不是实际数据。如果表里只有主键索引，没有二级索引时，那么，InnoDB 循环遍历聚簇索引，将读取到的记录返回给 server 层，然后读取记录中的 id 值，就会 id 值判断是否为 NULL，如果不为 NULL，就将 count 变量加 1。<p>这是因为相同数量的二级索引记录可以比聚簇索引记录占用更少的存储空间，所以二级索引树比聚簇索引树小，这样遍历二级索引的 I/O 成本比遍历聚簇索引的 I/O 成本小，因此「优化器」优先选择的是二级索引。<p>当你执行 <code>COUNT(主键列名)</code> 时：<ul><li>根据 <code>COUNT(expression)</code> 的定义，数据库需要检查主键列的值是否为 <code>NULL</code>。<li>然而，由于主键的<strong>非空性</strong>，我们知道主键列的任何值<strong>都不可能</strong>是 <code>NULL</code>。</ul><p>因此，数据库的查询优化器非常聪明，它会识别出这种特殊情况：<ul><li>当 <code>COUNT()</code> 的参数是<strong>主键列</strong>时，优化器会知道这个列永远不为 <code>NULL</code>。<li>所以，它会<strong>优化掉“检查是否为 <code>NULL</code>”这一步</strong>，直接将 <code>COUNT(主键列)</code> 的行为等同于 <code>COUNT(*)</code> 或 <code>COUNT(1)</code>。它会去计算所有行的数量，因为它知道主键列的每一个值都是有效的、非空的</ul><h4 id=count-1><a class=headerlink href=#count-1 title=count(1)></a>count(1)</h4><p>如果表里只有主键索引，没有二级索引时。那么，InnoDB 循环遍历聚簇索引（主键索引），将读取到的记录返回给 server 层，<strong>但是不会读取记录中的任何字段的值</strong>，因为 count 函数的参数是 1，不是字段，所以不需要读取记录中的字段值。参数 1 很明显并不是 NULL，因此 server 层每从 InnoDB 读取到一条记录，就将 count 变量加 1。<p>可以看到，count(1) 相比 count(主键字段) 少一个步骤，就是不需要读取记录中的字段值，所以通常会说 count(1) 执行效率会比 count(主键字段) 高一点。<p>但是，如果表里有二级索引时，InnoDB 循环遍历的对象就二级索引了<h4 id=count><a class=headerlink href=#count title=count(*)></a>count(*)</h4><p><strong>count(<code>\*</code>) 其实等于 count(<code>0</code>)</strong>，也就是说，当你使用 count(<code>*</code>) 时，MySQL 会将 <code>*</code> 参数转化为参数 0 来处理。<p><strong>count(*) 执行过程跟 count(1) 执行过程基本一样的</strong>，性能没有什么差异。<p>而且 MySQL 会对 count(*) 和 count(1) 有个优化，如果有多个二级索引的时候，优化器会使用key_len 最小的二级索引进行扫描。<p>只有当没有二级索引的时候，才会采用主键索引来进行统计<h4 id=count-普通字段><a class=headerlink href=#count-普通字段 title=count(普通字段)></a>count(普通字段)</h4><p>count(字段) 的执行效率相比前面的 count(1)、 count(*)、 count(主键字段) 执行效率是最差的。<p>count(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。<p>所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。<p>再来，就是不要使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。。<h3 id=如何优化count><a class=headerlink href=#如何优化count title=如何优化count(*)></a>如何优化count(*)</h3><p>如果业务对于统计个数不需要很精确，比如搜索引擎在搜索关键词的时候，给出的搜索结果条数是一个大概值<p>可以使用show table status或EXPLAIN SELECT COUNT(*) FROM table_name输出结果中的 <code>rows</code> 字段会给出优化器预估的行数。这个值通常不精确，但对于快速获取一个大概的数字很有用。<p>对于允许少量延迟的计数需求，维护一个独立的计数器是最高效的方法。将这个计数值保存到单独的一张计数表中。当在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，我们需要额外维护这个计数表。<ul><li><strong>原理：</strong><ul><li><strong>缓存：</strong> 将 <code>COUNT(*)</code> 的结果缓存到 Redis、Memcached 等缓存系统中，并设置过期时间。<li><strong>计数器表：</strong> 创建一个专门的表来存储各个实体的计数。例如 <code>product_counts (product_id INT PRIMARY KEY, view_count INT, sales_count INT)</code>。</ul><li><strong>实现：</strong><ul><li><strong>异步更新：</strong> 通过应用程序代码或消息队列，在数据发生增删改时异步更新计数器。<li><strong>触发器（不推荐用于高并发）：</strong> 可以在数据库层面使用触发器来自动更新计数器表，但触发器本身会增加写入开销，在高并发场景下可能成为瓶颈。</ul><li><strong>优点：</strong> 极高的读取性能，因为直接从内存缓存或小型计数器表获取。<li><strong>缺点：</strong> 计数可能存在短暂的延迟或不一致性；增加了系统的复杂性。<li><strong>适用场景：</strong> 网站访客数、商品浏览量、论坛帖子数等对实时性要求不那么高的场景。</ul><h2 id=MySQL分页优化><a class=headerlink href=#MySQL分页优化 title=MySQL分页优化></a>MySQL分页优化</h2><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>select</span> <span class=operator>*</span> <span class=keyword>from</span> <span class=keyword>table</span> <span class=keyword>order</span> <span class=keyword>by</span> id limit <span class=number>0</span>, <span class=number>10</span>;</span><br></pre></table></figure><p>mysql内部分为<strong>server层</strong>和<strong>存储引擎层</strong>。一般情况下存储引擎都用innodb。<p>server层有很多模块，其中需要关注的是<strong>执行器</strong>是用于跟存储引擎打交道的组件。<p>执行器可以通过调用存储引擎提供的接口，将一行行数据取出，当这些数据完全符合要求（比如满足其他where条件），则会放到<strong>结果集</strong>中，最后返回给调用mysql的<strong>客户端</strong>.<h3 id=基于主键索引的分页><a class=headerlink href=#基于主键索引的分页 title=基于主键索引的分页></a>基于主键索引的分页</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>select * from table order by id limit 6000000, 10;</span><br></pre></table></figure><p>server层会调用innodb的接口，由于offset=6000000，会在innodb里的主键索引中获取到第0到（6000000 + 10）条<strong>完整行数据</strong>，<strong>返回给server层之后根据offset的值挨个抛弃，最后只留下最后面的size条</strong>，也就是10条数据，放到server层的结果集中，返回给客户端。<p>可以看出，<strong>当offset非0时，server层会从引擎层获取到很多无用的数据，而当select后面是*号时，就需要拷贝完整的行信息</strong>，<strong>拷贝完整数据</strong>跟<strong>只拷贝行数据里的其中一两个列字段</strong>耗时是不同的，这就让原本就耗时的操作变得更多.<p>因为前面的offset条数据最后都是不要的，就算将完整字段都拷贝来了又有什么用呢，所以可以将sql语句修改成下面这样。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>select * from table where id >=(select id from table order by id limit 6000000, 1) order by id limit 10;</span><br></pre></table></figure><p>上面这条sql语句，里面先执行子查询 <code>select id from page order by id limit 6000000, 1</code>, 这个操作，其实也是将在innodb中的主键索引中获取到<code>6000000+1</code>条数据，然后server层会抛弃前6000000条，只保留最后一条数据的id。<p>但不同的地方在于，<strong>在返回server层的过程中，只会拷贝数据行内的id这一列，而不会拷贝数据行的所有列</strong>，当数据量较大时，这部分的耗时还是比较明显的。<p>在拿到了上面的id之后，假设这个id正好等于6000000，那sql就变成了<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>select</span> <span class=operator>*</span> <span class=keyword>from</span> <span class=keyword>table</span> <span class=keyword>where</span> id <span class=operator>>=</span>(<span class=number>6000000</span>) <span class=keyword>order</span> <span class=keyword>by</span> id limit <span class=number>10</span>;</span><br></pre></table></figure><p>这样innodb再走一次<strong>主键索引</strong>，通过B+树快速定位到id=6000000的行数据，时间复杂度是lg(n)，然后向后取10条数据。<h3 id=基于非主键索引的分页><a class=headerlink href=#基于非主键索引的分页 title=基于非主键索引的分页></a>基于非主键索引的分页</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>select * from page table by user_name  limit 0, 10;</span><br></pre></table></figure><p>server层会调用innodb的接口，在innodb里的非主键索引中获取到第0条数据对应的主键id后，<strong>回表</strong>到主键索引中找到对应的完整行数据，然后返回给server层，server层将其放到结果集中，返回给客户端。非主键索引的limit过程，比主键索引的limit过程，多了个回表的消耗<p>当limit offset过大时如果优化器分析回表操作次数过多会使用全表扫描<p>这种情况也能通过一些方式去优化。比如<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>select * from page t1, (select id from page order by user_name limit 6000000, 100) t2  WHERE t1.id = t2.id;</span><br></pre></table></figure><p>通过<code>select id from page order by user_name limit 6000000, 100</code>。先走innodb层的user_name非主键索引取出id，因为只拿主键id，<strong>不需要回表</strong>.<h3 id=深度分页问题><a class=headerlink href=#深度分页问题 title=深度分页问题></a>深度分页问题</h3><p>当offset变得超大时，比如到了百万千万的量级就导致了<strong>深度分页</strong>.<p>通过<code>limit offset size</code>分页的形式去分批获取，刚开始都是好的，等慢慢地，哪天数据表变得奇大无比，就有可能出现前面提到的<strong>深度分页</strong>问题。<h4 id=取出全表数据或下一页连续滚动加载><a class=headerlink href=#取出全表数据或下一页连续滚动加载 title=取出全表数据或下一页连续滚动加载></a>取出全表数据或下一页连续滚动加载</h4><p>可以将所有的数据<strong>根据id主键进行排序</strong>，然后分批次取，将当前批次的最大id作为下次筛选的条件进行查询。<p>这种方法的核心思想是<strong>记住上次查询的位置</strong>，而不是通过偏移量来跳过数据。它适用于可以找到一个唯一且有序的列（通常是主键或唯一索引列）作为“书签”的场景。<ul><li><strong>原理：</strong> 不使用 <code>OFFSET</code>，而是记录上一页最后一条记录的 ID（或其他有序列的值），然后查询下一页时从这个 ID 之后开始。<li><strong>示例：</strong><ul><li>第一页：<code>SELECT * FROM products ORDER BY id ASC LIMIT 10;</code> (假设最后一条记录 id 是 10)<li>第二页：<code>SELECT * FROM products WHERE id > 10 ORDER BY id ASC LIMIT 10;</code><li>第 N 页：<code>SELECT * FROM products WHERE id > [上一页最大ID] ORDER BY id ASC LIMIT 10;</code></ul><li><strong>优点：</strong> 无论页码多深，查询效率都非常高，因为它总是从一个已知点开始，进行固定数量的扫描。<li><strong>缺点：</strong> 不支持“跳到第 X 页”的需求，只支持“下一页/上一页”或连续滚动加载的场景。</ul><h4 id=给用户做分页展示><a class=headerlink href=#给用户做分页展示 title=给用户做分页展示></a>给用户做分页展示</h4><p>优化 <code>LIMIT offset, pageSize</code> 的子查询<p>这种方法适用于仍然需要支持“跳到第 X 页”的场景，但尝试减少主查询的回表成本。<ul><li><strong>原理：</strong> 先通过一个子查询只查出目标页的<strong>主键 ID</strong>，这通常能利用索引快速完成。然后，再通过这些 ID 回表查询完整的数据。<li><strong>示例：</strong> <code>SELECT p.* FROM products p INNER JOIN (SELECT id FROM products ORDER BY id ASC LIMIT 100000, 10) AS sub ON p.id = sub.id;</code><li><strong>优点：</strong><ul><li>子查询 <code>(SELECT id FROM products ORDER BY id ASC LIMIT 100000, 10)</code> 只扫描和排序 <code>id</code> 这一列（如果 <code>id</code> 是主键，可以走聚簇索引的索引部分或覆盖索引），这比扫描所有列要快得多。<li><code>INNER JOIN</code> 后，回表操作是基于精确的 ID 列表，通常效率较高。</ul><li><strong>缺点：</strong> 仍然需要扫描和排序 <code>offset + pageSize</code> 个 ID。当 <code>offset</code> 非常大时，子查询本身还是会有性能问题。但在某些情况下，尤其是有覆盖索引支持子查询时，比直接 <code>SELECT * LIMIT OFFSET</code> 要好。</ul><p>如果实现翻页需求,类似谷歌搜索时看到的翻页功能,不需要offset过多数据,一般十几页就够了.<p>如果要做搜索或筛选类的页面的话，就使用elastic search，并且也需要控制展示的结果数，比如一万以内，这样不至于让分页过深.<p>如果因为各种原因，必须使用mysql。那同样，也需要控制下返回结果数量，比如数量1k以内。这样就能勉强支持各种翻页，跳页（比如突然跳到第6页然后再跳到第106页）。<p>但如果能从产品的形式上就做成不支持跳页会更好，比如<strong>只支持上一页或下一页</strong>。这样就可以使用上面提到的start_id方式，采用分批获取，每批数据以start_id为起始位置。这个解法最大的好处是不管翻到多少页，查询速度永远稳定<ul><li><code>limit offset, size</code> 比 <code>limit size</code> 要慢，且offset的值越大，sql的执行速度越慢。<li>当offset过大，会引发<strong>深度分页</strong>问题，目前不管是mysql还是es都没有很好的方法去解决这个问题。只能通过限制查询数量或分批获取的方式进行规避。<li>遇到深度分页的问题，多思考其原始需求，大部分时候是不应该出现深度分页的场景的，必要时多去影响产品经理。<li>如果数据量很少，比如1k的量级，且长期不太可能有巨大的增长，还是用<code>limit offset, size</code> 的方案吧，整挺好，能用就行。</ul><h1 id=锁><a class=headerlink href=#锁 title=锁></a>锁</h1><p>根据加锁的范围，可以分为<strong>全局锁、表级锁和行锁</strong>三类。<h2 id=全局锁><a class=headerlink href=#全局锁 title=全局锁></a>全局锁</h2><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>flush tables <span class=keyword>with</span> read lock</span><br></pre></table></figure><p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：<ul><li>对数据的增删改操作，比如 insert、delete、update等语句；<li>对表结构的更改操作，比如 alter table、drop table 等语句。</ul><p>如果要释放全局锁，则要执行这条命令：<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>unlock tables</span><br></pre></table></figure><p>当会话断开了，全局锁会被自动释放。<p>加全局锁主要用在数据备份的时候,使得数据只读,避免备份时的数据不一致性问题.如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。<blockquote><p>既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？</blockquote><p>有的，如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。<p>因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。<p>备份数据库的工具是 mysqldump，在<strong>使用 mysqldump 时加上 <code>–single-transaction</code> 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。</strong><p>InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。<p>但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法<h2 id=表级锁><a class=headerlink href=#表级锁 title=表级锁></a>表级锁</h2><p>MySQL 里面表级别的锁有这几种：<ul><li>表锁；<li>元数据锁（MDL）;<li>意向锁；<li>AUTO-INC 锁；</ul><h3 id=表锁><a class=headerlink href=#表锁 title=表锁></a>表锁</h3><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>lock tables table_name read;</span><br><span class=line>lock tables table_name write;</span><br></pre></table></figure><p>read表锁是共享读锁,允许当前会话读取被锁定的表但阻止其他会话对这些表进行写操作.<p>write表锁是独占写锁,允许当前会话读写被锁定的表但阻止其他会话对这些表进行任何操作.<p>表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。<p>如果在某个线程 A 中执行 <code>lock tables t1 read, t2 write</code>; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。<p>当会话退出后，也会释放所有表锁。<p>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式，不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，<strong>InnoDB 实现了颗粒度更细的行级锁</strong><h3 id=元数据锁><a class=headerlink href=#元数据锁 title=元数据锁></a>元数据锁</h3><p>对数据库表进行操作时，会自动给这个表加上 MDL：<ul><li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；<li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</ul><p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。<p>当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。<p>反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。<p>元数据锁是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。<p>那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：<ol><li>首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；<li>然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；<li>接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</ol><p>那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。因为申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。<p>所以为了能安全的对表结构进行变更，<strong>在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更</strong>。<h3 id=意向锁><a class=headerlink href=#意向锁 title=意向锁></a>意向锁</h3><ul><li>在使用 InnoDB 引擎的表里对某些记录加上”共享锁”之前，需要先在表级别加上一个「意向共享锁」；<li>在使用 InnoDB 引擎的表里对某些纪录加上”独占锁”之前，需要先在表级别加上一个「意向独占锁」；</ul><p>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且<strong>意向锁之间也不会发生冲突</strong>，<strong>只会和共享表锁（lock tables … read）和独占表锁（</strong>lock tables … write）发生冲突。<p>普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=operator>/</span><span class=operator>/</span>先在表上加上意向共享锁，然后对读取的记录加共享锁</span><br><span class=line><span class=keyword>select</span> ... lock <span class=keyword>in</span> share mode;</span><br><span class=line></span><br><span class=line><span class=operator>/</span><span class=operator>/</span>先表上加上意向独占锁，然后对读取的记录加独占锁</span><br><span class=line><span class=keyword>select</span> ... <span class=keyword>for</span> update;</span><br></pre></table></figure><p>表锁和行锁是满足读读共享、读写互斥、写写互斥的。<p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。<p>在加上独占表锁时就会检查表上是否有意向独占锁,不用去遍历每个记录是否加行锁.<p>意向锁的目的是为了快速判断表里是否有记录被加锁<h3 id=AUCO-INC锁><a class=headerlink href=#AUCO-INC锁 title=AUCO-INC锁></a>AUCO-INC锁</h3><p>表里的主键通常都会设置成自增的，这是通过对主键字段声明 <code>AUTO_INCREMENT</code> 属性实现的。<p>之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 <strong>AUTO-INC 锁</strong>实现的。<p>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。<p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。<p>那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 <code>AUTO_INCREMENT</code> 修饰的字段的值是连续递增的。<p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。<blockquote><p>在老版本,自增字段通过表级锁AUTO-INC锁执行插入语句后再释放.</blockquote><p>在新版本,<code>AUTO-INC</code> 锁的工作机制在不同版本和模式下有所不同：<ol><li>传统模式（<code>innodb_autoinc_lock_mode=0</code>）</ol><p>这是最悲观的模式，也是最早的实现方式。<ul><li><strong>加锁机制</strong>：在执行 <code>INSERT</code> 语句时，无论是单行插入还是批量插入，都会对<strong>整个表</strong>加一个 <code>AUTO-INC</code> 表锁。<li><strong>并发性</strong>：当一个事务持有这个锁时，其他所有试图插入数据的事务都会被阻塞，直到锁被释放。这使得自增值严格连续，但<strong>并发性能非常差</strong>。</ul><ol><li>连续模式（<code>innodb_autoinc_lock_mode=1</code>）</ol><p>这是MySQL 5.1之后引入的默认模式，旨在提高并发性。<ul><li><strong>加锁机制</strong>：<ul><li><strong>对于单行插入</strong>：MySQL只在分配自增值时加一个<strong>轻量级锁</strong>，分配完后立即释放，锁定的时间非常短。<li><strong>对于批量插入</strong>：为了保证批量插入的自增值是连续的，MySQL会像传统模式一样加一个<code>AUTO-INC</code>表锁，直到语句执行完毕才释放。</ul><li><strong>并发性</strong>：这种模式在单行插入时有很高的并发性。对于批量插入，虽然性能有所牺牲，但保证了自增值的连续性。</ul><ol><li>交错模式（<code>innodb_autoinc_lock_mode=2</code>）</ol><p>这是MySQL 8.0的推荐模式。<ul><li><strong>加锁机制</strong>：完全移除了<code>AUTO-INC</code>表锁。所有插入操作都只在分配自增值时加一个轻量级的锁，分配完后立即释放。<li><strong>并发性</strong>：并发性能最高，<strong>自增值的生成完全不会阻塞其他事务</strong>。<li><strong>问题</strong>：由于不同事务的自增值是交错分配的，<strong>不能保证自增值的连续性</strong>。当一个事务回滚时，其已经分配的自增值会形成“空洞”，永远不会被使用。</ul><p>当 innodb_autoinc_lock_mode = 2 是性能最高的方式，但是当搭配 binlog 的日志格式是 statement 一起使用的时候，在「主从复制的场景」中会发生<strong>数据不一致的问题</strong>。<p>如果 innodb_autoinc_lock_mode = 2，意味着「申请自增主键后就释放锁，不必等插入语句执行完」。那么就可能出现这样的情况：<ul><li>session B 先插入了两个记录，(1,1,1)、(2,2,2)；<li>然后，session A 来申请自增 id 得到 id=3，插入了（3,5,5)；<li>之后，session B 继续执行，插入两条记录 (4,3,3)、 (5,4,4)。</ul><p>可以看到，<strong>session B 的 insert 语句，生成的 id 不连续</strong>。<p>当「主库」发生了这种情况，binlog 面对 t2 表的更新只会记录这两个 session 的 insert 语句，如果 binlog_format=statement，记录的语句就是原始语句。记录的顺序要么先记 session A 的 insert 语句，要么先记 session B 的 insert 语句。<p>但不论是哪一种，这个 binlog 拿去「从库」执行，这时从库是按「顺序」执行语句的，只有当执行完一条 SQL 语句后，才会执行下一条 SQL。因此，在<strong>从库上「不会」发生像主库那样两个 session 「同时」执行向表 t2 中插入数据的场景。所以，在备库上执行了 session B 的 insert 语句，生成的结果里面，id 都是连续的。这时，主从库就发生了数据不一致</strong>。<p>要解决这问题，binlog 日志格式要设置为 row，这样在 binlog 里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，从库的自增值就是什么。<p>所以，<strong>当 innodb_autoinc_lock_mode = 2 时，并且 binlog_format = row，既能提升并发性，又不会出现数据一致性问题</strong>。<h2 id=行级锁><a class=headerlink href=#行级锁 title=行级锁></a>行级锁</h2><p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。<p>前面也提到，普通的 select 语句是不会对记录加锁的，因为它属于快照读。如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为<strong>锁定读</strong>。<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=operator>/</span><span class=operator>/</span>对读取的记录加共享锁</span><br><span class=line><span class=keyword>select</span> ... lock <span class=keyword>in</span> share mode;</span><br><span class=line></span><br><span class=line><span class=operator>/</span><span class=operator>/</span>对读取的记录加独占锁</span><br><span class=line><span class=keyword>select</span> ... <span class=keyword>for</span> update;</span><br></pre></table></figure><p>上面这两条语句必须在一个事务中，<strong>因为当事务提交了，锁就会被释放</strong>，所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit = 0<p>普通的 select 语句是不会对记录加锁的（除了串行化隔离级别），因为它属于快照读，是通过 MVCC（多版本并发控制）实现的。<h4 id=记录锁><a class=headerlink href=#记录锁 title=记录锁></a>记录锁</h4><p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：<ul><li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;<li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</ul><p>插入、删除以及更新的DML语句会加互斥锁,select xx for update也会加互斥锁<p>而select xx for share会加共享锁.当事务执行 commit 后，事务过程中生成的锁都会被释放<h4 id=间隙锁><a class=headerlink href=#间隙锁 title=间隙锁></a>间隙锁</h4><p>Gap Lock 称为间隙锁，存在于可重复读隔离级别和串行化隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。<p>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，<strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong>。<h4 id=Next-Key-Lock><a title="Next-Key Lock" class=headerlink href=#Next-Key-Lock></a>Next-Key Lock</h4><p>记录锁 +间隙锁的组合，锁定一个范围，并且锁定记录本身。<p>对于记录锁，要考虑 X 型与 S 型关系，X 型的记录锁与 X 型的记录锁是冲突的<h4 id=插入意向锁><a class=headerlink href=#插入意向锁 title=插入意向锁></a>插入意向锁</h4><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。<p>插入意向锁名字虽然有意向锁，但是它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong>。如果说间隙锁锁住的是一个区间，那么<strong>插入意向锁</strong>锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。<p>插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。<h2 id=Mysql如何加行级锁><a class=headerlink href=#Mysql如何加行级锁 title=Mysql如何加行级锁></a>Mysql如何加行级锁</h2><p>行级锁加锁规则比较复杂，不同的场景，加锁的形式是不同的。<p><strong>加锁的对象是索引，加锁的基本单位是 next-key lock</strong>，它是由记录锁和间隙锁组合而成的，<strong>next-key lock 是前开后闭区间，而间隙锁是前开后开区间</strong>。<p>但是，next-key lock 在一些场景下会退化成记录锁或间隙锁。<strong>在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成记录锁或间隙锁</strong>。<h3 id=唯一索引等值查询><a class=headerlink href=#唯一索引等值查询 title=唯一索引等值查询></a>唯一索引等值查询</h3><p>当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：<ul><li>当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会<strong>退化成「记录锁」</strong>。<li>当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会<strong>退化成「间隙锁」</strong></ul><p>如果是用二级索引（不管是不是非唯一索引，还是唯一索引）进行锁定读查询的时候，除了会对二级索引项加行级锁（如果是唯一索引的二级索引，加锁规则和主键索引的案例相同），而且还会对查询到的记录的主键索引项上加「记录锁」<p>可以通过 <code>select * from performance_schema.data_locks\G;</code> 这条语句，查看事务执行 SQL 过程中加了什么锁.<strong>加锁的对象是针对索引</strong>，因为这里查询语句扫描的 B+ 树是聚簇索引树，即主键索引树，所以是对主键索引加锁。将对应记录的主键索引加记录锁后，就意味着其他事务无法对该记录进行更新和删除操作了。<h3 id=唯一索引范围查询><a class=headerlink href=#唯一索引范围查询 title=唯一索引范围查询></a>唯一索引范围查询</h3><p>当唯一索引进行范围查询时，<strong>会对每一个扫描到的索引加 next-key 锁，然后如果遇到下面这些情况，会退化成记录锁或者间隙锁</strong>：<ul><li>情况一：针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 next-key 锁会<strong>退化成记录锁</strong>。<li>情况二：针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中：<ul><li>当条件值的记录不在表中，那么不管是「小于」还是「小于等于」条件的范围查询，<strong>扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁</strong>，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。<li>当条件值的记录在表中，如果是「小于」条件的范围查询，<strong>扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁</strong>，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；如果「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。</ul></ul><h3 id=非唯一索引等值查询><a class=headerlink href=#非唯一索引等值查询 title=非唯一索引等值查询></a>非唯一索引等值查询</h3><p>当我们用非唯一索引进行等值查询的时候，<strong>因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以在加锁时，同时会对这两个索引都加锁，但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁</strong>。<p>针对非唯一索引等值查询时，查询的记录存不存在，加锁的规则也会不同：<ul><li>当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是<strong>非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁</strong>。<li>当查询的记录「不存在」时，<strong>扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁</strong>。</ul><h3 id=非唯一索引范围查询><a class=headerlink href=#非唯一索引范围查询 title=非唯一索引范围查询></a>非唯一索引范围查询</h3><p><strong>非唯一索引范围查询，索引的 next-key lock 不会有退化为间隙锁和记录锁的情况</strong>，也就是非唯一索引进行范围查询时，对二级索引记录加锁都是加 next-key 锁。<h4 id=没有使用索引的加锁><a class=headerlink href=#没有使用索引的加锁 title=没有使用索引的加锁></a>没有使用索引的加锁</h4><p><strong>如果锁定读查询语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞</strong>。<p>不只是锁定读查询语句不加索引才会导致这种情况，update 和 delete 语句如果查询条件不加索引，那么由于扫描的方式是全表扫描，于是就会对每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表。<p>因此，<strong>在线上在执行 update、delete、select … for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了</strong>，这是挺严重的问题<p>InnoDB 存储引擎的默认事务隔离级别是「可重复读」，但是在这个隔离级别下，在多个事务并发的时候，会出现幻读的问题，所谓的幻读是指在同一事务下，连续执行两次同样的查询语句，第二次的查询语句可能会返回之前不存在的行。<p>因此 InnoDB 存储引擎自己实现了行锁，通过 next-key 锁（记录锁和间隙锁的组合）来锁住记录本身和记录之间的“间隙”，防止其他事务在这个记录之间插入新的记录，从而避免了幻读现象。当我们执行 update 语句时，实际上是会对记录加独占锁（X 锁）的，如果其他事务对持有独占锁的记录进行修改时是会被阻塞的。另外，这个锁并不是执行完 update 语句就会释放的，而是会等事务结束时才会释放。<p>在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁。加锁的位置准确的说，锁是加在索引上的而非行上。<p>在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁。加锁的位置准确的说，锁是加在索引上的而非行上。<p>比如，在 update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁，也就是只会给一行记录加锁。<p>因为事务 A的 update 语句中 where 条件没有索引列，触发了全表扫描，在扫描过程中会对索引加锁，所以全表扫描的场景下，所有记录都会被加锁，也就是这条 update 语句产生了 4 个记录锁和 5 个间隙锁，相当于锁住了全表。<strong>在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了</strong>。<p>可以设置sql_safe_updates=1,update 语句必须满足如下条件之一才能执行成功：<ul><li>使用 where，并且 where 条件中必须有索引列；<li>使用 limit；<li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</ul><p>delete 语句必须满足以下条件能执行成功：<ul><li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</ul><p>如果 where 条件带上了索引列，但是优化器最终扫描选择的是全表，而不是索引的话，我们可以<strong>使用 <code>force index([index_name])</code> 可以告诉优化器使用哪个索引</strong>，以此避免有几率锁全表带来的隐患。<h3 id=Mysql发生死锁><a class=headerlink href=#Mysql发生死锁 title=Mysql发生死锁></a>Mysql发生死锁</h3><p>I<strong>nnodb 引擎为了解决「可重复读」隔离级别下的幻读问题，就引出了 next-key 锁</strong>，它是记录锁和间隙锁的组合。<ul><li>Record Lock，记录锁，锁的是记录本身；<li>Gap Lock，间隙锁，锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。</ul><p>死锁的四个必要条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。<p>在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：<ul><li><p><strong>设置事务等待锁的超时时间</strong>。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 <code>innodb_lock_wait_timeout</code> 是用来设置超时时间的，默认值时 50 秒。</p> <p>当发生超时后，就出现下面这个提示：</p></ul><p><img alt=图片 data-src=https://cdn.xiaolincoding.com//mysql/other/c296c1889f0101d335699311b4ef20a8.png><ul><li><p><strong>开启主动死锁检测</strong>。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑，默认就开启。</p> <p>当检测到死锁后，就会出现下面这个提示：</p></ul><p><img alt=图片 data-src=https://cdn.xiaolincoding.com//mysql/other/f380ef357d065498d8d54ad07f145e09.png><p>上面这个两种策略是「当有死锁发生时」的避免方式。<p>我们可以回归业务的角度来预防死锁，对订单做幂等性校验的目的是为了保证不会出现重复的订单，那我们可以直接将 order_no 字段设置为唯一索引列，利用它的唯一性来保证订单表不会出现重复的订单，不过有一点不好的地方就是在我们插入一个已经存在的订单记录时就会抛出异常。<h1 id=内存><a class=headerlink href=#内存 title=内存></a>内存</h1><p>MySQL 的数据是存储在磁盘里的，但是也不能每次都从磁盘里面读取数据，这样性能是极差的。要想提升查询性能，加个缓存就行了嘛。所以，当数据从磁盘中取出后，缓存内存中，下次查询同样的数据的时候，直接从内存中读取。<p>为此，Innodb 存储引擎设计了一个<strong>缓冲池（*Buffer Pool*）</strong>，来提高数据库的读写性能。<p>innodb引擎使用了Buffer Pool提升读取和修改效率.有了缓冲池后：<ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。<li>当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。</ul><p>InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。<p>在 MySQL 启动的时候，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的<code>16KB</code>的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页</strong>。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。<p>所以，MySQL 刚启动的时候，你会观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小，这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，接着将虚拟地址和物理地址建立映射关系。<p>Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 undo 页，change buffer缓存、自适应哈希索引、锁信息等等。<p>为了更好的管理这些在 Buffer Pool 中的缓存页，InnoDB 为每一个缓存页都创建了一个<strong>控制块</strong>，控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等。<p><strong>控制块也是占有内存空间的，它是放在 Buffer Pool 的最前面</strong>，接着才是缓存页.<h3 id=管理空闲页><a class=headerlink href=#管理空闲页 title=管理空闲页></a>管理空闲页</h3><p>Buffer Pool 是一片连续的内存空间，当 MySQL 运行一段时间后，这片连续的内存空间中的缓存页既有空闲的，也有被使用的。为了避免遍历整个buffer pool,为了快速找到空闲的缓存页，可以使用链表结构，将空闲缓存页的「控制块」作为链表的节点，这个链表称为 <strong>Free 链表</strong>（空闲链表）<p>Free 链表上除了有控制块，还有一个头节点，该头节点包含链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息。<p>Free 链表节点是一个一个的控制块，而每个控制块包含着对应缓存页的地址，<strong>所以相当于 Free 链表节点都对应一个空闲的缓存页</strong>。<p>有了 Free 链表后，每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除。<h3 id=管理脏页><a class=headerlink href=#管理脏页 title=管理脏页></a>管理脏页</h3><p>设计 Buffer Pool 除了能提高读性能，还能提高写性能，也就是<strong>更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页</strong>标记为<strong>脏页</strong>，然后再由后台线程将脏页写入到磁盘。<p>那为了能快速知道哪些缓存页是脏的，于是就设计出 <strong>Flush 链表</strong>，它跟 Free 链表类似的，链表的节点也是控制块，区别在于 Flush 链表的元素都是脏页。有了 Flush 链表后，后台线程就可以遍历 Flush 链表，将脏页写入到磁盘。<h3 id=LRU链表提高缓冲命中率><a class=headerlink href=#LRU链表提高缓冲命中率 title=LRU链表提高缓冲命中率></a>LRU链表提高缓冲命中率</h3><p>Buffer Pool 的大小是有限的，对于一些频繁访问的数据我们希望可以一直留在 Buffer Pool 中，而一些很少访问的数据希望可以在某些时机可以淘汰掉，从而保证 Buffer Pool 不会因为满了而导致无法再缓存新的数据，同时还能保证常用数据留在 Buffer Pool 中。<p>要实现这个，最容易想到的就是 LRU（Least recently used）算法。<p>该算法的思路是，<strong>链表头部的节点是最近使用的，而链表末尾的节点是最久没被使用的。那么，当空间不够了，就淘汰最久没被使用的节点</strong>，从而腾出空间。<p>简单的 LRU 算法的实现思路是这样的：<ul><li>当访问的页在 Buffer Pool 里，就直接把该页对应的 LRU 链表节点移动到链表的头部。<li>当访问的页不在 Buffer Pool 里，除了要把页放入到 LRU 链表的头部，还要淘汰 LRU 链表末尾的节点。</ul><p>Buffer Pool 里有三种页和链表来管理数据。<ul><li>Free Page（空闲页），表示此页未被使用，位于 Free 链表；<li>Clean Page（干净页），表示此页已被使用，但是页面未发生修改，位于LRU 链表。<li>Dirty Page（脏页），表示此页「已被使用」且「已经被修改」，其数据和磁盘上的数据已经不一致。当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了干净页。脏页同时存在于 LRU 链表和 Flush 链表。</ul><h4 id=普通LRU链表缺点><a class=headerlink href=#普通LRU链表缺点 title=普通LRU链表缺点></a>普通LRU链表缺点</h4><ul><li>预读失效；</ul><p>程序是有空间局部性的，靠近当前被访问数据的数据，在未来很大概率会被访问到。<p>所以，MySQL 在加载数据页时，会提前把它相邻的数据页一并加载进来，目的是为了减少磁盘 IO。但是可能这些<strong>被提前加载进来的数据页，并没有被访问</strong>，相当于这个预读是白做了，这个就是<strong>预读失效</strong>。如果使用简单的 LRU 算法，就会把预读页放到 LRU 链表头部，而当 Buffer Pool空间不够的时候，还需要把末尾的页淘汰掉。<p>如果这些预读页如果一直不会被访问到，就会出现一个很奇怪的问题，不会被访问的预读页<p>要避免预读失效带来影响，最好就是<strong>让预读的页停留在 Buffer Pool 里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在 Buffer Pool 里的时间尽可能长</strong>。<p>MySQL 改进了 LRU 算法，将 LRU 划分了 2 个区域<strong>：</strong>old 区域 和 young 区域<strong>。young 区域在 LRU 链表的前半部分，old 区域则是在后半部分.old 区域占整个 LRU 链表长度的比例可以通过 <code>innodb_old_blocks_pct</code> 参数来设置，默认是 37.</strong>划分这两个区域后，<strong>预读的页就只需要加入到 old 区域的头部</strong>，当页被真正访问的时候，才将页插入 young 区域的头部。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。<ul><li>Buffer Pool 污染；</ul><p>当某一个 SQL 语句<strong>扫描了大量的数据</strong>时，在 Buffer Pool 空间比较有限的情况下，可能会将 <strong>Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了</strong>，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 <strong>Buffer Pool 污染</strong>。<p>注意， Buffer Pool 污染并不只是查询语句查询出了大量的数据才出现的问题，即使查询出来的结果集很小，也会造成 Buffer Pool 污染。<p>在一个数据量非常大的表，执行了这条语句：<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>select</span> <span class=operator>*</span> <span class=keyword>from</span> t_user <span class=keyword>where</span> name <span class=keyword>like</span> "%xiaolin%";</span><br></pre></table></figure><p>可能这个查询出来的结果就几条记录，但是由于这条语句会发生索引失效，所以这个查询过程是全表扫描的，接着会发生如下的过程：<ul><li>从磁盘读到的页加入到 LRU 链表的 old 区域头部；<li>当从页里读取行记录时，也就是页被访问的时候，就要将该页放到 young 区域头部；<li>接下来拿行记录的 name 字段和字符串 xiaolin 进行模糊匹配，如果符合条件，就加入到结果集里；<li>如此往复，直到扫描完表中的所有记录。</ul><p>经过这一番折腾，原本 young 区域的热点数据都会被替换掉。<p>像前面这种全表扫描的查询，很多缓冲页其实只会被访问一次，但是它却只因为被访问了一次而进入到 young 区域，从而导致热点数据被替换了。<p>LRU 链表中 young 区域就是热点数据，只要我们提高进入到 young 区域的门槛，就能有效地保证 young 区域里的热点数据不会被替换掉。<p>MySQL 是这样做的，进入到 young 区域条件增加了一个<strong>停留在 old 区域的时间判断</strong>。<p>具体是这样做的，在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：<ul><li>如果后续的访问时间与第一次访问的时间<strong>在某个时间间隔内</strong>，那么<strong>该缓存页就不会被从 old 区域移动到 young 区域的头部</strong>；<li>如果后续的访问时间与第一次访问的时间<strong>不在某个时间间隔内</strong>，那么<strong>该缓存页移动到 young 区域的头部</strong>；</ul><p>这个间隔时间是由 <code>innodb_old_blocks_time</code> 控制的，默认是 1000 ms。<p>也就说，<strong>只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部</strong>，这样就解决了 Buffer Pool 污染的问题 。<p>另外，MySQL 针对 young 区域其实做了一个优化，<strong>为了防止 young 区域节点频繁移动到头部。young 区域前面 1/4 被访问不会移动到链表头部，只有后面的 3/4被访问了才会</strong><p>也就是说上面全索引读取到的数据页放在old区后,对页中的数据进行访问的时候,<h3 id=脏页刷盘时机><a class=headerlink href=#脏页刷盘时机 title=脏页刷盘时机></a>脏页刷盘时机</h3><p>引入了 Buffer Pool 后，当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，但是磁盘中还是原数据。<p>因此，脏页需要被刷入磁盘，保证缓存和磁盘数据一致，但是若每次修改数据都刷入磁盘，则性能会很差，因此一般都会在一定时机进行批量刷盘。<p>可能大家担心，如果在脏页还没有来得及刷入到磁盘时，MySQL 宕机了，不就丢失数据了吗？<p>这个不用担心，InnoDB 的更新操作采用的是 Write Ahead Log 策略，即先写日志，再写入磁盘，通过 redo log 日志让 MySQL 拥有了崩溃恢复能力。<p>下面几种情况会触发脏页的刷新：<ul><li>当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；<li>Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；<li>MySQL 认为空闲时，后台线程会定期将适量的脏页刷入到磁盘；<li>MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；</ul><p>在我们开启了慢 SQL 监控后，如果你发现<strong>「偶尔」会出现一些用时稍长的 SQL</strong>，这可能是因为脏页在刷新到磁盘时可能会给数据库带来性能开销，导致数据库操作抖动。<p>如果间断出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小<p>Innodb 存储引擎设计了一个<strong>缓冲池（*Buffer Pool*）</strong>，来提高数据库的读写性能。<p>Buffer Pool 以页为单位缓冲数据，可以通过 <code>innodb_buffer_pool_size</code> 参数调整缓冲池的大小，默认是 128 M。<p>Innodb 通过三种链表来管理缓页：<ul><li>Free List （空闲页链表），管理空闲页；<li>Flush List （脏页链表），管理脏页；<li>LRU List，管理脏页+干净页，将最近且经常查询的数据缓存在其中，而不常查询的数据就淘汰出去。；</ul><p>InnoDB 对 LRU 做了一些优化，我们熟悉的 LRU 算法通常是将最近查询的数据放到 LRU 链表的头部，而 InnoDB 做 2 点优化：<ul><li>将 LRU 链表 分为<strong>young 和 old 两个区域</strong>，加入缓冲池的页，优先插入 old 区域；页被访问时，才进入 young 区域，目的是为了解决预读失效的问题。<li>当<strong>「页被访问」且「 old 区域停留时间超过 <code>innodb_old_blocks_time</code> 阈值（默认为1秒）」</strong>时，才会将页插入到 young 区域，否则还是插入到 old 区域，目的是为了解决批量数据访问，大量热数据淘汰的问题。</ul><p>可以通过调整 <code>innodb_old_blocks_pct</code> 参数，设置 young 区域和 old 区域比例。<p>在开启了慢 SQL 监控后，如果你发现「偶尔」会出现一些用时稍长的 SQL，这可<strong>因为脏页在刷新到磁盘时导致数据库性能抖动。如果在很短的时间出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小</strong>。<h1 id=其他问题><a class=headerlink href=#其他问题 title=其他问题></a>其他问题</h1><h2 id=删除表中部分数据为什么文件没有减小以及表重建><a class=headerlink href=#删除表中部分数据为什么文件没有减小以及表重建 title=删除表中部分数据为什么文件没有减小以及表重建></a>删除表中部分数据为什么文件没有减小以及表重建</h2><ol><li>共享表空间模式（<code>ibdata1</code>）</ol><p>如果你使用的是<strong>共享表空间模式</strong>（即 <code>innodb_file_per_table = OFF</code>），那么所有 InnoDB 表的数据、索引以及系统元数据都存放在一个或少数几个名为 <code>ibdataX</code> 的文件中。<ul><li><strong>工作原理</strong>：当你删除表或数据时，这些空间并不会被立即释放。它们会被标记为“可重用”，并留在 <code>ibdata1</code> 文件内部。<li><strong>为什么不缩小</strong>：<code>ibdata1</code> 文件只会不断增大，而不会自动收缩。这是为了避免频繁的系统调用和 I/O 开销，因为收缩文件是一个复杂且昂贵的操作。<li><strong>如何回收空间</strong>：要回收这部分空间，你需要执行一个非常繁琐的操作：<ol><li>备份所有数据库。<li>删除所有数据文件（包括 <code>ibdata*</code> 文件）。<li>重启 MySQL，让它重新创建新的、干净的 <code>ibdata1</code> 文件。<li>恢复所有备份</ol></ul><hr><p>当你删除数据库中的表时，如果发现数据库文件大小没有变化，这通常是因为 MySQL 的存储引擎（尤其是 <strong>InnoDB</strong>）没有立即将释放的空间归还给操作系统。<ol><li>共享表空间模式（<code>ibdata1</code>）</ol><p>如果你使用的是<strong>共享表空间模式</strong>（即 <code>innodb_file_per_table = OFF</code>），那么所有 InnoDB 表的数据、索引以及系统元数据都存放在一个或少数几个名为 <code>ibdataX</code> 的文件中。<ul><li><strong>工作原理</strong>：当你删除表或数据时，这些空间并不会被立即释放。它们会被标记为“可重用”，并留在 <code>ibdata1</code> 文件内部。<li><strong>为什么不缩小</strong>：<code>ibdata1</code> 文件只会不断增大，而不会自动收缩。这是为了避免频繁的系统调用和 I/O 开销，因为收缩文件是一个复杂且昂贵的操作。<li><strong>如何回收空间</strong>：要回收这部分空间，你需要执行一个非常繁琐的操作：<ol><li>备份所有数据库。<li>删除所有数据文件（包括 <code>ibdata*</code> 文件）。<li>重启 MySQL，让它重新创建新的、干净的 <code>ibdata1</code> 文件。<li>恢复所有备份。</ol></ul><ol><li>独占表空间模式（<code>.ibd</code>）</ol><p>如果你使用的是<strong>独占表空间模式</strong>（即 <code>innodb_file_per_table = ON</code>），那么每个 InnoDB 表都有一个独立的 <code>.ibd</code> 文件。<ul><li><p><strong>工作原理</strong>：当你删除一张表时，MySQL 会<strong>直接删除</strong>对应的 <code>.ibd</code> 文件。这种情况下，磁盘空间会立即被操作系统回收。</p><li><p><strong>为什么有时也不缩小</strong>：</p> <ul><li><p><strong>碎片化</strong>：如果你只是删除了表中的部分数据（例如 <code>DELETE FROM table;</code>），而没有删除表本身，那么这些空间同样会被标记为“可重用”。虽然这些空间位于独立的 <code>.ibd</code> 文件中，但文件本身并不会自动缩小。</p><li><p><strong>如何回收空间</strong>：在这种情况下，你需要对表进行<strong>重建（Rebuilding）</strong>，才能真正回收空间。你可以使用以下命令：</p> <figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>ALTER</span> <span class=keyword>TABLE</span> your_table_name ENGINE<span class=operator>=</span>InnoDB;</span><br></pre></table></figure> <p>或者</p> <figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>OPTIMIZE <span class=keyword>TABLE</span> your_table_name;</span><br></pre></table></figure> <p>这些命令会重新整理表数据，清除碎片，从而减小 <code>.ibd</code> 文件的大小。</p></ul></ul><p>数据库文件大小没有变化，最常见的原因是文件<strong>碎片化</strong>。<ul><li>如果你使用的是<strong>共享表空间</strong>，那么即使删除了表，空间也无法自动回收。这是该模式最大的缺点。<li>如果你使用的是<strong>独占表空间</strong>，那么删除表文件本身会回收空间。但如果你只是删除了数据，则需要<strong>重建表</strong>才能回收碎片化空间。</ul><hr><p>表重建（Table Rebuilding）是一种数据库操作，指的是通过<strong>重新创建一张新的表</strong>来替换原有的表，以达到优化存储结构、回收空间和提升性能的目的。<h3 id=为什么需要表重建？><a class=headerlink href=#为什么需要表重建？ title=为什么需要表重建？></a>为什么需要表重建？</h3><p>在数据库的日常操作中，尤其是对于 InnoDB 存储引擎，随着时间的推移，表数据会因为频繁的增删改（<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>）操作而产生<strong>碎片（Fragmentation）</strong>。<ul><li><strong>删除操作</strong>：当你删除一行数据时，它占据的空间并不会立即被操作系统回收，而是被标记为“可重用”。这些“洞”散布在数据文件中。<li><strong>更新操作</strong>：当 <code>UPDATE</code> 导致数据行变长时，新数据可能无法存放在原来的位置，需要移动到新的位置，并在原位置留下碎片。</ul><p>这种碎片化会导致：<ol><li><strong>磁盘空间浪费</strong>：被标记为可重用的空间无法被操作系统回收，导致数据文件持续增大。<li><strong>I/O 效率降低</strong>：数据不再是连续存储，查询时需要更多的磁盘 I/O 操作来获取数据，影响查询性能。</ol><p>表重建的本质是一个“<strong>先复制，后替换</strong>”的过程。它通常包含以下步骤：<ol><li><strong>创建新表</strong>：在后台创建一个新的、结构相同的空表。<li><strong>复制数据</strong>：将旧表中的数据以连续、紧凑的方式复制到新表中。在这个过程中，所有碎片都会被清除。<br><strong>Copy data</strong>: Copy data from an old table to a new table in a continuous, compact manner. In this process, all debris is removed.<li><strong>重新构建索引</strong>：在新表中，所有索引都会被重新构建，同样是连续、紧凑的。<li><strong>原子替换</strong>：用一个原子的操作（例如，通过 <code>RENAME TABLE</code>），将旧表和新表进行互换。新表接管旧表的名称和所有权，旧表被删除。</ol><p>这个过程会暂时占用额外的磁盘空间，因为新旧两份表的数据会同时存在。<h3 id=如何进行表重建？><a class=headerlink href=#如何进行表重建？ title=如何进行表重建？></a>如何进行表重建？</h3><p>在 MySQL 中，进行表重建有几种常见的方法：<ol><li><code>OPTIMIZE TABLE</code></ol><p>这是最简单、最直接的表重建方式。<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>OPTIMIZE <span class=keyword>TABLE</span> your_table_name;</span><br></pre></table></figure><ul><li><strong>工作原理</strong>：对于 InnoDB 引擎，<code>OPTIMIZE TABLE</code> 实际上就是执行了一次表重建操作。它会重新整理数据，回收碎片空间。<li><strong>缺点</strong>：在执行期间，表会被<strong>锁定</strong>，导致无法进行写操作（<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>），在高并发场景下会影响业务。</ul><ol><li><code>ALTER TABLE</code></ol><p><code>ALTER TABLE</code> 语句也可以用来触发表重建，通常会与 <code>ENGINE=InnoDB</code> 结合使用。<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>ALTER</span> <span class=keyword>TABLE</span> your_table_name ENGINE<span class=operator>=</span>InnoDB;</span><br></pre></table></figure><ul><li><strong>工作原理</strong>：即使你没有修改表的存储引擎，执行这条命令也会强制 MySQL 以新的、紧凑的格式重新创建表，达到表重建的目的。<li><strong>缺点</strong>：同样会锁定表，影响并发。</ul><ol><li>在线表重建（Online DDL）</ol><p>从 MySQL 5.6 开始，InnoDB 引入了<strong>在线 DDL（Online DDL）</strong> 功能，这是一种<strong>不锁定表、不影响读写操作的表重建方式</strong>。<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>ALTER</span> <span class=keyword>TABLE</span> your_table_name ENGINE<span class=operator>=</span>InnoDB;</span><br></pre></table></figure><ul><li><strong>工作原理</strong>：MySQL 会在后台创建一个临时表并复制数据。在这个过程中，它会记录所有对旧表的修改，并在复制完成后，将这些修改应用到新表上，最后原子性地进行表替换。整个过程几乎不会中断业务。<li><strong>优点</strong>：<strong>不阻塞</strong>表的读写操作，对高并发业务友好。<li><strong>缺点</strong>：这个过程会消耗额外的 CPU 和 I/O 资源，并且可能会在表替换的瞬间有短暂的锁等待。</ul><h2 id=长事务问题以及如何查询长事务><a class=headerlink href=#长事务问题以及如何查询长事务 title=长事务问题以及如何查询长事务></a>长事务问题以及如何查询长事务</h2><p>长事务是指那些持续时间较长、长时间未提交的事务。它们通常被认为是数据库性能的“杀手”，因为它会占用大量资源，影响系统的稳定性和并发能力。<p>长事务引发的问题<ol><li><strong>资源占用与阻塞</strong>：长事务在执行期间会持有锁资源，这会阻塞其他需要访问相同数据或资源的事务，导致大量锁等待。如果一个长事务占用的锁是关键资源，整个数据库的吞吐量都会急剧下降。<li><strong>Undo Log 空间膨胀</strong>：事务在修改数据时，会将旧数据版本写入 <strong>Undo Log</strong>。Undo Log 的空间只有在事务提交后才能被清理。长事务会长时间占用 Undo Log，导致 Undo Log 文件持续增大，占用大量的磁盘空间。<li><strong>影响 MVCC 性能</strong>：长事务会长时间持有 <strong>Read View</strong>。其他事务在进行快照读（Snapshot Read）时，如果需要读取早于该长事务开启时的数据，就需要沿着 Undo Log 的版本链进行回溯，这会增加大量的 I/O 开销和 CPU 消耗。<li><p><strong>死锁风险增加</strong>：长事务由于持有锁的时间长，与其他事务发生循环等待的几率也会增加，从而导致死锁。</p><li><p>使用 <code>information_schema</code> 数据库</p></ol><p><code>information_schema</code> 提供了关于数据库服务器的元数据信息，我们可以通过查询其中的 <code>innodb_trx</code> 表来获取当前所有正在运行的事务信息。<figure class="highlight n1ql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>SELECT</span></span><br><span class=line>    trx_id,</span><br><span class=line>    trx_state,</span><br><span class=line>    trx_started,</span><br><span class=line>    trx_mysql_thread_id,</span><br><span class=line>    trx_query,</span><br><span class=line>    trx_operation_state,</span><br><span class=line>    (UNIX_TIMESTAMP() - UNIX_TIMESTAMP(trx_started)) <span class=keyword>AS</span> trx_running_time</span><br><span class=line><span class=keyword>FROM</span></span><br><span class=line>    information_schema.innodb_trx</span><br><span class=line><span class=keyword>WHERE</span></span><br><span class=line>    trx_state = <span class=string>'RUNNING'</span></span><br><span class=line><span class=keyword>ORDER</span> <span class=keyword>BY</span></span><br><span class=line>    trx_running_time <span class=keyword>DESC</span>;</span><br></pre></table></figure><ul><li><strong><code>trx_id</code></strong>: 事务的唯一ID。<li><strong><code>trx_started</code></strong>: 事务开始的时间。<li><strong><code>trx_mysql_thread_id</code></strong>: 事务所在的 MySQL 线程ID，可以配合 <code>SHOW PROCESSLIST</code> 使用。<li><strong><code>trx_query</code></strong>: 事务正在执行的 SQL 语句。<li><strong><code>trx_running_time</code></strong>: 事务已经运行的时长（秒），这是判断长事务的关键指标。</ul><p><strong>使用 <code>performance_schema</code> 数据库</strong><p><code>performance_schema</code> 提供了更详细和实时的性能数据，包括事务和会话信息。<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>SELECT</span></span><br><span class=line>    t.thread_id,</span><br><span class=line>    t.processlist_id,</span><br><span class=line>    t.processlist_user,</span><br><span class=line>    t.processlist_host,</span><br><span class=line>    t.processlist_db,</span><br><span class=line>    p.event_name <span class=keyword>AS</span> lock_type,</span><br><span class=line>    p.duration <span class=keyword>AS</span> lock_duration</span><br><span class=line><span class=keyword>FROM</span></span><br><span class=line>    performance_schema.events_transactions_current t</span><br><span class=line><span class=keyword>JOIN</span></span><br><span class=line>    performance_schema.events_waits_current p</span><br><span class=line>    <span class=keyword>ON</span> t.thread_id <span class=operator>=</span> p.thread_id</span><br><span class=line><span class=keyword>WHERE</span></span><br><span class=line>    t.state <span class=operator>=</span> <span class=string>'ACTIVE'</span></span><br><span class=line><span class=keyword>ORDER</span> <span class=keyword>BY</span></span><br><span class=line>    lock_duration <span class=keyword>DESC</span>;</span><br></pre></table></figure><ul><li><strong><code>events_transactions_current</code></strong>: 提供当前活跃事务的信息。<li><strong><code>events_waits_current</code></strong>: 提供线程正在等待的事件（例如锁等待）信息，可以帮助你定位长事务的原因。</ul><ol><li>使用 <code>SHOW PROCESSLIST</code> 命令</ol><p><code>SHOW PROCESSLIST</code> 可以快速查看所有正在运行的线程，这对于识别长事务非常有帮助。<figure class="highlight pgsql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>SHOW</span> <span class=keyword>FULL</span> PROCESSLIST;</span><br></pre></table></figure><ul><li><strong><code>ID</code></strong>: 线程ID，对应 <code>innodb_trx</code> 表中的 <code>trx_mysql_thread_id</code>。<li><strong><code>Time</code></strong>: 线程状态持续的时间（秒），如果这个值很大，可能是一个长事务。<li><strong><code>State</code></strong>: 线程的当前状态，例如 <code>Locked</code>、<code>Waiting for table metadata lock</code> 等状态可能表明有长事务在阻塞其他操作。<li><strong><code>Info</code></strong>: 线程正在执行的 SQL 语句。</ul><h2 id=双写缓冲与change-buffer><a title="双写缓冲与change buffer" class=headerlink href=#双写缓冲与change-buffer></a>双写缓冲与change buffer</h2><p><strong>核心目的</strong>：保证数据页的<strong>原子性写入</strong>，解决<strong>部分写失败</strong>（Partial Write Failure）问题。<p>在 InnoDB 中，数据最终是存储在磁盘的数据文件中的。一个数据页（通常为 16KB）写入磁盘不是一个原子操作，而是分多次进行的。如果在写入过程中，比如只写了 4KB，而数据库突然崩溃（如断电），就会导致数据页损坏。<p>双写缓冲机制就是为了防止这种情况：<ol><li><strong>第一次写</strong>：当 InnoDB 准备将脏页（Dirty Page，内存中被修改的数据页）刷新到磁盘时，它不会直接写入数据文件，而是先写入到<strong>双写缓冲区</strong>。这个缓冲区是一个位于系统表空间 <code>ibdata1</code> 中的连续存储区域。<li><strong>第二次写</strong>：双写缓冲区中的数据被一次性地刷新到磁盘。<li><strong>最终写</strong>：如果双写缓冲区中的数据写入成功，InnoDB 才会将脏页真正写入到数据文件的正确位置。</ol><p><strong>崩溃恢复</strong><p>如果数据库在写入过程中崩溃，InnoDB 会进行以下恢复操作：<ul><li><strong>如果最终写失败</strong>：数据库重启后，会检查双写缓冲区中的数据和数据文件中的数据。如果发现数据文件中的数据页损坏，它会从双写缓冲区中找到完整的数据页副本，将其恢复到数据文件中。<li><strong>如果第一次写失败</strong>：双写缓冲区中的数据也未写入，不会影响数据文件。</ul><p>双写缓冲牺牲了一些性能（多了一次写操作），但极大地增强了数据页写入的<strong>可靠性</strong>。<p><strong>Change Buffer（变更缓冲）</strong><p><strong>核心目的</strong>：提高数据库的<strong>写入性能</strong>，尤其是针对<strong>非唯一二级索引</strong>的插入、更新和删除操作。<p>当对一个表进行 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 操作时，如果涉及修改非唯一二级索引，InnoDB 的默认行为是：<ol><li>修改内存中的数据页。<li>修改内存中的非唯一二级索引页。<li>将这两个脏页异步刷新到磁盘。</ol><p>但如果非唯一二级索引页<strong>不在内存中</strong>，InnoDB 必须先从磁盘将索引页加载到内存，然后再进行修改。这个过程会产生大量的<strong>随机 I/O</strong>，极大地影响性能。<p>Change Buffer 的作用就是：<ol><li>当<strong>需要修改的非唯一二级索引页不在内存中时，InnoDB 不会立即去磁盘加载，而是将这个“变更操作”记录到 Change Buffer </strong>中**。<li>Change Buffer 中的数据会在后台（或在数据库关闭时）被<strong>合并（Merge）</strong>到真正的索引页中。</ol><p>Change Buffer 中的内容是持久化的。数据库重启后，InnoDB 会执行<strong>恢复</strong>操作，将 Change Buffer 中的变更应用到磁盘上的索引页。<p>Change Buffer 主要适用于<strong>写多读少</strong>的业务场景，比如日志系统、电商秒杀系统等。因为这些场景下，非唯一二级索引的写入操作远多于读取。<p><strong>注意</strong>：<ul><li>Change Buffer 只对<strong>非唯一二级索引</strong>有效。对于主键索引和唯一二级索引，由于需要检查唯一性，InnoDB 必须立即将对应的索引页加载到内存中，无法使用 Change Buffer。<li>Change Buffer 在<strong>读多写少</strong>的场景下可能适得其反，因为大量的读取操作会频繁触发 Change Buffer 的合并操作，反而增加了开销。</ul><h2 id=临时表与sort-buffer><a title="临时表与sort buffer" class=headerlink href=#临时表与sort-buffer></a>临时表与sort buffer</h2><p>MySQL 优化器在执行某些复杂查询时，为了提高效率，会在内部自动创建和管理临时表。<p><strong>触发条件</strong>：<ul><li><strong><code>GROUP BY</code> 或 <code>ORDER BY</code></strong>：当这些操作的列无法被索引覆盖时。<li><strong><code>UNION</code></strong>：在执行 <code>UNION</code> 操作时。<li><strong>子查询</strong>：在处理某些复杂的子查询时。<li><strong><code>DISTINCT</code></strong>：在对大量数据进行去重时。</ul><p><strong>性能开销</strong>：临时表会占用磁盘空间和内存。如果临时表数据量非常大，可能会导致 I/O 频繁，影响性能。<p><strong>内存 vs. 磁盘</strong>：MySQL 会优先在内存中（<code>tmp_table_size</code> 和 <code>max_heap_table_size</code> 变量控制）创建内部临时表。如果数据量超过阈值，它会自动转换为磁盘上的 InnoDB 或 MyISAM 表，这会带来额外的 I/O 开销。<p><strong><code>innodb_temp_data_file_path</code></strong>：在 InnoDB 存储引擎中，所有的用户创建的临时表和内部临时表数据都存放在一个共享的临时表空间中。你可以在 MySQL 5.7+ 中通过这个参数配置临时表空间文件。<p><code>Sort Buffer</code>（排序缓冲区）是 MySQL 在内存中为每个<strong>需要排序的线程</strong>分配的一块缓冲区。它的主要作用是存储查询结果，然后在内存中进行排序。<p>当 MySQL 执行一个查询时，如果需要对结果集进行排序（例如使用了 <code>ORDER BY</code> 或 <code>GROUP BY</code>），并且无法通过索引来完成这个排序操作时，就会使用 <code>Sort Buffer</code>。<p><code>Using filesort</code> 是一个明显的性能警示，它告诉我们：<ol><li>查询使用了 <code>ORDER BY</code> 或 <code>GROUP BY</code>。<li>MySQL 无法利用索引来完成排序。<li>查询将使用 <code>Sort Buffer</code>，并且可能需要进行磁盘上的外部排序。</ol><h2 id=慢查询优化><a class=headerlink href=#慢查询优化 title=慢查询优化></a>慢查询优化</h2><p>致慢查询的原因有很多，但归根结底，都可以归结为两个核心问题：<strong>数据量大</strong>和<strong>数据访问效率低</strong>。<ol><li>索引问题</ol><p>这是最常见、最核心的慢查询原因。<ul><li><strong>缺少索引：</strong> 当 <code>WHERE</code> 子句中的条件列没有索引时，数据库为了找到符合条件的行，不得不进行<strong>全表扫描（Full Table Scan）</strong>。这意味着它会逐行检查表中的每一条记录，直到找到所有匹配的行，这在高数据量下是灾难性的。<li><strong>索引失效：</strong> 即使创建了索引，也可能因为一些不当的 SQL 写法导致索引无法被使用。例如：<ul><li>在索引列上使用函数：<code>WHERE YEAR(order_date) = 2023</code>。<li>在索引列上进行类型转换：<code>WHERE user_id = '12345'</code>（<code>user_id</code> 是整型）。<li>模糊查询以 <code>%</code> 开头：<code>WHERE name LIKE '%john%'</code>。</ul><li><strong>选择了错误的索引：</strong> 数据库优化器可能会因为统计信息不准确等原因，选择了不是最优的索引，导致查询性能不佳。</ul><ol><li>SQL 语句本身的问题</ol><ul><li><strong>复杂的 JOIN：</strong> 当一个查询涉及到多个表的 <code>JOIN</code> 操作时，如果没有正确的索引和优化，可能会生成非常大的中间结果集，导致查询效率低下。<li><strong>大批量的数据返回：</strong> <code>SELECT *</code> 这种查询如果返回大量不必要的列，会增加网络传输和内存开销。<li><strong>不合理的 <code>ORDER BY</code> 和 <code>GROUP BY</code>：</strong> 如果 <code>ORDER BY</code> 或 <code>GROUP BY</code> 的列没有索引，数据库需要对结果集进行额外的<strong>文件排序（Using filesort）</strong> 或创建<strong>临时表（Using temporary）</strong>，这会消耗大量的 CPU 和内存资源。</ul><ol><li>数据表和数据库设计问题</ol><ul><li><strong>表结构不合理：</strong> 如果一个表设计得非常“宽”（即包含太多列），或者字段类型选择不当（例如，使用 <code>VARCHAR</code> 存储日期），都会影响查询性能。<li><strong>没有进行分库分表：</strong> 当单表数据量达到千万甚至上亿级别时，即使有索引，也会因为索引树过大而影响查询性能。此时，分库分表是解决性能瓶颈的有效手段。</ul><ol><li>数据库配置和硬件问题</ol><ul><li><strong>数据库配置不当：</strong> 比如 <code>innodb_buffer_pool_size</code> 设置过小，导致数据库无法在内存中缓存足够的热点数据，频繁地进行磁盘 I/O。<li><strong>硬件瓶颈：</strong> 磁盘 I/O 速度慢、CPU 核心数不足、内存不足等硬件问题，都会直接导致查询变慢。</ul><ol><li>并发与锁问题</ol><ul><li><strong>锁等待：</strong> 如果一个查询需要访问的行被其他长事务锁住，它就会进入等待状态，导致查询变慢。<li><strong>死锁：</strong> 在复杂的并发场景下，如果发生死锁，事务会被回滚，同样会影响性能和用户体验</ul><ol><li>开启慢查询日志</ol><p>首先，你需要让 MySQL 记录下这些慢查询。慢查询日志（Slow Query Log）是 MySQL 自带的诊断工具，可以记录所有执行时间超过 <code>long_query_time</code> 的 SQL 语句。<p>在 <code>my.cnf</code> 或 <code>my.ini</code> 配置文件中添加或修改以下配置：<figure class="highlight ini"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=section>[mysqld]</span></span><br><span class=line><span class=comment># 开启慢查询日志</span></span><br><span class=line><span class=attr>slow_query_log</span> = <span class=literal>ON</span></span><br><span class=line></span><br><span class=line><span class=comment># 设置慢查询日志文件路径</span></span><br><span class=line><span class=attr>slow_query_log_file</span> = /var/lib/mysql/mysql-slow.log</span><br><span class=line></span><br><span class=line><span class=comment># 设置慢查询阈值（单位：秒），这里设置为 1 秒</span></span><br><span class=line><span class=attr>long_query_time</span> = <span class=number>1</span></span><br><span class=line></span><br><span class=line><span class=comment># 记录没有使用索引的查询</span></span><br><span class=line><span class=attr>log_queries_not_using_indexes</span> = <span class=literal>ON</span></span><br></pre></table></figure><p>配置完成后，重启 MySQL 服务，它就会开始记录慢查询。<p>2.有了慢查询日志后，你需要工具来分析它。日志文件通常包含大量信息，直接阅读非常困难。<strong>使用 <code>mysqldumpslow</code></strong>：MySQL 自带的工具，可以对慢查询日志进行汇总和排序，帮助你快速找出最频繁、平均执行时间最长或锁定时间最长的慢查询。<p>3.当你找到一个需要优化的慢查询后，下一步就是分析它的执行计划。<code>EXPLAIN</code> 命令可以模拟优化器执行 SQL 查询，并告诉你数据库将如何处理这个查询，包括使用了哪些索引、扫描了多少行、是否使用了临时表等。<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>EXPLAIN <span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> age <span class=operator>></span> <span class=number>25</span> <span class=keyword>AND</span> city <span class=operator>=</span> <span class=string>'Shanghai'</span>;</span><br></pre></table></figure><p>重点关注 <code>EXPLAIN</code> 结果中的几个关键字段：<ul><li><strong><code>type</code></strong>：这是最重要的指标，它表示 MySQL 查找数据的方式。<ul><li><strong><code>const</code></strong>、<strong><code>eq_ref</code></strong>：非常高效，通常是主键或唯一索引查找。<li><strong><code>ref</code></strong>、<strong><code>range</code></strong>：较好，使用了索引。<li><strong><code>index</code></strong>：全索引扫描，通常比全表扫描好。<li><strong><code>ALL</code></strong>：全表扫描，性能最差，需要重点优化。</ul><li><strong><code>key</code></strong>：实际使用的索引。如果为 <code>NULL</code>，表示没有使用索引。<li><strong><code>rows</code></strong>：MySQL 估计要扫描的行数，值越小越好。<li><strong><code>Extra</code></strong>：额外信息，其中一些值需要特别注意：<ul><li><strong><code>Using filesort</code></strong>：表示需要额外的排序操作，通常可以创建合适的索引来避免。<li><strong><code>Using temporary</code></strong>：表示需要创建临时表，这通常是性能瓶颈。</ul></ul><p>根据 <code>EXPLAIN</code> 的分析结果，可以采取以下策略进行优化：<ul><li><p><strong>创建或优化索引</strong>：</p> <ul><li>为 <code>WHERE</code>、<code>ORDER BY</code>、<code>GROUP BY</code> 子句中使用的列创建索引。<li>使用<strong>联合索引</strong>来覆盖查询中的多个列，避免 <code>Using filesort</code> 和全表扫描。<li><strong>覆盖索引（Covering Index）</strong>：如果查询的所有列都包含在索引中，MySQL 可以直接从索引中返回数据，而无需回表（访问聚簇索引），这会显著提高性能。</ul><li><p><strong>优化 SQL 语句</strong>：</p> <ul><li><strong>避免全表扫描</strong>：检查 <code>EXPLAIN</code> 的 <code>type</code> 字段，确保没有 <code>ALL</code>。<li><strong>优化 <code>JOIN</code></strong>：确保 <code>JOIN</code> 语句的连接条件上有索引，并且小表驱动大表。<li><strong>避免使用函数</strong>：不在索引列上使用函数（例如 <code>WHERE YEAR(date_column) = 2023</code>），这会导致索引失效。<li><strong>使用 <code>LIMIT</code></strong>：在查询只需要部分结果时，使用 <code>LIMIT</code> 限制返回行数。</ul><li><p><strong>更改数据库或表结构</strong>：</p> <ul><li><strong>分库分表</strong>：当单表数据量过大时，考虑垂直拆分（按列）或水平拆分（按行）。<li><strong>冗余字段</strong>：适当增加冗余字段，减少 <code>JOIN</code> 操作。</ul><li><p><strong>硬件和系统层面</strong>：</p> <ul><li><strong>增加缓存</strong>：使用 Redis、Memcached 等缓存系统来缓存热点数据，减少数据库查询压力。<li><strong>升级硬件</strong>：升级 CPU、内存或使用更快的 SSD 硬盘。</ul> <p><strong>1.慢查询的解决方案</strong></p> <p>解决MySQL慢查询问题的方案可以按照资源消耗从少到多的顺序排列，像金字塔一样逐步提升。以下是从资源消耗少到多的常见优化方式：</p> <p>(1)SQL优化</p> <p>合理使用索引：确保查询字段使用了索引。对于WHERE、JOIN、ORDER BY、GROUP BY等操作的字段，应该创建相应的索引。</p> <p>(2)索引优化</p> <p>创建复合索引：对于多个字段联合查询，创建复合索引（注意索引顺序）。</p> <p>删除冗余索引：定期清理无用索引，减少索引维护的负担。</p> <p>避免索引覆盖不必要的字段：有时候一个大字段（如TEXT或BLOB）放入索引会增加存储开销，应该避免。</p> <p>更新统计信息：定期更新表的统计信息，帮助优化器选择更合适的执行计划。</p> <p>(3)数据库配置优化</p> <p>调整缓存设置：增加innodb_buffer_pool_size，确保更多的数据能够缓存到内存中。调整query_cache_size，如果适用，启用查询缓存（对于更新频繁的应用不推荐）。</p> <p>调整连接设置：如增加max_connections，但要注意数据库承载能力。</p> <p>调整临时表大小：如果临时表经常写入磁盘，可以通过调整tmp_table_size和max_heap_table_size来避免此问题。</p> <p>增加排序缓存：增加sort_buffer_size来提高ORDER BY和GROUP BY操作的效率。</p> <p>(4)架构优化</p> <p>分库分表：对于单表数据量过大的情况，使用分库分表策略，将数据分散到不同的数据库或表中，减少每个查询的负载。</p> <p>读写分离：通过主从复制，减少主库的查询压力，读请求分发到从库。</p> <p>数据库集群：使用分布式数据库系统，解决单机性能瓶颈。</p> <p>(5)硬件升级</p> <p>增加内存：通过增加内存，提高缓存命中率，减少磁盘IO。</p> <p>更换更快的磁盘：使用SSD代替传统的硬盘，提升磁盘IO性能。</p> <p>增加CPU处理能力：提升CPU性能，减少数据库查询的CPU瓶颈。</p></ul><h1 id=Mybatis><a class=headerlink href=#Mybatis title=Mybatis></a>Mybatis</h1><h3 id=与传统的JDBC相比，MyBatis的优点><a class=headerlink href=#与传统的JDBC相比，MyBatis的优点 title=与传统的JDBC相比，MyBatis的优点></a>与传统的JDBC相比，MyBatis的优点</h3><ul><li>基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任 何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重用。<li>与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不 需要手动开关连接；<li>很好的与各种数据库兼容，因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持。<li>能够与 Spring 很好的集成，开发效率高<li>提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射 标签，支持对象关系组件维护。</ul><p>MyBatis 在 <strong>SQL 灵活性</strong>、<strong>动态 SQL 支持</strong>、<strong>结果集映射</strong>和<strong>与 Spring 整合</strong>方面表现卓越，尤其适合重视 SQL 可控性的项目。<ul><li>SQL 与代码解耦，灵活可控：MyBatis 允许开发者直接编写和优化 SQL，相比全自动 ORM（如 Hibernate），MyBatis 让开发者明确知道每条 SQL 的执行逻辑，便于性能调优。<li>动态 SQL 的强大支持：比如可以动态拼接SQL，通过 <code>&LTif></code>, <code>&LTchoose></code>, <code>&LTforeach></code> 等标签动态生成 SQL，避免 Java 代码中繁琐的字符串拼接。<li>自动映射与自定义映射结合：自动将查询结果字段名与对象属性名匹配（如驼峰转换）。<li>插件扩展机制：可编写插件拦截 SQL 执行过程，实现分页、性能监控、SQL 改写等通用逻辑。<li>与 Spring 生态无缝集成：通过 <code>@MapperScan</code> 快速扫描 Mapper 接口，结合 Spring 事务管理，配置简洁高效。</ul><h3 id=Mybatis里的-和-的区别><a title="Mybatis里的 # 和 $ 的区别" class=headerlink href=#Mybatis里的-和-的区别></a>Mybatis里的 # 和 $ 的区别</h3><ul><li>Mybatis 在处理 #{} 时，会创建预编译的 SQL 语句，将 SQL 中的 #{} 替换为 ? 号，在执行 SQL 时会为预编译 SQL 中的占位符（?）赋值，调用 PreparedStatement 的 set 方法来赋值，预编译的 SQL 语句执行效率高，并且可以防止SQL 注入，提供更高的安全性，适合传递参数值。<li>Mybatis 在处理 ${} 时，只是创建普通的 SQL 语句，然后在执行 SQL 语句时 MyBatis 将参数直接拼入到 SQL 里，不能防止 SQL 注入，因为参数直接拼接到 SQL 语句中，如果参数未经过验证、过滤，可能会导致安全问题。</ul><link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script></div><div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a href=https://www.sekyoro.top/2025/07/01/mysql%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E4%BA%8Emysql%E5%AE%9E%E6%88%9845%E8%AE%B2/ title=mysql学习:基于mysql实战45讲>https://www.sekyoro.top/2025/07/01/mysql学习-基于mysql实战45讲/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div><footer class=post-footer><div class=post-tags><a href=/tags/mysql/ rel=tag><i class="fa fa-tag"></i> mysql</a></div><div class=post-nav><div class=post-nav-item><a href=/2025/05/12/%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%86%E6%9E%90/ rel=prev title=文件分片上传分析> <i class="fa fa-chevron-left"></i> 文件分片上传分析 </a></div><div class=post-nav-item><a title="coding agent in real world" href=/2025/07/01/coding-agent-in-real-world/ rel=next> coding agent in real world <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div><!-- 评论区 --><div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%9F%BA%E7%A1%80><span class=nav-number>1.</span> <span class=nav-text>基础</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84><span class=nav-number>1.1.</span> <span class=nav-text>基础架构</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%BF%9E%E6%8E%A5%E5%99%A8><span class=nav-number>1.1.1.</span> <span class=nav-text>连接器</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98><span class=nav-number>1.1.1.1.</span> <span class=nav-text>查询缓存</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%88%86%E6%9E%90%E5%99%A8><span class=nav-number>1.1.2.</span> <span class=nav-text>分析器</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BC%98%E5%8C%96%E5%99%A8><span class=nav-number>1.1.3.</span> <span class=nav-text>优化器</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%89%A7%E8%A1%8C%E5%99%A8><span class=nav-number>1.1.4.</span> <span class=nav-text>执行器</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%B5%81%E7%A8%8B><span class=nav-number>1.2.</span> <span class=nav-text>执行查询语句流程</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%B8%80%E8%A1%8C%E8%AE%B0%E5%BD%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84><span class=nav-number>1.3.</span> <span class=nav-text>一行记录是如何存储的</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%A1%8C%E6%A0%BC%E5%BC%8F><span class=nav-number>1.3.1.</span> <span class=nav-text>行格式</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AE%B0%E5%BD%95%E7%9A%84%E9%A2%9D%E5%A4%96%E4%BF%A1%E6%81%AF><span class=nav-number>1.3.2.</span> <span class=nav-text>记录的额外信息</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E5%88%97%E8%A1%A8><span class=nav-number>1.3.2.1.</span> <span class=nav-text>变长字段列表</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%A9%BA%E5%80%BC%E5%88%97%E8%A1%A8><span class=nav-number>1.3.2.2.</span> <span class=nav-text>空值列表</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF><span class=nav-number>1.3.2.3.</span> <span class=nav-text>记录头信息</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE><span class=nav-number>1.3.3.</span> <span class=nav-text>记录的真实数据</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#varchar-n-%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8An%E6%9C%80%E5%A4%A7%E5%8F%96%E5%80%BC><span class=nav-number>1.3.4.</span> <span class=nav-text>varchar(n)含义以及n最大取值</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%A1%8C%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98><span class=nav-number>1.3.5.</span> <span class=nav-text>行溢出问题</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%89%A7%E8%A1%8C%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%B5%81%E7%A8%8B><span class=nav-number>1.4.</span> <span class=nav-text>执行更新语句流程</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97><span class=nav-number>1.4.1.</span> <span class=nav-text>日志模块</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#Undo-log><span class=nav-number>1.4.1.1.</span> <span class=nav-text>Undo log</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Redo-log><span class=nav-number>1.4.1.2.</span> <span class=nav-text>Redo log</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#redo-log%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA><span class=nav-number>1.4.1.3.</span> <span class=nav-text>redo log刷盘时机</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Bin-log><span class=nav-number>1.4.1.4.</span> <span class=nav-text>Bin log</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6><span class=nav-number>1.4.1.5.</span> <span class=nav-text>主从复制</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#Buffer-Pool><span class=nav-number>1.4.2.</span> <span class=nav-text>Buffer Pool</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4><span class=nav-number>1.4.3.</span> <span class=nav-text>两阶段提交</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#redo-log%E4%B8%8Ebin-log%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E6%80%A7><span class=nav-number>1.4.3.1.</span> <span class=nav-text>redo log与bin log数据不一致性</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E8%BF%87%E7%A8%8B><span class=nav-number>1.4.3.2.</span> <span class=nav-text>两阶段提交过程</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E9%97%AE%E9%A2%98><span class=nav-number>1.4.3.3.</span> <span class=nav-text>两阶段提交问题</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#prepare%E9%98%B6%E6%AE%B5><span class=nav-number>1.4.3.3.1.</span> <span class=nav-text>prepare阶段</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#flush%E9%98%B6%E6%AE%B5><span class=nav-number>1.4.3.3.2.</span> <span class=nav-text>flush阶段</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#sync%E9%98%B6%E6%AE%B5><span class=nav-number>1.4.3.3.3.</span> <span class=nav-text>sync阶段</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#commit%E9%98%B6%E6%AE%B5><span class=nav-number>1.4.3.3.4.</span> <span class=nav-text>commit阶段</span></a></ol></ol></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E4%BA%8B%E5%8A%A1><span class=nav-number>2.</span> <span class=nav-text>事务</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7><span class=nav-number>2.1.</span> <span class=nav-text>事务特性</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%B9%B6%E8%A1%8C%E4%BA%8B%E5%8A%A1%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98><span class=nav-number>2.2.</span> <span class=nav-text>并行事务遇到的问题</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB><span class=nav-number>2.3.</span> <span class=nav-text>事务隔离级别</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#MVCC%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0><span class=nav-number>2.4.</span> <span class=nav-text>MVCC如何实现</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#Read-View%E6%98%AF%E4%BB%80%E4%B9%88><span class=nav-number>2.4.1.</span> <span class=nav-text>Read View是什么</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C><span class=nav-number>2.5.</span> <span class=nav-text>可重复读如何工作</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%B9%BB%E8%AF%BB%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3><span class=nav-number>2.6.</span> <span class=nav-text>幻读如何解决</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%BF%AB%E7%85%A7%E8%AF%BB%E6%83%85%E5%86%B5%E4%B8%8B><span class=nav-number>2.6.1.</span> <span class=nav-text>快照读情况下</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%BD%93%E5%89%8D%E8%AF%BB%E6%83%85%E5%86%B5%E4%B8%8B><span class=nav-number>2.6.2.</span> <span class=nav-text>当前读情况下</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E7%B4%A2%E5%BC%95><span class=nav-number>3.</span> <span class=nav-text>索引</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86><span class=nav-number>3.1.</span> <span class=nav-text>索引原理</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95><span class=nav-number>3.2.</span> <span class=nav-text>聚簇索引与二级索引</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95><span class=nav-number>3.3.</span> <span class=nav-text>什么时候需要索引</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%82%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%9F><span class=nav-number>3.3.1.</span> <span class=nav-text>什么时候适用索引？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F><span class=nav-number>3.3.2.</span> <span class=nav-text>什么时候不需要创建索引？</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#InnoDB%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE><span class=nav-number>3.4.</span> <span class=nav-text>InnoDB如何存储数据</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8B-%E6%A0%91%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2><span class=nav-number>3.4.1.</span> <span class=nav-text>如何使用B+树进行查询</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B-%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B><span class=nav-number>3.5.</span> <span class=nav-text>为什么使用B+树作为索引的数据类型</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#B%E6%A0%91-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8EB-%E6%A0%91%E7%9A%84%E7%89%B9%E5%88%AB%E7%82%B9%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB><span class=nav-number>3.5.1.</span> <span class=nav-text>B树,红黑树与B+树的特别点以及区别</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BC%98%E5%8C%96%E7%B4%A2%E5%BC%95%E6%96%B9%E6%B3%95><span class=nav-number>3.6.</span> <span class=nav-text>优化索引方法</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5><span class=nav-number>3.7.</span> <span class=nav-text>索引失效情况</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E5%B7%A6%E6%88%96%E5%B7%A6%E5%8F%B3%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D><span class=nav-number>3.7.1.</span> <span class=nav-text>索引使用左或左右模糊匹配</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AF%B9%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2><span class=nav-number>3.7.2.</span> <span class=nav-text>对索引使用函数、表达式、隐式类型转换</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E9%9D%9E%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D><span class=nav-number>3.7.3.</span> <span class=nav-text>联合索引非最左前缀匹配</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#where%E5%AD%97%E5%8F%A5%E4%B8%AD%E7%9A%84OR><span class=nav-number>3.7.4.</span> <span class=nav-text>where字句中的OR</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92><span class=nav-number>3.7.5.</span> <span class=nav-text>explain执行计划</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#count-%E5%92%8C-count-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%93%AA%E4%B8%AA%E6%80%A7%E8%83%BD%E6%9C%80%E5%A5%BD%EF%BC%9F><span class=nav-number>3.8.</span> <span class=nav-text>count(*) 和 count(1) 有什么区别？哪个性能最好？</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#count%E4%BD%9C%E7%94%A8%E5%8E%9F%E7%90%86><span class=nav-number>3.8.1.</span> <span class=nav-text>count作用原理</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#count-1-count-count-%E4%B8%BB%E9%94%AE-count-%E5%AD%97%E6%AE%B5><span class=nav-number>3.8.2.</span> <span class=nav-text>count(1) count(*) count(主键) count(字段)</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#count-%E4%B8%BB%E9%94%AE><span class=nav-number>3.8.2.1.</span> <span class=nav-text>count(主键)</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#count-1><span class=nav-number>3.8.2.2.</span> <span class=nav-text>count(1)</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#count><span class=nav-number>3.8.2.3.</span> <span class=nav-text>count(*)</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#count-%E6%99%AE%E9%80%9A%E5%AD%97%E6%AE%B5><span class=nav-number>3.8.2.4.</span> <span class=nav-text>count(普通字段)</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96count><span class=nav-number>3.8.3.</span> <span class=nav-text>如何优化count(*)</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#MySQL%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96><span class=nav-number>3.9.</span> <span class=nav-text>MySQL分页优化</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%9F%BA%E4%BA%8E%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E9%A1%B5><span class=nav-number>3.9.1.</span> <span class=nav-text>基于主键索引的分页</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%9F%BA%E4%BA%8E%E9%9D%9E%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E9%A1%B5><span class=nav-number>3.9.2.</span> <span class=nav-text>基于非主键索引的分页</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E9%97%AE%E9%A2%98><span class=nav-number>3.9.3.</span> <span class=nav-text>深度分页问题</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8F%96%E5%87%BA%E5%85%A8%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%88%96%E4%B8%8B%E4%B8%80%E9%A1%B5%E8%BF%9E%E7%BB%AD%E6%BB%9A%E5%8A%A8%E5%8A%A0%E8%BD%BD><span class=nav-number>3.9.3.1.</span> <span class=nav-text>取出全表数据或下一页连续滚动加载</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%BB%99%E7%94%A8%E6%88%B7%E5%81%9A%E5%88%86%E9%A1%B5%E5%B1%95%E7%A4%BA><span class=nav-number>3.9.3.2.</span> <span class=nav-text>给用户做分页展示</span></a></ol></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E9%94%81><span class=nav-number>4.</span> <span class=nav-text>锁</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%85%A8%E5%B1%80%E9%94%81><span class=nav-number>4.1.</span> <span class=nav-text>全局锁</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%A1%A8%E7%BA%A7%E9%94%81><span class=nav-number>4.2.</span> <span class=nav-text>表级锁</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%A1%A8%E9%94%81><span class=nav-number>4.2.1.</span> <span class=nav-text>表锁</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81><span class=nav-number>4.2.2.</span> <span class=nav-text>元数据锁</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%84%8F%E5%90%91%E9%94%81><span class=nav-number>4.2.3.</span> <span class=nav-text>意向锁</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#AUCO-INC%E9%94%81><span class=nav-number>4.2.4.</span> <span class=nav-text>AUCO-INC锁</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%A1%8C%E7%BA%A7%E9%94%81><span class=nav-number>4.3.</span> <span class=nav-text>行级锁</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%AE%B0%E5%BD%95%E9%94%81><span class=nav-number>4.3.0.1.</span> <span class=nav-text>记录锁</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%97%B4%E9%9A%99%E9%94%81><span class=nav-number>4.3.0.2.</span> <span class=nav-text>间隙锁</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Next-Key-Lock><span class=nav-number>4.3.0.3.</span> <span class=nav-text>Next-Key Lock</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81><span class=nav-number>4.3.0.4.</span> <span class=nav-text>插入意向锁</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Mysql%E5%A6%82%E4%BD%95%E5%8A%A0%E8%A1%8C%E7%BA%A7%E9%94%81><span class=nav-number>4.4.</span> <span class=nav-text>Mysql如何加行级锁</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2><span class=nav-number>4.4.1.</span> <span class=nav-text>唯一索引等值查询</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2><span class=nav-number>4.4.2.</span> <span class=nav-text>唯一索引范围查询</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2><span class=nav-number>4.4.3.</span> <span class=nav-text>非唯一索引等值查询</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2><span class=nav-number>4.4.4.</span> <span class=nav-text>非唯一索引范围查询</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8A%A0%E9%94%81><span class=nav-number>4.4.4.1.</span> <span class=nav-text>没有使用索引的加锁</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#Mysql%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81><span class=nav-number>4.4.5.</span> <span class=nav-text>Mysql发生死锁</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%86%85%E5%AD%98><span class=nav-number>5.</span> <span class=nav-text>内存</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%AE%A1%E7%90%86%E7%A9%BA%E9%97%B2%E9%A1%B5><span class=nav-number>5.0.1.</span> <span class=nav-text>管理空闲页</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%AE%A1%E7%90%86%E8%84%8F%E9%A1%B5><span class=nav-number>5.0.2.</span> <span class=nav-text>管理脏页</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#LRU%E9%93%BE%E8%A1%A8%E6%8F%90%E9%AB%98%E7%BC%93%E5%86%B2%E5%91%BD%E4%B8%AD%E7%8E%87><span class=nav-number>5.0.3.</span> <span class=nav-text>LRU链表提高缓冲命中率</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%99%AE%E9%80%9ALRU%E9%93%BE%E8%A1%A8%E7%BC%BA%E7%82%B9><span class=nav-number>5.0.3.1.</span> <span class=nav-text>普通LRU链表缺点</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%84%8F%E9%A1%B5%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA><span class=nav-number>5.0.4.</span> <span class=nav-text>脏页刷盘时机</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98><span class=nav-number>6.</span> <span class=nav-text>其他问题</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%88%A0%E9%99%A4%E8%A1%A8%E4%B8%AD%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E6%96%87%E4%BB%B6%E6%B2%A1%E6%9C%89%E5%87%8F%E5%B0%8F%E4%BB%A5%E5%8F%8A%E8%A1%A8%E9%87%8D%E5%BB%BA><span class=nav-number>6.1.</span> <span class=nav-text>删除表中部分数据为什么文件没有减小以及表重建</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%A1%A8%E9%87%8D%E5%BB%BA%EF%BC%9F><span class=nav-number>6.1.1.</span> <span class=nav-text>为什么需要表重建？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%A1%A8%E9%87%8D%E5%BB%BA%EF%BC%9F><span class=nav-number>6.1.2.</span> <span class=nav-text>如何进行表重建？</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%95%BF%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2%E9%95%BF%E4%BA%8B%E5%8A%A1><span class=nav-number>6.2.</span> <span class=nav-text>长事务问题以及如何查询长事务</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%8F%8C%E5%86%99%E7%BC%93%E5%86%B2%E4%B8%8Echange-buffer><span class=nav-number>6.3.</span> <span class=nav-text>双写缓冲与change buffer</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%B8%B4%E6%97%B6%E8%A1%A8%E4%B8%8Esort-buffer><span class=nav-number>6.4.</span> <span class=nav-text>临时表与sort buffer</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96><span class=nav-number>6.5.</span> <span class=nav-text>慢查询优化</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#Mybatis><span class=nav-number>7.</span> <span class=nav-text>Mybatis</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%B8%8E%E4%BC%A0%E7%BB%9F%E7%9A%84JDBC%E7%9B%B8%E6%AF%94%EF%BC%8CMyBatis%E7%9A%84%E4%BC%98%E7%82%B9><span class=nav-number>7.0.1.</span> <span class=nav-text>与传统的JDBC相比，MyBatis的优点</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Mybatis%E9%87%8C%E7%9A%84-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB><span class=nav-number>7.0.2.</span> <span class=nav-text>Mybatis里的 # 和 $ 的区别</span></a></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>246</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>16</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>215</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a><li class=links-of-blogroll-item><a href=https://www.lllomh.com/ rel=noopener target=_blank title=https://www.lllomh.com/>芈渡</a><li class=links-of-blogroll-item><a href=https://protool-ten.vercel.app/ rel=noopener target=_blank title=https://protool-ten.vercel.app/>protools</a></ul></div><div class="motion-element announcement"><div class=title></div><p class=content><p class=date></div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>文章词云</h3><div class="widget tagcloud" id=myCanvasContainer><canvas height=250 id=resCanvas style=width:100% width=250><ul class=tag-list itemprop=keywords><li class=tag-list-item><a class=tag-list-link href=/tags/mysql/ rel=tag>mysql</a><span class=tag-list-count>1</span></ul></canvas></div></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2025</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>3.3m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>50:09</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer></div><script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script><script src=/lib/anime.min.js></script><script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script><script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/pisces.js></script><script src=/js/next-boot.js></script><script src=/js/bookmark.js></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	'.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script><script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script><script src=/js/algolia-search.js></script><script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script><div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div><script charset=utf-8 defer src=/js/tagcanvas.js></script><script charset=utf-8 defer src=/js/tagcloud.js></script><script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script><script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script><script src=/js/src/activate-power-mode.min.js></script><script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script>
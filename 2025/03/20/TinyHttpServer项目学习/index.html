<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"0F9LEEVW82","apiKey":"78839e9f9be09d081c5c4da81975cd19","indexName":"sekyoblog_sec","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content="经典的C++ Linux网络编程项目." name=description><meta content=article property=og:type><meta content=TinyWebServer项目学习 property=og:title><meta content=https://www.sekyoro.top/2025/03/20/TinyHttpServer%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content="经典的C++ Linux网络编程项目." property=og:description><meta content=zh_CN property=og:locale><meta content=2025-03-20T09:46:11.000Z property=article:published_time><meta content=2025-03-25T08:28:26.634Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content=c++ property=article:tag><meta content=webserver property=article:tag><meta content=summary name=twitter:card><link href=https://www.sekyoro.top/2025/03/20/TinyHttpServer%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>TinyWebServer项目学习 | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2025/03/20/TinyHttpServer%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>TinyWebServer项目学习</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2025-03-20 17:46:11" datetime=2025-03-20T17:46:11+08:00>2025-03-20</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-03-25 16:28:26" datetime=2025-03-25T16:28:26+08:00 itemprop=dateModified>2025-03-25</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>26k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>24 分钟</span> </span></div></header><div class=post-body itemprop=articleBody><p>经典的C++ Linux网络编程项目.<br><span id=more></span><blockquote><p>不相关的话:<p>C++后端相关项目集中体现在:Linux环境编程,网络编程,并发(多线程)编程<p>常见项目就是webserver以及基于moduo等库进行业务开发(聊天服务,结合mysql,redis)等.比如下面项目:<p><a href=https://zhuanlan.zhihu.com/p/688641400 rel=noopener target=_blank>从易到难，推荐9个适合练手的C++项目 - 知乎</a><p><a href=https://www.cnblogs.com/xiaokang-coding/p/18531816 rel=noopener target=_blank>应届生必看！23 个高质量 C++ 项目推荐，校招简历秒加分 - 江小康 - 博客园</a><p><a href=https://www.nowcoder.com/discuss/353157418395836416 rel=noopener target=_blank>我整理了10个可以写到简历上的C++项目_牛客网</a><p><a href=https://zhuanlan.zhihu.com/p/17138007124 rel=noopener target=_blank>GitHub项目推荐—适合练手的13个C++开源项目 - 知乎</a></blockquote><h2 id=并发同步方法><a class=headerlink href=#并发同步方法 title=并发同步方法></a>并发同步方法</h2><p>在多线程并发条件下,对于共享资源,需要用锁机制解决.在c++标准中,有<code>mutex</code>,<code>condition_variable</code>以及新增的<code>barrier</code>,<code>latch</code>,<code>counting_semaphore</code>等机制.<p>这里使用了linux上的信号量<code>sem_t</code>和<code>pthread_mutex_t</code>锁机制.<h3 id=sem-t><a class=headerlink href=#sem-t title=sem_t></a>sem_t</h3><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsemaphore.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTthread></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTchrono></span></span></span><br><span class=line></span><br><span class=line><span class=keyword>sem_t</span> sem;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>task</span><span class=params>(<span class=keyword>const</span> <span class=keyword>char</span>* name, <span class=keyword>int</span> waitSeconds)</span> </span>{</span><br><span class=line>    std::this_thread::<span class=built_in>sleep_for</span>(std::chrono::<span class=built_in>seconds</span>(waitSeconds));</span><br><span class=line>    <span class=built_in>sem_wait</span>(&sem); <span class=comment>// 尝试获取信号量</span></span><br><span class=line>    std::cout << <span class=string>"Task "</span> << name << <span class=string>" is running.\n"</span>;</span><br><span class=line>    std::this_thread::<span class=built_in>sleep_for</span>(std::chrono::<span class=built_in>seconds</span>(<span class=number>1</span>));</span><br><span class=line>    <span class=built_in>sem_post</span>(&sem); <span class=comment>// 释放信号量</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=built_in>sem_init</span>(&sem, <span class=number>0</span>, <span class=number>2</span>); <span class=comment>// 初始化信号量，初始值为2</span></span><br><span class=line></span><br><span class=line>    <span class=function>std::thread <span class=title>t1</span><span class=params>(task, <span class=string>"A"</span>, <span class=number>1</span>)</span></span>;</span><br><span class=line>    <span class=function>std::thread <span class=title>t2</span><span class=params>(task, <span class=string>"B"</span>, <span class=number>2</span>)</span></span>;</span><br><span class=line>    <span class=function>std::thread <span class=title>t3</span><span class=params>(task, <span class=string>"C"</span>, <span class=number>3</span>)</span></span>;</span><br><span class=line></span><br><span class=line>    t1.<span class=built_in>join</span>();</span><br><span class=line>    t2.<span class=built_in>join</span>();</span><br><span class=line>    t3.<span class=built_in>join</span>();</span><br><span class=line></span><br><span class=line>    <span class=built_in>sem_destroy</span>(&sem); <span class=comment>// 销毁信号量</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>​ <code>sem_wait</code> 函数用于等待一个信号量。它会尝试减少（减1）信号量的计数值。如果信号量的值大于0，则该函数会将信号量的值减1，并立即返回。<p>如果信号量的值为0，则调用 <code>sem_wait</code> 的线程或进程会被阻塞，直到另一个线程或进程通过调用 <code>sem_post</code> 增加了信号量的值，使得其大于0为止。<p>常用于表示“获取”一个资源或进入临界区。<strong>当信号量代表可用资源的数量时，<code>sem_wait</code> 可以理解为尝试占用一个资源。</strong>成功时返回 <code>0</code>,失败时返回 <code>-1</code> 并设置 <code>errno</code><p>​ <code>sem_post</code>函数用于增加（加1）信号量的计数值，并通知可能正在等待该信号量的一个线程或进程。该函数总是成功地将信号量的值加1。<p>如果有其他线程或进程正在等待这个信号量（即因为信号量的值为0而被阻塞），那么其中一个等待的线程或进程会被唤醒并继续执行。常用于表示“释放”一个资源或离开临界区。<strong>当某个线程完成了对共享资源的操作后，可以通过调用 <code>sem_post</code> 来通知其他线程可以继续操作该资源</strong>。成功时返回 <code>0</code>,失败时返回 <code>-1</code> 并设置 <code>errno</code><h3 id=pthread-mutex-t><a class=headerlink href=#pthread-mutex-t title=pthread_mutex_t></a>pthread_mutex_t</h3><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdlib.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTpthread.h></span></span></span><br><span class=line></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> NUM_THREADS 5</span></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> ITERATIONS 100000</span></span><br><span class=line></span><br><span class=line><span class=keyword>int</span> counter = <span class=number>0</span>;</span><br><span class=line><span class=keyword>pthread_mutex_t</span> mutex;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span>* <span class=title>increment_counter</span><span class=params>(<span class=keyword>void</span>* arg)</span> </span>{</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < ITERATIONS; ++i) {</span><br><span class=line>        <span class=built_in>pthread_mutex_lock</span>(&mutex); <span class=comment>// 加锁</span></span><br><span class=line>        ++counter;</span><br><span class=line>        <span class=built_in>pthread_mutex_unlock</span>(&mutex); <span class=comment>// 解锁</span></span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=literal>NULL</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>pthread_t</span> threads[NUM_THREADS];</span><br><span class=line>    </span><br><span class=line>    <span class=comment>// 初始化互斥锁</span></span><br><span class=line>    <span class=keyword>if</span> (<span class=built_in>pthread_mutex_init</span>(&mutex, <span class=literal>NULL</span>) != <span class=number>0</span>) {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Mutex init failed\n"</span>);</span><br><span class=line>        <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 创建多个线程</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < NUM_THREADS; ++i) {</span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>pthread_create</span>(&threads[i], <span class=literal>NULL</span>, increment_counter, <span class=literal>NULL</span>) != <span class=number>0</span>) {</span><br><span class=line>            <span class=built_in>printf</span>(<span class=string>"Thread creation failed\n"</span>);</span><br><span class=line>            <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 等待所有线程完成</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < NUM_THREADS; ++i) {</span><br><span class=line>        <span class=built_in>pthread_join</span>(threads[i], <span class=literal>NULL</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 销毁互斥锁</span></span><br><span class=line>    <span class=built_in>pthread_mutex_destroy</span>(&mutex);</span><br><span class=line></span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"Final counter value: %d\n"</span>, counter);</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><p><code>pthread_mutex_t</code> 是 POSIX 线程（也称为 pthreads）库中用于实现互斥锁（mutex）的数据类型。互斥锁是一种同步机制，用于保护共享资源免受并发访问的影响，从而避免数据竞争和不一致的状态。<p>互斥锁：互斥锁是一种同步原语，用于确保在任何给定时间只有一个线程可以访问特定的代码段或共享资源。<p>初始化与销毁：互斥锁需要先初始化才能使用，并且在不再需要时应该被销毁以释放相关资源。<p>加锁与解锁：通过 <code>pthread_mutex_lock()</code> 和 <code>pthread_mutex_unlock()</code> 函数来控制对临界区的访问。<ol><li><p><strong>初始化互斥锁</strong></p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>pthread_mutex_init</span><span class=params>(<span class=keyword>pthread_mutex_t</span> *<span class=keyword>restrict</span> mutex, <span class=keyword>const</span> <span class=keyword>pthread_mutexattr_t</span> *<span class=keyword>restrict</span> attr)</span></span>;</span><br></pre></table></figure> <ul><li><code>mutex</code>: 要初始化的互斥锁指针。<li><code>attr</code>: 互斥锁属性（通常可以传入 <code>NULL</code> 使用默认属性）。<li>返回值：成功返回 <code>0</code>，失败返回错误码。</ul><li><p><strong>销毁互斥锁</strong></p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>pthread_mutex_destroy</span><span class=params>(<span class=keyword>pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></table></figure> <ul><li><code>mutex</code>: 要销毁的互斥锁指针。<li>返回值：成功返回 <code>0</code>，失败返回错误码。</ul><li><p><strong>加锁</strong></p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>pthread_mutex_lock</span><span class=params>(<span class=keyword>pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></table></figure> <ul><li><code>mutex</code>: 要加锁的互斥锁指针。<li>返回值：成功返回 <code>0</code>，失败返回错误码。</ul><li><p><strong>尝试加锁</strong></p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>pthread_mutex_trylock</span><span class=params>(<span class=keyword>pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></table></figure> <ul><li><code>mutex</code>: 要尝试加锁的互斥锁指针。<li>返回值：成功返回 <code>0</code>，如果锁已经被其他线程持有则返回 <code>EBUSY</code>，失败返回其他错误码。</ul><li><p><strong>解锁</strong></p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>pthread_mutex_unlock</span><span class=params>(<span class=keyword>pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></table></figure> <ul><li><code>mutex</code>: 要解锁的互斥锁指针。<li>返回值：成功返回 <code>0</code>，失败返回错误码。</ul></ol><h3 id=pthread-cond-t><a class=headerlink href=#pthread-cond-t title=pthread_cond_t></a>pthread_cond_t</h3><p>在 POSIX 线程（也称为 pthreads）中，条件变量（<code>pthread_cond_t</code>）是一种用于线程间通信的同步机制。条件变量允许一个线程等待某个条件成立，而另一个线程可以在满足条件时通知等待的线程继续执行<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTpthread.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstdlib.h></span></span></span><br><span class=line></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> BUFFER_SIZE 10</span></span><br><span class=line></span><br><span class=line><span class=keyword>int</span> buffer[BUFFER_SIZE];</span><br><span class=line><span class=keyword>int</span> fill_ptr = <span class=number>0</span>;</span><br><span class=line><span class=keyword>int</span> use_ptr = <span class=number>0</span>;</span><br><span class=line><span class=keyword>int</span> count = <span class=number>0</span>;</span><br><span class=line></span><br><span class=line><span class=keyword>pthread_mutex_t</span> mutex;</span><br><span class=line><span class=keyword>pthread_cond_t</span> cond_var;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>put</span><span class=params>(<span class=keyword>int</span> value)</span> </span>{</span><br><span class=line>    buffer[fill_ptr] = value;</span><br><span class=line>    fill_ptr = (fill_ptr + <span class=number>1</span>) % BUFFER_SIZE;</span><br><span class=line>    count++;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>get</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> tmp = buffer[use_ptr];</span><br><span class=line>    use_ptr = (use_ptr + <span class=number>1</span>) % BUFFER_SIZE;</span><br><span class=line>    count--;</span><br><span class=line>    <span class=keyword>return</span> tmp;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span>* <span class=title>producer</span><span class=params>(<span class=keyword>void</span>* arg)</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> item;</span><br><span class=line>    <span class=keyword>while</span> (<span class=number>1</span>) {</span><br><span class=line>        item = <span class=built_in>rand</span>() % <span class=number>100</span>; <span class=comment>// 生产随机数</span></span><br><span class=line>        <span class=built_in>pthread_mutex_lock</span>(&mutex);</span><br><span class=line>        <span class=keyword>while</span> (count == BUFFER_SIZE) {</span><br><span class=line>            <span class=built_in>pthread_cond_wait</span>(&cond_var, &mutex); <span class=comment>// 缓冲区满，等待</span></span><br><span class=line>        }</span><br><span class=line>        <span class=built_in>put</span>(item);</span><br><span class=line>        <span class=built_in>pthread_cond_signal</span>(&cond_var); <span class=comment>// 通知消费者</span></span><br><span class=line>        <span class=built_in>pthread_mutex_unlock</span>(&mutex);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=literal>NULL</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span>* <span class=title>consumer</span><span class=params>(<span class=keyword>void</span>* arg)</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> item;</span><br><span class=line>    <span class=keyword>while</span> (<span class=number>1</span>) {</span><br><span class=line>        <span class=built_in>pthread_mutex_lock</span>(&mutex);</span><br><span class=line>        <span class=keyword>while</span> (count == <span class=number>0</span>) {</span><br><span class=line>            <span class=built_in>pthread_cond_wait</span>(&cond_var, &mutex); <span class=comment>// 缓冲区空，等待</span></span><br><span class=line>        }</span><br><span class=line>        item = <span class=built_in>get</span>();</span><br><span class=line>        <span class=built_in>pthread_cond_signal</span>(&cond_var); <span class=comment>// 通知生产者</span></span><br><span class=line>        <span class=built_in>pthread_mutex_unlock</span>(&mutex);</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Consumed: %d\n"</span>, item);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=literal>NULL</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>pthread_t</span> prod_thread, cons_thread;</span><br><span class=line></span><br><span class=line>    <span class=built_in>pthread_mutex_init</span>(&mutex, <span class=literal>NULL</span>);</span><br><span class=line>    <span class=built_in>pthread_cond_init</span>(&cond_var, <span class=literal>NULL</span>);</span><br><span class=line></span><br><span class=line>    <span class=built_in>pthread_create</span>(&prod_thread, <span class=literal>NULL</span>, producer, <span class=literal>NULL</span>);</span><br><span class=line>    <span class=built_in>pthread_create</span>(&cons_thread, <span class=literal>NULL</span>, consumer, <span class=literal>NULL</span>);</span><br><span class=line></span><br><span class=line>    <span class=built_in>pthread_join</span>(prod_thread, <span class=literal>NULL</span>);</span><br><span class=line>    <span class=built_in>pthread_join</span>(cons_thread, <span class=literal>NULL</span>);</span><br><span class=line></span><br><span class=line>    <span class=built_in>pthread_mutex_destroy</span>(&mutex);</span><br><span class=line>    <span class=built_in>pthread_cond_destroy</span>(&cond_var);</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><ol><li><p><strong>初始化条件变量</strong></p> <ul><li><p>```c++<br>int pthread_cond_init(pthread_cond_t <em>cond, const pthread_condattr_t </em>attr);</p> <figure class="highlight markdown"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line></span><br><span class=line><span class=bullet>     -</span> <span class=code>`cond`</span>: 指向要初始化的条件变量。</span><br><span class=line><span class=bullet>     -</span> <span class=code>`attr`</span>: 条件变量属性，通常设置为 <span class=code>`NULL`</span> 使用默认属性。</span><br><span class=line><span class=bullet>     -</span> 返回值：成功返回 <span class=code>`0`</span>，错误则返回非零错误码。</span><br><span class=line></span><br><span class=line><span class=bullet>2.</span> <span class=strong>**销毁条件变量**</span></span><br><span class=line></span><br><span class=line><span class=bullet>   -</span> <span class=code>```c++</span></span><br><span class=line><span class=code>     int pthread_cond_destroy(pthread_cond_t *cond);</span></span><br></pre></table></figure> <ul><li><code>cond</code>: 要销毁的条件变量。<li>返回值：成功返回 <code>0</code>，错误则返回非零错误码。</ul></ul></ol><p>等待和通知<ol><li><p><strong>等待条件变量</strong></p> <ul><li><p>```c++<br>int pthread_cond_wait(pthread_cond_t <em>cond, pthread_mutex_t </em>mutex);</p> <figure class="highlight markdown"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line></span><br><span class=line><span class=bullet>     -</span> <span class=code>`cond`</span>: 条件变量。</span><br><span class=line><span class=bullet>     -</span> <span class=code>`mutex`</span>: 保护共享资源的互斥锁，必须是在调用前已经锁定的同一个互斥锁。</span><br><span class=line><span class=bullet>     -</span> 功能：原子地解锁互斥锁并使当前线程进入等待状态，直到被其他线程通过 <span class=code>`pthread_cond_signal`</span> 或 <span class=code>`pthread_cond_broadcast`</span> 唤醒。唤醒后，在重新开始执行之前会自动重新获取互斥锁。</span><br><span class=line><span class=bullet>     -</span> 返回值：成功返回 <span class=code>`0`</span>，错误则返回非零错误码。</span><br><span class=line></span><br><span class=line><span class=bullet>2.</span> <span class=strong>**定时等待条件变量**</span></span><br><span class=line></span><br><span class=line><span class=bullet>   -</span> <span class=code>```c++</span></span><br><span class=line><span class=code>     int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);</span></span><br></pre></table></figure> <ul><li><code>cond</code>: 条件变量。<li><code>mutex</code>: 保护共享资源的互斥锁。<li><code>abstime</code>: 绝对超时时间点，使用 <code>struct timespec</code> 定义。<li>功能：类似于 <code>pthread_cond_wait</code>，但是它会在指定的时间过后自动返回，即使条件尚未满足。<li>返回值：成功返回 <code>0</code>，超时返回 <code>ETIMEDOUT</code>，其他错误则返回相应的错误码。</ul></ul><li><p><strong>通知单个等待线程</strong></p> <ul><li><p>```c++<br>int pthread_cond_signal(pthread_cond_t *cond);</p> <figure class="highlight markdown"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line></span><br><span class=line><span class=bullet>     -</span> <span class=code>`cond`</span>: 条件变量。</span><br><span class=line><span class=bullet>     -</span> 功能：唤醒至少一个正在等待该条件变量的线程。如果有多个线程在等待，则具体唤醒哪一个由实现定义。</span><br><span class=line><span class=bullet>     -</span> 返回值：成功返回 <span class=code>`0`</span>，错误则返回非零错误码。</span><br><span class=line></span><br><span class=line><span class=bullet>4.</span> <span class=strong>**广播通知所有等待线程**</span></span><br><span class=line></span><br><span class=line><span class=bullet>   -</span> <span class=code>```c++</span></span><br><span class=line><span class=code>     int pthread_cond_broadcast(pthread_cond_t *cond);</span></span><br></pre></table></figure> <ul><li><code>cond</code>: 条件变量。<li>功能：唤醒所有正在等待该条件变量的线程。<li>返回值：成功返回 <code>0</code>，错误则返回非零错误码</ul></ul></ol><h2 id=异步日志写入><a class=headerlink href=#异步日志写入 title=异步日志写入></a>异步日志写入</h2><p>文件读写是IO操作,会引起系统中断的耗时操作. 通过异步写入,<p>IO操作设计的阻塞/非阻塞与同步/异步区分:<ol><li><strong>阻塞 vs 非阻塞</strong>主要关注于如何处理未准备好数据的情况:是立即返回还是等待。<li><strong>同步 vs 异步</strong>则更多地涉及到整个I/O操作流程的设计理念:是否需要等待I/O操作完成才能继续执行。</ol><p>利用<strong>单例模式</strong>创建了日志类,这样每个线程都共享这个实例.<p>通过多线程写入文件,避免IO的阻塞. 如果使用异步写入,主线程将日志写入到一个阻塞列表,创建的读出线程读取这个阻塞列表并将内容写入文件.<p>这个过程涉及到生产者-消费者问题,在加入数据时,判断队列是否满,如果满则返回false表明不能再添加,同时唤醒条件变量等待的线程(也就是读取线程). 如果没满则添加数据,同时也唤醒读取线程.<p>当读取数据时,如果队列为空,则阻塞读取线程,释放锁,让写入线程写入阻塞列表(缓冲区).<p>所以异步日志创建时就会创建一个消费者线程用于读取数据并写入到文件. 设计一个缓冲区(阻塞队列),利用上面的并发同步方法,也就是一个生产者-消费者模型.<p>此外日志有根据日期写入到不同的文件,此外写入的行数超出要求的行数时会另外创建一个日志.<h2 id=数据库连接池><a class=headerlink href=#数据库连接池 title=数据库连接池></a>数据库连接池</h2><p>复用数据库的连接. 创建包含多个连接的连接池,初始化时根据账号密码以及数据库url创建连接存入list列表,这是个共享资源也需要使用锁进行保护. 这里使用信号量,根据连接数初始化信号量,每当获得一个连接,使用sem.wait(),信号量-1,信号量机制是当信号量为0时进行阻塞,否则减1. 当释放一个连接(将一个连接加入连接池),使用sem.post()信号量加1并唤醒阻塞线程. 对于一些共享资源,比如m_FreeConn和m_CurConn等变量进行锁保护.<h2 id=线程池><a class=headerlink href=#线程池 title=线程池></a>线程池</h2><p>在I/O模型中，同步I/O和异步I/O主要的区别是内核向应用程序通知的是就绪事件还是完成事件，以及是由应用程序还是由内核来完成I/O的读写操作<blockquote><p>同步I/O：内核向应用程序通知就绪事件，由应用程序自身来完成I/O的读写操作<br>异步I/O：由内核来完成I/O的读写后向应用程序通知完成事件</blockquote><p>在并发模式中，同步和异步的主要区别是<strong><em>\</em>功能完成的流程是否是顺序化的，是否需要等待**</strong><blockquote><ul><li>同步：当遇到阻塞任务时，会一直等待，直到该任务处理完成，程序完全按照代码顺序执行；<li>异步：程序的执行需要由系统事件驱动，程序的执行是不确定的，没有顺序上的要求</ul></blockquote><h3 id=事件处理模式><a class=headerlink href=#事件处理模式 title=事件处理模式></a>事件处理模式</h3><h4 id=Reactor模式和Proactor模式><a class=headerlink href=#Reactor模式和Proactor模式 title=Reactor模式和Proactor模式></a>Reactor模式和Proactor模式</h4><p>​ <strong>Reactor模式</strong>是一种事件驱动的设计模式，主要用于处理并发的输入操作（如网络连接或文件I/O）。它的主要思想是<strong>将所有I/O操作分派给一个专门的事件循环来处理，这个事件循环会监听多个事件源，并在相应的事件发生时调用对应的处理器（Handler）</strong>。这种模式非常适合于需要处理大量并发连接的应用程序，比如Web服务器。<blockquote><p>Reactor 模式的核心是使用事件循环监听多个文件描述符（如套接字），并在事件发生时调用相应的处理器</blockquote><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/select.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/socket.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTnetinet/in.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTcstring></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTvector></span></span></span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>EventHandler</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=keyword>virtual</span> ~<span class=built_in>EventHandler</span>() = <span class=keyword>default</span>;</span><br><span class=line>    <span class=function><span class=keyword>virtual</span> <span class=keyword>void</span> <span class=title>handle_event</span><span class=params>(<span class=keyword>int</span> fd)</span> </span>= <span class=number>0</span>;</span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Reactor</span> {</span></span><br><span class=line><span class=keyword>private</span>:</span><br><span class=line>    fd_set read_fds; <span class=comment>// 监听的文件描述符集合</span></span><br><span class=line>    <span class=keyword>int</span> max_fd;      <span class=comment>// 最大文件描述符</span></span><br><span class=line>    std::vector&LTEventHandler*> handlers;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=built_in>Reactor</span>() : <span class=built_in>max_fd</span>(<span class=number>0</span>) {</span><br><span class=line>        <span class=built_in>FD_ZERO</span>(&read_fds);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>register_handler</span><span class=params>(<span class=keyword>int</span> fd, EventHandler* handler)</span> </span>{</span><br><span class=line>        <span class=built_in>FD_SET</span>(fd, &read_fds);</span><br><span class=line>        <span class=keyword>if</span> (fd > max_fd) {</span><br><span class=line>            max_fd = fd;</span><br><span class=line>        }</span><br><span class=line>        handlers.<span class=built_in>push_back</span>(handler);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>run_event_loop</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>while</span> (<span class=literal>true</span>) {</span><br><span class=line>            fd_set tmp_fds = read_fds;</span><br><span class=line>            <span class=keyword>int</span> ret = <span class=built_in>select</span>(max_fd + <span class=number>1</span>, &tmp_fds, <span class=literal>nullptr</span>, <span class=literal>nullptr</span>, <span class=literal>nullptr</span>);</span><br><span class=line>            <span class=keyword>if</span> (ret < <span class=number>0</span>) {</span><br><span class=line>                std::cerr << <span class=string>"Select error!"</span> << std::endl;</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            }</span><br><span class=line></span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i <= max_fd; ++i) {</span><br><span class=line>                <span class=keyword>if</span> (<span class=built_in>FD_ISSET</span>(i, &tmp_fds)) {</span><br><span class=line>                    <span class=keyword>for</span> (<span class=keyword>auto</span> handler : handlers) {</span><br><span class=line>                        handler-><span class=built_in>handle_event</span>(i);</span><br><span class=line>                    }</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>ReadHandler</span> :</span> <span class=keyword>public</span> EventHandler {</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>handle_event</span><span class=params>(<span class=keyword>int</span> fd)</span> <span class=keyword>override</span> </span>{</span><br><span class=line>        <span class=keyword>char</span> buffer[<span class=number>1024</span>];</span><br><span class=line>        <span class=keyword>int</span> bytes = <span class=built_in>read</span>(fd, buffer, <span class=built_in><span class=keyword>sizeof</span></span>(buffer) - <span class=number>1</span>);</span><br><span class=line>        <span class=keyword>if</span> (bytes > <span class=number>0</span>) {</span><br><span class=line>            buffer[bytes] = <span class=string>'\0'</span>;</span><br><span class=line>            std::cout << <span class=string>"Received: "</span> << buffer << std::endl;</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            std::cerr << <span class=string>"Client disconnected."</span> << std::endl;</span><br><span class=line>            <span class=built_in>close</span>(fd);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=comment>// 创建服务器套接字</span></span><br><span class=line>    <span class=keyword>int</span> server_fd = <span class=built_in>socket</span>(AF_INET, SOCK_STREAM, <span class=number>0</span>);</span><br><span class=line>    sockaddr_in server_addr{};</span><br><span class=line>    server_addr.sin_family = AF_INET;</span><br><span class=line>    server_addr.sin_port = <span class=built_in>htons</span>(<span class=number>8080</span>);</span><br><span class=line>    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class=line></span><br><span class=line>    <span class=built_in>bind</span>(server_fd, <span class=keyword>reinterpret_cast</span>&LTsockaddr*>(&server_addr), <span class=built_in><span class=keyword>sizeof</span></span>(server_addr));</span><br><span class=line>    <span class=built_in>listen</span>(server_fd, <span class=number>5</span>);</span><br><span class=line></span><br><span class=line>    Reactor reactor;</span><br><span class=line>    ReadHandler read_handler;</span><br><span class=line></span><br><span class=line>    <span class=comment>// 注册服务器套接字</span></span><br><span class=line>    reactor.<span class=built_in>register_handler</span>(server_fd, &read_handler);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 运行事件循环</span></span><br><span class=line>    reactor.<span class=built_in>run_event_loop</span>();</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>​ <strong>Proactor模式</strong>是一种异步的事件处理模式，与Reactor模式不同，它允许操作在后台执行，当操作完成时通知应用程序。通常，Proactor模式<strong>涉及到的操作如读写文件或网络I/O都是通过操作系统提供的异步I/O服务来实现</strong>的。然而，在某些不支持异步I/O的操作系统上，<strong>可以通过同步I/O结合多线程或者回调机制来模拟Proactor模式的效果。这意味着主线程可以提交I/O操作给一个工作线程池，然后继续处理其他任务</strong>，而工作线程会在I/O操作完成后通过某种方式（例如回调函数）通知主线程<blockquote><p>Proactor 模式依赖于异步 I/O 操作，通常由操作系统提供支持。</blockquote><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTaio.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTfcntl.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunistd.h></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTcstring></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTvector></span></span></span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Proactor</span> {</span></span><br><span class=line><span class=keyword>private</span>:</span><br><span class=line>    std::vector&LTaiocb*> aio_controls; <span class=comment>// 异步 I/O 控制块</span></span><br><span class=line></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    ~<span class=built_in>Proactor</span>() {</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span> cb : aio_controls) {</span><br><span class=line>            <span class=keyword>delete</span> cb;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>start_read</span><span class=params>(<span class=keyword>int</span> fd)</span> </span>{</span><br><span class=line>        aiocb* cb = <span class=keyword>new</span> <span class=built_in>aiocb</span>();</span><br><span class=line>        <span class=built_in>memset</span>(cb, <span class=number>0</span>, <span class=built_in><span class=keyword>sizeof</span></span>(aiocb));</span><br><span class=line></span><br><span class=line>        <span class=keyword>char</span> buffer[<span class=number>1024</span>];</span><br><span class=line>        cb->aio_fildes = fd;</span><br><span class=line>        cb->aio_buf = buffer;</span><br><span class=line>        cb->aio_nbytes = <span class=built_in><span class=keyword>sizeof</span></span>(buffer) - <span class=number>1</span>;</span><br><span class=line>        cb->aio_offset = <span class=number>0</span>;</span><br><span class=line></span><br><span class=line>        aio_controls.<span class=built_in>push_back</span>(cb);</span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>aio_read</span>(cb) < <span class=number>0</span>) {</span><br><span class=line>            std::cerr << <span class=string>"Error starting async read."</span> << std::endl;</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        std::cout << <span class=string>"Async read started on fd: "</span> << fd << std::endl;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>wait_for_completion</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span> cb : aio_controls) {</span><br><span class=line>            <span class=keyword>while</span> (<span class=built_in>aio_error</span>(cb) == EINPROGRESS) {</span><br><span class=line>                <span class=built_in>usleep</span>(<span class=number>1000</span>); <span class=comment>// 等待操作完成</span></span><br><span class=line>            }</span><br><span class=line></span><br><span class=line>            <span class=keyword>ssize_t</span> bytes = <span class=built_in>aio_return</span>(cb);</span><br><span class=line>            <span class=keyword>if</span> (bytes > <span class=number>0</span>) {</span><br><span class=line>                std::cout << <span class=string>"Async read completed. Data: "</span></span><br><span class=line>                          << <span class=keyword>static_cast</span><<span class=keyword>char</span>*>(cb->aio_buf) << std::endl;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                std::cerr << <span class=string>"Async read failed."</span> << std::endl;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=comment>// 打开一个文件进行异步读取</span></span><br><span class=line>    <span class=keyword>int</span> fd = <span class=built_in>open</span>(<span class=string>"test.txt"</span>, O_RDONLY);</span><br><span class=line>    <span class=keyword>if</span> (fd < <span class=number>0</span>) {</span><br><span class=line>        std::cerr << <span class=string>"Failed to open file."</span> << std::endl;</span><br><span class=line>        <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    Proactor proactor;</span><br><span class=line>    proactor.<span class=built_in>start_read</span>(fd); <span class=comment>// 开始异步读取</span></span><br><span class=line>    proactor.<span class=built_in>wait_for_completion</span>(); <span class=comment>// 等待完成</span></span><br><span class=line></span><br><span class=line>    <span class=built_in>close</span>(fd);</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><div class=table-container><table><thead><tr><th>特性<th>Reactor 模式<th>Proactor 模式<tbody><tr><td><strong>核心机制</strong><td>同步 I/O，事件驱动<td>异步 I/O，操作系统支持<tr><td><strong>适用场景</strong><td>高并发连接，如网络服务器<td>高性能 I/O 密集型应用<tr><td><strong>复杂度</strong><td>较低，易于理解和实现<td>较高，需要操作系统支持异步 I/O<tr><td><strong>效率</strong><td>受限于同步 I/O<td>更高效，I/O 操作在后台完成<tr><td><strong>典型实现</strong><td><code>select</code>、<code>poll</code>、<code>epoll</code><td>POSIX AIO、Windows Overlapped I/O</table></div><blockquote><ul><li>reactor模式中，主线程(<strong>I/O处理单元</strong>)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(<strong>逻辑单元</strong> )，读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由<strong>同步I/O</strong>实现。<li>proactor模式中，主线程和内核负责处理读写数据、接受新连接等I/O操作，工作线程仅负责业务逻辑，如处理客户请求。通常由<strong>异步I/O</strong>实现。</ul></blockquote><h3 id=并发编程模式><a class=headerlink href=#并发编程模式 title=并发编程模式></a>并发编程模式</h3><h4 id=半同步-半异步模式><a class=headerlink href=#半同步-半异步模式 title=半同步/半异步模式></a>半同步/半异步模式</h4><p><strong>半同步/半异步（Half-Sync/Half-Async）模式</strong>是一种设计模式，用于处理不同类型的并发任务。它通过分离同步和异步的任务处理路径，使得系统能够更高效地管理资源并提高响应速度。这种模式特别适用于那些需要同时处理同步任务（如用户界面交互）和异步任务（如后台计算或I/O操作）的应用场景.<p><strong>同步层（Synchronous Layer）</strong>：负责处理需要立即响应的任务，例如用户界面的交互事件。这些任务通常要求快速响应以提供良好的用户体验。<p><strong>队列（Queue）</strong>：作为同步层和异步层之间的桥梁，用于传递消息或任务。同步层将任务放入队列中，异步层从队列中取出任务进行处理。<p><strong>异步层（Asynchronous Layer）</strong>：负责执行耗时较长的任务，比如文件I/O、网络通信或者复杂的计算。这些任务不会阻塞主线程，从而保证了系统的流畅性。<h4 id=半同步-半反应堆模式><a class=headerlink href=#半同步-半反应堆模式 title=半同步/半反应堆模式></a>半同步/半反应堆模式</h4><p><strong>半同步/半反应堆（Half-Sync/Half-Reactor）</strong>模式是一种混合的设计模式，它<strong>结合了同步和异步处理的优势来管理并发连接</strong>。这种模式通常用于服务器程序中，旨在提高系统的性能和可扩展性。<p><strong>Reactor部分</strong>：主要负责监听多个文件描述符（如套接字），并在相应的事件发生时（比如有新的连接请求或数据到达）通知对应的事件处理器。<ul><li>主线程运行一个事件循环，调用 <code>select</code>、<code>poll</code> 或者更高效的 <code>epoll</code> 等函数等待感兴趣的事件发生。<li>当检测到新的连接请求时，主线程接受该连接，并将其交给工作线程池中的某个线程处理。</ul><p><strong>Worker部分</strong>：每个工作线程独立地处理从主线程接收过来的具体连接上的读写操作。<ul><li>工作线程执行同步的I/O操作，这意味着它们会在读取或写入数据时阻塞，直到操作完成。<li>尽管如此，由于这些操作是在单独的线程中进行的，因此不会影响主线程对新连接的响应速度。</ul><h4 id=与半同步-半反应堆的区别><a class=headerlink href=#与半同步-半反应堆的区别 title=与半同步/半反应堆的区别></a>与半同步/半反应堆的区别</h4><ul><li><strong>半同步/半反应堆</strong>：主要用于服务器程序中，其中主线程（Reactor部分）监听新的连接请求，然后将新建立的连接交给工作线程处理。这是一种专门针对网络编程的设计模式，强调的是如何有效地管理和分发多个并发连接。<li><strong>半同步/半异步模式</strong>：更加通用，不仅仅局限于网络编程。它可以应用于任何需要同时处理同步任务（如UI更新）和异步任务（如后台数据处理）的场景。其重点在于如何通过分离同步和异步的任务处理路径来优化系统性能和响应速度。</ul><p><a href=https://blog.csdn.net/qq_35423154/article/details/108930574?ops_request_misc=%7B%22request%5Fid%22%3A%22168103147416800192255531%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&request_id=168103147416800192255531&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-108930574-null-null.142^v82^insert_down1,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=半同步%2F半异步并发模式&spm=1018.2226.3001.4187 rel=noopener target=_blank>Linux网络编程 | 并发模式：半同步/半异步模式、领导者/追随者模式_linux 网络编程 leadfollow模式-CSDN博客</a><p><a href=https://zhuanlan.zhihu.com/p/58860015 rel=noopener target=_blank>高山仰之可极，谈半同步/半异步网络并发模型 - 知乎</a><h2 id=IO多路复用><a class=headerlink href=#IO多路复用 title=IO多路复用></a>IO多路复用</h2><p>五种I/O模型<blockquote><ul><li><strong>阻塞IO</strong>:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作<li><strong>非阻塞IO</strong>:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I/O执行系统调用总是立即返回，不管时间是否已经发生，若时间没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept，recv和send，事件未发生时，errno通常被设置成eagain<li><strong>信号驱动IO</strong>:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。<li><strong>IO复用</strong>:linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数<li><strong>异步IO</strong>:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</ul><p><strong>注意：阻塞I/O，非阻塞I/O，信号驱动I/O和I/O复用都是同步I/O。同步I/O指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行I/O操作，异步I/O是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成I/O操作。</strong></blockquote><p><strong>IO多路复用</strong>是一种允许单个进程监视多个文件描述符（如套接字、管道等）的技术，当其中任意一个文件描述符准备好进行读写操作时，该技术能够通知应用程序。这种方法可以显著提高服务器程序的性能，因为它避免了为每个连接创建单独线程或进程所带来的开销。<blockquote><p>单线程Polling API的常规用法是：<p>让Polling API监控服务端socket的状态，然后开始死循循环，循环过程中主要有三种逻辑分支：<ol><li>服务端socket的状态变为可读，即表示有客户端发起连接，此时就调用accept建立连接，得到一个客户端fd。将其加入到Polling API的监控集合，并标记其为可读。<li>客户端fd的状态变为可读，则调用read/recv从fd读取数据，然后执行业务逻辑，处理完，再将其加入到Polling API的监控集合，并标记其为可写。<li>客户端fd的状态变为可写，则调用write/send将数据发送给客户端。</ol></blockquote><h3 id=select><a class=headerlink href=#select title=select></a>select</h3><p><code>select</code>函数监视一组文件描述符，等待它们中的任何一个变为可读、可写或发生异常条件。<p>通过三个位图（fd_set类型）来分别表示需要监视的可读、可写及异常事件集合。<p>当调用<code>select</code>时，<strong>内核会阻塞当前进程，直到指定的文件描述符集合中的至少一个准备就绪</strong>。<p>返回值有响应的文件描述符个数.如果超时，则返回0；如果出错，则返回-1。<ol><li><p>在调用 <code>select</code> 之前，你需要将感兴趣的文件描述符添加到 <code>fd_set</code> 中（通过 <code>FD_SET</code>）。</p><li><p>当 <code>select</code> 返回时，<strong><code>fd_set</code> 中的内容会被更新，仅保留那些已经“就绪”的文件描述符</strong>。</p><li><p>换句话说，<code>select</code> 会清除未就绪的文件描述符，只留下那些可以进行读、写或异常处理的文件描述符。</p></ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/select.h></span></span></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>select</span><span class=params>(<span class=keyword>int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class=line><span class=params><span class=function>          fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></table></figure><ul><li><code>nfds</code>: 要监视的最大文件描述符加1。<li><code>readfds</code>, <code>writefds</code>, <code>exceptfds</code>: 分别指向要监视的可读、可写及异常事件的文件描述符集合。<li><code>timeout</code>: 等待的时间限制，若设置为NULL则无限期等待。</ul><ol><li><code>FD_ZERO</code></ol><ul><li><p><strong>功能</strong>：清空一个 <code>fd_set</code> 集合。</p> <figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>void</span> <span class=title>FD_ZERO</span><span class=params>(fd_set *set)</span></span>;</span><br></pre></table></figure></ul><ol><li><code>FD_SET</code></ol><ul><li><p><strong>功能</strong>：将一个特定的文件描述符添加到一个 <code>fd_set</code> 集合中。</p> <figure class="highlight reasonml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>void <span class=constructor>FD_SET(<span class=params>int</span> <span class=params>fd</span>, <span class=params>fd_set</span> <span class=operator>*</span><span class=params>set</span>)</span>;</span><br></pre></table></figure></ul><ol><li><code>FD_CLR</code></ol><ul><li><p><strong>功能</strong>：从一个 <code>fd_set</code> 集合中移除一个特定的文件描述符。</p> <figure class="highlight reasonml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>void <span class=constructor>FD_CLR(<span class=params>int</span> <span class=params>fd</span>, <span class=params>fd_set</span> <span class=operator>*</span><span class=params>set</span>)</span>;</span><br></pre></table></figure></ul><ol><li><code>FD_ISSET</code></ol><ul><li><p><strong>功能</strong>：检查一个特定的文件描述符是否在某个 <code>fd_set</code> 集合中。</p> <figure class="highlight reasonml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>int</span> <span class=constructor>FD_ISSET(<span class=params>int</span> <span class=params>fd</span>, <span class=params>fd_set</span> <span class=operator>*</span><span class=params>set</span>)</span>;</span><br></pre></table></figure></ul><p>fd_set数据结构<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=comment>/* fd_set for select and pselect.  */</span></span><br><span class=line><span class=keyword>typedef</span> <span class=class><span class=keyword>struct</span></span></span><br><span class=line><span class=class>  {</span></span><br><span class=line>    <span class=comment>/* XPG4.2 requires this member name.  Otherwise avoid the name</span></span><br><span class=line><span class=comment>       from the global namespace.  */</span></span><br><span class=line><span class=meta>#<span class=meta-keyword>ifdef</span> __USE_XOPEN</span></span><br><span class=line>    <span class=comment>// __FD_SETSIZE = 1024 表示fd_set是个包含一个1024bit数组的结构体</span></span><br><span class=line>    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class=line><span class=meta># <span class=meta-keyword>define</span> __FDS_BITS(set) ((set)->fds_bits)</span></span><br><span class=line><span class=meta>#<span class=meta-keyword>else</span></span></span><br><span class=line>    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class=line><span class=meta># <span class=meta-keyword>define</span> __FDS_BITS(set) ((set)->__fds_bits)</span></span><br><span class=line><span class=meta>#<span class=meta-keyword>endif</span></span></span><br><span class=line>  } fd_set;</span><br></pre></table></figure><h4 id=select示例代码><a class=headerlink href=#select示例代码 title=select示例代码></a>select示例代码</h4><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br></pre><td class=code><pre><span class=line>fd_set read_fds, active_fds;</span><br><span class=line> <span class=keyword>int</span> max_fd = sockfd;</span><br><span class=line> std::vector<<span class=keyword>unsigned</span> <span class=keyword>int</span>> clients_fd;</span><br><span class=line> <span class=built_in>FD_ZERO</span>(&read_fds);</span><br><span class=line> <span class=built_in>FD_SET</span>(sockfd, &read_fds);</span><br><span class=line> <span class=keyword>while</span> (<span class=literal>true</span>) {</span><br><span class=line>   <span class=comment>// 轮询select 直到有连接</span></span><br><span class=line>   timeval timeout{<span class=number>1</span>, <span class=number>0</span>};</span><br><span class=line>   read_fds = active_fds;</span><br><span class=line>   <span class=comment>// select阻塞,直到相应文件描述符就绪(可读,可写或异常)</span></span><br><span class=line>   <span class=comment>// 成功返回时(>=1),fd_set内容更新,仅保留就绪的fd</span></span><br><span class=line>   <span class=keyword>int</span> ret = <span class=built_in>select</span>(max_fd + <span class=number>1</span>, &read_fds, <span class=literal>nullptr</span>, <span class=literal>nullptr</span>, &timeout);</span><br><span class=line>   <span class=built_in>errif</span>(ret < <span class=number>0</span>, <span class=string>"select failed"</span>);</span><br><span class=line></span><br><span class=line>   <span class=keyword>if</span> (<span class=built_in>FD_ISSET</span>(sockfd, &read_fds)) {</span><br><span class=line>     <span class=comment>// 服务器可读(有connect连接)</span></span><br><span class=line>     sockaddr_in client_addr;</span><br><span class=line>     <span class=keyword>socklen_t</span> client_addr_len = <span class=built_in><span class=keyword>sizeof</span></span>(client_addr);</span><br><span class=line>     <span class=built_in>bzero</span>(&client_addr, client_addr_len);</span><br><span class=line>     <span class=keyword>int</span> client_sockfd =</span><br><span class=line>         <span class=built_in>accept</span>(sockfd, (struct sockaddr *)&client_addr, &client_addr_len);</span><br><span class=line>     <span class=built_in>FD_SET</span>(client_sockfd, &active_fds);</span><br><span class=line>     max_fd = std::<span class=built_in>max</span>(client_sockfd, max_fd);</span><br><span class=line>     clients_fd.<span class=built_in>push_back</span>(client_sockfd);</span><br><span class=line></span><br><span class=line>     std::cout << <span class=string>"New connection, socket fd: "</span> << client_sockfd</span><br><span class=line>               << <span class=string>", IP: "</span> << <span class=built_in>inet_ntoa</span>(client_addr.sin_addr)</span><br><span class=line>               << <span class=string>", Port: "</span> << <span class=built_in>ntohs</span>(client_addr.sin_port) << std::endl;</span><br><span class=line>   }</span><br><span class=line>   <span class=keyword>for</span> (<span class=keyword>auto</span> it = clients_fd.<span class=built_in>begin</span>(); it != clients_fd.<span class=built_in>end</span>();) {</span><br><span class=line>     <span class=keyword>unsigned</span> <span class=keyword>int</span> client_fd = *it;</span><br><span class=line>     <span class=keyword>if</span> (<span class=built_in>FD_ISSET</span>(client_fd, &read_fds)) {</span><br><span class=line>       <span class=comment>//客户端可读数据</span></span><br><span class=line>       <span class=comment>// 读取数据</span></span><br><span class=line>       <span class=keyword>char</span> read_bytes[<span class=number>1024</span>]{};</span><br><span class=line>       <span class=keyword>size_t</span> bytes_len = <span class=built_in>read</span>(client_fd, read_bytes, <span class=built_in><span class=keyword>sizeof</span></span>(read_bytes));</span><br><span class=line>       <span class=keyword>if</span> (bytes_len <= <span class=number>0</span>) {</span><br><span class=line>         std::cout << <span class=string>"client closed...\n"</span>;</span><br><span class=line>         <span class=built_in>close</span>(client_fd);</span><br><span class=line>         <span class=built_in>FD_CLR</span>(client_fd, &active_fds);</span><br><span class=line>         it = clients_fd.<span class=built_in>erase</span>(it);</span><br><span class=line>         <span class=keyword>continue</span>;</span><br><span class=line>       } <span class=keyword>else</span> {</span><br><span class=line>         std::string resp =</span><br><span class=line>             <span class=string>"你好,你发送了"</span> + std::<span class=built_in>string</span>(read_bytes, bytes_len);</span><br><span class=line>         <span class=built_in>errif</span>(<span class=built_in>write</span>(client_fd, resp.<span class=built_in>c_str</span>(), resp.<span class=built_in>size</span>()) == <span class=number>-1</span>,</span><br><span class=line>               <span class=string>"write socket failed"</span>);</span><br><span class=line>         ++it;</span><br><span class=line>       }</span><br><span class=line>     } <span class=keyword>else</span> {</span><br><span class=line>       ++it;</span><br><span class=line>     }</span><br><span class=line>   }</span><br><span class=line> }</span><br><span class=line> <span class=keyword>for</span> (<span class=keyword>auto</span> &client_fd : clients_fd) {</span><br><span class=line>   <span class=comment>// 关闭所有客户端</span></span><br><span class=line>   <span class=built_in>close</span>(client_fd);</span><br><span class=line> }</span><br><span class=line> <span class=comment>// close 关闭服务端</span></span><br><span class=line> <span class=built_in>close</span>(sockfd);</span><br></pre></table></figure><p><strong>优点</strong><ul><li>支持跨平台使用，几乎所有类Unix系统都支持。</ul><p><strong>缺点</strong><ul><li><strong>文件描述符集合大小有限制</strong>（通常为1024）。<li>每次调用都需要重新构建文件描述符集合。<li>效率较低，随着监听的文件描述符数量增加性能下降明显。</ul><h3 id=poll><a class=headerlink href=#poll title=poll></a>poll</h3><p><code>poll</code>与<code>select</code>类似，但它使用了一个结构体数组来代替<code>select</code>中的位图。<p>这使得它可以处理更多数量的文件描述符，并且没有像<code>select</code>那样的固定上限。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTpoll.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>poll</span><span class=params>(struct pollfd *fds, <span class=keyword>nfds_t</span> nfds, <span class=keyword>int</span> timeout)</span></span>;</span><br></pre></table></figure><ul><li><code>fds</code>: 指向一个包含多个<code>pollfd</code>结构体的数组，每个结构体描述了一个文件描述符及其感兴趣的事件。<li><code>nfds</code>: 数组中元素的数量。<li><code>timeout</code>: 等待的时间限制，单位为毫秒。</ul><p>pollfd数据结构<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment>/* Data structure describing a polling request.  */</span></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>pollfd</span></span></span><br><span class=line><span class=class>  {</span></span><br><span class=line>    <span class=keyword>int</span> fd;			<span class=comment>/* File descriptor to poll.  */</span></span><br><span class=line>    <span class=keyword>short</span> <span class=keyword>int</span> events;		<span class=comment>/* Types of events poller cares about.  */</span></span><br><span class=line>    <span class=keyword>short</span> <span class=keyword>int</span> revents;		<span class=comment>/* Types of events that actually occurred.  */</span></span><br><span class=line>  };</span><br><span class=line></span><br></pre></table></figure><ul><li><p><strong><code>fd</code></strong>：要监视的文件描述符。</p><li><p><code>events</code></p> <p>：请求监视的事件类型，可以是以下标志的组合：</p> <ul><li><code>POLLIN</code>：有数据可读。<li><code>POLLPRI</code>：有紧急数据可读。<li><code>POLLOUT</code>：准备好写数据。<li><code>POLLRDHUP</code>（自 Linux 2.6.17 起）：TCP连接被对端关闭，或对端关闭了写入一半的连接。<li><code>POLLERR</code>：发生错误。<li><code>POLLHUP</code>：挂起。<li><code>POLLNVAL</code>：无效请求；指定的文件描述符无效。</ul><li><p><strong><code>revents</code></strong>：实际发生的事件，由内核在 <code>poll</code> 调用返回时填充。</p></ul><p>事件类型如下<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=comment>/* Event types that can be polled for.  These bits may be set in `events'</span></span><br><span class=line><span class=comment>   to indicate the interesting event types; they will appear in `revents'</span></span><br><span class=line><span class=comment>   to indicate the status of the file descriptor.  */</span></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> POLLIN		0x001		<span class=comment>/* There is data to read.  */</span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> POLLPRI		0x002		<span class=comment>/* There is urgent data to read.  */</span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> POLLOUT		0x004		<span class=comment>/* Writing now will not block.  */</span></span></span><br><span class=line></span><br><span class=line><span class=comment>/* Event types always implicitly polled for.  These bits need not be set in</span></span><br><span class=line><span class=comment>   `events', but they will appear in `revents' to indicate the status of</span></span><br><span class=line><span class=comment>   the file descriptor.  */</span></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> POLLERR		0x008		<span class=comment>/* Error condition.  */</span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> POLLHUP		0x010		<span class=comment>/* Hung up.  */</span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> POLLNVAL	0x020		<span class=comment>/* Invalid polling request.  */</span></span></span><br></pre></table></figure><h4 id=poll示例代码><a class=headerlink href=#poll示例代码 title=poll示例代码></a>poll示例代码</h4><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br></pre><td class=code><pre><span class=line>std::vector&LTpollfd> poll_fds;</span><br><span class=line>pollfd server_pollfd;</span><br><span class=line>server_pollfd.fd = sockfd;</span><br><span class=line>server_pollfd.events = POLLIN; <span class=comment>// 设置事件</span></span><br><span class=line>poll_fds.<span class=built_in>push_back</span>(server_pollfd);</span><br><span class=line><span class=keyword>while</span> (<span class=literal>true</span>) {</span><br><span class=line>  <span class=keyword>int</span> ret = <span class=built_in>poll</span>(poll_fds.<span class=built_in>data</span>(), poll_fds.<span class=built_in>size</span>(), <span class=number>-1</span>);</span><br><span class=line>  <span class=built_in>errif</span>(ret < <span class=number>0</span>, <span class=string>"poll error"</span>);</span><br><span class=line>  <span class=keyword>if</span> (poll_fds.<span class=built_in>at</span>(<span class=number>0</span>).revents & POLLIN) {</span><br><span class=line>    <span class=comment>// 数据读入事件</span></span><br><span class=line>    <span class=comment>// serverfd可读,即可accept</span></span><br><span class=line>    sockaddr_in client_addr{};</span><br><span class=line>    <span class=keyword>socklen_t</span> addr_len = <span class=built_in><span class=keyword>sizeof</span></span>(client_addr);</span><br><span class=line>    <span class=keyword>int</span> client_fd = <span class=built_in>accept</span>(sockfd, (struct sockaddr *)&client_addr,</span><br><span class=line>                           (<span class=keyword>socklen_t</span> *)&addr_len);</span><br><span class=line>    <span class=built_in>errif</span>(client_fd == <span class=number>-1</span>, <span class=string>"accept failed"</span>);</span><br><span class=line></span><br><span class=line>    pollfd client_pollfd;</span><br><span class=line>    client_pollfd.fd = client_fd;</span><br><span class=line>    client_pollfd.events = POLLIN;</span><br><span class=line>    poll_fds.<span class=built_in>push_back</span>(client_pollfd);</span><br><span class=line>    std::cout << <span class=string>"New connection, socket fd: "</span> << client_fd</span><br><span class=line>              << <span class=string>", IP: "</span> << <span class=built_in>inet_ntoa</span>(client_addr.sin_addr)</span><br><span class=line>              << <span class=string>", Port: "</span> << <span class=built_in>ntohs</span>(client_addr.sin_port) << std::endl;</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>for</span> (<span class=keyword>auto</span> it = poll_fds.<span class=built_in>begin</span>() + <span class=number>1</span>; it != poll_fds.<span class=built_in>end</span>();) {</span><br><span class=line>    <span class=keyword>char</span> bytes_read[<span class=number>1024</span>]{};</span><br><span class=line>    pollfd &client_pollfd = *it;</span><br><span class=line>    <span class=keyword>size_t</span> read_bytes_len =</span><br><span class=line>        <span class=built_in>read</span>(client_pollfd.fd, bytes_read, <span class=built_in><span class=keyword>sizeof</span></span>(bytes_read));</span><br><span class=line>    <span class=keyword>if</span> (read_bytes_len <= <span class=number>0</span>) {</span><br><span class=line>      <span class=comment>// 关闭</span></span><br><span class=line>      std::cout << <span class=string>"client closed...\n"</span>;</span><br><span class=line>      <span class=built_in>close</span>(client_pollfd.fd);</span><br><span class=line>      it = poll_fds.<span class=built_in>erase</span>(it);</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>      <span class=comment>// echo</span></span><br><span class=line>      std::string resp =</span><br><span class=line>          <span class=string>"你好,你的请求是"</span> + std::<span class=built_in>string</span>(bytes_read, read_bytes_len);</span><br><span class=line>      <span class=built_in>write</span>(client_pollfd.fd, resp.<span class=built_in>data</span>(), resp.<span class=built_in>size</span>());</span><br><span class=line>      ++it;</span><br><span class=line>    }</span><br><span class=line>  }</span><br><span class=line>}</span><br><span class=line>  <span class=comment>// 关闭所有客户端连接</span></span><br><span class=line>  <span class=keyword>for</span> (<span class=keyword>const</span> <span class=keyword>auto</span> &pfd : poll_fds) {</span><br><span class=line>      <span class=built_in>close</span>(pfd.fd);</span><br><span class=line>  }</span><br><span class=line></span><br></pre></table></figure><p><strong>优点</strong><ul><li>不受文件描述符数量的限制。<li>对于大量文件描述符的情况比<code>select</code>更高效。</ul><p><strong>缺点</strong><ul><li>在大量文件描述符的情况下，效率仍然不高，因为每次调用都需要遍历整个文件描述符列表。</ul><p>对于大量文件描述符的情况，<code>poll</code> 的性能优于 <code>select</code>，因为它不需要每次调用前都重新初始化文件描述符集合。<h3 id=epoll><a class=headerlink href=#epoll title=epoll></a>epoll</h3><ul><li><code>epoll</code>是Linux特有的高级IO多路复用机制，旨在克服<code>select</code>和<code>poll</code>的局限性。<li><p>它采用事件驱动的方式，只有当某个文件描述符有事件发生时才会被通知，而不是每次都检查所有文件描述符的状态。</p><li><p><code>epoll_create1</code>: 创建一个新的epoll实例。</p><li><code>epoll_ctl</code>: 向epoll实例添加、修改或删除关注的文件描述符。<li><code>epoll_wait</code>: 等待事件的发生。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTsys/epoll.h></span></span></span><br><span class=line></span><br><span class=line><span class=comment>// 创建epoll实例</span></span><br><span class=line><span class=comment>/* Creates an epoll instance.  Returns an fd for the new instance.</span></span><br><span class=line><span class=comment>   The "size" parameter is a hint specifying the number of file</span></span><br><span class=line><span class=comment>   descriptors to be associated with the new instance.  The fd</span></span><br><span class=line><span class=comment>   returned by epoll_create() should be closed with close().  */</span></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>epoll_create</span><span class=params>(<span class=keyword>int</span> size)</span></span>;</span><br><span class=line></span><br><span class=line><span class=comment>/* Same as epoll_create but with an FLAGS parameter.  The unused SIZE</span></span><br><span class=line><span class=comment>   parameter has been dropped.  */</span></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>epoll_create1</span><span class=params>(<span class=keyword>int</span> flags)</span></span>;</span><br><span class=line><span class=comment>// 控制epoll实例</span></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>epoll_ctl</span><span class=params>(<span class=keyword>int</span> epfd, <span class=keyword>int</span> op, <span class=keyword>int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class=line></span><br><span class=line><span class=comment>// 等待事件</span></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>epoll_wait</span><span class=params>(<span class=keyword>int</span> epfd, struct epoll_event *events, <span class=keyword>int</span> maxevents, <span class=keyword>int</span> timeout)</span></span>;</span><br></pre></table></figure><blockquote><p>当使用 <code>epoll_create</code> 或 <code>epoll_create1</code> 函数创建一个新的 <code>epoll</code> 实例时，<strong>Linux 内核会在内部创建一个“事件表”</strong>。<strong>这个事件表本质上是一个动态调整大小的数据结构，用来跟踪所有被注册到该 <code>epoll</code> 实例上的文件描述符及其感兴趣的事件类型</strong>（如可读、可写等）。通过这种方式，应用程序可以向内核注册多个文件描述符，并指定对每个文件描述符感兴趣的事件类型。</blockquote><p><strong>epoll_ctl</strong><ul><li><p><strong><code>epfd</code></strong>：指向由 <code>epoll_create</code> 或 <code>epoll_create1</code> 创建的 <code>epoll</code> 实例的文件描述符。</p><li><p><code>op</code></p> <p>：指定要执行的操作类型，可以是以下值之一：</p> <ul><li><strong><code>EPOLL_CTL_ADD</code></strong>：将新的文件描述符加入到 <code>epoll</code> 实例的监视列表中，并关联相应的事件。<li><strong><code>EPOLL_CTL_MOD</code></strong>：修改已经存在于 <code>epoll</code> 实例中的文件描述符所关注的事件。<li><strong><code>EPOLL_CTL_DEL</code></strong>：从 <code>epoll</code> 实例中移除一个文件描述符，不再监视其事件。</ul><li><p><strong><code>fd</code></strong>：要操作的目标文件描述符。</p><li><p><strong><code>event</code></strong>：指向 <code>struct epoll_event</code> 结构体的指针，包含与该文件描述符相关联的事件信息（当 <code>op</code> 是 <code>EPOLL_CTL_ADD</code> 或 <code>EPOLL_CTL_MOD</code> 时需要）。对于 <code>EPOLL_CTL_DEL</code> 操作，此参数可以为 <code>NULL</code>，因为此时仅关心移除文件描述符本身。</p></ul><p><strong>epoll_event结构体</strong><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>epoll_event</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>  <span class=keyword>uint32_t</span> events;	<span class=comment>/* Epoll events */</span></span><br><span class=line>  <span class=keyword>epoll_data_t</span> data;	<span class=comment>/* User data variable */</span></span><br><span class=line>} __EPOLL_PACKED;</span><br><span class=line></span><br><span class=line><span class=keyword>typedef</span> <span class=class><span class=keyword>union</span> <span class=title>epoll_data</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>  <span class=keyword>void</span> *ptr;</span><br><span class=line>  <span class=keyword>int</span> fd;</span><br><span class=line>  <span class=keyword>uint32_t</span> u32;</span><br><span class=line>  <span class=keyword>uint64_t</span> u64;</span><br><span class=line>} <span class=keyword>epoll_data_t</span>;</span><br></pre></table></figure><ul><li><p><strong><code>events</code></strong>：</p> <ul><li>表示需要监视的事件类型。<li>它是一个位掩码（bitmask），可以是以下标志的组合：<ul><li><strong><code>EPOLLIN</code></strong>：表示文件描述符可读（有数据可读）。<li><strong><code>EPOLLOUT</code></strong>：表示文件描述符可写（可以写入数据）。<li><strong><code>EPOLLRDHUP</code></strong>：表示对端关闭了连接或关闭了写入方向（自 Linux 2.6.17 起支持）。<li><strong><code>EPOLLPRI</code></strong>：表示有紧急数据可读（例如带外数据）。<li><strong><code>EPOLLERR</code></strong>：表示发生了错误。<li><strong><code>EPOLLHUP</code></strong>：表示挂起（hang up），通常表示对端关闭了连接。<li><strong><code>EPOLLET</code></strong>：启用边缘触发模式（Edge-Triggered, ET）。默认是水平触发模式（Level-Triggered, LT）。<li><strong><code>EPOLLONESHOT</code></strong>：表示事件只会触发一次，之后需要重新添加到 <code>epoll</code> 实例中。</ul></ul><li><p><strong><code>data</code></strong>：</p> <ul><li><p>这是一个联合体（union），允许用户将任意数据与文件描述符关联起来。</p><li><p>定义如下：</p> <figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>typedef</span> <span class=class><span class=keyword>union</span> <span class=title>epoll_data</span> {</span></span><br><span class=line>    <span class=keyword>void</span>    *ptr;  <span class=comment>// 指针类型</span></span><br><span class=line>    <span class=keyword>int</span>      fd;   <span class=comment>// 文件描述符</span></span><br><span class=line>    <span class=keyword>uint32_t</span> u32;  <span class=comment>// 32位无符号整数</span></span><br><span class=line>    <span class=keyword>uint64_t</span> u64;  <span class=comment>// 64位无符号整数</span></span><br><span class=line>} <span class=keyword>epoll_data_t</span>;</span><br></pre></table></figure><li><p>最常见的用法是通过 <code>fd</code> 字段存储文件描述符，以便在事件触发时快速定位对应的文件描述符。</p></ul></ul><h4 id=epoll示例代码><a class=headerlink href=#epoll示例代码 title=epoll示例代码></a>epoll示例代码</h4><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br></pre><td class=code><pre><span class=line><span class=keyword>int</span> epoll_fd = <span class=built_in>epoll_create1</span>(<span class=number>0</span>);</span><br><span class=line> <span class=built_in>errif</span>(epoll_fd == <span class=number>-1</span>, <span class=string>"epoll creation failed"</span>);</span><br><span class=line> <span class=keyword>const</span> <span class=keyword>int</span> MAX_EVENTS = <span class=number>10</span>;</span><br><span class=line> epoll_event ev, events[MAX_EVENTS];</span><br><span class=line> ev.events = POLLIN | EPOLLET; <span class=comment>// 水平触发模式</span></span><br><span class=line> ev.data.fd = sockfd;</span><br><span class=line> <span class=comment>// 添加服务端fd</span></span><br><span class=line> ret = <span class=built_in>epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, sockfd, &ev);</span><br><span class=line> <span class=built_in>errif</span>(ret == <span class=number>-1</span>, <span class=string>"ctl failed"</span>);</span><br><span class=line> <span class=keyword>while</span> (<span class=literal>true</span>) {</span><br><span class=line>   <span class=comment>// 等待事件</span></span><br><span class=line>   <span class=keyword>int</span> nfds = <span class=built_in>epoll_wait</span>(epoll_fd, events, MAX_EVENTS, <span class=number>-1</span>);</span><br><span class=line>   <span class=built_in>errif</span>(nfds == <span class=number>-1</span>, <span class=string>"epoll waut failed"</span>);</span><br><span class=line>   <span class=keyword>if</span> ((events[<span class=number>0</span>].data.fd == sockfd) && (events[<span class=number>0</span>].events & POLLIN)) {</span><br><span class=line>     <span class=comment>// accept就绪</span></span><br><span class=line>     sockaddr_in client_addr;</span><br><span class=line>     <span class=keyword>socklen_t</span> client_addr_len = <span class=built_in><span class=keyword>sizeof</span></span>(client_addr);</span><br><span class=line>     <span class=keyword>int</span> client_fd =</span><br><span class=line>         <span class=built_in>accept</span>(sockfd, (struct sockaddr *)&client_addr, &client_addr_len);</span><br><span class=line>     epoll_event ev;</span><br><span class=line>     ev.events = EPOLLIN | EPOLLET; <span class=comment>// 水平触发模式</span></span><br><span class=line>     ev.data.fd = client_fd;</span><br><span class=line>     <span class=comment>// 将客户端连接加入epoll实例</span></span><br><span class=line>     ret = <span class=built_in>epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, client_fd, &ev);</span><br><span class=line>     <span class=built_in>errif</span>(ret == <span class=number>-1</span>, <span class=string>"ctl failed"</span>);</span><br><span class=line>   }</span><br><span class=line></span><br><span class=line>   <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i < MAX_EVENTS; i++) {</span><br><span class=line>     <span class=keyword>if</span> (events[i].events & POLLIN) {</span><br><span class=line>       <span class=keyword>int</span> client_fd = events[i].data.fd;</span><br><span class=line>       <span class=comment>// read就绪</span></span><br><span class=line>       <span class=keyword>char</span> bytes_read[<span class=number>1024</span>]{};</span><br><span class=line>       <span class=keyword>size_t</span> bytes_read_len = <span class=built_in>read</span>(client_fd, bytes_read, <span class=built_in><span class=keyword>sizeof</span></span>(bytes_read));</span><br><span class=line>       <span class=keyword>if</span> (bytes_read_len <= <span class=number>0</span>) {</span><br><span class=line>         std::cout << <span class=string>"client connection closed...\n"</span>;</span><br><span class=line>         <span class=built_in>close</span>(client_fd);</span><br><span class=line>         <span class=built_in>epoll_ctl</span>(epoll_fd, EPOLL_CTL_DEL, client_fd, <span class=literal>nullptr</span>);</span><br><span class=line>       } <span class=keyword>else</span> {</span><br><span class=line>         std::string resp =</span><br><span class=line>             <span class=string>"你好,你发送了:"</span> + std::<span class=built_in>string</span>(bytes_read, bytes_read_len);</span><br><span class=line>         <span class=built_in>write</span>(client_fd, resp.<span class=built_in>data</span>(), resp.<span class=built_in>size</span>());</span><br><span class=line>       }</span><br><span class=line>     }</span><br><span class=line>   }</span><br><span class=line>     <span class=built_in>close</span>(epoll_fd);</span><br></pre></table></figure><ul><li>默认情况下，<code>epoll</code> 使用水平触发模式（Level-Triggered, LT），即只要文件描述符处于就绪状态，<code>epoll_wait</code> 就会一直返回。<li>通过设置 <code>EPOLLET</code> 标志，可以启用边缘触发模式（Edge-Triggered, ET）。在这种模式下，只有当文件描述符的状态发生变化时，<code>epoll_wait</code> 才会返回。</ul><p><strong>优点</strong><ul><li>高效地管理大量文件描述符。<li>只返回活跃的文件描述符，减少了不必要的上下文切换。<li>支持边缘触发（Edge Triggered）和水平触发（Level Triggered）两种模式。</ul><p><strong>缺点</strong><ul><li>仅适用于Linux操作系统，不具有跨平台兼容性。</ul><p><strong>注意事项</strong><ol><li><strong>边缘触发模式的使用</strong>：<ul><li>在边缘触发模式下，必须一次性读取完所有可用数据，否则可能会丢失事件。</ul><li><strong>错误处理</strong>：<ul><li>示例代码中包含了基本的错误处理，在实际应用中应更全面地处理各种异常情况。</ul><li><strong>缓冲区大小</strong>：<ul><li>确保 <code>BUFFER_SIZE</code> 足够大，以避免数据截断。</ul></ol><p>​ 设置epoll触发事件时可以设置水平触发(LT)和边缘触发(ET).<p>如果使用 LT 模式，只要文件描述符处于就绪状态（例如，对于读操作而言，意味着有数据可读），每次调用 <code>epoll_wait()</code> 都会返回该文件描述符。这意味着<strong>即使没有完全读取所有可用的数据，在后续的 <code>epoll_wait()</code> 调用中，只要还有未处理的数据，这个文件描述符仍然会被标记为就绪</strong>。<p>​ ET 模式仅在文件描述符的状态发生变化时触发一次通知（即从不可读变为可读或反之）。这意味着如果你在一个 <code>epoll_wait()</code> 返回后没有完全处理完所有可用的数据，<strong>那么在下一次调用 <code>epoll_wait()</code> 之前，即使文件描述符仍然处于就绪状态，也不会再次收到通知。因此，你需要确保一次性读取尽可能多的数据直到没有更多数据为止</strong>。<ul><li><p>选择 LT 还是 ET 主要取决于你的应用需求</p> <ul><li>如果你需要简单的实现，并且对偶尔的重复通知不敏感，LT 是更好的选择。<li>如果你追求高性能，并且能够保证每次都能高效地处理所有数据，ET 则可能更适合。</ul><li><p>通常建议</p> <ul><li>对于大多数情况，默认使用 LT 模式即可满足需求。<li>在需要处理大量并发连接并且希望减少系统开销的情况下，可以考虑使用 ET 模式，但需要小心处理以避免错过事件。</ul> <h4 id=LT-模式示例><a title="LT 模式示例" class=headerlink href=#LT-模式示例></a><strong>LT 模式示例</strong></h4><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>epoll_event</span> <span class=title>event</span>;</span></span><br><span class=line>event.events = EPOLLIN;</span><br><span class=line>event.data.fd = listen_sock;</span><br><span class=line></span><br><span class=line><span class=built_in>epoll_ctl</span>(epfd, EPOLL_CTL_ADD, listen_sock, &event);</span><br><span class=line></span><br><span class=line><span class=keyword>while</span> (<span class=literal>true</span>) {</span><br><span class=line>    <span class=keyword>int</span> n = <span class=built_in>epoll_wait</span>(epfd, events, MAX_EVENTS, <span class=number>-1</span>);</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < n; i++) {</span><br><span class=line>        <span class=keyword>if</span> (events[i].data.fd == listen_sock) {</span><br><span class=line>            <span class=comment>// 接受新连接...</span></span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=comment>// 处理现有连接上的数据...</span></span><br><span class=line>            <span class=comment>// LT 模式下，如果有剩余数据未读，下次 epoll_wait 仍会通知</span></span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=ET-模式示例><a title="ET 模式示例" class=headerlink href=#ET-模式示例></a><strong>ET 模式示例</strong></h4><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>epoll_event</span> <span class=title>event</span>;</span></span><br><span class=line>event.events = EPOLLIN | EPOLLET; <span class=comment>// 启用 ET 模式</span></span><br><span class=line>event.data.fd = listen_sock;</span><br><span class=line></span><br><span class=line><span class=built_in>epoll_ctl</span>(epfd, EPOLL_CTL_ADD, listen_sock, &event);</span><br><span class=line></span><br><span class=line><span class=keyword>while</span> (<span class=literal>true</span>) {</span><br><span class=line>    <span class=keyword>int</span> n = <span class=built_in>epoll_wait</span>(epfd, events, MAX_EVENTS, <span class=number>-1</span>);</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < n; i++) {</span><br><span class=line>        <span class=keyword>if</span> (events[i].data.fd == listen_sock) {</span><br><span class=line>            <span class=comment>// 接受新连接...</span></span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=comment>// ET 模式下，需要循环读取直到 EAGAIN 或 EWOULDBLOCK</span></span><br><span class=line>            <span class=keyword>while</span> ((nread = <span class=built_in>read</span>(events[i].data.fd, buf, <span class=built_in><span class=keyword>sizeof</span></span>(buf))) > <span class=number>0</span>) {</span><br><span class=line>                <span class=comment>// 处理读取到的数据...</span></span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (nread == <span class=number>-1</span> && errno != EAGAIN) {</span><br><span class=line>                <span class=built_in>perror</span>(<span class=string>"read error"</span>);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <ul><li><strong>ET 模式的特点</strong>：只会在文件描述符状态发生变化时触发一次通知，因此需要开发者确保在每次事件触发时尽可能多地处理数据。<li>为什么需要 <code>while</code> 循环<ul><li>确保读取所有可用数据，避免遗漏。<li><strong>防止因为缓冲区大小限制或数据分段到达而导致未处理的数据残留</strong>。<li>提高数据处理的效率和可靠性。</ul></ul></ul><blockquote><p>在网络编程中，特别是在高并发场景下，以下情况可能导致数据未被完全读取：<ul><li><strong>TCP 流的特性</strong>：<ul><li>TCP 是面向流的协议，数据是以字节流的形式传输的，而不是固定大小的消息包。接收方可能会收到部分数据，也可能收到多个消息拼接在一起的数据。<li>即使当前已经触发了“可读”事件，你并不能假设一次 <code>read()</code> 调用就能读取到完整的数据块。</ul><li><strong>缓冲区的限制</strong>：<ul><li>每次调用 <code>read()</code> 时，操作系统内核会将数据从内核缓冲区复制到用户空间缓冲区。如果用户空间缓冲区不足以容纳所有数据，则只能读取一部分数据。<li>剩余的数据仍然存在于内核缓冲区中，但在 ET 模式下，如果没有新的事件触发，这些数据将不会被通知给应用程序。</ul></ul></blockquote><div class=table-container><table><thead><tr><th>特性<th><code>select</code><th><code>poll</code><th><code>epoll</code><tbody><tr><td><strong>跨平台支持</strong><td>是<td>是<td>否（仅Linux）<tr><td><strong>最大文件描述符数</strong><td>有限制（通常是1024）<td>无限制<td>无限制<tr><td><strong>性能</strong><td>随文件描述符数量增加而降低<td>相对较好，但仍有改进空间<td>非常高效，适合高并发场景<tr><td><strong>事件通知方式</strong><td>轮询所有文件描述符<td>轮询所有文件描述符<td>仅通知活跃的文件描述符</table></div><h2 id=定时器><a class=headerlink href=#定时器 title=定时器></a>定时器</h2><p>实现了一个定时器,定时器包括截至时间,回调函数以及client_data.<p>超时的时候调用回调函数,执行将fd从epoll中去除并close(fd),user_count—的操作. 并实现定时器队列,按照定时器的截至事件升序.<p>webserver包含多个client_data,client_data包含fd,address以及定时器用于控制超时事件.<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line>WebServer::WebServer() {</span><br><span class=line>  <span class=comment>// http_conn类对象</span></span><br><span class=line>  users = <span class=keyword>new</span> http_conn[MAX_FD]; <span class=comment>// 为每个连接创建一个http_conn和client_data对象</span></span><br><span class=line>  <span class=comment>// 用户数据</span></span><br><span class=line>  users_timer = <span class=keyword>new</span> client_data[MAX_FD];</span><br><span class=line>  <span class=comment>// root文件夹路径</span></span><br><span class=line>  <span class=keyword>char</span> server_path[<span class=number>200</span>];</span><br><span class=line>  getcwd(server_path, <span class=number>200</span>);</span><br><span class=line>	</span><br><span class=line>  <span class=comment>// 设置文件根目录</span></span><br><span class=line>  <span class=keyword>char</span> root[<span class=number>6</span>] = <span class=string>"/root"</span>;</span><br><span class=line>  m_root = (<span class=keyword>char</span> *)<span class=built_in>malloc</span>(<span class=built_in>strlen</span>(server_path) + <span class=built_in>strlen</span>(root) + <span class=number>1</span>);</span><br><span class=line>  <span class=built_in>strcpy</span>(m_root, server_path);</span><br><span class=line>  <span class=built_in>strcat</span>(m_root, root);</span><br><span class=line>}</span><br></pre></table></figure><h2 id=相关书籍和资料><a class=headerlink href=#相关书籍和资料 title=相关书籍和资料></a>相关书籍和资料</h2><ul><li><a href=https://zhuanlan.zhihu.com/p/689466361 rel=noopener target=_blank>《Linux高性能服务器编程》</a><li><a href=https://www.manongbook.com/linux/681.html rel=noopener target=_blank>Linux多线程服务端编程</a><li><a href=https://zhuanlan.zhihu.com/p/460399249 rel=noopener target=_blank>《TCP/IP网络编程》学习笔记 - 知乎</a></ul><p><a href=https://mp.weixin.qq.com/s?__biz=MzAxNzU2MzcwMw==&mid=2649274278&idx=4&sn=caa323faf0c51d882453c0e0c6a62282&chksm=83ffbefeb48837e841a6dbff292217475d9075e91cbe14042ad6e55b87437dcd01e6d9219e7d&cur_album_id=1339230165934882817&scene=189#wechat_redirect rel=noopener target=_blank>最新版Web服务器项目详解 - 02 半同步半反应堆线程池（上）</a><p>Unix环境高级编程<p>Unix网络编程<p>类似项目github上有很多<p><a href=https://github.com/forthespada/MyPoorWebServer rel=noopener target=_blank>forthespada/MyPoorWebServer: 一款可运行的基于C++ 实现的WebServer服务器，基于《TCPIP网络编程》和《Linux高性能服务器编程》实现的服务器项目。</a><p><a href=https://github.com/linyacool/WebServer rel=noopener target=_blank>linyacool/WebServer: A C++ High Performance Web Server</a><p><a href=https://github.com/Wlgls/30daysCppWebServer rel=noopener target=_blank>Wlgls/30daysCppWebServer</a></p><link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script></div><div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div class=popular-posts-header>相关文章</div><ul class=popular-posts><li class=popular-posts-item><div class=popular-posts-title><a href=\2025\02\27\Linux网络编程入门\ rel=bookmark>Linux网络编程入门</a></div><li class=popular-posts-item><div class=popular-posts-title><a href=\2024\10\16\现代C-中的异常处理\ rel=bookmark>现代C++中的异常处理</a></div><li class=popular-posts-item><div class=popular-posts-title><a href=\2024\10\09\也许需要知道的c-概念\ rel=bookmark>也许需要知道的c++概念</a></div><li class=popular-posts-item><div class=popular-posts-title><a href=\2024\10\05\现代c-并发深入\ rel=bookmark>现代c++并发深入</a></div></ul><div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a href=https://www.sekyoro.top/2025/03/20/TinyHttpServer%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/ title=TinyWebServer项目学习>https://www.sekyoro.top/2025/03/20/TinyHttpServer项目学习/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div><footer class=post-footer><div class=post-tags><a href=/tags/c/ rel=tag><i class="fa fa-tag"></i> c++</a><a href=/tags/webserver/ rel=tag><i class="fa fa-tag"></i> webserver</a></div><div class=post-nav><div class=post-nav-item><a href=/2025/03/20/Java%E9%A1%B9%E7%9B%AE%E5%A4%A7%E8%B5%8F-%E5%AE%9E%E4%B9%A0%E7%89%88/ rel=prev title=Java项目大赏(实习版)> <i class="fa fa-chevron-left"></i> Java项目大赏(实习版) </a></div><div class=post-nav-item></div></div></footer></article></div><!-- 评论区 --><div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%B9%B6%E5%8F%91%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95><span class=nav-number>1.</span> <span class=nav-text>并发同步方法</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#sem-t><span class=nav-number>1.1.</span> <span class=nav-text>sem_t</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#pthread-mutex-t><span class=nav-number>1.2.</span> <span class=nav-text>pthread_mutex_t</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#pthread-cond-t><span class=nav-number>1.3.</span> <span class=nav-text>pthread_cond_t</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%BC%82%E6%AD%A5%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5><span class=nav-number>2.</span> <span class=nav-text>异步日志写入</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0><span class=nav-number>3.</span> <span class=nav-text>数据库连接池</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%BA%BF%E7%A8%8B%E6%B1%A0><span class=nav-number>4.</span> <span class=nav-text>线程池</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F><span class=nav-number>4.1.</span> <span class=nav-text>事件处理模式</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#Reactor%E6%A8%A1%E5%BC%8F%E5%92%8CProactor%E6%A8%A1%E5%BC%8F><span class=nav-number>4.1.1.</span> <span class=nav-text>Reactor模式和Proactor模式</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F><span class=nav-number>4.2.</span> <span class=nav-text>并发编程模式</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F><span class=nav-number>4.2.1.</span> <span class=nav-text>半同步/半异步模式</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%BC%8F><span class=nav-number>4.2.2.</span> <span class=nav-text>半同步/半反应堆模式</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%B8%8E%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E7%9A%84%E5%8C%BA%E5%88%AB><span class=nav-number>4.2.3.</span> <span class=nav-text>与半同步/半反应堆的区别</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8><span class=nav-number>5.</span> <span class=nav-text>IO多路复用</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#select><span class=nav-number>5.1.</span> <span class=nav-text>select</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#select%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81><span class=nav-number>5.1.1.</span> <span class=nav-text>select示例代码</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#poll><span class=nav-number>5.2.</span> <span class=nav-text>poll</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#poll%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81><span class=nav-number>5.2.1.</span> <span class=nav-text>poll示例代码</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#epoll><span class=nav-number>5.3.</span> <span class=nav-text>epoll</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#epoll%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81><span class=nav-number>5.3.1.</span> <span class=nav-text>epoll示例代码</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#LT-%E6%A8%A1%E5%BC%8F%E7%A4%BA%E4%BE%8B><span class=nav-number>5.3.2.</span> <span class=nav-text>LT 模式示例</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#ET-%E6%A8%A1%E5%BC%8F%E7%A4%BA%E4%BE%8B><span class=nav-number>5.3.3.</span> <span class=nav-text>ET 模式示例</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%AE%9A%E6%97%B6%E5%99%A8><span class=nav-number>6.</span> <span class=nav-text>定时器</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%9B%B8%E5%85%B3%E4%B9%A6%E7%B1%8D%E5%92%8C%E8%B5%84%E6%96%99><span class=nav-number>7.</span> <span class=nav-text>相关书籍和资料</span></a></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>236</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>16</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>211</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a><li class=links-of-blogroll-item><a href=https://www.lllomh.com/ rel=noopener target=_blank title=https://www.lllomh.com/>芈渡</a><li class=links-of-blogroll-item><a href=https://protool-ten.vercel.app/ rel=noopener target=_blank title=https://protool-ten.vercel.app/>protools</a></ul></div><div class="motion-element announcement"><div class=title></div><p class=content><p class=date></div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>文章词云</h3><div class="widget tagcloud" id=myCanvasContainer><canvas height=250 id=resCanvas style=width:100% width=250><ul class=tag-list itemprop=keywords><li class=tag-list-item><a class=tag-list-link href=/tags/c/ rel=tag>c++</a><span class=tag-list-count>5</span><li class=tag-list-item><a class=tag-list-link href=/tags/webserver/ rel=tag>webserver</a><span class=tag-list-count>1</span></ul></canvas></div></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2025</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>2.6m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>39:03</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer></div><script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script><script src=/lib/anime.min.js></script><script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script><script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/pisces.js></script><script src=/js/next-boot.js></script><script src=/js/bookmark.js></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	'.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script><script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script><script src=/js/algolia-search.js></script><script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script><div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div><script charset=utf-8 defer src=/js/tagcanvas.js></script><script charset=utf-8 defer src=/js/tagcloud.js></script><script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script><script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script><script src=/js/src/activate-power-mode.min.js></script><script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script>
<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"0F9LEEVW82","apiKey":"78839e9f9be09d081c5c4da81975cd19","indexName":"sekyoblog_sec","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content=学习很潮很流行的Java以及相关框架. name=description><meta content=article property=og:type><meta content=mini-java-guide property=og:title><meta content=https://www.sekyoro.top/2025/03/09/mini-java-guide/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content=学习很潮很流行的Java以及相关框架. property=og:description><meta content=zh_CN property=og:locale><meta content=https://s2.loli.net/2025/03/19/XA1uEi8Q4GBOYeL.png property=og:image><meta content=https://s2.loli.net/2025/03/19/oHwP9Ub47rKRhyu.png property=og:image><meta content=https://s2.loli.net/2025/03/19/BG9x3zCAEjU7IlX.png property=og:image><meta content=https://s2.loli.net/2025/03/19/GyptQ1F3KcbhIZo.png property=og:image><meta content=https://s2.loli.net/2025/03/18/JHyvrF3A1SiuIel.png property=og:image><meta content=https://s2.loli.net/2025/03/18/VPxZDv3EGAcUpXs.png property=og:image><meta content=https://s2.loli.net/2025/03/18/zGuoR1B98kEKLxS.png property=og:image><meta content=https://s2.loli.net/2025/03/18/cQr1mCLgliJtbvz.png property=og:image><meta content=https://s2.loli.net/2025/03/18/GrE4zd586Jh9jAO.png property=og:image><meta content=https://s2.loli.net/2025/03/18/DvQmr3tiWezX2xq.png property=og:image><meta content=https://s2.loli.net/2025/03/19/wiUs3FnHfLKgjkQ.png property=og:image><meta content=https://s2.loli.net/2025/03/19/zEqWugTiRUsaK7C.png property=og:image><meta content=https://s2.loli.net/2025/03/19/Dq6nC1eRwIlMUmS.png property=og:image><meta content=https://s2.loli.net/2025/03/19/ycB948TkMLeEwmr.png property=og:image><meta content=https://s2.loli.net/2025/03/19/qfkja1eAIUKObEX.png property=og:image><meta content=https://s2.loli.net/2025/03/11/yhg79kQxwJiCBO6.png property=og:image><meta content=https://s2.loli.net/2025/03/11/XR4zx7ycNQiSBlt.png property=og:image><meta content=https://s2.loli.net/2025/03/14/8tKapiLbw7csMlP.png property=og:image><meta content=https://s2.loli.net/2025/03/14/ZL6IFGzBio5Pbc2.png property=og:image><meta content=https://s2.loli.net/2025/03/19/WxNStmTMp2D5viR.png property=og:image><meta content=https://s2.loli.net/2025/03/19/8Dlxb1zAqTgOWyF.png property=og:image><meta content=https://s2.loli.net/2025/03/19/S8WiOA2HE5gwVUT.png property=og:image><meta content=https://s2.loli.net/2025/03/19/y1U9gKj6fHmab8k.png property=og:image><meta content=https://s2.loli.net/2025/03/19/bBamC6ND3n7TcEO.png property=og:image><meta content=https://s2.loli.net/2025/03/19/yTXM2Brukzw7IC8.png property=og:image><meta content=https://s2.loli.net/2025/03/19/yIabTL2S9J4vDlX.png property=og:image><meta content=https://s2.loli.net/2025/03/19/A8KrfdjOShZTsnU.png property=og:image><meta content=https://s2.loli.net/2025/03/20/iZdH8kUa9LYAFQW.png property=og:image><meta content=https://s2.loli.net/2025/03/20/BMyrksQT5S6xlqf.png property=og:image><meta content=https://s2.loli.net/2025/03/30/CYqToSF1d9ax7lA.png property=og:image><meta content=https://s2.loli.net/2025/03/30/8PW4irnVQOo1U7M.png property=og:image><meta content=https://s2.loli.net/2025/03/30/Y9PDFgfRLC8Bdp6.png property=og:image><meta content=https://s2.loli.net/2025/03/30/Uqb7n83iNwsRuoB.png property=og:image><meta content=https://s2.loli.net/2025/03/30/cBvlUxGDnWa84Yp.png property=og:image><meta content=https://www.runoob.com/wp-content/uploads/2018/09/maven-package-build-phase.png property=og:image><meta content=https://s2.loli.net/2025/03/29/qaAURO3uTdrxlEY.png property=og:image><meta content=https://s2.loli.net/2025/03/26/F7Ebo35RH6XIQft.png property=og:image><meta content=https://s2.loli.net/2025/03/26/LjCFSxblAyBGEhd.png property=og:image><meta content=https://s2.loli.net/2025/03/29/TolUSndakcOP3ti.png property=og:image><meta content=https://s2.loli.net/2025/03/29/zI1SvEeYGsfFkpy.png property=og:image><meta content=https://s2.loli.net/2025/03/29/TmRpyswKoazBdO3.png property=og:image><meta content=https://s2.loli.net/2025/03/29/dIRX1Fx5kQ2gPra.png property=og:image><meta content=https://s2.loli.net/2025/03/30/7TQF6gL1Cro5w2R.png property=og:image><meta content=https://s2.loli.net/2025/03/29/H6AyOzY18MKCcPJ.png property=og:image><meta content=https://s2.loli.net/2025/03/30/MXwuylP5fqpNBz4.png property=og:image><meta content=https://s2.loli.net/2025/03/30/jpQ7nwHN8rg34Jq.png property=og:image><meta content=https://s2.loli.net/2025/03/30/KcSBGzw6C1W5Iho.png property=og:image><meta content=https://s2.loli.net/2025/03/30/86OFTKqeLhJwMxY.png property=og:image><meta content=https://s2.loli.net/2025/03/30/xTDM5wFYCa4g1rU.png property=og:image><meta content=https://s2.loli.net/2025/03/30/VrLeJvdSgTYf79C.png property=og:image><meta content=https://s2.loli.net/2025/03/30/gA2pIsEbMSnZ3vc.png property=og:image><meta content=https://s2.loli.net/2025/03/30/dILW1GOJw7h5UAu.png property=og:image><meta content=https://s2.loli.net/2025/03/30/3B4fXRhOl1Zqgoe.png property=og:image><meta content=https://s2.loli.net/2025/03/30/P2bx8Qfzch4Wgsq.png property=og:image><meta content=https://s2.loli.net/2025/03/30/G7SjImNUFL8g1un.png property=og:image><meta content=https://s2.loli.net/2025/03/30/FajEoXNZCSVrk3H.png property=og:image><meta content=https://s2.loli.net/2025/03/30/wAtkHS1Z5zXsBpy.png property=og:image><meta content=https://s2.loli.net/2025/03/30/idITAkyWSDp6m5M.png property=og:image><meta content=https://s2.loli.net/2025/03/30/CRmDU9XvnuzKfbj.png property=og:image><meta content=https://s2.loli.net/2025/03/30/afxo4iHyzStjgPR.png property=og:image><meta content=https://s2.loli.net/2025/03/09/S12tudvJjEeoXTp.png property=og:image><meta content=https://s2.loli.net/2025/03/10/u1fMijOcWHJGRTF.png property=og:image><meta content=https://s2.loli.net/2025/03/10/ckaRKM5JnPW9FEB.png property=og:image><meta content=https://s2.loli.net/2025/03/10/odIl2cm87SBxpk3.png property=og:image><meta content=https://s2.loli.net/2025/03/10/NjzLtSgZ9UKIQWC.png property=og:image><meta content=https://s2.loli.net/2025/03/26/sjPGpMUlIBCfXrg.png property=og:image><meta content=https://s2.loli.net/2025/03/26/ALHs6CkcYGnB8me.png property=og:image><meta content=https://s2.loli.net/2025/03/26/4JMB7i9FwZpSLVW.png property=og:image><meta content=https://s2.loli.net/2025/03/26/sKmpPezAdXafgn4.png property=og:image><meta content=https://s2.loli.net/2025/03/26/UhEFYszHKGQjTBt.png property=og:image><meta content=https://s2.loli.net/2025/03/26/8d5MsA1VqQovZXc.png property=og:image><meta content=https://s2.loli.net/2025/03/26/n8DoQbwTMVa5FZY.png property=og:image><meta content=https://s2.loli.net/2025/03/26/4BPamIhnFEviQWy.png property=og:image><meta content=https://s2.loli.net/2025/03/26/D25tMOAiSJjCx1n.png property=og:image><meta content=https://s2.loli.net/2025/03/25/Xij1Npoe8xrqcS3.png property=og:image><meta content=https://s2.loli.net/2025/03/25/axN3ZGnYCrV2dt1.png property=og:image><meta content=https://s2.loli.net/2025/03/25/Aaehzxr8njmpCbq.png property=og:image><meta content=https://s2.loli.net/2025/03/25/I2n1hxzA8XteQP5.png property=og:image><meta content=https://s2.loli.net/2025/03/25/2FKGxVs6pUu5d3g.png property=og:image><meta content=https://s2.loli.net/2025/03/25/KnfBu1UqX9DrAEW.png property=og:image><meta content=https://s2.loli.net/2025/03/25/UYWLnOzjM3FitKD.png property=og:image><meta content=https://s2.loli.net/2025/03/25/vSzoKf3ibdCDQw2.png property=og:image><meta content=https://s2.loli.net/2025/03/25/ObYogUBk1F5Xi3C.png property=og:image><meta content=https://s2.loli.net/2025/03/25/eVhk1jS2WB9H7Za.png property=og:image><meta content=https://s2.loli.net/2025/03/25/KvqyuzAp4XeFJE8.png property=og:image><meta content=https://s2.loli.net/2025/03/25/hL2vHmQEdOAuocX.png property=og:image><meta content=2025-03-09T02:10:08.000Z property=article:published_time><meta content=2025-07-19T08:05:01.826Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content="个人博客 技术学习 计算机 互联网 人工智能" property=article:tag><meta content=summary name=twitter:card><meta content=https://s2.loli.net/2025/03/19/XA1uEi8Q4GBOYeL.png name=twitter:image><link href=https://www.sekyoro.top/2025/03/09/mini-java-guide/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>mini-java-guide | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2025/03/09/mini-java-guide/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>mini-java-guide</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2025-03-09 10:10:08" datetime=2025-03-09T10:10:08+08:00>2025-03-09</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-07-19 16:05:01" datetime=2025-07-19T16:05:01+08:00 itemprop=dateModified>2025-07-19</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>179k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>2:43</span> </span></div></header><div class=post-body itemprop=articleBody><p>学习很潮很流行的Java以及相关框架.<br><span id=more></span><p><a href=https://liaoxuefeng.com/books/java/introduction/index.html rel=noopener target=_blank>简介 - Java教程 - 廖雪峰的官方网站</a><h1 id=Java基础><a class=headerlink href=#Java基础 title=Java基础></a>Java基础</h1><h2 id=Java基础-1><a class=headerlink href=#Java基础-1 title=Java基础></a>Java基础</h2><h3 id=1-java-lang><a title="1. java.lang.*" class=headerlink href=#1-java-lang></a>1. java.lang.*</h3><p>这是默认导入的包，包含基本类和接口。<ul><li><strong>Object</strong>：所有类的超类。<li><strong>String</strong>：不可变字符串类，用于文本处理。<li><strong>StringBuilder/StringBuffer</strong>：可变字符串类，适用于频繁修改字符串的场景。<code>StringBuffer</code>是线程安全的版本。<li><strong>System</strong>：提供系统相关的信息和操作，如<code>System.out.println()</code>打印输出。<li><strong>Math</strong>：提供数学计算的方法，如三角函数、对数等。<li><strong>Integer, Double 等包装类</strong>：基本类型的对象表示形式，支持自动装箱/拆箱。</ul><h3 id=2-java-util><a title="2. java.util.*" class=headerlink href=#2-java-util></a>2. java.util.*</h3><p>包含了集合框架、日期时间工具、随机数生成器等实用工具类。<ul><li><strong>Collection 接口及其实现类</strong>（如ArrayList, LinkedList, HashSet, TreeSet等）：提供了不同类型的集合实现。<li><strong>Map 接口及其实现类</strong>（如HashMap, TreeMap等）：键值对存储结构。<li><strong>Iterator</strong>：遍历集合的标准方式。<li><strong>Date, Calendar, LocalDate, LocalDateTime</strong>（Java 8+）：处理日期和时间。<li><strong>Random</strong>：生成伪随机数。<li><strong>Arrays</strong>：提供操作数组的各种静态方法。</ul><p>函数式编程(function)包提供了一些功能接口<ul><li><p><strong><code>Function&LTT, R></code></strong>：接受一个参数并返回结果。</p><li><p><strong><code>Predicate&LTT></code></strong>：接受一个输入参数并返回布尔值。方法签名：`boolean test(T t)``</p><li><p><code>`BiFunction&LTT, U, R></code>：接受两个输入参数并返回结果。<strong>方法签名</strong>：<code>R apply(T t, U u)</code></p><li><p><code>UnaryOperator&LTT></code> ：接受一个参数并返回相同类型的值，是 <code>Function&LTT, T></code> 的特化形式。 <strong>方法签名</strong>：<code>T apply(T t)</code></p><li><p><code>BinaryOperator&LTT></code>：接受两个相同类型的参数并返回相同类型的值，是 <code>BiFunction&LTT, T, T></code> 的特化形式。 <strong>方法签名</strong>：`T apply(T t, T u)```</p><li><p><code>BiPredicate&LTT, U></code>：接受两个输入参数并返回布尔值。<strong>方法签名</strong>：<code>boolean test(T t, U u)</code>,用于需要基于两个输入值进行条件判断的场景</p><li><p><strong><code>Supplier&LTT></code></strong>：适用于你需要从无到有地“生产”数据的场合。它不接收任何参数，但是可以返回你所需要的类型的实例。这使得它非常适合用于延迟初始化、配置加载等场景。</p><li><strong><code>BiConsumer&LTT, U></code></strong>：当你需要处理或操作一对相关的值，并且这些操作的结果并不重要（即不需要返回值）时非常有用。比如，你可能想要记录一组键值对的日志，或者将两个值合并在一起而不关心最终结果。</ul><h3 id=3-java-io><a title="3. java.io.*" class=headerlink href=#3-java-io></a>3. java.io.*</h3><p>提供输入输出流的支持，用于读写文件或进行网络通信。<ul><li><strong>InputStream/OutputStream</strong>：字节流基类。<li><strong>Reader/Writer</strong>：字符流基类。<li><strong>File</strong>：文件或目录路径名的抽象表示形式。<li><strong>BufferedReader/BufferedWriter, BufferedInputStream/BufferedOutputStream</strong>：提高I/O效率的缓冲类。</ul><h3 id=4-java-nio><a title="4. java.nio.*" class=headerlink href=#4-java-nio></a>4. java.nio.*</h3><p>新的I/O API，提供了更高效的非阻塞I/O操作。<ul><li><strong>Path, Paths</strong>：用于处理文件系统路径。<li><strong>Files</strong>：提供对文件的操作方法。<li><strong>ByteBuffer</strong>及其他缓冲区类型：用于高效地管理字节序列。</ul><h3 id=5-java-net><a title="5. java.net.*" class=headerlink href=#5-java-net></a>5. java.net.*</h3><p>网络编程相关的API。<ul><li><strong>URL, URI</strong>：统一资源定位符/标识符。<li><strong>URLConnection</strong>：与URL建立连接。<li><strong>Socket, ServerSocket</strong>：TCP/IP套接字编程的基础类。<li><strong>DatagramPacket, DatagramSocket</strong>：UDP协议的支持。</ul><h3 id=6-java-text><a title="6. java.text.*" class=headerlink href=#6-java-text></a>6. java.text.*</h3><p>用于格式化和解析文本。<ul><li><strong>NumberFormat, DecimalFormat</strong>：数字格式化。<li><strong>DateFormat, SimpleDateFormat</strong>：日期格式化。<li><strong>MessageFormat</strong>：根据模式格式化消息。</ul><h3 id=7-java-time><a title="7. java.time.*" class=headerlink href=#7-java-time></a>7. java.time.*</h3><p>Java 8引入的新日期时间API。<ul><li><strong>Instant</strong>：表示时间线上的一点。<li><strong>LocalDate, LocalTime, LocalDateTime</strong>：分别表示不带时区的日期、时间和日期时间。<li><strong>ZonedDateTime, OffsetDateTime</strong>：带有时区信息的日期时间。</ul><h3 id=8-并发相关><a title="8. 并发相关" class=headerlink href=#8-并发相关></a>8. 并发相关</h3><ul><li><strong>Thread</strong>：创建和控制线程。<li><strong>Runnable</strong>：线程执行的目标接口。<li><strong>ExecutorService, Executors</strong>：更高级别的线程管理。<li><strong>Lock, ReentrantLock</strong>：比同步块更灵活的锁定机制。<li><strong>ConcurrentHashMap</strong>：线程安全的哈希表实现。</ul><h3 id=9-其他><a title="9. 其他" class=headerlink href=#9-其他></a>9. 其他</h3><ul><li><strong>Optional</strong>（Java 8+）：避免空指针异常的一种设计模式。<li><strong>Stream API</strong>（Java 8+）：提供了一种高效且易于使用的集合元素处理方式。</ul><div class=table-container><table><thead><tr><th>访问修饰符<th>同一类<th>同一包<th>子类（不同包）<th>全局<tbody><tr><td><code>public</code><td>是<td>是<td>是<td>是<tr><td><code>protected</code><td>是<td>是<td>是<td>否<tr><td>默认<td>是<td>是<td>否<td>否<tr><td><code>private</code><td>是<td>否<td>否<td>否</table></div><h3 id=内部类><a class=headerlink href=#内部类 title=内部类></a>内部类</h3><p>成员内部类,静态内部类,局部内部类,匿名内部类<p><img alt=image-20250319142346062 data-src=https://s2.loli.net/2025/03/19/XA1uEi8Q4GBOYeL.png><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=comment>// 成员内部类</span></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>outerclass</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> String age;</span><br><span class=line>    <span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>innerclass</span> </span>{</span><br><span class=line>        <span class=function><span class=keyword>void</span> <span class=title>display</span><span class=params>()</span> </span>{</span><br><span class=line>            System.out.println(<span class=string>"This is an inner class"</span>);</span><br><span class=line>            System.out.println(name);</span><br><span class=line>            System.out.println(age);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><img alt=image-20250319142856906 data-src=https://s2.loli.net/2025/03/19/oHwP9Ub47rKRhyu.png><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=class><span class=keyword>class</span> <span class=title>innercls</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>display</span><span class=params>()</span> </span>{</span><br><span class=line>        System.out.println(<span class=string>"This is an inner class"</span>);</span><br><span class=line>        System.out.println(innercls.<span class=keyword>this</span>);</span><br><span class=line>        System.out.println(age);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><img alt=image-20250319144727002 data-src=https://s2.loli.net/2025/03/19/BG9x3zCAEjU7IlX.png><p><img alt=image-20250319150803696 data-src=https://s2.loli.net/2025/03/19/GyptQ1F3KcbhIZo.png><h3 id=集合Collection与Map><a class=headerlink href=#集合Collection与Map title=集合Collection与Map></a>集合Collection与Map</h3><p>数组和集合的区别：<p>数组<ul><li><p><strong>固定大小</strong>：数组一旦创建，其大小是固定的，不能动态增加或减少元素。</p><li><p><strong>类型安全</strong>：数组可以是基本数据类型（如 <code>int[]</code>, <code>double[]</code>）或对象类型（如 <code>String[]</code>）。对于对象类型的数组，所有元素都必须是该类的实例或者 <code>null</code>。</p><li><p><strong>内存连续</strong>：数组中的元素在内存中是连续存储的，这使得访问速度非常快，因为可以通过计算偏移量直接访问任何元素（时间复杂度为 O(1)）。</p><li><p>声明方式</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>int</span>[] numbers = <span class=keyword>new</span> <span class=keyword>int</span>[<span class=number>5</span>]; <span class=comment>// 创建一个包含5个整数的数组</span></span><br><span class=line>String[] names = {<span class=string>"Alice"</span>, <span class=string>"Bob"</span>}; <span class=comment>// 初始化时赋值</span></span><br></pre></table></figure></ul><p><strong>优点</strong><ul><li>访问速度快，支持随机访问。<li>对于小规模、固定数量的数据集非常适合。</ul><h5 id=List><a class=headerlink href=#List title=List></a>List</h5><p><strong>定义与特性</strong><ul><li><p><strong>动态大小</strong>：<code>List</code> 接口的主要实现类（如 <code>ArrayList</code>, <code>LinkedList</code>）允许动态添加和删除元素，这意味着你可以根据需要扩展或缩小列表的大小。</p><li><p><strong>接口与实现</strong>：<code>List</code> 是一个接口，常用的实现包括 <code>ArrayList</code> 和 <code>LinkedList</code>。<code>ArrayList</code> 底层基于数组实现，而 <code>LinkedList</code> 则是一个双向链表。</p><li><p><strong>类型安全</strong>：<code>List</code> 只能存储对象，不能直接存储基本数据类型（但可以使用自动装箱/拆箱功能处理基本数据类型）。</p><li><p>声明方式</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>List&LTString> names = <span class=keyword>new</span> ArrayList<>();</span><br><span class=line>names.add(<span class=string>"Alice"</span>);</span><br><span class=line>names.add(<span class=string>"Bob"</span>);</span><br></pre></table></figure></ul><p><strong>优点</strong><ul><li>动态大小，方便添加和删除元素。<li>提供了丰富的操作方法，比如 <code>add()</code>, <code>remove()</code>, <code>get()</code>, <code>indexOf()</code> 等等。<li>更好的抽象层次，代码更加灵活易读。</ul><p><strong>缺点</strong><ul><li>相比于数组，某些操作可能效率较低，例如在 <code>ArrayList</code> 中插入或删除中间位置的元素会导致其他元素移动；而在 <code>LinkedList</code> 中查找元素则需要从头或尾遍历整个列表。</ul><p>ArrayList使用数组实现,查询快,增删慢<p>LinkedList使用双向链表实现,查询慢,增删快,尤其对于首尾操作<p><img alt=image-20250318215401958 data-src=https://s2.loli.net/2025/03/18/JHyvrF3A1SiuIel.png><h5 id=Set><a class=headerlink href=#Set title=Set></a>Set</h5><p><img alt=image-20250318220123427 data-src=https://s2.loli.net/2025/03/18/VPxZDv3EGAcUpXs.png><p>HashSet使用哈希表实现,增删改查性能较好<p><img alt=image-20250318220818128 data-src=https://s2.loli.net/2025/03/18/zGuoR1B98kEKLxS.png><p><img alt=image-20250318221151248 data-src=https://s2.loli.net/2025/03/18/cQr1mCLgliJtbvz.png><p>HashSet去重主要依赖于两个关键方法：<code>hashCode()</code> 和 <code>equals()</code>。<ol><li><strong>hashCode() 方法</strong>：<ul><li>当你尝试将一个对象添加到 HashSet 中时，HashSet 会首先调用这个对象的 <code>hashCode()</code> 方法来计算该对象的哈希值。<li>这个哈希值决定了对象在内部哈希表中的存储位置（即所谓的“桶”）。</ul><li><strong>equals() 方法</strong>：<ul><li>如果两个对象有相同的哈希值（或者它们被分配到了同一个桶中），HashSet 将使用 <code>equals()</code> 方法来进一步检查这两个对象是否真正相等。<li>如果 <code>equals()</code> 返回 <code>true</code>，则认为这两个对象是重复的，新对象不会被添加到集合中。如果 <code>equals()</code> 返回 <code>false</code>，即使哈希值相同，这两个对象也被认为是不同的，并且都会被添加到集合中。</ul></ol><p>对于自定义类的对象，如果你希望它们能够正确地在 HashSet 中进行去重，你需要重写 <code>hashCode()</code> 和 <code>equals()</code> 方法，以确保具有相同业务含义的对象返回相同的哈希码并且 <code>equals()</code> 方法也返回 <code>true</code>。<p>TreeSet底层基于红黑树,可排序,不重复,无索引<p><img alt=image-20250318231528714 data-src=https://s2.loli.net/2025/03/18/GrE4zd586Jh9jAO.png><p><img alt=image-20250318234747847 data-src=https://s2.loli.net/2025/03/18/DvQmr3tiWezX2xq.png><h5 id=Map><a class=headerlink href=#Map title=Map></a>Map</h5><p><img alt=image-20250319103421264 data-src=https://s2.loli.net/2025/03/19/wiUs3FnHfLKgjkQ.png><p><img alt=image-20250319104523905 data-src=https://s2.loli.net/2025/03/19/zEqWugTiRUsaK7C.png><p>Map的遍历方式<p><img alt=image-20250319110144222 data-src=https://s2.loli.net/2025/03/19/Dq6nC1eRwIlMUmS.png><p><strong>使用 for-each 循环和 entrySet()</strong><p>这是最常用的遍历方式之一，因为它提供了对键和值的访问。<figure class="highlight ada"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>for</span> (Map.<span class=keyword>Entry</span>&LTString, Integer> <span class=keyword>entry</span> : <span class=type>map.entrySet</span>()) {</span><br><span class=line>    System.<span class=keyword>out</span>.println(<span class=keyword>entry</span>.getKey() + <span class=string>": "</span> + <span class=keyword>entry</span>.getValue());</span><br><span class=line>}</span><br></pre></table></figure><p><strong>使用迭代器</strong><p>使用迭代器可以更灵活地控制遍历过程。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>Iterator&LTMap.Entry&LTString, Integer>> iterator = map.entrySet().iterator();</span><br><span class=line><span class=keyword>while</span> (iterator.hasNext()) {</span><br><span class=line>    Map.Entry&LTString, Integer> entry = iterator.next();</span><br><span class=line>    System.out.println(entry.getKey() + <span class=string>": "</span> + entry.getValue());</span><br><span class=line>}</span><br></pre></table></figure><p><strong>使用 Java 8 的 Stream API</strong><p>通过 <code>stream()</code> 方法可以利用 Stream API 来遍历或进行其他操作。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>map.entrySet().stream().forEach(entry -> </span><br><span class=line>    System.out.println(entry.getKey() + <span class=string>": "</span> + entry.getValue())</span><br><span class=line>);</span><br></pre></table></figure><p>或者对于某些特定的操作，比如过滤、映射等：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>map.entrySet().stream()</span><br><span class=line>   .filter(entry -> entry.getValue() > <span class=number>1</span>)</span><br><span class=line>   .forEach(entry -> System.out.println(entry.getKey()));</span><br></pre></table></figure><p><img alt=image-20250319114156720 data-src=https://s2.loli.net/2025/03/19/ycB948TkMLeEwmr.png><p>Stream流包括中间方法和最终方法,中间方法使用filter,map,调用完成后会返回新的流<p><img alt=image-20250319120025921 data-src=https://s2.loli.net/2025/03/19/qfkja1eAIUKObEX.png><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line>List&LTString> alist = <span class=keyword>new</span> ArrayList<>();</span><br><span class=line>alist.add(<span class=string>"a"</span>);</span><br><span class=line>alist.add(<span class=string>"b"</span>);</span><br><span class=line>List&LTString> list = alist.stream().map((String a) -> a + <span class=string>"a"</span>).toList();</span><br><span class=line>List&LTDouble> blist = <span class=keyword>new</span> ArrayList<>();</span><br><span class=line>list.stream().filter(s-> !s.isEmpty()).forEach(System.out::println);</span><br><span class=line></span><br><span class=line>list.stream().sorted(Comparator.comparingDouble(String::length).reversed()).forEach(System.out::println);</span><br><span class=line>blist.stream().sorted(Double::compare).forEach(System.out::println);</span><br><span class=line></span><br><span class=line><span class=comment>// 去重 limit只需要一个参数 skip跳过前几个</span></span><br><span class=line>blist.stream().distinct().skip(<span class=number>1</span>).limit(<span class=number>2</span>).forEach(System.out::println);</span><br><span class=line></span><br><span class=line><span class=comment>// 转换成map</span></span><br><span class=line>list.stream().collect(Collectors.toMap(Function.identity(), String::length)).forEach((k, v) -> System.out.println(k + <span class=string>":"</span> + v));</span><br><span class=line></span><br><span class=line>Stream&LTString> a = Stream.of(<span class=string>"a"</span>, <span class=string>"b"</span>, <span class=string>"c"</span>);</span><br><span class=line>Stream&LTInteger> integerStream = Stream.of(<span class=number>1</span>, <span class=number>2</span>);</span><br><span class=line><span class=comment>// 合并两个流</span></span><br><span class=line>Stream.concat(a, integerStream).forEach(System.out::println);</span><br></pre></table></figure><p>java集合类->实现的数据结构<p>Collections List Set HashSet LinkedHashSet TreeSet<p>Map<p>HashMap LinkedHashMap TreeMap<p><strong><code>HashMap</code></strong><ul><li><strong>底层实现：</strong> JDK 8 之前是<strong>数组 + 链表</strong>；JDK 8 及之后是<strong>数组 + 链表/红黑树</strong>。当链表长度超过阈值（默认为 8）时，链表会转换为红黑树，以提高查找效率（从 O(N) 优化到 O(log N)）。<li><strong>特点：</strong><ul><li><strong>非线程安全：</strong> 在多线程环境下，如果不进行同步处理，可能出现数据不一致或死循环（早期版本）等问题。<li><strong>允许键和值为 <code>null</code>：</strong> 最多允许一个键为 <code>null</code>，允许多个值为 <code>null</code>。<li><strong>无序性：</strong> 不保证元素的迭代顺序。<li><strong>性能：</strong> 增删查的平均时间复杂度为 O(1)。</ul><li><strong>适用场景：</strong> 单线程环境或需要高性能的非线程安全哈希表场景。</ul><p>Hashtable(线程安全)<p><strong><code>Hashtable</code></strong><ul><li><strong>底层实现：</strong> 也是基于<strong>数组 + 链表</strong>。<li><strong>特点：</strong><ul><li><strong>线程安全：</strong> 所有公共方法都使用了 <code>synchronized</code> 关键字进行同步，因此是线程安全的。<li><strong>不允许键和值为 <code>null</code>：</strong> 如果尝试插入 <code>null</code> 键或 <code>null</code> 值，会抛出 <code>NullPointerException</code>。<li><strong>性能：</strong> 由于同步开销，性能比 <code>HashMap</code> 低。</ul></ul><p>ArrayList与LinkedList区别<p>动态数组 连续内存 查询O(1) 增删需要移动元素O(N)<p>双向链表 查询O(N) 首位增删O(1)<p>HashMap原理,如何扩容<p>数组+链表/红黑树 插入元素时进行哈希,使用链地址法解决哈希冲突<p>当 <code>HashMap</code> 中的元素数量 <code>size</code> 达到 <code>capacity * loadFactor</code> 时，<code>HashMap</code> 就会进行扩容操作。这个过程在 <code>resize()</code> 方法中实现。<h4 id=扩容流程：><a class=headerlink href=#扩容流程： title=扩容流程：></a>扩容流程：</h4><ol><li><strong>创建新数组：</strong><ul><li><code>HashMap</code> 会创建一个新的 <code>Node</code> 数组，其容量是原数组的两倍。例如，如果原容量是 16，新容量就是 32。</ul><li><strong>数据迁移（Rehash）：</strong><ul><li>这是扩容中最耗时的一步。<code>HashMap</code> 会遍历原数组中的每一个桶。<li>对于每个桶中的链表或红黑树，会将其中的所有 <code>Node</code> 元素<strong>重新计算哈希值和在新数组中的索引位置</strong>，然后移动到新数组中对应的桶里。</ul></ol><p>为什么是两倍扩容？为什么是 2 的幂次方？<ul><li><strong>两倍扩容：</strong> 使得 <code>capacity</code> 始终保持为 2 的幂次方，这对于通过位运算 <code>hash & (capacity - 1)</code> 来快速计算索引至关重要。如果 <code>capacity</code> 不是 2 的幂次方，那么 <code>hash % capacity</code> 的性能会降低，并且哈希值分布可能不均匀，增加冲突。<li><strong>计算索引的优化：</strong> 当容量从 <code>N</code> 扩容到 <code>2N</code> 时，一个键在旧数组中的索引是 <code>hash & (N - 1)</code>。在新数组中，它的索引是 <code>hash & (2N - 1)</code>。<ul><li>对于每个 <code>Node</code>，它的新的索引位置要么和旧索引相同，要么是旧索引 <code>+ N</code>。<li>这个判断依据是 <code>(hash & N)</code> 是否为 <code>0</code>。如果为 <code>0</code>，则新索引不变；如果不为 <code>0</code>，则新索引是旧索引 <code>+ N</code>。<li>这种设计避免了对每个元素重新进行复杂的取模运算，<strong>显著提高了数据迁移的效率</strong>。</ul></ul><p>在 JDK 8 中，<code>resize</code> 过程也进行了优化，它不再需要重新计算每个元素的哈希值，而是利用了容量是 2 的幂次方的特性。<p>当容量从 <code>N</code> 变为 <code>2N</code> 时，对于一个节点 <code>e</code>，它的新索引只会有两种情况：<code>e.hash & (N-1)</code> (即原位置) 或者 <code>e.hash & (N-1) + N</code> (即原位置 + N)。 这个判断可以简化为查看 <code>e.hash</code> 的第 <code>N</code> 位（即 <code>(hash & N)</code>）是 <code>0</code> 还是 <code>1</code>。<ul><li>如果 <code>(hash & N) == 0</code>，则节点仍在原索引位置。<li>如果 <code>(hash & N) != 0</code>，则节点会移动到 <code>原索引 + N</code> 的位置。</ul><p>这样，在扩容时，每个桶的链表（或红黑树）可以被<strong>分成两条链表（或红黑树）</strong>，一条留在原位置，另一条移动到新位置（原位置 + N），从而大大提高了数据迁移的效率，避免了逐个重新哈希。<p>红黑树 ->B,B+树区别<p>红黑树是一种<strong>自平衡的二叉查找树（Binary Search Tree, BST）</strong>。它通过给节点着色（红色或黑色）并遵循一系列规则来保证树的平衡，<strong>确保任何路径从根节点到叶子节点的最长路径不会超过最短路径的两倍</strong>，<strong>从而使所有操作的时间复杂度保持在 O(logN)。</strong><p><strong>平衡通过颜色和旋转：</strong> 通过节点的颜色（红/黑）属性和插入/删除时的<strong>旋转（Rotations）</strong>和<strong>重新着色（Recoloring）</strong>操作来维持近似平衡。<p><strong>所有数据都在节点中：</strong> 每个节点都存储着实际的键值对。<p><strong>高度：</strong> 树的高度相对较小，但比 AVL 树（另一种平衡二叉树）可能略高，但其插入和删除的平均性能更好。<h3 id=B-树-B-Tree><a title="B 树 (B-Tree)" class=headerlink href=#B-树-B-Tree></a>B 树 (B-Tree)</h3><ul><li><strong>基本概念：</strong> B 树是一种<strong>多路平衡查找树</strong>。与二叉树不同，B 树的每个节点可以有<strong>多个子节点</strong>（通常多于两个）。它的设计核心是为了<strong>优化磁盘 I/O 操作</strong>，因为磁盘读写是块（block）为单位的，B 树通过增加节点的分支数（阶数）来降低树的高度，从而减少磁盘访问次数。<li><strong>核心特性：</strong><ol><li><strong>多路（M 阶树）：</strong> 每个节点可以有 <code>M</code> 个子节点（<code>M > 2</code>），并包含 <code>M-1</code> 个键。<li><strong>节点内有序：</strong> 每个节点中的键值是排序的。<li><strong>节点内存储数据：</strong> <strong>非叶子节点和叶子节点都可以存储实际的键值数据</strong>（或指向数据的指针）。<li><strong>所有叶子节点在同一层：</strong> 这保证了从根到任何叶子节点的查找路径长度相同，因此查找效率稳定。<li><strong>为磁盘优化：</strong> 节点的大小通常被设计为与磁盘块大小相匹配，一次磁盘 I/O 可以读取更多的键。</ol><li><strong>典型应用场景：</strong><ul><li><strong>文件系统和数据库索引：</strong> B 树被广泛应用于文件系统（如 NTFS, HFS+）和某些数据库系统（如 MongoDB）的索引结构。<li><strong>数据量大，无法完全加载到内存：</strong> 当数据存储在磁盘等外部存储介质上，且需要最小化磁盘 I/O 次数时，B 树是理想选择。</ul></ul><hr><h3 id=3-B-树-B-Tree><a title="3. B+ 树 (B+ Tree)" class=headerlink href=#3-B-树-B-Tree></a>3. B+ 树 (B+ Tree)</h3><ul><li><p><strong>基本概念：</strong> B+ 树是 B 树的一种<strong>变体</strong>，它对 B 树进行了进一步的优化，使其更适合于<strong>数据库索引</strong>和文件系统。B+ 树的核心特点是<strong>所有的数据都存储在叶子节点，并且叶子节点之间通过链表连接</strong>。</p><li><p><strong>核心特性：</strong></p> <ol><li><strong>多路（M 阶树）：</strong> 与 B 树类似，每个节点可以有 <code>M</code> 个子节点。<li><strong>非叶子节点只存储键（索引）：</strong> 非叶子节点（内部节点）只存储键（或索引），不存储实际的键值数据。这使得每个非叶子节点可以存储更多的键，从而降低树的高度，进一步减少磁盘 I/O。<li><strong>所有数据都在叶子节点：</strong> 所有的实际键值数据（或指向数据的指针）都存储在<strong>叶子节点</strong>中。<li><strong>叶子节点通过链表连接：</strong> 所有叶子节点构成一个<strong>有序的链表</strong>。<li><strong>所有键都在叶子节点出现：</strong> 即使是存在于非叶子节点中的键，也会在叶子节点中再次出现。</ol><li><p><strong>典型应用场景：</strong></p> <ul><li><strong>关系型数据库索引（如 MySQL 的 InnoDB 存储引擎）：</strong> 这是 B+ 树最主要的应用场景。<li><strong>需要高效的范围查询和全表扫描：</strong> 由于叶子节点通过链表连接且包含所有数据，范围查询变得非常高效，只需找到起始叶子节点，然后沿着链表遍历即可。全表扫描也只需遍历叶子节点链表。</ul> <h3 id=红黑树、B-树、B-树的主要区别总结><a title="红黑树、B 树、B+ 树的主要区别总结" class=headerlink href=#红黑树、B-树、B-树的主要区别总结></a>红黑树、B 树、B+ 树的主要区别总结</h3><p>| 特性 | 红黑树 (Red-Black Tree) | B 树 (B-Tree) | B+ 树 (B+ Tree) |<br>| ——————— | —————————————————————————————— | ———————————————————————- | —————————————————————————————— |<br>| <strong>结构类型</strong> | <strong>二叉查找树</strong> (每个节点最多 2 个子节点) | <strong>多路查找树</strong> (每个节点可以有 M 个子节点) | <strong>多路查找树</strong> (B 树的变体，每个节点可以有 M 个子节点) |<br>| <strong>平衡方式</strong> | 节点着色 (红/黑) + 旋转 + 重新着色 | 节点分裂/合并 (所有叶子节点在同一层) | 节点分裂/合并 (所有叶子节点在同一层) |<br>| <strong>数据存储</strong> | <strong>所有节点</strong>都存储键值对 | <strong>非叶子节点和叶子节点</strong>都可能存储键值数据 | <strong>只有叶子节点</strong>存储键值数据，非叶子节点只存储键（索引） |<br>| <strong>查询路径</strong> | 从根到目标节点的路径长度可能不同 (近似平衡) | 从根到任何键的路径长度相同 (所有叶子在同一层) | <strong>所有查找必须达到叶子节点</strong>，路径长度相同，查询效率稳定 |<br>| <strong>范围查询</strong> | 效率相对较低，需要中序遍历 | 效率一般，需要进行多节点的中序遍历 | <strong>效率高</strong>，所有叶子节点通过链表连接，可顺序遍历 |<br>| <strong>磁盘 I/O</strong> | 针对内存设计，<strong>不考虑磁盘 I/O 优化</strong>，树高较高，可能导致多次 I/O | 为磁盘优化，降低树高，减少 I/O 次数 | <strong>进一步优化磁盘 I/O</strong>，非叶子节点只存索引，可装更多键，树更矮胖，且范围查询更高效 |<br>| <strong>典型应用</strong> | 内存中的集合 (<code>TreeMap</code>, <code>std::map</code>) | 文件系统 (部分)、一些 NoSQL 数据库 (如 MongoDB) | <strong>关系型数据库索引</strong> (如 MySQL 的 InnoDB), 文件系统 |<br>| <strong>父节点冗余</strong> | 无 | 有 (键可能出现在父节点和其子节点中) | <strong>有</strong> (非叶子节点的键也会出现在其子节点中，最终在叶子节点中) |</p></ul><p>如果你主要处理<strong>内存中的数据</strong>，且需要高效的<strong>单点查找、插入和删除</strong>（且对范围查询不那么敏感），<strong>红黑树</strong>通常是更好的选择，因为它实现相对简单，且在内存中性能优异。<p>如果你处理<strong>大量数据，需要存储在磁盘上</strong>，并且要<strong>最小化磁盘 I/O 次数</strong>，<strong>B 树</strong>是一个好的选择。<p>如果你处理的是<strong>数据库索引</strong>或需要<strong>频繁进行范围查询</strong>的场景，<strong>B+ 树</strong>无疑是最佳选择，因为它通过将所有数据集中在叶子节点并用链表连接，极大地优化了范围查找和全表扫描的性能。<p>concurrentHashMap实现 JDK7 分段锁 JDK8+ CAS+synchronized+Node<p>JDK 8 对 <code>ConcurrentHashMap</code> 进行了<strong>彻底的重构</strong>，放弃了分段锁的设计，转而采用 <strong>CAS（Compare-And-Swap）+ <code>synchronized</code> + 红黑树</strong> 的混合策略。<p>核心思想：<p><strong>取消 Segment 概念：</strong> JDK 8 中不再有 <code>Segment</code> 类。取而代之的是一个由 <code>Node</code> 数组组成的哈希表。<ol><li><strong>锁的粒度：</strong><ul><li><strong>读操作：</strong> 大部分读操作仍然是无锁的，通过 <code>volatile</code> 和 <code>final</code> 关键字保证可见性。<li><strong>写操作：</strong> 写操作（put、remove）只锁定发生冲突的哈希桶的<strong>头节点（Node）</strong>。当多个线程操作不同的哈希桶时，它们之间不会互相阻塞，实现了更高的并发度。<li><strong><code>synchronized</code> 代替 <code>ReentrantLock</code>：</strong> JDK 8 使用 <code>synchronized</code> 关键字替代了 <code>ReentrantLock</code>。这是因为 JDK 8 对 <code>synchronized</code> 关键字进行了大量优化，使其性能已经非常接近甚至超越了 <code>ReentrantLock</code>，并且代码实现更为简洁。</ul><li><strong>链表转红黑树：</strong> 与 <code>HashMap</code> 类似，当链表长度超过阈值（默认为 8）时，链表会转换为红黑树，以提高查找效率（从 O(N) 优化到 O(log N)）。这在哈希冲突严重时能有效避免性能下降。<li><strong>CAS 操作：</strong> 在进行一些非阻塞操作（如扩容时的迁移、<code>size</code> 统计）时，会利用 CAS 操作来保证原子性。例如，在修改 <code>size</code> 变量时，会使用 <code>CAS</code> 操作。</ol><p><code>ConcurrentHashMap</code> 在 JDK 7 中的实现 (分段锁 Segment)<p>在 JDK 7 中，<code>ConcurrentHashMap</code> 主要通过<strong>分段锁（Segment）</strong>的机制来实现高并发。<p>核心思想：<ol><li><strong>分段（Segmentation）：</strong> 整个 <code>ConcurrentHashMap</code> 被分成若干个独立的段（Segment），每个段都是一个独立的 <code>ReentrantLock</code>。默认情况下，通常有 16 个或更多个段，这意味着理论上可以支持 16 个或更多个并发的写入操作。<li><strong>写操作的并发：</strong> 当一个线程需要写入（put、remove）数据时，它只需要锁定数据所在的那个 Segment，而其他线程仍然可以并发地访问（读写）其他 Segment。这大大减少了锁的粒度。<li><strong>读操作的并发：</strong> 大多数读操作（get）是无锁的。它通过 <code>volatile</code> 关键字来保证数据的可见性，允许多个线程同时读取。在某些情况下（如 Segment 的 <code>modCount</code> 发生变化），可能需要进行二次检查以确保数据一致性。<li><strong>结构：</strong><ul><li>内部有一个 <code>Segment</code> 数组，<code>Segment</code> 继承自 <code>ReentrantLock</code>。<li>每个 <code>Segment</code> 内部包含一个 <code>HashEntry</code> 数组（类似于 <code>HashMap</code> 的底层数组）和链表结构。<li>哈希函数会先确定键属于哪个 Segment，然后再在该 Segment 内部计算哈希值，定位到具体的 <code>HashEntry</code> 数组索引。</ul></ol><p>多线程安全环境下使用集合,线程安全的集合.<p><strong>面试题：</strong> 如何在多线程环境下使用集合？请列举并解释几种线程安全的集合类。<ul><li><strong><code>Vector</code> 和 <code>Hashtable</code>：</strong><ul><li><strong>原理：</strong> 通过在每个方法上加 <code>synchronized</code> 关键字实现粗粒度同步（锁住整个对象）。<li><strong>缺点：</strong> 性能低下，因为同一时间只有一个线程能访问集合的任何方法，并发度很低。</ul><li><strong><code>Collections.synchronizedList/Set/Map()</code>：</strong><ul><li><strong>原理：</strong> 这是一系列工厂方法，它返回一个由底层非线程安全集合（如 <code>ArrayList</code>, <code>HashMap</code>）包装而成的线程安全版本。同样是通过 <code>synchronized</code> 关键字对所有方法进行同步。<li><strong>缺点：</strong> 与 <code>Vector</code>/<code>Hashtable</code> 类似，也是粗粒度同步，性能瓶颈明显。</ul><li><strong><code>ConcurrentHashMap</code>：</strong> (推荐用于并发Map)<ul><li><strong>原理：</strong> 采用<strong>分段锁（Segment）</strong>（JDK 7）或 <strong>CAS + Synchronized + Node</strong>（JDK 8）实现更细粒度的并发控制。在 JDK 8 中，取消了 Segment，直接使用 <code>synchronized</code> 锁住哈希桶的头节点，结合 CAS 操作，实现了更高的并发度。<li><strong>特点：</strong> 读操作通常不需要加锁，写操作只锁住受影响的部分，大大提高了并发性能。<li><strong>适用场景：</strong> 高并发场景下对 Map 的读写操作。</ul><li><strong><code>CopyOnWriteArrayList</code> 和 <code>CopyOnWriteArraySet</code>：</strong> (推荐用于并发List/Set，写少读多)<ul><li><strong>原理：</strong> 写时复制（Copy-On-Write）。当对集合进行写操作（添加、修改、删除）时，会先复制一份底层数组，在新数组上完成修改，然后将新数组的引用指向集合。读操作则不需要加锁，直接读取旧数组。<li><strong>特点：</strong><ul><li><strong>读写分离：</strong> 读操作完全是无锁的，性能极高。<li><strong>写操作开销大：</strong> 每次写操作都会复制整个数组，对于数据量大且写操作频繁的场景，性能会很差。<li><strong>数据一致性：</strong> 读到的可能是旧版本的数据（写操作过程中），是<strong>最终一致性</strong>。</ul><li><strong>适用场景：</strong> 读操作远远多于写操作的并发场景，例如黑名单、白名单、事件监听器列表等。</ul></ul><h4 id=异常、泛型与集合框架><a class=headerlink href=#异常、泛型与集合框架 title=异常、泛型与集合框架></a>异常、泛型与集合框架</h4><p>Java中异常的类继承体系<p><img alt=image-20250311153912955 data-src=https://s2.loli.net/2025/03/11/yhg79kQxwJiCBO6.png><p>运行时异常(extends RuntimeException:数组索引越界<p>编译异常(extends Exception). 编译时异常需要通过try-catch或throw丢出异常进行处理,<p>运行时异常不需要特别处理<p>此外异常可以分为业务类和运行逻辑类,一些代码中的异常应该被catch然后向上抛给业务类或者直接处理.<p><img alt=image-20250311175150716 data-src=https://s2.loli.net/2025/03/11/XR4zx7ycNQiSBlt.png><p>泛型允许编写可以<strong>处理不同类型数据的类、接口和方法，而无需在代码中明确指定具体类型</strong>。泛型提供了更强的类型检查，并且消除了对类型转换的需求，从而使得代码更加安全和易于维护。<p><strong>类型参数</strong>：在定义泛型类或方法时使用占位符（通常为大写字母如 <code>T</code>, <code>E</code>, <code>K</code>, <code>V</code> 等），代表实际应用中的类型。<ul><li><strong>类型安全</strong>：编译器会在编译期进行类型检查，减少运行时出现的 <code>ClassCastException</code> 错误。<li><strong>消除类型转换</strong>：由于类型信息在编译时已知，因此不需要显式的类型转换。</ul><h4 id=使用泛型类><a class=headerlink href=#使用泛型类 title=使用泛型类></a>使用泛型类</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>Box&LTInteger> integerBox = <span class=keyword>new</span> Box<>();</span><br><span class=line>integerBox.set(<span class=number>10</span>);</span><br><span class=line>Integer intValue = integerBox.get();</span><br><span class=line></span><br><span class=line>Box&LTString> stringBox = <span class=keyword>new</span> Box<>();</span><br><span class=line>stringBox.set(<span class=string>"Hello World"</span>);</span><br><span class=line>String strValue = stringBox.get();</span><br></pre></table></figure><h4 id=泛型方法><a class=headerlink href=#泛型方法 title=泛型方法></a>泛型方法</h4><p>你也可以定义泛型方法，即在方法级别上使用泛型。例如：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> &LTT> <span class=function><span class=keyword>void</span> <span class=title>printArray</span><span class=params>(T[] array)</span> </span>{</span><br><span class=line>    <span class=keyword>for</span> (T element : array) {</span><br><span class=line>        System.out.println(element);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>    Integer[] intArray = {<span class=number>1</span>, <span class=number>2</span>, <span class=number>3</span>};</span><br><span class=line>    String[] stringArray = {<span class=string>"A"</span>, <span class=string>"B"</span>, <span class=string>"C"</span>};</span><br><span class=line></span><br><span class=line>    printArray(intArray);</span><br><span class=line>    printArray(stringArray);</span><br><span class=line>}</span><br></pre></table></figure><p>在这个例子中，<code>&LTT></code> 在方法签名前声明了类型参数，这样这个方法就可以接受任意类型的数组作为参数。<h4 id=泛型接口><a class=headerlink href=#泛型接口 title=泛型接口></a>泛型接口</h4><p>类似地，也可以定义泛型接口：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>interface</span> <span class=title>Container</span><<span class=title>T</span>> </span>{</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>add</span><span class=params>(T item)</span></span>;</span><br><span class=line>    <span class=function>T <span class=title>get</span><span class=params>(<span class=keyword>int</span> index)</span></span>;</span><br><span class=line>}</span><br></pre></table></figure><p>然后实现这个接口：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>StringContainer</span> <span class=keyword>implements</span> <span class=title>Container</span><<span class=title>String</span>> </span>{</span><br><span class=line>    <span class=keyword>private</span> List&LTString> items = <span class=keyword>new</span> ArrayList<>();</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>add</span><span class=params>(String item)</span> </span>{</span><br><span class=line>        items.add(item);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> String <span class=title>get</span><span class=params>(<span class=keyword>int</span> index)</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> items.get(index);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>Java 泛型是在 Java 5 中引入的，而在此之前已经存在了大量的 Java 代码库。如果直接在 JVM 层面实现泛型支持，那么这些现有的代码可能会因为缺乏泛型信息而不兼容。通过类型擦除，Java 编译器能够在编译时移除泛型类型信息，并将泛型代码转换为非泛型代码，这样就可以确保新旧代码可以无缝地一起工作</blockquote><p><strong>通配符</strong><p>有时可能需要编写能够与多种类型工作的代码，但并不需要知道这些类型的具体细节。这时可以使用通配符 <code>?</code>：<ul><li><strong>无界通配符</strong>：<code>&LT?></code> 表示可以是任何类型。<li><strong>有界通配符</strong>：<code>&LT? extends T></code> 和 <code>&LT? super T></code> 分别表示类型必须是 <code>T</code> 或其子类，以及 <code>T</code> 或其父类。</ul><p><strong>泛型的优点</strong><ol><li><strong>类型安全</strong>：编译器可以在编译时进行更多的类型检查，减少运行时错误。<li><strong>消除强制类型转换</strong>：不再需要手动将对象转换回原始类型。<li><strong>提高代码重用性</strong>：通过泛型，相同的逻辑可以应用于不同的数据类型。</ol><p>Java集合是一种容器,类似于数组但集合的大小可变.<p><img alt=image-20250314192425271 data-src=https://s2.loli.net/2025/03/14/8tKapiLbw7csMlP.png><p><img alt=image-20250314230501695 data-src=https://s2.loli.net/2025/03/14/ZL6IFGzBio5Pbc2.png><h3 id=多线程与线程池><a class=headerlink href=#多线程与线程池 title=多线程与线程池></a>多线程与线程池</h3><p><img alt=image-20250319170141141 data-src=https://s2.loli.net/2025/03/19/WxNStmTMp2D5viR.png><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.sekyoro.tutorThread;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.util.concurrent.Callable;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.ExecutionException;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.FutureTask;</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * <span class=doctag>@projectName</span>: workspace</span></span><br><span class=line><span class=comment> * <span class=doctag>@package</span>: com.sekyoro.tutorThread</span></span><br><span class=line><span class=comment> * <span class=doctag>@className</span>: threadDemo</span></span><br><span class=line><span class=comment> * <span class=doctag>@author</span>: proanimer</span></span><br><span class=line><span class=comment> * <span class=doctag>@description</span>:</span></span><br><span class=line><span class=comment> * <span class=doctag>@date</span>: 2025/3/19 16:19</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>easyThread</span> <span class=keyword>extends</span> <span class=title>Thread</span> </span>{</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>run</span><span class=params>()</span> </span>{</span><br><span class=line>        System.out.println(<span class=string>"This is a thread"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>miniThread</span> <span class=keyword>implements</span> <span class=title>Runnable</span></span>{</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>run</span><span class=params>()</span> </span>{</span><br><span class=line>        System.out.println(<span class=string>"This is a mini thread"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>miniCallable</span> <span class=keyword>implements</span> <span class=title>Callable</span><<span class=title>Integer</span>> </span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>int</span> n;</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>miniCallable</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.n = <span class=number>0</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>miniCallable</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.n = n;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> Integer <span class=title>call</span><span class=params>()</span> <span class=keyword>throws</span> Exception </span>{</span><br><span class=line>        System.out.println(<span class=string>"Calculating..."</span>);</span><br><span class=line>        <span class=keyword>return</span> <span class=number>10</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>int</span> <span class=title>getN</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> n;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>threadDemo</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> ExecutionException, InterruptedException </span>{</span><br><span class=line>        Thread et = <span class=keyword>new</span> easyThread();</span><br><span class=line>        et.start();</span><br><span class=line>        <span class=keyword>new</span> Thread(<span class=keyword>new</span> miniThread()).start();</span><br><span class=line></span><br><span class=line>        Callable&LTInteger> mc = <span class=keyword>new</span> miniCallable();</span><br><span class=line>        FutureTask&LTInteger> ft = <span class=keyword>new</span> FutureTask<>(mc);</span><br><span class=line>        <span class=keyword>new</span> Thread(ft).start();</span><br><span class=line>        Integer i = ft.get();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><img alt=image-20250319171222472 data-src=https://s2.loli.net/2025/03/19/8Dlxb1zAqTgOWyF.png><p>线程同步解决线程安全问题<p><strong>同步代码块</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>synchronized</span>() {</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><p><img alt=image-20250319173439131 data-src=https://s2.loli.net/2025/03/19/S8WiOA2HE5gwVUT.png><p><strong>同步方法</strong><p><img alt=image-20250319173832373 data-src=https://s2.loli.net/2025/03/19/y1U9gKj6fHmab8k.png><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>synchronized</span> <span class=keyword>void</span> <span class=title>draw</span><span class=params>(<span class=keyword>int</span> m)</span> </span>{</span><br><span class=line>          money -= m;   </span><br><span class=line>  }</span><br></pre></table></figure><p><strong>Lock锁</strong><p><img alt=image-20250319174259793 data-src=https://s2.loli.net/2025/03/19/bBamC6ND3n7TcEO.png><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>ReentrantLock lock = <span class=keyword>new</span> ReentrantLock();</span><br><span class=line>lock.lock();</span><br><span class=line>...</span><br><span class=line>lock.unlock();</span><br></pre></table></figure><p>显式锁（Explicit Lock）<ul><li><p>ReentrantLock 类提供了比synchronized更灵活的锁操作，例如可中断的锁等待、尝试非阻塞获取锁、超时获取锁等。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>Lock lock = <span class=keyword>new</span> ReentrantLock();</span><br><span class=line>lock.lock(); <span class=comment>// 获取锁</span></span><br><span class=line><span class=keyword>try</span> {</span><br><span class=line>    <span class=comment>// 受保护的代码</span></span><br><span class=line>} <span class=keyword>finally</span> {</span><br><span class=line>    lock.unlock(); <span class=comment>// 确保释放锁</span></span><br><span class=line>}</span><br></pre></table></figure></ul><ol><li>读写锁（ReadWriteLock）</ol><p>ReadWriteLock 接口 和 ReentrantReadWriteLock 实现类.允许多个读操作同时进行，但在写操作时排斥所有其他读写操作。适用于读多写少的场景。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line>ReadWriteLock rwl = <span class=keyword>new</span> ReentrantReadWriteLock();</span><br><span class=line>rwl.readLock().lock(); <span class=comment>// 获取读锁</span></span><br><span class=line><span class=keyword>try</span> {</span><br><span class=line>    <span class=comment>// 读取操作</span></span><br><span class=line>} <span class=keyword>finally</span> {</span><br><span class=line>    rwl.readLock().unlock(); <span class=comment>// 释放读锁</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line>rwl.writeLock().lock(); <span class=comment>// 获取写锁</span></span><br><span class=line><span class=keyword>try</span> {</span><br><span class=line>    <span class=comment>// 写入操作</span></span><br><span class=line>} <span class=keyword>finally</span> {</span><br><span class=line>    rwl.writeLock().unlock(); <span class=comment>// 释放写锁</span></span><br><span class=line>}</span><br></pre></table></figure><ol><li>条件变量（Condition）</ol><p>Condition 接口与显式锁配合使用，提供类似<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>Lock lock = <span class=keyword>new</span> ReentrantLock();</span><br><span class=line>Condition condition = lock.newCondition();</span><br><span class=line></span><br><span class=line>lock.lock();</span><br><span class=line><span class=keyword>try</span> {</span><br><span class=line>    condition.await(); <span class=comment>// 相当于 wait()</span></span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>    condition.signal(); <span class=comment>// 相当于 notify()</span></span><br><span class=line>} <span class=keyword>finally</span> {</span><br><span class=line>    lock.unlock();</span><br><span class=line>}</span><br></pre></table></figure><ol><li>StampedLock</ol><p>StampedLock 类是Java 8引入的一种新的锁类型，支持乐观读锁策略，适用于读多写少且大部分读操作不会发生冲突的情况。它提供了三种模式：写锁、悲观读锁和乐观读锁。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line>StampedLock stampedLock = <span class=keyword>new</span> StampedLock();</span><br><span class=line></span><br><span class=line><span class=keyword>long</span> stamp = stampedLock.readLock(); <span class=comment>// 悲观读锁</span></span><br><span class=line><span class=keyword>try</span> {</span><br><span class=line>    <span class=comment>// 读取操作</span></span><br><span class=line>} <span class=keyword>finally</span> {</span><br><span class=line>    stampedLock.unlockRead(stamp);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line>stamp = stampedLock.writeLock(); <span class=comment>// 写锁</span></span><br><span class=line><span class=keyword>try</span> {</span><br><span class=line>    <span class=comment>// 写入操作</span></span><br><span class=line>} <span class=keyword>finally</span> {</span><br><span class=line>    stampedLock.unlockWrite(stamp);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>long</span> optimisticStamp = stampedLock.tryOptimisticRead(); <span class=comment>// 乐观读锁</span></span><br><span class=line><span class=comment>// 验证并使用乐观读锁...</span></span><br><span class=line><span class=keyword>if</span> (!stampedLock.validate(optimisticStamp)) {</span><br><span class=line>    <span class=comment>// 如果验证失败，则需要重新获取悲观读锁或写锁</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>线程池</strong><ol><li>ThreadPoolExecutor创建线程池</ol><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment>// 1. 创建线程池</span></span><br><span class=line>ExecutorService pool = <span class=keyword>new</span> ThreadPoolExecutor(<span class=number>3</span>, <span class=number>5</span>, <span class=number>4</span>, TimeUnit.SECONDS, <span class=keyword>new</span> ArrayBlockingQueue<>(<span class=number>3</span>), Executors.defaultThreadFactory(), <span class=keyword>new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class=line></span><br><span class=line><span class=comment>// 2. 使用线程池处理任务</span></span><br><span class=line>Runnable myRunnable = <span class=keyword>new</span> MyRunnable(<span class=number>3</span>);</span><br><span class=line>pool.execute(<span class=keyword>new</span> MyRunnable(<span class=number>3</span>)); <span class=comment>//提交任务</span></span><br><span class=line>pool.execute(<span class=keyword>new</span> MyRunnable(<span class=number>3</span>)); <span class=comment>//提交任务</span></span><br><span class=line>pool.execute(<span class=keyword>new</span> MyRunnable(<span class=number>3</span>)); <span class=comment>//提交任务</span></span><br><span class=line>pool.execute(<span class=keyword>new</span> MyRunnable(<span class=number>3</span>)); <span class=comment>//提交任务</span></span><br></pre></table></figure><p><img alt=image-20250319205156594 data-src=https://s2.loli.net/2025/03/19/yTXM2Brukzw7IC8.png><p><img alt=image-20250319205627740 data-src=https://s2.loli.net/2025/03/19/yIabTL2S9J4vDlX.png><ol><li>利用Executors创建线程池</ol><p><img alt=image-20250319210516204 data-src=https://s2.loli.net/2025/03/19/A8KrfdjOShZTsnU.png><p>利用ThreadPoolExecutor设置不同参数调用<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>static</span> ExecutorService <span class=title>newFixedThreadPool</span><span class=params>(<span class=keyword>int</span> nThreads)</span> </span>{</span><br><span class=line><span class=keyword>return</span> <span class=keyword>new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class=line>                              <span class=number>0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=line>                              <span class=keyword>new</span> LinkedBlockingQueue&LTRunnable>());</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><h3 id=反射、注解与动态代理><a class=headerlink href=#反射、注解与动态代理 title=反射、注解与动态代理></a>反射、注解与动态代理</h3><p>反射是指在运行时动态地获取类的信息以及操作对象的能力。通常情况下，Java 编译器会在编译期确定所有类型和成员变量的访问权限及调用方式，而反射则允许你在运行时进行这些操作<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=comment>// 方式一: 直接通过类名获取</span></span><br><span class=line>Class&LT?> clazz = MyClass.class;</span><br><span class=line></span><br><span class=line><span class=comment>// 方式二: 使用对象的 getClass() 方法</span></span><br><span class=line>MyClass obj = <span class=keyword>new</span> MyClass();</span><br><span class=line>clazz = obj.getClass();</span><br><span class=line></span><br><span class=line><span class=comment>// 方式三: 通过全限定类名字符串</span></span><br><span class=line><span class=keyword>try</span> {</span><br><span class=line>    clazz = Class.forName(<span class=string>"com.example.MyClass"</span>);</span><br><span class=line>} <span class=keyword>catch</span> (ClassNotFoundException e) {</span><br><span class=line>    e.printStackTrace();</span><br><span class=line>}</span><br></pre></table></figure><p>得到的class类可以用来<strong>创建实例</strong>、<strong>访问字段</strong>、<strong>调用方法</strong>等<p>创建实例<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>try</span> {</span><br><span class=line>    <span class=comment>// 假设 MyClass 有一个无参构造函数</span></span><br><span class=line>    Object obj = clazz.getDeclaredConstructor().newInstance();</span><br><span class=line>} <span class=keyword>catch</span> (Exception e) {</span><br><span class=line>    e.printStackTrace();</span><br><span class=line>}</span><br><span class=line><span class=keyword>try</span> {</span><br><span class=line>    <span class=comment>// 获取指定参数类型的构造函数</span></span><br><span class=line>    Constructor&LTMyClass> constructor = clazz.getConstructor(paramType.class);</span><br><span class=line>    </span><br><span class=line>    <span class=comment>// 创建实例</span></span><br><span class=line>    MyClass instance = constructor.newInstance(args);</span><br><span class=line>} <span class=keyword>catch</span> (Exception e) {</span><br><span class=line>    e.printStackTrace();</span><br><span class=line>}</span><br></pre></table></figure><p><strong>注解（Annotations）</strong>是一种元数据形式，它提供了关于程序代码的额外信息，但这些信息并不直接改变程序的运行逻辑。注解自 Java 5 引入以来，已经成为 Java 开发中不可或缺的一部分，用于简化开发流程、提供配置信息、增强代码的功能等<ul><li><strong>定义</strong>：注解是接口的一种特殊形式，它通过 <code>@interface</code> 关键字来定义，并可以附加到类、方法、变量、参数、包声明等语言元素上。<li><strong>用途</strong>：主要用于编译时检查、运行时处理和生成源代码或文档。</ul><ol><li><strong>标记注解</strong>：没有成员变量，仅作为标记使用，如 <code>@Override</code>。<li><strong>单值注解</strong>：只有一个值，通常省略名称直接指定值，如 <code>@SuppressWarnings("unchecked")</code>。<li><strong>完整注解</strong>：包含多个成员变量，需要明确指定每个成员的值。</ol><p>元注解是指用来注解其他注解的注解，主要包括以下几个：<ul><li><code>@Retention</code>：定义了注解的存在阶段（SOURCE, CLASS, RUNTIME）。<li><code>@Target</code>：指定了注解可以应用的目标元素类型（TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE 等）。<li><code>@Documented</code>：表明这个注解应该被 javadoc 工具记录。<li><code>@Inherited</code>：允许子类继承父类中的注解。<li><code>@Repeatable</code>：从 Java 8 开始支持，表示相同的注解可以在同一地方多次使用。</ul><p><strong>注解的解析</strong><p>检查方法和类等是否包含对应注解,若包含则进行相关调用<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line>annotationDemo annotationDemo = <span class=keyword>new</span> annotationDemo();</span><br><span class=line> Class&LT?> aClass = annotationDemo.class;</span><br><span class=line> Method[] methods = aClass.getMethods();</span><br><span class=line> <span class=keyword>for</span> (Method method : methods) {</span><br><span class=line>     <span class=keyword>if</span> (method.isAnnotationPresent( MyTest.class)) {</span><br><span class=line>         <span class=keyword>try</span> {</span><br><span class=line>             MyTest declaredAnnotation = method.getDeclaredAnnotation(MyTest.class);</span><br><span class=line>             method.invoke(annotationDemo);</span><br><span class=line>         } <span class=keyword>catch</span> (IllegalAccessException | InvocationTargetException e) {</span><br><span class=line>             <span class=keyword>throw</span> <span class=keyword>new</span> RuntimeException(e);</span><br><span class=line>         }</span><br><span class=line>     }</span><br><span class=line> }</span><br></pre></table></figure><p><strong>动态代理</strong><p>Proxy.newProxyInstance创建代理,参数包括类加载器,需要实现的接口,和代理需要做的事情<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ProxyUtils</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> StarService <span class=title>createProxy</span><span class=params>(StarService starService)</span></span>{</span><br><span class=line>        StarService o = (StarService)Proxy.newProxyInstance(ProxyUtils.class.getClassLoader(), starService.getClass().getInterfaces(), <span class=keyword>new</span> InvocationHandler() {</span><br><span class=line>            <span class=meta>@Override</span></span><br><span class=line>            <span class=function><span class=keyword>public</span> Object <span class=title>invoke</span><span class=params>(Object proxy, Method method, Object[] args)</span> <span class=keyword>throws</span> Throwable </span>{</span><br><span class=line>               String methodName = method.getName();</span><br><span class=line>               <span class=keyword>if</span>(<span class=string>"sing"</span>.equals(methodName)) {</span><br><span class=line>                   System.out.println(<span class=string>"sing a song: "</span> + args[<span class=number>0</span>]);</span><br><span class=line>               }<span class=keyword>else</span>{</span><br><span class=line>                     System.out.println(<span class=string>"dance a dance"</span>);</span><br><span class=line>               }</span><br><span class=line>                <span class=keyword>if</span>(method.getReturnType().equals(Void.TYPE)) {</span><br><span class=line>                   <span class=keyword>return</span> <span class=keyword>null</span>;</span><br><span class=line>               }<span class=keyword>else</span>{</span><br><span class=line>                       <span class=keyword>return</span>  method.invoke(starService,args);</span><br><span class=line>               }</span><br><span class=line>            }</span><br><span class=line>        });</span><br><span class=line>        <span class=keyword>return</span> o;</span><br><span class=line></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><h4 id=ClassLoader><a class=headerlink href=#ClassLoader title=ClassLoader></a>ClassLoader</h4><p>类加载过程主要包括三个阶段：<strong>加载</strong>、<strong>链接</strong>和<strong>初始化</strong>。<ul><li><strong>加载</strong>：通过类的全限定名获取定义此类的二进制字节流，并将其转换为方法区中的运行时数据结构，在内存中生成一个代表该类的 <code>java.lang.Class</code> 对象。<li><strong>链接</strong>：包括验证、准备和解析三个步骤。验证确保被加载类的正确性；准备则为类变量分配内存并设置默认初始值；解析是将类、接口、字段和方法的符号引用转为直接引用的过程。<li><strong>初始化</strong>：执行类构造器 <code>&LTclinit>()</code> 方法的过程，对静态变量和静态代码块进行初始化。</ul><p>Java 类加载器使用双亲委派模型来搜索类或资源。<strong>当一个类加载器收到类加载请求时，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成</strong>，每一层的类加载器都是如此，因此所有的类加载请求最终都会传送到顶层的启动类加载器。<strong>只有当父类加载器无法加载该类时，子类加载器才会尝试自己加载</strong><p>Java 提供了三种内置的类加载器：<ul><li><strong>Bootstrap ClassLoader</strong>：这是最顶层的类加载器，由本地代码实现，通<strong>常用于加载核心 JDK 类库</strong>（如 <code>rt.jar</code>）。 无法直接访问,显示为null<li><strong>Extension ClassLoader</strong>：扩展类加载器，<strong>用来加载位于 <code>$JAVA_HOME/jre/lib/ext</code> 目录下的 JAR 包</strong>。 (目前使用PlatformClassLoader,加载 JDK 提供的平台模块中的类，例如 <code>java.sql</code>, <code>java.xml</code>, <code>javax.*</code> 等模块化的平台类。)<li><strong>Application ClassLoader</strong>：应用程序类加载器，<strong>负责加载用户类路径（ClassPath）上指定的类库</strong></ul><p>Java 提供了一些常用的方法来操作类加载器：<p><strong>(1) <code>loadClass(String name)</code></strong><p>加载指定名称的类或接口。如果已经加载过，则直接返回对应的 <code>Class</code> 对象；如果没有，则按照双亲委派机制尝试加载。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>try</span> {</span><br><span class=line>    Class&LT?> clazz = ClassLoader.getSystemClassLoader().loadClass(<span class=string>"com.example.MyClass"</span>);</span><br><span class=line>} <span class=keyword>catch</span> (ClassNotFoundException e) {</span><br><span class=line>    e.printStackTrace();</span><br><span class=line>}</span><br></pre></table></figure><p><strong>(2) <code>findClass(String name)</code></strong><p>查找指定名称的类。默认实现会抛出 <code>ClassNotFoundException</code> 异常，通常需要自定义类加载器覆盖此方法以提供具体的类查找逻辑。<p><strong>(3) <code>defineClass(byte[] b, int off, int len)</code></strong><p>将一个字节数组转换成一个类的 <code>Class</code> 对象。一般不直接调用，主要用于自定义类加载器。<p><strong>(4) <code>getResource(String name)</code> 和 <code>getResourceAsStream(String name)</code></strong><p>用于查找资源文件。前者返回资源的 URL，后者返回资源的输入流。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>URL resourceUrl = getClass().getClassLoader().getResource(<span class=string>"config.properties"</span>);</span><br><span class=line>InputStream inputStream = getClass().getClassLoader().getResourceAsStream(<span class=string>"config.properties"</span>);</span><br></pre></table></figure><p><strong>(5) <code>getParent()</code></strong><p>返回该类加载器的父类加载器。注意，Bootstrap ClassLoader 没有父类加载器，所以对于 Bootstrap ClassLoader 调用 <code>getParent()</code> 将返回 <code>null</code>。<p><strong>4. 自定义类加载器</strong><p>有时我们需要根据特定的需求来自定义类加载器。可以通过继承 <code>java.lang.ClassLoader</code> 并重写 <code>findClass</code> 方法来实现。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>MyClassLoader</span> <span class=keyword>extends</span> <span class=title>ClassLoader</span> </span>{</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>protected</span> Class&LT?> findClass(String name) <span class=keyword>throws</span> ClassNotFoundException {</span><br><span class=line>        <span class=keyword>byte</span>[] classData = loadClassData(name); <span class=comment>// 实现类数据加载逻辑</span></span><br><span class=line>        <span class=keyword>return</span> defineClass(name, classData, <span class=number>0</span>, classData.length);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>byte</span>[] loadClassData(String className) {</span><br><span class=line>        <span class=comment>// 加载类数据的逻辑</span></span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class=keyword>byte</span>[<span class=number>0</span>];</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>以下是实现自定义类加载器的基本步骤：<ol><li><p>继承 <code>ClassLoader</code></p> <ul><li>创建一个类并继承 <code>ClassLoader</code>。</ul><li><p>重写 <code>findClass()</code> 方法(遵从双亲委派机制)</p> <ul><li>实现自定义的类加载逻辑。</ul><li><p>调用 <code>defineClass()</code> 方法</p> <ul><li>将字节码转换为 <code>Class</code> 对象。</ul> <p>class对象相同需要classloader相同,相同的classloader进行loadclass相同的类得到的class相同</p></ol><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.io.ByteArrayOutputStream;</span><br><span class=line><span class=keyword>import</span> java.io.FileInputStream;</span><br><span class=line><span class=keyword>import</span> java.io.IOException;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>CustomClassLoader</span> <span class=keyword>extends</span> <span class=title>ClassLoader</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=comment>// 加载类的根路径</span></span><br><span class=line>    <span class=keyword>private</span> String classPath;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>CustomClassLoader</span><span class=params>(String classPath)</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.classPath = classPath;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>protected</span> Class&LT?> findClass(String name) <span class=keyword>throws</span> ClassNotFoundException {</span><br><span class=line>        <span class=comment>// 读取类的字节码</span></span><br><span class=line>        <span class=keyword>byte</span>[] classData = loadClassData(name);</span><br><span class=line>        <span class=keyword>if</span> (classData == <span class=keyword>null</span>) {</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> ClassNotFoundException(<span class=string>"Class not found: "</span> + name);</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 解密字节码</span></span><br><span class=line>        <span class=keyword>byte</span>[] decryptedClassData = decrypt(classData);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 定义类</span></span><br><span class=line>        <span class=keyword>return</span> defineClass(name, decryptedClassData, <span class=number>0</span>, decryptedClassData.length);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 加载类的字节码</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>byte</span>[] loadClassData(String className) {</span><br><span class=line>        String path = classPath + className.replace(<span class=string>'.'</span>, <span class=string>'/'</span>) + <span class=string>".class"</span>;</span><br><span class=line>        <span class=keyword>try</span> (FileInputStream fis = <span class=keyword>new</span> FileInputStream(path);</span><br><span class=line>             ByteArrayOutputStream baos = <span class=keyword>new</span> ByteArrayOutputStream()) {</span><br><span class=line>            <span class=keyword>int</span> buffer;</span><br><span class=line>            <span class=keyword>while</span> ((buffer = fis.read()) != -<span class=number>1</span>) {</span><br><span class=line>                baos.write(buffer);</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>return</span> baos.toByteArray();</span><br><span class=line>        } <span class=keyword>catch</span> (IOException e) {</span><br><span class=line>            e.printStackTrace();</span><br><span class=line>            <span class=keyword>return</span> <span class=keyword>null</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 模拟解密过程</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>byte</span>[] decrypt(<span class=keyword>byte</span>[] data) {</span><br><span class=line>        <span class=comment>// 简单的异或解密</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < data.length; i++) {</span><br><span class=line>            data[i] = (<span class=keyword>byte</span>) (data[i] ^ <span class=number>0xFF</span>);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> data;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> Exception </span>{</span><br><span class=line>        <span class=comment>// 自定义类加载器</span></span><br><span class=line>        CustomClassLoader customClassLoader = <span class=keyword>new</span> CustomClassLoader(<span class=string>"path/to/classes/"</span>);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 使用自定义类加载器加载类</span></span><br><span class=line>        Class&LT?> clazz = customClassLoader.loadClass(<span class=string>"com.example.MyClass"</span>);</span><br><span class=line>        System.out.println(<span class=string>"Loaded class: "</span> + clazz.getName());</span><br><span class=line></span><br><span class=line>        <span class=comment>// 创建实例并调用方法</span></span><br><span class=line>        Object instance = clazz.getDeclaredConstructor().newInstance();</span><br><span class=line>        clazz.getMethod(<span class=string>"sayHello"</span>).invoke(instance);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h4 id=线程上下文加载器><a class=headerlink href=#线程上下文加载器 title=线程上下文加载器></a>线程上下文加载器</h4><p>线程上下文类加载器（Thread Context ClassLoader）是 Java 提供的一种机制，允许开发者在线程中设置和获取类加载器。这种机制主要用于解决某些特定场景下类加载的问题，尤其是在复杂的类层次结构或模块化系统中。<p><strong>线程上下文类加载器的作用</strong><ol><li><strong>解决类加载器隔离问题</strong>：<ul><li>在 Java 应用程序中，不同的类加载器可能会形成类加载器树，这导致了类加载器之间的隔离性。<li>例如，在 Web 容器或 OSGi 等环境中，不同应用或模块可能使用不同的类加载器来加载各自的类。在这种情况下，如果一个类需要加载另一个类加载器负责加载的类，则会遇到问题。<li>线程上下文类加载器提供了一种绕过双亲委派模型的方式，允许当前线程使用指定的类加载器来加载类。</ul><li><strong>支持框架和库的开发</strong>：<ul><li>许多框架和库（如 JNDI、JDBC 驱动等）依赖于线程上下文类加载器来加载必要的类。<li>这些框架通常不知道具体的类加载器，因此它们可以利用线程上下文类加载器来动态地加载所需的类。</ul></ol><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ThreadContextClassLoaderExample</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            <span class=comment>// 获取默认的上下文类加载器</span></span><br><span class=line>            ClassLoader defaultClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class=line>            System.out.println(<span class=string>"默认的上下文类加载器: "</span> + defaultClassLoader);</span><br><span class=line></span><br><span class=line>            <span class=comment>// 创建一个新的类加载器（例如自定义类加载器）</span></span><br><span class=line>            ClassLoader customClassLoader = <span class=keyword>new</span> CustomClassLoader();</span><br><span class=line></span><br><span class=line>            <span class=comment>// 设置新的上下文类加载器</span></span><br><span class=line>            Thread.currentThread().setContextClassLoader(customClassLoader);</span><br><span class=line>            System.out.println(<span class=string>"设置后的上下文类加载器: "</span> + Thread.currentThread().getContextClassLoader());</span><br><span class=line></span><br><span class=line>            <span class=comment>// 使用上下文类加载器加载类</span></span><br><span class=line>            Class&LT?> clazz = Thread.currentThread().getContextClassLoader().loadClass(<span class=string>"com.example.MyClass"</span>);</span><br><span class=line>            System.out.println(<span class=string>"加载的类: "</span> + clazz.getName());</span><br><span class=line>        } <span class=keyword>catch</span> (ClassNotFoundException e) {</span><br><span class=line>            e.printStackTrace();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>CustomClassLoader</span> <span class=keyword>extends</span> <span class=title>ClassLoader</span> </span>{</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>protected</span> Class&LT?> findClass(String name) <span class=keyword>throws</span> ClassNotFoundException {</span><br><span class=line>        <span class=comment>// 实现类的查找逻辑</span></span><br><span class=line>        <span class=keyword>byte</span>[] classData = loadClassData(name);</span><br><span class=line>        <span class=keyword>if</span> (classData == <span class=keyword>null</span>) {</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> ClassNotFoundException();</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=keyword>return</span> defineClass(name, classData, <span class=number>0</span>, classData.length);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>byte</span>[] loadClassData(String className) {</span><br><span class=line>        <span class=comment>// 模拟从文件或其他来源读取类数据的逻辑</span></span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>null</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=JVM><a class=headerlink href=#JVM title=JVM></a>JVM</h2><p><img alt=image-20250320221417773 data-src=https://s2.loli.net/2025/03/20/iZdH8kUa9LYAFQW.png><p>程序计数器: 线程私有<h3 id=垃圾回收><a class=headerlink href=#垃圾回收 title=垃圾回收></a>垃圾回收</h3><p>判断对象可以回收<h4 id=引用计数法><a class=headerlink href=#引用计数法 title=引用计数法></a>引用计数法</h4><p>工作原理<ol><li><strong>初始化</strong>：每当创建一个新的对象时，该对象的引用计数器被初始化为1。<li><strong>增加引用</strong>：每当有新的引用指向这个对象时（例如，将对象赋值给另一个变量），该对象的引用计数加1。<li><strong>减少引用</strong>：每当某个引用不再指向该对象时（例如，变量超出作用域或重新赋值），该对象的引用计数减1。<li><strong>回收内存</strong>：当一个对象的引用计数降为0时，表示没有其他引用指向该对象，这时就可以立即回收该对象所占用的内存。</ol><p>缺点:<p><strong>无法处理循环引用</strong>：如果两个或多个对象相互引用形成环状结构，则即使这些对象实际上已经不可达，它们的引用计数也不会变为0，导致内存泄漏。为了克服这个问题，一些语言引入了弱引用（weak references）或专门的循环检测机制。<p><strong>多线程环境下的复杂性</strong>：在多线程环境下，对引用计数的修改需要同步操作，以防止竞态条件（race condition），这也增加了实现的复杂性和运行时的开销<h4 id=可达性分析算法><a class=headerlink href=#可达性分析算法 title=可达性分析算法></a>可达性分析算法</h4><p>可达性分析的基本思想是<strong>从一组被称为“根节点”（root set）的对象开始，遍历所有可以通过这些根节点直接或间接引用到的对象，并将它们标记为存活</strong>。未被标记的对象则被认为是不可达的，可以被安全地回收。<blockquote><p>在命令行中输入 <code>jps</code> 可以列出所有由当前用户启动的 Java 进程的基本信息<p><code>-q</code>：仅输出 JVM 的进程 ID，不输出类名、jar 名等信息<p><code>-l</code>：输出主类的完整包名；如果进程执行的是 jar 文件，则输出 jar 文件的完整路径</blockquote><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>jmap -dump:[live,]format=b,file=&LTfilename>.hprof &LTpid></span><br></pre></table></figure><ul><li><code>live</code>：如果指定了这个选项，则只转储存活的对象；如果不指定，则转储所有对象。<li><code>format=b</code>：表示输出格式为二进制，默认就是二进制格式，所以通常省略不写。<li><code>&LTfilename>.hprof</code>：指定生成的堆转储文件的名字。<li><code>&LTpid></code>：目标Java进程的进程ID。</ul><p>引用<p><img alt=image-20250320220503285 data-src=https://s2.loli.net/2025/03/20/BMyrksQT5S6xlqf.png><p>强引用 软引用 弱引用<p>软引用:垃圾回收时且内存不足时会被回收掉<p>虚引用 引用队列<p>终结器引用<ul><li><strong>强引用</strong>：日常编程中最常用的引用类型，几乎所有对象都是通过强引用创建的。<li><strong>软引用</strong>：适用于缓存场景，当内存不足时，允许GC回收缓存数据。<li><strong>弱引用</strong>：适合于需要自动清理的资源管理场景，例如监听器或回调函数列表中的对象。<li><strong>虚引用</strong>：主要用于了解对象何时被垃圾回收，常用于做一些清理工作，比如清除本地内存、关闭文件等</ul><h4 id=回收算法><a class=headerlink href=#回收算法 title=回收算法></a>回收算法</h4><p><strong>标记-清除</strong><ul><li>这是最基本的垃圾回收算法，分为两个阶段：标记和清除。在标记阶段，GC从根集合（GC Roots）开始遍历所有可达对象，并标记它们为存活对象；在清除阶段，未被标记的对象即被视为垃圾对象并被回收<li>优点是实现简单，适用于任何对象的内存管理；<strong>缺点是会产生内存碎片</strong>，因为<strong>删除了不可达对象后留下的空闲内存可能是不连续的</strong>，这可能导致后续大对象分配失败。</ul><p><strong>复制（Copying）算法</strong>：<ul><li>复制算法将堆内存划分为两部分，每次只使用其中一部分。当这部分内存用完时，GC会暂停应用，将存活对象复制到另一部分内存中，并清空原内存区域<li>此算法避免了内存碎片问题，但代价是只能使用一半的内存空间，且对于存活率较高的对象效率较低。</ul><p>复制算法将可用内存分为两部分，通常称为From Space和To Space。<p>程序只使用其中一部分（From Space），当这部分内存满后，GC会遍历From Space中的所有对象，将存活的对象复制到To Space，并且更新这些对象的引用指向新的位置。<p>清理完From Space后，它变为可用空间，而To Space则成为下次分配新对象的空间<p>这个过程有效地避免了内存碎片化的问题，因为每次清理后的内存区域都是连续的<p><strong>标记-整理（Mark-Compact）算法</strong>：<ul><li>标记-整理算法结合了标记-清除和复制的优点，在标记阶段与标记-清除类似，但在清除阶段，它会将存活的对象移动到内存的一端，然后清理掉端边界以外的空间<li>它解决了内存碎片问题，但需要移动存活对象，增加了回收的开销。</ul><p>标记整理算法首先执行标记阶段，这与标记清除算法相同，即通<strong>过可达性分析找到所有存活的对象并进行标记</strong>。<p>接下来是整理阶段，在这个阶段，<strong>所有的存活对象会被移动到内存的一端，这样可以确保所有的空闲空间都在另一端</strong>，形成一个连续的块。<p>最后一步是<strong>对剩余的未被标记的部分进行清理，释放出连续的内存块</strong><p><strong>分代收集（Generational Collection）算法</strong>：<ul><li>分代收集是一种基于对象生命周期特征优化的策略，将堆内存划分为年轻代（Young Generation）和老年代（Old Generation）。年轻代通常采用复制算法，而老年代则采用标记-清除或标记-整理算法<li>这种方法利用了大多数对象“朝生夕死”的特点，提高了垃圾回收的效率。</ul><p><strong>1. 堆内存分区</strong><p>在分代垃圾回收中，堆内存通常被划分为三个主要区域：<ul><li><strong>年轻代（Young Generation）</strong>：<ul><li>主要用于存放新创建的对象。<li>进一步细分为一个 Eden 区和两个 Survivor 区（From 和 To）。</ul><li><strong>老年代（Old Generation）</strong>：<ul><li>存放的是经过多次垃圾回收后仍然存活的对象，这些对象被认为具有较长的生命期。</ul><li><strong>永久代/元空间（Permanent Generation/Metaspace）</strong>：<ul><li>在 Java 8 之前称为永久代，之后改为元空间，主要用于存储类的元数据、方法描述等信息，并不属于堆的一部分。</ul></ul><p><strong>2. 分代垃圾回收过程</strong><p><strong>年轻代垃圾回收（Minor GC）</strong><ul><li><strong>Eden 区与 Survivor 区</strong>：当一个新的对象被创建时，它首先被分配到 Eden 区。如果 Eden 区满了，就会触发一次 Minor GC。<li><strong>复制算法</strong>：Minor GC 使用这种算法来清理垃圾对象。在这个过程中，存活的对象会被复制到其中一个 Survivor 区（假设为 From），同时清除 Eden 区。<li><strong>Survivor 区交换</strong>：下一次 Minor GC 发生时，Eden 区和当前的 From Survivor 区中的存活对象会被复制到另一个 Survivor 区（To）。然后这两个角色会互换（即原来的 From 变成 To，反之亦然）。<li><strong>晋升至老年代</strong>：当某个对象经历了若干次 Minor GC 后仍然存活（默认情况下是 15 次），它将被移动到老年代。</ul><p><strong>老年代垃圾回收（Major GC / Full GC）</strong><ul><li><strong>Full GC</strong>：当老年代也满时，将会触发 Full GC，这会同时清理年轻代和老年代。由于老年代中的对象通常是长期存活的，所以 Full GC 的频率远低于 Minor GC，但其执行成本更高。<li><strong>标记-清除或标记-整理算法</strong>：对于老年代，可能会使用这两种算法之一。标记-清除算法简单地标识并删除不再使用的对象，但会导致内存碎片化；标记-整理算法则会在清理的同时压缩内存，减少碎片。</ul><p>一些常用的 JVM 参数，用于调整分代垃圾回收行为：<ul><li><strong>年轻代相关参数</strong>：<ul><li><code>-Xmn&LTsize></code>：设置年轻代大小。<li><code>-XX:SurvivorRatio=&LTratio></code>：设置 Eden 区与 Survivor 区的比例（默认为 8:1）。<li><code>-XX:MaxTenuringThreshold=&LTn></code>：设置对象晋升到老年代的最大年龄（默认为 15）。</ul><li><strong>老年代相关参数</strong>：<ul><li><code>-Xms&LTsize></code>：设置堆内存初始大小。<li><code>-Xmx&LTsize></code>：设置堆内存最大大小。</ul><li><strong>垃圾回收器选择</strong>：<ul><li><code>-XX:+UseSerialGC</code>：启用 Serial 收集器。<li><code>-XX:+UseParallelGC</code>：启用 Parallel 收集器。<li><code>-XX:+UseConcMarkSweepGC</code>：启用 CMS 收集器。<li><code>-XX:+UseG1GC</code>：启用 G1 收集器。<li><code>-XX:+UseZGC</code>：启用 ZGC 收集器。<li><code>-XX:+UseShenandoahGC</code>：启用 Shenandoah 收集器</ul></ul><p><strong>(1) 基本 GC 日志</strong><ul><li><code>-XX:+PrintGCDetails</code>：打印详细的垃圾回收日志。<li><code>-XX:+PrintGC</code> 或 <code>-verbose:gc</code>：打印简单的垃圾回收日志（仅显示每次 GC 的时间和类型）。</ul><p>示例：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -XX:+PrintGCDetails -XX:+PrintGC MyApplication</span><br></pre></table></figure><p>输出示例：<figure class="highlight json"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>[GC (Allocation Failure) [PSYoungGen: <span class=number>1024</span>K-><span class=number>512</span>K(<span class=number>2048</span>K)] <span class=number>1024</span>K-><span class=number>768</span>K(<span class=number>6144</span>K), <span class=number>0.0023456</span> secs] [Times: user=<span class=number>0.01</span> sys=<span class=number>0.00</span>, real=<span class=number>0.00</span> secs]</span><br></pre></table></figure><p><strong>(2) 打印时间戳</strong><ul><li><code>-XX:+PrintGCTimeStamps</code>：在每条 GC 日志前添加时间戳（从 JVM 启动开始的时间）。<li><code>-XX:+PrintGCDateStamps</code>：在每条 GC 日志前添加实际日期和时间。</ul><p>示例：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps MyApplication</span><br></pre></table></figure><p>输出示例：<figure class="highlight apache"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attribute>2023</span>-<span class=number>03</span>-<span class=number>29</span>T<span class=number>12</span>:<span class=number>00</span>:<span class=number>00</span>.<span class=number>000</span>+<span class=number>0000</span>: <span class=number>1</span>.<span class=number>234</span>:<span class=meta> [GC (Allocation Failure) ...]</span></span><br></pre></table></figure><p><strong>(3) 将 GC 日志写入文件</strong><ul><li><code>-Xloggc:&LTfile></code>：将 GC 日志写入指定文件。<li>结合其他参数可以生成更详细的日志文件。</ul><p>示例：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -XX:+PrintGCDetails -Xloggc:gc.log MyApplication</span><br></pre></table></figure><p><strong>2. 调整堆内存大小</strong><ul><li><code>-Xms&LTsize></code>：设置 JVM 堆内存的初始大小。例如 <code>-Xms512m</code> 表示初始堆大小为 512MB。<li><code>-Xmx&LTsize></code>：设置 JVM 堆内存的最大大小。例如 <code>-Xmx2g</code> 表示最大堆大小为 2GB。</ul><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -Xms512m -Xmx2g MyApplication</span><br></pre></table></figure><p><strong>3. 调整年轻代和老年代比例</strong><ul><li><code>-XX:NewRatio=&LTratio></code>：设置老年代与年轻代的比例。例如 <code>-XX:NewRatio=3</code> 表示老年代与年轻代的比例为 3:1。<li><code>-XX:SurvivorRatio=&LTratio></code>：设置 Eden 区与 Survivor 区的比例。例如 <code>-XX:SurvivorRatio=8</code> 表示 Eden 区与每个 Survivor 区的比例为 8:1。</ul><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -XX:NewRatio=3 -XX:SurvivorRatio=8 MyApplication</span><br></pre></table></figure><p><strong>4. 设置元空间大小</strong><ul><li><code>-XX:MetaspaceSize=&LTsize></code>：设置元空间的初始大小。<li><code>-XX:MaxMetaspaceSize=&LTsize></code>：设置元空间的最大大小。</ul><p>示例：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m MyApplication</span><br></pre></table></figure><p><strong>5. 设置线程栈大小</strong><ul><li><code>-Xss&LTsize></code>：设置每个线程的栈大小。例如 <code>-Xss512k</code> 表示每个线程的栈大小为 512KB。</ul><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -Xss512k MyApplication</span><br></pre></table></figure><p><strong>6. 启用特定垃圾回收器</strong><ul><li><code>-XX:+UseSerialGC</code>：启用 Serial 收集器（单线程）。<li><code>-XX:+UseParallelGC</code>：启用 Parallel 收集器（多线程，关注吞吐量）。<li><code>-XX:+UseConcMarkSweepGC</code>：启用 CMS 收集器（低延迟，适合 Web 应用）。<li><code>-XX:+UseG1GC</code>：启用 G1 收集器（适合大内存应用）。<li><code>-XX:+UseZGC</code>：启用 ZGC 收集器（超低延迟，适合大内存）。<li><code>-XX:+UseShenandoahGC</code>：启用 Shenandoah 收集器（超低延迟）。</ul><p>示例：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -XX:+UseG1GC MyApplication</span><br></pre></table></figure><p><strong>7. 设置 GC 暂停时间目标</strong><ul><li><code>-XX:MaxGCPauseMillis=&LTtime></code>：设置 GC 的最大暂停时间目标（单位为毫秒）。只对 G1 和 ZGC 有效。<li><code>-XX:GCTimeRatio=&LTratio></code>：设置 GC 时间与应用程序运行时间的比例。例如 <code>-XX:GCTimeRatio=19</code> 表示 GC 时间占总时间的 1/20。</ul><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -XX:+UseG1GC -XX:MaxGCPauseMillis=200 MyApplication</span><br></pre></table></figure><p><strong>8. 监控 JVM 性能</strong><ul><li><code>-XX:+HeapDumpOnOutOfMemoryError</code>：当发生 OutOfMemoryError 时自动生成堆转储文件。<li><code>-XX:HeapDumpPath=&LTpath></code>：指定堆转储文件的路径。<li><code>-XX:+PrintCommandLineFlags</code>：打印 JVM 启动时的所有命令行参数。<li><code>-XX:+PrintFlagsFinal</code>：打印所有 JVM 参数及其最终值。</ul><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./heapdump.hprof MyApplication</span><br></pre></table></figure><p><strong>9. 其他常用参数</strong><ul><li><code>-D&LTproperty>=&LTvalue></code>：设置系统属性。例如 <code>-Dfile.encoding=UTF-8</code>。<li><code>-server</code>：启用服务器模式（默认情况下大多数 JVM 都会自动启用此模式）。<li><code>-XX:+DisableExplicitGC</code>：禁用通过 <code>System.gc()</code> 显式触发的垃圾回收。</ul><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -Dfile.encoding=UTF-8 -server -XX:+DisableExplicitGC MyApplication</span><br></pre></table></figure><h4 id=垃圾回收器><a class=headerlink href=#垃圾回收器 title=垃圾回收器></a>垃圾回收器</h4><p><strong>1. Serial 收集器</strong><ul><li><strong>工作模式</strong>：单线程运行，适用于单核处理器或客户端应用。<li><strong>应用场景</strong>：适合内存较小的应用程序，特别是那些对响应时间要求不高且资源有限的环境。<li><strong>优点</strong>：实现简单，对于小型应用程序非常有效。<li><strong>缺点</strong>：由于是单线程执行，在进行垃圾回收时会暂停所有其他的工作线程（Stop-The-World, STW），这会导致较长时间的停顿。</ul><p>启用参数：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-XX:+UseSerialGC</span><br></pre></table></figure><p><strong>2. Parallel 收集器（也称为 Throughput Collector）</strong><ul><li><strong>工作模式</strong>：多线程并行执行，适用于多核处理器环境下的服务器端应用。<li><strong>关注点</strong>：提高吞吐量，即减少垃圾回收时间占总运行时间的比例。<li><strong>年轻代</strong>：使用标记-复制算法。<li><strong>老年代</strong>：使用标记-整理算法。<li><strong>优点</strong>：通过并行处理提高了垃圾回收效率，减少了总的停顿时间。<li><strong>缺点</strong>：仍然会有较长的停顿时间，特别是在老年代垃圾回收期间。</ul><p>启用参数：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-XX:+UseParallelGC</span><br></pre></table></figure><p>为了优化老年代的收集性能，可以加上 <code>-XX:+UseParallelOldGC</code> 来启用老年代的并行压缩。<p><strong>3. CMS（Concurrent Mark Sweep）收集器</strong><ul><li><p><strong>工作模式</strong>：专注于减少停顿时间，尽可能地与应用程序并发执行大部分垃圾回收工作。</p><li><p>主要阶段</p> <p>：</p> <ul><li>初始标记（Initial Mark）<li>并发标记（Concurrent Mark）<li>再标记（Remark）<li>并发清除（Concurrent Sweep）</ul><li><p><strong>优点</strong>：尽量减少了应用程序的停顿时间。</p><li><p><strong>缺点</strong>：虽然减少了停顿时间，但增加了总体的CPU占用率；无法压缩内存，可能导致内存碎片化问题；在某些情况下可能会导致“Concurrent Mode Failure”。</p></ul><p>启用参数：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-XX:+UseConcMarkSweepGC</span><br></pre></table></figure><p><strong>4. G1（Garbage First）收集器</strong><ul><li><p><strong>设计理念</strong>：旨在提供可预测的停顿时间和高吞吐量。G1 将堆划分为多个区域（Region），优先回收垃圾最多的区域。</p><li><p>主要特性</p> <p>：</p> <ul><li>可以设置最大停顿时间目标。<li>支持大堆内存管理，并能有效避免内存碎片。<li>在进行垃圾回收时，尝试同时清理年轻代和老年代。</ul><li><p><strong>优点</strong>：相比 CMS，G1 提供了更好的停顿时间控制，并减少了内存碎片的问题。</p><li><p><strong>缺点</strong>：配置相对复杂，可能需要更多的调优才能达到最佳效果。</p></ul><p>启用参数：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-XX:+UseG1GC</span><br></pre></table></figure><h3 id=CAS与原子类><a class=headerlink href=#CAS与原子类 title=CAS与原子类></a>CAS与原子类</h3><p>CAS（Compare-And-Swap，比较并交换）是一种重要的原子操作机制，广泛应用于多线程并发控制中。它<strong>允许在不使用锁的情况下实现对共享数据的同步访问</strong>，从而<strong>避免了传统锁机制可能带来的性能瓶颈和死锁问题</strong>。CAS操作包含三个参数：内存位置V、预期原值A和新值B。只有当内存位置V的值等于预期原值A时，才会将内存位置V的值更新为新值B，并返回操作是否成功的布尔值；否则，不做任何操作<p>在 Java 中，<code>java.util.concurrent.atomic</code> 包提供了基于 CAS 的原子类，例如 <code>AtomicInteger</code>、<code>AtomicLong</code> 等。这些类内部使用了 <code>Unsafe</code> 类提供的底层 CAS 操作<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>CASCounter</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> AtomicInteger value = <span class=keyword>new</span> AtomicInteger(<span class=number>0</span>); <span class=comment>// 使用 AtomicInteger 实现 CAS</span></span><br><span class=line></span><br><span class=line>    <span class=comment>// 增加计数器的值</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>increment</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> current, next;</span><br><span class=line>        <span class=keyword>do</span> {</span><br><span class=line>            current = value.get(); <span class=comment>// 获取当前值</span></span><br><span class=line>            next = current + <span class=number>1</span>;    <span class=comment>// 计算下一个值</span></span><br><span class=line>        } <span class=keyword>while</span> (!value.compareAndSet(current, next)); <span class=comment>// 尝试 CAS 更新</span></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 获取当前计数器的值</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>int</span> <span class=title>getValue</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> value.get();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> InterruptedException </span>{</span><br><span class=line>        CASCounter counter = <span class=keyword>new</span> CASCounter();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 创建多个线程并发增加计数器</span></span><br><span class=line>        Thread t1 = <span class=keyword>new</span> Thread(() -> {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < <span class=number>1000</span>; i++) {</span><br><span class=line>                counter.increment();</span><br><span class=line>            }</span><br><span class=line>        });</span><br><span class=line></span><br><span class=line>        Thread t2 = <span class=keyword>new</span> Thread(() -> {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < <span class=number>1000</span>; i++) {</span><br><span class=line>                counter.increment();</span><br><span class=line>            }</span><br><span class=line>        });</span><br><span class=line></span><br><span class=line>        <span class=comment>// 启动线程</span></span><br><span class=line>        t1.start();</span><br><span class=line>        t2.start();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 等待线程完成</span></span><br><span class=line>        t1.join();</span><br><span class=line>        t2.join();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 输出最终计数器的值</span></span><br><span class=line>        System.out.println(<span class=string>"Final counter value: "</span> + counter.getValue());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h5 id=乐观锁和悲观锁><a class=headerlink href=#乐观锁和悲观锁 title=乐观锁和悲观锁></a>乐观锁和悲观锁</h5><p>乐观锁（Optimistic Locking）和悲观锁（Pessimistic Locking）是两种处理并发控制的策略，它们在如何管理数据冲突方面采取了不同的方法。<p>乐观锁则假设不会发生并发冲突，因此不会主动加锁。它允许所有事务同时读取并尝试修改数据，但在提交更改前检查是否有其他事务已经修改了相同的数据。如果有，则拒绝此次修改或根据具体业务逻辑进行重试或其他处理。<p>悲观锁假设会发生并发冲突，因此在操作数据时会直接加锁，防止其他事务对该数据进行修改直到当前事务完成。<p><strong>使用悲观锁</strong>的方式可能是这样的：在处理订单时首先锁定库存记录，然后检查库存是否足够，若足够则扣减库存并提交事务释放锁；否则回滚事务并告知用户库存不足。<p><strong>使用乐观锁</strong>的方式则是：在开始处理订单时不加锁，而是记录下当前库存记录的版本号或时间戳。在准备扣减库存时再次检查版本号或时间戳是否未变，若未变则扣减库存并更新版本号/时间戳；若有变化则表明期间有其他订单已修改了库存，此时可以选择重试或通知用户稍后再试。<h5 id=原子操作类><a class=headerlink href=#原子操作类 title=原子操作类></a>原子操作类</h5><ol><li>CAS 操作</ol><p>CAS（Compare-And-Swap）是实现原子操作的核心机制。它是一个低级别的、硬件提供的原子指令，通常用于无锁算法中。一个典型的 CAS 操作包含三个参数：<ul><li><strong>内存位置 V</strong>：要更新的数据在内存中的地址。<li><strong>预期值 A</strong>：期望在内存位置 V 处找到的值。<li><strong>新值 B</strong>：如果内存位置 V 的当前值等于预期值 A，则将该位置的值更新为新值 B。</ul><p>CAS 操作会检查内存位置 V 的当前值是否与预期值 A 相等。如果相等，则将内存位置 V 更新为新值 B，并返回成功；如果不相等，则不进行任何修改，并返回失败。这个过程是原子性的，意味着在同一时刻只能有一个线程成功执行 CAS 操作。<blockquote><p>传统的 <code>AtomicLong</code> (以及AtomicInteger等)使用 CAS（Compare-And-Swap）操作来保证线程安全，但在高并发情况下，多个线程同时竞争同一个值时，CAS 操作可能会频繁失败并重试，导致性能下降。<p><code>LongAdder</code> 的设计目标是解决这个问题。它通过<strong>分段锁</strong>的思想将数据分散到多个变量中，减少了线程间的竞争，从而提高了性能。最终结果可以通过这些变量汇总得到。</blockquote><ol><li>Java 内存模型 (JMM)</ol><p>Java 内存模型定义了多线程环境下变量的可见性和顺序性规则。为了保证线程间共享变量的一致性，Java 提供了 <code>volatile</code> 关键字和同步块 (<code>synchronized</code>) 来确保变量的可见性。原子类内部使用了类似的技术来确保线程间的可见性，即使它们自身并不总是需要显式的同步块。<ol><li>Unsafe 类</ol><p>Java 的原子类内部通常使用 <code>sun.misc.Unsafe</code> 类提供的本地方法来直接调用底层的 CAS 操作。虽然 <code>Unsafe</code> 类并不是官方推荐的 API，但它被广泛应用于高性能并发库中，如 <code>java.util.concurrent</code> 包内的实现。通过 <code>Unsafe</code>，开发者可以绕过 Java 的安全检查直接与操作系统交互，这使得它可以非常高效地执行 CAS 操作。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>AtomicIntegerExample</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        AtomicInteger atomicInt = <span class=keyword>new</span> AtomicInteger(<span class=number>0</span>);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 原子递增</span></span><br><span class=line>        System.out.println(<span class=string>"Initial value: "</span> + atomicInt.get());</span><br><span class=line>        atomicInt.incrementAndGet(); <span class=comment>// 自增1</span></span><br><span class=line>        System.out.println(<span class=string>"After increment: "</span> + atomicInt.get());</span><br><span class=line></span><br><span class=line>        <span class=comment>// 原子更新</span></span><br><span class=line>        atomicInt.updateAndGet(x -> x * <span class=number>2</span>); <span class=comment>// 使用函数式更新</span></span><br><span class=line>        System.out.println(<span class=string>"After update: "</span> + atomicInt.get());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=synchronized优化><a class=headerlink href=#synchronized优化 title=synchronized优化></a>synchronized优化</h3><h4 id=偏向锁><a class=headerlink href=#偏向锁 title=偏向锁></a>偏向锁</h4><p>偏向锁的设计初衷是为了<strong>消除无竞争情况下的同步原语，进一步提高程序的运行性能</strong>。当一个线程访问同步块并获取锁时,<strong>会在对象头中记录当前线程的ID，表示该线程占有了这个对象的锁。</strong><p>当大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得时，使用偏向锁可以减少不必要的同步操作。<p>特性：当没有其他线程尝试获取同一个锁时，持有偏向锁的线程不需要进行同步操作。<p>如果有其他线程尝试获取偏向锁，则会发生偏向锁撤销，锁可能会升级为轻量级锁。<h4 id=轻量级锁><a class=headerlink href=#轻量级锁 title=轻量级锁></a>轻量级锁</h4><p>Java 轻量级锁是 JVM 提供的一种优化机制，旨在<strong>减少多线程环境下获取锁的开销</strong>。它主要通过使用 CAS（Compare-And-Swap）操作来避免传统锁带来的性能损耗，<strong>适用于线程竞争较少的情况</strong>。轻量级锁是 Java 锁机制的一部分，它可以动态升级为重量级锁以应对更高的竞争情况。<ul><li>在线程交替执行同步块且存在轻微的竞争时，轻量级锁能够通过CAS（Compare-and-Swap）操作来避免线程阻塞和上下文切换。<li>特性<ul><li>每个线程都有自己的栈帧，其中包含用于存储锁的记录空间（Lock Record）。当线程试图获取轻量级锁时，会将对象头中的Mark Word复制到该线程的锁记录中，并尝试通过CAS操作将对象头指向该线程的锁记录。<li>若<strong>多个线程同时请求轻量级锁且自旋一定次数后仍未成功获取锁，则锁将膨胀为重量级锁</strong>。</ul></ul><h4 id=轻量级锁的工作原理><a class=headerlink href=#轻量级锁的工作原理 title=轻量级锁的工作原理></a>轻量级锁的工作原理</h4><ol><li><strong>加锁过程</strong><ul><li>当一个线程尝试获取锁时，如果对象没有被锁定（锁标志位为“01”），JVM 会在当前线程的栈帧中创建一个称为 Lock Record 的空间，并<strong>将对象头中的 Mark Word 复制到这个 Lock Record 中</strong>。<li>然后，线程会尝试用 CAS 操作<strong>将对象头中的 Mark Word 更新为指向该线程 Lock Record 的指针</strong>。如果成功，则该线程获得了锁。<li>如果 CAS 操作失败，意味着另一个线程已经持有了锁，这时当前线程会自旋（忙等）一段时间，尝试重新获取锁。</ul><li><strong>解锁过程</strong><ul><li>当线程退出同步块时，会使用 CAS 操作尝试将对象头中的 Mark Word 恢复为其原始值（即从 Lock Record 中拷贝回来的 Displaced Mark Word）。<li>如果 CAS 操作成功，则表示没有其他线程尝试获取该锁，锁被成功释放。<li>如果 CAS 操作失败，说明有其他线程尝试获取过该锁，此时轻量级锁将会膨胀为重量级锁。</ul><li><strong>锁的升级</strong><ul><li>轻量级锁在遇到高竞争（即多个线程频繁尝试获取同一把锁）的情况下，可能会膨胀为重量级锁。这是因为持续的自旋等待会消耗大量的 CPU 资源。<li>一旦锁升级为重量级锁，后续试图获取锁的线程将进入阻塞状态，直到锁被释放。</ul><li><strong>适用场景</strong><ul><li>轻量级锁适用于线程竞争不激烈、锁占用时间较短的情况。在这种情况下，轻量级锁能够通过 CAS 操作和自旋来避免线程的阻塞和上下文切换，从而提高程序的并发性能。<li>对于锁竞争较为激烈的场景，建议使用 ReentrantLock 或者其他的高级同步机制，因为这些机制提供了更灵活的锁管理和更好的性能表现。</ul></ol><h4 id=重量锁><a class=headerlink href=#重量锁 title=重量锁></a>重量锁</h4><p>重量级锁通过操作系统提供的互斥量（mutex）来实现线程间的同步，这种锁会让线程调用者进入阻塞状态，并被操作系统挂起。<p>在高竞争环境下，即多个线程频繁争夺同一资源时，重量级锁能够确保数据的一致性和完整性。<p>特性<ul><li>锁住的线程会被挂起直到锁被释放，此时其他等待的线程才有可能获取锁。<li>由于<strong>涉及用户态到内核态的切换以及线程的挂起和唤醒，重量级锁的开销较大</strong>。</ul><h4 id=锁膨胀><a class=headerlink href=#锁膨胀 title=锁膨胀></a>锁膨胀</h4><p>锁膨胀（Lock Escalation）在Java中通常指的是synchronized关键字背后的锁机制随着竞争条件的变化而动态升级的过程。具体来说，在Java虚拟机（JVM）中，锁的状态可以经历从无锁状态到偏向锁、轻量级锁，最后到重量级锁的转变过程。这个过程称为锁膨胀或锁升级，并且它是一个单向的过程，即锁只能从低级别向高级别升级，不能降级。<p>锁膨胀的具体过程：<ol><li><strong>无锁状态</strong>：当对象刚创建时，没有线程尝试获取该对象上的锁，此时处于无锁状态。<li><strong>偏向锁状态</strong>：当第一个线程尝试获取对象上的锁时，JVM会将锁设置为偏向锁，并记录下持有偏向锁的线程ID。如果之后还是同一个线程访问，则不需要再次进行加锁操作，直接进入同步块执行代码。偏向锁的目标是减少无实际竞争情况下的锁获取成本。<li><strong>轻量级锁状态</strong>：如果有第二个线程尝试获取已经被偏向锁持有的对象的锁时，偏向锁会升级为轻量级锁。轻量级锁使用CAS（Compare and Swap）操作来尝试获取锁，以减少锁的竞争和系统的开销。轻量级锁适用于多个线程交替执行同步块的情况。<li><strong>重量级锁状态</strong>：当多个线程长时间竞争同一个对象的锁时，轻量级锁会升级为重量级锁。重量级锁采用操作系统的互斥量（Mutex）来实现，确保线程的安全性。在这种状态下，JVM会创建一个等待队列，将等待获取锁的线程挂起在队列中。重量级锁会导致较大的性能开销，因为它涉及到用户态与内核态之间的切换。</ol><p>锁膨胀的设计目的是为了优化多线程环境下的性能。通过这种方式，JVM可以根据不同的并发场景自动调整锁的状态，从而减少不必要的性能损耗。例如，在几乎没有竞争的情况下，偏向锁可以提供很好的性能；而在有少量竞争的情况下，轻量级锁可以通过自旋避免阻塞，提高效率；只有在高竞争的情况下，才会升级为重量级锁。这种机制使得synchronized在大多数情况下都能够高效运行。<h4 id=其他优化><a class=headerlink href=#其他优化 title=其他优化></a>其他优化</h4><ol><li>减少上锁时间<li>减少锁的颗粒度 使用concurrentHashMap<li>锁粗化 多次循环进入同步块不如在同步块内进行循环<li>锁消除<li>读写分离</ol><h2 id=JUC><a class=headerlink href=#JUC title=JUC></a>JUC</h2><h4 id=创建线程><a class=headerlink href=#创建线程 title=创建线程></a>创建线程</h4><p><strong>1. 继承 <code>Thread</code> 类</strong><p><strong>(1) 基本原理</strong><p>通过继承 <code>Thread</code> 类并重写 <code>run()</code> 方法，调用 <code>start()</code> 方法启动线程。<p><strong>(2) 示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>MyThread</span> <span class=keyword>extends</span> <span class=title>Thread</span> </span>{</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>run</span><span class=params>()</span> </span>{</span><br><span class=line>        System.out.println(<span class=string>"Thread running: "</span> + Thread.currentThread().getName());</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>Main</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        MyThread thread1 = <span class=keyword>new</span> MyThread();</span><br><span class=line>        MyThread thread2 = <span class=keyword>new</span> MyThread();</span><br><span class=line></span><br><span class=line>        thread1.start(); <span class=comment>// 启动线程</span></span><br><span class=line>        thread2.start(); <span class=comment>// 启动线程</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>(3) 优点</strong><ul><li>简单直观，易于理解。</ul><p><strong>(4) 缺点</strong><ul><li><p>Java 不支持多重继承，如果一个类已经继承了其他类，则无法再继承 <code>Thread</code>。</p> <p><strong>2. 实现 <code>Runnable</code> 接口</strong></p></ul><p><strong>(1) 基本原理</strong><p>通过实现 <code>Runnable</code> 接口并实现 <code>run()</code> 方法，将 <code>Runnable</code> 对象传递给 <code>Thread</code> 构造器来启动线程。<p><strong>(2) 示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>MyRunnable</span> <span class=keyword>implements</span> <span class=title>Runnable</span> </span>{</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>run</span><span class=params>()</span> </span>{</span><br><span class=line>        System.out.println(<span class=string>"Runnable running: "</span> + Thread.currentThread().getName());</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>Main</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        Thread thread1 = <span class=keyword>new</span> Thread(<span class=keyword>new</span> MyRunnable());</span><br><span class=line>        Thread thread2 = <span class=keyword>new</span> Thread(<span class=keyword>new</span> MyRunnable());</span><br><span class=line></span><br><span class=line>        thread1.start(); <span class=comment>// 启动线程</span></span><br><span class=line>        thread2.start(); <span class=comment>// 启动线程</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>(3) 优点</strong><ul><li>更灵活：可以避免因为继承 <code>Thread</code> 而导致的多重继承问题。<li>适合资源共享（多个线程共享同一个 <code>Runnable</code> 实例）。</ul><p><strong>(4) 缺点</strong><ul><li>需要显式地将 <code>Runnable</code> 对象传递给 <code>Thread</code>。</ul><p><strong>3. 使用 <code>Callable</code> 和 <code>FutureTask</code></strong><p><strong>(1) 基本原理</strong><p><code>Callable</code> 接口类似于 <code>Runnable</code>，但<strong>它可以返回结果，并且可以抛出异常。<code>FutureTask</code> 是一个包装类，</strong>用于管理 <code>Callable</code> 的执行结果。<p><strong>(2) 示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.concurrent.Callable;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.FutureTask;</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>MyCallable</span> <span class=keyword>implements</span> <span class=title>Callable</span><<span class=title>Integer</span>> </span>{</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> Integer <span class=title>call</span><span class=params>()</span> <span class=keyword>throws</span> Exception </span>{</span><br><span class=line>        System.out.println(<span class=string>"Callable running: "</span> + Thread.currentThread().getName());</span><br><span class=line>        <span class=keyword>return</span> <span class=number>42</span>; <span class=comment>// 返回计算结果</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>Main</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> Exception </span>{</span><br><span class=line>        FutureTask&LTInteger> futureTask1 = <span class=keyword>new</span> FutureTask<>(<span class=keyword>new</span> MyCallable());</span><br><span class=line>        FutureTask&LTInteger> futureTask2 = <span class=keyword>new</span> FutureTask<>(<span class=keyword>new</span> MyCallable());</span><br><span class=line></span><br><span class=line>        Thread thread1 = <span class=keyword>new</span> Thread(futureTask1);</span><br><span class=line>        Thread thread2 = <span class=keyword>new</span> Thread(futureTask2);</span><br><span class=line></span><br><span class=line>        thread1.start();</span><br><span class=line>        thread2.start();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 获取线程执行结果</span></span><br><span class=line>        System.out.println(<span class=string>"Result from thread1: "</span> + futureTask1.get());</span><br><span class=line>        System.out.println(<span class=string>"Result from thread2: "</span> + futureTask2.get());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>(3) 优点</strong><ul><li>可以返回结果。<li>可以捕获线程中的异常。<li>适合需要获取线程执行结果的场景。</ul><p><strong>(4) 缺点</strong><ul><li>相比 <code>Runnable</code>，代码稍微复杂一些。</ul><p><strong>4. 使用线程池（推荐）</strong><p><strong>(1) 基本原理</strong><p>Java 提供了 <code>ExecutorService</code> 接口和 <code>Executors</code> 工厂类，用于管理和复用线程，避免频繁创建和销毁线程带来的开销。<p><strong>(2) 示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.concurrent.ExecutorService;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.Executors;</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Task</span> <span class=keyword>implements</span> <span class=title>Runnable</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>Task</span><span class=params>(String name)</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.name = name;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>run</span><span class=params>()</span> </span>{</span><br><span class=line>        System.out.println(<span class=string>"Executing task: "</span> + name + <span class=string>" in thread: "</span> + Thread.currentThread().getName());</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>Main</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        ExecutorService executor = Executors.newFixedThreadPool(<span class=number>3</span>); <span class=comment>// 创建固定大小的线程池</span></span><br><span class=line></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < <span class=number>5</span>; i++) {</span><br><span class=line>            executor.submit(<span class=keyword>new</span> Task(<span class=string>"Task-"</span> + i));</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        executor.shutdown(); <span class=comment>// 关闭线程池</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>(3) 优点</strong><ul><li>高效：线程池可以复用线程，减少线程创建和销毁的开销。<li>灵活：可以设置线程池大小、任务队列等。<li>易于管理：提供更高级的任务调度和生命周期管理功能。</ul><p><strong>(4) 缺点</strong><ul><li>初学者可能觉得使用线程池的 API 比较复杂。</ul><p><strong>5. 使用 Lambda 表达式（简化代码）</strong><p>从 Java 8 开始，可以使用 Lambda 表达式进一步简化线程的创建和使用。<p><strong>(1) 示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>Main</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        <span class=comment>// 使用 Lambda 表达式实现 Runnable</span></span><br><span class=line>        Thread thread1 = <span class=keyword>new</span> Thread(() -> </span><br><span class=line>            System.out.println(<span class=string>"Lambda thread running: "</span> + Thread.currentThread().getName())</span><br><span class=line>        );</span><br><span class=line></span><br><span class=line>        <span class=comment>// 使用 Lambda 表达式提交任务到线程池</span></span><br><span class=line>        ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class=line>        executor.submit(() -> </span><br><span class=line>            System.out.println(<span class=string>"Lambda task running: "</span> + Thread.currentThread().getName())</span><br><span class=line>        );</span><br><span class=line></span><br><span class=line>        thread1.start();</span><br><span class=line>        executor.shutdown();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>(2) 优点</strong><ul><li>简洁：减少了样板代码。<li>易读：代码更加紧凑。</ul><p><strong>6. 总结与选择建议</strong><div class=table-container><table><thead><tr><th>方法<th>适用场景<th>优点<th>缺点<tbody><tr><td>继承 <code>Thread</code> 类<td>简单任务，快速验证<td>简单直观<td>不能多重继承<tr><td>实现 <code>Runnable</code> 接口<td>多线程共享资源<td>灵活，避免多重继承限制<td>需要显式传递 <code>Runnable</code><tr><td>使用 <code>Callable</code> 和 <code>FutureTask</code><td>需要返回结果或处理异常的任务<td>支持返回值和异常处理<td>代码稍微复杂<tr><td>使用线程池<td>长时间运行的任务，或者需要高效管理线程的场景<td>高效，易于管理<td>API 较复杂<tr><td>使用 Lambda 表达式<td>简化代码，尤其是在线程池中<td>代码简洁<td>依赖 Java 8+</table></div><p><img alt=image-20250330162459693 data-src=https://s2.loli.net/2025/03/30/CYqToSF1d9ax7lA.png><h4 id=Syncronized优化原理><a class=headerlink href=#Syncronized优化原理 title=Syncronized优化原理></a>Syncronized优化原理</h4><p><code>synchronized</code> 的底层实现依赖于 JVM 提供的<strong>监视器锁（Monitor）\</strong>机制，而监视器锁最终映射到操作系统提供的*<em>互斥锁（Mutex Lock）*</em>。具体来说，<code>synchronized</code> 的工作原理分为以下几个阶段：<p><strong>(1) Monitor（监视器）</strong><ul><li>每个 Java 对象都有一个与之关联的监视器（Monitor），也称为“内置锁”或“监视器锁”。<li>监视器的作用是确保同一时刻只有一个线程能够持有该锁并执行同步代码。</ul><p><strong>(2) 对象头中的 Mark Word</strong><ul><li>在 HotSpot 虚拟机中，每个 Java 对象都有一个对象头（Object Header），其中包含一个 <code>Mark Word</code>。<li><code>Mark Word</code> 用来存储对象的元信息，例如哈希码、GC 分代年龄、锁状态等。<li>当线程尝试获取锁时，<code>Mark Word</code> 的内容会动态变化，表示锁的状态（无锁、偏向锁、轻量级锁、重量级锁）。</ul><p><strong>(3) 锁的升级机制</strong><p>为了优化性能，<code>synchronized</code> 实现了锁的升级机制，从低开销的锁逐步升级到高开销的锁。锁的升级过程如下：<ol><li><strong>无锁状态</strong>：<ul><li>初始状态下，对象没有被任何线程锁定。</ul><li><strong>偏向锁（Biased Locking）</strong>：<ul><li>如果某个线程多次进入同步代码块，JVM 会将锁偏向于该线程。<li>偏向锁通过在 <code>Mark Word</code> 中记录线程 ID 来实现，避免每次加锁和解锁都需要 CAS（Compare-And-Swap）操作。<li>偏向锁适用于单线程访问同步代码块的场景。</ul><li><strong>轻量级锁（Lightweight Locking）</strong>：<ul><li>当有多个线程竞争同一个锁时，偏向锁会升级为轻量级锁。<li>轻量级锁使用自旋的方式尝试获取锁，减少线程上下文切换的开销。<li>如果自旋成功，则直接获取锁；如果自旋失败，则升级为重量级锁。</ul><li><strong>重量级锁（Heavyweight Locking）</strong>：<ul><li>当竞争激烈时，轻量级锁会升级为重量级锁。<li>重量级锁依赖于操作系统的互斥锁（Mutex Lock），会导致线程阻塞和唤醒，开销较大。</ul></ol><p><strong>(4) 锁的释放</strong><ul><li>当线程退出同步代码块时，会释放锁。<li>JVM 会根据锁的状态（偏向锁、轻量级锁、重量级锁）进行相应的处理，恢复对象头的 <code>Mark Word</code> 状态。</ul><div class=table-container><table><thead><tr><th>特性<th><code>synchronized</code><th><code>ReentrantLock</code><tbody><tr><td><strong>实现方式</strong><td>JVM 内置关键字<td>显式锁，API 实现<tr><td><strong>锁优化</strong><td>支持偏向锁、轻量级锁<td>不支持<tr><td><strong>公平性</strong><td>非公平锁<td>支持公平锁<tr><td><strong>可中断性</strong><td>不支持<td>支持<tr><td><strong>超时机制</strong><td>不支持<td>支持<tr><td><strong>条件变量</strong><td>不支持<td>支持（通过 <code>Condition</code>）</table></div><p><img alt=image-20250330171150577 data-src=https://s2.loli.net/2025/03/30/8PW4irnVQOo1U7M.png><h4 id=ReentrantLock><a class=headerlink href=#ReentrantLock title=ReentrantLock></a>ReentrantLock</h4><p><code>ReentrantLock</code> 是 Java 提供的一种可重入的互斥锁，它位于 <code>java.util.concurrent.locks</code> 包中，是 <code>Lock</code> 接口的一个实现类。相比于 <code>synchronized</code> 关键字，<code>ReentrantLock</code> 提供了更灵活、更强大的锁机制，适用于复杂的并发场景。<p>可重入锁（Reentrant Lock） 指的是一个线程可以多次获取同一个锁而不被自己阻塞。这意味着如果一个线程已经持有了某个锁，并尝试再次获取该锁，则该操作会成功，而不是导致死锁。每次获取锁时，锁内部的计数器会增加；每次释放锁时，计数器会减少；只有当计数器归零时，锁才会真正被释放，允许其他线程获取。<h5 id=可重入><a class=headerlink href=#可重入 title=可重入></a>可重入</h5><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ReentrantLockExample</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> ReentrantLock lock = <span class=keyword>new</span> ReentrantLock();</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>firstMethod</span><span class=params>()</span> </span>{</span><br><span class=line>        lock.lock();</span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            <span class=comment>// 执行一些操作</span></span><br><span class=line>            secondMethod();</span><br><span class=line>        } <span class=keyword>finally</span> {</span><br><span class=line>            lock.unlock();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>secondMethod</span><span class=params>()</span> </span>{</span><br><span class=line>        lock.lock();</span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            <span class=comment>// 执行更多操作</span></span><br><span class=line>        } <span class=keyword>finally</span> {</span><br><span class=line>            lock.unlock();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h5 id=可打断><a class=headerlink href=#可打断 title=可打断></a>可打断</h5><p>“可打断”（Interruptible）指的是线程在<strong>等待某种资源或处于阻塞状态时,是否能够响应中断请求并进行相应的处理</strong>.当一个线程处于不可打断的状态下（如通过某些同步机制等待获取锁）,它将不会响应中断信号；而在可打断状态下,线程可以捕获到中断请求,并根据应用逻辑决定如何处理这个中断.<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>InterruptibleLockExample</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> ReentrantLock lock = <span class=keyword>new</span> ReentrantLock();</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>performTask</span><span class=params>()</span> <span class=keyword>throws</span> InterruptedException </span>{</span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            System.out.println(Thread.currentThread().getName() + <span class=string>" is trying to acquire the lock."</span>);</span><br><span class=line>            <span class=comment>// 尝试获取锁，但是可以响应中断</span></span><br><span class=line>            lock.lockInterruptibly();</span><br><span class=line>            <span class=keyword>try</span> {</span><br><span class=line>                System.out.println(Thread.currentThread().getName() + <span class=string>" has acquired the lock."</span>);</span><br><span class=line>                <span class=comment>// 模拟任务处理</span></span><br><span class=line>                Thread.sleep(<span class=number>5000</span>);</span><br><span class=line>            } <span class=keyword>finally</span> {</span><br><span class=line>                lock.unlock();</span><br><span class=line>            }</span><br><span class=line>        } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>            System.out.println(Thread.currentThread().getName() + <span class=string>" was interrupted while waiting for the lock."</span>);</span><br><span class=line>            <span class=comment>// 处理中断，通常这里需要做一些清理工作</span></span><br><span class=line>            Thread.currentThread().interrupt(); <span class=comment>// 重新设置中断标志</span></span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> InterruptedException </span>{</span><br><span class=line>        InterruptibleLockExample example = <span class=keyword>new</span> InterruptibleLockExample();</span><br><span class=line></span><br><span class=line>        Thread t1 = <span class=keyword>new</span> Thread(() -> {</span><br><span class=line>            <span class=keyword>try</span> {</span><br><span class=line>                example.performTask();</span><br><span class=line>            } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>                e.printStackTrace();</span><br><span class=line>            }</span><br><span class=line>        }, <span class=string>"Worker-1"</span>);</span><br><span class=line></span><br><span class=line>        Thread t2 = <span class=keyword>new</span> Thread(() -> {</span><br><span class=line>            <span class=keyword>try</span> {</span><br><span class=line>                Thread.sleep(<span class=number>1000</span>); <span class=comment>// 让 t1 先开始尝试获取锁</span></span><br><span class=line>                example.performTask();</span><br><span class=line>            } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>                e.printStackTrace();</span><br><span class=line>            }</span><br><span class=line>        }, <span class=string>"Worker-2"</span>);</span><br><span class=line></span><br><span class=line>       t1.start();</span><br><span class=line>        t2.start();</span><br><span class=line></span><br><span class=line>        Thread.sleep(<span class=number>2000</span>); <span class=comment>// 主线程等待一段时间后中断 t2</span></span><br><span class=line>        t2.interrupt();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h5 id=尝试获取锁><a class=headerlink href=#尝试获取锁 title=尝试获取锁></a>尝试获取锁</h5><ul><li><code>boolean tryLock()</code><ul><li>尝试获取锁。如果锁可用，则立即获取并返回 <code>true</code>；否则返回 <code>false</code>。</ul><li><code>boolean tryLock(long timeout, TimeUnit unit)</code><ul><li>尝试在指定时间内获取锁。如果在超时前获取到锁，则返回 <code>true</code>；否则返回 <code>false</code>。</ul></ul><h5 id=公平锁><a class=headerlink href=#公平锁 title=公平锁></a>公平锁</h5><p><code>ReentrantLock</code> <strong>默认是非公平锁</strong>。也就是说，当多个线程竞争锁时，默认情况下新来的线程可能会直接插队获取锁，而不需要严格按照线程等待的顺序（FIFO 队列）来分配锁。<p><strong>公平锁与非公平锁的区别</strong><ol><li><strong>公平锁（Fair Lock）</strong><ul><li>公平锁会按照线程请求锁的顺序（即 FIFO 队列）来分配锁。<li>这种方式可以避免线程饥饿问题，但可能会导致性能下降，因为线程切换的开销较高。</ul><li><strong>非公平锁（Non-Fair Lock）</strong><ul><li>非公平锁允许插队，即新来的线程可以直接尝试获取锁，而不需要排队。<li>这种方式减少了线程上下文切换的开销，提高了吞吐量，但在高并发场景下可能导致某些线程长时间无法获取锁（饥饿问题）。</ul></ol><h5 id=与条件变量><a class=headerlink href=#与条件变量 title=与条件变量></a>与条件变量</h5><p>在并发编程中，条件变量是一种用于线程间协调的机制。它允许一个或多个线程等待某个条件变为真，而不是忙等（busy-waiting）。在Java中，<code>Condition</code> 接口由 <code>ReentrantLock</code> 类提供支持，<strong>每个 <code>ReentrantLock</code> 可以创建多个 <code>Condition</code> 实例，从而实现更加灵活的线程控制</strong>。<p><code>Condition</code> 接口的主要方法<ul><li><strong>await()</strong>：使当前线程等待，并释放锁。直到其他线程调用 <code>signal()</code> 或 <code>signalAll()</code> 方法唤醒它。<li><strong>signal()</strong>：唤醒一个等待该条件的线程。如果有多个线程在等待，则选择其中的一个。<li><strong>signalAll()</strong>：唤醒所有等待该条件的线程。<li><strong>awaitUninterruptibly()</strong>：类似于 <code>await()</code>，但是不会响应中断。<li><strong>awaitNanos(long nanosTimeout)</strong>、<strong>awaitUntil(Date deadline)</strong>：带超时的等待方法。</ul><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.concurrent.locks.Condition;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.locks.Lock;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ProducerConsumerExample</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> Lock lock = <span class=keyword>new</span> ReentrantLock();</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> Condition notFull = lock.newCondition();</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> Condition notEmpty = lock.newCondition();</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> <span class=keyword>int</span>[] buffer;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>int</span> count = <span class=number>0</span>;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>ProducerConsumerExample</span><span class=params>(<span class=keyword>int</span> size)</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.buffer = <span class=keyword>new</span> <span class=keyword>int</span>[size];</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>produce</span><span class=params>(<span class=keyword>int</span> value)</span> <span class=keyword>throws</span> InterruptedException </span>{</span><br><span class=line>        lock.lock();</span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            <span class=keyword>while</span> (count == buffer.length) { <span class=comment>// Buffer is full</span></span><br><span class=line>                notFull.await(); <span class=comment>// Wait until buffer is not full</span></span><br><span class=line>            }</span><br><span class=line>            buffer[count] = value;</span><br><span class=line>            count++;</span><br><span class=line>            notEmpty.signal(); <span class=comment>// Signal that buffer is not empty now</span></span><br><span class=line>        } <span class=keyword>finally</span> {</span><br><span class=line>            lock.unlock();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>int</span> <span class=title>consume</span><span class=params>()</span> <span class=keyword>throws</span> InterruptedException </span>{</span><br><span class=line>        lock.lock();</span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            <span class=keyword>while</span> (count == <span class=number>0</span>) { <span class=comment>// Buffer is empty</span></span><br><span class=line>                notEmpty.await(); <span class=comment>// Wait until buffer is not empty</span></span><br><span class=line>            }</span><br><span class=line>            count--;</span><br><span class=line>            <span class=keyword>int</span> value = buffer[count];</span><br><span class=line>            notFull.signal(); <span class=comment>// Signal that buffer is not full now</span></span><br><span class=line>            <span class=keyword>return</span> value;</span><br><span class=line>        } <span class=keyword>finally</span> {</span><br><span class=line>            lock.unlock();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        ProducerConsumerExample example = <span class=keyword>new</span> ProducerConsumerExample(<span class=number>5</span>);</span><br><span class=line></span><br><span class=line>        Runnable producerTask = () -> {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < <span class=number>10</span>; i++) {</span><br><span class=line>                <span class=keyword>try</span> {</span><br><span class=line>                    example.produce(i);</span><br><span class=line>                    System.out.println(<span class=string>"Produced: "</span> + i);</span><br><span class=line>                } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>                    Thread.currentThread().interrupt();</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        };</span><br><span class=line></span><br><span class=line>        Runnable consumerTask = () -> {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < <span class=number>10</span>; i++) {</span><br><span class=line>                <span class=keyword>try</span> {</span><br><span class=line>                    <span class=keyword>int</span> value = example.consume();</span><br><span class=line>                    System.out.println(<span class=string>"Consumed: "</span> + value);</span><br><span class=line>                } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>                    Thread.currentThread().interrupt();</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        };</span><br><span class=line></span><br><span class=line>        <span class=keyword>new</span> Thread(producerTask).start();</span><br><span class=line>        <span class=keyword>new</span> Thread(consumerTask).start();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h4 id=volatile原理><a class=headerlink href=#volatile原理 title=volatile原理></a>volatile原理</h4><p><code>volatile</code> 是 Java 中的一个关键字，用于修饰变量，它提供了一种<strong>比锁更轻量级的同步机制</strong>。尽管 <code>volatile</code> 并不能替代 synchronized 关键字所提供的所有功能，但在某些特定场景下，它可以有效地保证线程间的可见性和有序性。<p><strong>工作原理</strong><ol><li><strong>可见性</strong>：<strong>当一个线程对一个 <code>volatile</code> 变量进行写操作时，会将该变量立即刷新到主内存中</strong>。而当其他线程读取这个 <code>volatile</code> 变量时，它们会被强制从主内存中重新读取这个变量的最新值，而不是使用自己工作内存中的缓存副本。这就确保了所有线程都能看到最新的变量值。<li><strong>禁止指令重排序优化</strong>：Java 编译器和处理器可以对指令进行重排序以提高执行效率。然而，这种重排序可能会导致多线程环境下的程序出现意料之外的行为。<code>volatile</code> 变量可以防止编译器对涉及该变量的操作进行指令重排序，从而保持代码的预期执行顺序。</ol><p>虽然 <code>volatile</code> 和原子类（如 <code>AtomicInteger</code>）都提供了线程安全的操作，但它们之间存在一些关键差异：<ul><li><strong>原子性</strong>：<code>volatile</code> 只能保证变量的可见性和有序性，不能保证复合操作（比如增加、减少）的原子性。而原子类通过使用 CAS（比较并交换）等硬件级别的原子操作来保证操作的原子性。<li><strong>性能</strong>：由于 <code>volatile</code> 不需要像锁那样复杂的开销，因此在只涉及简单状态更新的情况下，它的性能通常优于基于锁的解决方案。但是，在需要进行复杂的状态转换或需要保证原子性的场景下，原子类可能是更好的选择。</ul><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>FlagExample</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>volatile</span> <span class=keyword>boolean</span> flag = <span class=keyword>false</span>;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> InterruptedException </span>{</span><br><span class=line>        Thread t1 = <span class=keyword>new</span> Thread(() -> {</span><br><span class=line>            System.out.println(<span class=string>"Thread is waiting for the flag to be set."</span>);</span><br><span class=line>            <span class=keyword>while</span> (!flag) {</span><br><span class=line>                <span class=comment>// 等待直到flag被设置为true</span></span><br><span class=line>            }</span><br><span class=line>            System.out.println(<span class=string>"Flag has been set, thread is proceeding."</span>);</span><br><span class=line>        });</span><br><span class=line></span><br><span class=line>        t1.start();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 主线程暂停一段时间</span></span><br><span class=line>        Thread.sleep(<span class=number>1000</span>);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 设置标志位</span></span><br><span class=line>        flag = <span class=keyword>true</span>;</span><br><span class=line>        System.out.println(<span class=string>"Flag has been set by main thread."</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><code>volatile</code> 适用于以下场景：<ul><li>变量的写入不依赖于其当前值。<li>变量不需要与其他状态变量共同参与不变约束。<li>对变量的访问都是原子操作（例如，简单的布尔标志）。</ul><h4 id=自定义线程池><a class=headerlink href=#自定义线程池 title=自定义线程池></a>自定义线程池</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br><span class=line>103</span><br><span class=line>104</span><br><span class=line>105</span><br><span class=line>106</span><br><span class=line>107</span><br><span class=line>108</span><br><span class=line>109</span><br><span class=line>110</span><br><span class=line>111</span><br><span class=line>112</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>ThreadPool</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> BlockingQueue&LTRunnable> taskQueue;</span><br><span class=line>    <span class=keyword>private</span> HashSet&LTWorker> workers = <span class=keyword>new</span> HashSet<>();</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>int</span> coreSize; <span class=comment>// 核心线程数</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>long</span> timeout;</span><br><span class=line>    <span class=keyword>private</span> TimeUnit timeoutUnit;</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>ThreadPool</span><span class=params>(<span class=keyword>int</span> coreSize, <span class=keyword>long</span> timeout, TimeUnit timeoutUnit)</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.coreSize = coreSize;</span><br><span class=line>        <span class=keyword>this</span>.timeout = timeout;</span><br><span class=line>        <span class=keyword>this</span>.timeoutUnit = timeoutUnit;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>execute</span><span class=params>(Runnable task)</span> </span>{</span><br><span class=line>        <span class=keyword>synchronized</span> (workers) {</span><br><span class=line>            <span class=keyword>if</span>(workers.size()&LTcoreSize) {</span><br><span class=line>                Worker worker = <span class=keyword>new</span> Worker(task);</span><br><span class=line>                workers.add(worker);</span><br><span class=line>                worker.start();</span><br><span class=line>            }<span class=keyword>else</span>{</span><br><span class=line>                taskQueue.put(task);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=class><span class=keyword>class</span> <span class=title>Worker</span> <span class=keyword>extends</span> <span class=title>Thread</span> </span>{</span><br><span class=line>        <span class=keyword>private</span> Runnable task;</span><br><span class=line>        <span class=function><span class=keyword>public</span> <span class=title>Worker</span><span class=params>(Runnable task)</span> </span>{</span><br><span class=line>            <span class=keyword>this</span>.task = task;</span><br><span class=line>        }</span><br><span class=line>        <span class=meta>@Override</span></span><br><span class=line>        <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>run</span><span class=params>()</span> </span>{</span><br><span class=line>            <span class=comment>//1) task不为空</span></span><br><span class=line>            <span class=keyword>while</span> (<span class=keyword>this</span>.task != <span class=keyword>null</span> ||(task = taskQueue.take()) != <span class=keyword>null</span>) {</span><br><span class=line>                <span class=keyword>try</span> {</span><br><span class=line>                    task.run();</span><br><span class=line>                }<span class=keyword>catch</span> (Exception e) {</span><br><span class=line>                    e.printStackTrace();</span><br><span class=line>                }<span class=keyword>finally</span> {</span><br><span class=line>                    task = <span class=keyword>null</span>;</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>synchronized</span> (workers) {</span><br><span class=line>                workers.remove(<span class=keyword>this</span>);</span><br><span class=line>            }</span><br><span class=line></span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>BlockingQueue</span><<span class=title>T</span>> </span>{</span><br><span class=line>    <span class=keyword>private</span> Deque&LTT> queue = <span class=keyword>new</span> ArrayDeque<>();</span><br><span class=line>    <span class=keyword>private</span> ReentrantLock lock = <span class=keyword>new</span> ReentrantLock();</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> Condition notEmptyWaitSet = lock.newCondition();</span><br><span class=line>    <span class=keyword>private</span> Condition emptyWaitSet = lock.newCondition();</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>int</span> capacity;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> T <span class=title>take</span><span class=params>()</span> </span>{</span><br><span class=line>        lock.lock();</span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            <span class=keyword>while</span> (queue.isEmpty()) {</span><br><span class=line>                notEmptyWaitSet.await();</span><br><span class=line>            }</span><br><span class=line>            T t = queue.removeFirst();</span><br><span class=line>            emptyWaitSet.signal();</span><br><span class=line>            <span class=keyword>return</span> t;</span><br><span class=line>        } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> RuntimeException(e);</span><br><span class=line>        } <span class=keyword>finally</span> {</span><br><span class=line>            lock.unlock();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>put</span><span class=params>(T t)</span> </span>{</span><br><span class=line>        lock.lock();</span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            <span class=keyword>while</span> (queue.size() == capacity) {</span><br><span class=line>                <span class=keyword>try</span> {</span><br><span class=line>                    emptyWaitSet.await();</span><br><span class=line>                } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>                    <span class=keyword>throw</span> <span class=keyword>new</span> RuntimeException(e);</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>            queue.addLast(t);</span><br><span class=line>            notEmptyWaitSet.signal();</span><br><span class=line>        } <span class=keyword>finally</span> {</span><br><span class=line>            lock.unlock();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> T <span class=title>poll</span><span class=params>(<span class=keyword>long</span> timeout, TimeUnit unit)</span> </span>{</span><br><span class=line>        lock.lock();</span><br><span class=line>       <span class=keyword>try</span> {</span><br><span class=line>           <span class=keyword>long</span> nanos = unit.toNanos(timeout);</span><br><span class=line>           <span class=keyword>while</span>(queue.isEmpty()) {</span><br><span class=line>               <span class=keyword>try</span> {</span><br><span class=line>                   <span class=keyword>if</span> (nanos <= <span class=number>0</span>) {</span><br><span class=line>                       <span class=keyword>return</span> <span class=keyword>null</span>;</span><br><span class=line>                   }</span><br><span class=line>                   nanos = notEmptyWaitSet.awaitNanos(nanos);</span><br><span class=line>               } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>                   <span class=keyword>throw</span> <span class=keyword>new</span> RuntimeException(e);</span><br><span class=line>               }</span><br><span class=line>           }</span><br><span class=line>           T t = queue.removeFirst();</span><br><span class=line>              emptyWaitSet.signal();</span><br><span class=line>              <span class=keyword>return</span> t;</span><br><span class=line>       }<span class=keyword>finally</span> {</span><br><span class=line>           lock.unlock();</span><br><span class=line>       }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>使用JDK提供的方法<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.concurrent.*;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ThreadPoolExample</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        <span class=comment>// 核心线程数</span></span><br><span class=line>        <span class=keyword>int</span> corePoolSize = <span class=number>2</span>;</span><br><span class=line>        <span class=comment>// 最大线程数</span></span><br><span class=line>        <span class=keyword>int</span> maximumPoolSize = <span class=number>4</span>;</span><br><span class=line>        <span class=comment>// 空闲线程存活时间</span></span><br><span class=line>        <span class=keyword>long</span> keepAliveTime = <span class=number>10</span>;</span><br><span class=line>        <span class=comment>// 时间单位</span></span><br><span class=line>        TimeUnit unit = TimeUnit.SECONDS;</span><br><span class=line>        <span class=comment>// 任务队列</span></span><br><span class=line>        BlockingQueue&LTRunnable> workQueue = <span class=keyword>new</span> LinkedBlockingQueue<>(<span class=number>2</span>);</span><br><span class=line>        <span class=comment>// 线程工厂</span></span><br><span class=line>        ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br><span class=line>        <span class=comment>// 拒绝策略</span></span><br><span class=line>        RejectedExecutionHandler handler = <span class=keyword>new</span> ThreadPoolExecutor.AbortPolicy();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 创建线程池</span></span><br><span class=line>        ThreadPoolExecutor executor = <span class=keyword>new</span> ThreadPoolExecutor(</span><br><span class=line>            corePoolSize,</span><br><span class=line>            maximumPoolSize,</span><br><span class=line>            keepAliveTime,</span><br><span class=line>            unit,</span><br><span class=line>            workQueue,</span><br><span class=line>            threadFactory,</span><br><span class=line>            handler</span><br><span class=line>        );</span><br><span class=line></span><br><span class=line>        <span class=comment>// 提交任务</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < <span class=number>10</span>; i++) {</span><br><span class=line>            <span class=keyword>final</span> <span class=keyword>int</span> taskId = i;</span><br><span class=line>            executor.submit(() -> {</span><br><span class=line>                System.out.println(<span class=string>"Task "</span> + taskId + <span class=string>" is running on thread "</span> + Thread.currentThread().getName());</span><br><span class=line>                <span class=keyword>try</span> {</span><br><span class=line>                    Thread.sleep(<span class=number>2000</span>); <span class=comment>// 模拟任务执行</span></span><br><span class=line>                } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>                    Thread.currentThread().interrupt();</span><br><span class=line>                }</span><br><span class=line>            });</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=comment>// 关闭线程池</span></span><br><span class=line>        executor.shutdown();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>ThreadPoolExecutor threadPoolExecutor = <span class=keyword>new</span> ThreadPoolExecutor(<span class=number>1</span>, <span class=number>1</span>, <span class=number>0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=line>               <span class=keyword>new</span> LinkedBlockingQueue&LTRunnable>(), <span class=keyword>new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class=line>       <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < <span class=number>10</span>; i++) {</span><br><span class=line>           Future&LTInteger> submit = threadPoolExecutor.submit(<span class=keyword>new</span> MyCallable());</span><br><span class=line>           <span class=keyword>try</span> {</span><br><span class=line>               System.out.println(submit.get());</span><br><span class=line>           } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>               <span class=keyword>throw</span> <span class=keyword>new</span> RuntimeException(e);</span><br><span class=line>           } <span class=keyword>catch</span> (ExecutionException e) {</span><br><span class=line>               <span class=keyword>throw</span> <span class=keyword>new</span> RuntimeException(e);</span><br><span class=line>           }</span><br><span class=line>       }</span><br></pre></table></figure><p><img alt=image-20250330221744556 data-src=https://s2.loli.net/2025/03/30/Y9PDFgfRLC8Bdp6.png><ol><li><strong>corePoolSize</strong>：<ul><li>核心线程数，即线程池中始终保持的最小线程数量。<li>即使这些线程处于空闲状态，也不会被销毁（除非设置了 <code>allowCoreThreadTimeOut</code>）。</ul><li><strong>maximumPoolSize</strong>：<ul><li>线程池允许的最大线程数。<li>当任务队列已满且当前线程数小于 <code>maximumPoolSize</code> 时，线程池会创建新线程来处理任务。</ul><li><strong>keepAliveTime</strong>：<ul><li>空闲线程的存活时间。<li>如果线程数超过 <code>corePoolSize</code>，多余的空闲线程会在空闲一段时间后被回收。</ul><li><strong>unit</strong>：<ul><li><code>keepAliveTime</code> 的时间单位，例如 <code>TimeUnit.SECONDS</code>。</ul><li><strong>workQueue</strong>：<ul><li>任务队列，用于保存等待执行的任务。<li>常见实现包括：<ul><li><code>ArrayBlockingQueue</code>：有界队列。<li><code>LinkedBlockingQueue</code>：无界队列。<li><code>SynchronousQueue</code>：不存储任务，直接交给线程执行。</ul></ul><li><strong>threadFactory</strong>：<ul><li>创建线程的工厂，用于自定义线程的名称、优先级等属性。<li>默认使用 <code>Executors.defaultThreadFactory()</code>。</ul><li><strong>handler</strong>：<ul><li>拒绝策略，当线程池无法处理新任务时（例如线程池已满且任务队列已满），会调用此策略。<li>常见实现包括：<ul><li><code>AbortPolicy</code>：抛出 <code>RejectedExecutionException</code> 异常。<li><code>CallerRunsPolicy</code>：由调用线程（提交任务的线程）执行该任务。<li><code>DiscardPolicy</code>：直接丢弃任务。<li><code>DiscardOldestPolicy</code>：丢弃队列中最旧的任务，然后尝试重新提交新任务。</ul></ul></ol><p><strong>3. 线程池的工作原理</strong><ol><li><strong>任务提交</strong>：<ul><li>当一个任务被提交到线程池时，线程池会根据当前线程数和任务队列的状态决定如何处理任务。</ul><li><strong>任务分配逻辑</strong>：<ul><li>如果当前线程数小于 <code>corePoolSize</code>，即使有空闲线程，也会创建新线程来执行任务。<li>如果当前线程数等于或大于 <code>corePoolSize</code>，任务会被放入任务队列中等待。<li>如果任务队列已满且当前线程数小于 <code>maximumPoolSize</code>，线程池会创建新线程来执行任务。<li>如果任务队列已满且当前线程数等于 <code>maximumPoolSize</code>，则触发拒绝策略。</ul><li><strong>线程回收</strong>：<ul><li>如果线程数超过 <code>corePoolSize</code>，多余的空闲线程会在空闲一段时间（<code>keepAliveTime</code>）后被回收</ul></ol><h5 id=Executors><a class=headerlink href=#Executors title=Executors></a>Executors</h5><ol><li>创建固定大小的线程池 - <code>newFixedThreadPool</code></ol><p>该方法返回一个固定大小的线程池，适用于需要限制并发线程数的场景。<p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.concurrent.ExecutorService;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.Executors;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>FixedThreadPoolExample</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        <span class=comment>// 创建一个固定大小为3的线程池</span></span><br><span class=line>        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class=number>3</span>);</span><br><span class=line></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < <span class=number>5</span>; i++) {</span><br><span class=line>            <span class=keyword>int</span> taskId = i;</span><br><span class=line>            fixedThreadPool.submit(() -> {</span><br><span class=line>                System.out.println(<span class=string>"Task "</span> + taskId + <span class=string>" is running on thread "</span> + Thread.currentThread().getName());</span><br><span class=line>                <span class=keyword>try</span> {</span><br><span class=line>                    Thread.sleep(<span class=number>2000</span>); <span class=comment>// 模拟任务执行时间</span></span><br><span class=line>                } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>                    Thread.currentThread().interrupt();</span><br><span class=line>                }</span><br><span class=line>            });</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=comment>// 关闭线程池</span></span><br><span class=line>        fixedThreadPool.shutdown();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><ul><li>线程池中的线程数量是固定的。<li>如果所有线程都在忙，新的任务将等待直到有空闲线程可用。</ul><ol><li>创建单线程化的线程池 - <code>newSingleThreadExecutor</code></ol><p>该方法返回一个只有一个工作线程的线程池，适用于需要保证顺序执行任务的场景。<p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.concurrent.ExecutorService;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.Executors;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>SingleThreadExecutorExample</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        <span class=comment>// 创建一个单线程化的线程池</span></span><br><span class=line>        ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class=line></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < <span class=number>5</span>; i++) {</span><br><span class=line>            <span class=keyword>int</span> taskId = i;</span><br><span class=line>            singleThreadExecutor.submit(() -> {</span><br><span class=line>                System.out.println(<span class=string>"Task "</span> + taskId + <span class=string>" is running on thread "</span> + Thread.currentThread().getName());</span><br><span class=line>                <span class=keyword>try</span> {</span><br><span class=line>                    Thread.sleep(<span class=number>2000</span>); <span class=comment>// 模拟任务执行时间</span></span><br><span class=line>                } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>                    Thread.currentThread().interrupt();</span><br><span class=line>                }</span><br><span class=line>            });</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=comment>// 关闭线程池</span></span><br><span class=line>        singleThreadExecutor.shutdown();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><ul><li>所有提交的任务按照提交顺序依次执行。<li>即使发生故障，也会重新创建一个线程来替代原来的线程继续处理后续任务。</ul><ol><li>创建一个会根据需要创建新线程的线程池 - <code>newCachedThreadPool</code></ol><p>该方法返回一个可根据需要创建新线程的线程池，适用于执行大量短期异步任务的场景。<p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.concurrent.ExecutorService;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.Executors;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>CachedThreadPoolExample</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        <span class=comment>// 创建一个缓存线程池</span></span><br><span class=line>        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class=line></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < <span class=number>5</span>; i++) {</span><br><span class=line>            <span class=keyword>final</span> <span class=keyword>int</span> taskId = i;</span><br><span class=line>            cachedThreadPool.submit(() -> {</span><br><span class=line>                System.out.println(<span class=string>"Task "</span> + taskId + <span class=string>" is running on thread "</span> + Thread.currentThread().getName());</span><br><span class=line>                <span class=keyword>try</span> {</span><br><span class=line>                    Thread.sleep(<span class=number>2000</span>); <span class=comment>// 模拟任务执行时间</span></span><br><span class=line>                } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>                    Thread.currentThread().interrupt();</span><br><span class=line>                }</span><br><span class=line>            });</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=comment>// 关闭线程池</span></span><br><span class=line>        cachedThreadPool.shutdown();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><ul><li>线程池可以根据需要创建新线程，并在空闲60秒后回收未使用的线程。<li>适合执行大量短期异步任务的应用程序。</ul><ol><li>创建支持定时及周期性任务执行的线程池 - <code>newScheduledThreadPool</code></ol><p>该方法返回一个支持定时和周期性任务执行的线程池。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.concurrent.Executors;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.TimeUnit;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ScheduledThreadPoolExample</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        <span class=comment>// 创建一个支持定时及周期性任务执行的线程池</span></span><br><span class=line>        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class=number>3</span>);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 定时执行任务，延迟2秒后执行</span></span><br><span class=line>        scheduledThreadPool.schedule(() -> {</span><br><span class=line>            System.out.println(<span class=string>"This task is run after a delay of 2 seconds"</span>);</span><br><span class=line>        }, <span class=number>2</span>, TimeUnit.SECONDS);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 周期性执行任务，初始延迟2秒后开始执行，之后每隔3秒执行一次</span></span><br><span class=line>        scheduledThreadPool.scheduleAtFixedRate(() -> {</span><br><span class=line>            System.out.println(<span class=string>"This task is run periodically every 3 seconds"</span>);</span><br><span class=line>        }, <span class=number>2</span>, <span class=number>3</span>, TimeUnit.SECONDS);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 记得关闭线程池</span></span><br><span class=line>        <span class=comment>// scheduledThreadPool.shutdown(); 在实际应用中，可能需要在适当的时候调用shutdown()来关闭线程池</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><ul><li>支持延迟执行任务或周期性执行任务。<li><code>schedule()</code> 方法用于一次性延迟执行任务。<li><code>scheduleAtFixedRate()</code> 方法用于周期性执行任务。</ul><ol><li>使用自定义线程工厂</ol><p>你可以通过提供自定义的 <code>ThreadFactory</code> 来定制线程的创建过程，比如设置线程名称、优先级等。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.concurrent.*;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>CustomThreadFactoryExample</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        ThreadFactory customThreadFactory = <span class=keyword>new</span> ThreadFactory() {</span><br><span class=line>            <span class=meta>@Override</span></span><br><span class=line>            <span class=function><span class=keyword>public</span> Thread <span class=title>newThread</span><span class=params>(Runnable r)</span> </span>{</span><br><span class=line>                <span class=keyword>return</span> <span class=keyword>new</span> Thread(r, <span class=string>"CustomThread-"</span> + System.currentTimeMillis());</span><br><span class=line>            }</span><br><span class=line>        };</span><br><span class=line></span><br><span class=line>        ExecutorService executorService = Executors.newFixedThreadPool(<span class=number>2</span>, customThreadFactory);</span><br><span class=line></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < <span class=number>5</span>; i++) {</span><br><span class=line>            <span class=keyword>int</span> taskId = i;</span><br><span class=line>            executorService.submit(() -> {</span><br><span class=line>                System.out.println(<span class=string>"Task "</span> + taskId + <span class=string>" is running on thread "</span> + Thread.currentThread().getName());</span><br><span class=line>                <span class=keyword>try</span> {</span><br><span class=line>                    Thread.sleep(<span class=number>2000</span>); <span class=comment>// 模拟任务执行时间</span></span><br><span class=line>                } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>                    Thread.currentThread().interrupt();</span><br><span class=line>                }</span><br><span class=line>            });</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        executorService.shutdown();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>自定义线程工厂允许更灵活地控制线程的创建过程。<p><img alt=image-20250330223813273 data-src=https://s2.loli.net/2025/03/30/Uqb7n83iNwsRuoB.png><p><strong>线程池关闭方法</strong><ol><li><code>shutdown()</code></ol><ul><li><strong>描述</strong>：该方法不会立即强制关闭线程池，而是<strong>首先停止接收新的任务，并尝试完成已经提交的任务</strong>。<li>行为<ul><li>已经提交到线程池中的任务将继续执行直至完成。<li>此方法调用后，如果尝试向线程池提交新任务，则会根据线程池的拒绝策略处理（通常是抛出 <code>RejectedExecutionException</code>）。</ul></ul><p>示例代码<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.concurrent.ExecutorService;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.Executors;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ShutdownExample</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> InterruptedException </span>{</span><br><span class=line>        ExecutorService executor = Executors.newFixedThreadPool(<span class=number>2</span>);</span><br><span class=line></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < <span class=number>5</span>; i++) {</span><br><span class=line>            <span class=keyword>int</span> taskId = i;</span><br><span class=line>            executor.submit(() -> {</span><br><span class=line>                System.out.println(<span class=string>"Task "</span> + taskId + <span class=string>" is running on thread "</span> + Thread.currentThread().getName());</span><br><span class=line>                <span class=keyword>try</span> {</span><br><span class=line>                    Thread.sleep(<span class=number>2000</span>); <span class=comment>// 模拟任务执行时间</span></span><br><span class=line>                } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>                    Thread.currentThread().interrupt();</span><br><span class=line>                }</span><br><span class=line>            });</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        System.out.println(<span class=string>"Shutting down the executor..."</span>);</span><br><span class=line>        executor.shutdown(); <span class=comment>// 发出关闭信号</span></span><br><span class=line></span><br><span class=line>        <span class=comment>// 等待所有任务完成</span></span><br><span class=line>        <span class=keyword>if</span> (!executor.awaitTermination(<span class=number>60</span>, TimeUnit.SECONDS)) {</span><br><span class=line>            System.out.println(<span class=string>"Some tasks are still running"</span>);</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            System.out.println(<span class=string>"All tasks finished."</span>);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><ol><li><code>shutdownNow()</code></ol><ul><li><strong>描述</strong>：尝试<strong>立即停止所有正在执行的任务，并暂停处理等待的任务</strong>。<li>行为<ul><li>它试图终止所有正在执行的任务，并返回一个等待执行的任务列表。<li>并不能保证能够立即停止正在执行的任务，因为任务可能无法响应中断。</ul></ul><p>示例代码<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.List;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.ExecutorService;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.Executors;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ShutdownNowExample</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> InterruptedException </span>{</span><br><span class=line>        ExecutorService executor = Executors.newFixedThreadPool(<span class=number>2</span>);</span><br><span class=line></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < <span class=number>5</span>; i++) {</span><br><span class=line>            <span class=keyword>int</span> taskId = i;</span><br><span class=line>            executor.submit(() -> {</span><br><span class=line>                <span class=keyword>try</span> {</span><br><span class=line>                    System.out.println(<span class=string>"Task "</span> + taskId + <span class=string>" is running on thread "</span> + Thread.currentThread().getName());</span><br><span class=line>                    Thread.sleep(<span class=number>2000</span>); <span class=comment>// 模拟任务执行时间</span></span><br><span class=line>                } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>                    System.out.println(<span class=string>"Task "</span> + taskId + <span class=string>" was interrupted."</span>);</span><br><span class=line>                    Thread.currentThread().interrupt(); <span class=comment>// 重新设置中断状态</span></span><br><span class=line>                }</span><br><span class=line>            });</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        System.out.println(<span class=string>"Attempting to shutdown the executor now..."</span>);</span><br><span class=line>        List&LTRunnable> notExecutedTasks = executor.shutdownNow(); <span class=comment>// 尝试立即关闭</span></span><br><span class=line></span><br><span class=line>        System.out.println(<span class=string>"Number of tasks that will not be executed: "</span> + notExecutedTasks.size());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><ol><li><code>awaitTermination(long timeout, TimeUnit unit)</code></ol><ul><li><strong>描述</strong>：阻塞当前线程直到线程池中的所有任务都已完成执行，或者超时发生，或者当前线程被中断。<li>行为<ul><li>通常与 <code>shutdown()</code> 方法一起使用，以确保所有任务都在程序退出之前完成。<li>返回值为 <code>true</code> 表示所有任务都已经完成；返回 <code>false</code> 则表示由于超时而未完成。</ul></ul><p>可以通过调用 <code>isShutdown()</code> 方法来检查线程池是否已经被标记为关闭。此外，<code>isTerminated()</code> 可用于判断线程池是否已经完全终止（即所有任务都已完成）<h4 id=线程安全集合类><a class=headerlink href=#线程安全集合类 title=线程安全集合类></a>线程安全集合类</h4><p>线程安全的集合类是用于在多线程环境中安全地存储和操作数据的工具。这些集合类通过<strong>内部的同步机制</strong>或<strong>无锁算法（如 CAS）</strong>来保证线程安全。<p><img alt=image-20250330225400344 data-src=https://s2.loli.net/2025/03/30/cBvlUxGDnWa84Yp.png><h5 id=Vector-和-Hashtable><a title="Vector 和 Hashtable" class=headerlink href=#Vector-和-Hashtable></a><code>Vector</code> 和 <code>Hashtable</code></h5><p>这两个类是早期 Java 提供的线程安全集合类，但现在已被更高效的替代品取代。<p><strong><code>Vector</code></strong><ul><li>线程安全的动态数组，类似于 <code>ArrayList</code>，但所有操作都通过 <code>synchronized</code> 加锁。<li>性能较低，推荐使用 <code>CopyOnWriteArrayList</code> 或 <code>Collections.synchronizedList()</code> 替代。</ul><p><strong><code>Hashtable</code></strong><ul><li>线程安全的哈希表，类似于 <code>HashMap</code>，但所有操作都通过 <code>synchronized</code> 加锁。<li>推荐使用 <code>ConcurrentHashMap</code> 替代。</ul><h5 id=同步包装类（Collections-synchronizedXxx-方法）><a title="同步包装类（Collections.synchronizedXxx() 方法）" class=headerlink href=#同步包装类（Collections-synchronizedXxx-方法）></a>同步包装类（<code>Collections.synchronizedXxx()</code> 方法）</h5><p>Java 的 <code>Collections</code> 类提供了一组静态方法，可以将普通的非线程安全集合包装成线程安全的集合。<p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.*;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>SynchronizedCollectionsExample</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        <span class=comment>// 创建一个线程安全的 ArrayList</span></span><br><span class=line>        List&LTString> synchronizedList = Collections.synchronizedList(<span class=keyword>new</span> ArrayList<>());</span><br><span class=line></span><br><span class=line>        <span class=comment>// 创建一个线程安全的 HashMap</span></span><br><span class=line>        Map&LTString, String> synchronizedMap = Collections.synchronizedMap(<span class=keyword>new</span> HashMap<>());</span><br><span class=line></span><br><span class=line>        <span class=comment>// 使用时仍需手动加锁以保证复合操作的线程安全</span></span><br><span class=line>        <span class=keyword>synchronized</span> (synchronizedList) {</span><br><span class=line>            <span class=keyword>if</span> (!synchronizedList.isEmpty()) {</span><br><span class=line>                synchronizedList.remove(<span class=number>0</span>);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>特点<ul><li>内部通过 <code>synchronized</code> 关键字实现同步。<li>简单易用，但性能较差，因为所有操作都需要竞争同一把锁。<li>复合操作（如迭代、条件检查等）需要外部手动加锁。</ul><h5 id=Concurrent-系列集合><a title="Concurrent 系列集合" class=headerlink href=#Concurrent-系列集合></a><code>Concurrent</code> 系列集合</h5><p><code>java.util.concurrent</code> 包中提供了多个高性能的线程安全集合类，它们基于分段锁（Segment Lock）或其他无锁算法（如 CAS），性能优于传统的同步集合。<p><strong>常用类</strong><ul><li><strong><code>ConcurrentHashMap</code></strong>：<ul><li>线程安全的 <code>Map</code> 实现。<li>支持高并发访问，性能优于 <code>Hashtable</code>。<li>内部通过分段锁或 CAS 操作实现线程安全。</ul><li><strong><code>ConcurrentSkipListMap</code></strong>：<ul><li>线程安全的有序 <code>Map</code> 实现。<li>基于跳表（Skip List）实现。</ul><li><strong><code>ConcurrentSkipListSet</code></strong>：<ul><li>线程安全的有序 <code>Set</code> 实现。</ul><li><strong><code>ConcurrentLinkedQueue</code></strong>：<ul><li>线程安全的无界非阻塞队列。<li>基于链表实现，支持高并发。</ul><li><strong><code>ConcurrentLinkedDeque</code></strong>：<ul><li>线程安全的双端队列。</ul></ul><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ConcurrentHashMapExample</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        ConcurrentHashMap&LTString, Integer> map = <span class=keyword>new</span> ConcurrentHashMap<>();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 添加元素</span></span><br><span class=line>        map.put(<span class=string>"A"</span>, <span class=number>1</span>);</span><br><span class=line>        map.put(<span class=string>"B"</span>, <span class=number>2</span>);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 获取元素</span></span><br><span class=line>        System.out.println(map.get(<span class=string>"A"</span>));</span><br><span class=line></span><br><span class=line>        <span class=comment>// 原子操作</span></span><br><span class=line>        map.computeIfAbsent(<span class=string>"C"</span>, key -> <span class=number>3</span>); <span class=comment>// 如果不存在则添加</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>特点<ul><li>高性能，支持高并发。<li>提供了丰富的原子操作（如 <code>computeIfAbsent</code>、<code>merge</code> 等）。<li>适用于高并发场景。</ul><h5 id=阻塞队列（Blocking-Queue）><a title="阻塞队列（Blocking Queue）" class=headerlink href=#阻塞队列（Blocking-Queue）></a>阻塞队列（Blocking Queue）</h5><p>阻塞队列是线程安全的队列，当队列为空或满时，会阻塞线程直到满足条件。<p><strong>常用类</strong><ul><li><strong><code>ArrayBlockingQueue</code></strong>：<ul><li>有界阻塞队列，基于数组实现。<li>需要指定容量。</ul><li><strong><code>LinkedBlockingQueue</code></strong>：<ul><li>无界或有界阻塞队列，基于链表实现。<li>默认情况下是无界的（容量为 <code>Integer.MAX_VALUE</code>）。</ul><li><strong><code>PriorityBlockingQueue</code></strong>：<ul><li>线程安全的优先级队列。<li>元素按优先级排序。</ul><li><strong><code>SynchronousQueue</code></strong>：<ul><li>不存储元素的阻塞队列。<li>每次插入操作必须等待一个对应的移除操作。</ul><li><strong><code>DelayQueue</code></strong>：<ul><li>用于延迟处理元素的阻塞队列。<li>元素只有在延迟时间到期后才能被取出。</ul></ul><p>示例代码<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.BlockingQueue;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>BlockingQueueExample</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> InterruptedException </span>{</span><br><span class=line>        BlockingQueue&LTString> queue = <span class=keyword>new</span> ArrayBlockingQueue<>(<span class=number>2</span>);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 生产者线程</span></span><br><span class=line>        Thread producer = <span class=keyword>new</span> Thread(() -> {</span><br><span class=line>            <span class=keyword>try</span> {</span><br><span class=line>                queue.put(<span class=string>"A"</span>);</span><br><span class=line>                queue.put(<span class=string>"B"</span>);</span><br><span class=line>                queue.put(<span class=string>"C"</span>); <span class=comment>// 队列满时阻塞</span></span><br><span class=line>            } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>                Thread.currentThread().interrupt();</span><br><span class=line>            }</span><br><span class=line>        });</span><br><span class=line></span><br><span class=line>        <span class=comment>// 消费者线程</span></span><br><span class=line>        Thread consumer = <span class=keyword>new</span> Thread(() -> {</span><br><span class=line>            <span class=keyword>try</span> {</span><br><span class=line>                System.out.println(queue.take());</span><br><span class=line>                System.out.println(queue.take());</span><br><span class=line>                System.out.println(queue.take()); <span class=comment>// 队列空时阻塞</span></span><br><span class=line>            } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>                Thread.currentThread().interrupt();</span><br><span class=line>            }</span><br><span class=line>        });</span><br><span class=line></span><br><span class=line>        producer.start();</span><br><span class=line>        consumer.start();</span><br><span class=line></span><br><span class=line>        producer.join();</span><br><span class=line>        consumer.join();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>特点</strong><ul><li>适用于生产者-消费者模型。<li>提供了阻塞操作（如 <code>put</code> 和 <code>take</code>）。<li>可以控制队列的容量。</ul><h5 id=CopyOnWrite-系列集合><a title="CopyOnWrite 系列集合" class=headerlink href=#CopyOnWrite-系列集合></a><code>CopyOnWrite</code> 系列集合</h5><p><code>CopyOnWrite</code> 系列集合适用于读多写少的场景，其核心思想是：每次修改时复制一份新的数据副本，从而避免读写冲突。<p><strong>常用类</strong><ul><li><strong><code>CopyOnWriteArrayList</code></strong>：<ul><li>线程安全的 <code>List</code> 实现。<li>适用于读操作远多于写操作的场景。</ul><li><strong><code>CopyOnWriteArraySet</code></strong>：<ul><li>基于 <code>CopyOnWriteArrayList</code> 实现的线程安全 <code>Set</code>。</ul></ul><p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.List;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>CopyOnWriteArrayListExample</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        List&LTString> list = <span class=keyword>new</span> CopyOnWriteArrayList<>();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 添加元素</span></span><br><span class=line>        list.add(<span class=string>"A"</span>);</span><br><span class=line>        list.add(<span class=string>"B"</span>);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 遍历（无需额外加锁）</span></span><br><span class=line>        <span class=keyword>for</span> (String item : list) {</span><br><span class=line>            System.out.println(item);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>特点<ul><li>修改操作（如 <code>add</code>、<code>remove</code>）会创建数据副本，因此写操作成本较高。<li>读操作不需要加锁，性能高。<li>不适合频繁写入的场景。</ul><div class=table-container><table><thead><tr><th>集合类型<th>场景<th>特点<tbody><tr><td><code>Collections.synchronizedXxx()</code><td>简单线程安全需求<td>所有操作加锁，性能较低<tr><td><code>Vector</code> / <code>Hashtable</code><td>兼容旧代码<td>过时，不推荐<tr><td><code>CopyOnWriteArrayList</code><td>读多写少<td>写操作成本高，读操作无需加锁<tr><td><code>ConcurrentHashMap</code><td>高并发场景<td>高性能，支持原子操作<tr><td>阻塞队列（如 <code>ArrayBlockingQueue</code>）<td>生产者-消费者模型<td>提供阻塞操作，支持容量控制</table></div><h3 id=FAQ><a class=headerlink href=#FAQ title=FAQ></a>FAQ</h3><h4 id=HashMap并发死链问题><a class=headerlink href=#HashMap并发死链问题 title=HashMap并发死链问题></a>HashMap并发死链问题</h4><p><code>HashMap</code> 的底层实现是一个数组（桶）和链表/红黑树的结合。当发生哈希冲突时，多个键值对会被存储在同一个桶中，形成链表或红黑树。在多线程环境下，如果多个线程同时对 <code>HashMap</code> 进行写操作（如扩容或插入），可能会破坏链表的结构，导致链表形成环状结构（即死链）。<p><strong>具体原因：</strong><ul><li>扩容时的并发问题<ul><li>当 <code>HashMap</code> 的容量不足时，会触发扩容操作（<code>resize()</code> 方法），将旧数组中的元素重新分配到新数组中。<li>在多线程环境下，多个线程可能同时执行扩容操作，导致链表节点被错误地连接，形成环形链表。</ul><li>链表插入时的并发问题<ul><li>多个线程同时插入元素时，可能会导致链表节点的指针被错误地修改，从而形成环形链表。</ul></ul><p>一旦链表形成了环形结构，后续的读操作（如 <code>get()</code>）会在遍历链表时陷入无限循环。<p>为了避免 <code>HashMap</code> 的并发死链问题，可以采取以下几种解决方案：<p><strong>(1) 使用线程安全的集合类</strong><ul><li>使用ConcurrentHashMap替代HashMap<ul><li><code>ConcurrentHashMap</code> 是专门为多线程环境设计的线程安全集合类。<li>它通过分段锁（Segment Lock）或 CAS 操作来保证线程安全，避免了死链问题。</ul></ul><p><strong>(2) 手动加锁</strong><ul><li>如果必须使用 <code>HashMap</code>，可以通过 <code>synchronized</code> 或显式锁（如 <code>ReentrantLock</code>）来保护对其的修改操作。</ul><p><strong>(3) 使用 <code>Collections.synchronizedMap()</code> 包装</strong><ul><li>将 <code>HashMap</code> 包装成线程安全的集合。</ul><h1 id=项目管理><a class=headerlink href=#项目管理 title=项目管理></a>项目管理</h1><h2 id=Maven✨><a class=headerlink href=#Maven✨ title=Maven✨></a>Maven✨</h2><p><a href=https://maven.apache.org/guides/getting-started/index.html rel=noopener target=_blank>Maven Getting Started Guide – Maven</a><p><a href=https://www.runoob.com/maven/maven-tutorial.html rel=noopener target=_blank>Maven 教程 | 菜鸟教程</a><p><a href=https://www.bilibili.com/video/BV1Ah411S7ZE/?spm_id_from=333.337.search-card.all.click&vd_source=177ef88aa6608bc3652c72d71b0aa098 rel=noopener target=_blank>黑马程序员Maven全套教程，maven项目管理从基础到高级，Java项目开发必会管理工具maven_哔哩哔哩_bilibili</a><blockquote><p>项目中源码目录,资源文件夹目录等都是maven设置的</blockquote><p>Maven 提倡使用一个共同的标准目录结构，Maven 使用约定优于配置的原则，大家尽可能的遵守这样的目录结构。如下所示：<div class=table-container><table><thead><tr><th style=text-align:left>目录<th style=text-align:left>目的<tbody><tr><td style=text-align:left>${basedir}<td style=text-align:left>存放pom.xml和所有的子目录<tr><td style=text-align:left>${basedir}/src/main/java<td style=text-align:left>项目的java源代码<tr><td style=text-align:left>${basedir}/src/main/resources<td style=text-align:left>项目的资源，比如说property文件，springmvc.xml<tr><td style=text-align:left>${basedir}/src/test/java<td style=text-align:left>项目的测试类，比如说Junit代码<tr><td style=text-align:left>${basedir}/src/test/resources<td style=text-align:left>测试用的资源<tr><td style=text-align:left>${basedir}/src/main/webapp/WEB-INF<td style=text-align:left>web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面<tr><td style=text-align:left>${basedir}/target<td style=text-align:left>打包输出目录<tr><td style=text-align:left>${basedir}/target/classes<td style=text-align:left>编译输出目录<tr><td style=text-align:left>${basedir}/target/test-classes<td style=text-align:left>测试编译输出目录<tr><td style=text-align:left>Test.java<td style=text-align:left>Maven只会自动运行符合该命名规则的测试类<tr><td style=text-align:left>~/.m2/repository<td style=text-align:left>Maven默认的本地仓库目录位置</table></div><p>POM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。<p>执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。<p>POM 中可以指定以下配置：<ul><li>项目依赖<li>插件<li>执行目标<li>项目构建 profile<li>项目版本<li>项目开发者列表<li>相关邮件列表信息</ul><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>project</span> <span class=attr>xmlns</span> = <span class=string>"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span> = <span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span> = <span class=string>"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class=line><span class=string><span class=tag>    http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>></span></span><br><span class=line> </span><br><span class=line>    <span class=comment>&LT!-- 模型版本 --></span></span><br><span class=line>    <span class=tag><<span class=name>modelVersion</span>></span>4.0.0<span class=tag>&LT/<span class=name>modelVersion</span>></span></span><br><span class=line>    <span class=comment>&LT!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>com.companyname.project-group<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line> </span><br><span class=line>    <span class=comment>&LT!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>project<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line> </span><br><span class=line>    <span class=comment>&LT!-- 版本号 --></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>1.0<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>project</span>></span></span><br></pre></table></figure><p>所有 POM 文件都需要 project 元素和三个必需字段：groupId，artifactId，version。<div class=table-container><table><thead><tr><th style=text-align:left>节点<th style=text-align:left>描述<tbody><tr><td style=text-align:left>project<td style=text-align:left>工程的根标签。<tr><td style=text-align:left>modelVersion<td style=text-align:left>模型版本需要设置为 4.0。<tr><td style=text-align:left>groupId<td style=text-align:left>这是工程组的标识。它在一个组织或者项目中通常是唯一的。例如，一个银行组织 com.companyname.project-group 拥有所有的和银行相关的项目。<tr><td style=text-align:left>artifactId<td style=text-align:left>这是工程的标识。它通常是工程的名称。例如，消费者银行。groupId 和 artifactId 一起定义了 artifact 在仓库中的位置。<tr><td style=text-align:left>version<td style=text-align:left>这是工程的版本号。在 artifact 的仓库中，它用来区分不同的版本。例如：<code>com.company.bank:consumer-banking:1.0 com.company.bank:consumer-banking:1.1</code></table></div><h3 id=依赖管理><a class=headerlink href=#依赖管理 title=依赖管理></a>依赖管理</h3><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>    <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>        <span class=tag><<span class=name>groupId</span>></span>org.springframework<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>artifactId</span>></span>spring-core<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>version</span>></span>5.3.9<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencies</span>></span></span><br></pre></table></figure><h3 id=插件管理><a class=headerlink href=#插件管理 title=插件管理></a>插件管理</h3><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>build</span>></span></span><br><span class=line>    <span class=tag><<span class=name>plugins</span>></span></span><br><span class=line>        <span class=tag><<span class=name>plugin</span>></span></span><br><span class=line>            <span class=tag><<span class=name>groupId</span>></span>org.apache.maven.plugins<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>            <span class=tag><<span class=name>artifactId</span>></span>maven-compiler-plugin<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>            <span class=tag><<span class=name>version</span>></span>3.8.1<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>            <span class=tag><<span class=name>configuration</span>></span></span><br><span class=line>                <span class=tag><<span class=name>source</span>></span>1.8<span class=tag>&LT/<span class=name>source</span>></span></span><br><span class=line>                <span class=tag><<span class=name>target</span>></span>1.8<span class=tag>&LT/<span class=name>target</span>></span></span><br><span class=line>            <span class=tag>&LT/<span class=name>configuration</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>plugin</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>plugins</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>build</span>></span></span><br></pre></table></figure><h3 id=其他常用元素><a class=headerlink href=#其他常用元素 title=其他常用元素></a>其他常用元素</h3><p><strong>properties</strong>: 定义项目中的一些属性变量:<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>properties</span>></span></span><br><span class=line>    <span class=tag><<span class=name>maven.compiler.source</span>></span>1.8<span class=tag>&LT/<span class=name>maven.compiler.source</span>></span></span><br><span class=line>    <span class=tag><<span class=name>maven.compiler.target</span>></span>1.8<span class=tag>&LT/<span class=name>maven.compiler.target</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>properties</span>></span></span><br></pre></table></figure><p>repositories: 定义项目的依赖库:<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>repositories</span>></span></span><br><span class=line>    <span class=tag><<span class=name>repository</span>></span></span><br><span class=line>        <span class=tag><<span class=name>id</span>></span>central<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>        <span class=tag><<span class=name>url</span>></span>https://repo.maven.apache.org/maven2<span class=tag>&LT/<span class=name>url</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>repository</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>repositories</span>></span></span><br></pre></table></figure><p><strong>dependencyManagement</strong>: 用于管理依赖的版本，特别是在多模块项目中：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependencyManagement</span>></span></span><br><span class=line>    <span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>        <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>            <span class=tag><<span class=name>groupId</span>></span>org.springframework<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>            <span class=tag><<span class=name>artifactId</span>></span>spring-core<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>            <span class=tag><<span class=name>version</span>></span>5.3.9<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>dependencies</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencyManagement</span>></span></span><br></pre></table></figure><p>profiles: 用于定义不同的构建配置，可以根据不同的环境进行构建：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>profiles</span>></span></span><br><span class=line>    <span class=tag><<span class=name>profile</span>></span></span><br><span class=line>        <span class=tag><<span class=name>id</span>></span>development<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>        <span class=tag><<span class=name>properties</span>></span></span><br><span class=line>            <span class=tag><<span class=name>environment</span>></span>dev<span class=tag>&LT/<span class=name>environment</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>properties</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>profile</span>></span></span><br><span class=line>    <span class=tag><<span class=name>profile</span>></span></span><br><span class=line>        <span class=tag><<span class=name>id</span>></span>production<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>        <span class=tag><<span class=name>properties</span>></span></span><br><span class=line>            <span class=tag><<span class=name>environment</span>></span>prod<span class=tag>&LT/<span class=name>environment</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>properties</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>profile</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>profiles</span>></span></span><br></pre></table></figure><p>继承: 通过parent元素，一个POM文件可以继承另一个POM文件的配置：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>parent</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>com.example<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>parent-project<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>1.0-SNAPSHOT<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>parent</span>></span></span><br></pre></table></figure><p>聚合: 通过modules元素，一个POM文件可以管理多个子模块：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>modules</span>></span></span><br><span class=line>    <span class=tag><<span class=name>module</span>></span>module1<span class=tag>&LT/<span class=name>module</span>></span></span><br><span class=line>    <span class=tag><<span class=name>module</span>></span>module2<span class=tag>&LT/<span class=name>module</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>modules</span>></span></span><br></pre></table></figure><h3 id=生命周期><a class=headerlink href=#生命周期 title=生命周期></a>生命周期</h3><p>个典型的 Maven 构建（build）生命周期是由以下几个阶段的序列组成的：<p><img alt=img data-src=https://www.runoob.com/wp-content/uploads/2018/09/maven-package-build-phase.png><div class=table-container><table><thead><tr><th style=text-align:left>阶段<th style=text-align:left>处理<th style=text-align:left>描述<tbody><tr><td style=text-align:left>验证 validate<td style=text-align:left>验证项目<td style=text-align:left>验证项目是否正确且所有必须信息是可用的<tr><td style=text-align:left>编译 compile<td style=text-align:left>执行编译<td style=text-align:left>源代码编译在此阶段完成<tr><td style=text-align:left>测试 Test<td style=text-align:left>测试<td style=text-align:left>使用适当的单元测试框架（例如JUnit）运行测试。<tr><td style=text-align:left>包装 package<td style=text-align:left>打包<td style=text-align:left>将编译后的代码打包成可分发的格式，例如 JAR 或 WAR<tr><td style=text-align:left>检查 verify<td style=text-align:left>检查<td style=text-align:left>对集成测试的结果进行检查，以保证质量达标<tr><td style=text-align:left>安装 install<td style=text-align:left>安装<td style=text-align:left>安装打包的项目到本地仓库，以供其他项目使用<tr><td style=text-align:left>部署 deploy<td style=text-align:left>部署<td style=text-align:left>拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程</table></div><p>为了完成 default 生命周期，这些阶段（包括其他未在上面罗列的生命周期阶段）将被按顺序地执行。<p>Maven 有以下三个标准的生命周期：<p><strong>1、Clean 生命周期：</strong><ul><li><strong>clean</strong>：删除目标目录中的编译输出文件。这通常是在构建之前执行的，以确保项目从一个干净的状态开始。</ul><p><strong>2、Default 生命周期（也称为 Build 生命周期）：</strong><ul><li><strong>validate</strong>：验证项目的正确性，例如检查项目的版本是否正确。<li><strong>compile</strong>：编译项目的源代码。<li><strong>test</strong>：运行项目的单元测试。<li><strong>package</strong>：将编译后的代码打包成可分发的格式，例如 JAR 或 WAR。<li><strong>verify</strong>：对项目进行额外的检查以确保质量。<li><strong>install</strong>：将项目的构建结果安装到本地 Maven 仓库中，以供其他项目使用。<li><strong>deploy</strong>：将项目的构建结果复制到远程仓库，以供其他开发人员或团队使用。</ul><p><strong>3、Site 生命周期：</strong><ul><li><strong>site</strong>：生成项目文档和站点信息。<li><strong>deploy-site</strong>：将生成的站点信息发布到远程服务器，以便共享项目文档。</ul><h3 id=仓库><a class=headerlink href=#仓库 title=仓库></a>仓库</h3><p>在 Maven 的术语中，仓库是一个位置（place）。<p>Maven 仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。<p>在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称之为构件。<p>Maven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。<p>Maven 仓库有三种类型：<ul><li>本地（local）<li>中央（central）<li>远程（remote）</ul><p>Maven 的本地仓库，<strong>在安装 Maven 后并不会创建，它是在第一次执行 maven 命令的时候才被创建</strong>。<p>运行 Maven 的时候，Maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。<blockquote><p>默认情况下，不管Linux还是 Windows，每个用户在自己的用户目录下都有一个路径名为 .m2/repository/ 的仓库目录。</blockquote><p>Maven 本地仓库默认被创建在 %USER_HOME% 目录下。要修改默认位置，在 %M2_HOME%\conf 目录中的 Maven 的 settings.xml 文件中定义另一个路径。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>settings</span> <span class=attr>xmlns</span>=<span class=string>"http://maven.apache.org/SETTINGS/1.0.0"</span>   <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span>   <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://maven.apache.org/SETTINGS/1.0.0    http://maven.apache.org/xsd/settings-1.0.0.xsd"</span>></span>      <span class=tag><<span class=name>localRepository</span>></span>C:/MyLocalRepository<span class=tag>&LT/<span class=name>localRepository</span>></span> <span class=tag>&LT/<span class=name>settings</span>></span></span><br></pre></table></figure><p>当运行 Maven 命令，Maven 将下载依赖的文件到你指定的路径中。<p>Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。<p>中央仓库包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。<p>中央仓库的关键概念：<ul><li>这个仓库由 Maven 社区管理。<li>不需要配置。<li>需要通过网络才能访问。</ul><p>如果 Maven 在中央仓库中也找不到依赖的文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。<p>举例说明，使用下面的 pom.xml，<strong>Maven 将从远程仓库中下载该 pom.xml 中声明的所依赖的（在中央仓库中获取不到的）文件</strong>。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>project</span> <span class=attr>xmlns</span>=<span class=string>"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class=line><span class=tag>   <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>   <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class=line><span class=string><span class=tag>   http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>></span></span><br><span class=line>   <span class=tag><<span class=name>modelVersion</span>></span>4.0.0<span class=tag>&LT/<span class=name>modelVersion</span>></span></span><br><span class=line>   <span class=tag><<span class=name>groupId</span>></span>com.companyname.projectgroup<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>   <span class=tag><<span class=name>artifactId</span>></span>project<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>   <span class=tag><<span class=name>version</span>></span>1.0<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>   <span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>      <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>         <span class=tag><<span class=name>groupId</span>></span>com.companyname.common-lib<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>         <span class=tag><<span class=name>artifactId</span>></span>common-lib<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>         <span class=tag><<span class=name>version</span>></span>1.0.0<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>      <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>   <span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>   <span class=tag><<span class=name>repositories</span>></span></span><br><span class=line>      <span class=tag><<span class=name>repository</span>></span></span><br><span class=line>          <span class=comment>&LT!--自定义远程仓库--></span></span><br><span class=line>         <span class=tag><<span class=name>id</span>></span>companyname.lib1<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>      <span class=tag><<span class=name>url</span>></span>http://download.companyname.org/maven2/lib1<span class=tag>&LT/<span class=name>url</span>></span></span><br><span class=line>      <span class=tag>&LT/<span class=name>repository</span>></span></span><br><span class=line>      <span class=tag><<span class=name>repository</span>></span></span><br><span class=line>         <span class=tag><<span class=name>id</span>></span>companyname.lib2<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>         <span class=tag><<span class=name>url</span>></span>http://download.companyname.org/maven2/lib2<span class=tag>&LT/<span class=name>url</span>></span></span><br><span class=line>      <span class=tag>&LT/<span class=name>repository</span>></span></span><br><span class=line>   <span class=tag>&LT/<span class=name>repositories</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>project</span>></span></span><br></pre></table></figure><p>当执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库：<ul><li><strong>步骤 1</strong> － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。<li><strong>步骤 2</strong> － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。<li><strong>步骤 3</strong> － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。<li><strong>步骤 4</strong> － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</ul><p>Maven 仓库默认在国外， 国内使用难免很慢，我们可以更换为阿里云的仓库。<p><strong>修改 maven 根目录下的 conf 文件夹中的 settings.xml 文件</strong>，在 mirrors 节点上，添加内容如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>mirror</span>></span></span><br><span class=line>  <span class=tag><<span class=name>id</span>></span>aliyunmaven<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>  <span class=tag><<span class=name>mirrorOf</span>></span>*<span class=tag>&LT/<span class=name>mirrorOf</span>></span></span><br><span class=line>  <span class=tag><<span class=name>name</span>></span>阿里云公共仓库<span class=tag>&LT/<span class=name>name</span>></span></span><br><span class=line>  <span class=tag><<span class=name>url</span>></span>https://maven.aliyun.com/repository/public<span class=tag>&LT/<span class=name>url</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>mirror</span>></span></span><br></pre></table></figure><p>如果想使用其它代理仓库，可在 <strong><repositories></repositories></strong> 节点中加入对应的仓库使用地址。以使用 spring 代理仓为例：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>repository</span>></span></span><br><span class=line>  <span class=tag><<span class=name>id</span>></span>spring<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>  <span class=tag><<span class=name>url</span>></span>https://maven.aliyun.com/repository/spring<span class=tag>&LT/<span class=name>url</span>></span></span><br><span class=line>  <span class=tag><<span class=name>releases</span>></span></span><br><span class=line>    <span class=tag><<span class=name>enabled</span>></span>true<span class=tag>&LT/<span class=name>enabled</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>releases</span>></span></span><br><span class=line>  <span class=tag><<span class=name>snapshots</span>></span></span><br><span class=line>    <span class=tag><<span class=name>enabled</span>></span>true<span class=tag>&LT/<span class=name>enabled</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>snapshots</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>repository</span>></span></span><br></pre></table></figure><p>在你的 pom.xml 文件 <strong><denpendencies></denpendencies></strong> 节点中加入你要引用的文件信息：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>  <span class=tag><<span class=name>groupId</span>></span>[GROUP_ID]<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>  <span class=tag><<span class=name>artifactId</span>></span>[ARTIFACT_ID]<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>  <span class=tag><<span class=name>version</span>></span>[VERSION]<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><h3 id=常用命令><a class=headerlink href=#常用命令 title=常用命令></a>常用命令</h3><ol><li><strong><code>mvn clean</code></strong><ul><li>清理项目，删除 <code>target</code> 目录（该目录包含了编译和打包过程中生成的所有文件）。</ul><li><strong><code>mvn compile</code></strong><ul><li>编译项目的源代码。默认情况下，会查找 <code>src/main/java</code> 目录下的所有 <code>.java</code> 文件，并将编译后的 <code>.class</code> 文件输出到 <code>target/classes</code> 目录中。</ul><li><strong><code>mvn test</code></strong><ul><li>使用合适的单元测试框架（如 JUnit 或 TestNG）运行项目的测试代码。默认情况下，测试代码位于 <code>src/test/java</code> 目录下。</ul><li><strong><code>mvn package</code></strong><ul><li>将编译好的字节码打包成可分发的格式，例如 JAR 或 WAR 文件。这个命令首先执行 <code>compile</code> 和 <code>test</code>，然后将项目打包并存放在 <code>target</code> 目录中。</ul><li><strong><code>mvn install</code></strong><ul><li>安装打包好的构件到本地仓库（通常是用户主目录下的 <code>.m2/repository</code>），以便它可以被其他项目作为依赖使用。此命令还会执行 <code>package</code> 的所有步骤。</ul><li><strong><code>mvn deploy</code></strong><ul><li>在集成或发布阶段使用，用于将最终包复制到远程仓库，使得其他开发者或项目可以共享这个构件。</ul><li><strong><code>mvn site</code></strong><ul><li>生成关于项目的站点文档，包括测试覆盖率报告、依赖列表等信息。</ul><li><strong><code>mvn clean install</code></strong><ul><li>组合命令，先清理项目 (<code>clean</code>) 然后安装 (<code>install</code>) 到本地仓库。这是非常常见的组合，用于确保在干净环境下重新构建整个项目。</ul><li><strong><code>mvn dependency:tree</code></strong><ul><li>显示项目依赖树，有助于分析依赖冲突或了解项目依赖关系。</ul><li><strong><code>mvn archetype:generate</code></strong><ul><li>生成一个新的 Maven 项目结构，通过交互式的方式选择项目模板</ul></ol><h1 id=数据库><a class=headerlink href=#数据库 title=数据库></a>数据库</h1><h2 id=MySQL✨><a class=headerlink href=#MySQL✨ title=MySQL✨></a>MySQL✨</h2><h4 id=事务><a class=headerlink href=#事务 title=事务></a>事务</h4><p>一组操作的集合,不可分割的一个工作单位. 事务会把所有操作作为一个整体向系统提交或撤销操作,即这些操作要么同时成功,要么同时失败.<p>事务四大特性<ul><li><strong>原子性（Atomicity）</strong>：事务中的所有操作要么全部完成，要么全部不执行。<li><strong>一致性（Consistency）</strong>：事务应该将数据库从一种一致状态转换为另一种一致状态。<li><strong>隔离性（Isolation）</strong>：并发事务之间相互隔离，不会互相干扰。<li><strong>持久性（Durability）</strong>：一旦事务提交，所做的更改将是永久性的，即使系统发生故障也不会丢失。</ul><p><img alt=image-20250329225640854 data-src=https://s2.loli.net/2025/03/29/qaAURO3uTdrxlEY.png><h5 id=事务并发问题><a class=headerlink href=#事务并发问题 title=事务并发问题></a>事务并发问题</h5><p>多个事务并发进行的问题<h6 id=脏读><a class=headerlink href=#脏读 title=脏读></a>脏读</h6><p>一个事务读到另外一个事务还没有提交的数据<h6 id=不可重复读><a class=headerlink href=#不可重复读 title=不可重复读></a>不可重复读</h6><p>一个事务先后读取同一条记录,但两次读取的数据不同,称之为不可重复读<h6 id=幻读><a class=headerlink href=#幻读 title=幻读></a>幻读</h6><p>一个事务按照条件查询数据时,没有对应的数据行,但是在插入数据时,又发现这行数据已经存在<h5 id=事务隔离级别><a class=headerlink href=#事务隔离级别 title=事务隔离级别></a>事务隔离级别</h5><p>MySQL 支持四种标准的事务隔离级别：<ol><li><strong>读未提交（Read Uncommitted）</strong>:最低级别的隔离，允许脏读、不可重复读和幻读。<li><strong>读已提交（Read Committed）</strong>:防止脏读，但允许不可重复读和幻读。<li><strong>可重复读（Repeatable Read）</strong>:默认级别，防止脏读和不可重复读，但允许幻读。<li><strong>串行化（Serializable）</strong>:最高级别的隔离，完全防止脏读、不可重复读和幻读，但会降低并发性能。</ol><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class=line>-- 或者</span><br><span class=line>SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br></pre></table></figure><p><strong>1. 默认情况下：事务需要显式提交</strong><ul><li>在 <code>START TRANSACTION</code> 开始一个事务后，所有对数据库的修改操作（如 <code>UPDATE</code>、<code>INSERT</code> 等）都只会暂时存在于事务的上下文中，而不会直接写入数据库。<li>这些更改对其他事务是不可见的（根据隔离级别），直到你显式调用 <code>COMMIT</code> 提交事务。<li>如果你调用 <code>ROLLBACK</code>，则所有的更改会被撤销，数据库恢复到事务开始前的状态。</ul><p><strong>2. 如果未提交且会话结束</strong><ul><li><p>如果你在事务中执行了更新语句，但没有显式调用COMMITROLLBACK</p> <p>，然后会话意外终止（例如客户端断开连接），MySQL 的行为如下：</p> <ul><li><strong>InnoDB 存储引擎</strong>（支持事务）：事务会被自动回滚，所有未提交的更改都会被撤销。<li><strong>MyISAM 存储引擎</strong>（不支持事务）：由于 MyISAM 不支持事务，所有操作会立即生效，无法回滚。</ul></ul><p><strong>3. autocommit 模式的影响</strong><ul><li>MySQL 默认开启了 <strong>autocommit 模式</strong>（<code>autocommit=1</code>）。在这种模式下，每条单独的 SQL 语句都会被视为一个独立的事务，并在执行后自动提交。<li>当你使用 <code>START TRANSACTION</code> 或 <code>BEGIN</code> 时，会临时禁用 autocommit 模式，直到事务结束（通过 <code>COMMIT</code> 或 <code>ROLLBACK</code>）。<li>如果你没有显式提交事务，而会话结束时 autocommit 模式重新启用，InnoDB 会自动回滚未提交的事务。</ul><p><img alt=image-20250326191732721 data-src=https://s2.loli.net/2025/03/26/F7Ebo35RH6XIQft.png><h4 id=存储引擎><a class=headerlink href=#存储引擎 title=存储引擎></a>存储引擎</h4><p><img alt=image-20250326192221989 data-src=https://s2.loli.net/2025/03/26/LjCFSxblAyBGEhd.png><p><strong>1. InnoDB</strong><ul><li><p><strong>默认存储引擎</strong>：从 MySQL 5.5 开始成为默认存储引擎。</p><li><p>特性</p> <ul><li><strong>事务支持</strong>：完全支持 ACID（原子性、一致性、隔离性、持久性）属性，适合需要高可靠性和数据一致性的应用。<li><strong>行级锁定</strong>：提供高效的并发处理能力，减少了锁冲突的可能性。</ul> <blockquote><p>行级锁定是指在对数据进行操作时，只锁定受影响的具体行而不是整个表。这意味着在同一张表中，不同事务可以同时对不同的行进行读写操作。</blockquote> <ul><li><strong>外键支持</strong>：唯一支持外键约束的存储引擎，有助于维护数据完整性和引用完整性。<li><strong>崩溃恢复</strong>：通过 redo 和 undo 日志实现快速崩溃恢复。<li><strong>聚簇索引</strong>：每个表都使用主键作为聚簇索引，提高了查询效率。</ul></ul><p><strong>2. MyISAM</strong><ul><li><strong>早期默认存储引擎</strong>：在 MySQL 5.5 之前是默认的存储引擎。<li>特性<ul><li><strong>不支持事务</strong>：适用于对事务要求不高、以读操作为主的场景。<li><strong>表级锁定</strong>：整个表被锁定进行写入操作，可能导致高并发下的性能瓶颈。<li><strong>全文索引</strong>：MyISAM 支持全文搜索，这在某些文本检索应用中非常有用。<li><strong>压缩表</strong>：可以创建只读压缩表，节省存储空间。<li><strong>简单高效</strong>：对于简单的查询操作，MyISAM 提供了较高的性能。</ul></ul><p><strong>3. Memory (Heap)</strong><ul><li><strong>内存中的表</strong>：数据存放在内存中，因此访问速度非常快。<li>特性<ul><li><strong>临时性</strong>：重启服务器后数据丢失，适用于缓存数据或临时计算。<li><strong>表级锁定</strong>：由于是内存操作，锁定粒度较粗并不会显著影响性能。<li><strong>哈希索引</strong>：默认使用哈希索引，对于精确匹配查询特别有效。<li><strong>不支持事务</strong>：与 MyISAM 类似，Memory 引擎也不支持事务。</ul></ul><p><img alt=image-20250329230207046 data-src=https://s2.loli.net/2025/03/29/TolUSndakcOP3ti.png><p><img alt=image-20250329230247585 data-src=https://s2.loli.net/2025/03/29/zI1SvEeYGsfFkpy.png><h4 id=索引><a class=headerlink href=#索引 title=索引></a>索引</h4><p><img alt=image-20250329230936523 data-src=https://s2.loli.net/2025/03/29/TmRpyswKoazBdO3.png><ul><li><strong>定义</strong>：索引是一种特殊的数据结构，用于加速数据库表中数据的检索速度。<li><strong>目的</strong>：减少查询时需要扫描的数据量，从而提高查询性能。<li><p><strong>代价</strong>：虽然索引可以加快查询速度，但它们也会占用额外的存储空间，并且在进行插入、更新和删除操作时会增加一些开销。</p> <p><strong>B-Tree 索引</strong></p><li><p><strong>适用范围</strong>：这是 MySQL 中最常用的索引类型，默认情况下，<code>CREATE INDEX</code> 创建的就是 B-Tree 索引。</p><li><p>特点</p> <ul><li>支持全键值、键值范围和键前缀查找（如 <code>LIKE 'abc%'</code>）。<li>能够有效地支持等值查询和范围查询（例如 <code>></code>、<code><</code>、<code>BETWEEN</code>、<code>IN</code> 等）。<li>适用于大多数类型的比较操作（包括 <code>=</code>、<code><></code>、<code>></code>、<code>>=</code>、<code><</code>、<code><=</code>）。</ul></ul><p><strong>(1) 阶数（Order）</strong><ul><li>B 树的阶数 t是一个定义其结构的重要参数。每个节点最多可以有 2t−1个键值，并且至少包含 t−1个键值（除了根节点外）。每个内部节点最多有 2t个子节点。<li><p>这种设计确保了树的高度保持较低，从而减少了查找所需的时间。<strong>(2) 节点类型</strong></p><li><p><strong>内部节点</strong>：除了叶子节点之外的所有节点。它们存储键值和指向子节点的指针。</p><li><strong>叶子节点</strong>：位于树的最底层，直接存储数据或指向数据的指针。</ul><p><strong>2. B+ 树（B+Tree）</strong><p><strong>定义</strong><ul><li>B+ 树是 B 树的一种变体，特别优化了范围查询性能。与 B 树不同的是，B+ 树的所有数据都存储在叶子节点中，而内部节点仅用于导航目的。</ul><p><strong>特点</strong><ul><li><strong>所有数据都在叶子节点</strong>：这意味着所有的实际数据记录都存储在叶子节点上，而不是分散在整棵树中。这样做的好处是可以将更多的键值放入内部节点，从而进一步降低树的高度。<li><strong>叶子节点链表</strong>：B+ 树的叶子节点通过双向链表连接在一起，这极大地提高了范围查询的效率，因为一旦定位到起始位置，就可以沿着链表顺序访问后续的数据。<li><strong>更高的分支因子</strong>：由于内部节点不存储数据，因此可以容纳更多的子节点指针，这有助于进一步减少树的高度，提高查找效率。</ul><p><strong>3. B 树 vs. B+ 树</strong><div class=table-container><table><thead><tr><th>特性<th>B 树<th>B+ 树<tbody><tr><td><strong>数据存储位置</strong><td>内部节点和叶子节点都可以存储数据<td><strong>仅叶子节点存储数据</strong>，内部节点仅用于导航<tr><td><strong>叶子节点连接</strong><td>不具备叶子节点间的直接连接<td><strong>叶子节点之间通过链表相连</strong>，便于范围查询<tr><td><strong>树的高度</strong><td>较高，因为内部节点也需要存储数据<td>更低，因为<strong>内部节点可以存储更多键值</strong>，减少了树的高度<tr><td><strong>适用场景</strong><td>适合于大多数基本查询操作<td>特别<strong>适合于范围查询</strong>和排序操作</table></div><p><img alt=image-20250329231556772 data-src=https://s2.loli.net/2025/03/29/dIRX1Fx5kQ2gPra.png><div class=table-container><table><thead><tr><th><strong>特性</strong><th><strong>B树</strong><th><strong>B+树</strong><tbody><tr><td><strong>数据存储</strong><td><strong>数据（key-value）存储在所有节点（叶子+内部）</strong><td><strong>数据仅存储在叶子节点</strong>，内部节点只存 key<tr><td><strong>指针</strong><td><strong>内部节点的指针指向子节点</strong><td><strong>叶子节点间有额外的顺序指针（双向链表）</strong><tr><td><strong>搜索</strong><td><strong>可以在非叶子节点找到数据</strong>，搜索可能提前结束<td><strong>必须走到叶子节点才能找到数据</strong>，查询路径固定<tr><td><strong>范围查询</strong><td><strong>范围查询效率较低</strong>，需回溯<td><strong>范围查询效率高</strong>（叶子节点是链表，顺序扫描快）<tr><td><strong>磁盘I/O</strong><td><strong>较多随机I/O</strong><td><strong>较少随机I/O，访问更快</strong><tr><td><strong>树的高度</strong><td><strong>相对较高</strong><td><strong>相对较低</strong>（因为内部节点更小，能容纳更多 key）</table></div><p><img alt=image-20250330000450278 data-src=https://s2.loli.net/2025/03/30/7TQF6gL1Cro5w2R.png><p><img alt=image-20250329231337759 data-src=https://s2.loli.net/2025/03/29/H6AyOzY18MKCcPJ.png><p><img alt=image-20250330000930507 data-src=https://s2.loli.net/2025/03/30/MXwuylP5fqpNBz4.png><div class=table-container><table><thead><tr><th>特性<th>聚集索引<th>二级索引<tbody><tr><td><strong>物理存储</strong><td>数据按索引键顺序存储<td>数据存储位置与索引无关，索引中包含指向数据行的指针<tr><td><strong>数量限制</strong><td>每个表只能有一个<td>可以有多个<tr><td><strong>查询效率</strong><td>对于按索引键排序的查询非常高效<td>需要两次查找（先找索引，再找数据行），但适用于多种查询条件<tr><td><strong>更新开销</strong><td>更新可能导致大量数据重排，开销较大<td>更新仅需修改索引结构，开销相对较小</table></div><h4 id=SQL优化><a class=headerlink href=#SQL优化 title=SQL优化></a>SQL优化</h4><p><strong>1. 使用 <code>EXPLAIN</code> 分析查询性能</strong><p>🔹 <code>EXPLAIN</code> 可以 <strong>分析 SQL 查询的执行计划</strong>，查看 <strong>索引使用情况</strong>、<strong>扫描方式</strong> 和 <strong>查询优化器的决策</strong>。<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>EXPLAIN <span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> name <span class=operator>=</span> <span class=string>'Alice'</span>;</span><br></pre></table></figure><p>🚀 <strong>关键字段解读</strong>：<div class=table-container><table><thead><tr><th><strong>字段</strong><th><strong>作用</strong><th><strong>优化建议</strong><tbody><tr><td><code>id</code><td>查询的执行顺序<td>ID 越大，优先执行<tr><td><code>select_type</code><td>查询类型<td><code>SIMPLE</code> 是最优<tr><td><code>table</code><td>查询的表<td>确保表索引优化<tr><td><code>type</code><td>访问类型<td><code>ALL</code>(全表扫描) 最差，<code>index</code>、<code>ref</code>、<code>range</code>、<code>const</code> 最优<tr><td><code>possible_keys</code><td>可能使用的索引<td>如果 <code>NULL</code>，说明没有合适的索引<tr><td><code>key</code><td>实际使用的索引<td>确保索引合理<tr><td><code>rows</code><td>需要扫描的行数<td>越少越好<tr><td><code>Extra</code><td>额外信息<td><strong>避免 <code>Using filesort</code> 和 <code>Using temporary</code></strong></table></div><p>🔹 <strong>优化示例</strong><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>EXPLAIN <span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> email <span class=operator>=</span> <span class=string>'test@example.com'</span>;</span><br></pre></table></figure><p><img alt=image-20250330111354571 data-src=https://s2.loli.net/2025/03/30/jpQ7nwHN8rg34Jq.png><p><strong>2. 使用 <code>SHOW PROFILE</code> 进行 SQL 运行时间分析</strong><p>🔹 <code>SHOW PROFILE</code> 详细分析 SQL <strong>在各个阶段的执行时间</strong>，如 <strong>解析、优化、执行、发送数据</strong>。<figure class="highlight pgsql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>sqlCopyEditSET profiling = <span class=number>1</span>;</span><br><span class=line><span class=keyword>SELECT</span> * <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> email = <span class=string>'test@example.com'</span>;</span><br><span class=line><span class=keyword>SHOW</span> PROFILES;</span><br></pre></table></figure><p>🔹 <strong>查看 SQL 具体耗时</strong><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>SHOW</span> PROFILE <span class=keyword>FOR</span> QUERY <span class=number>1</span>;</span><br></pre></table></figure><p>🚀 <strong>优化方向</strong><ul><li><strong>如果 <code>sending data</code> 耗时长</strong> ➝ 可能需要优化索引或减少返回数据量。<li><strong>如果 <code>query optimization</code> 耗时长</strong> ➝ SQL 逻辑复杂，可以考虑优化子查询或 JOIN。</ul><p><img alt=image-20250330112810495 data-src=https://s2.loli.net/2025/03/30/KcSBGzw6C1W5Iho.png><p><strong>3. 使用 <code>SHOW STATUS</code> 获取数据库运行状态</strong><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>SHOW</span> STATUS <span class=keyword>LIKE</span> <span class=string>'Threads%'</span>;</span><br><span class=line><span class=keyword>SHOW</span> <span class=keyword>GLOBAL</span> STATUS <span class=keyword>LIKE</span> <span class=string>'Com_______'</span>;</span><br></pre></table></figure><p>🚀 <strong>关键指标</strong><div class=table-container><table><thead><tr><th><strong>指标</strong><th><strong>作用</strong><th><strong>优化建议</strong><tbody><tr><td><code>Threads_running</code><td>当前正在执行的查询数<td><strong>避免长时间运行的查询</strong><tr><td><code>Threads_connected</code><td>当前连接数<td><strong>优化连接池配置</strong><tr><td><code>Slow_queries</code><td>慢查询数量<td><strong>检查慢查询日志</strong><tr><td><code>Handler_read_rnd_next</code><td>全表扫描次数<td><strong>应减少</strong>（索引优化）</table></div><p><strong>4. 慢查询日志分析</strong><p>🔹 <strong>开启慢查询日志</strong><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>SET</span> <span class=keyword>GLOBAL</span> slow_query_log <span class=operator>=</span> <span class=number>1</span>;</span><br><span class=line><span class=keyword>SET</span> <span class=keyword>GLOBAL</span> long_query_time <span class=operator>=</span> <span class=number>1</span>; <span class=comment>-- 记录执行时间 >1秒的查询</span></span><br></pre></table></figure><p>🔹 <strong>查看慢查询</strong><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> mysql.slow_log <span class=keyword>ORDER</span> <span class=keyword>BY</span> start_time <span class=keyword>DESC</span>;</span><br></pre></table></figure><p>🚀 <strong>优化方法</strong><ul><li><strong>使用索引，减少 <code>ALL</code> 扫描</strong><li><strong>优化 <code>JOIN</code>，避免 <code>Using temporary</code></strong><li><strong>避免 <code>ORDER BY</code> + <code>LIMIT</code> 造成的 <code>filesort</code></strong></ul><p><strong>5. 索引优化</strong><p><strong>（1）使用合适的索引</strong><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>CREATE</span> INDEX idx_users_name <span class=keyword>ON</span> users(name);</span><br></pre></table></figure><ul><li><p><strong>单列索引</strong>：适用于<strong>单个查询字段</strong></p><li><p><strong>复合索引</strong>：适用于 <strong><code>WHERE col1 AND col2</code></strong></p><li><p><strong>前缀索引</strong>：适用于<strong>长字符串字段</strong></p> <figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>CREATE</span> INDEX idx_users_email <span class=keyword>ON</span> users(email(<span class=number>10</span>));</span><br></pre></table></figure></ul><p><strong>（2）避免索引失效</strong><p>🔹 <strong>索引会失效的情况</strong><div class=table-container><table><thead><tr><th><strong>错误写法</strong><th><strong>原因</strong><tbody><tr><td><code>WHERE name LIKE '%abc'</code><td><code>%</code> 开头索引失效<tr><td><code>WHERE DATE(create_time) = '2024-03-30'</code><td><strong>函数</strong> 使索引失效<tr><td><code>WHERE id + 1 = 10</code><td><strong>计算操作</strong> 使索引失效</table></div><p>🔹 <strong>优化索引查询</strong><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment>-- 方式 1：避免前导 %</span></span><br><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> name <span class=keyword>LIKE</span> <span class=string>'abc%'</span>;</span><br><span class=line></span><br><span class=line><span class=comment>-- 方式 2：索引时间范围查询</span></span><br><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> orders <span class=keyword>WHERE</span> create_time <span class=keyword>BETWEEN</span> <span class=string>'2024-03-30'</span> <span class=keyword>AND</span> <span class=string>'2024-03-31'</span>;</span><br></pre></table></figure><p><strong>6. SQL 语句优化</strong><p><strong>（1）避免 <code>SELECT \*</code></strong><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>SELECT</span> id, name <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> id <span class=operator>=</span> <span class=number>10</span>;</span><br></pre></table></figure><p>🔹 <strong>减少不必要的数据传输，提高查询效率</strong><p><strong>（2）避免 <code>OR</code>，改为 <code>UNION ALL</code></strong><figure class="highlight pgsql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>sqlCopyEdit<span class=comment>-- ❌ 索引失效</span></span><br><span class=line><span class=keyword>SELECT</span> * <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> <span class=type>name</span> = <span class=string>'Alice'</span> <span class=keyword>OR</span> age = <span class=number>25</span>;</span><br><span class=line></span><br><span class=line><span class=comment>-- ✅ 改成 UNION ALL</span></span><br><span class=line><span class=keyword>SELECT</span> * <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> <span class=type>name</span> = <span class=string>'Alice'</span></span><br><span class=line><span class=keyword>UNION</span> <span class=keyword>ALL</span></span><br><span class=line><span class=keyword>SELECT</span> * <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> age = <span class=number>25</span>;</span><br></pre></table></figure><p>🔹 <strong><code>OR</code> 可能导致索引失效，而 <code>UNION ALL</code> 可提高性能</strong><p><strong>（3）避免 <code>NOT IN</code>，改用 <code>NOT EXISTS</code></strong><figure class="highlight pgsql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>sqlCopyEdit<span class=comment>-- ❌ NOT IN 可能导致全表扫描</span></span><br><span class=line><span class=keyword>SELECT</span> * <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> id <span class=keyword>NOT</span> <span class=keyword>IN</span> (<span class=keyword>SELECT</span> user_id <span class=keyword>FROM</span> orders);</span><br><span class=line></span><br><span class=line><span class=comment>-- ✅ 使用 NOT EXISTS</span></span><br><span class=line><span class=keyword>SELECT</span> * <span class=keyword>FROM</span> users u <span class=keyword>WHERE</span> <span class=keyword>NOT</span> <span class=keyword>EXISTS</span> (</span><br><span class=line>    <span class=keyword>SELECT</span> <span class=number>1</span> <span class=keyword>FROM</span> orders o <span class=keyword>WHERE</span> u.id = o.user_id</span><br><span class=line>);</span><br></pre></table></figure><p>🔹 <strong><code>NOT EXISTS</code> 在大数据量下查询效率更高</strong><div class=table-container><table><thead><tr><th><strong>优化点</strong><th><strong>方法</strong><tbody><tr><td><strong>SQL 分析</strong><td><code>EXPLAIN</code>、<code>SHOW PROFILE</code><tr><td><strong>索引优化</strong><td><code>CREATE INDEX</code>，避免索引失效<tr><td><strong>慢查询优化</strong><td><code>SHOW SLOW LOGS</code>，减少 <code>SELECT *</code><tr><td><strong>SQL 语句优化</strong><td><strong>避免 <code>OR</code>，使用 <code>EXISTS</code></strong><tr><td><strong>缓存优化</strong><td><strong>使用 Redis</strong>，调整 <code>query_cache_size</code><tr><td><strong>服务器配置优化</strong><td><strong>优化 <code>innodb_buffer_pool_size</code>、<code>max_connections</code></strong></table></div><p><strong>1. 最左前缀法则</strong><p><strong>定义</strong><ul><li><p><strong>最左前缀法则</strong>指的是，在使用组合索引时，查询条件必须从索引的最左边开始匹配。只有满足这个规则，MySQL 才能利用该索引来加速查询。</p><li><p>例如，如果你在一个表上创建了一个组合索引</p></ul><figure class="highlight clojure"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>(<span class=name>col1</span>, col2, col3)</span><br></pre></table></figure><p>，那么以下查询可以有效利用该索引：<p>sql<p>深色版本<figure class="highlight pgsql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>SELECT</span> * <span class=keyword>FROM</span> <span class=keyword>table</span> <span class=keyword>WHERE</span> col1 = <span class=string>'value'</span>;</span><br><span class=line><span class=keyword>SELECT</span> * <span class=keyword>FROM</span> <span class=keyword>table</span> <span class=keyword>WHERE</span> col1 = <span class=string>'value'</span> <span class=keyword>AND</span> col2 = <span class=string>'value'</span>;</span><br><span class=line><span class=keyword>SELECT</span> * <span class=keyword>FROM</span> <span class=keyword>table</span> <span class=keyword>WHERE</span> col1 = <span class=string>'value'</span> <span class=keyword>AND</span> col2 = <span class=string>'value'</span> <span class=keyword>AND</span> col3 = <span class=string>'value'</span>;</span><br></pre></table></figure><p>但是，如果查询条件不包含col1或者跳过了col1，则无法完全利用该索引：<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=comment>-- 不能利用索引</span></span><br><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> <span class=keyword>table</span> <span class=keyword>WHERE</span> col2 <span class=operator>=</span> <span class=string>'value'</span>;</span><br><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> <span class=keyword>table</span> <span class=keyword>WHERE</span> col3 <span class=operator>=</span> <span class=string>'value'</span>;</span><br></pre></table></figure><p><strong>原理</strong><ul><li>组合索引实际上是对多个列进行排序后构建的索引结构。MySQL 在查找数据时，会首先根据索引中最左边的列进行过滤，然后再依次考虑后面的列。<li>因此，为了最大化索引的利用率，查询条件应该尽可能地从最左边的列开始，并且保持连续</ul><p>模糊查询,如果是头部进行模糊,索引不会失效.<p>在索引上进行运算,索引会失效.<p><strong>1. <code>LIKE</code> 以 <code>%</code> 开头</strong><p>❌ <strong>错误示例</strong>（索引失效，全表扫描）：<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> name <span class=keyword>LIKE</span> <span class=string>'%Alice'</span>;</span><br></pre></table></figure><p>📌 <strong>原因</strong>：<ul><li><code>LIKE '%XXX'</code> <strong>前面有通配符</strong>，MySQL <strong>无法利用 B+ 树索引</strong>，只能<strong>全表扫描</strong>。</ul><p>✅ <strong>正确优化</strong><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> name <span class=keyword>LIKE</span> <span class=string>'Alice%'</span>;</span><br></pre></table></figure><p>📌 <strong>优化点</strong>：<ul><li><p><strong><code>Alice%</code> 结尾带 <code>%</code>，索引仍然有效</strong>。</p><li><p>若要支持前缀匹配，可 <strong>使用全文索引（FULLTEXT）</strong>：</p> <figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>sqlCopyEdit<span class=keyword>ALTER</span> <span class=keyword>TABLE</span> users <span class=keyword>ADD</span> FULLTEXT(name);</span><br><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> <span class=keyword>MATCH</span>(name) AGAINST(<span class=string>'Alice'</span>);</span><br></pre></table></figure></ul><p><strong>2. <code>OR</code> 可能导致索引失效</strong><p>❌ <strong>错误示例</strong>（索引失效）：<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> name <span class=operator>=</span> <span class=string>'Alice'</span> <span class=keyword>OR</span> age <span class=operator>=</span> <span class=number>25</span>;</span><br></pre></table></figure><p>📌 <strong>原因</strong>：<ul><li><strong><code>name</code> 和 <code>age</code> 上都有索引</strong>，但 <code>OR</code> 让 MySQL <strong>无法同时使用多个索引</strong>，会导致全表扫描。</ul><p>✅ <strong>正确优化</strong><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>-- 方式 1：使用 UNION（若 name 和 age 都有索引）</span></span><br><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> name <span class=operator>=</span> <span class=string>'Alice'</span></span><br><span class=line><span class=keyword>UNION</span> <span class=keyword>ALL</span></span><br><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> age <span class=operator>=</span> <span class=number>25</span>;</span><br></pre></table></figure><p>📌 <strong>优化点</strong>：<ul><li><code>UNION ALL</code> <strong>分两次查询，分别使用索引</strong>，<strong>避免全表扫描</strong>。</ul><p><strong>3. <code>NOT IN</code> 可能导致索引失效</strong><p>❌ <strong>错误示例</strong>（索引失效）：<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> id <span class=keyword>NOT</span> <span class=keyword>IN</span> (<span class=number>1</span>, <span class=number>2</span>, <span class=number>3</span>);</span><br></pre></table></figure><p>📌 <strong>原因</strong>：<ul><li><code>NOT IN</code> 可能触发全表扫描，因为 MySQL 需要 <strong>检查每一行是否符合条件</strong>。</ul><p>✅ <strong>正确优化</strong><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>-- 方式 1：改用 NOT EXISTS</span></span><br><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> users u <span class=keyword>WHERE</span> <span class=keyword>NOT</span> <span class=keyword>EXISTS</span> (</span><br><span class=line>    <span class=keyword>SELECT</span> <span class=number>1</span> <span class=keyword>FROM</span> orders o <span class=keyword>WHERE</span> u.id <span class=operator>=</span> o.user_id</span><br><span class=line>);</span><br></pre></table></figure><p>📌 <strong>优化点</strong>：<ul><li><strong><code>NOT EXISTS</code> 性能更优</strong>，可有效利用索引。</ul><p><strong>4. 对索引列进行计算</strong><p>❌ <strong>错误示例</strong>（索引失效）：<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> id <span class=operator>+</span> <span class=number>1</span> <span class=operator>=</span> <span class=number>10</span>;</span><br></pre></table></figure><p>📌 <strong>原因</strong>：<ul><li><code>id + 1 = 10</code> <strong>对索引字段进行了计算</strong>，导致 MySQL <strong>无法使用索引</strong>。</ul><p>✅ <strong>正确优化</strong><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> id <span class=operator>=</span> <span class=number>9</span>;</span><br></pre></table></figure><p>📌 <strong>优化点</strong>：<ul><li><strong>尽量避免索引列上的计算</strong>。</ul><p><strong>5. 对索引列使用函数</strong><p>❌ <strong>错误示例</strong>（索引失效）：<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> <span class=keyword>LEFT</span>(phone, <span class=number>3</span>) <span class=operator>=</span> <span class=string>'138'</span>;</span><br></pre></table></figure><p>📌 <strong>原因</strong>：<ul><li><code>LEFT(phone, 3)</code> <strong>对 <code>phone</code> 列进行了函数操作</strong>，导致索引失效。</ul><p>✅ <strong>正确优化</strong><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> phone <span class=keyword>LIKE</span> <span class=string>'138%'</span>;</span><br></pre></table></figure><p>📌 <strong>优化点</strong>：<ul><li><strong>避免对索引列使用函数</strong>，可以使用 <code>LIKE 'XXX%'</code>。</ul><p><strong>6. 数据类型不匹配</strong><p>❌ <strong>错误示例</strong>（索引失效）：<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> phone <span class=operator>=</span> <span class=number>13812345678</span>;</span><br></pre></table></figure><p>📌 <strong>原因</strong>：<ul><li><code>phone</code> 列是 <strong><code>VARCHAR(11)</code> 类型</strong>，但查询时传入的是 <strong>数值</strong>（<code>INT</code>）。<li>MySQL <strong>会进行隐式类型转换</strong>，导致索引失效。</ul><p>✅ <strong>正确优化</strong><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> phone <span class=operator>=</span> <span class=string>'13812345678'</span>;</span><br></pre></table></figure><p>📌 <strong>优化点</strong>：<ul><li><strong>保证查询参数类型与索引列类型一致</strong>。</ul><p><strong>7. 范围查询 (<code>></code>、<code><</code>、<code>BETWEEN</code>) 导致索引失效</strong><p>❌ <strong>错误示例</strong>（索引失效部分字段）：<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> age <span class=operator>></span> <span class=number>30</span> <span class=keyword>AND</span> name <span class=operator>=</span> <span class=string>'Alice'</span>;</span><br></pre></table></figure><p>📌 <strong>原因</strong>：<ul><li><strong><code>age > 30</code> 是范围查询</strong>，<strong>索引可能只用到 <code>age</code>，导致 <code>name</code> 不能被索引优化</strong>。</ul><p>✅ <strong>正确优化</strong><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> name <span class=operator>=</span> <span class=string>'Alice'</span> <span class=keyword>AND</span> age <span class=operator>></span> <span class=number>30</span>;</span><br></pre></table></figure><p>📌 <strong>优化点</strong>：<ul><li><strong>调整查询字段顺序，让等值查询 (<code>=</code>) 在前</strong>，<strong>让 MySQL 更容易使用索引</strong>。</ul><p><strong>8. <code>ORDER BY</code> + <code>LIMIT</code> 可能导致索引失效</strong><p>❌ <strong>错误示例</strong>：<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> users <span class=keyword>ORDER</span> <span class=keyword>BY</span> age LIMIT <span class=number>10000</span>, <span class=number>10</span>;</span><br></pre></table></figure><p>📌 <strong>原因</strong>：<ul><li>当 <code>LIMIT</code> 偏移量过大时，MySQL <strong>仍然会扫描大量数据</strong>，导致性能下降。</ul><p>✅ <strong>正确优化</strong><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>-- 方式 1：使用覆盖索引</span></span><br><span class=line><span class=keyword>SELECT</span> id, name <span class=keyword>FROM</span> users <span class=keyword>ORDER</span> <span class=keyword>BY</span> age LIMIT <span class=number>10000</span>, <span class=number>10</span>;</span><br><span class=line></span><br><span class=line><span class=comment>-- 方式 2：使用子查询优化</span></span><br><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> users </span><br><span class=line><span class=keyword>WHERE</span> id <span class=operator>>=</span> (<span class=keyword>SELECT</span> id <span class=keyword>FROM</span> users <span class=keyword>ORDER</span> <span class=keyword>BY</span> age LIMIT <span class=number>10000</span>, <span class=number>1</span>)</span><br><span class=line><span class=keyword>ORDER</span> <span class=keyword>BY</span> age LIMIT <span class=number>10</span>;</span><br></pre></table></figure><p>📌 <strong>优化点</strong>：<ul><li><strong>尽量减少 <code>LIMIT</code> 偏移量</strong>，可用 <strong>子查询</strong> 或 <strong>覆盖索引</strong> 提高效率。</ul><p><strong>索引失效的常见原因总结</strong><div class=table-container><table><thead><tr><th>失效原因<th>解决方案<tbody><tr><td><code>LIKE '%XXX'</code><td>改为 <code>LIKE 'XXX%'</code>，或使用 <code>FULLTEXT</code> 索引<tr><td><code>OR</code><td>使用 <code>UNION ALL</code><tr><td><code>NOT IN</code><td>使用 <code>NOT EXISTS</code><tr><td>索引列计算<td>直接在 <code>WHERE</code> 子句中使用索引列<tr><td>索引列使用函数<td>避免 <code>LEFT(phone, 3)</code>，改用 <code>LIKE 'XXX%'</code><tr><td>数据类型不匹配<td>查询参数类型与索引列类型一致<tr><td>范围查询 (<code>></code>, <code><</code>, <code>BETWEEN</code>)<td>让等值查询 (<code>=</code>) 在前<tr><td><code>ORDER BY</code> + <code>LIMIT</code><td>使用覆盖索引或子查询优化</table></div><p>在某些情况下，可以通过 <code>FORCE INDEX</code> 强制 MySQL 使用特定的索引，避免优化器选择全表扫描。<h5 id=示例><a class=headerlink href=#示例 title=示例></a>示例</h5><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>SELECT</span> <span class=operator>*</span> <span class=keyword>FROM</span> employees FORCE INDEX (idx_department)</span><br><span class=line><span class=keyword>WHERE</span> department <span class=operator>=</span> <span class=string>'Sales'</span> <span class=keyword>OR</span> salary <span class=operator>></span> <span class=number>5000</span>;</span><br></pre></table></figure><ul><li><strong>注意</strong>：强制使用索引需要谨慎，因为优化器通常会选择最优的执行计划。如果强制使用不合适的索引，可能会适得其反</ul><p><strong>覆盖索引</strong><p>如果查询的所有列都包含在一个索引中，可以通过创建覆盖索引来避免回表操作，从而提高查询效率。<h5 id=示例-1><a class=headerlink href=#示例-1 title=示例></a>示例</h5><p>假设查询如下：<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>SELECT</span> department, salary <span class=keyword>FROM</span> employees <span class=keyword>WHERE</span> department <span class=operator>=</span> <span class=string>'Sales'</span> <span class=keyword>OR</span> salary <span class=operator>></span> <span class=number>5000</span>;</span><br></pre></table></figure><p>可以创建以下覆盖索引：<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>CREATE</span> INDEX idx_dept_salary <span class=keyword>ON</span> employees(department, salary);</span><br></pre></table></figure><p>由于查询所需的所有列都在索引中，MySQL 可以直接通过索引返回结果，无需访问数据表(不需要回标)。<p><strong>前缀索引</strong><ul><li><strong>前缀索引</strong>是指对列中值的前 N 个字符或字节创建索引，而不是对整个列值进行索引。<li>这种方法特别适用于 <code>VARCHAR</code>、<code>TEXT</code> 和 <code>BLOB</code> 类型的列，这些列通常包含较长的数据。</ul><p>前缀索引（Prefix Index）是 MySQL 中一种特殊的索引类型，它允许你为列的值的前缀创建索引，而不是整个列的值。这种索引对于那些存储较长字符串的列特别有用，因为它可以显著减少索引的大小，同时仍然提供良好的查询性能<p>假设有一个博客系统，其中的文章标题可能很长，并且我们希望根据标题的部分内容进行搜索：<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>CREATE</span> <span class=keyword>TABLE</span> articles (</span><br><span class=line>    id <span class=type>INT</span> <span class=keyword>PRIMARY</span> KEY,</span><br><span class=line>    title <span class=type>VARCHAR</span>(<span class=number>255</span>),</span><br><span class=line>    content TEXT,</span><br><span class=line>    INDEX idx_title (title(<span class=number>50</span>))  <span class=comment>-- 对标题的前50个字符创建索引</span></span><br><span class=line>);</span><br></pre></table></figure><p>对于存储长文本数据的列，除了前缀索引外，还可以考虑使用<strong>全文索引</strong>（Full-Text Index）。全文索引专门用于支持复杂的文本搜索功能，如自然语言查询和布尔查询。<p><strong>(1) 适用场景</strong><ul><li><strong>前缀索引</strong>：适合于简单的前缀匹配查询（如 <code>LIKE 'prefix%'</code>）。<li><strong>全文索引</strong>：适合于复杂的文本搜索需求（如 <code>MATCH ... AGAINST</code>）。</ul><p><strong>(2) 性能对比</strong><ul><li>前缀索引更适合于快速定位具有特定前缀的记录，但在处理复杂的文本搜索时不如全文索引高效。<li>全文索引虽然功能强大，但构建和维护成本较高，尤其是在数据量较大的情况下。</ul><p><img alt=image-20250330133609570 data-src=https://s2.loli.net/2025/03/30/86OFTKqeLhJwMxY.png><p><img alt=image-20250330134534828 data-src=https://s2.loli.net/2025/03/30/xTDM5wFYCa4g1rU.png><p><img alt=image-20250330134512802 data-src=https://s2.loli.net/2025/03/30/VrLeJvdSgTYf79C.png><h3 id=视图-存储过程-触发器><a class=headerlink href=#视图-存储过程-触发器 title=视图/存储过程/触发器></a>视图/存储过程/触发器</h3><h4 id=视图-Views><a title="视图 (Views)" class=headerlink href=#视图-Views></a>视图 (Views)</h4><p><strong>视图</strong>是基于SQL语句的结果集的可视化的表。视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实表中的字段<ul><li><strong>虚拟表</strong>：视图并不在数据库中以存储的数据值集形式存在；行和列数据来自于定义视图的查询所引用的基本表，并且是在访问视图时动态生成的。<li><strong>简化复杂查询</strong>：可以将复杂的查询封装进视图中，使用户可以通过简单的查询来访问这些数据。<li><strong>安全性</strong>：通过视图限制对基础表的访问，从而提高安全性。例如，<strong>只允许用户通过视图查看特定的列或行</strong>。<li><strong>更新限制</strong>：并非所有视图都可以被更新。对于包含聚合函数、DISTINCT关键字、GROUP BY、HAVING等的视图，通常不能直接进行更新操作。</ul><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>CREATE</span> <span class=keyword>VIEW</span> view_name <span class=keyword>AS</span></span><br><span class=line><span class=keyword>SELECT</span> column1, column2, ...</span><br><span class=line><span class=keyword>FROM</span> table_name</span><br><span class=line><span class=keyword>WHERE</span> <span class=keyword>condition</span>;</span><br></pre></table></figure><h3 id=存储过程-Stored-Procedures><a title="存储过程 (Stored Procedures)" class=headerlink href=#存储过程-Stored-Procedures></a>存储过程 (Stored Procedures)</h3><p>定义<ul><li><strong>存储过程</strong>是一组为了完成特定功能的SQL语句集，经过编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。</ul><p>特点与重点<ul><li><strong>性能优化</strong>：由于存储过程在创建时就已经进行了编译，因此在执行时速度更快。<li><strong>模块化编程</strong>：可以将复杂的业务逻辑封装到存储过程中，提高代码的重用性和可维护性。<li><strong>减少网络流量</strong>：通过将一系列操作封装在一个存储过程中，可以减少客户端与服务器之间的通信量。<li><strong>安全控制</strong>：可以为存储过程设置权限，从而控制谁可以执行哪些操作。</ul><p>创建示例<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>DELIMITER <span class=operator>/</span><span class=operator>/</span></span><br><span class=line><span class=keyword>CREATE</span> <span class=keyword>PROCEDURE</span> procedure_name()</span><br><span class=line><span class=keyword>BEGIN</span></span><br><span class=line>    <span class=comment>-- SQL statements here</span></span><br><span class=line><span class=keyword>END</span> <span class=operator>/</span><span class=operator>/</span></span><br><span class=line>DELIMITER ;</span><br></pre></table></figure><h3 id=触发器-Triggers><a title="触发器 (Triggers)" class=headerlink href=#触发器-Triggers></a>触发器 (Triggers)</h3><p>定义<ul><li><strong>触发器</strong>是一种特殊的存储过程，它不能被显式地调用，而是当一个与其关联的操作发生的时候自动触发执行。这些操作包括<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>等。</ul><p>特点与重点<ul><li><strong>自动执行</strong>：无需人工干预即可自动执行，用于确保某些规则或流程的一致性。<li><strong>事务支持</strong>：触发器会参与到同一个事务中，这意味着如果触发器中的操作失败，则整个事务都会回滚。<li><strong>事件驱动</strong>：可以根据表上的插入、更新或删除操作来触发相应的逻辑。<li><strong>注意性能影响</strong>：虽然触发器提供了强大的功能，但不恰当地使用可能会导致性能问题，尤其是在高并发环境下。</ul><p>创建示例<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>CREATE</span> <span class=keyword>TRIGGER</span> trigger_name</span><br><span class=line>BEFORE<span class=operator>/</span>AFTER <span class=keyword>INSERT</span><span class=operator>/</span>UPDATE<span class=operator>/</span><span class=keyword>DELETE</span> <span class=keyword>ON</span> table_name</span><br><span class=line><span class=keyword>FOR</span> <span class=keyword>EACH</span> <span class=type>ROW</span></span><br><span class=line><span class=keyword>BEGIN</span></span><br><span class=line>    <span class=comment>-- Trigger logic here</span></span><br><span class=line><span class=keyword>END</span>;</span><br></pre></table></figure><ul><li><strong>视图</strong>主要用于简化查询、增强安全性和提供抽象层。<li><strong>存储过程</strong>则侧重于执行效率、模块化编程和减少网络负载。<li><strong>触发器</strong>适用于需要在数据库层面自动响应特定事件的情况，如保持数据一致性或记录审计信息。</ul><h3 id=锁><a class=headerlink href=#锁 title=锁></a>锁</h3><p>锁（Locking）是确保数据一致性和事务隔离级别的核心机制。通过锁定数据库中的资源，可以防止多个用户或进程同时对相同的数据进行修改而导致的数据不一致性问题。<p><strong>全局锁</strong><p>全局读锁允许在锁定期间进行读操作，但阻止写操作。全局读锁通常用于备份操作或其他需要读取整个数据库的场景。通常使用 <code>FLUSH TABLES WITH READ LOCK</code> 语句来获取全局读锁。<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>flush tables <span class=keyword>with</span> read lock;</span><br><span class=line>mysqldump db <span class=operator>></span> xx.sql;</span><br><span class=line>unlock tables;</span><br></pre></table></figure><p><strong>表级锁</strong>:锁定整个表，适用于高并发写入较少的场景。<p>表锁<p><code>LOCK TABLES</code> 语句用于在事务或会话中显式地锁定一张或多张表。锁定的表会根据需要加共享锁或排它锁，直到 <code>UNLOCK TABLES</code> 被调用。<p><strong>示例：</strong><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>LOCK TABLES table_name READ;  <span class=comment>-- 给表加共享锁</span></span><br><span class=line>LOCK TABLES table_name WRITE;  <span class=comment>-- 给表加排它锁</span></span><br></pre></table></figure><p><code>UNLOCK TABLES</code> 用于释放之前使用 <code>LOCK TABLES</code> 锁定的所有表。此命令会解除锁定，允许其他事务访问这些表。<p><strong>示例：</strong><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>UNLOCK TABLES;</span><br></pre></table></figure><p><strong>共享锁（S Lock 读锁）</strong><p>共享锁允许多个事务同时读取表中的数据，但阻止写操作。也就是说，多个事务可以同时持有共享锁并执行读取操作，但不能修改表中的数据。<ul><li><strong>共享锁的特点</strong>：<ul><li>允许多个事务并发读取同一个表的数据。<li>其他事务无法修改表中的数据，但可以进行读取操作。</ul></ul><p><strong>排它锁（X Lock 写锁）</strong><p>排它锁是一种更强的锁类型，当一个事务对某一表加了排它锁时，其他事务既不能读取也不能修改这个表中的数据。<ul><li><strong>排它锁的特点</strong>：<ul><li>只有持有排它锁的事务可以对表进行修改。<li>其他事务无法读取或修改这个表。</ul></ul><p>元数据锁<p>用于保护数据库元数据的一种锁机制。元数据指的是描述数据库结构的信息，比如表、索引、列、外键等数据库对象的定义。元数据锁的主要作用是<strong>防止在某些操作（如修改表结构）期间，其他操作对相同数据库对象的访问或修改</strong>，以保证元数据的一致性和完整性。<p><img alt=image-20250330141448484 data-src=https://s2.loli.net/2025/03/30/gA2pIsEbMSnZ3vc.png><p>意向锁<p>意向锁是一种<strong>表级锁</strong>，它的作用并不是直接控制对数据的访问，而是<strong>表明某个事务希望对表中的某些行加锁</strong>，从而避免在加行级锁时与其他事务产生冲突。<p>当一个事务打算<strong>在某个表中对某些行加行级锁时，必须首先获取意向锁（IS 或 IX）来表明它的意图</strong>。这些意向锁会被 <strong>自动加上</strong>，因此，事务无需手动显式地设置意向锁。<ul><li><strong>意向共享锁（Intention Shared Lock, IS 锁）</strong>：<ul><li>表示事务打算在某些行上加共享锁（S 锁）。<li>其他事务仍然可以对该表加意向共享锁或意向排他锁，但不能加排他锁（X 锁）。</ul><li><strong>意向排他锁（Intention Exclusive Lock, IX 锁）</strong>：<ul><li>表示事务打算在某些行上加排他锁（X 锁）。<li>其他事务不能对该表加任何类型的锁（包括共享锁和排他锁），但可以加意向排他锁。</ul></ul><div class=table-container><table><thead><tr><th>当前锁 \ 请求锁<th>IS 锁<th>IX 锁<th>S 锁<th>X 锁<tbody><tr><td><strong>IS 锁</strong><td>兼容<td>兼容<td>兼容<td>不兼容<tr><td><strong>IX 锁</strong><td>兼容<td>兼容<td>不兼容<td>不兼容<tr><td><strong>S 锁</strong><td>兼容<td>不兼容<td>兼容<td>不兼容<tr><td><strong>X 锁</strong><td>不兼容<td>不兼容<td>不兼容<td>不兼容</table></div><p><strong>1. 使用 <code>SELECT ... FOR UPDATE</code> 触发意向排它锁（IX）</strong><p><code>SELECT ... FOR UPDATE</code> 语句会在查询的行上加上 <strong>排它锁（X）</strong>，同时在表级别加上 <strong>意向排它锁（IX）</strong>，表示这个事务打算对该表中的一些行加排它锁。这样做是为了避免多个事务在同一表上进行行级锁时产生冲突。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>-- 开始一个事务</span><br><span class=line>START TRANSACTION;</span><br><span class=line></span><br><span class=line>-- 对表中的某行数据加排它锁，并在表上加意向排它锁（IX）</span><br><span class=line>SELECT * FROM your_table WHERE id = 1 FOR UPDATE;</span><br></pre></table></figure><p><strong>2. 使用 <code>SELECT ... LOCK IN SHARE MODE</code> 触发意向共享锁（IS）</strong><p><code>SELECT ... LOCK IN SHARE MODE</code> 语句会在查询的行上加上 <strong>共享锁（S）</strong>，同时在表级别加上 <strong>意向共享锁（IS）</strong>，表示这个事务打算对该表中的一些行加共享锁。意向锁表明了事务打算进行共享锁操作，而不直接锁定整个表。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>-- 开始一个事务</span><br><span class=line>START TRANSACTION;</span><br><span class=line></span><br><span class=line>-- 对表中的某行数据加共享锁，并在表上加意向共享锁（IS）</span><br><span class=line>SELECT * FROM your_table WHERE id = 1 LOCK IN SHARE MODE;</span><br></pre></table></figure><p><strong>行级锁</strong>:锁定特定的行，适用于高并发写入较多的场景，能提供更高的并发性能。<p><strong>记录锁（Record Locks）</strong><ul><li><strong>定义</strong>：记录锁是对索引记录加的锁。即使表没有定义索引，MySQL也会使用隐藏的主键索引来执行记录锁。</ul><p><img alt=image-20250330143657554 data-src=https://s2.loli.net/2025/03/30/dILW1GOJw7h5UAu.png><p><img alt=image-20250330143737180 data-src=https://s2.loli.net/2025/03/30/3B4fXRhOl1Zqgoe.png><p><img alt=image-20250330151445124 data-src=https://s2.loli.net/2025/03/30/P2bx8Qfzch4Wgsq.png><p><strong>间隙锁（Gap Locks）</strong><p>用于锁定索引记录之间的间隙，或者锁定第一个索引记录之前或最后一个索引记录之后的空间。间隙锁主要用于防止其他事务在这个间隙中插入新的记录，从而避免幻读问题（Phantom Reads）。它通常在可重复读（Repeatable Read）隔离级别下工作<ul><li><strong>定义</strong>：间隙锁锁定的是索引记录之间的间隙，或者锁定第一个索引记录之前或最后一个索引记录之后的空间。主要用于防止幻读现象。<li><strong>适用范围</strong>：仅在可重复读（Repeatable Read）隔离级别下有效。</ul><p><strong>Next-Key Locks</strong><ul><li><strong>定义</strong>：Next-Key Locks 是记录锁与间隙锁的组合，锁定的是索引记录本身以及它之前的间隙。这种锁机制有效地解决了幻读问题</ul><p><img alt=image-20250330151930245 data-src=https://s2.loli.net/2025/03/30/G7SjImNUFL8g1un.png><p><img alt=image-20250330152702028 data-src=https://s2.loli.net/2025/03/30/FajEoXNZCSVrk3H.png><h3 id=日志><a class=headerlink href=#日志 title=日志></a>日志</h3><h4 id=错误日志><a class=headerlink href=#错误日志 title=错误日志></a>错误日志</h4><p><strong>(1) 定义</strong><ul><li><strong>错误日志</strong>记录了 MySQL 服务器启动、运行或停止过程中遇到的问题，包括启动失败、崩溃以及一些警告信息。</ul><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>show variable like '%log_error%'</span><br></pre></table></figure><p><strong>(2) 配置</strong><ul><li><p>默认情况下，错误日志通常位于数据目录下，文件名为 <code>hostname.err</code>(windows)。</p><li><p>可以通过修改配置文件my.cnf或my.ini来指定错误日志的位置和是否启用：</p> <figure class="highlight applescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>[mysqld]</span><br><span class=line>log_error=/path/<span class=keyword>to</span>/<span class=keyword>error</span>.<span class=built_in>log</span></span><br></pre></table></figure></ul><p><strong>2. 二进制日志（Binary Log）</strong><p><strong>(1) 定义</strong><ul><li><strong>二进制日志</strong>记录了所有更改数据库内容的事件（如 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 等），主要用于数据恢复和主从复制。</ul><p><strong>(2) 配置</strong><ul><li><p>启用二进制日志：</p> <figure class="highlight ini"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=section>[mysqld]</span></span><br><span class=line><span class=attr>server-id</span>=<span class=number>1</span></span><br><span class=line><span class=attr>log-bin</span>=/path/to/bin-log</span><br></pre></table></figure><li><p>可以设置过期时间自动清理旧的日志文件：</p> <figure class="highlight ini"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>expire_logs_days</span>=<span class=number>7</span></span><br></pre></table></figure> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>show variable like '%log_bin%'</span><br></pre></table></figure></ul><p><img alt=image-20250330153408013 data-src=https://s2.loli.net/2025/03/30/wAtkHS1Z5zXsBpy.png><p><img alt=image-20250330153726345 data-src=https://s2.loli.net/2025/03/30/idITAkyWSDp6m5M.png><p><img alt=image-20250330154122177 data-src=https://s2.loli.net/2025/03/30/CRmDU9XvnuzKfbj.png><p><strong>查询日志（General Query Log）</strong><p><strong>(1) 定义</strong><ul><li><strong>查询日志</strong>记录了所有客户端连接和执行的所有 SQL 语句，这对于调试和审计非常有用。</ul><p><strong>(2) 配置</strong><ul><li><p>可以通过以下方式启用查询日志：</p> <figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>SET</span> <span class=keyword>GLOBAL</span> general_log <span class=operator>=</span> <span class=string>'ON'</span>;</span><br></pre></table></figure> <p>或者在配置文件中设置：</p> <figure class="highlight ini"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=section>[mysqld]</span></span><br><span class=line><span class=attr>general_log</span>=<span class=number>1</span></span><br><span class=line><span class=attr>general_log_file</span>=/path/to/query.log</span><br></pre></table></figure></ul><p><strong>(3) 使用场景</strong><ul><li>调试：当需要了解应用程序如何与数据库交互时，查询日志是一个很好的工具。<li>性能分析：虽然查询日志对性能有一定影响，但它可以用来识别慢查询或频繁执行的查询。</ul><p><strong>3. 慢查询日志（Slow Query Log）</strong><p><strong>(1) 定义</strong><ul><li><strong>慢查询日志</strong>记录了执行时间超过指定阈值的查询，有助于识别性能瓶颈。</ul><p><strong>(2) 配置</strong><ul><li><p>启用慢查询日志：</p> <figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>SET</span> <span class=keyword>GLOBAL</span> slow_query_log <span class=operator>=</span> <span class=string>'ON'</span>;</span><br></pre></table></figure> <p>设置慢查询的时间阈值（单位为秒）：</p> <figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>SET</span> <span class=keyword>GLOBAL</span> long_query_time <span class=operator>=</span> <span class=number>2</span>; <span class=comment>-- 记录执行时间超过2秒的查询</span></span><br></pre></table></figure> <p>在配置文件中也可以进行相应的设置：</p> <figure class="highlight ini"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=section>[mysqld]</span></span><br><span class=line><span class=attr>slow_query_log</span>=<span class=number>1</span></span><br><span class=line><span class=attr>slow_query_log_file</span>=/path/to/slow-query.log</span><br><span class=line><span class=attr>long_query_time</span>=<span class=number>2</span></span><br></pre></table></figure></ul><p><strong>(3) 使用场景</strong><ul><li>性能优化：通过分析慢查询日志，可以找到执行效率低下的查询并进行优化。<li>监控：持续监控慢查询日志可以帮助及时发现性能问题。</ul><p><img alt=image-20250330155227205 data-src=https://s2.loli.net/2025/03/30/afxo4iHyzStjgPR.png><h3 id=Join连接><a class=headerlink href=#Join连接 title=Join连接></a>Join连接</h3><p>join连接两个表<ul><li><strong>INNER JOIN</strong>：仅返回两个表中满足连接条件的记录。<li><strong>LEFT JOIN</strong>（或LEFT OUTER JOIN）：返回左表中的所有记录，以及右表中满足连接条件的记录。若右表无匹配记录则填充NULL。<li><strong>RIGHT JOIN</strong>（或RIGHT OUTER JOIN）：返回右表中的所有记录，以及左表中满足连接条件的记录。若左表无匹配记录则填充NULL。<li><strong>FULL JOIN</strong>（或FULL OUTER JOIN）：返回两个表中的所有记录，任何表中无匹配记录的部分用NULL填充。（注意：MySQL不直接支持此语法）<li><strong>CROSS JOIN</strong>：产生两个表的笛卡尔积。<li><strong>SELF JOIN</strong>：一个表与自身的连接，适用于查询具有层次结构的数据。</ul><p><code>%</code> 可以匹配任意长度的字符串（包括空字符串），而 <code>_</code> 总是代表一个单一字符.在SQL中，默认情况下并没有一个预设的转义字符用于 <code>LIKE</code> 查询中的通配符（如 <code>%</code> 和 <code>_</code>）转义。这意味着，如果你需要转义这些特殊字符，你必须明确指定一个转义字符，并通过 <code>ESCAPE</code> 关键字来定义它。<p>尽管没有默认的转义字符，但你可以选择一个不会出现在目标字符串中的字符作为转义字符。常用的转义字符包括反斜杠 <code>\</code> 或者感叹号 <code>!</code> 等。下面是如何使用 <code>ESCAPE</code> 来定义转义字符的例子：<p>如果想查找包含实际百分比符号 <code>%</code> 的记录，可以这样做：<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>SELECT</span> column_name </span><br><span class=line><span class=keyword>FROM</span> table_name </span><br><span class=line><span class=keyword>WHERE</span> column_name <span class=keyword>LIKE</span> <span class=string>'%\%%'</span> <span class=keyword>ESCAPE</span> <span class=string>'\'</span>;</span><br></pre></table></figure><p>在这个例子中：<ul><li><code>\%</code> 表示实际的百分号字符 <code>%</code> 而不是通配符。<li><code>ESCAPE '\'</code> 告诉数据库 <code>\</code> 是转义字符。</ul><h2 id=PostgresSQL><a class=headerlink href=#PostgresSQL title=PostgresSQL></a>PostgresSQL</h2><p><a href=https://www.postgresql.org/ rel=noopener target=_blank>PostgreSQL: The world’s most advanced open source database</a><h2 id=MongoDB><a class=headerlink href=#MongoDB title=MongoDB></a>MongoDB</h2><p><a href=https://www.mongodb.com/docs/guides/ rel=noopener target=_blank>Start with Guides - Start with Guides</a><h1 id=持久层框架><a class=headerlink href=#持久层框架 title=持久层框架></a>持久层框架</h1><h2 id=Mybatis✨><a class=headerlink href=#Mybatis✨ title=Mybatis✨></a>Mybatis✨</h2><p><a href=https://mybatis.org/mybatis-3/zh_CN/index.html rel=noopener target=_blank>MyBatis 3 | 简介 – mybatis</a><p><a href=https://www.bilibili.com/video/BV1VP4y1c7j7/ rel=noopener target=_blank>【尚硅谷】MyBatis零基础入门教程（细致全面，快速上手mybatis）_哔哩哔哩_bilibili</a><p><a href=https://www.bilibili.com/video/BV1JP4y1Z73S/ rel=noopener target=_blank>MyBatis视频零基础入门到进阶，MyBatis全套视频教程源码级深入详解_哔哩哔哩_bilibili</a><p>持久层框架,简化JDBC开发,负责数据库的读写.<p>JDBC问题:硬编码 操作繁琐<h3 id=查询单表数据整体流程><a class=headerlink href=#查询单表数据整体流程 title=查询单表数据整体流程></a>查询单表数据整体流程</h3><ol><li>创建表,插入数据<li>创建模块,导入maven<li>编写mybatis核心配置文件(替换连接信息,解决硬编码)<li>编写sql映射文件(统一管理sql语句)<li>编码: 定义POJO类 加载核心配置文件,获取sqlsessionfactory对象,执行sql语句</ol><h3 id=使用Mapper代理开发><a class=headerlink href=#使用Mapper代理开发 title=使用Mapper代理开发></a>使用Mapper代理开发</h3><blockquote><p>创建mapper类,该类名称与命名空间相同,方法申明与mapper映射xml文件相同</blockquote><p>既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>try</span> (SqlSession session = sqlSessionFactory.openSession()) {</span><br><span class=line>  Blog blog = (Blog) session.selectOne(<span class=string>"org.mybatis.example.BlogMapper.selectBlog"</span>, <span class=number>101</span>);</span><br><span class=line>}</span><br></pre></table></figure><p>诚然，这种方式能够正常工作，对使用旧版本 MyBatis 的用户来说也比较熟悉。但现在有了一种更简洁的方式——<strong>使用和指定语句的参数和返回值相匹配的接口（比如 BlogMapper.class），现在你的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换。</strong><p>例如：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>try</span> (SqlSession session = sqlSessionFactory.openSession()) {</span><br><span class=line>  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class=line>  Blog blog = mapper.selectBlog(<span class=number>101</span>);</span><br><span class=line>}</span><br></pre></table></figure><p><img alt=image-20250309134454871 data-src=https://s2.loli.net/2025/03/09/S12tudvJjEeoXTp.png><h3 id=properties><a class=headerlink href=#properties title=properties></a>properties</h3><p>这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。例如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>properties</span> <span class=attr>resource</span>=<span class=string>"org/mybatis/example/config.properties"</span>></span></span><br><span class=line>  <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"username"</span> <span class=attr>value</span>=<span class=string>"dev_user"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"password"</span> <span class=attr>value</span>=<span class=string>"F2Fa3!33TYyg"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>properties</span>></span></span><br></pre></table></figure><h3 id=settings><a class=headerlink href=#settings title=settings></a>settings</h3><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>settings</span>></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"cacheEnabled"</span> <span class=attr>value</span>=<span class=string>"true"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"lazyLoadingEnabled"</span> <span class=attr>value</span>=<span class=string>"true"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"multipleResultSetsEnabled"</span> <span class=attr>value</span>=<span class=string>"true"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"useColumnLabel"</span> <span class=attr>value</span>=<span class=string>"true"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"useGeneratedKeys"</span> <span class=attr>value</span>=<span class=string>"false"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"autoMappingBehavior"</span> <span class=attr>value</span>=<span class=string>"PARTIAL"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"autoMappingUnknownColumnBehavior"</span> <span class=attr>value</span>=<span class=string>"WARNING"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"defaultExecutorType"</span> <span class=attr>value</span>=<span class=string>"SIMPLE"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"defaultStatementTimeout"</span> <span class=attr>value</span>=<span class=string>"25"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"defaultFetchSize"</span> <span class=attr>value</span>=<span class=string>"100"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"safeRowBoundsEnabled"</span> <span class=attr>value</span>=<span class=string>"false"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"mapUnderscoreToCamelCase"</span> <span class=attr>value</span>=<span class=string>"false"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"localCacheScope"</span> <span class=attr>value</span>=<span class=string>"SESSION"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"jdbcTypeForNull"</span> <span class=attr>value</span>=<span class=string>"OTHER"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"lazyLoadTriggerMethods"</span> <span class=attr>value</span>=<span class=string>"equals,clone,hashCode,toString"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>settings</span>></span></span><br></pre></table></figure><h3 id=TypeAliases><a class=headerlink href=#TypeAliases title=TypeAliases></a>TypeAliases</h3><p>类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>&LTtypeAliases></span><br><span class=line>  &LTtypeAlias <span class=built_in>alias</span>=<span class=string>"Author"</span> <span class=built_in>type</span>=<span class=string>"domain.blog.Author"</span>/></span><br><span class=line>  &LTtypeAlias <span class=built_in>alias</span>=<span class=string>"Blog"</span> <span class=built_in>type</span>=<span class=string>"domain.blog.Blog"</span>/></span><br><span class=line>  &LTtypeAlias <span class=built_in>alias</span>=<span class=string>"Comment"</span> <span class=built_in>type</span>=<span class=string>"domain.blog.Comment"</span>/></span><br><span class=line>  &LTtypeAlias <span class=built_in>alias</span>=<span class=string>"Post"</span> <span class=built_in>type</span>=<span class=string>"domain.blog.Post"</span>/></span><br><span class=line>  &LTtypeAlias <span class=built_in>alias</span>=<span class=string>"Section"</span> <span class=built_in>type</span>=<span class=string>"domain.blog.Section"</span>/></span><br><span class=line>  &LTtypeAlias <span class=built_in>alias</span>=<span class=string>"Tag"</span> <span class=built_in>type</span>=<span class=string>"domain.blog.Tag"</span>/></span><br><span class=line>&LT/typeAliases></span><br></pre></table></figure><p>当这样配置时，<code>Blog</code> 可以用在任何使用 <code>domain.blog.Blog</code> 的地方。<p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>typeAliases</span>></span></span><br><span class=line>  <span class=tag><<span class=name>package</span> <span class=attr>name</span>=<span class=string>"domain.blog"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>typeAliases</span>></span></span><br></pre></table></figure><p>每一个在包 <code>domain.blog</code> 中的 Java Bean,<strong>在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名</strong>。 比如 <code>domain.blog.Author</code> 的别名为 <code>author</code>；若有注解，则别名为其注解值。见下面的例子：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Alias("author")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>Author</span> </span>{</span><br><span class=line>    ...</span><br><span class=line>}</span><br></pre></table></figure><h3 id=typehandlers><a class=headerlink href=#typehandlers title=typehandlers></a>typehandlers</h3><p>MyBatis 在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。<h3 id=插件（plugins）><a class=headerlink href=#插件（plugins） title=插件（plugins）></a>插件（plugins）</h3><p>MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：<ul><li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)<li>ParameterHandler (getParameterObject, setParameters)<li>ResultSetHandler (handleResultSets, handleOutputParameters)<li>StatementHandler (prepare, parameterize, batch, update, query)</ul><p>这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 发行包中的源代码。 如果你想做的不仅仅是监控方法的调用，那么你最好相当了解要重写的方法的行为。 因为在试图修改或重写已有方法的行为时，很可能会破坏 MyBatis 的核心模块。 这些都是更底层的类和方法，所以使用插件的时候要特别当心。<p>通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。<figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=comment>// ExamplePlugin.java</span></span><br><span class=line><span class=meta>@Intercepts</span>({<span class=meta>@Signature</span>(</span><br><span class=line>  <span class=keyword>type</span>= Executor.class,</span><br><span class=line>  method = <span class=string>"update"</span>,</span><br><span class=line>  args = {MappedStatement.class,<span class=built_in>Object</span>.class})})</span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ExamplePlugin</span> <span class=title>implements</span> <span class=title>Interceptor</span> </span>{</span><br><span class=line>  <span class=keyword>private</span> Properties properties = <span class=keyword>new</span> Properties();</span><br><span class=line>  <span class=keyword>public</span> <span class=built_in>Object</span> intercept(Invocation invocation) throws Throwable {</span><br><span class=line>    <span class=comment>// implement pre processing if need</span></span><br><span class=line>    <span class=built_in>Object</span> returnObject = invocation.proceed();</span><br><span class=line>    <span class=comment>// implement post processing if need</span></span><br><span class=line>    <span class=keyword>return</span> returnObject;</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>public</span> <span class=built_in>void</span> <span class=function><span class=title>setProperties</span>(<span class=params>Properties properties</span>)</span> {</span><br><span class=line>    <span class=built_in>this</span>.properties = properties;</span><br><span class=line>  }</span><br><span class=line>}</span><br><span class=line>&LT!-- mybatis-config.xml --></span><br><span class=line><span class=xml><span class=tag><<span class=name>plugins</span>></span></span></span><br><span class=line><span class=xml>  <span class=tag><<span class=name>plugin</span> <span class=attr>interceptor</span>=<span class=string>"org.mybatis.example.ExamplePlugin"</span>></span></span></span><br><span class=line><span class=xml>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"someProperty"</span> <span class=attr>value</span>=<span class=string>"100"</span>/></span></span></span><br><span class=line><span class=xml>  <span class=tag>&LT/<span class=name>plugin</span>></span></span></span><br><span class=line><span class=xml><span class=tag>&LT/<span class=name>plugins</span>></span></span></span><br></pre></table></figure><p>上面的插件将会拦截在 Executor 实例中所有的 “update” 方法调用， 这里的 Executor 是负责执行底层映射语句的内部对象。<h3 id=xml映射器><a class=headerlink href=#xml映射器 title=xml映射器></a>xml映射器</h3><p>MyBatis 的真正强大在于它的语句映射，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 致力于减少使用成本，让用户能更专注于 SQL 代码。<p>SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：<ul><li><code>cache</code> – 该命名空间的缓存配置。<li><code>cache-ref</code> – 引用其它命名空间的缓存配置。<li><code>resultMap</code> – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。<li><del><code>parameterMap</code> – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。文档中不会介绍此元素。</del><li><code>sql</code> – 可被其它语句引用的可重用语句块。<li><code>insert</code> – 映射插入语句。<li><code>update</code> – 映射更新语句。<li><code>delete</code> – 映射删除语句。<li><code>select</code> – 映射查询语句。</ul><p>常用属性<div class=table-container><table><thead><tr><th>属性<th>描述<tbody><tr><td><code>id</code><td>在命名空间中唯一的标识符，可以被用来引用这条语句。<tr><td><code>parameterType</code><td>将会传入这条语句的参数的类全限定名或别名。<strong>这个属性是可选的，因为 MyBatis 可以根据语句中实际传入的参数计算出应该使用的类型处理器</strong>（TypeHandler），默认值为未设置（unset）。<tr><td><del>parameterMap</del><td><del>用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。</del><tr><td><code>resultType</code><td>期望从这条语句中返回结果的类全限定名或别名。 注意，<strong>如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型</strong>。 resultType 和 resultMap 之间只能同时使用一个。<tr><td><code>resultMap</code><td><strong>对外部 resultMap 的命名引用</strong>。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。</table></div><p>特殊字符处理,转义或CDATA区<p>参数占位符:#{} ${}<h3 id=参数映射><a class=headerlink href=#参数映射 title=参数映射></a>参数映射</h3><p>​ 鉴于参数类型（parameterType）会被自动设置为 <code>int</code>，这个参数可以随意命名。原始类型或简单数据类型（比如 <code>Integer</code> 和 <code>String</code>）因为没有其它属性，会用它们的值来作为参数。<p><img alt=image-20250310172440304 data-src=https://s2.loli.net/2025/03/10/u1fMijOcWHJGRTF.png><p><img alt=image-20250310182221930 data-src=https://s2.loli.net/2025/03/10/ckaRKM5JnPW9FEB.png><p><strong>不需要使用 <code>@Param</code> 的情况</strong><ol><li><p><strong>单个参数</strong>：如果你的 Mapper 方法只接受一个参数，那么你不需要使用 <code>@Param</code> 注解。MyBatis 会自动将这个参数映射到 SQL 语句中的占位符。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function>List&LTUser> <span class=title>selectUserByUserName</span><span class=params>(String username)</span></span>;</span><br></pre></table></figure> <p>在对应的 XML 映射文件中可以直接引用该参数：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectUserByUserName"</span> <span class=attr>resultType</span>=<span class=string>"User"</span>></span></span><br><span class=line>    SELECT * FROM users WHERE username = #{username}</span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><li><p><strong>Java Bean 参数</strong>：如果你直接传递一个 Java Bean 对象作为参数，MyBatis 可以通过 OGNL 表达式访问 Bean 的属性，因此也不需要使用 <code>@Param</code>。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function>List&LTUser> <span class=title>selectUserByCondition</span><span class=params>(User user)</span></span>;</span><br></pre></table></figure> <p>在 XML 文件中可以通过点符号访问属性：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectUserByCondition"</span> <span class=attr>resultType</span>=<span class=string>"User"</span>></span></span><br><span class=line>    SELECT * FROM users WHERE username = #{username} AND age = #{age}</span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure></ol><p><strong>需要使用 <code>@Param</code> 的情况</strong><ol><li><p><strong>多个简单类型参数</strong>：如果 Mapper 方法接受多个简单类型的参数（如 <code>int</code>, <code>String</code> 等），你需要使用 <code>@Param</code> 来为每个参数指定一个名称，以便在 SQL 语句中引用它们。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function>List&LTUser> <span class=title>selectUsersByAgeAndUsername</span><span class=params>(<span class=meta>@Param("age")</span> <span class=keyword>int</span> age, <span class=meta>@Param("username")</span> String username)</span></span>;</span><br></pre></table></figure> <p>在 XML 文件中可以这样引用这些参数：</p> <figure class="highlight n1ql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><<span class=keyword>select</span> id=<span class=string>"selectUsersByAgeAndUsername"</span> resultType=<span class=string>"User"</span>></span><br><span class=line>    <span class=keyword>SELECT</span> * <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> age = #{age} <span class=keyword>AND</span> username = #{username}</span><br><span class=line>&LT/<span class=keyword>select</span>></span><br></pre></table></figure><li><p><strong>为了提高代码可读性</strong>：即使只有一个参数，有时候为了增加代码的可读性和明确性，也可以选择使用 <code>@Param</code> 注解来命名参数。</p><li><p><strong>Map 类型参数</strong>：当使用 Map 传递参数时，通常也需要指定键名来访问值。在这种情况下，虽然不强制要求使用 <code>@Param</code>，但你可以通过 Map 的键来访问值。</p> <figure class="highlight coffeescript"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>List&LTUser> selectUsersByConditions(<span class=built_in>Map</span><<span class=built_in>String</span>, <span class=built_in>Object</span>> params);</span><br></pre></table></figure> <figure class="highlight n1ql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><<span class=keyword>select</span> id=<span class=string>"selectUsersByConditions"</span> resultType=<span class=string>"User"</span>></span><br><span class=line>    <span class=keyword>SELECT</span> * <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> age = #{age} <span class=keyword>AND</span> username = #{username}</span><br><span class=line>&LT/<span class=keyword>select</span>></span><br></pre></table></figure></ol><p><strong>总结</strong><ul><li>如果是单个参数或者传递的是 Java Bean，则通常不需要使用 <code>@Param</code>。<li>当方法有多个简单类型参数时，必须使用 <code>@Param</code> 来为每个参数指定名称，以便在 SQL 语句中引用。<li>使用 <code>@Param</code> 还有助于提高代码的可读性和维护性，尤其是在参数较多或逻辑较为复杂的情况下。</ul><blockquote><p>Java Bean 是一种符合特定规范的 Java 类，主要用于封装数据。它是 Java 中的一种标准，旨在使对象更容易被复用和管理，尤其是在可视化开发工具中。一个典型的 Java Bean 通常具有以下特征：<p><strong>特征</strong><ol><li><strong>私有属性</strong>：类中的成员变量应该是私有的（<code>private</code>），这意味着它们不能直接从类外部访问。<li><strong>无参构造器</strong>：必须提供一个公共的无参构造函数（默认构造器），以便能够实例化对象而不需要传递任何参数。这是为了确保可以通过反射机制创建对象实例，比如在框架内部（如Spring, MyBatis）。<li><strong>getter 和 setter 方法</strong>：对于每个私有属性，应该提供公共的 getter（获取值）和 setter（设置值）方法。这允许外部代码安全地访问和修改这些属性的值。<li><strong>可序列化</strong>（可选）：如果需要在网络上传输对象或者保存到文件中，那么这个类应该实现 <code>Serializable</code> 接口。</ol></blockquote><p><img alt=image-20250310110128114 data-src=https://s2.loli.net/2025/03/10/odIl2cm87SBxpk3.png><h3 id=结果映射><a class=headerlink href=#结果映射 title=结果映射></a>结果映射</h3><p>返回结果如果包含多个值,可以使用map.<p>如果使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为领域模型。MyBatis 对两者都提供了支持。看看下面这个 JavaBean：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.someapp.model;</span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>User</span> </span>{</span><br><span class=line>  <span class=keyword>private</span> <span class=keyword>int</span> id;</span><br><span class=line>  <span class=keyword>private</span> String username;</span><br><span class=line>  <span class=keyword>private</span> String hashedPassword;</span><br><span class=line></span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=keyword>int</span> <span class=title>getId</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>return</span> id;</span><br><span class=line>  }</span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>setId</span><span class=params>(<span class=keyword>int</span> id)</span> </span>{</span><br><span class=line>    <span class=keyword>this</span>.id = id;</span><br><span class=line>  }</span><br><span class=line>  <span class=function><span class=keyword>public</span> String <span class=title>getUsername</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>return</span> username;</span><br><span class=line>  }</span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>setUsername</span><span class=params>(String username)</span> </span>{</span><br><span class=line>    <span class=keyword>this</span>.username = username;</span><br><span class=line>  }</span><br><span class=line>  <span class=function><span class=keyword>public</span> String <span class=title>getHashedPassword</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>return</span> hashedPassword;</span><br><span class=line>  }</span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>setHashedPassword</span><span class=params>(String hashedPassword)</span> </span>{</span><br><span class=line>    <span class=keyword>this</span>.hashedPassword = hashedPassword;</span><br><span class=line>  }</span><br><span class=line>}</span><br></pre></table></figure><p>基于 JavaBean 的规范，上面这个类有 3 个属性：id，username 和 hashedPassword。这些属性会对应到 select 语句中的列名。<p>这样的一个 JavaBean 可以被映射到 <code>ResultSet</code>，就像映射到 <code>HashMap</code> 一样简单。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectUsers"</span> <span class=attr>resultType</span>=<span class=string>"com.someapp.model.User"</span>></span></span><br><span class=line>  select id, username, hashedPassword</span><br><span class=line>  from some_table</span><br><span class=line>  where id = #{id}</span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><p>类型别名是你的好帮手。使用它们，你就可以不用输入类的全限定名了。比如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- mybatis-config.xml 中 --></span></span><br><span class=line><span class=tag><<span class=name>typeAlias</span> <span class=attr>type</span>=<span class=string>"com.someapp.model.User"</span> <span class=attr>alias</span>=<span class=string>"User"</span>/></span></span><br><span class=line></span><br><span class=line><span class=comment>&LT!-- SQL 映射 XML 中 --></span></span><br><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectUsers"</span> <span class=attr>resultType</span>=<span class=string>"User"</span>></span></span><br><span class=line>  select id, username, hashedPassword</span><br><span class=line>  from some_table</span><br><span class=line>  where id = #{id}</span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><p>在这些情况下，<strong>MyBatis 会在幕后自动创建一个 <code>ResultMap</code>，再根据属性名来映射列到 JavaBean 的属性上</strong>。如果列名和属性名不能匹配上，可以在 SELECT 语句中设置列别名（这是一个基本的 SQL 特性）来完成匹配。比如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectUsers"</span> <span class=attr>resultType</span>=<span class=string>"User"</span>></span></span><br><span class=line>  select</span><br><span class=line>    user_id             as "id",</span><br><span class=line>    user_name           as "userName",</span><br><span class=line>    hashed_password     as "hashedPassword"</span><br><span class=line>  from some_table</span><br><span class=line>  where id = #{id}</span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><p>在学习了上面的知识后，你会发现上面的例子没有一个需要显式配置 <code>ResultMap</code>，这就是 <code>ResultMap</code> 的优秀之处——你完全可以不用显式地配置它们。 虽然上面的例子不用显式配置 <code>ResultMap</code>。 但为了讲解，我们来看看如果在刚刚的示例中，显式使用外部的 <code>resultMap</code> 会怎样，这也是解决列名不匹配的另外一种方式。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>resultMap</span> <span class=attr>id</span>=<span class=string>"userResultMap"</span> <span class=attr>type</span>=<span class=string>"User"</span>></span></span><br><span class=line>  <span class=tag><<span class=name>id</span> <span class=attr>property</span>=<span class=string>"id"</span> <span class=attr>column</span>=<span class=string>"user_id"</span> /></span></span><br><span class=line>  <span class=tag><<span class=name>result</span> <span class=attr>property</span>=<span class=string>"username"</span> <span class=attr>column</span>=<span class=string>"user_name"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>result</span> <span class=attr>property</span>=<span class=string>"password"</span> <span class=attr>column</span>=<span class=string>"hashed_password"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>resultMap</span>></span></span><br></pre></table></figure><p>然后在引用它的语句中设置 <code>resultMap</code> 属性就行了（注意我们去掉了 <code>resultType</code> 属性）。比如:<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectUsers"</span> <span class=attr>resultMap</span>=<span class=string>"userResultMap"</span>></span></span><br><span class=line>  select user_id, user_name, hashed_password</span><br><span class=line>  from some_table</span><br><span class=line>  where id = #{id}</span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><p>sql元素可以用来定义可重用的 SQL 代码片段，以便在其它语句中使用。 参数可以静态地（在加载的时候）确定下来，并且可以在不同的 include 元素中定义不同的参数值。比如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>sql</span> <span class=attr>id</span>=<span class=string>"userColumns"</span>></span> ${alias}.id,${alias}.username,${alias}.password <span class=tag>&LT/<span class=name>sql</span>></span></span><br></pre></table></figure><p>这个 SQL 片段可以在其它语句中使用，例如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectUsers"</span> <span class=attr>resultType</span>=<span class=string>"map"</span>></span></span><br><span class=line>  select</span><br><span class=line>    <span class=tag><<span class=name>include</span> <span class=attr>refid</span>=<span class=string>"userColumns"</span>></span><span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"alias"</span> <span class=attr>value</span>=<span class=string>"t1"</span>/></span><span class=tag>&LT/<span class=name>include</span>></span>,</span><br><span class=line>    <span class=tag><<span class=name>include</span> <span class=attr>refid</span>=<span class=string>"userColumns"</span>></span><span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"alias"</span> <span class=attr>value</span>=<span class=string>"t2"</span>/></span><span class=tag>&LT/<span class=name>include</span>></span></span><br><span class=line>  from some_table t1</span><br><span class=line>    cross join some_table t2</span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><p>也可以在 include 元素的 refid 属性或内部语句中使用属性值，例如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>sql</span> <span class=attr>id</span>=<span class=string>"sometable"</span>></span></span><br><span class=line>  ${prefix}Table</span><br><span class=line><span class=tag>&LT/<span class=name>sql</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>sql</span> <span class=attr>id</span>=<span class=string>"someinclude"</span>></span></span><br><span class=line>  from</span><br><span class=line>    <span class=tag><<span class=name>include</span> <span class=attr>refid</span>=<span class=string>"${include_target}"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>sql</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"select"</span> <span class=attr>resultType</span>=<span class=string>"map"</span>></span></span><br><span class=line>  select</span><br><span class=line>    field1, field2, field3</span><br><span class=line>  <span class=tag><<span class=name>include</span> <span class=attr>refid</span>=<span class=string>"someinclude"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"prefix"</span> <span class=attr>value</span>=<span class=string>"Some"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"include_target"</span> <span class=attr>value</span>=<span class=string>"sometable"</span>/></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>include</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><p>在INSERT和UPDATE时,可以获取自增的字段值.设置useGeneratedKeys和<code>keyProperty</code><div class=table-container><table><thead><tr><th>属性<th>描述<tbody><tr><td><code>useGeneratedKeys</code><td>（仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。<tr><td><code>keyProperty</code><td>（仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（<code>unset</code>）。如果生成列不止一个，可以用逗号分隔多个属性名称。</table></div><ul><li><strong><code>&LTinsert></code></strong>：用于插入新记录，返回受影响的行数或通过配置获取自增主键。<li><strong><code>&LTupdate></code></strong>：用于更新现有记录，返回受影响的行数。<li><strong><code>&LTdelete></code></strong>：用于删除记录，返回受影响的行数。</ul><h3 id=动态SQL><a class=headerlink href=#动态SQL title=动态SQL></a>动态SQL</h3><ul><li>if<li>choose (when, otherwise)<li>trim (where, set)<li>foreach</ul><p><img alt=image-20250310114956563 data-src=https://s2.loli.net/2025/03/10/NjzLtSgZ9UKIQWC.png><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"findActiveBlogLike"</span></span></span><br><span class=line><span class=tag>     <span class=attr>resultType</span>=<span class=string>"Blog"</span>></span></span><br><span class=line>  SELECT * FROM BLOG</span><br><span class=line>  <span class=tag><<span class=name>where</span>></span></span><br><span class=line>    <span class=tag><<span class=name>if</span> <span class=attr>test</span>=<span class=string>"state != null"</span>></span></span><br><span class=line>         state = #{state}</span><br><span class=line>    <span class=tag>&LT/<span class=name>if</span>></span></span><br><span class=line>    <span class=tag><<span class=name>if</span> <span class=attr>test</span>=<span class=string>"title != null"</span>></span></span><br><span class=line>        AND title like #{title}</span><br><span class=line>    <span class=tag>&LT/<span class=name>if</span>></span></span><br><span class=line>    <span class=tag><<span class=name>if</span> <span class=attr>test</span>=<span class=string>"author != null and author.name != null"</span>></span></span><br><span class=line>        AND author_name like #{author.name}</span><br><span class=line>    <span class=tag>&LT/<span class=name>if</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>where</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><p>where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。<p>用于动态更新语句的类似解决方案叫做 <em>set</em>。<em>set</em> 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>update</span> <span class=attr>id</span>=<span class=string>"updateAuthorIfNecessary"</span>></span></span><br><span class=line>  update Author</span><br><span class=line>    <span class=tag><<span class=name>set</span>></span></span><br><span class=line>      <span class=tag><<span class=name>if</span> <span class=attr>test</span>=<span class=string>"username != null"</span>></span>username=#{username},<span class=tag>&LT/<span class=name>if</span>></span></span><br><span class=line>      <span class=tag><<span class=name>if</span> <span class=attr>test</span>=<span class=string>"password != null"</span>></span>password=#{password},<span class=tag>&LT/<span class=name>if</span>></span></span><br><span class=line>      <span class=tag><<span class=name>if</span> <span class=attr>test</span>=<span class=string>"email != null"</span>></span>email=#{email},<span class=tag>&LT/<span class=name>if</span>></span></span><br><span class=line>      <span class=tag><<span class=name>if</span> <span class=attr>test</span>=<span class=string>"bio != null"</span>></span>bio=#{bio}<span class=tag>&LT/<span class=name>if</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>set</span>></span></span><br><span class=line>  where id=#{id}</span><br><span class=line><span class=tag>&LT/<span class=name>update</span>></span></span><br></pre></table></figure><p>这个例子中，<em>set</em> 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。<p>或者，你可以通过使用<em>trim</em>元素来达到同样的效果：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>trim</span> <span class=attr>prefix</span>=<span class=string>"SET"</span> <span class=attr>suffixOverrides</span>=<span class=string>","</span>></span></span><br><span class=line>  ...</span><br><span class=line><span class=tag>&LT/<span class=name>trim</span>></span></span><br></pre></table></figure><p>注意，我们覆盖了后缀值设置，并且自定义了前缀值<blockquote><p>可以使用mybatisx插件提升开发效率</blockquote><p><strong>相关视频</strong><ol><li><a href=https://www.bilibili.com/video/BV1MT4y1k7wZ/ rel=noopener target=_blank>黑马mybatis教程全套视频教程，2天Mybatis框架从入门到精通_哔哩哔哩_bilibili</a><li><a href=https://www.bilibili.com/video/BV1G5411H7F8 rel=noopener target=_blank>快速上手mybatis</a><li><a href=https://www.bilibili.com/video/BV1VP4y1c7j7 rel=noopener target=_blank>MyBatis零基础入门教程</a></ol><h3 id=mybatis-plus><a class=headerlink href=#mybatis-plus title=mybatis-plus></a>mybatis-plus</h3><p>MyBatis-Plus 是一个 MyBatis 的增强工具，旨在简化开发、减少工作量。它不仅<strong>封装了 CRUD 操作，还提供了代码生成器、分页插件</strong>等实用功能。<p>MyBatis-Plus 提供了 <code>QueryWrapper</code> 和 <code>UpdateWrapper</code> 两个主要的条件构造器，用于进行复杂查询和更新操作。<p><strong>QueryWrapper</strong><p><code>QueryWrapper</code> 用于查询条件的构造，支持链式调用。<ul><li><strong>等值查询</strong>：<code>eq("name", "Tom")</code><li><strong>范围查询</strong>：<code>between("age", 18, 30)</code><li><strong>模糊查询</strong>：<code>like("name", "Tom")</code><li><strong>排序</strong>：<code>orderByAsc("age")</code>，<code>orderByDesc("age")</code><li><strong>分组查询</strong>：<code>groupBy("age")</code><li><strong>限制查询数量</strong>：<code>last("limit 10")</code></ul><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>javaCopyEditQueryWrapper&LTUser> queryWrapper = <span class=keyword>new</span> QueryWrapper<>();</span><br><span class=line>queryWrapper.eq(<span class=string>"name"</span>, <span class=string>"Tom"</span>).gt(<span class=string>"age"</span>, <span class=number>18</span>);</span><br><span class=line>List&LTUser> users = userService.list(queryWrapper);</span><br></pre></table></figure><p><strong>UpdateWrapper</strong><p><code>UpdateWrapper</code> 用于更新操作，支持条件和修改字段。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>javaCopyEditUpdateWrapper&LTUser> updateWrapper = <span class=keyword>new</span> UpdateWrapper<>();</span><br><span class=line>updateWrapper.eq(<span class=string>"name"</span>, <span class=string>"Tom"</span>).set(<span class=string>"age"</span>, <span class=number>30</span>);</span><br><span class=line>userService.update(<span class=keyword>null</span>, updateWrapper);</span><br></pre></table></figure><p><strong>分页操作</strong><p><strong>分页查询</strong><p>MyBatis-Plus 提供了 <code>Page</code> 类用于分页查询。<ul><li><p><strong><code>page(Page&LTT> page)</code></strong>: 分页查询</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>javaCopyEditPage&LTUser> page = <span class=keyword>new</span> Page<>(<span class=number>1</span>, <span class=number>10</span>);  <span class=comment>// 页码和每页条数</span></span><br><span class=line>Page&LTUser> userPage = userService.page(page);</span><br></pre></table></figure><li><p><strong><code>page(Page&LTT> page, QueryWrapper&LTT> queryWrapper)</code></strong>: 带条件的分页查询</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>javaCopyEditQueryWrapper&LTUser> queryWrapper = <span class=keyword>new</span> QueryWrapper<>();</span><br><span class=line>queryWrapper.eq(<span class=string>"age"</span>, <span class=number>25</span>);</span><br><span class=line>Page&LTUser> userPage = userService.page(page, queryWrapper);</span><br></pre></table></figure></ul><p>链式调用是一种非常方便的查询方式，它允许开发者通过流式 API 构建复杂的查询条件<div class=table-container><table><thead><tr><th>类型<th>示例方法<th>功能描述<tbody><tr><td><strong>查询</strong><td><code>query()</code>, <code>lambdaQuery()</code><td>构建查询条件并获取结果<tr><td><strong>更新</strong><td><code>update()</code>, <code>lambdaUpdate()</code><td>构建更新条件并执行更新<tr><td><strong>删除</strong><td><code>remove()</code>, <code>lambdaRemove()</code><td>构建删除条件并执行删除<tr><td><strong>条件组合</strong><td><code>and()</code>, <code>or()</code>, <code>nested()</code><td>支持复杂条件组合<tr><td><strong>排序与分组</strong><td><code>orderByAsc()</code>, <code>orderByDesc()</code>, <code>groupBy()</code><td>支持排序、分组等操作</table></div><h2 id=Hibernate><a class=headerlink href=#Hibernate title=Hibernate></a>Hibernate</h2><p><a href=https://www.geeksforgeeks.org/hibernate-native-sql/?ref=next_article_top rel=noopener target=_blank>Hibernate - Native SQL - GeeksforGeeks</a><p><a href=https://docs.jboss.org/hibernate/orm/6.5/quickstart/html_single/#hibernate-gsg-tutorial-annotations-entity rel=noopener target=_blank>Getting Started with Hibernate</a><p><strong>maven依赖</strong><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>org.hibernate.orm<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>hibernate-core<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>6.6.10.Final<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><p><strong>配置</strong><p>配置文件hibernate.properties<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=comment># Database connection settings</span></span><br><span class=line><span class=meta>hibernate.connection.url</span>=<span class=string>jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1</span></span><br><span class=line><span class=meta>hibernate.connection.username</span>=<span class=string>sa</span></span><br><span class=line><span class=meta>hibernate.connection.password</span>=<span class=string></span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment># Echo all executed SQL to console</span></span><br><span class=line><span class=meta>hibernate.show_sql</span>=<span class=string>true</span></span><br><span class=line><span class=meta>hibernate.format_sql</span>=<span class=string>true</span></span><br><span class=line><span class=meta>hibernate.highlight_sql</span>=<span class=string>true</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment># Automatically export the schema</span></span><br><span class=line><span class=meta>hibernate.hbm2ddl.auto</span>=<span class=string>create</span></span><br></pre></table></figure><p><strong>创建注解实体类</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Entity</span>   </span><br><span class=line><span class=meta>@Table(name = "Events")</span>   </span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>Event</span> </span>{</span><br><span class=line>   <span class=meta>@Id</span>   </span><br><span class=line><span class=meta>@GeneratedValue</span>   </span><br><span class=line><span class=keyword>private</span> Long id;</span><br><span class=line>    <span class=meta>@Column(name = "eventDate")</span>   </span><br><span class=line><span class=keyword>private</span> LocalDateTime date;</span><br><span class=line>    <span class=comment>//实体其他字段默认被认为是持久的。</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>使用sessionFactory</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>protected</span> <span class=keyword>void</span> <span class=title>setUp</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=comment>// A SessionFactory is set up once for an application!</span></span><br><span class=line>    <span class=keyword>final</span> StandardServiceRegistry registry =</span><br><span class=line>            <span class=keyword>new</span> StandardServiceRegistryBuilder()</span><br><span class=line>                    .build();     </span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>        sessionFactory =</span><br><span class=line>                <span class=keyword>new</span> MetadataSources(registry)             </span><br><span class=line>                        .addAnnotatedClass(Event.class)   </span><br><span class=line>                        .buildMetadata()                  </span><br><span class=line>                        .buildSessionFactory();           </span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>catch</span> (Exception e) {</span><br><span class=line>        <span class=comment>// The registry would be destroyed by the SessionFactory, but we</span></span><br><span class=line>        <span class=comment>// had trouble building the SessionFactory so destroy it manually.</span></span><br><span class=line>        StandardServiceRegistryBuilder.destroy(registry);</span><br><span class=line>    }</span><br><span class=line>    sessionFactory.inTransaction(session -> {   </span><br><span class=line>    session.persist(<span class=keyword>new</span> Event(<span class=string>"Our very first event!"</span>, now()));   </span><br><span class=line>    session.persist(<span class=keyword>new</span> Event(<span class=string>"A follow up event"</span>, now()));</span><br><span class=line>});</span><br><span class=line>    sessionFactory.inTransaction(session -> {</span><br><span class=line>    session.createSelectionQuery(<span class=string>"from Event"</span>, Event.class)   </span><br><span class=line>            .getResultList()   </span><br><span class=line>            .forEach(event -> out.println(<span class=string>"Event ("</span> + event.getDate() + <span class=string>") : "</span> + event.getTitle()));</span><br><span class=line>});</span><br><span class=line>}</span><br></pre></table></figure><p>上面是native hibernate APIs<p>此外还可以使用JPA标准APIs<blockquote><p>5.x版本的hibernate使用cfg和hbm提供映射,但新版本已经不用了.</blockquote><p>><blockquote><p>JPA全称为Java Persistence API（Java持久层API），它是Sun公司在JavaEE 5中提出的Java持久化规范。它为Java开发人员提供了一种对象/关联映射工具，来管理Java应用中的关系数据，JPA吸取了目前Java持久化技术的优点，旨在规范、简化Java对象的持久化工作。很多ORM框架都是实现了JPA的规范，如：Hibernate、EclipseLink。<p>需要注意的是JPA统一了Java应用程序访问ORM框架的规范<p><strong>JPA为我们提供了以下规范：</strong><ol><li>ORM映射元数据：JPA支持XML和注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中<li>JPA 的API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发人员不用再写SQL了<li>JPQL查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。</ol></blockquote><h2 id=Spring-Data-JPA><a title="Spring Data JPA" class=headerlink href=#Spring-Data-JPA></a>Spring Data JPA</h2><blockquote><p>Spring Data是Spring 社区的一个子项目，主要用于简化数据（关系型&非关系型）访问，其主要目标是使得数据库的访问变得方便快捷。<p>Spring Data JPA是在实现了JPA规范的基础上封装的一套 JPA 应用框架，虽然ORM框架都实现了JPA规范，但是在不同的ORM框架之间切换仍然需要编写不同的代码，而使用Spring Data JPA能够方便大家在不同的ORM框架之间进行切换而不需要更改代码。</blockquote><p><a href=https://docs.spring.io/spring-data/jpa/reference/repositories/core-concepts.html rel=noopener target=_blank>Core concepts :: Spring Data JPA</a><p>Spring Data JPA往往搭配Spring以及SpringBoot使用.<p><strong>使用注解创建POJO类</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Entity</span></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Person</span> </span>{</span><br><span class=line></span><br><span class=line>  <span class=meta>@Id</span> <span class=meta>@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class=line>  <span class=keyword>private</span> Long id;</span><br><span class=line>  <span class=keyword>private</span> String name;</span><br><span class=line></span><br><span class=line>  <span class=comment>// getters and setters omitted for brevity</span></span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><p><strong>声明仓库接口</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>interface</span> <span class=title>PersonRepository</span> <span class=keyword>extends</span> <span class=title>Repository</span><<span class=title>Person</span>, <span class=title>Long</span>> </span>{</span><br><span class=line></span><br><span class=line>  <span class=function>Person <span class=title>save</span><span class=params>(Person person)</span></span>;</span><br><span class=line></span><br><span class=line>  <span class=function>Optional&LTPerson> <span class=title>findById</span><span class=params>(<span class=keyword>long</span> id)</span></span>;</span><br><span class=line>}</span><br></pre></table></figure><p><strong>使用仓库</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Service;</span><br><span class=line></span><br><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserService</span> </span>{</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> UserRepository userRepository;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>addUser</span><span class=params>(String name)</span> </span>{</span><br><span class=line>        User user = <span class=keyword>new</span> User();</span><br><span class=line>        user.setName(name);</span><br><span class=line>        userRepository.save(user);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>增加自定义的CRUD方法</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>interface</span> <span class=title>UserRepository</span> <span class=keyword>extends</span> <span class=title>CrudRepository</span><<span class=title>User</span>, <span class=title>Long</span>> </span>{</span><br><span class=line>    <span class=function>List&LTUser> <span class=title>findByName</span><span class=params>(String name)</span></span>; <span class=comment>// 根据名字查找用户</span></span><br><span class=line>}</span><br></pre></table></figure><p>按照相关规范生成相应JPQL查询.<p>基本原则<ol><li><strong>实体属性作为基础</strong>：查询方法通常基于实体类中的属性名称构建。例如，如果你有一个 <code>User</code> 实体，并且这个实体有一个 <code>name</code> 属性，你可以创建一个以 <code>findByName</code> 开头的方法来查找具有特定名称的所有用户。<li><strong>关键词用于指定操作</strong>：在方法名中使用特定的关键字可以指定你想要执行的操作类型（如查找、计数等）以及查询条件（如等于、包含等）。</ol><p>对于更复杂的查询需求，如果方法名约定不能满足要求，可以使用 <code>@Query</code> 注解直接定义JPQL或原生SQL查询。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>interface</span> <span class=title>UserRepository</span> <span class=keyword>extends</span> <span class=title>JpaRepository</span><<span class=title>User</span>, <span class=title>Long</span>> </span>{</span><br><span class=line>    <span class=meta>@Query("select u from User u where u.emailAddress = ?1")</span></span><br><span class=line>    <span class=function>User <span class=title>findByEmailAddress</span><span class=params>(String emailAddress)</span></span>;</span><br><span class=line>}</span><br></pre></table></figure><p>或者使用原生SQL：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=meta>@Query(value = "SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?1", nativeQuery = true)</span></span><br><span class=line><span class=function>User <span class=title>findByEmailAddress</span><span class=params>(String emailAddress)</span></span>;</span><br></pre></table></figure><h1 id=消息组件><a class=headerlink href=#消息组件 title=消息组件></a>消息组件</h1><h2 id=Redis✨><a class=headerlink href=#Redis✨ title=Redis✨></a>Redis✨</h2><h3 id=基本操作><a class=headerlink href=#基本操作 title=基本操作></a>基本操作</h3><p><strong>Redis 的主要特性</strong><ul><li><strong>高性能</strong>：所有数据都存储在内存中，读写速度非常快。<li><strong>持久化</strong>：支持 RDB 和 AOF 两种方式将内存中的数据保存到硬盘上，以防止数据丢失。<li><strong>复制功能</strong>：支持主从复制，可以提高系统的可用性和扩展性。<li><strong>事务支持</strong>：通过 MULTI, EXEC, DISCARD 和 WATCH 等命令实现简单的事务管理。<li><strong>发布订阅模式</strong>：支持 Pub/Sub 消息传递模式。<li><strong>Lua 脚本支持</strong>：允许用户执行自定义逻辑，保证原子性。<li><strong>键过期时间</strong>：可以为每个键设置生存时间，过期后自动删除。</ul><h3 id=数据类型><a class=headerlink href=#数据类型 title=数据类型></a>数据类型</h3><p>Redis 主要支持以下几种数据类型：<ul><li><strong>string（字符串）:</strong> 基本的数据存储单元，可以存储字符串、整数或者浮点数。<li><strong>hash（哈希）:</strong>一个键值对集合，可以存储多个字段。<li><strong>list（列表）:</strong>一个简单的列表，可以存储一系列的字符串元素。<li><strong>set（集合）:</strong>一个无序集合，可以存储不重复的字符串元素。<li><strong>zset(sorted set：有序集合):</strong> 类似于集合，但是每个元素都有一个分数（score）与之关联。<li><strong>位图（Bitmaps）：</strong>基于字符串类型，可以对每个位进行操作。<li><strong>超日志（HyperLogLogs）：</strong>用于基数统计，可以估算集合中的唯一元素数量。<li><strong>地理空间（Geospatial）：</strong>用于存储地理位置信息。<li><strong>发布/订阅（Pub/Sub）：</strong>一种消息通信模式，允许客户端订阅消息通道，并接收发布到该通道的消息。<li><strong>流（Streams）：</strong>用于消息队列和日志存储，支持消息的持久化和时间排序。<li><strong>模块（Modules）：</strong>Redis 支持动态加载模块，可以扩展 Redis 的功能。</ul><h4 id=String><a class=headerlink href=#String title=String></a>String</h4><p>基本编码方式是RAW,基于简单动态字符串实现. 存储上限512MB.<p>如果存储的SDS长度小于44字节,则会采用EMBSTR,此时object head与SDSS是连续空间.<p>如果是整数值,并且在LONG_MAX之内,采用INT编码.不需要SDS部分,ptr直接指向整数.<p><img alt=image-20250326102935636 data-src=https://s2.loli.net/2025/03/26/sjPGpMUlIBCfXrg.png><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>object encoding key <span class=comment># 查询编码方式</span></span><br></pre></table></figure><h4 id=List-1><a class=headerlink href=#List-1 title=List></a>List</h4><p>从首、尾操作元素的列表<p><img alt=image-20250326103337835 data-src=https://s2.loli.net/2025/03/26/ALHs6CkcYGnB8me.png><p><img alt=image-20250326104058671 data-src=https://s2.loli.net/2025/03/26/4JMB7i9FwZpSLVW.png><h4 id=Set-1><a class=headerlink href=#Set-1 title=Set></a>Set</h4><p>单列集合,不保证有序性,保证元素唯一,求交集、并集和差集.<p>set采用HT编码(Dict),key用来存储元素,value统一为null.<p>当存储的所有数据为整数,并且元素数量不超过set-max-intset-entries时,Set会采用IntSet编码,节省内存.<p><img alt=image-20250326105453513 data-src=https://s2.loli.net/2025/03/26/sKmpPezAdXafgn4.png><h4 id=ZSet><a class=headerlink href=#ZSet title=ZSet></a>ZSet</h4><p>每个元素指定一个score值<p><img alt=image-20250326111021533 data-src=https://s2.loli.net/2025/03/26/UhEFYszHKGQjTBt.png><p><img alt=image-20250326111516132 data-src=https://s2.loli.net/2025/03/26/8d5MsA1VqQovZXc.png><p><img alt=image-20250326112849287 data-src=https://s2.loli.net/2025/03/26/n8DoQbwTMVa5FZY.png><h4 id=Hash><a class=headerlink href=#Hash title=Hash></a>Hash</h4><p><img alt=image-20250326113333031 data-src=https://s2.loli.net/2025/03/26/4BPamIhnFEviQWy.png><p><img alt=image-20250326113448318 data-src=https://s2.loli.net/2025/03/26/D25tMOAiSJjCx1n.png><h3 id=缓存穿透><a class=headerlink href=#缓存穿透 title=缓存穿透></a>缓存穿透</h3><p>缓存穿透是指客户端请求的数据在缓冲中和数据库中都不存在,这样缓存永远不会起作用,这些请求直接访问数据库.<h4 id=缓存空对象><a class=headerlink href=#缓存空对象 title=缓存空对象></a>缓存空对象</h4><p>对于查询结果为空的数据，也可以将其缓存起来（通常设置较短的过期时间），这样当同样的请求再次到来时，可以直接从缓存中获取结果而不需要访问数据库。<p><img alt=image-20250325171102410 data-src=https://s2.loli.net/2025/03/25/Xij1Npoe8xrqcS3.png><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=comment>// 示例伪代码</span></span><br><span class=line><span class=function><span class=keyword>public</span> Object <span class=title>getData</span><span class=params>(String key)</span> </span>{</span><br><span class=line>    <span class=comment>// 尝试从缓存获取数据</span></span><br><span class=line>    Object value = cache.get(key);</span><br><span class=line>    <span class=keyword>if</span> (value != <span class=keyword>null</span>) {</span><br><span class=line>        <span class=keyword>return</span> value;</span><br><span class=line>    }</span><br><span class=line>    </span><br><span class=line>    <span class=comment>// 如果缓存未命中，则尝试从数据库获取</span></span><br><span class=line>    value = db.query(key);</span><br><span class=line>    <span class=keyword>if</span> (value == <span class=keyword>null</span>) {</span><br><span class=line>        <span class=comment>// 对于不存在的数据也进行缓存，但设置较短的过期时间</span></span><br><span class=line>        cache.put(key, <span class=string>"NULL"</span>, SHORT_EXPIRE_TIME);</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>        cache.put(key, value);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> value;</span><br><span class=line>}</span><br></pre></table></figure><p>优点:实现简单,维护方便<p>缺点:额外的内存消耗,可能造成短期的不一致<h4 id=布隆过滤><a class=headerlink href=#布隆过滤 title=布隆过滤></a>布隆过滤</h4><p>使用布隆过滤器可以在内存中高效地判断一个元素是否在一个集合中。它通过多个哈希函数将元素映射到位数组中的几个点，设置这些点为1。查询时，只要有一个对应的位不是1，就可以确定该元素不在集合中。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=comment>// 示例伪代码</span></span><br><span class=line>BloomFilter&LTString> bloomFilter = BloomFilter.create(Funnels.stringFunnel(), expectedInsertions);</span><br><span class=line></span><br><span class=line><span class=comment>// 加载所有可能存在的key到布隆过滤器中</span></span><br><span class=line><span class=keyword>for</span> (String key : allPossibleKeys) {</span><br><span class=line>    bloomFilter.put(key);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>boolean</span> <span class=title>mightContain</span><span class=params>(String key)</span> </span>{</span><br><span class=line>    <span class=keyword>return</span> bloomFilter.mightContain(key);</span><br><span class=line>}</span><br></pre></table></figure><p><img alt=image-20250325173115631 data-src=https://s2.loli.net/2025/03/25/axN3ZGnYCrV2dt1.png><p>在实际应用中，你可以在查询之前先用布隆过滤器检查是否存在该键，只有当布隆过滤器认为该键可能存在时，才去数据库查询并更新缓存。<ul><li><strong>优点</strong>：节省空间且查询速度快。<li><strong>缺点</strong>：有一定的误判率，即可能存在某些元素实际上不在集合中却被认为存在的假阳性情况，但对于缓存穿透问题来说，这通常是可接受的。</ul><p>其他方法<p><strong>接口限流与用户行为分析</strong><p><strong>合理的缓存策略设计</strong><p><img alt=image-20250325175340534 data-src=https://s2.loli.net/2025/03/25/Aaehzxr8njmpCbq.png><h3 id=缓存雪崩><a class=headerlink href=#缓存雪崩 title=缓存雪崩></a>缓存雪崩</h3><p>缓存雪崩是指在某个时间段内，<strong>大量的缓存数据同时过期失效，导致大量请求直接打到后端数据库或其他数据源上</strong>，造成服务器负载急剧增加，甚至可能导致系统崩溃的现象。这种情况通常发生在缓存层突然不可用或者缓存策略设计不合理时。<h4 id=解决方案><a class=headerlink href=#解决方案 title=解决方案></a>解决方案</h4><ol><li><strong>设置不同的缓存过期时间</strong></ol><p>随机化过期时间,为避免大量缓存同时过期，可以在设定缓存的有效期时加入一定的随机性。例如，原本所有缓存的有效期都是1小时，现在可以设置成1小时±5分钟，这样可以分散缓存失效的时间点。<ol><li><strong>双缓存机制</strong></ol><p>实现两个级别的缓存，一级缓存用于快速响应请求，二级缓存则在一级缓存失效时提供支持。当一级缓存中的数据过期后，仍然可以从二级缓存中获取数据，从而减轻对数据库的压力。<p><strong>其他</strong><p>利用Redis集群提高服务可用性<p>给缓存业务添加降级限流策略<h3 id=缓存击穿><a class=headerlink href=#缓存击穿 title=缓存击穿></a>缓存击穿</h3><p><strong>缓存击穿</strong>是指一个非常热门的key，在缓存失效的瞬间，大量的请求同时访问这个key，由于此时缓存中没有该数据（已经过期或被删除），这些请求会直接打到数据库上，导致数据库压力骤增。这种情况类似于“击穿”了缓存层，直接冲击后端存储。<h4 id=解决方案-1><a class=headerlink href=#解决方案-1 title=解决方案></a>解决方案</h4><p>1, 互斥锁<p>使用互斥锁可以在缓存失效时只允许一个线程去查询数据库并更新缓存，其他线程等待该线程完成后再从缓存中读取数据。这种方法能有效避免大量线程同时访问数据库。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>public</span> Object <span class=title>getData</span><span class=params>(String key)</span> </span>{</span><br><span class=line>    String lockKey = <span class=string>"lock:"</span> + key;</span><br><span class=line>    Object value = cache.get(key);</span><br><span class=line>    <span class=keyword>if</span> (value == <span class=keyword>null</span>) { <span class=comment>// 缓存未命中</span></span><br><span class=line>        <span class=keyword>synchronized</span>(lockKey.intern()) { <span class=comment>// 使用字符串内部池作为锁对象</span></span><br><span class=line>            value = cache.get(key); <span class=comment>// 再次检查缓存，防止其他线程已经填充了缓存</span></span><br><span class=line>            <span class=keyword>if</span> (value == <span class=keyword>null</span>) {</span><br><span class=line>                value = db.query(key); <span class=comment>// 查询数据库</span></span><br><span class=line>                cache.put(key, value); <span class=comment>// 更新缓存</span></span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> value;</span><br><span class=line>}</span><br></pre></table></figure><p><img alt=image-20250325205849705 data-src=https://s2.loli.net/2025/03/25/I2n1hxzA8XteQP5.png><p>利用<code>setnx</code>实现互斥逻辑.<figure class="highlight processing"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br></pre><td class=code><pre><span class=line><span class=keyword>String</span> solvePassthrough(<span class=keyword>String</span> <span class=built_in>key</span>) {</span><br><span class=line>    <span class=comment>// 1. 查询缓存是否存在</span></span><br><span class=line>    <span class=keyword>String</span> s = redisTemplate.opsForValue().<span class=built_in>get</span>(<span class=built_in>key</span>);</span><br><span class=line>    <span class=keyword>if</span>(s != <span class=keyword>null</span>) {</span><br><span class=line>        <span class=comment>//存在直接返回</span></span><br><span class=line>        <span class=keyword>return</span> s ;</span><br><span class=line>    }<span class=keyword>else</span>{</span><br><span class=line>        <span class=comment>// 不存在 s==null,表示不存在</span></span><br><span class=line>        <span class=comment>// 2. 缓存不存在，尝试拿锁</span></span><br><span class=line>        Boolean b = tryLock(<span class=built_in>key</span>);</span><br><span class=line>        <span class=keyword>if</span>(b) {</span><br><span class=line>            <span class=comment>//3. 拿到锁，查询数据库</span></span><br><span class=line>            <span class=comment>//"select * from table where key = " + key;</span></span><br><span class=line>            <span class=keyword>String</span> result = <span class=string>"result"</span>;</span><br><span class=line>            <span class=keyword>if</span>(result == <span class=keyword>null</span>) {</span><br><span class=line>                <span class=comment>// 数据库查询 没找到数据</span></span><br><span class=line>                <span class=comment>// 设置空缓存对象 避免缓存穿透</span></span><br><span class=line>                redisTemplate.opsForValue().<span class=built_in>set</span>(<span class=built_in>key</span>, <span class=string>""</span>, <span class=number>10</span>, TimeUnit.SECONDS);</span><br><span class=line>                unlock(<span class=built_in>key</span>);</span><br><span class=line>                <span class=keyword>return</span> <span class=keyword>null</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=comment>//4. 查询数据库后，将数据放入缓存</span></span><br><span class=line>            redisTemplate.opsForValue().<span class=built_in>set</span>(<span class=built_in>key</span>, result, <span class=number>10</span>, TimeUnit.SECONDS);</span><br><span class=line>            <span class=comment>//5. 释放锁</span></span><br><span class=line>            unlock(<span class=built_in>key</span>);</span><br><span class=line>            <span class=comment>// 返回结果</span></span><br><span class=line>            <span class=keyword>return</span> result;</span><br><span class=line>        }<span class=keyword>else</span>{</span><br><span class=line>            <span class=comment>//4. 没有拿到锁,等待重试</span></span><br><span class=line>            <span class=keyword>try</span> {</span><br><span class=line>                Thread.sleep(<span class=number>1000</span>);</span><br><span class=line>                <span class=keyword>return</span> solvePassthrough(<span class=built_in>key</span>);</span><br><span class=line>            } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>                <span class=keyword>throw</span> <span class=keyword>new</span> RuntimeException(e);</span><br><span class=line>            }<span class=keyword>finally</span> {</span><br><span class=line>                unlock(<span class=built_in>key</span>);</span><br><span class=line>            }</span><br><span class=line></span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line>Boolean tryLock(<span class=keyword>String</span> <span class=built_in>key</span>) {</span><br><span class=line>    Boolean b = redisTemplate.opsForValue().setIfAbsent(<span class=built_in>key</span>, <span class=string>"1"</span>, <span class=number>2</span>, TimeUnit.SECONDS);</span><br><span class=line>    <span class=keyword>return</span> b;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>void</span> unlock(<span class=keyword>String</span> <span class=built_in>key</span>) {</span><br><span class=line>    redisTemplate.delete(<span class=built_in>key</span>);</span><br><span class=line>}</span><br></pre></table></figure><p>2.逻辑过期<p>对于一些极其重要的热点数据，可以考虑将其缓存设置为永不过期。但是这种方式需要配合后台异步任务定期刷新缓存中的数据，以确保数据的时效性。<p><img alt=image-20250325205936982 data-src=https://s2.loli.net/2025/03/25/2FKGxVs6pUu5d3g.png><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=comment>// 假设我们有一个后台任务定期执行此方法</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>refreshHotData</span><span class=params>()</span> </span>{</span><br><span class=line>    String hotKey = <span class=string>"hot_data"</span>;</span><br><span class=line>    Object newValue = db.query(hotKey); <span class=comment>// 从数据库获取最新数据</span></span><br><span class=line>    cache.put(hotKey, newValue); <span class=comment>// 更新缓存</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 在业务逻辑中获取数据时，直接从缓存读取即可</span></span><br><span class=line><span class=function><span class=keyword>public</span> Object <span class=title>getHotData</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>return</span> cache.get(<span class=string>"hot_data"</span>);</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>可以增加过期时间,在业务层进行判断,如果实际已经过期(此时Redis中仍有数据,因为没有超过TTL). 则创建线程更新数据并写入缓存(加锁),原本线程返回过期数据.</blockquote><p><img alt=image-20250325182959630 data-src=https://s2.loli.net/2025/03/25/KnfBu1UqX9DrAEW.png><h3 id=内存持久化><a class=headerlink href=#内存持久化 title=内存持久化></a>内存持久化</h3><h4 id=RDB><a class=headerlink href=#RDB title=RDB></a>RDB</h4><p>Redis <strong>SAVE</strong> 命令用于创建当前数据库的备份<p>创建 redis 备份文件也可以使用命令 <strong>BGSAVE</strong>，该命令在后台执行。<p>basave会fork主进程得到子进程,子进程共享主进程的内存数据,完成fork后读取内存数据写入RDB文件.<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line>################################ SNAPSHOTTING </span><br><span class=line>#   Note: you can disable saving completely by commenting out all "save" lines.</span><br><span class=line>#</span><br><span class=line>#   It is also possible to remove all the previously configured save</span><br><span class=line>#   points by adding a save directive with a single empty string argument</span><br><span class=line>#   like in the following example:</span><br><span class=line>#</span><br><span class=line>#   save ""</span><br><span class=line></span><br><span class=line>save 900 1</span><br><span class=line>save 300 10</span><br><span class=line>save 60 10000</span><br><span class=line>rdbcompression yes</span><br><span class=line># The filename where to dump the DB</span><br><span class=line>dbfilename dump.rdb</span><br><span class=line># The working directory.</span><br><span class=line>#</span><br><span class=line># The DB will be written inside this directory, with the filename specified</span><br><span class=line># above using the 'dbfilename' configuration directive.</span><br><span class=line>#</span><br><span class=line># The Append Only File will also be created inside this directory.</span><br><span class=line>#</span><br><span class=line># Note that you must specify a directory here, not a file name.</span><br><span class=line>dir ./</span><br></pre></table></figure><p><img alt=image-20250325220031131 data-src=https://s2.loli.net/2025/03/25/UYWLnOzjM3FitKD.png><p><img alt=image-20250325220501005 data-src=https://s2.loli.net/2025/03/25/vSzoKf3ibdCDQw2.png><p><img alt=image-20250325220624058 data-src=https://s2.loli.net/2025/03/25/ObYogUBk1F5Xi3C.png><h4 id=AOF><a class=headerlink href=#AOF title=AOF></a>AOF</h4><p>APPEND ONLY MODE<figure class="highlight coffeescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=comment>######</span><span class=comment>######</span><span class=comment>######</span><span class=comment>######</span><span class=comment>######</span> APPEND ONLY MODE <span class=comment>######</span><span class=comment>######</span><span class=comment>######</span><span class=comment>######</span><span class=comment>######</span><span class=comment>#</span></span><br><span class=line><span class=comment># still running correctly.</span></span><br><span class=line><span class=comment>#</span></span><br><span class=line><span class=comment># AOF and RDB persistence can be enabled at the same time without problems.</span></span><br><span class=line><span class=comment># If the AOF is enabled on startup Redis will load the AOF, that is the file</span></span><br><span class=line><span class=comment># with the better durability guarantees.</span></span><br><span class=line><span class=comment>#</span></span><br><span class=line><span class=comment># Please check http://redis.io/topics/persistence for more information.</span></span><br><span class=line></span><br><span class=line>appendonly <span class=literal>no</span></span><br><span class=line></span><br><span class=line><span class=comment># The name of the append only file (default: "appendonly.aof")</span></span><br><span class=line></span><br><span class=line>appendfilename <span class=string>"appendonly.aof"</span></span><br><span class=line><span class=comment># The default is "everysec", as that's usually the right compromise between</span></span><br><span class=line><span class=comment># speed and data safety. It's up to you to understand if you can relax this to</span></span><br><span class=line><span class=comment># "no" that will let the operating system flush the output buffer when</span></span><br><span class=line><span class=comment># it wants, for better performances (but if you can live with the idea of</span></span><br><span class=line><span class=comment># some data loss consider the default persistence mode that's snapshotting),</span></span><br><span class=line><span class=comment># or on the contrary, use "always" that's very slow but a bit safer than</span></span><br><span class=line><span class=comment># everysec.</span></span><br><span class=line><span class=comment>#</span></span><br><span class=line><span class=comment># More details please check the following article:</span></span><br><span class=line><span class=comment># http://antirez.com/post/redis-persistence-demystified.html</span></span><br><span class=line><span class=comment>#</span></span><br><span class=line><span class=comment># If unsure, use "everysec".</span></span><br><span class=line></span><br><span class=line><span class=comment># appendfsync always</span></span><br><span class=line>appendfsync everysec</span><br><span class=line><span class=comment># appendfsync no</span></span><br></pre></table></figure><p><img alt=image-20250325221116370 data-src=https://s2.loli.net/2025/03/25/eVhk1jS2WB9H7Za.png><p>使用<code>bgrewriteaof</code>节省AOF文件,因为记录的AOF命令可能多余(比如后面的更新了前面的值)<p><img alt=image-20250325222257850 data-src=https://s2.loli.net/2025/03/25/KvqyuzAp4XeFJE8.png><p><img alt=image-20250325222328632 data-src=https://s2.loli.net/2025/03/25/hL2vHmQEdOAuocX.png><h3 id=事务-1><a class=headerlink href=#事务-1 title=事务></a>事务</h3><p>Redis 提供了一种简单的事务机制，它<strong>允许用户将多个命令打包成一个事务进行执行</strong>。与传统数据库中的事务不同<strong>，Redis 的事务并不支持回滚（rollback）操作</strong>。<p>Redis 事务的关键命令<ul><li><strong>MULTI</strong>：标记一个事务块的开始。一旦调用了 <code>MULTI</code> 命令，客户端会进入事务模式，在这种模式下所有的后续命令都会被放入队列中等待执行，而不是立即执行。<li><strong>EXEC</strong>：执行所有在 <code>MULTI</code> 和 <code>EXEC</code> 之间的命令。当调用 <code>EXEC</code> 时，Redis 会顺序地执行事务队列中的每个命令，并返回每个命令的结果。<li><strong>DISCARD</strong>：取消事务，放弃执行事务队列中的所有命令并退出事务模式。<li><p><strong>WATCH</strong>：用于监控一个或多个键，如果这些键在事务执行之前被其他客户端修改了，则事务会被中断，<code>EXEC</code> 返回 <code>nil</code> 表示事务未成功执行。这为 Redis 提供了一种乐观锁机制。</p><li><p><strong>原子性</strong>：虽然 Redis 的事务保证了命令序列要么全部执行，要么一个都不执行，但是 Redis 并不支持回滚功能。这意味着如果有任何命令执行失败，其余命令仍将继续执行。</p><li><strong>乐观锁</strong>：通过 <code>WATCH</code> 命令实现的乐观锁机制可以在一定程度上解决并发修改的问题。例如，在对某个键进行修改前先 <code>WATCH</code> 它，然后执行一系列的操作，最后通过 <code>EXEC</code> 提交事务。如果在这期间有其他客户端修改了该键，则当前事务将被中断，<code>EXEC</code> 将返回 <code>nil</code>。</ul><blockquote><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。<p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</blockquote><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>WATCH mykey</span><br><span class=line>... <span class=comment># 其他客户端可能在此期间修改了 mykey</span></span><br><span class=line>MULTI</span><br><span class=line>SET mykey newValue</span><br><span class=line>EXEC <span class=comment># 如果 mykey 在 WATCH 后被修改过，EXEC 将返回 nil</span></span><br></pre></table></figure><h2 id=RabbitMQ✨><a class=headerlink href=#RabbitMQ✨ title=RabbitMQ✨></a>RabbitMQ✨</h2><h2 id=Kafka><a class=headerlink href=#Kafka title=Kafka></a>Kafka</h2><ol><li><strong>Topic（主题）</strong></ol><ul><li>Kafka 中的 Topic 类似于数据库中的表，用于对消息进行分类。每个消息都会被发布到一个特定的 Topic 下。</ul><ol><li><strong>Partition（分区）</strong></ol><ul><li>每个 Topic 可以被划分为多个 Partition，Partition 是 Kafka 中数据的基本存储单元。每个 Partition 内部的消息是有序的。</ul><ol><li><strong>Producer（生产者）</strong></ol><ul><li>Producer 是向 Kafka 中发布消息的客户端应用程序。它将消息发送到指定的 Topic。<a href=https://kafka.apachecn.org/1/?utm_source=chatgpt.com rel=noopener target=_blank>kafka.apachecn.org+1support.huaweicloud.com+1</a></ul><ol><li><strong>Consumer（消费者）</strong></ol><ul><li>Consumer 是从 Kafka 中订阅并消费消息的客户端应用程序。它从指定的 Topic 中读取消息。</ul><ol><li><strong>Consumer Group（消费者组）</strong></ol><ul><li>Consumer Group 是一组 Consumer 的集合，Kafka 会将一个 Topic 的消息分发给 Consumer Group 中的各个 Consumer，每个消息只会被 Consumer Group 中的一个 Consumer 消费。<a href=https://www.cnblogs.com/zjdxr-up/p/15000181.html?utm_source=chatgpt.com rel=noopener target=_blank>博客园</a></ul><ol><li><strong>Broker（代理）</strong></ol><ul><li>Broker 是 Kafka 集群中的一个节点，负责接收、存储和转发消息。一个 Kafka 集群由多个 Broker 组成。<a href=https://www.cnblogs.com/zjdxr-up/p/15000181.html?utm_source=chatgpt.com rel=noopener target=_blank>博客园</a></ul><ol><li><strong>Cluster（集群）</strong></ol><ul><li>Kafka 集群由多个 Broker 组成，提供高可用性和水平扩展能力。每个 Broker 都可以处理消息的读写请求。<a href=https://blog.csdn.net/weixin_37693463/article/details/144621118?utm_source=chatgpt.com rel=noopener target=_blank>CSDN+1CSDN+1</a></ul><ol><li><strong>Zookeeper</strong></ol><ul><li>Zookeeper 是 Kafka 的协调服务，用于管理和协调 Kafka 集群中的 Broker 元数据。Kafka 2.8.0 以后，Kafka 引入了 KRaft 模式，逐步减少对 Zookeeper 的依赖。</ul><ol><li><strong>Offset（偏移量）</strong></ol><ul><li>Offset 是 Kafka 中每条消息在 Partition 中的唯一标识符。Consumer 通过 Offset 来追踪已消费的消息。</ul><ol><li><strong>Replication（副本）</strong></ol><ul><li>Kafka 支持对 Topic 的 Partition 进行副本复制，以提高数据的可靠性和容错能力。每个 Partition 可以有多个副本，其中一个副本为 Leader，其他为 Follower。</ul><ol><li><strong>Retention（消息保留）</strong></ol><ul><li>Kafka 允许设置消息的保留策略，可以根据时间（如 7 天）或空间（如 1 GB）来控制消息的保留期限。超过保留期限的消息会被删除。</ul><ol><li><strong>Consumer Lag（消费者滞后）</strong></ol><ul><li>Consumer Lag 是指 Consumer 当前消费的 Offset 与 Partition 中最新消息的 Offset 之间的差距。较大的 Consumer Lag 可能意味着 Consumer 的消费速度跟不上生产者的生产速度。</ul><h2 id=RocketMQ><a class=headerlink href=#RocketMQ title=RocketMQ></a>RocketMQ</h2><h1 id=网络编程框架><a class=headerlink href=#网络编程框架 title=网络编程框架></a>网络编程框架</h1><h2 id=Netty><a class=headerlink href=#Netty title=Netty></a>Netty</h2><p>Netty 是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能协议服务器和客户端。它简化了网络编程的复杂性，使得开发者能够专注于业务逻辑而非底层细节。以下是 Netty 的一些重要概念、经典例子以及在使用时需要注意的地方。<h3 id=重要概念><a class=headerlink href=#重要概念 title=重要概念></a>重要概念</h3><ol><li><strong>Channel</strong>：表示一个打开的连接，可以是TCP/IP连接、UDP连接等。每个Channel都关联了一个ChannelPipeline，用于处理入站和出站事件。<li><strong>EventLoop</strong>：负责处理Channel上的I/O操作。每个EventLoop通常绑定到单个线程上，并且管理多个Channel实例。<li><strong>ChannelHandler</strong>：实现对Channel中数据的处理逻辑。它可以是入站处理器（如解码器）或出站处理器（如编码器）。ChannelHandler可以通过ChannelPipeline链式地组织起来。<li><strong>ChannelPipeline</strong>：为每个Channel提供一个ChannelHandler实例的链表结构，用于处理通道中的事件流。你可以根据需要添加、删除或替换这些处理器。<li><strong>Bootstrap 和 ServerBootstrap</strong>：分别用于配置客户端和服务端的启动参数。它们提供了简单的方法来设置各种属性，比如通道类型、事件循环组等。</ol><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>EchoServer</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> <span class=keyword>int</span> port;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>EchoServer</span><span class=params>(<span class=keyword>int</span> port)</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.port = port;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> Exception </span>{</span><br><span class=line>        <span class=keyword>new</span> EchoServer(<span class=number>8080</span>).start();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>start</span><span class=params>()</span> <span class=keyword>throws</span> Exception </span>{</span><br><span class=line>        EventLoopGroup group = <span class=keyword>new</span> NioEventLoopGroup();</span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            ServerBootstrap b = <span class=keyword>new</span> ServerBootstrap();</span><br><span class=line>            b.group(group)</span><br><span class=line>             .channel(NioServerSocketChannel.class)</span><br><span class=line>             .localAddress(<span class=keyword>new</span> InetSocketAddress(port))</span><br><span class=line>             .childHandler(<span class=keyword>new</span> ChannelInitializer&LTSocketChannel>() {</span><br><span class=line>                 <span class=meta>@Override</span></span><br><span class=line>                 <span class=function><span class=keyword>protected</span> <span class=keyword>void</span> <span class=title>initChannel</span><span class=params>(SocketChannel ch)</span> <span class=keyword>throws</span> Exception </span>{</span><br><span class=line>                     ch.pipeline().addLast(<span class=keyword>new</span> EchoServerHandler());</span><br><span class=line>                 }</span><br><span class=line>             });</span><br><span class=line></span><br><span class=line>            ChannelFuture f = b.bind().sync();</span><br><span class=line>            System.out.println(<span class=string>"Server started and listening on "</span> + f.channel().localAddress());</span><br><span class=line>            f.channel().closeFuture().sync();</span><br><span class=line>        } <span class=keyword>finally</span> {</span><br><span class=line>            group.shutdownGracefully().sync();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>EchoServerHandler</span> <span class=keyword>extends</span> <span class=title>ChannelInboundHandlerAdapter</span> </span>{</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>channelRead</span><span class=params>(ChannelHandlerContext ctx, Object msg)</span> </span>{</span><br><span class=line>        ByteBuf in = (ByteBuf) msg;</span><br><span class=line>        System.out.println(<span class=string>"Server received: "</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class=line>        ctx.write(msg);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>channelReadComplete</span><span class=params>(ChannelHandlerContext ctx)</span> </span>{</span><br><span class=line>        ctx.flush();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>exceptionCaught</span><span class=params>(ChannelHandlerContext ctx, Throwable cause)</span> </span>{</span><br><span class=line>        cause.printStackTrace();</span><br><span class=line>        ctx.close();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h1 id=Spring家族✨><a class=headerlink href=#Spring家族✨ title=Spring家族✨></a>Spring家族✨</h1><p>Spring提供依赖注入(DI),控制反转(IOC),面向切面编程等,为Java开发提供便利.而SpringMVC提供了比纯Servlet更好的开发体验.<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> org.example.MyServlets;</span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * <span class=doctag>@Author</span>: proanimer</span></span><br><span class=line><span class=comment> * <span class=doctag>@Description</span>:</span></span><br><span class=line><span class=comment> * <span class=doctag>@Date</span>: Created in 2025/3/10</span></span><br><span class=line><span class=comment> * <span class=doctag>@Modified</span> By proanimer</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line></span><br><span class=line><span class=comment>// Servlet实现web请求响应</span></span><br><span class=line><span class=keyword>import</span> jakarta.servlet.ServletException;</span><br><span class=line><span class=keyword>import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class=line><span class=keyword>import</span> jakarta.servlet.http.HttpServlet;</span><br><span class=line><span class=keyword>import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class=line><span class=keyword>import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.io.IOException;</span><br><span class=line><span class=keyword>import</span> java.io.PrintWriter;</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * <span class=doctag>@projectName</span>: workspace</span></span><br><span class=line><span class=comment> * <span class=doctag>@package</span>: org.example.MyServlets</span></span><br><span class=line><span class=comment> * <span class=doctag>@className</span>: MyServlet</span></span><br><span class=line><span class=comment> * <span class=doctag>@author</span>: proanimer</span></span><br><span class=line><span class=comment> * <span class=doctag>@description</span>:</span></span><br><span class=line><span class=comment> * <span class=doctag>@date</span>: 2025/3/10 20:01</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=meta>@WebServlet(name = "MyServlet", urlPatterns = "/hello")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>MyServlet</span> <span class=keyword>extends</span> <span class=title>HttpServlet</span> </span>{</span><br><span class=line>    <span class=keyword>private</span>  <span class=keyword>static</span> <span class=keyword>final</span> <span class=keyword>long</span> serialVersionUID = <span class=number>1L</span>;</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>MyServlet</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>super</span>();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>protected</span> <span class=keyword>void</span> <span class=title>doGet</span><span class=params>(HttpServletRequest req, HttpServletResponse resp)</span> <span class=keyword>throws</span> ServletException, IOException </span>{</span><br><span class=line>        resp.setContentType(<span class=string>"text/html;charset=UTF-8"</span>);</span><br><span class=line>        <span class=keyword>try</span>(PrintWriter out = resp.getWriter()) {</span><br><span class=line>            out.println(<span class=string>"&LThtml>"</span>);</span><br><span class=line>            out.println(<span class=string>"&LThead>"</span>);</span><br><span class=line>            out.println(<span class=string>"&LTtitle>MyServlet&LT/title>"</span>);</span><br><span class=line>            out.println(<span class=string>"&LT/head>"</span>);</span><br><span class=line>            out.println(<span class=string>"&LTbody>"</span>);</span><br><span class=line>            out.println(<span class=string>"&LTh1>MyServlet&LT/h1>"</span>);</span><br><span class=line>            out.println(<span class=string>"&LT/body>"</span>);</span><br><span class=line>            out.println(<span class=string>"&LT/html>"</span>);</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>protected</span> <span class=keyword>void</span> <span class=title>doPost</span><span class=params>(HttpServletRequest req, HttpServletResponse resp)</span> <span class=keyword>throws</span> ServletException, IOException </span>{</span><br><span class=line>       doGet(req,resp);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><h2 id=spring><a class=headerlink href=#spring title=spring></a>spring</h2><p><a href=https://spring.io/quickstart rel=noopener target=_blank>Spring | Quickstart</a><p><a href=https://www.cainiaojc.com/spring/spring-tutorial.html rel=noopener target=_blank>Spring 教程 - Spring教程 - 菜鸟教程</a><h3 id=IOC容器><a class=headerlink href=#IOC容器 title=IOC容器></a>IOC容器</h3><blockquote><p>依赖注入（DI）是 IoC 的一种特殊形式，其中对象仅通过构造函数参数、工厂方法参数或在对象实例构建或从工厂方法返回后设置的属性来定义其依赖（即它们与之一起工作的其他对象）。IoC 容器在创建 bean 时注入这些依赖。这个过程本质上是 bean 本身通过直接构建类或如Service Locator pattern等机制控制其依赖的实例化或位置的反向（因此得名，控制反转）。</blockquote><p>Spring 框架支持多种配置方式，包括<strong>基于 XML 的配置</strong>、<strong>基于注解的配置</strong>以及<strong>基于 Java 配置类</strong>的配置。<blockquote><p>spring6.x版本官方文档已经不再详细说xml配置,主流是java配置类.</blockquote><ul><li><strong>XML 配置</strong>：适用于传统的 Spring 应用程序，提供了对 Spring 容器的详细控制。<li><strong>注解配置</strong>：减少了 XML 配置的需求，使得代码更加简洁，但可能不如 XML 配置那样直观地看到整个应用程序的结构。<li><strong>Java 配置类</strong>：提供了一种类型安全的方式来配置 Spring 应用程序，尤其适合新的项目或微服务架构。</ul><p><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 包是 Spring 框架 IoC 容器的基石。 <code>BeanFactory</code> 接口提供了一种高级配置机制，能够管理任何类型的对象。 <code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口。<blockquote><p>Spring容器就是<code>ApplicationContext</code>，它是一个接口，有很多实现类，比如<code>ClassPathXmlApplicationContext</code>，表示它会自动从classpath中查找指定的XML配置文件。</blockquote><p><code>BeanFactory</code> 接口提供了一种高级配置机制，能够管理任何类型的对象，它是SpringIoC容器标准化超接口！<p><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口。它扩展了以下功能：<ul><li>更容易与 Spring 的 AOP 功能集成<li>消息资源处理（用于国际化）<li>特定于应用程序给予此接口实现，例如Web 应用程序的 <code>WebApplicationContext</code></ul><p>简而言之， <code>BeanFactory</code> 提供了配置框架和基本功能，而 <code>ApplicationContext</code> 添加了更多特定于企业的功能。 <code>ApplicationContext</code> 是 <code>BeanFactory</code> 的完整超集<p><strong>ApplicationContext容器实现类</strong>：<div class=table-container><table><thead><tr><th>类型名<th>简介<tbody><tr><td><strong>ClassPathXmlApplicationContext</strong><td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象<tr><td>FileSystemXmlApplicationContext<td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象<tr><td><strong>AnnotationConfigApplicationContext</strong><td>通过读取Java配置类创建 IOC 容器对象<tr><td>WebApplicationContext<td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</table></div><p>IoC 容器的基本职责包括：<ul><li>实例化 Bean。<li>设置 Bean 的属性值和生命周期回调。<li>管理 Bean 之间的依赖关系。<li>控制 Bean 的作用域（如 singleton, prototype 等）。</ul><p>Spring 提供了两种类型的 IoC 容器：<ul><li><strong>BeanFactory</strong>：提供了基础的功能来管理和操作 Bean，适合资源受限的环境。<li><strong>ApplicationContext</strong>：扩展了 <code>BeanFactory</code>，增加了事件发布、国际化支持、AOP 集成等功能，适用于大多数应用场合。</ul><p>通常情况下，开发者更倾向于使用 <code>ApplicationContext</code>，因为它提供了更多的功能和便利性。<p><strong>2. ApplicationContext 的实现类</strong><p>Spring 提供了几种 <code>ApplicationContext</code> 的实现类，每种都有其特定的应用场景：<ul><li><strong>ClassPathXmlApplicationContext</strong>：从类路径下的 XML 文件加载 Bean 定义。<li><strong>FileSystemXmlApplicationContext</strong>：从文件系统中指定位置的 XML 文件加载 Bean 定义。<li><strong>AnnotationConfigApplicationContext</strong>：用于基于 Java 注解的配置，不依赖于 XML 文件。<li><strong>WebApplicationContext</strong>：专为 Web 应用设计，支持 Servlet 上下文，并且可以方便地集成到 Web 应用程序中。</ul><p><strong>3. Bean 定义</strong><p>在 Spring 中，Bean 定义是描述如何创建一个 Bean 的元数据。可以通过以下方式定义 Bean：<ul><li><strong>XML 配置文件</strong>：传统方式，通过 XML 文件定义 Bean 及其依赖关系。<li><strong>注解</strong>：例如 <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code> 等，配合 <code>@Autowired</code> 或构造函数注入。<li><strong>Java 配置类</strong>：使用 <code>@Configuration</code> 和 <code>@Bean</code> 注解定义 Bean。</ul><h4 id=构造器注入><a class=headerlink href=#构造器注入 title=构造器注入></a>构造器注入</h4><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"com.example.ExampleBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>value</span>=<span class=string>"value1"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>ref</span>=<span class=string>"anotherBean"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"anotherBean"</span> <span class=attr>class</span>=<span class=string>"com.example.AnotherBean"</span>/></span></span><br></pre></table></figure><p><code>&LTconstructor-arg></code> 标签用于在 XML 配置文件中定义构造函数注入所需的参数。通过该标签，你可以指定将哪些值或 Bean 注入到目标类的构造函数中。<code>&LTconstructor-arg></code> 支持多个属性来帮助精确地匹配和注入依赖，主要包括 <code>name</code>, <code>value</code>, <code>index</code>, 和 <code>type</code> 等属性。下面详细介绍这些属性的意义：<ol><li><code>name</code></ol><ul><li><p><strong>用途</strong>：指定构造函数参数的名字。</p><li><p><strong>适用场景</strong>：当目标类的构造函数使用命名参数时，可以通过 <code>name</code> 属性明确指定要注入哪个参数。不过需要注意的是，Spring 在早期版本中并不直接支持按名称注入构造参数，而是根据类型和顺序（索引）进行匹配。从 Spring 3.0 开始，如果使用 CGLIB 来增强字节码，则可以支持基于名称的构造函数注入。</p><li><p>示例</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"com.example.ExampleClass"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>name</span>=<span class=string>"paramName"</span> <span class=attr>value</span>=<span class=string>"someValue"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure></ul><ol><li><code>value</code></ol><ul><li><p><strong>用途</strong>：直接为基本数据类型或 String 类型的构造函数参数提供值。</p><li><p><strong>适用场景</strong>：适用于需要传递简单类型的值作为构造函数参数的情况。</p><li><p>示例：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"com.example.ExampleClass"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>index</span>=<span class=string>"0"</span> <span class=attr>value</span>=<span class=string>"Hello, World!"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>这里”Hello, World!”将被作为第一个参数传递给ExampleClass的构造函数。</p></ul><ol><li><code>index</code></ol><ul><li><p><strong>用途</strong>：指定构造函数参数的位置索引，以确定向哪个参数注入值。</p><li><p><strong>适用场景</strong>：当你有多个构造函数参数并且想要精确控制哪个参数接收哪个值时非常有用。</p><li><p><strong>注意事项</strong>：索引是从 0 开始的。</p><li><p>示例：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"com.example.ExampleClass"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>index</span>=<span class=string>"0"</span> <span class=attr>value</span>=<span class=string>"First Argument"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>index</span>=<span class=string>"1"</span> <span class=attr>ref</span>=<span class=string>"anotherBean"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure></ul><ol><li><code>type</code></ol><ul><li><p><strong>用途</strong>：指定构造函数参数的数据类型，帮助 Spring 容器更准确地选择合适的构造函数（特别是在存在重载构造函数的情况下）。</p><li><p><strong>适用场景</strong>：当你有多个同名但不同类型的构造函数参数时，或者你需要确保特定类型的值被注入时使用。</p><li><p>示例：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"com.example.ExampleClass"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>type</span>=<span class=string>"java.lang.String"</span> <span class=attr>value</span>=<span class=string>"String Argument"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>type</span>=<span class=string>"int"</span> <span class=attr>value</span>=<span class=string>"123"</span>/></span></span><br></pre></table></figure></ul><p>Java配置类<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>AppConfig</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> MyRepository <span class=title>myRepository</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> MyRepositoryImpl();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> MyService <span class=title>myService</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=comment>// 使用构造函数注入</span></span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> MyServiceImpl(myRepository());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h4 id=静态工厂方法><a class=headerlink href=#静态工厂方法 title=静态工厂方法></a>静态工厂方法</h4><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"clientService"</span> <span class=attr>class</span>=<span class=string>"com.example.ClientService"</span> <span class=attr>factory-method</span>=<span class=string>"createInstance"</span>/></span></span><br></pre></table></figure><p>利用工厂类的静态方法<h4 id=实例工厂方法><a class=headerlink href=#实例工厂方法 title=实例工厂方法></a>实例工厂方法</h4><p>利用工厂的实例方法<p>首先定义工厂 Bean<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"serviceFactory"</span> <span class=attr>class</span>=<span class=string>"com.example.ServiceFactory"</span>/></span></span><br></pre></table></figure><p>然后，使用这个工厂 Bean 的方法来创建目标 Bean。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"clientService"</span> <span class=attr>factory-bean</span>=<span class=string>"serviceFactory"</span> <span class=attr>factory-method</span>=<span class=string>"createClientServiceInstance"</span>/></span></span><br></pre></table></figure><p>这里假设 <code>ServiceFactory</code> 类中有一个名为 <code>createClientServiceInstance</code> 的方法，用于创建并返回一个新的 <code>ClientService</code> 实例。<p><strong>注解方式创建工厂Bean</strong><p>用工厂模式创建Bean需要实现<code>FactoryBean</code>接口。我们观察下面的代码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ZoneIdFactoryBean</span> <span class=keyword>implements</span> <span class=title>FactoryBean</span><<span class=title>ZoneId</span>> </span>{</span><br><span class=line></span><br><span class=line>    String zone = <span class=string>"Z"</span>;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> ZoneId <span class=title>getObject</span><span class=params>()</span> <span class=keyword>throws</span> Exception </span>{</span><br><span class=line>        <span class=keyword>return</span> ZoneId.of(zone);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Class&LT?> getObjectType() {</span><br><span class=line>        <span class=keyword>return</span> ZoneId.class;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>当一个Bean实现了<code>FactoryBean</code>接口后，Spring会先实例化这个工厂，然后调用<code>getObject()</code>创建真正的Bean。<code>getObjectType()</code>可以指定创建的Bean的类型，因为指定类型不一定与实际类型一致，可以是接口或抽象类。<p>因此，如果定义了一个<code>FactoryBean</code>，要注意Spring创建的Bean实际上是这个<code>FactoryBean</code>的<code>getObject()</code>方法返回的Bean。为了和普通Bean区分，我们通常都以<code>XxxFactoryBean</code>命名。<p><strong>由于可以用<code>@Bean</code>方法创建第三方Bean，本质上<code>@Bean</code>方法就是工厂方法，所以，<code>FactoryBean</code>已经用得越来越少了</strong>。<h4 id=实例化后设置属性><a class=headerlink href=#实例化后设置属性 title=实例化后设置属性></a>实例化后设置属性</h4><p>这是最常见的 Bean 实例化方式之一，在 Bean 被实例化之后，通过 setter 方法设置其属性。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"com.example.ExampleBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"property1"</span> <span class=attr>value</span>=<span class=string>"value1"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"property2"</span> <span class=attr>ref</span>=<span class=string>"anotherBean"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"anotherBean"</span> <span class=attr>class</span>=<span class=string>"com.example.AnotherBean"</span>/></span></span><br></pre></table></figure><p>在这个例子中，<code>ExampleBean</code> 有两个属性 <code>property1</code> 和 <code>property2</code>，它们分别通过 <code>set</code> 方法被赋值<h4 id=注解Annotation配置><a class=headerlink href=#注解Annotation配置 title=注解Annotation配置></a>注解Annotation配置</h4><p>使用XML配置的优点是所有的Bean都能一目了然地列出来，并通过配置注入能直观地看到每个Bean的依赖。它的缺点是写起来非常繁琐，每增加一个组件，就必须把新的Bean配置到XML中。<p>可以使用Annotation配置，可以完全不需要XML，让Spring自动扫描Bean并组装它们。<p><code>@Component</code>注解就相当于定义了一个Bean，它有一个可选的名称，默认是<code>mailService</code>，即小写开头的类名。<h4 id=使用Java配置类><a class=headerlink href=#使用Java配置类 title=使用Java配置类></a>使用Java配置类</h4><h4 id=Bean的声明周期管理><a class=headerlink href=#Bean的声明周期管理 title=Bean的声明周期管理></a>Bean的声明周期管理</h4><p><strong>Bean 生命周期的基本流程</strong><p>一个典型的 Spring Bean 生命周期包括以下几个步骤：<ol><li><strong>实例化</strong>：根据配置元数据（如 XML 配置、Java 注解或 Java 配置类），Spring 容器首先实例化 Bean。<li><strong>设置属性值</strong>：将 Bean 实例化后，Spring 会为该 Bean 设置属性值和其他依赖注入。<li><strong>初始化前</strong>：如果实现了 <code>Aware</code> 系列接口（例如 <code>BeanNameAware</code>, <code>BeanFactoryAware</code>, <code>ApplicationContextAware</code>），则调用这些接口的方法，让 Bean 能够感知其环境信息。<li><strong>BeanPostProcessor 前处理</strong>：如果存在实现了 <code>BeanPostProcessor</code> 接口的 Bean，则调用其 <code>postProcessBeforeInitialization</code> 方法。这是对所有 Bean 都适用的一个扩展点。<li><strong>初始化</strong>：<ul><li>如果 Bean 实现了 <code>InitializingBean</code> 接口，则调用 <code>afterPropertiesSet()</code> 方法。<li>如果指定了 <code>&LTbean></code> 元素的 <code>init-method</code> 属性或使用了 <code>@PostConstruct</code> 注解，则调用指定的初始化方法。</ul><li><strong>BeanPostProcessor 后处理</strong>：接着再次调用实现了 <code>BeanPostProcessor</code> 接口的 <code>postProcessAfterInitialization</code> 方法。<li><strong>使用阶段</strong>：此时 Bean 已经准备好并可以被应用程序使用了。<li><strong>销毁阶段</strong>：<ul><li>当容器关闭时，如果 Bean 实现了 <code>DisposableBean</code> 接口，则调用 <code>destroy()</code> 方法。<li>如果指定了 <code>&LTbean></code> 元素的 <code>destroy-method</code> 属性或使用了 <code>@PreDestroy</code> 注解，则调用指定的销毁方法。</ul></ol><p><strong>2. 控制 Bean 生命周期的关键接口和注解</strong><ul><li><strong><code>Aware</code> 系列接口</strong>：用于让 Bean 感知到容器的一些信息。<ul><li><code>BeanNameAware</code>: 获取 Bean 的名称。<li><code>BeanFactoryAware</code>: 获取 BeanFactory。<li><code>ApplicationContextAware</code>: 获取 ApplicationContext。</ul><li><strong><code>BeanPostProcessor</code> 接口</strong>：提供两个方法用于前后处理 Bean 初始化逻辑。<ul><li><code>postProcessBeforeInitialization(Object bean, String beanName)</code> 在初始化之前调用。<li><code>postProcessAfterInitialization(Object bean, String beanName)</code> 在初始化之后调用。</ul><li><strong><code>InitializingBean</code> 接口</strong>：提供 <code>afterPropertiesSet()</code> 方法，在所有属性设置完成后执行自定义初始化逻辑。<li><strong><code>DisposableBean</code> 掀口</strong>：提供 <code>destroy()</code> 方法，在容器关闭时执行清理工作。<li><strong>注解支持</strong>：<ul><li><code>@PostConstruct</code>：标注在方法上，表示这是一个初始化方法。<li><code>@PreDestroy</code>：标注在方法上，表示这是一个销毁方法。</ul></ul><p>在 Spring 框架中，Bean 的作用域（Scope）决定了 Bean 实例的作用范围和生命周期。Spring 提供了多种内置的作用域类型，每种类型适用于不同的场景。理解这些作用域可以帮助你更好地控制 Bean 的行为，确保它们在应用程序中的正确使用。<blockquote><ol><li><strong>实例化（Instantiation）</strong>：<ul><li>Spring容器根据Bean定义的信息创建Bean的实例。</ul><li><strong>属性赋值（Populate）</strong>：<ul><li>Spring容器将配置文件中的属性值或者依赖注入到Bean实例中。这一步通常通过setter方法完成，也可以通过构造函数注入。</ul><li><strong>设置其他属性</strong>：<ul><li>如果Bean实现了<code>BeanNameAware</code>接口，Spring会调用<code>setBeanName(String name)</code>方法，传入Bean的名字。<li>如果Bean实现了<code>BeanFactoryAware</code>接口，Spring会调用<code>setBeanFactory(BeanFactory beanFactory)</code>方法，传入BeanFactory的实例。<li>如果Bean实现了<code>ApplicationContextAware</code>接口，Spring会调用<code>setApplicationContext(ApplicationContext applicationContext)</code>方法，传入ApplicationContext的实例。</ul><li><strong>初始化前处理（Initialization Before Processing）</strong>：<ul><li>如果有实现<code>BeanPostProcessor</code>接口的后处理器，它们的<code>postProcessBeforeInitialization(Object bean, String beanName)</code>方法会被调用。</ul><li><strong>初始化（Initialization）</strong>：<ul><li>如果Bean实现了<code>InitializingBean</code>接口，Spring会调用其<code>afterPropertiesSet()</code>方法。<li>如果在XML配置中指定了<code>init-method</code>属性，那么对应的自定义初始化方法也会被调用。<li>也可以使用<code>@PostConstruct</code>注解来指定初始化方法。</ul><li><strong>初始化后处理（Initialization After Processing）</strong>：<ul><li>如果有实现<code>BeanPostProcessor</code>接口的后处理器，它们的<code>postProcessAfterInitialization(Object bean, String beanName)</code>方法会被调用。</ul><li><strong>使用Bean</strong>：<ul><li>此时Bean已经完全初始化，可以正常使用了。</ul><li><strong>销毁前处理（Destruction Before Processing）</strong>：<ul><li>当容器关闭时，如果Bean实现了<code>DisposableBean</code>接口，Spring会调用其<code>destroy()</code>方法。<li>如果在XML配置中指定了<code>destroy-method</code>属性，那么对应的自定义销毁方法也会被调用。<li>同样可以使用<code>@PreDestroy</code>注解来指定销毁方法。</ul></ol></blockquote><p><strong>1. 常见的 Bean 作用域</strong><p><strong>(1) Singleton（单例）</strong><ul><li><strong>默认作用域</strong>：如果未指定作用域，默认为 <code>singleton</code>。<li><strong>行为</strong>：Spring 容器在整个应用上下文中只会创建一个该类型的 Bean 实例，并且所有对该 Bean 的请求都会返回这个唯一的实例。<li><strong>适用场景</strong>：大多数情况下，特别是对于无状态的服务类，如服务层、数据访问层等。</ul><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"com.example.ExampleClass"</span> <span class=attr>scope</span>=<span class=string>"singleton"</span>/></span></span><br></pre></table></figure><p>或通过注解：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Scope("singleton")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ExampleClass</span> </span>{</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>(2) Prototype（原型）</strong><ul><li><strong>行为</strong>：每次对 Bean 的请求都会创建一个新的实例。<li><strong>适用场景</strong>：当需要每次获取到的是一个新的对象实例时使用，例如命令对象、Web 控制器等。</ul><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"com.example.ExampleClass"</span> <span class=attr>scope</span>=<span class=string>"prototype"</span>/></span></span><br></pre></table></figure><p>或通过注解：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Scope("prototype")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ExampleClass</span> </span>{</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>此外还有Request,Session和Application等作用域.<h4 id=选择性实例化Bean><a class=headerlink href=#选择性实例化Bean title=选择性实例化Bean></a>选择性实例化Bean</h4><p>选择性实例化 Bean 是指根据某些条件动态决定是否创建某个 Bean 实例。Spring 提供了多种机制来实现这种功能，例如使用注解、配置文件或编程方式<p><strong>使用 <code>@Conditional</code> 注解</strong><p><code>@Conditional</code> 是 Spring 中的一个核心注解，用于根据特定条件决定是否加载某个 Bean。<p><strong>(1) 工作原理</strong><ul><li><code>@Conditional</code> 接受一个实现了 <code>Condition</code> 接口的类作为参数。<li>在运行时，Spring 会调用 <code>Condition</code> 的 <code>matches()</code> 方法，如果返回 <code>true</code>，则加载该 Bean；否则跳过。</ul><p><strong>(2) 示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.context.annotation.Condition;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.ConditionContext;</span><br><span class=line><span class=keyword>import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class=line></span><br><span class=line><span class=comment>// 自定义条件类</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>MyCondition</span> <span class=keyword>implements</span> <span class=title>Condition</span> </span>{</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>boolean</span> <span class=title>matches</span><span class=params>(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>{</span><br><span class=line>        <span class=comment>// 检查系统属性 "my.condition" 是否为 true</span></span><br><span class=line>        <span class=keyword>return</span> Boolean.parseBoolean(System.getProperty(<span class=string>"my.condition"</span>));</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 配置类</span></span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.Bean;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.Conditional;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.Configuration;</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>AppConfig</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=meta>@Conditional(MyCondition.class)</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> MyBean <span class=title>myBean</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> MyBean();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment># 不加载 MyBean</span></span><br><span class=line>java -jar app.jar</span><br><span class=line></span><br><span class=line><span class=comment># 加载 MyBean</span></span><br><span class=line>java -Dmy.condition=<span class=literal>true</span> -jar app.jar</span><br></pre></table></figure><p><code>@Profile</code> 是 Spring 中的一种更简单的条件加载机制，它根据当前激活的环境（profile）来决定是否加载某个 Bean。<p><strong>(1) 工作原理</strong><ul><li>每个 <code>@Profile</code> 注解可以指定一个或多个 profile 名称。<li>只有当这些 profile 被激活时，对应的 Bean 才会被加载。</ul><p><strong>(2) 示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.context.annotation.Bean;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.Configuration;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.Profile;</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ProfileConfig</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=meta>@Profile("dev")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> MyBean <span class=title>devBean</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> MyBean(<span class=string>"Development Environment"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=meta>@Profile("prod")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> MyBean <span class=title>prodBean</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> MyBean(<span class=string>"Production Environment"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>(3) 测试</strong><p>启动程序时，可以通过指定激活的 profile 来加载不同的 Bean：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment># 激活开发环境</span></span><br><span class=line>java -Dspring.profiles.active=dev -jar app.jar</span><br><span class=line></span><br><span class=line><span class=comment># 激活生产环境</span></span><br><span class=line>java -Dspring.profiles.active=prod -jar app.jar</span><br></pre></table></figure><p><strong>使用 FactoryBean 动态创建 Bean</strong><p><code>FactoryBean</code> 是 Spring 提供的一种接口，用于动态创建 Bean 实例。<p><strong>(1) 工作原理</strong><ul><li>实现 <code>FactoryBean</code> 接口，并重写 <code>getObject()</code> 方法。<li>在运行时，Spring 会调用 <code>getObject()</code> 方法来获取实际的 Bean 实例。</ul><p><strong>(2) 示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>MyBeanFactory</span> <span class=keyword>implements</span> <span class=title>FactoryBean</span><<span class=title>MyBean</span>> </span>{</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>boolean</span> enabled;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>MyBeanFactory</span><span class=params>(<span class=keyword>boolean</span> enabled)</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.enabled = enabled;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> MyBean <span class=title>getObject</span><span class=params>()</span> <span class=keyword>throws</span> Exception </span>{</span><br><span class=line>        <span class=keyword>if</span> (!enabled) {</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> IllegalStateException(<span class=string>"Bean creation is disabled!"</span>);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> MyBean();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Class&LT?> getObjectType() {</span><br><span class=line>        <span class=keyword>return</span> MyBean.class;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>boolean</span> <span class=title>isSingleton</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>true</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>(3) 配置</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.context.annotation.Bean;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.Configuration;</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>FactoryBeanConfig</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> MyBeanFactory <span class=title>myBeanFactory</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> MyBeanFactory(Boolean.getBoolean(<span class=string>"factory.bean.enabled"</span>));</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><div class=table-container><table><thead><tr><th>版本<th>Bean 自动覆盖行为<tbody><tr><td><strong>Spring Boot 2.0</strong><td>允许用户定义相同类型的 Bean，Spring Boot 预置 Bean 被跳过。<tr><td><strong>Spring Boot 2.1+</strong><td>Spring Boot 检测到多个相同类型 Bean 时，可能会有警告。<tr><td><strong>Spring Boot 2.4+</strong><td><strong>默认不允许手动定义的 Bean 覆盖自动配置的 Bean</strong>（可通过 <code>spring.main.allow-bean-definition-overriding=true</code> 启用）。<tr><td><strong>Spring Boot 3.0+</strong><td>仍然默认不允许覆盖 Bean，除非手动启用 <code>allow-bean-definition-overriding</code>。</table></div><h3 id=如何实现依赖注入><a class=headerlink href=#如何实现依赖注入 title=如何实现依赖注入></a>如何实现依赖注入</h3><p>依赖注入是 IoC 的一种实现方式，允许对象定义其依赖关系而不必自行创建或查找依赖的对象。Spring 支持三种依赖注入类型：<ul><li><strong>构造器注入</strong>：通过构造函数参数注入依赖。<li><strong>Setter 方法注入</strong>：通过 setter 方法注入依赖。<li><strong>字段注入</strong>：直接在字段上使用 <code>@Autowired</code> 注解进行注入。</ul><p>当 Spring 应用启动时，IoC 容器会根据 <code>@Autowired</code> 注解的信息去寻找相应的 Bean 并将其注入到目标对象中。以下是几种常见的注入方式：<ol><li><strong>构造函数注入</strong></ol><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ServiceUser</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> MyService myService;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Autowired</span> <span class=comment>// 自 Spring 4.3 起可以省略，如果只有一个构造函数的话</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>ServiceUser</span><span class=params>(MyService myService)</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.myService = myService;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><ul><li>在这个例子中，Spring 将会查找类型为 <code>MyService</code> 的 Bean，并将其注入到 <code>ServiceUser</code> 类的构造函数中。</ul><ol><li><strong>字段注入</strong></ol><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ServiceUser</span> </span>{</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> MyService myService; <span class=comment>// 直接注入 MyService 实例</span></span><br><span class=line>}</span><br></pre></table></figure><ul><li>字段注入是最简单的形式，但它可能会导致难以进行单元测试，因为它绕过了类的构造函数。</ul><ol><li><strong>Setter 方法注入</strong></ol><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ServiceUser</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> MyService myService;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>setMyService</span><span class=params>(MyService myService)</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.myService = myService;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><ul><li>Setter 方法注入适合于那些可选依赖或希望在运行时更改依赖的情况</ul><p><strong>Bean 查找规则</strong><p>Spring 容器按照以下顺序尝试解析依赖：<ol><li><strong>类型匹配</strong>：首先<strong>基于参数类型</strong>查找匹配的 Bean。<li><strong>名称匹配</strong>：如果<strong>有多个相同类型的 Bean 存在，则根据参数名作为 Bean 名称进行匹配</strong>。<li><strong>限定符（Qualifiers）</strong>：当存在多个相同类型的 Bean 且名称也不足以区分时，可以使用 <code>@Qualifier</code> 注解指定确切的 Bean 名称</ol><p>如果你希望给 Bean 指定一个不同于方法名的名称，可以通过 <code>@Bean</code> 注解的 <code>name</code> 属性来实现或者 <code>@Qualifier</code>。例如：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean(name = "zoneZ")</span></span><br><span class=line><span class=function>ZoneId <span class=title>createZoneOfZ</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>return</span> ZoneId.of(<span class=string>"Z"</span>);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=meta>@Bean(name = "zoneUTC8")</span></span><br><span class=line><span class=function>ZoneId <span class=title>createZoneOfUTC8</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>return</span> ZoneId.of(<span class=string>"UTC+08:00"</span>);</span><br><span class=line>}</span><br></pre></table></figure><p><code>@Autowired</code> 标记的构造函数、字段或方法会被 Spring 容器扫描，并尝试找到匹配的 Bean 来注入。如果找到多个匹配的 Bean，则可能需要通过 <code>@Qualifier</code> 注解来指定具体的 Bean。<p>Spring 提供了多种注解用于实现依赖注入。以下是常用的注入注解及其用途：<p><strong>1. 核心注入注解</strong><p><strong>(1) <code>@Autowired</code></strong><ul><li><strong>作用</strong>：自动注入依赖对象。<li>位置:<ul><li>构造器<li>方法（如 setter 方法）<li>字段<li>参数</ul><li>特点<ul><li><strong>默认按类型（byType）</strong>进行匹配。<li>如果有多个相同类型的 Bean，则会抛出异常，需要结合 <code>@Qualifier</code> 使用。 注解用在构造器,setter,属性上和方法参数上</ul></ul><p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserService</span> </span>{</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> UserRepository userRepository; <span class=comment>// 自动注入 UserRepository</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>(2) <code>@Qualifier</code></strong><ul><li><strong>作用</strong>：当存在多个相同类型的 Bean 时，指定要注入的具体 Bean。<li><strong>配合</strong>：通常与 <code>@Autowired</code> 配合使用。<li><strong>特点</strong>：<strong>通过名称（byName）</strong>来限定注入的 Bean。</ul><p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component("userRepositoryV1")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserRepositoryV1</span> <span class=keyword>implements</span> <span class=title>UserRepository</span> </span>{ }</span><br><span class=line></span><br><span class=line><span class=meta>@Component("userRepositoryV2")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserRepositoryV2</span> <span class=keyword>implements</span> <span class=title>UserRepository</span> </span>{ }</span><br><span class=line></span><br><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserService</span> </span>{</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=meta>@Qualifier("userRepositoryV1")</span></span><br><span class=line>    <span class=keyword>private</span> UserRepository userRepository; <span class=comment>// 注入 UserRepositoryV1</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>(3) <code>@Primary</code></strong><ul><li><strong>作用</strong>：<strong>标记一个 Bean 为首选 Bean，当有多个相同类型的 Bean 时优先注入该 Bean</strong>。<li><strong>特点</strong>：无需显式使用 <code>@Qualifier</code>，简化配置。</ul><p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Primary</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserRepositoryV1</span> <span class=keyword>implements</span> <span class=title>UserRepository</span> </span>{ }</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserRepositoryV2</span> <span class=keyword>implements</span> <span class=title>UserRepository</span> </span>{ }</span><br><span class=line></span><br><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserService</span> </span>{</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> UserRepository userRepository; <span class=comment>// 自动注入 UserRepositoryV1</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>(4) <code>@Resource</code></strong><ul><li><strong>作用</strong>：JSR-250 规范提供的注解，用于注入依赖。<li>特点<ul><li><strong>默认按名称（byName）</strong>进行匹配。<li><strong>如果未找到匹配的名称，则按类型（byType）匹配</strong>。</ul><li><strong>区别</strong>：<code>@Resource</code> 是 Java 的标准注解，而 <code>@Autowired</code> 是 Spring 的注解。(推荐Resource而不是Autowired) 注解用在属性上和setter上.</ul><p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component("userRepository")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserRepository</span> </span>{ }</span><br><span class=line></span><br><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserService</span> </span>{</span><br><span class=line>    <span class=meta>@Resource(name = "userRepository")</span></span><br><span class=line>    <span class=keyword>private</span> UserRepository userRepository; <span class=comment>// 按名称注入</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>(5) <code>@Inject</code></strong><ul><li><strong>作用</strong>：JSR-330 规范提供的注解，功能类似于 <code>@Autowired</code>。<li>特点:<ul><li>默认按类型（byType）进行匹配。<li>需要引入 <code>javax.inject</code> 包。</ul><li><strong>区别</strong>：<code>@Inject</code> 是 Java 的标准注解，而 <code>@Autowired</code> 是 Spring 的注解。</ul><p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> javax.inject.Inject;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserRepository</span> </span>{ }</span><br><span class=line></span><br><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserService</span> </span>{</span><br><span class=line>    <span class=meta>@Inject</span></span><br><span class=line>    <span class=keyword>private</span> UserRepository userRepository; <span class=comment>// 自动注入</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>2. 高级注入注解</strong><p><strong>(6) <code>@Value</code></strong><ul><li><strong>作用</strong>：注入简单的值（如字符串、数字）、系统属性或配置文件中的值。<li><strong>特点</strong>：支持占位符 <code>${}</code> 和 SpEL 表达式 <code>#{}</code>。</ul><p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>AppConfig</span> </span>{</span><br><span class=line>    <span class=meta>@Value("${app.name}")</span></span><br><span class=line>    <span class=keyword>private</span> String appName; <span class=comment>// 注入配置文件中的 app.name</span></span><br><span class=line></span><br><span class=line>    <span class=meta>@Value("#{2 + 3}")</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>int</span> sum; <span class=comment>// 注入表达式的计算结果 (2 + 3 = 5)</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>(7) <code>@ConfigurationProperties</code></strong><ul><li><strong>作用</strong>：批量注入配置文件中的属性到一个 Java 对象中。<li><strong>特点</strong>：适合处理复杂的配置结构。</ul><p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Component;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@ConfigurationProperties(prefix = "app")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>AppProperties</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>int</span> version;</span><br><span class=line></span><br><span class=line>    <span class=comment>// Getters and Setters</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>配置文件 (<code>application.properties</code>)：</strong><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=meta>app.name</span>=<span class=string>MyApp</span></span><br><span class=line><span class=meta>app.version</span>=<span class=string>1</span></span><br></pre></table></figure><p><strong>(8) <code>@Lookup</code></strong><ul><li><strong>作用</strong>：用于方法注入，每次调用方法时都会返回一个新的 Bean 实例。<li><strong>场景</strong>：适用于原型（Prototype）作用域的 Bean。</ul><p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Scope("prototype")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>PrototypeBean</span> </span>{ }</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=class><span class=keyword>class</span> <span class=title>SingletonBean</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Lookup</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>abstract</span> PrototypeBean <span class=title>getPrototypeBean</span><span class=params>()</span></span>; <span class=comment>// 每次调用返回新的实例</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>3. 其他相关注解</strong><p><strong>(9) <code>@Required</code></strong><ul><li><strong>作用</strong>：标记某个 setter 方法必须注入值，否则抛出异常。<li><strong>注意</strong>：从 Spring 5 开始已被废弃，推荐使用构造器注入或 <code>@Autowired(required = true)</code>。</ul><p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserService</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> UserRepository userRepository;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Required</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>setUserRepository</span><span class=params>(UserRepository userRepository)</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.userRepository = userRepository;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>(10) <code>@Lazy</code></strong><ul><li><strong>作用</strong>：延迟加载 Bean，只有在第一次使用时才会被创建。<li><strong>特点</strong>：可以减少启动时间，适用于不常用的功能。</ul><p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Lazy</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>LazyBean</span> </span>{ }</span><br><span class=line></span><br><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserService</span> </span>{</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> LazyBean lazyBean; <span class=comment>// 延迟加载</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>4. 总结</strong><div class=table-container><table><thead><tr><th>注解<th>功能描述<th>特点<tbody><tr><td><code>@Autowired</code><td>自动注入依赖，按类型匹配<td>默认按类型，支持配合 <code>@Qualifier</code> 使用<tr><td><code>@Qualifier</code><td>指定要注入的 Bean 名称<td>按名称匹配<tr><td><code>@Primary</code><td>标记首选 Bean<td>简化多 Bean 场景下的注入<tr><td><code>@Resource</code><td>按名称或类型注入<td>JSR-250 标准注解<tr><td><code>@Inject</code><td>按类型注入<td>JSR-330 标准注解<tr><td><code>@Value</code><td>注入简单值或配置文件中的值<td>支持占位符和 SpEL<tr><td><code>@ConfigurationProperties</code><td>批量注入配置文件中的属性<td>适合复杂配置<tr><td><code>@Lookup</code><td>方法注入，每次返回新实例<td>适用于原型作用域<tr><td><code>@Required</code><td>强制要求注入<td>已废弃，推荐使用其他方式<tr><td><code>@Lazy</code><td>延迟加载 Bean<td>减少启动时间</table></div><h3 id=AOP的底层原理><a class=headerlink href=#AOP的底层原理 title=AOP的底层原理></a>AOP的底层原理</h3><p>如何把切面织入到核心逻辑中？这正是AOP需要解决的问题。换句话说，如果客户端获得了<code>BookService</code>的引用，当调用<code>bookService.createBook()</code>时，如何对调用方法进行拦截，并在拦截前后进行安全检查、日志、事务等处理，就相当于完成了所有业务功能。<p>在Java平台上，对于AOP的织入，有3种方式：<ol><li>编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ就扩展了Java编译器，使用关键字aspect来实现织入；<li>类加载器：在目标类被装载到JVM时，通过一个特殊的类加载器，对目标类的字节码重新“增强”；<li>运行期：目标对象和切面都是普通Java类，通过JVM的动态代理功能或者第三方库实现运行期动态织入。</ol><p>最简单的方式是第三种，Spring的AOP实现就是基于JVM的动态代理。由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过<a href=https://github.com/cglib/cglib rel=noopener target=_blank>CGLIB</a>或者<a href=https://www.javassist.org/ rel=noopener target=_blank>Javassist</a>这些第三方库实现。<p>AOP 的几个核心概念：<h4 id=AOP七大术语><a class=headerlink href=#AOP七大术语 title=AOP七大术语></a>AOP七大术语</h4><ul><li><strong>切面（Aspect）</strong>：一个模块化的关注点，例如日志记录、事务管理等。<li><strong>连接点（Join Point）</strong>：程序执行过程中的某个特定点，例如方法调用或异常抛出。<li><strong>通知（Advice）</strong>：在连接点执行的动作，分为前置通知、后置通知、环绕通知等。<li><strong>切入点（Pointcut）</strong>：定义哪些连接点会被通知。<li><strong>目标对象（Target Object）</strong>：被代理的对象。<li><strong>代理对象（Proxy Object）</strong>：由 AOP 框架创建的包装目标对象的对象。<li><strong>织入（Weaving）</strong>：织入是将切面与业务逻辑代码结合起来的过程。这个过程可以在编译时、类加载时或运行时完成</ul><p>如果<strong>目标对象实现了接口，Spring 默认使用 JDK 动态代理</strong>。JDK 动态代理<strong>通过反射机制创建代理对象，并拦截方法调用</strong>。<p>如果目标对象没有实现接口，Spring 使用 CGLIB 动态代理。<strong>CGLIB 通过继承目标类并重写其方法来创建代理对象</strong>。<ul><li>CGLIB 是一个基于字节码生成的库，它通过 ASM 库操作字节码生成子类。<li>子类会覆盖父类的方法，并在方法调用前后插入自定义逻辑。</ul><p>Spring AOP 封装了动态代理的细节，开发者只需关注切面和通知的定义。<p><strong>(1) 定义切面和通知</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Before;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Component;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>LoggingAspect</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Before("execution(* com.example.service.*.*(..))")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>logBefore</span><span class=params>()</span> </span>{</span><br><span class=line>        System.out.println(<span class=string>"Logging before method execution..."</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>(2) 配置 Spring AOP</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.Configuration;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableAspectJAutoProxy</span> <span class=comment>// 启用 AOP 支持</span></span><br><span class=line><span class=meta>@ComponentScan(basePackages = "com.example")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>AppConfig</span> </span>{</span><br><span class=line>}</span><br></pre></table></figure><p><strong>(3) 测试代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.context.ApplicationContext;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>MainApp</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        ApplicationContext context = <span class=keyword>new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class=line></span><br><span class=line>        Service service = context.getBean(Service.class);</span><br><span class=line>        service.doSomething();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><ul><li>Spring AOP 的底层依赖于动态代理技术。<li>如果目标对象实现了接口，则使用 JDK 动态代理。<li>如果目标对象未实现接口，则使用 CGLIB 动态代理。</ul><p>面向切面编程（Aspect-Oriented Programming, AOP）是一种编程范式，它旨在<strong>通过将横切关注点从核心业务逻辑中分离出来，来提高代码的模块化程度。横切关注点指的是那些影响多个模块的功能，如日志记录、事务管理、安全性等</strong>。AOP的核心思想是将这些功能从业务逻辑中抽离出来，形成独立的模块——即所谓的“切面”.<p>代码复用性强<p>代码易维护<h4 id=切点表达式><a class=headerlink href=#切点表达式 title=切点表达式></a>切点表达式</h4><p>切点表达式（Pointcut Expression）是Spring AOP中用于<strong>指定哪些连接点应当被通知（Advice）所影响的关键部分</strong>。它通过特定的语法来描述匹配条件，从而选择程序执行流程中的某些点作为切点。<p><code>execution</code>是最常用的切点指示器，用来匹配方法执行的连接点。<ul><li><p>语法格式：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) <span class=keyword>throws</span>-pattern?)</span><br></pre></table></figure><li><p>示例：</p> <ul><li><code>execution(public * com.example.service.*.*(..))</code>：匹配<code>com.example.service</code>包下所有公共方法的执行。<li><code>execution(* com.example.service.UserServiceImpl.*(..))</code>：匹配<code>UserServiceImpl</code>类中所有方法的执行。</ul></ul><p><strong>访问控制权限符</strong>: 可选项,没写就是四个权限都包括.写public方法就表示只包括公开的方法.<p><strong>返回值类型</strong>: 必填项 *表示返回值类型任意<p><strong>全限定类名</strong>:可选项 两个点”..”代表当前包及子包下的所有类<p>省略时表示所有的类<p><strong>方法名</strong>: 必填项 *表示所有方法<p><strong>形式参数列表</strong>:必填项 ()表示没有参数的方法,(..)参数类型和个数随意的方法,(*)只有一个参数的方法<p><code>within</code>用来限定匹配特定类型内的连接点。<ul><li><p>语法格式：</p> <figure class="highlight stylus"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=title>within</span><span class=params>(type-pattern)</span></span></span><br></pre></table></figure><li><p>示例：</p> <ul><li><code>within(com.example.service.*)</code>：匹配<code>com.example.service</code>包内所有类的方法。<li><code>within(com.example.service..*)</code>：匹配<code>com.example.service</code>包及其子包内所有类的方法。</ul></ul><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Aspect</span> <span class=comment>// 切面类</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>logDemo</span> </span>{</span><br><span class=line>    <span class=comment>// 交叉业务</span></span><br><span class=line>    <span class=meta>@Before("execution(* com.sekyoro.tutorAOP.*.*(..))")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>log</span><span class=params>()</span> </span>{</span><br><span class=line>        System.out.println(<span class=string>"log"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Before("execution(* com.sekyoro.tutorAOP.*.*(..))")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>transaction</span><span class=params>()</span> </span>{</span><br><span class=line>        System.out.println(<span class=string>"transaction"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>通知类型<ol><li><p><strong>@Before</strong> - 前置通知，在目标方法执行之前执行。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Before("execution(* com.example.service..*(..))")</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>beforeAdvice</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=comment>// 在目标方法执行前执行的逻辑</span></span><br><span class=line>}</span><br></pre></table></figure><li><p><strong>@After (或 @AfterReturning)</strong> - 后置通知，在目标方法成功执行之后执行（即使方法抛出异常，也会执行）。</p> <ul><li>如果你只关心方法正常返回的情况，可以使用 <code>@AfterReturning</code>，它可以访问到返回值。</ul> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@AfterReturning(pointcut = "execution(* com.example.service..*(..))", returning = "result")</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>afterReturningAdvice</span><span class=params>(Object result)</span> </span>{</span><br><span class=line>    <span class=comment>// 在目标方法执行后执行的逻辑，并且可以访问返回值</span></span><br><span class=line>}</span><br></pre></table></figure><li><p><strong>@AfterThrowing</strong> - 异常通知，在目标方法抛出异常后执行。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@AfterThrowing(pointcut = "execution(* com.example.service..*(..))", throwing = "error")</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>afterThrowingAdvice</span><span class=params>(Exception error)</span> </span>{</span><br><span class=line>    <span class=comment>// 在目标方法抛出异常后执行的逻辑，并且可以访问异常对象</span></span><br><span class=line>}</span><br></pre></table></figure><li><p><strong>@Around</strong> - 环绕通知，可以在目标方法执行前后自定义行为，甚至控制是否执行目标方法。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Around("execution(* com.example.service..*(..))")</span></span><br><span class=line><span class=function><span class=keyword>public</span> Object <span class=title>aroundAdvice</span><span class=params>(ProceedingJoinPoint joinPoint)</span> <span class=keyword>throws</span> Throwable </span>{</span><br><span class=line>    <span class=comment>// 在目标方法执行前的逻辑</span></span><br><span class=line>    Object proceed = joinPoint.proceed(); <span class=comment>// 执行目标方法</span></span><br><span class=line>    <span class=comment>// 在目标方法执行后的逻辑</span></span><br><span class=line>    <span class=keyword>return</span> proceed;</span><br><span class=line>}</span><br></pre></table></figure><li><p><strong>@After</strong> - 最终通知，在任何情况下（无论方法正常返回还是抛出异常）都会执行。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@After("execution(* com.example.service..*(..))")</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>afterAdvice</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=comment>// 无论目标方法正常返回还是抛出异常都会执行的逻辑</span></span><br><span class=line>}</span><br></pre></table></figure></ol><p><code>@Order</code> 注解是 Spring 框架提供的一个用于定义组件加载顺序的注解。它可以在类、方法或接口上使用，主要用于控制 Bean 的加载顺序、切面的执行顺序以及组件的处理顺序<p>定义和作用<p><code>@Order</code> 注解可以指定一个整数值作为参数，该值表示加载顺序，数值越小优先级越高。这意味着拥有较小 <code>@Order</code> 值的 Bean 将被优先加载<p>需要注意的是，<strong>这个注解并不影响 Bean 的实例化顺序，而是决定了 Bean 在集合中的排序或者是在自动装配时的顺序</strong>。<p>使用场景<ol><li><p>多个拦截器的执行顺序</p> <p>在 Spring MVC 中，如果有多个拦截器，可以使用@Order来确保它们按照特定顺序执行</p><li><p>切面的执行顺序</p> <p>在 AOP 编程中，如果存在多个切面，可以通过@Order确定它们执行的顺序</p><li><p>事件监听器的执行顺序：当有多个事件监听器监听同一事件时，可以使用@Order来定义它们的执行顺序</p><li><p>定时任务的执行顺序：在 Spring 中，如果有多个定时任务，可以使用@Order来指定它们的执行顺序</p></ol><p><strong>通用切点</strong><p>用切点指的是可以被多个通知（Advice）或者多个切面（Aspect）所共享的切点定义。通过将切点逻辑集中到一个地方来定义，可以在不同的通知或切面中复用这个切点表达式，从而减少重复代码并提高维护性。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Order(1)</span></span><br><span class=line><span class=meta>@Aspect</span> <span class=comment>// 切面类</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>logDemo</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=comment>// 定义通用切点表达式</span></span><br><span class=line>    <span class=meta>@Pointcut("execution(* com.sekyoro.tutorAOP.*.*(..))")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>pointCut</span><span class=params>()</span> </span>{</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 交叉业务</span></span><br><span class=line>    <span class=meta>@Before("pointCut()")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>log</span><span class=params>()</span> </span>{</span><br><span class=line>        System.out.println(<span class=string>"log"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Before("pointCut()")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>transaction</span><span class=params>()</span> </span>{</span><br><span class=line>        System.out.println(<span class=string>"transaction"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>CommonPointcuts</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 定义一个名为 allServiceMethods 的公共切点，</span></span><br><span class=line><span class=comment>     * 该切点匹配 com.example.service 包及其子包下所有服务类中的任意方法。</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=meta>@Pointcut("execution(* com.example.service..*(..))")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>allServiceMethods</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=comment>// 空方法体，因为 Pointcut 注解已经定义了切点逻辑</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Component;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>LoggingAspect</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 假设我们已经有了上面定义的 CommonPointcuts 类</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line></span><br><span class=line>    <span class=meta>@AfterReturning(pointcut = "com.example.CommonPointcuts.allServiceMethods()", returning = "result")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>logServiceAccess</span><span class=params>(Object result)</span> </span>{</span><br><span class=line>        System.out.println(<span class=string>"完成了服务方法调用，结果是: "</span> + result);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=如何管理事务><a class=headerlink href=#如何管理事务 title=如何管理事务></a>如何管理事务</h3><p>事务是一组数据库操作的逻辑单元，这些操作要么全部成功执行（提交），要么全部不执行（回滚）。事务通常用于保证数据在并发访问或异常情况下的完整性和一致性。<p>事务的核心特性可以用 ACID 来概括：<ul><li><strong>原子性（Atomicity）</strong>：事务中的所有操作要么全部完成，要么全部不完成，不允许部分执行。例如，转账操作中扣款和存款必须同时成功。<li><strong>一致性（Consistency）</strong>：事务执行前后，数据库必须从一个一致状态转换到另一个一致状态。例如，转账后账户余额总和不变。<li><strong>隔离性（Isolation）</strong>：多个事务并发执行时，一个事务的执行不应影响其他事务。通常通过隔离级别来控制。<li><strong>持久性（Durability）</strong>：一旦事务提交，其结果必须永久保存在数据库中，即使系统崩溃也能恢复。</ul><p><strong>开始事务（Begin Transaction）</strong>：标记事务的起点。<p><strong>提交（Commit）</strong>：确认所有操作成功，将结果持久化。<p><strong>回滚（Rollback）</strong>：如果发生错误或异常，撤销所有操作，恢复到事务开始前的状态。<h4 id=Spring事务><a class=headerlink href=#Spring事务 title=Spring事务></a>Spring事务</h4><ul><li><p>编程式</p><li><p>声明式</p></ul><p>​ - 基于注解<p>​ - 基于xml<p>Spring声明式事务管理是<strong>通过面向切面编程（AOP）机制实现</strong>的。当Spring容器启动时，如果发现有<code>@EnableTransactionManagement</code>注解存在，那么会拦截所有Bean的创建过程，扫描是否有<code>@Transactional</code>注解的存在。如果有，Spring会通过AOP的方式给Bean生成代理对象，代理对象中会增加一个拦截器，该拦截器会在方法执行之前启动事务，在方法执行完毕之后提交或回滚事务<h4 id=事务属性><a class=headerlink href=#事务属性 title=事务属性></a>事务属性</h4><p><strong>（1）传播行为（Propagation）</strong><p><code>propagation</code> 属性决定<strong>当前事务方法执行时，是否新建事务或加入已有事务</strong>。<div class=table-container><table><thead><tr><th>传播行为<th>说明<tbody><tr><td><code>REQUIRED</code>（默认）<td>如果有事务，则加入；否则创建新事务。<tr><td><code>REQUIRES_NEW</code><td>无论是否已有事务，都创建新事务，暂停旧事务。<tr><td><code>SUPPORTS</code><td>如果有事务，则加入；如果没有，则以非事务方式运行。<tr><td><code>NOT_SUPPORTED</code><td>始终以非事务方式运行，若有事务则挂起。<tr><td><code>MANDATORY</code><td>必须在已有事务中运行，否则抛异常。<tr><td><code>NEVER</code><td>不能在事务中运行，否则抛异常。<tr><td><code>NESTED</code><td>在当前事务中嵌套一个子事务，子事务可以单独回滚。</table></div><p>🔹 <strong>示例</strong>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>saveData</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=comment>// 该方法无论是否存在事务，都会新建一个事务</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>（2）隔离级别（Isolation）</strong><p><code>isolation</code> 属性决定多个事务并发时，数据的可见性。通常数据库提供以下隔离级别：<div class=table-container><table><thead><tr><th>隔离级别<th>说明<th>可能问题<tbody><tr><td><code>DEFAULT</code><td>使用数据库默认隔离级别<td>-<tr><td><code>READ_UNCOMMITTED</code><td>允许读取未提交数据<td>脏读、不可重复读、幻读<tr><td><code>READ_COMMITTED</code><td>只能读取已提交数据<td>可能出现不可重复读、幻读<tr><td><code>REPEATABLE_READ</code><td>事务内多次查询，结果一致<td>可能出现幻读<tr><td><code>SERIALIZABLE</code><td>串行化访问数据，最高隔离级别<td>性能开销大</table></div><p>🔹 <strong>示例</strong>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Transactional(isolation = Isolation.REPEATABLE_READ)</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>processTransaction</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=comment>// 事务中多次查询结果保持一致</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>只读事务（Read-Only）</strong><p><code>readOnly = true</code> 表示事务仅用于查询，不允许数据修改，数据库可能进行优化。<strong>适用于 <code>SELECT</code> 语句，提高性能</strong>。<p>🔹 <strong>示例</strong>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Transactional(readOnly = true)</span></span><br><span class=line><span class=function><span class=keyword>public</span> List&LTUser> <span class=title>findAllUsers</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>return</span> userRepository.findAll();</span><br><span class=line>}</span><br></pre></table></figure><p><strong>注意</strong>：某些数据库（如 MySQL）会对 <code>readOnly=true</code> 进行优化，但仍需手动确保没有写操作。<p><strong>回滚规则（Rollback Rules）</strong><p><code>rollbackFor</code> 和 <code>noRollbackFor</code> 控制事务回滚条件：<ul><li><code>rollbackFor = Exception.class</code>：遇到指定异常回滚（默认只回滚 <code>RuntimeException</code>）。<li><code>noRollbackFor = CustomException.class</code>：遇到指定异常不回滚。</ul><p>🔹 <strong>示例</strong>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Transactional(rollbackFor = Exception.class)</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>processTransaction</span><span class=params>()</span> <span class=keyword>throws</span> Exception </span>{</span><br><span class=line>    <span class=comment>// 遇到任何 Exception（包括 Checked Exception）都会回滚</span></span><br><span class=line>}</span><br><span class=line>javaCopyEdit<span class=meta>@Transactional(noRollbackFor = IllegalArgumentException.class)</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>processWithoutRollback</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=comment>// 遇到 IllegalArgumentException 不回滚</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>超时（Timeout）</strong><p><code>timeout</code> 指定事务的最大执行时间（秒），超时后事务会回滚。默认值 <code>-1</code>（无限制）。<p>🔹 <strong>示例</strong>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>javaCopyEdit<span class=meta>@Transactional(timeout = 5)</span> <span class=comment>// 事务最多执行 5 秒，否则回滚</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>slowTransaction</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=comment>// 事务执行超过 5 秒，会自动回滚</span></span><br><span class=line>}</span><br></pre></table></figure><p>超时时间记录的是直到最后一条DML语句执行完成的时间.<p>Spring 的事务管理通过动态代理实现，默认使用 <strong>JDK 动态代理</strong> 或 <strong>CGLIB 代理</strong> 来为目标对象创建一个代理对象。事务拦截器会在代理对象上调用方法时生效，从而开启或管理事务。<p><strong>关键点：</strong><ul><li>当你在目标对象内部直接调用另一个方法时，调用并不会经过代理对象，而是直接在目标对象本身上执行。<li>因此，事务拦截器无法介入，事务也就不会生效</ul><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>MyService</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Transactional</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>methodA</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=comment>// 自调用 methodB</span></span><br><span class=line>        methodB(); <span class=comment>// 不会触发事务</span></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Transactional</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>methodB</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=comment>// 数据库操作</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>在这个例子中：<ol><li><code>methodA()</code> 调用了 <code>methodB()</code>。<li>由于 <code>methodB()</code> 是目标对象内部的方法调用，调用不会经过代理对象，因此事务拦截器不会对 <code>methodB()</code> 生效。</ol><p>为了确保事务在自调用时也能生效，可以采取以下几种解决方法：<p><strong>(1) 使用 AOP 代理对象显式调用</strong><p>通过获取当前类的代理对象来调用目标方法，从而确保事务拦截器生效。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>MyService</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> ApplicationContext applicationContext;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Transactional</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>methodA</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=comment>// 获取代理对象</span></span><br><span class=line>        MyService proxy = applicationContext.getBean(MyService.class);</span><br><span class=line>        proxy.methodB(); <span class=comment>// 通过代理对象调用</span></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Transactional</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>methodB</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=comment>// 数据库操作</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>(2) 使用 <code>AopContext.currentProxy()</code></strong><p>通过 <code>AopContext.currentProxy()</code> 获取当前代理对象，并调用目标方法<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>MyService</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Transactional</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>methodA</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=comment>// 获取当前代理对象</span></span><br><span class=line>        MyService proxy = (MyService) AopContext.currentProxy();</span><br><span class=line>        proxy.methodB(); <span class=comment>// 通过代理对象调用</span></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Transactional</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>methodB</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=comment>// 数据库操作</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>注意：</strong> 使用 <code>AopContext.currentProxy()</code> 时，需要在 Spring 配置中启用暴露代理对象的功能：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=meta>@EnableAspectJAutoProxy(exposeProxy = true)</span></span><br></pre></table></figure><p><strong>(3) 将方法拆分到不同的类中</strong><p>将需要事务管理的方法拆分到另一个服务类中，这样可以通过代理对象调用该方法。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>MyService</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> AnotherService anotherService;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Transactional</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>methodA</span><span class=params>()</span> </span>{</span><br><span class=line>        anotherService.methodB(); <span class=comment>// 调用另一个类的方法</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>AnotherService</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Transactional</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>methodB</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=comment>// 数据库操作</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>这种方式利用了不同类之间的调用，确保事务管理能够正常工作。<div class=table-container><table><thead><tr><th>方法<th>优点<th>缺点<tbody><tr><td><strong>自调用（不推荐）</strong><td>简单直接<td>事务不生效<tr><td><strong>通过 <code>ApplicationContext</code> 获取代理对象</strong><td>灵活，适用于复杂的场景<td>需要注入 <code>ApplicationContext</code>，稍显冗长<tr><td><strong>使用 <code>AopContext.currentProxy()</code></strong><td>简洁，避免额外的依赖<td>需要启用 <code>exposeProxy</code> 配置<tr><td><strong>拆分到不同的类中</strong><td>符合单一职责原则，结构清晰<td>可能增加类的数量</table></div><h3 id=如何处理循环依赖><a class=headerlink href=#如何处理循环依赖 title=如何处理循环依赖></a>如何处理循环依赖</h3><p>在 Spring 中，<strong>循环依赖</strong>是指两个或多个 Bean 在初始化过程中相互依赖。例如：<ul><li><strong>Bean A</strong> 依赖于 <strong>Bean B</strong>；<li><strong>Bean B</strong> 又依赖于 <strong>Bean A</strong>。</ul><p>Spring 容器通过一些机制来处理循环依赖问题，但并不是所有类型的循环依赖都能被解决<p>循环依赖可以分为以下几种情况：<p><strong>(1) 构造函数注入的循环依赖</strong><p>当两个 Bean 使用构造函数注入时，如果它们之间存在循环依赖，则 Spring 无法解决这种循环依赖，会抛出 <code>BeanCurrentlyInCreationException</code> 异常。<p><strong>示例代码：</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>BeanA</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> BeanB beanB;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>BeanA</span><span class=params>(BeanB beanB)</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.beanB = beanB;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>BeanB</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> BeanA beanA;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>BeanB</span><span class=params>(BeanA beanA)</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.beanA = beanA;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>在这种情况下，Spring 无法创建任何一个 Bean，因为它们互相依赖且都需要完全初始化后才能使用<p><strong>(2) Setter 方法或字段注入的循环依赖</strong><p>当两个 Bean 使用 setter 方法或字段注入时，Spring 可以解决这种循环依赖。<p><strong>示例代码：</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>BeanA</span> </span>{</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> BeanB beanB;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>BeanB</span> </span>{</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> BeanA beanA;</span><br><span class=line>}</span><br></pre></table></figure><p>Spring 能够通过提前暴露未完全初始化的 Bean 来解决这种循环依赖。<p><strong>Spring 处理循环依赖的机制</strong><p>Spring 容器通过三级缓存（singleton caches）和提前暴露未完全初始化的 Bean 来解决循环依赖问题。<p><strong>(1) 单例 Bean 的三级缓存</strong><p>Spring 容器维护了三个缓存来管理单例 Bean 的生命周期：<ol><li>一级缓存（singletonObjects）<ul><li>存储已经完全初始化完成的 Bean。<li>当 Bean 完全初始化后，会从二级缓存移动到一级缓存。</ul><li>二级缓存（earlySingletonObjects）<ul><li>存储未完全初始化但已经被提前暴露的 Bean。<li>当一个 Bean 正在初始化但还未完成时，Spring 会将其放入二级缓存中，以便其他 Bean 可以引用它。</ul><li>三级缓存（singletonFactories）<ul><li>存储 Bean 的工厂对象（ObjectFactory），用于动态生成未完全初始化的 Bean。<li>当需要提前暴露一个 Bean 时，Spring 会先将其工厂对象放入三级缓存。</ul></ol><p><strong>(2) 提前暴露未完全初始化的 Bean</strong><p>当 Spring 发现一个 Bean 正在初始化且有其他 Bean 需要引用它时，Spring 会提前暴露该 Bean 的实例（即使它还未完全初始化）。这通过以下步骤实现：<ol><li>创建 Bean 实例（调用构造函数）。<li>将 Bean 实例的工厂对象放入三级缓存。<li>如果需要提前暴露，将工厂对象生成的 Bean 放入二级缓存。<li>其他 Bean 可以从二级缓存中获取该未完全初始化的 Bean。<li>当 Bean 完全初始化后，将其移入一级缓存。</ol><p>这种方式适用于基于 setter 方法或字段注入的循环依赖。<p><strong>3. 为什么构造函数注入的循环依赖无法解决？</strong><p>构造函数注入要求 Bean 必须在完全初始化后才能被使用。因此，当两个 Bean 通过构造函数相互依赖时，Spring 无法满足它们的初始化顺序要求。以下是具体原因：<ol><li><strong>Bean A</strong> 需要 <strong>Bean B</strong> 的完全初始化实例。<li><strong>Bean B</strong> 需要 <strong>Bean A</strong> 的完全初始化实例。<li>由于两者都处于“正在初始化”状态，Spring 无法完成任意一方的初始化。</ol><p>一个 Bean 被认为是<strong>完全初始化</strong>的，当它已经通过了所有的初始化步骤，并且可以安全地用于应用程序中。这些步骤通常包括：<ul><li><strong>实例化</strong>：创建 Bean 的实例。<li><strong>属性填充</strong>：为 Bean 的属性设置值或注入依赖（通过构造函数、setter 方法或字段注入）。<li><strong>Aware 接口回调</strong>：如果 Bean 实现了特定的 <code>Aware</code> 接口（如 <code>BeanNameAware</code>, <code>BeanFactoryAware</code>, <code>ApplicationContextAware</code> 等），Spring 会调用相应的方法，让 Bean 能够访问到容器的相关信息。<li><strong>初始化方法调用</strong>：如果有定义初始化方法（通过 <code>@PostConstruct</code> 注解或 <code>&LTbean></code> 元素中的 <code>init-method</code> 属性），Spring 会在该阶段调用这些方法。</ul><p>​ 一旦所有这些步骤都完成了，这个 Bean 就被认为是完全初始化的，并被放入 Spring 容器的一级缓存（singletonObjects）中，供其他组件使用。<p>一个 Bean 被认为是<strong>未完全初始化</strong>的，是指它正处于初始化过程中的某个中间状态。例如，在某些情况下，Bean 已经被实例化并注入了一些依赖，但尚未完成所有的初始化步骤（比如还没有调用初始化方法）。这种状态下，Bean 还不能完全满足其契约要求，因此可能不适合直接使用。<p>​ 在处理循环依赖时，Spring 使用一种称为“提前暴露”的机制来解决 Setter 或字段注入引起的循环依赖问题。具体来说，当 Spring 正在初始化一个 Bean A 时，如果发现另一个 Bean B 需要引用 Bean A，而此时 Bean A 尚未完全初始化，Spring 会将 Bean A 提前暴露出来，尽管它还未经过全部的初始化步骤。这种提前暴露的 Bean 只完成了实例化和部分依赖注入，但尚未执行 Aware 接口回调、初始化方法等后续步骤。<h3 id=代理模式><a class=headerlink href=#代理模式 title=代理模式></a>代理模式</h3><p><strong>静态代理</strong><p>对于安全检查、日志、事务等代码，它们会重复出现在每个业务方法中。使用OOP，我们很难将这些四处分散的代码模块化<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>SecurityCheckBookService</span> <span class=keyword>implements</span> <span class=title>BookService</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> BookService target;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>SecurityCheckBookService</span><span class=params>(BookService target)</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.target = target;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>createBook</span><span class=params>(Book book)</span> </span>{</span><br><span class=line>        securityCheck();</span><br><span class=line>        target.createBook(book);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>updateBook</span><span class=params>(Book book)</span> </span>{</span><br><span class=line>        securityCheck();</span><br><span class=line>        target.updateBook(book);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>deleteBook</span><span class=params>(Book book)</span> </span>{</span><br><span class=line>        securityCheck();</span><br><span class=line>        target.deleteBook(book);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>private</span> <span class=keyword>void</span> <span class=title>securityCheck</span><span class=params>()</span> </span>{</span><br><span class=line>        ...</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><p><strong>动态代理</strong><p>在内存中动态生成字节码代理类<p>JDK动态代理技术:只能代理接口.这是Java标准库提供的一种代理方式，要求被代理的目标对象必须实现了接口。Spring会在目标对象实现了接口时默认使用这种代理方式。JDK动态代理主要通过<code>java.lang.reflect.Proxy</code>类来创建代理对象，并通过<code>InvocationHandler</code>接口来处理代理对象的方法调用。<p>CGLIB:当目标对象没有实现任何接口时，Spring会使用CGLIB（Code Generation Library）来为该类创建子类，并覆盖其方法以实现代理。CGLIB通过继承的方式进行代理，因此不能对final类或final方法进行代理。与JDK动态代理相比，CGLIB代理不需要目标对象实现接口，但是性能上可能会稍逊一筹。<blockquote><p>从Spring 4.0开始，默认情况下即使目标对象实现了多个接口，Spring也会尝试使用CGLIB代理，除非特别配置了只使用JDK动态代理</blockquote><p>JDK动态代理<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.lang.reflect.InvocationHandler;</span><br><span class=line><span class=keyword>import</span> java.lang.reflect.Method;</span><br><span class=line><span class=keyword>import</span> java.lang.reflect.Proxy;</span><br><span class=line></span><br><span class=line><span class=comment>// 定义接口</span></span><br><span class=line><span class=class><span class=keyword>interface</span> <span class=title>UserService</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>addUser</span><span class=params>(String name)</span></span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 实现类</span></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>UserServiceImpl</span> <span class=keyword>implements</span> <span class=title>UserService</span> </span>{</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>addUser</span><span class=params>(String name)</span> </span>{</span><br><span class=line>        System.out.println(<span class=string>"Adding user: "</span> + name);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 动态代理处理器</span></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>MyInvocationHandler</span> <span class=keyword>implements</span> <span class=title>InvocationHandler</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> Object target; <span class=comment>// 被代理的目标对象</span></span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>MyInvocationHandler</span><span class=params>(Object target)</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.target = target;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> Object <span class=title>invoke</span><span class=params>(Object proxy, Method method, Object[] args)</span> <span class=keyword>throws</span> Throwable </span>{</span><br><span class=line>        <span class=comment>// 在方法调用前执行逻辑</span></span><br><span class=line>        System.out.println(<span class=string>"Before method: "</span> + method.getName());</span><br><span class=line></span><br><span class=line>        <span class=comment>// 调用目标对象的方法</span></span><br><span class=line>        Object result = method.invoke(target, args);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 在方法调用后执行逻辑</span></span><br><span class=line>        System.out.println(<span class=string>"After method: "</span> + method.getName());</span><br><span class=line></span><br><span class=line>        <span class=keyword>return</span> result;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 测试类</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>JdkDynamicProxyExample</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        <span class=comment>// 创建目标对象</span></span><br><span class=line>        UserService userService = <span class=keyword>new</span> UserServiceImpl();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 创建代理对象</span></span><br><span class=line>        UserService proxyInstance = (UserService) Proxy.newProxyInstance(</span><br><span class=line>                userService.getClass().getClassLoader(),</span><br><span class=line>                userService.getClass().getInterfaces(),</span><br><span class=line>                <span class=keyword>new</span> MyInvocationHandler(userService)</span><br><span class=line>        );</span><br><span class=line></span><br><span class=line>        <span class=comment>// 调用代理对象的方法</span></span><br><span class=line>        proxyInstance.addUser(<span class=string>"Alice"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>CGLIB动态代理</strong><p>CGLIB（Code Generation Library）是一个强大的、高性能的代码生成库，它允许在运行时扩展Java类和实现接口。CGLIB动态代理主要通过继承的方式来实现代理对象，而不是像JDK动态代理那样基于接口。以下是关于CGLIB动态代理的关键点：<p><strong>工作原理</strong><ul><li>CGLIB通过字节码技术为代理对象创建一个子类，并在子类中重写父类中的非final方法。<li>在调用这些重写的方法时，会先经过用户自定义的拦截器（<code>MethodInterceptor</code>），然后可以选择性地调用父类的方法。</ul><p><strong>使用场景</strong><ul><li>当目标对象没有实现任何接口时，可以使用CGLIB来创建代理对象。<li>对于那些需要对现有类进行功能增强，而不想修改原始类的情况下，CGLIB也是一个不错的选择。</ul><p><strong>与JDK动态代理的区别</strong><ul><li><strong>依赖</strong>：JDK动态代理要求被代理类必须实现至少一个接口；CGLIB则不需要，它可以代理普通的类。<li><strong>性能</strong>：CGLIB代理的执行速度通常比JDK动态代理快，因为它直接生成了目标类的子类，而JDK动态代理是基于反射机制的。<li><strong>限制</strong>：CGLIB不能代理final类或final方法，因为子类无法覆盖它们</ul><h2 id=springmvc><a class=headerlink href=#springmvc title=springmvc></a>springmvc</h2><blockquote><p>拦截器<p>过滤器</blockquote><p><a href=https://springdoc.cn/spring-mvc-tutorial/ rel=noopener target=_blank>Spring MVC 教程 - spring 中文网</a><p>Spring 框架中处理模型（Model）- 视图（View）- 控制器（Controller）或 MVC 模式的一个模块。它结合了 MVC 模式的所有优点和 Spring 的便利性。<p>Spring 使用其 <code>DispatcherServlet</code> 前控制器模式实现 MVC。<p>简而言之，<code>DispatcherServlet</code> 是将请求路由到预定目的地的主要控制器。Model 只是应用的数据，而视图则由各种模板引擎来表示。<p>包含spring的依赖同时使用servlet等实现MVC架构的Web开发.<p>servlet如下<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.io.IOException;</span><br><span class=line><span class=keyword>import</span> javax.servlet.ServletException;</span><br><span class=line><span class=keyword>import</span> javax.servlet.annotation.WebServlet;</span><br><span class=line><span class=keyword>import</span> javax.servlet.http.HttpServlet;</span><br><span class=line><span class=keyword>import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=line><span class=keyword>import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=line></span><br><span class=line><span class=meta>@WebServlet("/hello")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>HelloServlet</span> <span class=keyword>extends</span> <span class=title>HttpServlet</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>final</span> <span class=keyword>long</span> serialVersionUID = <span class=number>1L</span>;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>protected</span> <span class=keyword>void</span> <span class=title>doGet</span><span class=params>(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class=line><span class=function>            <span class=keyword>throws</span> ServletException, IOException </span>{</span><br><span class=line>        response.setContentType(<span class=string>"text/html"</span>);</span><br><span class=line>        response.getWriter().println(<span class=string>"&LTh1>Hello, World!&LT/h1>"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>springmvc的示例代码如下.<p>要通过 Java 配置类启用 Spring MVC 支持，只需添加 <code>@EnableWebMvc</code><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=meta>@EnableWebMvc</span></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>WebConfig</span> <span class=keyword>implements</span> <span class=title>WebMvcConfigurer</span> </span>{</span><br><span class=line></span><br><span class=line>   <span class=meta>@Override</span></span><br><span class=line>   <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>addViewControllers</span><span class=params>(ViewControllerRegistry registry)</span> </span>{</span><br><span class=line>      registry.addViewController(<span class=string>"/"</span>).setViewName(<span class=string>"index"</span>);</span><br><span class=line>   }</span><br><span class=line></span><br><span class=line>   <span class=meta>@Bean</span></span><br><span class=line>   <span class=function><span class=keyword>public</span> ViewResolver <span class=title>viewResolver</span><span class=params>()</span> </span>{</span><br><span class=line>      InternalResourceViewResolver bean = <span class=keyword>new</span> InternalResourceViewResolver();</span><br><span class=line></span><br><span class=line>      <span class=comment>//bean.setViewClass(JstlView.class); in older version</span></span><br><span class=line>      bean.setPrefix(<span class=string>"/WEB-INF/view/"</span>);</span><br><span class=line>      bean.setSuffix(<span class=string>".jsp"</span>);</span><br><span class=line></span><br><span class=line>      <span class=keyword>return</span> bean;</span><br><span class=line>   }</span><br><span class=line>}</span><br></pre></table></figure><p>这将设置 MVC 项目所需的基本支持，如注册处理器、映射器、类型转换器、验证支持、消息转换器和异常处理。本例中注册了一个 <code>ViewResolver</code> Bean，它从 <code>/WEB-INF/view</code> 目录返回 <code>.jsp</code> 视图。可以注册视图控制器（ViewController），使用 <code>ViewControllerRegistry</code> 在 URL 和视图名称之间创建直接映射。这样，两者之间就不需要任何 Controller 了。<p>如果想自定义扫描 Controller 类，可以使用 <code>@ComponentScan</code> 注解，并指定包含 Controller 的包。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=meta>@EnableWebMvc</span></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@ComponentScan(basePackages = { "com.baeldung.web.controller" })</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>WebConfig</span> <span class=keyword>implements</span> <span class=title>WebMvcConfigurer</span> </span>{</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>为了引导应用加载该配置，还需要一个 Initializer 类：<blockquote><p>在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。 Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。</blockquote><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>MainWebAppInitializer</span> <span class=keyword>implements</span> <span class=title>WebApplicationInitializer</span> </span>{</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>onStartup</span><span class=params>(<span class=keyword>final</span> ServletContext sc)</span> <span class=keyword>throws</span> ServletException </span>{</span><br><span class=line></span><br><span class=line>        AnnotationConfigWebApplicationContext root = </span><br><span class=line>          <span class=keyword>new</span> AnnotationConfigWebApplicationContext();</span><br><span class=line>        </span><br><span class=line>        root.scan(<span class=string>"com.baeldung"</span>);</span><br><span class=line>        sc.addListener(<span class=keyword>new</span> ContextLoaderListener(root));</span><br><span class=line></span><br><span class=line>        ServletRegistration.Dynamic appServlet = </span><br><span class=line>          sc.addServlet(<span class=string>"mvc"</span>, <span class=keyword>new</span> DispatcherServlet(<span class=keyword>new</span> GenericWebApplicationContext()));</span><br><span class=line>        appServlet.setLoadOnStartup(<span class=number>1</span>);</span><br><span class=line>        appServlet.addMapping(<span class=string>"/"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>MyWebAppInitializer</span> <span class=keyword>extends</span> <span class=title>AbstractAnnotationConfigDispatcherServletInitializer</span> </span>{</span><br><span class=line> </span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>protected</span> Class&LT?>[] getRootConfigClasses() {</span><br><span class=line>        <span class=comment>// 返回应用级别的配置类</span></span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> Class&LT?>[]{RootConfig.class};</span><br><span class=line>    }</span><br><span class=line> </span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>protected</span> Class&LT?>[] getServletConfigClasses() {</span><br><span class=line>        <span class=comment>// 返回与 DispatcherServlet 相关的配置类</span></span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> Class&LT?>[]{WebConfig.class};</span><br><span class=line>    }</span><br><span class=line> </span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>protected</span> String[] getServletMappings() {</span><br><span class=line>        <span class=comment>// 设置 DispatcherServlet 的 URL 映射</span></span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> String[]{<span class=string>"/"</span>};</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>一个基本的 Controller 示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Controller</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>SampleController</span> </span>{</span><br><span class=line>    <span class=meta>@GetMapping("/sample")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> String <span class=title>showForm</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"sample"</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><p>相应的 JSP 资源是 <code>sample.jsp</code>：<figure class="highlight html"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>html</span>></span></span><br><span class=line>   <span class=tag><<span class=name>head</span>></span><span class=tag>&LT/<span class=name>head</span>></span></span><br><span class=line></span><br><span class=line>   <span class=tag><<span class=name>body</span>></span></span><br><span class=line>      <span class=tag><<span class=name>h1</span>></span>This is the body of the sample view<span class=tag>&LT/<span class=name>h1</span>></span></span><br><span class=line>   <span class=tag>&LT/<span class=name>body</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>html</span>></span></span><br></pre></table></figure><p>基于 <code>JSP</code> 的视图文件位于项目的 <code>/WEB-INF</code> 文件夹下，因此只有 Spring 才能访问它们，而不能直接通过 URL 访问。<p>也可以使用纯 XML 配置来代替上述 Java 配置：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>context:component-scan</span> <span class=attr>base-package</span>=<span class=string>"com.baeldung.web.controller"</span> /></span></span><br><span class=line><span class=tag><<span class=name>mvc:annotation-driven</span> /></span>    </span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"viewResolver"</span> </span></span><br><span class=line><span class=tag>      <span class=attr>class</span>=<span class=string>"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"prefix"</span> <span class=attr>value</span>=<span class=string>"/WEB-INF/view/"</span> /></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"suffix"</span> <span class=attr>value</span>=<span class=string>".jsp"</span> /></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>mvc:view-controller</span> <span class=attr>path</span>=<span class=string>"/"</span> <span class=attr>view-name</span>=<span class=string>"index"</span> /></span></span><br><span class=line></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure><p>如果想使用纯 XML 配置，还需要添加一个 <code>web.xml</code> 文件来引导应用。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>servlet</span>></span></span><br><span class=line>    <span class=tag><<span class=name>servlet-name</span>></span>dispatcher<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>    <span class=tag><<span class=name>servlet-class</span>></span></span><br><span class=line>        org.springframework.web.servlet.DispatcherServlet</span><br><span class=line>    <span class=tag>&LT/<span class=name>servlet-class</span>></span></span><br><span class=line>    <span class=tag><<span class=name>init-param</span>></span></span><br><span class=line>        <span class=tag><<span class=name>param-name</span>></span>contextConfigLocation<span class=tag>&LT/<span class=name>param-name</span>></span></span><br><span class=line>        <span class=tag><<span class=name>param-value</span>></span>/WEB-INF/spring/dispatcher-config.xml<span class=tag>&LT/<span class=name>param-value</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>init-param</span>></span></span><br><span class=line>    <span class=tag><<span class=name>load-on-startup</span>></span>1<span class=tag>&LT/<span class=name>load-on-startup</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servlet</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>servlet-mapping</span>></span></span><br><span class=line>    <span class=tag><<span class=name>servlet-name</span>></span>dispatcher<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>    <span class=tag><<span class=name>url-pattern</span>></span>/<span class=tag>&LT/<span class=name>url-pattern</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servlet-mapping</span>></span></span><br></pre></table></figure><h2 id=springboot><a class=headerlink href=#springboot title=springboot></a>springboot</h2><p><a href=https://springdoc.cn/spring-boot/ rel=noopener target=_blank>Spring Boot 中文文档</a><p><a href=https://spring.io/ rel=noopener target=_blank>Spring | Home</a><p>Spring Boot 是对 Spring 平台的补充，它能让你轻松上手并创建独立的生产级应用。Spring Boot 的目的不是取代 Spring，而是让使用 Spring 变得更快、更简单。<p><strong>pring Boot Starter</strong><p>Spring Boot 提供了便捷的 Starter 依赖，这是一种依赖描述符，可以为特定功能引入所有必要的技术。<p>这样做的好处是，不再需要为每个依赖项指定版本，而是让 Starter 管理依赖。<p>最快捷的入门方法是在 <code>pom.xml</code> 中添加 <code>spring-boot-starter-parent</code>：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>parent</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>spring-boot-starter-parent<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>parent</span>></span></span><br></pre></table></figure><p>这样就能解决依赖管理问题。<p><strong>Spring Boot 入口点</strong><p>使用 Spring Boot 构建的每个应用都需定义 main 入口点。<p>这通常是一个 Java 类，带有 main 方法，并用 <code>@SpringBootApplication</code> 进行注解：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=meta>@SpringBootApplication</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>Application</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        SpringApplication.run(Application.class, args);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>该注解添加了以下其他注解：<ul><li><code>@Configuration</code> 将类标记为 bean 定义的来源。<li><code>@EnableAutoConfiguration</code> 会告诉框架根据 classpath 上的依赖自动添加 Bean。<li><code>@ComponentScan</code> 会扫描与 Application 类相同包或其子包中的其他配置和 Bean。</ul><p>有了 Spring Boot，就可以使用 Thymeleaf 或 JSP 设置前端，而无需使用定义的 <code>ViewResolver</code>。在 <code>pom.xml</code> 中添加 <code>spring-boot-starter-thymeleaf</code> 依赖后，Thymeleaf 就会启用，无需额外配置。<h4 id=application-yml><a class=headerlink href=#application-yml title=application.yml></a>application.yml</h4><p>这是Spring Boot默认的配置文件，它采用<a href=https://yaml.org/ rel=noopener target=_blank>YAML</a>格式而不是<code>.properties</code>格式，文件名必须是<code>application.yml</code>而不是其他名称。<p>YAML格式比<code>key=value</code>格式的<code>.properties</code>文件更易读。比较一下两者的写法：<p>使用<code>.properties</code>格式：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=comment># application.properties</span></span><br><span class=line></span><br><span class=line><span class=meta>spring.application.name</span>=<span class=string>${APP_NAME:unnamed}</span></span><br><span class=line></span><br><span class=line><span class=meta>spring.datasource.url</span>=<span class=string>jdbc:hsqldb:file:testdb</span></span><br><span class=line><span class=meta>spring.datasource.username</span>=<span class=string>sa</span></span><br><span class=line><span class=meta>spring.datasource.password</span>=<span class=string></span></span><br><span class=line><span class=meta>spring.datasource.driver-class-name</span>=<span class=string>org.hsqldb.jdbc.JDBCDriver</span></span><br><span class=line></span><br><span class=line><span class=meta>spring.datasource.hikari.auto-commit</span>=<span class=string>false</span></span><br><span class=line><span class=meta>spring.datasource.hikari.connection-timeout</span>=<span class=string>3000</span></span><br><span class=line><span class=meta>spring.datasource.hikari.validation-timeout</span>=<span class=string>3000</span></span><br><span class=line><span class=meta>spring.datasource.hikari.max-lifetime</span>=<span class=string>60000</span></span><br><span class=line><span class=meta>spring.datasource.hikari.maximum-pool-size</span>=<span class=string>20</span></span><br><span class=line><span class=meta>spring.datasource.hikari.minimum-idle</span>=<span class=string>1</span></span><br></pre></table></figure><p>使用YAML格式：<figure class="highlight yaml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=comment># application.yml</span></span><br><span class=line></span><br><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>application:</span></span><br><span class=line>    <span class=attr>name:</span> <span class=string>${APP_NAME:unnamed}</span></span><br><span class=line>  <span class=attr>datasource:</span></span><br><span class=line>    <span class=attr>url:</span> <span class=string>jdbc:hsqldb:file:testdb</span></span><br><span class=line>    <span class=attr>username:</span> <span class=string>sa</span></span><br><span class=line>    <span class=attr>password:</span></span><br><span class=line>    <span class=attr>driver-class-name:</span> <span class=string>org.hsqldb.jdbc.JDBCDriver</span></span><br><span class=line>    <span class=attr>hikari:</span></span><br><span class=line>      <span class=attr>auto-commit:</span> <span class=literal>false</span></span><br><span class=line>      <span class=attr>connection-timeout:</span> <span class=number>3000</span></span><br><span class=line>      <span class=attr>validation-timeout:</span> <span class=number>3000</span></span><br><span class=line>      <span class=attr>max-lifetime:</span> <span class=number>60000</span></span><br><span class=line>      <span class=attr>maximum-pool-size:</span> <span class=number>20</span></span><br><span class=line>      <span class=attr>minimum-idle:</span> <span class=number>1</span></span><br></pre></table></figure><p>可见，YAML是一种层级格式，它和<code>.properties</code>很容易互相转换，它的优点是去掉了大量重复的前缀，并且更加易读。<h3 id=使用环境变量><a class=headerlink href=#使用环境变量 title=使用环境变量></a>使用环境变量</h3><p>在配置文件中，我们经常使用如下的格式对某个key进行配置：<figure class="highlight yaml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=attr>app:</span></span><br><span class=line>  <span class=attr>db:</span></span><br><span class=line>    <span class=attr>host:</span> <span class=string>${DB_HOST:localhost}</span></span><br><span class=line>    <span class=attr>user:</span> <span class=string>${DB_USER:root}</span></span><br><span class=line>    <span class=attr>password:</span> <span class=string>${DB_PASSWORD:password}</span></span><br></pre></table></figure><p>这种<code>${DB_HOST:localhost}</code>意思是，首先从环境变量查找<code>DB_HOST</code>，如果环境变量定义了，那么使用环境变量的值，否则，使用默认值<code>localhost</code>。<p>这使得我们在开发和部署时更加方便，因为开发时无需设定任何环境变量，直接使用默认值即本地数据库，而实际线上运行的时候，只需要传入环境变量即可<h3 id=logback-spring-xml><a class=headerlink href=#logback-spring-xml title=logback-spring.xml></a>logback-spring.xml</h3><p>这是Spring Boot的logback配置文件名称（也可以使用<code>logback.xml</code>），一个标准的写法如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version="1.0" encoding="UTF-8"?></span></span><br><span class=line><span class=tag><<span class=name>configuration</span>></span></span><br><span class=line>    <span class=tag><<span class=name>include</span> <span class=attr>resource</span>=<span class=string>"org/springframework/boot/logging/logback/defaults.xml"</span> /></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>appender</span> <span class=attr>name</span>=<span class=string>"CONSOLE"</span> <span class=attr>class</span>=<span class=string>"ch.qos.logback.core.ConsoleAppender"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>encoder</span>></span></span><br><span class=line>            <span class=tag><<span class=name>pattern</span>></span>${CONSOLE_LOG_PATTERN}<span class=tag>&LT/<span class=name>pattern</span>></span></span><br><span class=line>            <span class=tag><<span class=name>charset</span>></span>utf8<span class=tag>&LT/<span class=name>charset</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>encoder</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>appender</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>appender</span> <span class=attr>name</span>=<span class=string>"APP_LOG"</span> <span class=attr>class</span>=<span class=string>"ch.qos.logback.core.rolling.RollingFileAppender"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>encoder</span>></span></span><br><span class=line>            <span class=tag><<span class=name>pattern</span>></span>${FILE_LOG_PATTERN}<span class=tag>&LT/<span class=name>pattern</span>></span></span><br><span class=line>            <span class=tag><<span class=name>charset</span>></span>utf8<span class=tag>&LT/<span class=name>charset</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>encoder</span>></span></span><br><span class=line>          <span class=tag><<span class=name>file</span>></span>app.log<span class=tag>&LT/<span class=name>file</span>></span></span><br><span class=line>        <span class=tag><<span class=name>rollingPolicy</span> <span class=attr>class</span>=<span class=string>"ch.qos.logback.core.rolling.FixedWindowRollingPolicy"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>maxIndex</span>></span>1<span class=tag>&LT/<span class=name>maxIndex</span>></span></span><br><span class=line>            <span class=tag><<span class=name>fileNamePattern</span>></span>app.log.%i<span class=tag>&LT/<span class=name>fileNamePattern</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>rollingPolicy</span>></span></span><br><span class=line>        <span class=tag><<span class=name>triggeringPolicy</span> <span class=attr>class</span>=<span class=string>"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>MaxFileSize</span>></span>1MB<span class=tag>&LT/<span class=name>MaxFileSize</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>triggeringPolicy</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>appender</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>root</span> <span class=attr>level</span>=<span class=string>"INFO"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>appender-ref</span> <span class=attr>ref</span>=<span class=string>"CONSOLE"</span> /></span></span><br><span class=line>        <span class=tag><<span class=name>appender-ref</span> <span class=attr>ref</span>=<span class=string>"APP_LOG"</span> /></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>root</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>configuration</span>></span></span><br></pre></table></figure><p>它主要通过<code>&LTinclude resource="..." /></code>引入了Spring Boot的一个缺省配置，这样我们就可以引用类似<code>${CONSOLE_LOG_PATTERN}</code>这样的变量。上述配置定义了一个控制台输出和文件输出，可根据需要修改。<p><code>static</code>是静态文件目录，<code>templates</code>是模板文件目录，注意它们不再存放在<code>src/main/webapp</code>下，而是直接放到<code>src/main/resources</code>这个classpath目录，因为在Spring Boot中已经不需要专门的webapp目录了。<h3 id=Controller><a class=headerlink href=#Controller title=Controller></a>Controller</h3><h4 id=传入参数><a class=headerlink href=#传入参数 title=传入参数></a>传入参数</h4><p>在 Spring MVC 中，如果你不明确地为控制器方法的参数添加注解，Spring 会根据参数类型以及请求的上下文来自动处理这些参数。以下是默认行为的一些关键点：<p><strong>默认行为概述</strong><ol><li><strong>基本类型和简单对象（如 <code>String</code>, <code>Integer</code> 等）</strong>：<ul><li>如果没有使用任何注解，默认情况下 Spring 尝试从 URL 路径变量、请求参数或请求体中匹配数据。<li>特别是对于 RESTful 风格的 API，如果方法参数名与路径变量名相同，则可以自动绑定到路径变量上。</ul><li><strong>复杂对象（POJO 类）</strong>：<ul><li>对于复杂对象，Spring 会尝试将请求参数（通常是表单数据或者查询参数）自动绑定到对象的属性上。这类似于使用了 <code>@ModelAttribute</code> 注解的效果。<li>若要通过请求体传递 JSON 或 XML 数据并将其转换为对象，必须使用 <code>@RequestBody</code> 注解，否则 Spring 不知道如何解析请求体中的数据。</ul></ol><ul><li>使用 <code>@RequestParam</code> 当：<ul><li>处理GET请求的查询参数<li>处理表单提交(application/x-www-form-urlencoded)<li>需要获取少量简单参数</ul><li>使用 <code>@RequestBody</code> 当：<ul><li>处理JSON/XML等结构化数据<li>需要接收复杂对象<li>构建RESTful API时</ul></ul><p><strong><code>@RequestBody</code> 适用场景</strong>:<ul><li>RESTful API设计<li>前端发送JSON/XML数据<li>复杂嵌套对象结构<li>需要完整对象替换更新的操作</ul><p><strong><code>@ModelAttribute</code> 适用场景</strong>:<ul><li>传统表单提交<li>多步骤表单处理<li>需要部分更新对象的场景<li>需要从URL参数绑定的情况</ul><h4 id=参数校验><a class=headerlink href=#参数校验 title=参数校验></a>参数校验</h4><p>使用<code>@Validated</code>和<code>@Valid</code>用于验证对象,帮助开发者确保传入的数据满足预定义的约束条件.<p><code>@Valid</code> 注解是 Java Bean Validation API（JSR 303/JSR 380）的一部分，通常用于触发<strong>对类实例或方法参数</strong>的验证。当你在一个方法参数、方法返回值或者字段上标记了 <code>@Valid</code>，Spring 会尝试根据该对象上的验证注解（如 <code>@NotNull</code>, <code>@Size</code> 等）来验证数据的有效性。如果验证失败，则抛出 <code>MethodArgumentNotValidException</code> 或者 <code>ConstraintViolationException</code> 异常。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserDTO</span> </span>{</span><br><span class=line>    <span class=meta>@NotNull(message = "Name cannot be null")</span></span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line></span><br><span class=line>    <span class=comment>// getter and setter</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=meta>@RestController</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserController</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@PostMapping("/user")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> ResponseEntity&LTString> <span class=title>createUser</span><span class=params>(<span class=meta>@Valid</span> <span class=meta>@RequestBody</span> UserDTO userDTO)</span> </span>{</span><br><span class=line>        <span class=comment>// 处理用户创建逻辑</span></span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> ResponseEntity<>(<span class=string>"User created successfully"</span>, HttpStatus.CREATED);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>interface</span> <span class=title>OnCreate</span> </span>{}</span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>interface</span> <span class=title>OnUpdate</span> </span>{}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserDTO</span> </span>{</span><br><span class=line>    <span class=meta>@NotNull(groups = OnCreate.class, message = "Name is required on create")</span></span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line></span><br><span class=line>    <span class=meta>@NotNull(groups = OnUpdate.class, message = "ID is required on update")</span></span><br><span class=line>    <span class=keyword>private</span> Long id;</span><br><span class=line></span><br><span class=line>    <span class=comment>// getter and setter</span></span><br><span class=line>}</span><br></pre></table></figure><p>然后在服务层使用 <code>@Validated</code> 来指定验证组：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=meta>@Validated</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserService</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Validated(OnCreate.class)</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>createUser</span><span class=params>(<span class=meta>@Valid</span> UserDTO userDTO)</span> </span>{</span><br><span class=line>        <span class=comment>// 创建用户的逻辑</span></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Validated(OnUpdate.class)</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>updateUser</span><span class=params>(<span class=meta>@Valid</span> UserDTO userDTO)</span> </span>{</span><br><span class=line>        <span class=comment>// 更新用户的逻辑</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>在这个例子中，<code>createUser</code> 方法只会验证那些标记了 <code>OnCreate</code> 分组的约束条件，而 <code>updateUser</code> 方法则只会验证那些标记了 <code>OnUpdate</code> 分组的约束条件。<h4 id=HttpSession><a class=headerlink href=#HttpSession title=HttpSession></a>HttpSession</h4><p><code>HttpSession</code> 是 Java Servlet 技术中用于在服务器端存储特定于用户的会话信息的重要机制。它允许<strong>开发者在多个请求之间保持用户的状态，这对于需要跟踪用户活动（如登录状态、购物车内容等）</strong>的 Web 应用程序来说是非常重要的。<p>如何在 Controller 方法中使用 HttpSession<p><strong>直接声明 HttpSession 参数</strong><p>Spring Boot 会自动将当前请求的 <code>HttpSession</code> 注入到控制器方法中。你只需要在方法参数列表中声明 <code>HttpSession</code> 即可。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> javax.servlet.http.HttpSession;</span><br><span class=line></span><br><span class=line><span class=meta>@RestController</span></span><br><span class=line><span class=meta>@RequestMapping("/session")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>SessionController</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@GetMapping("/set")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> String <span class=title>setSessionAttribute</span><span class=params>(HttpSession session)</span> </span>{</span><br><span class=line>        <span class=comment>// 存储数据到会话中</span></span><br><span class=line>        session.setAttribute(<span class=string>"username"</span>, <span class=string>"JohnDoe"</span>);</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"Session attribute 'username' has been set."</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@GetMapping("/get")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> String <span class=title>getSessionAttribute</span><span class=params>(HttpSession session)</span> </span>{</span><br><span class=line>        <span class=comment>// 从会话中获取数据</span></span><br><span class=line>        String username = (String) session.getAttribute(<span class=string>"username"</span>);</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"Username from session: "</span> + username;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@GetMapping("/invalidate")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> String <span class=title>invalidateSession</span><span class=params>(HttpSession session)</span> </span>{</span><br><span class=line>        <span class=comment>// 销毁会话</span></span><br><span class=line>        session.invalidate();</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"Session has been invalidated."</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>(2) <strong>测试流程</strong><ul><li>访问 <code>/session/set</code>：设置会话属性 <code>username</code>。<li>访问 <code>/session/get</code>：从会话中获取 <code>username</code>。<li>访问 <code>/session/invalidate</code>：销毁会话。</ul><p><strong>3. HttpSession 的常用方法</strong><p>以下是一些常用的 <code>HttpSession</code> 方法：<div class=table-container><table><thead><tr><th>方法名<th>描述<tbody><tr><td><code>setAttribute(String name, Object value)</code><td>将指定的属性存储到会话中。<tr><td><code>getAttribute(String name)</code><td>根据属性名称从会话中获取值。如果属性不存在，则返回 <code>null</code>。<tr><td><code>removeAttribute(String name)</code><td>从会话中移除指定的属性。<tr><td><code>invalidate()</code><td>使当前会话失效，并清除所有会话数据。<tr><td><code>setMaxInactiveInterval(int interval)</code><td>设置会话的最大不活动时间（以秒为单位）。<tr><td><code>getId()</code><td>获取当前会话的唯一标识符（Session ID）。</table></div><p><strong>4. 使用场景</strong><p>(1) <strong>用户登录状态管理</strong><p>通过 <code>HttpSession</code>，可以存储用户的登录状态或用户信息，避免每次请求都需要重新验证身份。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=meta>@PostMapping("/login")</span></span><br><span class=line><span class=function><span class=keyword>public</span> String <span class=title>login</span><span class=params>(String username, String password, HttpSession session)</span> </span>{</span><br><span class=line>    <span class=keyword>if</span> (<span class=string>"admin"</span>.equals(username) && <span class=string>"123456"</span>.equals(password)) {</span><br><span class=line>        session.setAttribute(<span class=string>"user"</span>, username); <span class=comment>// 存储登录信息</span></span><br><span class=line>        <span class=keyword>return</span> <span class=string>"Login successful!"</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=string>"Invalid credentials!"</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=meta>@GetMapping("/dashboard")</span></span><br><span class=line><span class=function><span class=keyword>public</span> String <span class=title>dashboard</span><span class=params>(HttpSession session)</span> </span>{</span><br><span class=line>    String user = (String) session.getAttribute(<span class=string>"user"</span>);</span><br><span class=line>    <span class=keyword>if</span> (user == <span class=keyword>null</span>) {</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"Please login first!"</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=string>"Welcome to the dashboard, "</span> + user + <span class=string>"!"</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=meta>@GetMapping("/logout")</span></span><br><span class=line><span class=function><span class=keyword>public</span> String <span class=title>logout</span><span class=params>(HttpSession session)</span> </span>{</span><br><span class=line>    session.invalidate(); <span class=comment>// 销毁会话</span></span><br><span class=line>    <span class=keyword>return</span> <span class=string>"Logged out successfully!"</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>(2) <strong>购物车功能</strong><p>在电商系统中，可以使用 <code>HttpSession</code> 来存储用户的购物车数据<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=meta>@PostMapping("/addToCart")</span></span><br><span class=line><span class=function><span class=keyword>public</span> String <span class=title>addToCart</span><span class=params>(String item, HttpSession session)</span> </span>{</span><br><span class=line>    List&LTString> cart = (List&LTString>) session.getAttribute(<span class=string>"cart"</span>);</span><br><span class=line>    <span class=keyword>if</span> (cart == <span class=keyword>null</span>) {</span><br><span class=line>        cart = <span class=keyword>new</span> ArrayList<>();</span><br><span class=line>    }</span><br><span class=line>    cart.add(item);</span><br><span class=line>    session.setAttribute(<span class=string>"cart"</span>, cart);</span><br><span class=line>    <span class=keyword>return</span> <span class=string>"Item added to cart!"</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=meta>@GetMapping("/viewCart")</span></span><br><span class=line><span class=function><span class=keyword>public</span> String <span class=title>viewCart</span><span class=params>(HttpSession session)</span> </span>{</span><br><span class=line>    List&LTString> cart = (List&LTString>) session.getAttribute(<span class=string>"cart"</span>);</span><br><span class=line>    <span class=keyword>if</span> (cart == <span class=keyword>null</span> || cart.isEmpty()) {</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"Your cart is empty!"</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=string>"Cart items: "</span> + String.join(<span class=string>", "</span>, cart);</span><br><span class=line>}</span><br></pre></table></figure><p><strong>5. 注意事项</strong><p>(1) <strong>会话超时</strong><p>默认情况下，<code>HttpSession</code> 的超时时间为 30 分钟（由服务器配置决定）。你可以通过以下方式修改超时时间：<ul><li><p>在<code>application.properties</code>中设置properties</p> <figure class="highlight ini"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>server.servlet.session.timeout</span>=<span class=number>15</span>m</span><br></pre></table></figure> <p>或者在代码中动态设置：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>session.setMaxInactiveInterval(<span class=number>900</span>); <span class=comment>// 超时时间为 15 分钟（900 秒）</span></span><br></pre></table></figure></ul><p>(2) <strong>内存消耗</strong><p>每个会话都会占用服务器的内存资源。如果会话数量过多，可能会导致性能问题。因此，尽量只存储必要的数据，并及时清理不再需要的会话。<p>(3) <strong>分布式环境</strong><p>在分布式环境中（如微服务架构），<code>HttpSession</code> 默认是存储在单个服务器上的。如果用户请求被负载均衡器分发到不同的服务器，可能导致会话丢失。解决方法包括：<ul><li>使用粘性会话（Sticky Session）。<li>使用外部化的会话存储（如 Redis）。</ul><p><strong>6. 替代方案</strong><p>在某些场景下，<code>HttpSession</code> 可能不是最佳选择。以下是一些替代方案：<p>(1) <strong>JWT（JSON Web Token）</strong><p>对于无状态的 RESTful API，可以使用 JWT 来代替 <code>HttpSession</code>。JWT 将用户信息存储在客户端（通常是 HTTP 请求头中），服务器无需维护会话状态。<p>(2) <strong>Spring Security</strong><p>Spring Security 提供了更强大的会话管理和认证机制，建议在需要复杂权限控制的场景下使用。<p>(3) <strong>数据库存储</strong><p>如果会话数据需要长期保存，可以考虑将数据存储在数据库中，而不是依赖 <code>HttpSession</code>。<p><code>HttpSession</code> 的核心实现原理可以总结为以下几点：<ol><li><strong>会话ID</strong>：唯一标识每个用户的会话。<li><strong>客户端与服务器的关联</strong>：通过 Cookie 或 URL 重写传递会话ID。<li><strong>服务器端存储</strong>：将以会话ID为键的会话数据存储在服务器端。<li><strong>超时机制</strong>：定期清理长时间未使用的会话。<li><strong>线程安全</strong>：注意并发访问会话数据时的线程安全问题。</ol><h4 id=返回值><a class=headerlink href=#返回值 title=返回值></a>返回值</h4><p><code>@RestController</code> 是一个复合注解，它结合了 <code>@Controller</code> 和 <code>@ResponseBody</code>。<ul><li><code>@Controller</code>：声明该类是一个控制器。<li><code>@ResponseBody</code>：表示方法的返回值会直接写入 HTTP 响应体中，而不是解析为视图名称</ul><p><code>@ResponseBody</code> 注解的作用是将方法的返回值直接写入 HTTP 响应体中，而不是解析为视图名称。<strong>如果返回值是一个对象，Spring 会自动将其序列化为 JSON 或 XML 格式</strong>（默认是 JSON），然后将序列化后的结果作为响应内容返回给客户端。<p>如果使用的是 <code>@ResponseBody</code> 注解，则所有方法默认都会将返回值作为响应体的一部分，并根据返回值的类型推断 <code>Content-Type</code>。<p><strong>默认推断规则</strong><ul><li><strong>String 类型</strong>：默认返回 <code>text/plain</code>。<li><strong>POJO 类型</strong>：默认返回 <code>application/json</code>。<li><strong>其他类型</strong>：可能需要手动指定 <code>produces</code> 或使用 <code>ResponseEntity</code>。</ul><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=meta>@RestController</span></span><br><span class=line><span class=meta>@RequestMapping("/api")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>MyController</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=comment>// 返回纯文本</span></span><br><span class=line>    <span class=meta>@GetMapping(value = "/text", produces = "text/plain")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> String <span class=title>getText</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"This is plain text."</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 返回 JSON 数据</span></span><br><span class=line>    <span class=meta>@GetMapping(value = "/json", produces = "application/json")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> Map&LTString, Object> <span class=title>getJson</span><span class=params>()</span> </span>{</span><br><span class=line>        Map&LTString, Object> data = <span class=keyword>new</span> HashMap<>();</span><br><span class=line>        data.put(<span class=string>"name"</span>, <span class=string>"JohnDoe"</span>);</span><br><span class=line>        data.put(<span class=string>"age"</span>, <span class=number>30</span>);</span><br><span class=line>        <span class=keyword>return</span> data;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 返回 HTML 内容</span></span><br><span class=line>    <span class=meta>@GetMapping(value = "/html", produces = "text/html")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> String <span class=title>getHtml</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"&LTh1>This is an HTML response&LT/h1>"</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>解释</strong>：<ul><li><code>produces</code> 属性用于指定返回内容的 <code>Content-Type</code>。<li>如果省略 <code>produces</code>，Spring 会根据返回值类型自动推断 <code>Content-Type</code>。</ul><div class=table-container><table><thead><tr><th>方法<th>特点<th>适用场景<tbody><tr><td><strong><code>@ResponseBody</code> + <code>produces</code></strong><td>易于使用，支持自动推断 <code>Content-Type</code>。<td>API 开发（JSON、文本等）。<tr><td><strong><code>ResponseEntity</code></strong><td>提供对状态码、头部信息和内容的完全控制。<td>需要动态生成响应的场景。<tr><td><strong><code>@RestController</code> 默认行为</strong><td>自动推断 <code>Content-Type</code>，无需额外配置。<td>简单的 RESTful API 开发。<tr><td><strong><code>HttpServletResponse</code></strong><td>完全手动控制响应内容和头部信息。<td>需要低级别的控制（如自定义格式）。<tr><td><strong>视图解析器</strong><td>结合模板引擎（如 Thymeleaf、JSP）返回完整的 HTML 页面。<td>动态网页开发。</table></div><h4 id=拦截器><a class=headerlink href=#拦截器 title=拦截器></a>拦截器</h4><p>在 Spring MVC 或 Spring Boot 应用程序中，拦截器（Interceptor）是一种用于<strong>在请求处理的不同阶段执行代码的机制。它们允许你在请求到达控制器之前或响应返回客户端之前对请求和响应进行预处理或后处理</strong>。拦截器非常适合用于日志记录、性能监控、安全检查、登录认证等场景。<p><strong>1. 拦截器的工作原理</strong><p>拦截器基于 Java 的 Servlet 规范实现，通过实现 <code>HandlerInterceptor</code> 接口或者继承 <code>HandlerInterceptorAdapter</code> 类来定义自己的拦截逻辑。Spring MVC 提供了三个主要的方法来控制请求的生命周期：<ul><li><strong><code>preHandle()</code></strong>：在处理器方法（Controller 方法）执行之前被调用。如果此方法返回 <code>false</code>，则请求将不再继续执行，可以用来做权限验证等。<li><strong><code>postHandle()</code></strong>：在处理器方法执行之后但在视图渲染之前被调用。可以在此方法中修改模型数据或视图名称。<li><strong><code>afterCompletion()</code></strong>：在整个请求完成之后被调用，通常用于资源清理工作。</ul><p><strong>2. 创建一个简单的拦截器</strong><p>首先，你需要创建一个类实现 <code>HandlerInterceptor</code> 接口，并重写上述提到的方法之一或全部。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.stereotype.Component;</span><br><span class=line><span class=keyword>import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class=line><span class=keyword>import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=line><span class=keyword>import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>MyInterceptor</span> <span class=keyword>implements</span> <span class=title>HandlerInterceptor</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>boolean</span> <span class=title>preHandle</span><span class=params>(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class=keyword>throws</span> Exception </span>{</span><br><span class=line>        <span class=comment>// 在请求处理之前进行调用（Controller方法调用之前）</span></span><br><span class=line>        System.out.println(<span class=string>"Pre-handle"</span>);</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>true</span>; <span class=comment>// 如果返回false，则请求不会继续到下一个拦截器或处理器</span></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>postHandle</span><span class=params>(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class=keyword>throws</span> Exception </span>{</span><br><span class=line>        <span class=comment>// 请求处理之后，视图渲染之前执行</span></span><br><span class=line>        System.out.println(<span class=string>"Post-handle"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>afterCompletion</span><span class=params>(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class=keyword>throws</span> Exception </span>{</span><br><span class=line>        <span class=comment>// 在整个请求结束之后被调用，也就是在视图渲染完成之后，通常用于资源清理工作</span></span><br><span class=line>        System.out.println(<span class=string>"After completion"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>3. 注册拦截器</strong><p>创建好拦截器后，需要将其注册到 Spring MVC 的配置中。可以通过实现 <code>WebMvcConfigurer</code> 接口并覆盖 <code>addInterceptors</code> 方法来注册自定义的拦截器。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.Configuration;</span><br><span class=line><span class=keyword>import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class=line><span class=keyword>import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>WebConfig</span> <span class=keyword>implements</span> <span class=title>WebMvcConfigurer</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> MyInterceptor myInterceptor;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>addInterceptors</span><span class=params>(InterceptorRegistry registry)</span> </span>{</span><br><span class=line>        registry.addInterceptor(myInterceptor)</span><br><span class=line>                .addPathPatterns(<span class=string>"/**"</span>)  <span class=comment>// 指定拦截的路径模式</span></span><br><span class=line>                .excludePathPatterns(<span class=string>"/login"</span>, <span class=string>"/register"</span>); <span class=comment>// 排除某些路径不被拦截</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>4. 使用场景示例</strong><p>(1) <strong>日志记录</strong><p>可以在 <code>preHandle</code> 和 <code>afterCompletion</code> 方法中添加日志记录功能，以追踪每个请求的开始和结束时间。<p>(2) <strong>权限验证</strong><p>在 <code>preHandle</code> 方法中根据用户的身份信息决定是否允许访问目标资源。<p>(3) <strong>性能监控</strong><p>计算从 <code>preHandle</code> 到 <code>afterCompletion</code> 之间的时间差，以此来衡量请求处理的耗时情况。<h3 id=Service><a class=headerlink href=#Service title=Service></a>Service</h3><h3 id=Mapper><a class=headerlink href=#Mapper title=Mapper></a>Mapper</h3><p>一般都是用mybatis,mybatis-plus.<p>MyBatis 的使用流程可以总结为以下几个步骤：<ol><li>引入依赖。<li>配置 MyBatis（XML 或 Spring Boot）。<li>创建实体类。<li>定义 Mapper 接口（注解或 XML）。<li>使用 MyBatis 执行 SQL。</ol><p><strong>1. 引入依赖</strong><p>在项目中引入 MyBatis 和数据库驱动相关的依赖。如果你使用的是 Maven 项目，可以在 <code>pom.xml</code> 中添加以下依赖：<p>xml<p>深色版本<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>    <span class=comment>&LT!-- MyBatis 核心依赖 --></span></span><br><span class=line>    <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>        <span class=tag><<span class=name>groupId</span>></span>org.mybatis<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>artifactId</span>></span>mybatis<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>version</span>></span>3.5.13<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- 数据库驱动（以 MySQL 为例） --></span></span><br><span class=line>    <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>        <span class=tag><<span class=name>groupId</span>></span>mysql<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>artifactId</span>></span>mysql-connector-java<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>version</span>></span>8.0.33<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- 如果使用 Spring Boot，可以引入 MyBatis-Spring-Boot-Starter --></span></span><br><span class=line>    <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>        <span class=tag><<span class=name>groupId</span>></span>org.mybatis.spring.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>artifactId</span>></span>mybatis-spring-boot-starter<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>version</span>></span>2.3.1<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencies</span>></span></span><br></pre></table></figure><p><strong>2. 配置 MyBatis</strong><p>(1) <strong>XML 配置方式</strong><p>创建一个 <code>mybatis-config.xml</code> 文件，用于配置 MyBatis 的全局设置，例如数据源、事务管理器等。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version="1.0" encoding="UTF-8" ?></span></span><br><span class=line><span class=meta>&LT!DOCTYPE <span class=meta-keyword>configuration</span></span></span><br><span class=line><span class=meta>  <span class=meta-keyword>PUBLIC</span> <span class=meta-string>"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class=line><span class=meta>  <span class=meta-string>"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>configuration</span>></span></span><br><span class=line>    <span class=comment>&LT!-- 全局设置 --></span></span><br><span class=line>    <span class=tag><<span class=name>settings</span>></span></span><br><span class=line>        <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"mapUnderscoreToCamelCase"</span> <span class=attr>value</span>=<span class=string>"true"</span>/></span> <span class=comment>&LT!-- 下划线转驼峰 --></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>settings</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- 数据源配置（可选，通常由 Spring 管理） --></span></span><br><span class=line>    <span class=tag><<span class=name>environments</span> <span class=attr>default</span>=<span class=string>"development"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>environment</span> <span class=attr>id</span>=<span class=string>"development"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>transactionManager</span> <span class=attr>type</span>=<span class=string>"JDBC"</span>/></span></span><br><span class=line>            <span class=tag><<span class=name>dataSource</span> <span class=attr>type</span>=<span class=string>"POOLED"</span>></span></span><br><span class=line>                <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"driver"</span> <span class=attr>value</span>=<span class=string>"com.mysql.cj.jdbc.Driver"</span>/></span></span><br><span class=line>                <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"url"</span> <span class=attr>value</span>=<span class=string>"jdbc:mysql://localhost:3306/mydb"</span>/></span></span><br><span class=line>                <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"username"</span> <span class=attr>value</span>=<span class=string>"root"</span>/></span></span><br><span class=line>                <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"password"</span> <span class=attr>value</span>=<span class=string>"password"</span>/></span></span><br><span class=line>            <span class=tag>&LT/<span class=name>dataSource</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>environment</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>environments</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- 映射文件 --></span></span><br><span class=line>    <span class=tag><<span class=name>mappers</span>></span></span><br><span class=line>        <span class=tag><<span class=name>mapper</span> <span class=attr>resource</span>=<span class=string>"com/example/mapper/UserMapper.xml"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>mappers</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>configuration</span>></span></span><br></pre></table></figure><p>(2) <strong>Spring Boot 配置方式</strong><p>如果使用 Spring Boot，可以直接在 <code>application.properties</code> 或 <code>application.yml</code> 中配置 MyBatis 和数据库连接信息。<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment># application.properties</span></span><br><span class=line><span class=meta>spring.datasource.url</span>=<span class=string>jdbc:mysql://localhost:3306/mydb</span></span><br><span class=line><span class=meta>spring.datasource.username</span>=<span class=string>root</span></span><br><span class=line><span class=meta>spring.datasource.password</span>=<span class=string>password</span></span><br><span class=line><span class=meta>spring.datasource.driver-class-name</span>=<span class=string>com.mysql.cj.jdbc.Driver</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment># MyBatis 配置</span></span><br><span class=line><span class=meta>mybatis.mapper-locations</span>=<span class=string>classpath:mapper/*.xml</span></span><br><span class=line><span class=meta>mybatis.configuration.map-underscore-to-camel-case</span>=<span class=string>true</span></span><br></pre></table></figure><p><strong>3. 创建实体类</strong><p>定义与数据库表对应的实体类（也称为 POJO 类）。例如，假设有一张 <code>user</code> 表：<figure class="highlight haxe"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>User</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> Integer id;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>String</span> username;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>String</span> email;</span><br><span class=line></span><br><span class=line>    <span class=comment>// Getters 和 Setters</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>4. 创建 Mapper 接口</strong><p>定义一个接口，用于声明 SQL 操作方法。MyBatis 会通过动态代理机制实现该接口<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.apache.ibatis.annotations.*;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.util.List;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>interface</span> <span class=title>UserMapper</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Select("SELECT * FROM user WHERE id = #{id}")</span></span><br><span class=line>    <span class=function>User <span class=title>getUserById</span><span class=params>(Integer id)</span></span>;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Insert("INSERT INTO user(username, email) VALUES(#{username}, #{email})")</span></span><br><span class=line>    <span class=meta>@Options(useGeneratedKeys = true, keyProperty = "id")</span></span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>insertUser</span><span class=params>(User user)</span></span>;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Update("UPDATE user SET username = #{username}, email = #{email} WHERE id = #{id}")</span></span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>updateUser</span><span class=params>(User user)</span></span>;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Delete("DELETE FROM user WHERE id = #{id}")</span></span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>deleteUser</span><span class=params>(Integer id)</span></span>;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Select("SELECT * FROM user")</span></span><br><span class=line>    <span class=function>List&LTUser> <span class=title>getAllUsers</span><span class=params>()</span></span>;</span><br><span class=line>}</span><br></pre></table></figure><p><strong>5. 编写 SQL 映射文件（可选）</strong><p>如果你不想使用注解，也可以将 SQL 写在 XML 文件中。例如，创建一个 <code>UserMapper.xml</code> 文件：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version="1.0" encoding="UTF-8" ?></span></span><br><span class=line><span class=meta>&LT!DOCTYPE <span class=meta-keyword>mapper</span></span></span><br><span class=line><span class=meta>  <span class=meta-keyword>PUBLIC</span> <span class=meta-string>"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class=line><span class=meta>  <span class=meta-string>"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>mapper</span> <span class=attr>namespace</span>=<span class=string>"com.example.mapper.UserMapper"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"getUserById"</span> <span class=attr>resultType</span>=<span class=string>"com.example.model.User"</span>></span></span><br><span class=line>        SELECT * FROM user WHERE id = #{id}</span><br><span class=line>    <span class=tag>&LT/<span class=name>select</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>insert</span> <span class=attr>id</span>=<span class=string>"insertUser"</span> <span class=attr>useGeneratedKeys</span>=<span class=string>"true"</span> <span class=attr>keyProperty</span>=<span class=string>"id"</span>></span></span><br><span class=line>        INSERT INTO user(username, email) VALUES(#{username}, #{email})</span><br><span class=line>    <span class=tag>&LT/<span class=name>insert</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>update</span> <span class=attr>id</span>=<span class=string>"updateUser"</span>></span></span><br><span class=line>        UPDATE user SET username = #{username}, email = #{email} WHERE id = #{id}</span><br><span class=line>    <span class=tag>&LT/<span class=name>update</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>delete</span> <span class=attr>id</span>=<span class=string>"deleteUser"</span>></span></span><br><span class=line>        DELETE FROM user WHERE id = #{id}</span><br><span class=line>    <span class=tag>&LT/<span class=name>delete</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"getAllUsers"</span> <span class=attr>resultType</span>=<span class=string>"com.example.model.User"</span>></span></span><br><span class=line>        SELECT * FROM user</span><br><span class=line>    <span class=tag>&LT/<span class=name>select</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>mapper</span>></span></span><br></pre></table></figure><p><strong>6. 使用 MyBatis 执行 SQL</strong><p>(1) <strong>非 Spring 环境</strong><p>手动创建 <code>SqlSessionFactory</code> 并获取 <code>SqlSession</code> 来执行 SQL。<figure class="highlight pgsql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.apache.ibatis.io.Resources;</span><br><span class=line><span class=keyword>import</span> org.apache.ibatis.<span class=keyword>session</span>.SqlSession;</span><br><span class=line><span class=keyword>import</span> org.apache.ibatis.<span class=keyword>session</span>.SqlSessionFactory;</span><br><span class=line><span class=keyword>import</span> org.apache.ibatis.<span class=keyword>session</span>.SqlSessionFactoryBuilder;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.io.InputStream;</span><br><span class=line></span><br><span class=line><span class=built_in>public</span> <span class=keyword>class</span> MyBatisExample {</span><br><span class=line>    <span class=built_in>public</span> static <span class=type>void</span> main(String[] args) throws <span class=keyword>Exception</span> {</span><br><span class=line>        // 加载 MyBatis 配置文件</span><br><span class=line>        String resource = "mybatis-config.xml";</span><br><span class=line>        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class=line>        SqlSessionFactory sqlSessionFactory = <span class=built_in>new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class=line></span><br><span class=line>        // 获取 SqlSession</span><br><span class=line>        try (SqlSession <span class=keyword>session</span> = sqlSessionFactory.openSession()) {</span><br><span class=line>            UserMapper mapper = <span class=keyword>session</span>.getMapper(UserMapper.<span class=keyword>class</span>);</span><br><span class=line>            <span class=keyword>User</span> <span class=keyword>user</span> = mapper.getUserById(<span class=number>1</span>);</span><br><span class=line>            <span class=keyword>System</span>.<span class=keyword>out</span>.println(<span class=keyword>user</span>);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>(2) <strong>Spring 或 Spring Boot 环境</strong><p>在 Spring 或 Spring Boot 中，直接注入 <code>Mapper</code> 接口即可。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=line><span class=keyword>import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=line></span><br><span class=line><span class=meta>@RestController</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserController</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> UserMapper userMapper;</span><br><span class=line></span><br><span class=line>    <span class=meta>@GetMapping("/user")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> User <span class=title>getUserById</span><span class=params>(Integer id)</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> userMapper.getUserById(id);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=springcloud><a class=headerlink href=#springcloud title=springcloud></a>springcloud</h2><h1 id=常用库><a class=headerlink href=#常用库 title=常用库></a>常用库</h1><h2 id=lombok✨><a class=headerlink href=#lombok✨ title=lombok✨></a>lombok✨</h2><ol><li><strong>@Getter 和 @Setter</strong></ol><ul><li>自动生成所有字段的 getter 和 setter 方法。<li>可以指定在类级别上使用，这样会为所有非静态字段生成 getter 和 setter 方法；也可以单独用于某个字段。</ul><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> lombok.Getter;</span><br><span class=line><span class=keyword>import</span> lombok.Setter;</span><br><span class=line></span><br><span class=line><span class=meta>@Getter</span> <span class=meta>@Setter</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>User</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>int</span> age;</span><br><span class=line>}</span><br></pre></table></figure><ol><li><strong>@ToString</strong></ol><ul><li>自动生成 <code>toString()</code> 方法，默认包含所有字段。<li>可以通过 <code>exclude</code> 参数排除某些字段，或者通过 <code>callSuper</code> 参数控制是否调用父类的 <code>toString()</code> 方法。</ul><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> lombok.ToString;</span><br><span class=line></span><br><span class=line><span class=meta>@ToString(exclude = "password")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>User</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> String username;</span><br><span class=line>    <span class=keyword>private</span> String password;</span><br><span class=line>}</span><br></pre></table></figure><ol><li><strong>@EqualsAndHashCode</strong></ol><ul><li>自动生成 <code>equals(Object other)</code> 和 <code>hashCode()</code> 方法。<li>类似于 <code>@ToString</code>，可以通过 <code>exclude</code> 排除特定字段，或通过 <code>callSuper</code> 控制是否考虑父类字段。</ul><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> lombok.EqualsAndHashCode;</span><br><span class=line></span><br><span class=line><span class=meta>@EqualsAndHashCode(exclude = "timestamp")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>User</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> String username;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>long</span> timestamp;</span><br><span class=line>}</span><br></pre></table></figure><ol><li><strong>@NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor</strong></ol><ul><li>自动生成构造函数：<ul><li><code>@NoArgsConstructor</code>: 无参构造函数。<li><code>@RequiredArgsConstructor</code>: 使用所有 <code>final</code> 或 <code>@NonNull</code> 注解标注的字段作为参数的构造函数。<li><code>@AllArgsConstructor</code>: 包含所有字段的构造函数。</ul></ul><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> lombok.NoArgsConstructor;</span><br><span class=line><span class=keyword>import</span> lombok.RequiredArgsConstructor;</span><br><span class=line><span class=keyword>import</span> lombok.AllArgsConstructor;</span><br><span class=line></span><br><span class=line><span class=meta>@NoArgsConstructor</span></span><br><span class=line><span class=meta>@RequiredArgsConstructor(staticName = "of")</span></span><br><span class=line><span class=meta>@AllArgsConstructor</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>User</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> String username;</span><br><span class=line>    <span class=keyword>private</span> String email;</span><br><span class=line>}</span><br></pre></table></figure><ol><li><strong>@Data</strong></ol><ul><li>组合了 <code>@Getter</code>, <code>@Setter</code>, <code>@ToString</code>, <code>@EqualsAndHashCode</code>, 和 <code>@RequiredArgsConstructor</code> 的功能。<li>非常适合用于简单的数据持有类。</ul><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> lombok.Data;</span><br><span class=line></span><br><span class=line><span class=meta>@Data</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>User</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> String username;</span><br><span class=line>    <span class=keyword>private</span> String email;</span><br><span class=line>}</span><br></pre></table></figure><ol><li><strong>@Builder</strong></ol><ul><li>提供了一个流畅的构建器 API，非常适合创建不可变对象或复杂对象的实例化。</ul><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> lombok.Builder;</span><br><span class=line></span><br><span class=line><span class=meta>@Builder</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>User</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> String username;</span><br><span class=line>    <span class=keyword>private</span> String email;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 使用</span></span><br><span class=line>User user = User.builder().username(<span class=string>"Alice"</span>).email(<span class=string>"alice@example.com"</span>).build();</span><br></pre></table></figure><ol><li><strong>@Slf4j</strong></ol><ul><li>自动生成一个 SLF4J Logger 实例，简化日志记录。</ul><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=line></span><br><span class=line><span class=meta>@Slf4j</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserService</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>login</span><span class=params>(String username)</span> </span>{</span><br><span class=line>        log.info(<span class=string>"User {} is logging in."</span>, username);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><ol><li><strong>@Cleanup</strong></ol><ul><li>自动管理资源，确保在方法退出时关闭资源（如文件流、数据库连接等）。</ul><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> lombok.Cleanup;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>readData</span><span class=params>()</span> <span class=keyword>throws</span> IOException </span>{</span><br><span class=line>    <span class=meta>@Cleanup</span> InputStream in = <span class=keyword>new</span> FileInputStream(<span class=string>"path/to/file"</span>);</span><br><span class=line>    <span class=comment>// 处理输入流</span></span><br><span class=line>}</span><br></pre></table></figure><ol><li><strong>@SneakyThrows</strong></ol><ul><li>简化异常处理，允许直接抛出受检异常而不必显式声明它们。</ul><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> lombok.SneakyThrows;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>readFile</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=meta>@SneakyThrows</span></span><br><span class=line>    FileReader fileReader = <span class=keyword>new</span> FileReader(<span class=string>"path/to/file"</span>);</span><br><span class=line>    <span class=comment>// 处理文件读取</span></span><br><span class=line>}</span><br></pre></table></figure><ol><li><strong>@Value</strong></ol><ul><li>创建不可变类（所有字段默认是私有的，并且带有 <code>final</code> 关键字），同时提供 <code>@Data</code> 的大部分功能</ul><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> lombok.Value;</span><br><span class=line></span><br><span class=line><span class=meta>@Value</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>User</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> String username;</span><br><span class=line>    <span class=keyword>private</span> String email;</span><br><span class=line>}</span><br></pre></table></figure><h2 id=hutool✨><a class=headerlink href=#hutool✨ title=hutool✨></a>hutool✨</h2><h2 id=slf4j✨><a class=headerlink href=#slf4j✨ title=slf4j✨></a>slf4j✨</h2><p><a href=https://logback.qos.ch/apidocs/index.html rel=noopener target=_blank>Overview (Logback-Parent 1.5.15 API)</a><p>SLF4J为各种日志框架（例如 java.util.logging、logback、log4j）提供了一个简单的门面或抽象，允许用户在部署时插入所需的日志框架。<h2 id=logback><a class=headerlink href=#logback title=logback></a>logback</h2><p><a href=https://logback.qos.ch/ rel=noopener target=_blank>Logback Home</a><p>Logback 旨在作为流行的 log4j 项目的继任者，从 log4j 1.x 停止的地方继续发展。<p>Logback 的架构相当通用，以便在不同情况下应用。目前，logback 分为三个模块，分别是 logback-core、logback-classic 和 logback-access。<p>logback -core模块为其他两个模块奠定了基础。logback-classic模块可以看作是 log4j 1.x 的改进版本。此外，logback-classic模块原生实现了 SLF4J API，因此您可以轻松地在logaback和其他日志框架（如 log4j 1.x 或 java.util.logging（JUL））之间切换。<h2 id=log4j><a class=headerlink href=#log4j title=log4j></a>log4j</h2><p><a href=https://logging.apache.org/log4j/2.12.x/ rel=noopener target=_blank>Log4j – Apache Log4j 2 - Apache Log4j 2</a><p>Apache Log4j 2 是 Log4j 的升级版本，在性能上对前一代 Log4j 1.x 进行了显著提升，并提供了许多 Logback 中的改进，同时修复了 Logback 架构中的一些固有缺陷。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic --></span></span><br><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>ch.qos.logback<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>logback-classic<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>1.5.18<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>    <span class=tag><<span class=name>scope</span>></span>compile<span class=tag>&LT/<span class=name>scope</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line><span class=comment>&LT!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --></span></span><br><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>org.slf4j<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>slf4j-api<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>2.0.17<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><p>一般可以使用slf4j-api接口加上logback-classic(或者slf4j-simple)实现.<h1 id=常用术语><a class=headerlink href=#常用术语 title=常用术语></a>常用术语</h1><ol><li><strong>类（Class）命名</strong></ol><ul><li><strong>规则</strong>：使用<strong>大写驼峰式（UpperCamelCase）</strong>，首字母大写，每个单词首字母大写。<li><strong>特点</strong>：通常是名词或名词短语，表示一个实体或概念。<li>示例<ul><li>User<li>OrderService<li>HttpRequestHandler</ul><li>注意<ul><li>接口命名与类类似，但通常反映其功能或角色，例如 Runnable、Serializable。<li>抽象类可以以 Abstract 开头，例如 AbstractFactory。</ul></ul><ol><li><strong>接口（Interface）命名</strong></ol><ul><li><strong>规则</strong>：同样使用<strong>大写驼峰式</strong>，通常是形容词或表示能力的名词。<li><strong>特点</strong>：突出功能或契约。<li>示例<ul><li>Comparable<li>Iterable<li>UserService</ul><li><strong>注意</strong>：避免使用 I 前缀（如 IUserService），这是 C# 的习惯，Java 中不推荐。</ul><ol><li><strong>方法（Method）命名</strong></ol><ul><li><strong>规则</strong>：使用<strong>小写驼峰式（lowerCamelCase）</strong>，首字母小写，后续单词首字母大写。<li><strong>特点</strong>：通常是动词或动词短语，表示行为或操作。<li>示例<ul><li>getName<li>calculateTotalPrice<li>isValid</ul><li>约定<ul><li>Getter 方法以 get 开头（返回布尔值时用 is），例如 getAge、isActive。<li>Setter 方法以 set 开头，例如 setName。<li>操作方法通常以动词开头，例如 saveUser、deleteRecord。</ul></ul><ol><li><strong>变量（Variable）命名</strong></ol><ul><li><strong>规则</strong>：使用<strong>小写驼峰式</strong>。<li><strong>特点</strong>：简洁、有意义，反映变量的作用。<li>示例<ul><li>userName<li>orderList<li>totalAmount</ul><li>约定<ul><li>局部变量：短而明确，例如 i（循环计数器）、temp。<li>成员变量（字段）：避免无意义的缩写，例如 firstName 而不是 fName。<li>布尔变量：通常以 is、has 等开头，例如 isFinished、hasPermission。</ul></ul><ol><li><strong>常量（Constant）命名</strong></ol><ul><li><strong>规则</strong>：全部<strong>大写</strong>，单词间用下划线 _ 分隔。<li><strong>特点</strong>：用于 static final 修饰的常量。<li>示例<ul><li>MAX_VALUE<li>DEFAULT_TIMEOUT<li>PI</ul><li><strong>注意</strong>：通常定义在类或接口中，表示不可变的值。</ul><ol><li><strong>包（Package）命名</strong></ol><ul><li><strong>规则</strong>：全部<strong>小写</strong>，使用点号 . 分隔，通常基于域名倒写。<li><strong>特点</strong>：层次清晰，避免关键字。<li>示例<ul><li>com.example.util<li>org.springframework.context</ul><li>约定<ul><li>避免使用连字符或下划线。<li>通常以公司或组织域名开头，避免命名冲突。</ul></ul><ol><li><strong>枚举（Enum）命名</strong></ol><ul><li><p><strong>规则</strong>：类名使用<strong>大写驼峰式</strong>，枚举值使用<strong>全大写</strong>（类似常量）。</p><li><p>示例</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>enum</span> <span class=title>Status</span> </span>{   </span><br><span class=line>    ACTIVE,    INACTIVE,    PENDING }</span><br></pre></table></figure></ul><ol><li><strong>异常（Exception）命名</strong></ol><ul><li><strong>规则</strong>：使用<strong>大写驼峰式</strong>，以 Exception 或 Error 结尾。<li>示例<ul><li>FileNotFoundException<li>NullPointerException<li>CustomValidationError</ul></ul><ol><li><strong>注解（Annotation）命名</strong></ol><ul><li><strong>规则</strong>：使用<strong>大写驼峰式</strong>，通常反映用途。<li>示例<ul><li>@Autowired<li>@RestController<li>@MyCustomAnnotation</ul></ul><ol><li><strong>测试类和方法命名</strong></ol><ul><li><p>规则</p> <ul><li>测试类以 Test 结尾，命名反映被测试的类，例如 UserServiceTest。<li>测试方法以 test 开头，描述测试行为，使用小写驼峰式。</ul><li><p>示例</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserServiceTest</span> </span>{  </span><br><span class=line>    <span class=meta>@Test</span>   </span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>testSaveUser</span><span class=params>()</span> </span>{        </span><br><span class=line>        <span class=comment>// 测试代码    } </span></span><br><span class=line>    }</span><br></pre></table></figure></ul><ol><li><strong>其他约定</strong></ol><ul><li><p><strong>避免缩写</strong>：除非是广为人知的缩写（如 URL、HTTP），否则使用完整单词，例如 userIdentifier 而不是 userId。</p><li><p><strong>语义清晰</strong>：命名应反映用途，避免过于泛泛的名称，如 data、process。</p><li><p>单复数</p> <p>：</p> <ul><li>集合使用复数，例如 users、orderList。<li>单个对象使用单数，例如 user、order。</ul></ul><ol><li><strong>Spring 中的特殊命名</strong></ol><ul><li>Bean 名称<ul><li>默认是类名首字母小写，例如 UserServiceImpl 的 Bean 名是 userServiceImpl。<li>可通过注解指定，例如 @Service(“customName”)。</ul><li>接口与实现类<ul><li>接口：UserService。<li>实现类：UserServiceImpl（以 Impl 结尾是常见约定）。</ul></ul><ol><li><strong>POJO (Plain Old Java Object)</strong></ol><ul><li><strong>含义</strong>：普通的 Java 对象，指不依赖特定框架、不继承特定类或实现特定接口的简单 Java 类。<li>特点<ul><li>只包含属性（字段）、getter/setter 方法，可能有简单的业务逻辑。<li>不受外部框架约束，例如不继承 Servlet 或实现 Serializable（除非业务需要）。</ul><li><strong>用途</strong>：作为基础数据载体，广泛用于各种场景</ul><ol><li><strong>VO (Value Object)</strong></ol><ul><li><strong>含义</strong>：值对象，通常用于表示不可变的数据结构，强调值的语义。<li>特点<ul><li>通常是不可变的（Immutable），创建后属性不可修改。<li>常用于传递数据，关注数据的完整性和一致性。<li>在某些场景下，也被用作视图对象（View Object），表示展示层的数据。</ul><li><strong>用途</strong>：在业务逻辑中传递数据，或在前端展示时封装数据。</ul><ol><li><strong>PO (Persistent Object)</strong></ol><ul><li><strong>含义</strong>：持久化对象，表示与数据库表直接映射的对象，通常用于 ORM（对象关系映射）框架（如 Hibernate、MyBatis）。<li>特点<ul><li>属性与数据库表的字段一一对应。<li>通常包含主键（如 id）和其他表字段。<li>可能有注解（如 @Entity、@Table）来映射数据库。</ul><li><strong>用途</strong>：用于数据持久化层，与数据库交互</ul><ol><li><strong>DAO (Data Access Object)</strong></ol><ul><li><p><strong>含义</strong>：数据访问对象，负责封装数据库操作的逻辑。</p><li><p>特点</p> <p>：</p> <ul><li>提供 CRUD（增删改查）方法，与数据库交互。<li>屏蔽底层数据访问细节（如 JDBC、ORM 的具体实现）。<li>通常与 PO 配合使用。</ul><li><p><strong>用途</strong>：隔离业务逻辑与数据访问逻辑。</p></ul><ol><li><strong>DTO (Data Transfer Object)</strong></ol><ul><li><p><strong>含义</strong>：数据传输对象，用于在不同层（如服务层与表现层）或系统之间传递数据。</p><li><p>特点</p> <p>：</p> <ul><li>不直接映射数据库表，属性根据传输需求设计。<li>通常是简单的数据容器，不含复杂业务逻辑。<li>常用于减少网络传输中的数据冗余或适配前端需求。</ul><li><p><strong>用途</strong>：跨层或跨系统的数据交换。</p></ul><ol><li><strong>BO (Business Object)</strong></ol><ul><li><strong>含义</strong>：业务对象，封装业务逻辑或表示业务实体的对象。<li>特点<ul><li>包含业务数据和相关操作方法。<li>通常聚合多个 PO 或 DTO，表示更高层次的业务概念。</ul><li><strong>用途</strong>：在业务逻辑层处理复杂的业务规则。</ul><p><strong>对比总结</strong><div class=table-container><table><thead><tr><th>术语<th>全称<th>主要用途<th>与数据库关系<th>是否含业务逻辑<tbody><tr><td>POJO<td>Plain Old Java Object<td>通用简单对象<td>无特定关系<td>可能有简单逻辑<tr><td>VO<td>Value Object<td>数据传递或视图展示<td>无直接关系<td>通常无<tr><td>PO<td>Persistent Object<td>数据库表映射<td>直接映射<td>通常无<tr><td>DAO<td>Data Access Object<td>数据访问逻辑<td>与数据库交互<td>数据操作逻辑<tr><td>DTO<td>Data Transfer Object<td>层间或系统间数据传输<td>无直接关系<td>通常无<tr><td>BO<td>Business Object<td>业务逻辑处理<td>间接（聚合 PO/DTO）<td>包含业务逻辑</table></div><p><strong>典型使用场景</strong><p>在一个 Spring 项目中，这些对象可能这样协作：<ol><li><strong>PO</strong>：UserPO 用于与数据库表 users 映射，由 ORM（如 JPA）管理。<li><strong>DAO</strong>：UserDAO 提供对 UserPO 的增删改查操作。<li><strong>DTO</strong>：UserDTO 从 UserPO 转换而来，传递给服务层或前端。<li><strong>BO</strong>：OrderBO 聚合多个 UserDTO 和订单信息，执行业务计算。<li><strong>VO</strong>：UserVO 用于返回给前端的不可变视图数据。<li><strong>POJO</strong>：任何简单的 Java 类都可以是 POJO，可能用作上述某种对象的基类。</ol><p>数据库连接池<div class=table-container><table><thead><tr><th>特性<th>DriverManagerDataSource<th>HikariCP<tbody><tr><td><strong>连接池支持</strong><td>无，每次创建新连接<td>有，高效连接池管理<tr><td><strong>性能</strong><td>低，适合低并发<td>高，优化了并发和资源复用<tr><td><strong>使用场景</strong><td>开发、测试、小型应用<td>生产环境、高并发应用<tr><td><strong>配置复杂度</strong><td>简单，仅基本连接信息<td>支持丰富配置（如池大小、超时等）<tr><td><strong>依赖</strong><td>Spring 自带，无需额外库<td>需引入 HikariCP 依赖<tr><td><strong>Spring Boot 默认</strong><td>否<td>是（2.x 和 3.x 默认使用）<tr><td><strong>连接管理</strong><td>每次获取连接都新建，关闭即销毁<td>池化管理，连接复用</table></div><p>HikariCP 是 Spring Boot 默认连接池，性能极高，但无内置监控。<p>Druid 提供强大监控功能（如 SQL 执行时间、连接状态），适合需要实时分析连接池状态的场景。</p><link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script></div><div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a href=https://www.sekyoro.top/2025/03/09/mini-java-guide/ title=mini-java-guide>https://www.sekyoro.top/2025/03/09/mini-java-guide/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div><footer class=post-footer><div class=post-nav><div class=post-nav-item><a href=/2025/02/27/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ rel=prev title=Linux网络编程入门> <i class="fa fa-chevron-left"></i> Linux网络编程入门 </a></div><div class=post-nav-item><a href=/2025/03/12/TCP-IP%E4%B8%8EHTTP%E7%BC%96%E7%A8%8B/ rel=next title=TCP/IP与HTTP编程> TCP/IP与HTTP编程 <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div><!-- 评论区 --><div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#Java%E5%9F%BA%E7%A1%80><span class=nav-number>1.</span> <span class=nav-text>Java基础</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#Java%E5%9F%BA%E7%A1%80-1><span class=nav-number>1.1.</span> <span class=nav-text>Java基础</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-java-lang><span class=nav-number>1.1.1.</span> <span class=nav-text>1. java.lang.*</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-java-util><span class=nav-number>1.1.2.</span> <span class=nav-text>2. java.util.*</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-java-io><span class=nav-number>1.1.3.</span> <span class=nav-text>3. java.io.*</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-java-nio><span class=nav-number>1.1.4.</span> <span class=nav-text>4. java.nio.*</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#5-java-net><span class=nav-number>1.1.5.</span> <span class=nav-text>5. java.net.*</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#6-java-text><span class=nav-number>1.1.6.</span> <span class=nav-text>6. java.text.*</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#7-java-time><span class=nav-number>1.1.7.</span> <span class=nav-text>7. java.time.*</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#8-%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3><span class=nav-number>1.1.8.</span> <span class=nav-text>8. 并发相关</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#9-%E5%85%B6%E4%BB%96><span class=nav-number>1.1.9.</span> <span class=nav-text>9. 其他</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%86%85%E9%83%A8%E7%B1%BB><span class=nav-number>1.1.10.</span> <span class=nav-text>内部类</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%9B%86%E5%90%88Collection%E4%B8%8EMap><span class=nav-number>1.1.11.</span> <span class=nav-text>集合Collection与Map</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#List><span class=nav-number>1.1.11.0.1.</span> <span class=nav-text>List</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Set><span class=nav-number>1.1.11.0.2.</span> <span class=nav-text>Set</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Map><span class=nav-number>1.1.11.0.3.</span> <span class=nav-text>Map</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%89%A9%E5%AE%B9%E6%B5%81%E7%A8%8B%EF%BC%9A><span class=nav-number>1.1.11.1.</span> <span class=nav-text>扩容流程：</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#B-%E6%A0%91-B-Tree><span class=nav-number>1.1.12.</span> <span class=nav-text>B 树 (B-Tree)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-B-%E6%A0%91-B-Tree><span class=nav-number>1.1.13.</span> <span class=nav-text>3. B+ 树 (B+ Tree)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%BA%A2%E9%BB%91%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81B-%E6%A0%91%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93><span class=nav-number>1.1.14.</span> <span class=nav-text>红黑树、B 树、B+ 树的主要区别总结</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%BC%82%E5%B8%B8%E3%80%81%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6><span class=nav-number>1.1.14.1.</span> <span class=nav-text>异常、泛型与集合框架</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%B1%BB><span class=nav-number>1.1.14.2.</span> <span class=nav-text>使用泛型类</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95><span class=nav-number>1.1.14.3.</span> <span class=nav-text>泛型方法</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3><span class=nav-number>1.1.14.4.</span> <span class=nav-text>泛型接口</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0><span class=nav-number>1.1.15.</span> <span class=nav-text>多线程与线程池</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86><span class=nav-number>1.1.16.</span> <span class=nav-text>反射、注解与动态代理</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#ClassLoader><span class=nav-number>1.1.16.1.</span> <span class=nav-text>ClassLoader</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8A%A0%E8%BD%BD%E5%99%A8><span class=nav-number>1.1.16.2.</span> <span class=nav-text>线程上下文加载器</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#JVM><span class=nav-number>1.2.</span> <span class=nav-text>JVM</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6><span class=nav-number>1.2.1.</span> <span class=nav-text>垃圾回收</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95><span class=nav-number>1.2.1.1.</span> <span class=nav-text>引用计数法</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95><span class=nav-number>1.2.1.2.</span> <span class=nav-text>可达性分析算法</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95><span class=nav-number>1.2.1.3.</span> <span class=nav-text>回收算法</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8><span class=nav-number>1.2.1.4.</span> <span class=nav-text>垃圾回收器</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E7%B1%BB><span class=nav-number>1.2.2.</span> <span class=nav-text>CAS与原子类</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81><span class=nav-number>1.2.2.0.1.</span> <span class=nav-text>乐观锁和悲观锁</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB><span class=nav-number>1.2.2.0.2.</span> <span class=nav-text>原子操作类</span></a></ol></ol><li class="nav-item nav-level-3"><a class=nav-link href=#synchronized%E4%BC%98%E5%8C%96><span class=nav-number>1.2.3.</span> <span class=nav-text>synchronized优化</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%81%8F%E5%90%91%E9%94%81><span class=nav-number>1.2.3.1.</span> <span class=nav-text>偏向锁</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81><span class=nav-number>1.2.3.2.</span> <span class=nav-text>轻量级锁</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86><span class=nav-number>1.2.3.3.</span> <span class=nav-text>轻量级锁的工作原理</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%87%8D%E9%87%8F%E9%94%81><span class=nav-number>1.2.3.4.</span> <span class=nav-text>重量锁</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%94%81%E8%86%A8%E8%83%80><span class=nav-number>1.2.3.5.</span> <span class=nav-text>锁膨胀</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96><span class=nav-number>1.2.3.6.</span> <span class=nav-text>其他优化</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#JUC><span class=nav-number>1.3.</span> <span class=nav-text>JUC</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B><span class=nav-number>1.3.0.1.</span> <span class=nav-text>创建线程</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Syncronized%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86><span class=nav-number>1.3.0.2.</span> <span class=nav-text>Syncronized优化原理</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#ReentrantLock><span class=nav-number>1.3.0.3.</span> <span class=nav-text>ReentrantLock</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%8F%AF%E9%87%8D%E5%85%A5><span class=nav-number>1.3.0.3.1.</span> <span class=nav-text>可重入</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%8F%AF%E6%89%93%E6%96%AD><span class=nav-number>1.3.0.3.2.</span> <span class=nav-text>可打断</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%B0%9D%E8%AF%95%E8%8E%B7%E5%8F%96%E9%94%81><span class=nav-number>1.3.0.3.3.</span> <span class=nav-text>尝试获取锁</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%85%AC%E5%B9%B3%E9%94%81><span class=nav-number>1.3.0.3.4.</span> <span class=nav-text>公平锁</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%B8%8E%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F><span class=nav-number>1.3.0.3.5.</span> <span class=nav-text>与条件变量</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#volatile%E5%8E%9F%E7%90%86><span class=nav-number>1.3.0.4.</span> <span class=nav-text>volatile原理</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0><span class=nav-number>1.3.0.5.</span> <span class=nav-text>自定义线程池</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#Executors><span class=nav-number>1.3.0.5.1.</span> <span class=nav-text>Executors</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB><span class=nav-number>1.3.0.6.</span> <span class=nav-text>线程安全集合类</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#Vector-%E5%92%8C-Hashtable><span class=nav-number>1.3.0.6.1.</span> <span class=nav-text>Vector 和 Hashtable</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%90%8C%E6%AD%A5%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%88Collections-synchronizedXxx-%E6%96%B9%E6%B3%95%EF%BC%89><span class=nav-number>1.3.0.6.2.</span> <span class=nav-text>同步包装类（Collections.synchronizedXxx() 方法）</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Concurrent-%E7%B3%BB%E5%88%97%E9%9B%86%E5%90%88><span class=nav-number>1.3.0.6.3.</span> <span class=nav-text>Concurrent 系列集合</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%88Blocking-Queue%EF%BC%89><span class=nav-number>1.3.0.6.4.</span> <span class=nav-text>阻塞队列（Blocking Queue）</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#CopyOnWrite-%E7%B3%BB%E5%88%97%E9%9B%86%E5%90%88><span class=nav-number>1.3.0.6.5.</span> <span class=nav-text>CopyOnWrite 系列集合</span></a></ol></ol><li class="nav-item nav-level-3"><a class=nav-link href=#FAQ><span class=nav-number>1.3.1.</span> <span class=nav-text>FAQ</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#HashMap%E5%B9%B6%E5%8F%91%E6%AD%BB%E9%93%BE%E9%97%AE%E9%A2%98><span class=nav-number>1.3.1.1.</span> <span class=nav-text>HashMap并发死链问题</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86><span class=nav-number>2.</span> <span class=nav-text>项目管理</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#Maven%E2%9C%A8><span class=nav-number>2.1.</span> <span class=nav-text>Maven✨</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86><span class=nav-number>2.1.1.</span> <span class=nav-text>依赖管理</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86><span class=nav-number>2.1.2.</span> <span class=nav-text>插件管理</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%85%83%E7%B4%A0><span class=nav-number>2.1.3.</span> <span class=nav-text>其他常用元素</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F><span class=nav-number>2.1.4.</span> <span class=nav-text>生命周期</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%93%E5%BA%93><span class=nav-number>2.1.5.</span> <span class=nav-text>仓库</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4><span class=nav-number>2.1.6.</span> <span class=nav-text>常用命令</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%95%B0%E6%8D%AE%E5%BA%93><span class=nav-number>3.</span> <span class=nav-text>数据库</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#MySQL%E2%9C%A8><span class=nav-number>3.1.</span> <span class=nav-text>MySQL✨</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BA%8B%E5%8A%A1><span class=nav-number>3.1.0.1.</span> <span class=nav-text>事务</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98><span class=nav-number>3.1.0.1.1.</span> <span class=nav-text>事务并发问题</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#%E8%84%8F%E8%AF%BB><span class=nav-number>3.1.0.1.1.1.</span> <span class=nav-text>脏读</span></a><li class="nav-item nav-level-6"><a class=nav-link href=#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB><span class=nav-number>3.1.0.1.1.2.</span> <span class=nav-text>不可重复读</span></a><li class="nav-item nav-level-6"><a class=nav-link href=#%E5%B9%BB%E8%AF%BB><span class=nav-number>3.1.0.1.1.3.</span> <span class=nav-text>幻读</span></a></ol><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB><span class=nav-number>3.1.0.1.2.</span> <span class=nav-text>事务隔离级别</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E><span class=nav-number>3.1.0.2.</span> <span class=nav-text>存储引擎</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%B4%A2%E5%BC%95><span class=nav-number>3.1.0.3.</span> <span class=nav-text>索引</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#SQL%E4%BC%98%E5%8C%96><span class=nav-number>3.1.0.4.</span> <span class=nav-text>SQL优化</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%A4%BA%E4%BE%8B><span class=nav-number>3.1.0.4.1.</span> <span class=nav-text>示例</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%A4%BA%E4%BE%8B-1><span class=nav-number>3.1.0.4.2.</span> <span class=nav-text>示例</span></a></ol></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%A7%86%E5%9B%BE-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-%E8%A7%A6%E5%8F%91%E5%99%A8><span class=nav-number>3.1.1.</span> <span class=nav-text>视图/存储过程/触发器</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%A7%86%E5%9B%BE-Views><span class=nav-number>3.1.1.1.</span> <span class=nav-text>视图 (Views)</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-Stored-Procedures><span class=nav-number>3.1.2.</span> <span class=nav-text>存储过程 (Stored Procedures)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%A7%A6%E5%8F%91%E5%99%A8-Triggers><span class=nav-number>3.1.3.</span> <span class=nav-text>触发器 (Triggers)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%94%81><span class=nav-number>3.1.4.</span> <span class=nav-text>锁</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%97%A5%E5%BF%97><span class=nav-number>3.1.5.</span> <span class=nav-text>日志</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97><span class=nav-number>3.1.5.1.</span> <span class=nav-text>错误日志</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#Join%E8%BF%9E%E6%8E%A5><span class=nav-number>3.1.6.</span> <span class=nav-text>Join连接</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#PostgresSQL><span class=nav-number>3.2.</span> <span class=nav-text>PostgresSQL</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#MongoDB><span class=nav-number>3.3.</span> <span class=nav-text>MongoDB</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6><span class=nav-number>4.</span> <span class=nav-text>持久层框架</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#Mybatis%E2%9C%A8><span class=nav-number>4.1.</span> <span class=nav-text>Mybatis✨</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%9F%A5%E8%AF%A2%E5%8D%95%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B><span class=nav-number>4.1.1.</span> <span class=nav-text>查询单表数据整体流程</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BD%BF%E7%94%A8Mapper%E4%BB%A3%E7%90%86%E5%BC%80%E5%8F%91><span class=nav-number>4.1.2.</span> <span class=nav-text>使用Mapper代理开发</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#properties><span class=nav-number>4.1.3.</span> <span class=nav-text>properties</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#settings><span class=nav-number>4.1.4.</span> <span class=nav-text>settings</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#TypeAliases><span class=nav-number>4.1.5.</span> <span class=nav-text>TypeAliases</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#typehandlers><span class=nav-number>4.1.6.</span> <span class=nav-text>typehandlers</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%8F%92%E4%BB%B6%EF%BC%88plugins%EF%BC%89><span class=nav-number>4.1.7.</span> <span class=nav-text>插件（plugins）</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#xml%E6%98%A0%E5%B0%84%E5%99%A8><span class=nav-number>4.1.8.</span> <span class=nav-text>xml映射器</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8F%82%E6%95%B0%E6%98%A0%E5%B0%84><span class=nav-number>4.1.9.</span> <span class=nav-text>参数映射</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84><span class=nav-number>4.1.10.</span> <span class=nav-text>结果映射</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8A%A8%E6%80%81SQL><span class=nav-number>4.1.11.</span> <span class=nav-text>动态SQL</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#mybatis-plus><span class=nav-number>4.1.12.</span> <span class=nav-text>mybatis-plus</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Hibernate><span class=nav-number>4.2.</span> <span class=nav-text>Hibernate</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#Spring-Data-JPA><span class=nav-number>4.3.</span> <span class=nav-text>Spring Data JPA</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%B6%88%E6%81%AF%E7%BB%84%E4%BB%B6><span class=nav-number>5.</span> <span class=nav-text>消息组件</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#Redis%E2%9C%A8><span class=nav-number>5.1.</span> <span class=nav-text>Redis✨</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C><span class=nav-number>5.1.1.</span> <span class=nav-text>基本操作</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B><span class=nav-number>5.1.2.</span> <span class=nav-text>数据类型</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#String><span class=nav-number>5.1.2.1.</span> <span class=nav-text>String</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#List-1><span class=nav-number>5.1.2.2.</span> <span class=nav-text>List</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Set-1><span class=nav-number>5.1.2.3.</span> <span class=nav-text>Set</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#ZSet><span class=nav-number>5.1.2.4.</span> <span class=nav-text>ZSet</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Hash><span class=nav-number>5.1.2.5.</span> <span class=nav-text>Hash</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F><span class=nav-number>5.1.3.</span> <span class=nav-text>缓存穿透</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%BC%93%E5%AD%98%E7%A9%BA%E5%AF%B9%E8%B1%A1><span class=nav-number>5.1.3.1.</span> <span class=nav-text>缓存空对象</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4><span class=nav-number>5.1.3.2.</span> <span class=nav-text>布隆过滤</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9><span class=nav-number>5.1.4.</span> <span class=nav-text>缓存雪崩</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88><span class=nav-number>5.1.4.1.</span> <span class=nav-text>解决方案</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF><span class=nav-number>5.1.5.</span> <span class=nav-text>缓存击穿</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1><span class=nav-number>5.1.5.1.</span> <span class=nav-text>解决方案</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%86%85%E5%AD%98%E6%8C%81%E4%B9%85%E5%8C%96><span class=nav-number>5.1.6.</span> <span class=nav-text>内存持久化</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#RDB><span class=nav-number>5.1.6.1.</span> <span class=nav-text>RDB</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#AOF><span class=nav-number>5.1.6.2.</span> <span class=nav-text>AOF</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BA%8B%E5%8A%A1-1><span class=nav-number>5.1.7.</span> <span class=nav-text>事务</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#RabbitMQ%E2%9C%A8><span class=nav-number>5.2.</span> <span class=nav-text>RabbitMQ✨</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#Kafka><span class=nav-number>5.3.</span> <span class=nav-text>Kafka</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#RocketMQ><span class=nav-number>5.4.</span> <span class=nav-text>RocketMQ</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6><span class=nav-number>6.</span> <span class=nav-text>网络编程框架</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#Netty><span class=nav-number>6.1.</span> <span class=nav-text>Netty</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5><span class=nav-number>6.1.1.</span> <span class=nav-text>重要概念</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#Spring%E5%AE%B6%E6%97%8F%E2%9C%A8><span class=nav-number>7.</span> <span class=nav-text>Spring家族✨</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#spring><span class=nav-number>7.1.</span> <span class=nav-text>spring</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#IOC%E5%AE%B9%E5%99%A8><span class=nav-number>7.1.1.</span> <span class=nav-text>IOC容器</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5><span class=nav-number>7.1.1.1.</span> <span class=nav-text>构造器注入</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95><span class=nav-number>7.1.1.2.</span> <span class=nav-text>静态工厂方法</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95><span class=nav-number>7.1.1.3.</span> <span class=nav-text>实例工厂方法</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%90%8E%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7><span class=nav-number>7.1.1.4.</span> <span class=nav-text>实例化后设置属性</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%B3%A8%E8%A7%A3Annotation%E9%85%8D%E7%BD%AE><span class=nav-number>7.1.1.5.</span> <span class=nav-text>注解Annotation配置</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BD%BF%E7%94%A8Java%E9%85%8D%E7%BD%AE%E7%B1%BB><span class=nav-number>7.1.1.6.</span> <span class=nav-text>使用Java配置类</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Bean%E7%9A%84%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86><span class=nav-number>7.1.1.7.</span> <span class=nav-text>Bean的声明周期管理</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%80%89%E6%8B%A9%E6%80%A7%E5%AE%9E%E4%BE%8B%E5%8C%96Bean><span class=nav-number>7.1.1.8.</span> <span class=nav-text>选择性实例化Bean</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5><span class=nav-number>7.1.2.</span> <span class=nav-text>如何实现依赖注入</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#AOP%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86><span class=nav-number>7.1.3.</span> <span class=nav-text>AOP的底层原理</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#AOP%E4%B8%83%E5%A4%A7%E6%9C%AF%E8%AF%AD><span class=nav-number>7.1.3.1.</span> <span class=nav-text>AOP七大术语</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F><span class=nav-number>7.1.3.2.</span> <span class=nav-text>切点表达式</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1><span class=nav-number>7.1.4.</span> <span class=nav-text>如何管理事务</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#Spring%E4%BA%8B%E5%8A%A1><span class=nav-number>7.1.4.1.</span> <span class=nav-text>Spring事务</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7><span class=nav-number>7.1.4.2.</span> <span class=nav-text>事务属性</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96><span class=nav-number>7.1.5.</span> <span class=nav-text>如何处理循环依赖</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F><span class=nav-number>7.1.6.</span> <span class=nav-text>代理模式</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#springmvc><span class=nav-number>7.2.</span> <span class=nav-text>springmvc</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#springboot><span class=nav-number>7.3.</span> <span class=nav-text>springboot</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#application-yml><span class=nav-number>7.3.0.1.</span> <span class=nav-text>application.yml</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F><span class=nav-number>7.3.1.</span> <span class=nav-text>使用环境变量</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#logback-spring-xml><span class=nav-number>7.3.2.</span> <span class=nav-text>logback-spring.xml</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Controller><span class=nav-number>7.3.3.</span> <span class=nav-text>Controller</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BC%A0%E5%85%A5%E5%8F%82%E6%95%B0><span class=nav-number>7.3.3.1.</span> <span class=nav-text>传入参数</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C><span class=nav-number>7.3.3.2.</span> <span class=nav-text>参数校验</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#HttpSession><span class=nav-number>7.3.3.3.</span> <span class=nav-text>HttpSession</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%BF%94%E5%9B%9E%E5%80%BC><span class=nav-number>7.3.3.4.</span> <span class=nav-text>返回值</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%8B%A6%E6%88%AA%E5%99%A8><span class=nav-number>7.3.3.5.</span> <span class=nav-text>拦截器</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#Service><span class=nav-number>7.3.4.</span> <span class=nav-text>Service</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Mapper><span class=nav-number>7.3.5.</span> <span class=nav-text>Mapper</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#springcloud><span class=nav-number>7.4.</span> <span class=nav-text>springcloud</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%B8%B8%E7%94%A8%E5%BA%93><span class=nav-number>8.</span> <span class=nav-text>常用库</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#lombok%E2%9C%A8><span class=nav-number>8.1.</span> <span class=nav-text>lombok✨</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#hutool%E2%9C%A8><span class=nav-number>8.2.</span> <span class=nav-text>hutool✨</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#slf4j%E2%9C%A8><span class=nav-number>8.3.</span> <span class=nav-text>slf4j✨</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#logback><span class=nav-number>8.4.</span> <span class=nav-text>logback</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#log4j><span class=nav-number>8.5.</span> <span class=nav-text>log4j</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD><span class=nav-number>9.</span> <span class=nav-text>常用术语</span></a></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>246</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>16</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>215</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a><li class=links-of-blogroll-item><a href=https://www.lllomh.com/ rel=noopener target=_blank title=https://www.lllomh.com/>芈渡</a><li class=links-of-blogroll-item><a href=https://protool-ten.vercel.app/ rel=noopener target=_blank title=https://protool-ten.vercel.app/>protools</a></ul></div><div class="motion-element announcement"><div class=title></div><p class=content><p class=date></div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>此文章目前无词云</h3></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2025</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>3.3m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>50:09</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer></div><script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script><script src=/lib/anime.min.js></script><script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script><script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/pisces.js></script><script src=/js/next-boot.js></script><script src=/js/bookmark.js></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	'.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script><script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script><script src=/js/algolia-search.js></script><script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script><div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div><script charset=utf-8 defer src=/js/tagcanvas.js></script><script charset=utf-8 defer src=/js/tagcloud.js></script><script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script><script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script><script src=/js/src/activate-power-mode.min.js></script><script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script>
<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"0F9LEEVW82","apiKey":"78839e9f9be09d081c5c4da81975cd19","indexName":"sekyoblog_sec","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content=学习很潮很流行的Java以及相关框架. name=description><meta content=article property=og:type><meta content=mini-java-guide property=og:title><meta content=https://www.sekyoro.top/2025/03/09/mini-java-guide/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content=学习很潮很流行的Java以及相关框架. property=og:description><meta content=zh_CN property=og:locale><meta content=https://s2.loli.net/2025/03/19/XA1uEi8Q4GBOYeL.png property=og:image><meta content=https://s2.loli.net/2025/03/19/oHwP9Ub47rKRhyu.png property=og:image><meta content=https://s2.loli.net/2025/03/19/BG9x3zCAEjU7IlX.png property=og:image><meta content=https://s2.loli.net/2025/03/19/GyptQ1F3KcbhIZo.png property=og:image><meta content=https://s2.loli.net/2025/03/18/JHyvrF3A1SiuIel.png property=og:image><meta content=https://s2.loli.net/2025/03/18/VPxZDv3EGAcUpXs.png property=og:image><meta content=https://s2.loli.net/2025/03/18/zGuoR1B98kEKLxS.png property=og:image><meta content=https://s2.loli.net/2025/03/18/cQr1mCLgliJtbvz.png property=og:image><meta content=https://s2.loli.net/2025/03/18/GrE4zd586Jh9jAO.png property=og:image><meta content=https://s2.loli.net/2025/03/18/DvQmr3tiWezX2xq.png property=og:image><meta content=https://s2.loli.net/2025/03/19/wiUs3FnHfLKgjkQ.png property=og:image><meta content=https://s2.loli.net/2025/03/19/zEqWugTiRUsaK7C.png property=og:image><meta content=https://s2.loli.net/2025/03/19/Dq6nC1eRwIlMUmS.png property=og:image><meta content=https://s2.loli.net/2025/03/19/ycB948TkMLeEwmr.png property=og:image><meta content=https://s2.loli.net/2025/03/19/qfkja1eAIUKObEX.png property=og:image><meta content=https://s2.loli.net/2025/03/11/yhg79kQxwJiCBO6.png property=og:image><meta content=https://s2.loli.net/2025/03/11/XR4zx7ycNQiSBlt.png property=og:image><meta content=https://s2.loli.net/2025/03/14/8tKapiLbw7csMlP.png property=og:image><meta content=https://s2.loli.net/2025/03/14/ZL6IFGzBio5Pbc2.png property=og:image><meta content=https://s2.loli.net/2025/03/19/WxNStmTMp2D5viR.png property=og:image><meta content=https://s2.loli.net/2025/03/19/8Dlxb1zAqTgOWyF.png property=og:image><meta content=https://s2.loli.net/2025/03/19/S8WiOA2HE5gwVUT.png property=og:image><meta content=https://s2.loli.net/2025/03/19/y1U9gKj6fHmab8k.png property=og:image><meta content=https://s2.loli.net/2025/03/19/bBamC6ND3n7TcEO.png property=og:image><meta content=https://s2.loli.net/2025/03/19/yTXM2Brukzw7IC8.png property=og:image><meta content=https://s2.loli.net/2025/03/19/yIabTL2S9J4vDlX.png property=og:image><meta content=https://s2.loli.net/2025/03/19/A8KrfdjOShZTsnU.png property=og:image><meta content=https://s2.loli.net/2025/03/20/iZdH8kUa9LYAFQW.png property=og:image><meta content=https://s2.loli.net/2025/03/20/BMyrksQT5S6xlqf.png property=og:image><meta content=https://www.runoob.com/wp-content/uploads/2018/09/maven-package-build-phase.png property=og:image><meta content=https://s2.loli.net/2025/03/26/F7Ebo35RH6XIQft.png property=og:image><meta content=https://s2.loli.net/2025/03/26/LjCFSxblAyBGEhd.png property=og:image><meta content=https://s2.loli.net/2025/03/09/S12tudvJjEeoXTp.png property=og:image><meta content=https://s2.loli.net/2025/03/10/u1fMijOcWHJGRTF.png property=og:image><meta content=https://s2.loli.net/2025/03/10/ckaRKM5JnPW9FEB.png property=og:image><meta content=https://s2.loli.net/2025/03/10/odIl2cm87SBxpk3.png property=og:image><meta content=https://s2.loli.net/2025/03/10/NjzLtSgZ9UKIQWC.png property=og:image><meta content=https://s2.loli.net/2025/03/26/sjPGpMUlIBCfXrg.png property=og:image><meta content=https://s2.loli.net/2025/03/26/ALHs6CkcYGnB8me.png property=og:image><meta content=https://s2.loli.net/2025/03/26/4JMB7i9FwZpSLVW.png property=og:image><meta content=https://s2.loli.net/2025/03/26/sKmpPezAdXafgn4.png property=og:image><meta content=https://s2.loli.net/2025/03/26/UhEFYszHKGQjTBt.png property=og:image><meta content=https://s2.loli.net/2025/03/26/8d5MsA1VqQovZXc.png property=og:image><meta content=https://s2.loli.net/2025/03/26/n8DoQbwTMVa5FZY.png property=og:image><meta content=https://s2.loli.net/2025/03/26/4BPamIhnFEviQWy.png property=og:image><meta content=https://s2.loli.net/2025/03/26/D25tMOAiSJjCx1n.png property=og:image><meta content=https://s2.loli.net/2025/03/25/Xij1Npoe8xrqcS3.png property=og:image><meta content=https://s2.loli.net/2025/03/25/axN3ZGnYCrV2dt1.png property=og:image><meta content=https://s2.loli.net/2025/03/25/Aaehzxr8njmpCbq.png property=og:image><meta content=https://s2.loli.net/2025/03/25/I2n1hxzA8XteQP5.png property=og:image><meta content=https://s2.loli.net/2025/03/25/2FKGxVs6pUu5d3g.png property=og:image><meta content=https://s2.loli.net/2025/03/25/KnfBu1UqX9DrAEW.png property=og:image><meta content=https://s2.loli.net/2025/03/25/UYWLnOzjM3FitKD.png property=og:image><meta content=https://s2.loli.net/2025/03/25/vSzoKf3ibdCDQw2.png property=og:image><meta content=https://s2.loli.net/2025/03/25/ObYogUBk1F5Xi3C.png property=og:image><meta content=https://s2.loli.net/2025/03/25/eVhk1jS2WB9H7Za.png property=og:image><meta content=https://s2.loli.net/2025/03/25/KvqyuzAp4XeFJE8.png property=og:image><meta content=https://s2.loli.net/2025/03/25/hL2vHmQEdOAuocX.png property=og:image><meta content=2025-03-09T02:10:08.000Z property=article:published_time><meta content=2025-03-27T15:41:17.024Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content="个人博客 技术学习 计算机 互联网 人工智能" property=article:tag><meta content=summary name=twitter:card><meta content=https://s2.loli.net/2025/03/19/XA1uEi8Q4GBOYeL.png name=twitter:image><link href=https://www.sekyoro.top/2025/03/09/mini-java-guide/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>mini-java-guide | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2025/03/09/mini-java-guide/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>mini-java-guide</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2025-03-09 10:10:08" datetime=2025-03-09T10:10:08+08:00>2025-03-09</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-03-27 23:41:17" datetime=2025-03-27T23:41:17+08:00 itemprop=dateModified>2025-03-27</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>82k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>1:15</span> </span></div></header><div class=post-body itemprop=articleBody><p>学习很潮很流行的Java以及相关框架.<br><span id=more></span><p><a href=https://liaoxuefeng.com/books/java/introduction/index.html rel=noopener target=_blank>简介 - Java教程 - 廖雪峰的官方网站</a><h1 id=Java基础><a class=headerlink href=#Java基础 title=Java基础></a>Java基础</h1><h2 id=Java基础-1><a class=headerlink href=#Java基础-1 title=Java基础></a>Java基础</h2><h3 id=1-java-lang><a title="1. java.lang.*" class=headerlink href=#1-java-lang></a>1. java.lang.*</h3><p>这是默认导入的包，包含基本类和接口。<ul><li><strong>Object</strong>：所有类的超类。<li><strong>String</strong>：不可变字符串类，用于文本处理。<li><strong>StringBuilder/StringBuffer</strong>：可变字符串类，适用于频繁修改字符串的场景。<code>StringBuffer</code>是线程安全的版本。<li><strong>System</strong>：提供系统相关的信息和操作，如<code>System.out.println()</code>打印输出。<li><strong>Math</strong>：提供数学计算的方法，如三角函数、对数等。<li><strong>Integer, Double 等包装类</strong>：基本类型的对象表示形式，支持自动装箱/拆箱。</ul><h3 id=2-java-util><a title="2. java.util.*" class=headerlink href=#2-java-util></a>2. java.util.*</h3><p>包含了集合框架、日期时间工具、随机数生成器等实用工具类。<ul><li><strong>Collection 接口及其实现类</strong>（如ArrayList, LinkedList, HashSet, TreeSet等）：提供了不同类型的集合实现。<li><strong>Map 接口及其实现类</strong>（如HashMap, TreeMap等）：键值对存储结构。<li><strong>Iterator</strong>：遍历集合的标准方式。<li><strong>Date, Calendar, LocalDate, LocalDateTime</strong>（Java 8+）：处理日期和时间。<li><strong>Random</strong>：生成伪随机数。<li><strong>Arrays</strong>：提供操作数组的各种静态方法。</ul><h3 id=3-java-io><a title="3. java.io.*" class=headerlink href=#3-java-io></a>3. java.io.*</h3><p>提供输入输出流的支持，用于读写文件或进行网络通信。<ul><li><strong>InputStream/OutputStream</strong>：字节流基类。<li><strong>Reader/Writer</strong>：字符流基类。<li><strong>File</strong>：文件或目录路径名的抽象表示形式。<li><strong>BufferedReader/BufferedWriter, BufferedInputStream/BufferedOutputStream</strong>：提高I/O效率的缓冲类。</ul><h3 id=4-java-nio><a title="4. java.nio.*" class=headerlink href=#4-java-nio></a>4. java.nio.*</h3><p>新的I/O API，提供了更高效的非阻塞I/O操作。<ul><li><strong>Path, Paths</strong>：用于处理文件系统路径。<li><strong>Files</strong>：提供对文件的操作方法。<li><strong>ByteBuffer</strong>及其他缓冲区类型：用于高效地管理字节序列。</ul><h3 id=5-java-net><a title="5. java.net.*" class=headerlink href=#5-java-net></a>5. java.net.*</h3><p>网络编程相关的API。<ul><li><strong>URL, URI</strong>：统一资源定位符/标识符。<li><strong>URLConnection</strong>：与URL建立连接。<li><strong>Socket, ServerSocket</strong>：TCP/IP套接字编程的基础类。<li><strong>DatagramPacket, DatagramSocket</strong>：UDP协议的支持。</ul><h3 id=6-java-text><a title="6. java.text.*" class=headerlink href=#6-java-text></a>6. java.text.*</h3><p>用于格式化和解析文本。<ul><li><strong>NumberFormat, DecimalFormat</strong>：数字格式化。<li><strong>DateFormat, SimpleDateFormat</strong>：日期格式化。<li><strong>MessageFormat</strong>：根据模式格式化消息。</ul><h3 id=7-java-time><a title="7. java.time.*" class=headerlink href=#7-java-time></a>7. java.time.*</h3><p>Java 8引入的新日期时间API。<ul><li><strong>Instant</strong>：表示时间线上的一点。<li><strong>LocalDate, LocalTime, LocalDateTime</strong>：分别表示不带时区的日期、时间和日期时间。<li><strong>ZonedDateTime, OffsetDateTime</strong>：带有时区信息的日期时间。</ul><h3 id=8-并发相关><a title="8. 并发相关" class=headerlink href=#8-并发相关></a>8. 并发相关</h3><ul><li><strong>Thread</strong>：创建和控制线程。<li><strong>Runnable</strong>：线程执行的目标接口。<li><strong>ExecutorService, Executors</strong>：更高级别的线程管理。<li><strong>Lock, ReentrantLock</strong>：比同步块更灵活的锁定机制。<li><strong>ConcurrentHashMap</strong>：线程安全的哈希表实现。</ul><h3 id=9-其他><a title="9. 其他" class=headerlink href=#9-其他></a>9. 其他</h3><ul><li><strong>Optional</strong>（Java 8+）：避免空指针异常的一种设计模式。<li><strong>Stream API</strong>（Java 8+）：提供了一种高效且易于使用的集合元素处理方式。</ul><div class=table-container><table><thead><tr><th>访问修饰符<th>同一类<th>同一包<th>子类（不同包）<th>全局<tbody><tr><td><code>public</code><td>是<td>是<td>是<td>是<tr><td><code>protected</code><td>是<td>是<td>是<td>否<tr><td>默认<td>是<td>是<td>否<td>否<tr><td><code>private</code><td>是<td>否<td>否<td>否</table></div><h3 id=内部类><a class=headerlink href=#内部类 title=内部类></a>内部类</h3><p>成员内部类,静态内部类,局部内部类,匿名内部类<p><img alt=image-20250319142346062 data-src=https://s2.loli.net/2025/03/19/XA1uEi8Q4GBOYeL.png><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=comment>// 成员内部类</span></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>outerclass</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> String age;</span><br><span class=line>    <span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>innerclass</span> </span>{</span><br><span class=line>        <span class=function><span class=keyword>void</span> <span class=title>display</span><span class=params>()</span> </span>{</span><br><span class=line>            System.out.println(<span class=string>"This is an inner class"</span>);</span><br><span class=line>            System.out.println(name);</span><br><span class=line>            System.out.println(age);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><img alt=image-20250319142856906 data-src=https://s2.loli.net/2025/03/19/oHwP9Ub47rKRhyu.png><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=class><span class=keyword>class</span> <span class=title>innercls</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>display</span><span class=params>()</span> </span>{</span><br><span class=line>        System.out.println(<span class=string>"This is an inner class"</span>);</span><br><span class=line>        System.out.println(innercls.<span class=keyword>this</span>);</span><br><span class=line>        System.out.println(age);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><img alt=image-20250319144727002 data-src=https://s2.loli.net/2025/03/19/BG9x3zCAEjU7IlX.png><p><img alt=image-20250319150803696 data-src=https://s2.loli.net/2025/03/19/GyptQ1F3KcbhIZo.png><h3 id=集合Collection与Map><a class=headerlink href=#集合Collection与Map title=集合Collection与Map></a>集合Collection与Map</h3><p>数组和集合的区别：<p>数组<ul><li><p><strong>固定大小</strong>：数组一旦创建，其大小是固定的，不能动态增加或减少元素。</p><li><p><strong>类型安全</strong>：数组可以是基本数据类型（如 <code>int[]</code>, <code>double[]</code>）或对象类型（如 <code>String[]</code>）。对于对象类型的数组，所有元素都必须是该类的实例或者 <code>null</code>。</p><li><p><strong>内存连续</strong>：数组中的元素在内存中是连续存储的，这使得访问速度非常快，因为可以通过计算偏移量直接访问任何元素（时间复杂度为 O(1)）。</p><li><p>声明方式</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>int</span>[] numbers = <span class=keyword>new</span> <span class=keyword>int</span>[<span class=number>5</span>]; <span class=comment>// 创建一个包含5个整数的数组</span></span><br><span class=line>String[] names = {<span class=string>"Alice"</span>, <span class=string>"Bob"</span>}; <span class=comment>// 初始化时赋值</span></span><br></pre></table></figure></ul><p><strong>优点</strong><ul><li>访问速度快，支持随机访问。<li>对于小规模、固定数量的数据集非常适合。</ul><h5 id=List><a class=headerlink href=#List title=List></a>List</h5><p><strong>定义与特性</strong><ul><li><p><strong>动态大小</strong>：<code>List</code> 接口的主要实现类（如 <code>ArrayList</code>, <code>LinkedList</code>）允许动态添加和删除元素，这意味着你可以根据需要扩展或缩小列表的大小。</p><li><p><strong>接口与实现</strong>：<code>List</code> 是一个接口，常用的实现包括 <code>ArrayList</code> 和 <code>LinkedList</code>。<code>ArrayList</code> 底层基于数组实现，而 <code>LinkedList</code> 则是一个双向链表。</p><li><p><strong>类型安全</strong>：<code>List</code> 只能存储对象，不能直接存储基本数据类型（但可以使用自动装箱/拆箱功能处理基本数据类型）。</p><li><p>声明方式</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>List&LTString> names = <span class=keyword>new</span> ArrayList<>();</span><br><span class=line>names.add(<span class=string>"Alice"</span>);</span><br><span class=line>names.add(<span class=string>"Bob"</span>);</span><br></pre></table></figure></ul><p><strong>优点</strong><ul><li>动态大小，方便添加和删除元素。<li>提供了丰富的操作方法，比如 <code>add()</code>, <code>remove()</code>, <code>get()</code>, <code>indexOf()</code> 等等。<li>更好的抽象层次，代码更加灵活易读。</ul><p><strong>缺点</strong><ul><li>相比于数组，某些操作可能效率较低，例如在 <code>ArrayList</code> 中插入或删除中间位置的元素会导致其他元素移动；而在 <code>LinkedList</code> 中查找元素则需要从头或尾遍历整个列表。</ul><p>ArrayList使用数组实现,查询快,增删慢<p>LinkedList使用双向链表实现,查询慢,增删快,尤其对于首尾操作<p><img alt=image-20250318215401958 data-src=https://s2.loli.net/2025/03/18/JHyvrF3A1SiuIel.png><h5 id=Set><a class=headerlink href=#Set title=Set></a>Set</h5><p><img alt=image-20250318220123427 data-src=https://s2.loli.net/2025/03/18/VPxZDv3EGAcUpXs.png><p>HashSet使用哈希表实现,增删改查性能较好<p><img alt=image-20250318220818128 data-src=https://s2.loli.net/2025/03/18/zGuoR1B98kEKLxS.png><p><img alt=image-20250318221151248 data-src=https://s2.loli.net/2025/03/18/cQr1mCLgliJtbvz.png><p>HashSet去重主要依赖于两个关键方法：<code>hashCode()</code> 和 <code>equals()</code>。<ol><li><strong>hashCode() 方法</strong>：<ul><li>当你尝试将一个对象添加到 HashSet 中时，HashSet 会首先调用这个对象的 <code>hashCode()</code> 方法来计算该对象的哈希值。<li>这个哈希值决定了对象在内部哈希表中的存储位置（即所谓的“桶”）。</ul><li><strong>equals() 方法</strong>：<ul><li>如果两个对象有相同的哈希值（或者它们被分配到了同一个桶中），HashSet 将使用 <code>equals()</code> 方法来进一步检查这两个对象是否真正相等。<li>如果 <code>equals()</code> 返回 <code>true</code>，则认为这两个对象是重复的，新对象不会被添加到集合中。如果 <code>equals()</code> 返回 <code>false</code>，即使哈希值相同，这两个对象也被认为是不同的，并且都会被添加到集合中。</ul></ol><p>对于自定义类的对象，如果你希望它们能够正确地在 HashSet 中进行去重，你需要重写 <code>hashCode()</code> 和 <code>equals()</code> 方法，以确保具有相同业务含义的对象返回相同的哈希码并且 <code>equals()</code> 方法也返回 <code>true</code>。<p>TreeSet底层基于红黑树,可排序,不重复,无索引<p><img alt=image-20250318231528714 data-src=https://s2.loli.net/2025/03/18/GrE4zd586Jh9jAO.png><p><img alt=image-20250318234747847 data-src=https://s2.loli.net/2025/03/18/DvQmr3tiWezX2xq.png><h5 id=Map><a class=headerlink href=#Map title=Map></a>Map</h5><p><img alt=image-20250319103421264 data-src=https://s2.loli.net/2025/03/19/wiUs3FnHfLKgjkQ.png><p><img alt=image-20250319104523905 data-src=https://s2.loli.net/2025/03/19/zEqWugTiRUsaK7C.png><p>Map的遍历方式<p><img alt=image-20250319110144222 data-src=https://s2.loli.net/2025/03/19/Dq6nC1eRwIlMUmS.png><p><strong>使用 for-each 循环和 entrySet()</strong><p>这是最常用的遍历方式之一，因为它提供了对键和值的访问。<figure class="highlight ada"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>for</span> (Map.<span class=keyword>Entry</span>&LTString, Integer> <span class=keyword>entry</span> : <span class=type>map.entrySet</span>()) {</span><br><span class=line>    System.<span class=keyword>out</span>.println(<span class=keyword>entry</span>.getKey() + <span class=string>": "</span> + <span class=keyword>entry</span>.getValue());</span><br><span class=line>}</span><br></pre></table></figure><p><strong>使用迭代器</strong><p>使用迭代器可以更灵活地控制遍历过程。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>Iterator&LTMap.Entry&LTString, Integer>> iterator = map.entrySet().iterator();</span><br><span class=line><span class=keyword>while</span> (iterator.hasNext()) {</span><br><span class=line>    Map.Entry&LTString, Integer> entry = iterator.next();</span><br><span class=line>    System.out.println(entry.getKey() + <span class=string>": "</span> + entry.getValue());</span><br><span class=line>}</span><br></pre></table></figure><p><strong>使用 Java 8 的 Stream API</strong><p>通过 <code>stream()</code> 方法可以利用 Stream API 来遍历或进行其他操作。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>map.entrySet().stream().forEach(entry -> </span><br><span class=line>    System.out.println(entry.getKey() + <span class=string>": "</span> + entry.getValue())</span><br><span class=line>);</span><br></pre></table></figure><p>或者对于某些特定的操作，比如过滤、映射等：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>map.entrySet().stream()</span><br><span class=line>   .filter(entry -> entry.getValue() > <span class=number>1</span>)</span><br><span class=line>   .forEach(entry -> System.out.println(entry.getKey()));</span><br></pre></table></figure><p><img alt=image-20250319114156720 data-src=https://s2.loli.net/2025/03/19/ycB948TkMLeEwmr.png><p>Stream流包括中间方法和最终方法,中间方法使用filter,map,调用完成后会返回新的流<p><img alt=image-20250319120025921 data-src=https://s2.loli.net/2025/03/19/qfkja1eAIUKObEX.png><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line>List&LTString> alist = <span class=keyword>new</span> ArrayList<>();</span><br><span class=line>alist.add(<span class=string>"a"</span>);</span><br><span class=line>alist.add(<span class=string>"b"</span>);</span><br><span class=line>List&LTString> list = alist.stream().map((String a) -> a + <span class=string>"a"</span>).toList();</span><br><span class=line>List&LTDouble> blist = <span class=keyword>new</span> ArrayList<>();</span><br><span class=line>list.stream().filter(s-> !s.isEmpty()).forEach(System.out::println);</span><br><span class=line></span><br><span class=line>list.stream().sorted(Comparator.comparingDouble(String::length).reversed()).forEach(System.out::println);</span><br><span class=line>blist.stream().sorted(Double::compare).forEach(System.out::println);</span><br><span class=line></span><br><span class=line><span class=comment>// 去重 limit只需要一个参数 skip跳过前几个</span></span><br><span class=line>blist.stream().distinct().skip(<span class=number>1</span>).limit(<span class=number>2</span>).forEach(System.out::println);</span><br><span class=line></span><br><span class=line><span class=comment>// 转换成map</span></span><br><span class=line>list.stream().collect(Collectors.toMap(Function.identity(), String::length)).forEach((k, v) -> System.out.println(k + <span class=string>":"</span> + v));</span><br><span class=line></span><br><span class=line>Stream&LTString> a = Stream.of(<span class=string>"a"</span>, <span class=string>"b"</span>, <span class=string>"c"</span>);</span><br><span class=line>Stream&LTInteger> integerStream = Stream.of(<span class=number>1</span>, <span class=number>2</span>);</span><br><span class=line><span class=comment>// 合并两个流</span></span><br><span class=line>Stream.concat(a, integerStream).forEach(System.out::println);</span><br></pre></table></figure><h4 id=异常、泛型与集合框架><a class=headerlink href=#异常、泛型与集合框架 title=异常、泛型与集合框架></a>异常、泛型与集合框架</h4><p>Java中异常的类继承体系<p><img alt=image-20250311153912955 data-src=https://s2.loli.net/2025/03/11/yhg79kQxwJiCBO6.png><p>运行时异常(extends RuntimeException:数组索引越界<p>编译异常(extends Exception). 编译时异常需要通过try-catch或throw丢出异常进行处理,<p>运行时异常不需要特别处理<p>此外异常可以分为业务类和运行逻辑类,一些代码中的异常应该被catch然后向上抛给业务类或者直接处理.<p><img alt=image-20250311175150716 data-src=https://s2.loli.net/2025/03/11/XR4zx7ycNQiSBlt.png><p>泛型允许编写可以<strong>处理不同类型数据的类、接口和方法，而无需在代码中明确指定具体类型</strong>。泛型提供了更强的类型检查，并且消除了对类型转换的需求，从而使得代码更加安全和易于维护。<p><strong>类型参数</strong>：在定义泛型类或方法时使用占位符（通常为大写字母如 <code>T</code>, <code>E</code>, <code>K</code>, <code>V</code> 等），代表实际应用中的类型。<ul><li><strong>类型安全</strong>：编译器会在编译期进行类型检查，减少运行时出现的 <code>ClassCastException</code> 错误。<li><strong>消除类型转换</strong>：由于类型信息在编译时已知，因此不需要显式的类型转换。</ul><h4 id=使用泛型类><a class=headerlink href=#使用泛型类 title=使用泛型类></a>使用泛型类</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>Box&LTInteger> integerBox = <span class=keyword>new</span> Box<>();</span><br><span class=line>integerBox.set(<span class=number>10</span>);</span><br><span class=line>Integer intValue = integerBox.get();</span><br><span class=line></span><br><span class=line>Box&LTString> stringBox = <span class=keyword>new</span> Box<>();</span><br><span class=line>stringBox.set(<span class=string>"Hello World"</span>);</span><br><span class=line>String strValue = stringBox.get();</span><br></pre></table></figure><h4 id=泛型方法><a class=headerlink href=#泛型方法 title=泛型方法></a>泛型方法</h4><p>你也可以定义泛型方法，即在方法级别上使用泛型。例如：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> &LTT> <span class=function><span class=keyword>void</span> <span class=title>printArray</span><span class=params>(T[] array)</span> </span>{</span><br><span class=line>    <span class=keyword>for</span> (T element : array) {</span><br><span class=line>        System.out.println(element);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>    Integer[] intArray = {<span class=number>1</span>, <span class=number>2</span>, <span class=number>3</span>};</span><br><span class=line>    String[] stringArray = {<span class=string>"A"</span>, <span class=string>"B"</span>, <span class=string>"C"</span>};</span><br><span class=line></span><br><span class=line>    printArray(intArray);</span><br><span class=line>    printArray(stringArray);</span><br><span class=line>}</span><br></pre></table></figure><p>在这个例子中，<code>&LTT></code> 在方法签名前声明了类型参数，这样这个方法就可以接受任意类型的数组作为参数。<h4 id=泛型接口><a class=headerlink href=#泛型接口 title=泛型接口></a>泛型接口</h4><p>类似地，也可以定义泛型接口：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>interface</span> <span class=title>Container</span><<span class=title>T</span>> </span>{</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>add</span><span class=params>(T item)</span></span>;</span><br><span class=line>    <span class=function>T <span class=title>get</span><span class=params>(<span class=keyword>int</span> index)</span></span>;</span><br><span class=line>}</span><br></pre></table></figure><p>然后实现这个接口：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>StringContainer</span> <span class=keyword>implements</span> <span class=title>Container</span><<span class=title>String</span>> </span>{</span><br><span class=line>    <span class=keyword>private</span> List&LTString> items = <span class=keyword>new</span> ArrayList<>();</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>add</span><span class=params>(String item)</span> </span>{</span><br><span class=line>        items.add(item);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> String <span class=title>get</span><span class=params>(<span class=keyword>int</span> index)</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> items.get(index);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>Java 泛型是在 Java 5 中引入的，而在此之前已经存在了大量的 Java 代码库。如果直接在 JVM 层面实现泛型支持，那么这些现有的代码可能会因为缺乏泛型信息而不兼容。通过类型擦除，Java 编译器能够在编译时移除泛型类型信息，并将泛型代码转换为非泛型代码，这样就可以确保新旧代码可以无缝地一起工作</blockquote><p><strong>通配符</strong><p>有时可能需要编写能够与多种类型工作的代码，但并不需要知道这些类型的具体细节。这时可以使用通配符 <code>?</code>：<ul><li><strong>无界通配符</strong>：<code>&LT?></code> 表示可以是任何类型。<li><strong>有界通配符</strong>：<code>&LT? extends T></code> 和 <code>&LT? super T></code> 分别表示类型必须是 <code>T</code> 或其子类，以及 <code>T</code> 或其父类。</ul><p><strong>泛型的优点</strong><ol><li><strong>类型安全</strong>：编译器可以在编译时进行更多的类型检查，减少运行时错误。<li><strong>消除强制类型转换</strong>：不再需要手动将对象转换回原始类型。<li><strong>提高代码重用性</strong>：通过泛型，相同的逻辑可以应用于不同的数据类型。</ol><p>Java集合是一种容器,类似于数组但集合的大小可变.<p><img alt=image-20250314192425271 data-src=https://s2.loli.net/2025/03/14/8tKapiLbw7csMlP.png><p><img alt=image-20250314230501695 data-src=https://s2.loli.net/2025/03/14/ZL6IFGzBio5Pbc2.png><h3 id=多线程与线程池><a class=headerlink href=#多线程与线程池 title=多线程与线程池></a>多线程与线程池</h3><p><img alt=image-20250319170141141 data-src=https://s2.loli.net/2025/03/19/WxNStmTMp2D5viR.png><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.sekyoro.tutorThread;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.util.concurrent.Callable;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.ExecutionException;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.FutureTask;</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * <span class=doctag>@projectName</span>: workspace</span></span><br><span class=line><span class=comment> * <span class=doctag>@package</span>: com.sekyoro.tutorThread</span></span><br><span class=line><span class=comment> * <span class=doctag>@className</span>: threadDemo</span></span><br><span class=line><span class=comment> * <span class=doctag>@author</span>: proanimer</span></span><br><span class=line><span class=comment> * <span class=doctag>@description</span>:</span></span><br><span class=line><span class=comment> * <span class=doctag>@date</span>: 2025/3/19 16:19</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>easyThread</span> <span class=keyword>extends</span> <span class=title>Thread</span> </span>{</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>run</span><span class=params>()</span> </span>{</span><br><span class=line>        System.out.println(<span class=string>"This is a thread"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>miniThread</span> <span class=keyword>implements</span> <span class=title>Runnable</span></span>{</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>run</span><span class=params>()</span> </span>{</span><br><span class=line>        System.out.println(<span class=string>"This is a mini thread"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>miniCallable</span> <span class=keyword>implements</span> <span class=title>Callable</span><<span class=title>Integer</span>> </span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>int</span> n;</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>miniCallable</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.n = <span class=number>0</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>miniCallable</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.n = n;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> Integer <span class=title>call</span><span class=params>()</span> <span class=keyword>throws</span> Exception </span>{</span><br><span class=line>        System.out.println(<span class=string>"Calculating..."</span>);</span><br><span class=line>        <span class=keyword>return</span> <span class=number>10</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>int</span> <span class=title>getN</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> n;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>threadDemo</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> ExecutionException, InterruptedException </span>{</span><br><span class=line>        Thread et = <span class=keyword>new</span> easyThread();</span><br><span class=line>        et.start();</span><br><span class=line>        <span class=keyword>new</span> Thread(<span class=keyword>new</span> miniThread()).start();</span><br><span class=line></span><br><span class=line>        Callable&LTInteger> mc = <span class=keyword>new</span> miniCallable();</span><br><span class=line>        FutureTask&LTInteger> ft = <span class=keyword>new</span> FutureTask<>(mc);</span><br><span class=line>        <span class=keyword>new</span> Thread(ft).start();</span><br><span class=line>        Integer i = ft.get();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><img alt=image-20250319171222472 data-src=https://s2.loli.net/2025/03/19/8Dlxb1zAqTgOWyF.png><p>线程同步解决线程安全问题<p><strong>同步代码块</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>synchronized</span>() {</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><p><img alt=image-20250319173439131 data-src=https://s2.loli.net/2025/03/19/S8WiOA2HE5gwVUT.png><p><strong>同步方法</strong><p><img alt=image-20250319173832373 data-src=https://s2.loli.net/2025/03/19/y1U9gKj6fHmab8k.png><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>synchronized</span> <span class=keyword>void</span> <span class=title>draw</span><span class=params>(<span class=keyword>int</span> m)</span> </span>{</span><br><span class=line>          money -= m;   </span><br><span class=line>  }</span><br></pre></table></figure><p><strong>Lock锁</strong><p><img alt=image-20250319174259793 data-src=https://s2.loli.net/2025/03/19/bBamC6ND3n7TcEO.png><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>ReentrantLock lock = <span class=keyword>new</span> ReentrantLock();</span><br><span class=line>lock.lock();</span><br><span class=line>...</span><br><span class=line>lock.unlock();</span><br></pre></table></figure><p>显式锁（Explicit Lock）<ul><li><p>ReentrantLock 类提供了比synchronized更灵活的锁操作，例如可中断的锁等待、尝试非阻塞获取锁、超时获取锁等。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>Lock lock = <span class=keyword>new</span> ReentrantLock();</span><br><span class=line>lock.lock(); <span class=comment>// 获取锁</span></span><br><span class=line><span class=keyword>try</span> {</span><br><span class=line>    <span class=comment>// 受保护的代码</span></span><br><span class=line>} <span class=keyword>finally</span> {</span><br><span class=line>    lock.unlock(); <span class=comment>// 确保释放锁</span></span><br><span class=line>}</span><br></pre></table></figure></ul><ol><li>读写锁（ReadWriteLock）</ol><p>ReadWriteLock 接口 和 ReentrantReadWriteLock 实现类.允许多个读操作同时进行，但在写操作时排斥所有其他读写操作。适用于读多写少的场景。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line>ReadWriteLock rwl = <span class=keyword>new</span> ReentrantReadWriteLock();</span><br><span class=line>rwl.readLock().lock(); <span class=comment>// 获取读锁</span></span><br><span class=line><span class=keyword>try</span> {</span><br><span class=line>    <span class=comment>// 读取操作</span></span><br><span class=line>} <span class=keyword>finally</span> {</span><br><span class=line>    rwl.readLock().unlock(); <span class=comment>// 释放读锁</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line>rwl.writeLock().lock(); <span class=comment>// 获取写锁</span></span><br><span class=line><span class=keyword>try</span> {</span><br><span class=line>    <span class=comment>// 写入操作</span></span><br><span class=line>} <span class=keyword>finally</span> {</span><br><span class=line>    rwl.writeLock().unlock(); <span class=comment>// 释放写锁</span></span><br><span class=line>}</span><br></pre></table></figure><ol><li>条件变量（Condition）</ol><p>Condition 接口与显式锁配合使用，提供类似<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>Lock lock = <span class=keyword>new</span> ReentrantLock();</span><br><span class=line>Condition condition = lock.newCondition();</span><br><span class=line></span><br><span class=line>lock.lock();</span><br><span class=line><span class=keyword>try</span> {</span><br><span class=line>    condition.await(); <span class=comment>// 相当于 wait()</span></span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>    condition.signal(); <span class=comment>// 相当于 notify()</span></span><br><span class=line>} <span class=keyword>finally</span> {</span><br><span class=line>    lock.unlock();</span><br><span class=line>}</span><br></pre></table></figure><ol><li>StampedLock</ol><p>StampedLock 类是Java 8引入的一种新的锁类型，支持乐观读锁策略，适用于读多写少且大部分读操作不会发生冲突的情况。它提供了三种模式：写锁、悲观读锁和乐观读锁。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line>StampedLock stampedLock = <span class=keyword>new</span> StampedLock();</span><br><span class=line></span><br><span class=line><span class=keyword>long</span> stamp = stampedLock.readLock(); <span class=comment>// 悲观读锁</span></span><br><span class=line><span class=keyword>try</span> {</span><br><span class=line>    <span class=comment>// 读取操作</span></span><br><span class=line>} <span class=keyword>finally</span> {</span><br><span class=line>    stampedLock.unlockRead(stamp);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line>stamp = stampedLock.writeLock(); <span class=comment>// 写锁</span></span><br><span class=line><span class=keyword>try</span> {</span><br><span class=line>    <span class=comment>// 写入操作</span></span><br><span class=line>} <span class=keyword>finally</span> {</span><br><span class=line>    stampedLock.unlockWrite(stamp);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>long</span> optimisticStamp = stampedLock.tryOptimisticRead(); <span class=comment>// 乐观读锁</span></span><br><span class=line><span class=comment>// 验证并使用乐观读锁...</span></span><br><span class=line><span class=keyword>if</span> (!stampedLock.validate(optimisticStamp)) {</span><br><span class=line>    <span class=comment>// 如果验证失败，则需要重新获取悲观读锁或写锁</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>线程池</strong><ol><li>ThreadPoolExecutor创建线程池</ol><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment>// 1. 创建线程池</span></span><br><span class=line>ExecutorService pool = <span class=keyword>new</span> ThreadPoolExecutor(<span class=number>3</span>, <span class=number>5</span>, <span class=number>4</span>, TimeUnit.SECONDS, <span class=keyword>new</span> ArrayBlockingQueue<>(<span class=number>3</span>), Executors.defaultThreadFactory(), <span class=keyword>new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class=line></span><br><span class=line><span class=comment>// 2. 使用线程池处理任务</span></span><br><span class=line>Runnable myRunnable = <span class=keyword>new</span> MyRunnable(<span class=number>3</span>);</span><br><span class=line>pool.execute(<span class=keyword>new</span> MyRunnable(<span class=number>3</span>)); <span class=comment>//提交任务</span></span><br><span class=line>pool.execute(<span class=keyword>new</span> MyRunnable(<span class=number>3</span>)); <span class=comment>//提交任务</span></span><br><span class=line>pool.execute(<span class=keyword>new</span> MyRunnable(<span class=number>3</span>)); <span class=comment>//提交任务</span></span><br><span class=line>pool.execute(<span class=keyword>new</span> MyRunnable(<span class=number>3</span>)); <span class=comment>//提交任务</span></span><br></pre></table></figure><p><img alt=image-20250319205156594 data-src=https://s2.loli.net/2025/03/19/yTXM2Brukzw7IC8.png><p><img alt=image-20250319205627740 data-src=https://s2.loli.net/2025/03/19/yIabTL2S9J4vDlX.png><ol><li>利用Executors创建线程池</ol><p><img alt=image-20250319210516204 data-src=https://s2.loli.net/2025/03/19/A8KrfdjOShZTsnU.png><p>利用ThreadPoolExecutor设置不同参数调用<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>static</span> ExecutorService <span class=title>newFixedThreadPool</span><span class=params>(<span class=keyword>int</span> nThreads)</span> </span>{</span><br><span class=line><span class=keyword>return</span> <span class=keyword>new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class=line>                              <span class=number>0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=line>                              <span class=keyword>new</span> LinkedBlockingQueue&LTRunnable>());</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><h3 id=反射、注解与动态代理><a class=headerlink href=#反射、注解与动态代理 title=反射、注解与动态代理></a>反射、注解与动态代理</h3><p>反射是指在运行时动态地获取类的信息以及操作对象的能力。通常情况下，Java 编译器会在编译期确定所有类型和成员变量的访问权限及调用方式，而反射则允许你在运行时进行这些操作<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=comment>// 方式一: 直接通过类名获取</span></span><br><span class=line>Class&LT?> clazz = MyClass.class;</span><br><span class=line></span><br><span class=line><span class=comment>// 方式二: 使用对象的 getClass() 方法</span></span><br><span class=line>MyClass obj = <span class=keyword>new</span> MyClass();</span><br><span class=line>clazz = obj.getClass();</span><br><span class=line></span><br><span class=line><span class=comment>// 方式三: 通过全限定类名字符串</span></span><br><span class=line><span class=keyword>try</span> {</span><br><span class=line>    clazz = Class.forName(<span class=string>"com.example.MyClass"</span>);</span><br><span class=line>} <span class=keyword>catch</span> (ClassNotFoundException e) {</span><br><span class=line>    e.printStackTrace();</span><br><span class=line>}</span><br></pre></table></figure><p>得到的class类可以用来<strong>创建实例</strong>、<strong>访问字段</strong>、<strong>调用方法</strong>等<p>创建实例<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>try</span> {</span><br><span class=line>    <span class=comment>// 假设 MyClass 有一个无参构造函数</span></span><br><span class=line>    Object obj = clazz.getDeclaredConstructor().newInstance();</span><br><span class=line>} <span class=keyword>catch</span> (Exception e) {</span><br><span class=line>    e.printStackTrace();</span><br><span class=line>}</span><br><span class=line><span class=keyword>try</span> {</span><br><span class=line>    <span class=comment>// 获取指定参数类型的构造函数</span></span><br><span class=line>    Constructor&LTMyClass> constructor = clazz.getConstructor(paramType.class);</span><br><span class=line>    </span><br><span class=line>    <span class=comment>// 创建实例</span></span><br><span class=line>    MyClass instance = constructor.newInstance(args);</span><br><span class=line>} <span class=keyword>catch</span> (Exception e) {</span><br><span class=line>    e.printStackTrace();</span><br><span class=line>}</span><br></pre></table></figure><p><strong>注解（Annotations）</strong>是一种元数据形式，它提供了关于程序代码的额外信息，但这些信息并不直接改变程序的运行逻辑。注解自 Java 5 引入以来，已经成为 Java 开发中不可或缺的一部分，用于简化开发流程、提供配置信息、增强代码的功能等<ul><li><strong>定义</strong>：注解是接口的一种特殊形式，它通过 <code>@interface</code> 关键字来定义，并可以附加到类、方法、变量、参数、包声明等语言元素上。<li><strong>用途</strong>：主要用于编译时检查、运行时处理和生成源代码或文档。</ul><ol><li><strong>标记注解</strong>：没有成员变量，仅作为标记使用，如 <code>@Override</code>。<li><strong>单值注解</strong>：只有一个值，通常省略名称直接指定值，如 <code>@SuppressWarnings("unchecked")</code>。<li><strong>完整注解</strong>：包含多个成员变量，需要明确指定每个成员的值。</ol><p>元注解是指用来注解其他注解的注解，主要包括以下几个：<ul><li><code>@Retention</code>：定义了注解的存在阶段（SOURCE, CLASS, RUNTIME）。<li><code>@Target</code>：指定了注解可以应用的目标元素类型（TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE 等）。<li><code>@Documented</code>：表明这个注解应该被 javadoc 工具记录。<li><code>@Inherited</code>：允许子类继承父类中的注解。<li><code>@Repeatable</code>：从 Java 8 开始支持，表示相同的注解可以在同一地方多次使用。</ul><p><strong>注解的解析</strong><p>检查方法和类等是否包含对应注解,若包含则进行相关调用<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line>annotationDemo annotationDemo = <span class=keyword>new</span> annotationDemo();</span><br><span class=line> Class&LT?> aClass = annotationDemo.class;</span><br><span class=line> Method[] methods = aClass.getMethods();</span><br><span class=line> <span class=keyword>for</span> (Method method : methods) {</span><br><span class=line>     <span class=keyword>if</span> (method.isAnnotationPresent( MyTest.class)) {</span><br><span class=line>         <span class=keyword>try</span> {</span><br><span class=line>             MyTest declaredAnnotation = method.getDeclaredAnnotation(MyTest.class);</span><br><span class=line>             method.invoke(annotationDemo);</span><br><span class=line>         } <span class=keyword>catch</span> (IllegalAccessException | InvocationTargetException e) {</span><br><span class=line>             <span class=keyword>throw</span> <span class=keyword>new</span> RuntimeException(e);</span><br><span class=line>         }</span><br><span class=line>     }</span><br><span class=line> }</span><br></pre></table></figure><p><strong>动态代理</strong><p>Proxy.newProxyInstance创建代理,参数包括类加载器,需要实现的接口,和代理需要做的事情<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ProxyUtils</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> StarService <span class=title>createProxy</span><span class=params>(StarService starService)</span></span>{</span><br><span class=line>        StarService o = (StarService)Proxy.newProxyInstance(ProxyUtils.class.getClassLoader(), starService.getClass().getInterfaces(), <span class=keyword>new</span> InvocationHandler() {</span><br><span class=line>            <span class=meta>@Override</span></span><br><span class=line>            <span class=function><span class=keyword>public</span> Object <span class=title>invoke</span><span class=params>(Object proxy, Method method, Object[] args)</span> <span class=keyword>throws</span> Throwable </span>{</span><br><span class=line>               String methodName = method.getName();</span><br><span class=line>               <span class=keyword>if</span>(<span class=string>"sing"</span>.equals(methodName)) {</span><br><span class=line>                   System.out.println(<span class=string>"sing a song: "</span> + args[<span class=number>0</span>]);</span><br><span class=line>               }<span class=keyword>else</span>{</span><br><span class=line>                     System.out.println(<span class=string>"dance a dance"</span>);</span><br><span class=line>               }</span><br><span class=line>                <span class=keyword>if</span>(method.getReturnType().equals(Void.TYPE)) {</span><br><span class=line>                   <span class=keyword>return</span> <span class=keyword>null</span>;</span><br><span class=line>               }<span class=keyword>else</span>{</span><br><span class=line>                       <span class=keyword>return</span>  method.invoke(starService,args);</span><br><span class=line>               }</span><br><span class=line>            }</span><br><span class=line>        });</span><br><span class=line>        <span class=keyword>return</span> o;</span><br><span class=line></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><h4 id=ClassLoader><a class=headerlink href=#ClassLoader title=ClassLoader></a>ClassLoader</h4><p>类加载过程主要包括三个阶段：<strong>加载</strong>、<strong>链接</strong>和<strong>初始化</strong>。<ul><li><strong>加载</strong>：通过类的全限定名获取定义此类的二进制字节流，并将其转换为方法区中的运行时数据结构，在内存中生成一个代表该类的 <code>java.lang.Class</code> 对象。<li><strong>链接</strong>：包括验证、准备和解析三个步骤。验证确保被加载类的正确性；准备则为类变量分配内存并设置默认初始值；解析是将类、接口、字段和方法的符号引用转为直接引用的过程。<li><strong>初始化</strong>：执行类构造器 <code>&LTclinit>()</code> 方法的过程，对静态变量和静态代码块进行初始化。</ul><p>Java 类加载器使用双亲委派模型来搜索类或资源。<strong>当一个类加载器收到类加载请求时，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成</strong>，每一层的类加载器都是如此，因此所有的类加载请求最终都会传送到顶层的启动类加载器。<strong>只有当父类加载器无法加载该类时，子类加载器才会尝试自己加载</strong><p>Java 提供了三种内置的类加载器：<ul><li><strong>Bootstrap ClassLoader</strong>：这是最顶层的类加载器，由本地代码实现，通<strong>常用于加载核心 JDK 类库</strong>（如 <code>rt.jar</code>）。 无法直接访问,显示为null<li><strong>Extension ClassLoader</strong>：扩展类加载器，<strong>用来加载位于 <code>$JAVA_HOME/jre/lib/ext</code> 目录下的 JAR 包</strong>。 (目前使用PlatformClassLoader,加载 JDK 提供的平台模块中的类，例如 <code>java.sql</code>, <code>java.xml</code>, <code>javax.*</code> 等模块化的平台类。)<li><strong>Application ClassLoader</strong>：应用程序类加载器，<strong>负责加载用户类路径（ClassPath）上指定的类库</strong></ul><p>Java 提供了一些常用的方法来操作类加载器：<p><strong>(1) <code>loadClass(String name)</code></strong><p>加载指定名称的类或接口。如果已经加载过，则直接返回对应的 <code>Class</code> 对象；如果没有，则按照双亲委派机制尝试加载。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>try</span> {</span><br><span class=line>    Class&LT?> clazz = ClassLoader.getSystemClassLoader().loadClass(<span class=string>"com.example.MyClass"</span>);</span><br><span class=line>} <span class=keyword>catch</span> (ClassNotFoundException e) {</span><br><span class=line>    e.printStackTrace();</span><br><span class=line>}</span><br></pre></table></figure><p><strong>(2) <code>findClass(String name)</code></strong><p>查找指定名称的类。默认实现会抛出 <code>ClassNotFoundException</code> 异常，通常需要自定义类加载器覆盖此方法以提供具体的类查找逻辑。<p><strong>(3) <code>defineClass(byte[] b, int off, int len)</code></strong><p>将一个字节数组转换成一个类的 <code>Class</code> 对象。一般不直接调用，主要用于自定义类加载器。<p><strong>(4) <code>getResource(String name)</code> 和 <code>getResourceAsStream(String name)</code></strong><p>用于查找资源文件。前者返回资源的 URL，后者返回资源的输入流。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>URL resourceUrl = getClass().getClassLoader().getResource(<span class=string>"config.properties"</span>);</span><br><span class=line>InputStream inputStream = getClass().getClassLoader().getResourceAsStream(<span class=string>"config.properties"</span>);</span><br></pre></table></figure><p><strong>(5) <code>getParent()</code></strong><p>返回该类加载器的父类加载器。注意，Bootstrap ClassLoader 没有父类加载器，所以对于 Bootstrap ClassLoader 调用 <code>getParent()</code> 将返回 <code>null</code>。<p><strong>4. 自定义类加载器</strong><p>有时我们需要根据特定的需求来自定义类加载器。可以通过继承 <code>java.lang.ClassLoader</code> 并重写 <code>findClass</code> 方法来实现。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>MyClassLoader</span> <span class=keyword>extends</span> <span class=title>ClassLoader</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>protected</span> Class&LT?> findClass(String name) <span class=keyword>throws</span> ClassNotFoundException {</span><br><span class=line>        <span class=keyword>byte</span>[] classData = loadClassData(name); <span class=comment>// 实现类数据加载逻辑</span></span><br><span class=line>        <span class=keyword>return</span> defineClass(name, classData, <span class=number>0</span>, classData.length);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>byte</span>[] loadClassData(String className) {</span><br><span class=line>        <span class=comment>// 加载类数据的逻辑</span></span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class=keyword>byte</span>[<span class=number>0</span>];</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>以下是实现自定义类加载器的基本步骤：<ol><li><p>继承 <code>ClassLoader</code></p> <ul><li>创建一个类并继承 <code>ClassLoader</code>。</ul><li><p>重写 <code>findClass()</code> 方法(遵从双亲委派机制)</p> <ul><li>实现自定义的类加载逻辑。</ul><li><p>调用 <code>defineClass()</code> 方法</p> <ul><li>将字节码转换为 <code>Class</code> 对象。</ul> <p>class对象相同需要classloader相同,相同的classloader进行loadclass相同的类得到的class相同</p></ol><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.io.ByteArrayOutputStream;</span><br><span class=line><span class=keyword>import</span> java.io.FileInputStream;</span><br><span class=line><span class=keyword>import</span> java.io.IOException;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>CustomClassLoader</span> <span class=keyword>extends</span> <span class=title>ClassLoader</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=comment>// 加载类的根路径</span></span><br><span class=line>    <span class=keyword>private</span> String classPath;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>CustomClassLoader</span><span class=params>(String classPath)</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.classPath = classPath;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>protected</span> Class&LT?> findClass(String name) <span class=keyword>throws</span> ClassNotFoundException {</span><br><span class=line>        <span class=comment>// 读取类的字节码</span></span><br><span class=line>        <span class=keyword>byte</span>[] classData = loadClassData(name);</span><br><span class=line>        <span class=keyword>if</span> (classData == <span class=keyword>null</span>) {</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> ClassNotFoundException(<span class=string>"Class not found: "</span> + name);</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 解密字节码</span></span><br><span class=line>        <span class=keyword>byte</span>[] decryptedClassData = decrypt(classData);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 定义类</span></span><br><span class=line>        <span class=keyword>return</span> defineClass(name, decryptedClassData, <span class=number>0</span>, decryptedClassData.length);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 加载类的字节码</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>byte</span>[] loadClassData(String className) {</span><br><span class=line>        String path = classPath + className.replace(<span class=string>'.'</span>, <span class=string>'/'</span>) + <span class=string>".class"</span>;</span><br><span class=line>        <span class=keyword>try</span> (FileInputStream fis = <span class=keyword>new</span> FileInputStream(path);</span><br><span class=line>             ByteArrayOutputStream baos = <span class=keyword>new</span> ByteArrayOutputStream()) {</span><br><span class=line>            <span class=keyword>int</span> buffer;</span><br><span class=line>            <span class=keyword>while</span> ((buffer = fis.read()) != -<span class=number>1</span>) {</span><br><span class=line>                baos.write(buffer);</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>return</span> baos.toByteArray();</span><br><span class=line>        } <span class=keyword>catch</span> (IOException e) {</span><br><span class=line>            e.printStackTrace();</span><br><span class=line>            <span class=keyword>return</span> <span class=keyword>null</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 模拟解密过程</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>byte</span>[] decrypt(<span class=keyword>byte</span>[] data) {</span><br><span class=line>        <span class=comment>// 简单的异或解密</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < data.length; i++) {</span><br><span class=line>            data[i] = (<span class=keyword>byte</span>) (data[i] ^ <span class=number>0xFF</span>);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> data;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> Exception </span>{</span><br><span class=line>        <span class=comment>// 自定义类加载器</span></span><br><span class=line>        CustomClassLoader customClassLoader = <span class=keyword>new</span> CustomClassLoader(<span class=string>"path/to/classes/"</span>);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 使用自定义类加载器加载类</span></span><br><span class=line>        Class&LT?> clazz = customClassLoader.loadClass(<span class=string>"com.example.MyClass"</span>);</span><br><span class=line>        System.out.println(<span class=string>"Loaded class: "</span> + clazz.getName());</span><br><span class=line></span><br><span class=line>        <span class=comment>// 创建实例并调用方法</span></span><br><span class=line>        Object instance = clazz.getDeclaredConstructor().newInstance();</span><br><span class=line>        clazz.getMethod(<span class=string>"sayHello"</span>).invoke(instance);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h4 id=线程上下文加载器><a class=headerlink href=#线程上下文加载器 title=线程上下文加载器></a>线程上下文加载器</h4><p>线程上下文类加载器（Thread Context ClassLoader）是 Java 提供的一种机制，允许开发者在线程中设置和获取类加载器。这种机制主要用于解决某些特定场景下类加载的问题，尤其是在复杂的类层次结构或模块化系统中。<p><strong>线程上下文类加载器的作用</strong><ol><li><strong>解决类加载器隔离问题</strong>：<ul><li>在 Java 应用程序中，不同的类加载器可能会形成类加载器树，这导致了类加载器之间的隔离性。<li>例如，在 Web 容器或 OSGi 等环境中，不同应用或模块可能使用不同的类加载器来加载各自的类。在这种情况下，如果一个类需要加载另一个类加载器负责加载的类，则会遇到问题。<li>线程上下文类加载器提供了一种绕过双亲委派模型的方式，允许当前线程使用指定的类加载器来加载类。</ul><li><strong>支持框架和库的开发</strong>：<ul><li>许多框架和库（如 JNDI、JDBC 驱动等）依赖于线程上下文类加载器来加载必要的类。<li>这些框架通常不知道具体的类加载器，因此它们可以利用线程上下文类加载器来动态地加载所需的类。</ul></ol><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ThreadContextClassLoaderExample</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            <span class=comment>// 获取默认的上下文类加载器</span></span><br><span class=line>            ClassLoader defaultClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class=line>            System.out.println(<span class=string>"默认的上下文类加载器: "</span> + defaultClassLoader);</span><br><span class=line></span><br><span class=line>            <span class=comment>// 创建一个新的类加载器（例如自定义类加载器）</span></span><br><span class=line>            ClassLoader customClassLoader = <span class=keyword>new</span> CustomClassLoader();</span><br><span class=line></span><br><span class=line>            <span class=comment>// 设置新的上下文类加载器</span></span><br><span class=line>            Thread.currentThread().setContextClassLoader(customClassLoader);</span><br><span class=line>            System.out.println(<span class=string>"设置后的上下文类加载器: "</span> + Thread.currentThread().getContextClassLoader());</span><br><span class=line></span><br><span class=line>            <span class=comment>// 使用上下文类加载器加载类</span></span><br><span class=line>            Class&LT?> clazz = Thread.currentThread().getContextClassLoader().loadClass(<span class=string>"com.example.MyClass"</span>);</span><br><span class=line>            System.out.println(<span class=string>"加载的类: "</span> + clazz.getName());</span><br><span class=line>        } <span class=keyword>catch</span> (ClassNotFoundException e) {</span><br><span class=line>            e.printStackTrace();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>CustomClassLoader</span> <span class=keyword>extends</span> <span class=title>ClassLoader</span> </span>{</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>protected</span> Class&LT?> findClass(String name) <span class=keyword>throws</span> ClassNotFoundException {</span><br><span class=line>        <span class=comment>// 实现类的查找逻辑</span></span><br><span class=line>        <span class=keyword>byte</span>[] classData = loadClassData(name);</span><br><span class=line>        <span class=keyword>if</span> (classData == <span class=keyword>null</span>) {</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> ClassNotFoundException();</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=keyword>return</span> defineClass(name, classData, <span class=number>0</span>, classData.length);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>byte</span>[] loadClassData(String className) {</span><br><span class=line>        <span class=comment>// 模拟从文件或其他来源读取类数据的逻辑</span></span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>null</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=JVM><a class=headerlink href=#JVM title=JVM></a>JVM</h2><p><img alt=image-20250320221417773 data-src=https://s2.loli.net/2025/03/20/iZdH8kUa9LYAFQW.png><p>程序计数器: 线程私有<h3 id=垃圾回收><a class=headerlink href=#垃圾回收 title=垃圾回收></a>垃圾回收</h3><p>判断对象可以回收<h4 id=引用计数法><a class=headerlink href=#引用计数法 title=引用计数法></a>引用计数法</h4><p>工作原理<ol><li><strong>初始化</strong>：每当创建一个新的对象时，该对象的引用计数器被初始化为1。<li><strong>增加引用</strong>：每当有新的引用指向这个对象时（例如，将对象赋值给另一个变量），该对象的引用计数加1。<li><strong>减少引用</strong>：每当某个引用不再指向该对象时（例如，变量超出作用域或重新赋值），该对象的引用计数减1。<li><strong>回收内存</strong>：当一个对象的引用计数降为0时，表示没有其他引用指向该对象，这时就可以立即回收该对象所占用的内存。</ol><p>缺点:<p><strong>无法处理循环引用</strong>：如果两个或多个对象相互引用形成环状结构，则即使这些对象实际上已经不可达，它们的引用计数也不会变为0，导致内存泄漏。为了克服这个问题，一些语言引入了弱引用（weak references）或专门的循环检测机制。<p><strong>多线程环境下的复杂性</strong>：在多线程环境下，对引用计数的修改需要同步操作，以防止竞态条件（race condition），这也增加了实现的复杂性和运行时的开销<h4 id=可达性分析算法><a class=headerlink href=#可达性分析算法 title=可达性分析算法></a>可达性分析算法</h4><p>可达性分析的基本思想是从一组被称为“根节点”（root set）的对象开始，遍历所有可以通过这些根节点直接或间接引用到的对象，并将它们标记为存活。未被标记的对象则被认为是不可达的，可以被安全地回收。<blockquote><p>在命令行中输入 <code>jps</code> 可以列出所有由当前用户启动的 Java 进程的基本信息<p><code>-q</code>：仅输出 JVM 的进程 ID，不输出类名、jar 名等信息<p><code>-l</code>：输出主类的完整包名；如果进程执行的是 jar 文件，则输出 jar 文件的完整路径</blockquote><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>jmap -dump:[live,]format=b,file=&LTfilename>.hprof &LTpid></span><br></pre></table></figure><ul><li><code>live</code>：如果指定了这个选项，则只转储存活的对象；如果不指定，则转储所有对象。<li><code>format=b</code>：表示输出格式为二进制，默认就是二进制格式，所以通常省略不写。<li><code>&LTfilename>.hprof</code>：指定生成的堆转储文件的名字。<li><code>&LTpid></code>：目标Java进程的进程ID。</ul><p>引用<p><img alt=image-20250320220503285 data-src=https://s2.loli.net/2025/03/20/BMyrksQT5S6xlqf.png><p>强引用 软引用 弱引用<p>软引用:垃圾回收时且内存不足时会被回收掉<p>虚引用 引用队列<p>终结器引用<ul><li><strong>强引用</strong>：日常编程中最常用的引用类型，几乎所有对象都是通过强引用创建的。<li><strong>软引用</strong>：适用于缓存场景，当内存不足时，允许GC回收缓存数据。<li><strong>弱引用</strong>：适合于需要自动清理的资源管理场景，例如监听器或回调函数列表中的对象。<li><strong>虚引用</strong>：主要用于了解对象何时被垃圾回收，常用于做一些清理工作，比如清除本地内存、关闭文件等</ul><h4 id=回收算法><a class=headerlink href=#回收算法 title=回收算法></a>回收算法</h4><p>标记-清除<h2 id=JUC><a class=headerlink href=#JUC title=JUC></a>JUC</h2><h1 id=项目管理><a class=headerlink href=#项目管理 title=项目管理></a>项目管理</h1><h2 id=Maven✨><a class=headerlink href=#Maven✨ title=Maven✨></a>Maven✨</h2><p><a href=https://maven.apache.org/guides/getting-started/index.html rel=noopener target=_blank>Maven Getting Started Guide – Maven</a><p><a href=https://www.runoob.com/maven/maven-tutorial.html rel=noopener target=_blank>Maven 教程 | 菜鸟教程</a><p><a href=https://www.bilibili.com/video/BV1Ah411S7ZE/?spm_id_from=333.337.search-card.all.click&vd_source=177ef88aa6608bc3652c72d71b0aa098 rel=noopener target=_blank>黑马程序员Maven全套教程，maven项目管理从基础到高级，Java项目开发必会管理工具maven_哔哩哔哩_bilibili</a><blockquote><p>项目中源码目录,资源文件夹目录等都是maven设置的</blockquote><p>Maven 提倡使用一个共同的标准目录结构，Maven 使用约定优于配置的原则，大家尽可能的遵守这样的目录结构。如下所示：<div class=table-container><table><thead><tr><th style=text-align:left>目录<th style=text-align:left>目的<tbody><tr><td style=text-align:left>${basedir}<td style=text-align:left>存放pom.xml和所有的子目录<tr><td style=text-align:left>${basedir}/src/main/java<td style=text-align:left>项目的java源代码<tr><td style=text-align:left>${basedir}/src/main/resources<td style=text-align:left>项目的资源，比如说property文件，springmvc.xml<tr><td style=text-align:left>${basedir}/src/test/java<td style=text-align:left>项目的测试类，比如说Junit代码<tr><td style=text-align:left>${basedir}/src/test/resources<td style=text-align:left>测试用的资源<tr><td style=text-align:left>${basedir}/src/main/webapp/WEB-INF<td style=text-align:left>web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面<tr><td style=text-align:left>${basedir}/target<td style=text-align:left>打包输出目录<tr><td style=text-align:left>${basedir}/target/classes<td style=text-align:left>编译输出目录<tr><td style=text-align:left>${basedir}/target/test-classes<td style=text-align:left>测试编译输出目录<tr><td style=text-align:left>Test.java<td style=text-align:left>Maven只会自动运行符合该命名规则的测试类<tr><td style=text-align:left>~/.m2/repository<td style=text-align:left>Maven默认的本地仓库目录位置</table></div><p>POM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。<p>执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。<p>POM 中可以指定以下配置：<ul><li>项目依赖<li>插件<li>执行目标<li>项目构建 profile<li>项目版本<li>项目开发者列表<li>相关邮件列表信息</ul><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>project</span> <span class=attr>xmlns</span> = <span class=string>"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span> = <span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span> = <span class=string>"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class=line><span class=string><span class=tag>    http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>></span></span><br><span class=line> </span><br><span class=line>    <span class=comment>&LT!-- 模型版本 --></span></span><br><span class=line>    <span class=tag><<span class=name>modelVersion</span>></span>4.0.0<span class=tag>&LT/<span class=name>modelVersion</span>></span></span><br><span class=line>    <span class=comment>&LT!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>com.companyname.project-group<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line> </span><br><span class=line>    <span class=comment>&LT!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>project<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line> </span><br><span class=line>    <span class=comment>&LT!-- 版本号 --></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>1.0<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>project</span>></span></span><br></pre></table></figure><p>所有 POM 文件都需要 project 元素和三个必需字段：groupId，artifactId，version。<div class=table-container><table><thead><tr><th style=text-align:left>节点<th style=text-align:left>描述<tbody><tr><td style=text-align:left>project<td style=text-align:left>工程的根标签。<tr><td style=text-align:left>modelVersion<td style=text-align:left>模型版本需要设置为 4.0。<tr><td style=text-align:left>groupId<td style=text-align:left>这是工程组的标识。它在一个组织或者项目中通常是唯一的。例如，一个银行组织 com.companyname.project-group 拥有所有的和银行相关的项目。<tr><td style=text-align:left>artifactId<td style=text-align:left>这是工程的标识。它通常是工程的名称。例如，消费者银行。groupId 和 artifactId 一起定义了 artifact 在仓库中的位置。<tr><td style=text-align:left>version<td style=text-align:left>这是工程的版本号。在 artifact 的仓库中，它用来区分不同的版本。例如：<code>com.company.bank:consumer-banking:1.0 com.company.bank:consumer-banking:1.1</code></table></div><h3 id=依赖管理><a class=headerlink href=#依赖管理 title=依赖管理></a>依赖管理</h3><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>    <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>        <span class=tag><<span class=name>groupId</span>></span>org.springframework<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>artifactId</span>></span>spring-core<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>version</span>></span>5.3.9<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencies</span>></span></span><br></pre></table></figure><h3 id=插件管理><a class=headerlink href=#插件管理 title=插件管理></a>插件管理</h3><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>build</span>></span></span><br><span class=line>    <span class=tag><<span class=name>plugins</span>></span></span><br><span class=line>        <span class=tag><<span class=name>plugin</span>></span></span><br><span class=line>            <span class=tag><<span class=name>groupId</span>></span>org.apache.maven.plugins<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>            <span class=tag><<span class=name>artifactId</span>></span>maven-compiler-plugin<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>            <span class=tag><<span class=name>version</span>></span>3.8.1<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>            <span class=tag><<span class=name>configuration</span>></span></span><br><span class=line>                <span class=tag><<span class=name>source</span>></span>1.8<span class=tag>&LT/<span class=name>source</span>></span></span><br><span class=line>                <span class=tag><<span class=name>target</span>></span>1.8<span class=tag>&LT/<span class=name>target</span>></span></span><br><span class=line>            <span class=tag>&LT/<span class=name>configuration</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>plugin</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>plugins</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>build</span>></span></span><br></pre></table></figure><h3 id=其他常用元素><a class=headerlink href=#其他常用元素 title=其他常用元素></a>其他常用元素</h3><p><strong>properties</strong>: 定义项目中的一些属性变量:<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>properties</span>></span></span><br><span class=line>    <span class=tag><<span class=name>maven.compiler.source</span>></span>1.8<span class=tag>&LT/<span class=name>maven.compiler.source</span>></span></span><br><span class=line>    <span class=tag><<span class=name>maven.compiler.target</span>></span>1.8<span class=tag>&LT/<span class=name>maven.compiler.target</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>properties</span>></span></span><br></pre></table></figure><p>repositories: 定义项目的依赖库:<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>repositories</span>></span></span><br><span class=line>    <span class=tag><<span class=name>repository</span>></span></span><br><span class=line>        <span class=tag><<span class=name>id</span>></span>central<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>        <span class=tag><<span class=name>url</span>></span>https://repo.maven.apache.org/maven2<span class=tag>&LT/<span class=name>url</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>repository</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>repositories</span>></span></span><br></pre></table></figure><p><strong>dependencyManagement</strong>: 用于管理依赖的版本，特别是在多模块项目中：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependencyManagement</span>></span></span><br><span class=line>    <span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>        <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>            <span class=tag><<span class=name>groupId</span>></span>org.springframework<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>            <span class=tag><<span class=name>artifactId</span>></span>spring-core<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>            <span class=tag><<span class=name>version</span>></span>5.3.9<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>dependencies</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencyManagement</span>></span></span><br></pre></table></figure><p>profiles: 用于定义不同的构建配置，可以根据不同的环境进行构建：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>profiles</span>></span></span><br><span class=line>    <span class=tag><<span class=name>profile</span>></span></span><br><span class=line>        <span class=tag><<span class=name>id</span>></span>development<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>        <span class=tag><<span class=name>properties</span>></span></span><br><span class=line>            <span class=tag><<span class=name>environment</span>></span>dev<span class=tag>&LT/<span class=name>environment</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>properties</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>profile</span>></span></span><br><span class=line>    <span class=tag><<span class=name>profile</span>></span></span><br><span class=line>        <span class=tag><<span class=name>id</span>></span>production<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>        <span class=tag><<span class=name>properties</span>></span></span><br><span class=line>            <span class=tag><<span class=name>environment</span>></span>prod<span class=tag>&LT/<span class=name>environment</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>properties</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>profile</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>profiles</span>></span></span><br></pre></table></figure><p>继承: 通过parent元素，一个POM文件可以继承另一个POM文件的配置：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>parent</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>com.example<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>parent-project<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>1.0-SNAPSHOT<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>parent</span>></span></span><br></pre></table></figure><p>聚合: 通过modules元素，一个POM文件可以管理多个子模块：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>modules</span>></span></span><br><span class=line>    <span class=tag><<span class=name>module</span>></span>module1<span class=tag>&LT/<span class=name>module</span>></span></span><br><span class=line>    <span class=tag><<span class=name>module</span>></span>module2<span class=tag>&LT/<span class=name>module</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>modules</span>></span></span><br></pre></table></figure><h3 id=生命周期><a class=headerlink href=#生命周期 title=生命周期></a>生命周期</h3><p>个典型的 Maven 构建（build）生命周期是由以下几个阶段的序列组成的：<p><img alt=img data-src=https://www.runoob.com/wp-content/uploads/2018/09/maven-package-build-phase.png><div class=table-container><table><thead><tr><th style=text-align:left>阶段<th style=text-align:left>处理<th style=text-align:left>描述<tbody><tr><td style=text-align:left>验证 validate<td style=text-align:left>验证项目<td style=text-align:left>验证项目是否正确且所有必须信息是可用的<tr><td style=text-align:left>编译 compile<td style=text-align:left>执行编译<td style=text-align:left>源代码编译在此阶段完成<tr><td style=text-align:left>测试 Test<td style=text-align:left>测试<td style=text-align:left>使用适当的单元测试框架（例如JUnit）运行测试。<tr><td style=text-align:left>包装 package<td style=text-align:left>打包<td style=text-align:left>将编译后的代码打包成可分发的格式，例如 JAR 或 WAR<tr><td style=text-align:left>检查 verify<td style=text-align:left>检查<td style=text-align:left>对集成测试的结果进行检查，以保证质量达标<tr><td style=text-align:left>安装 install<td style=text-align:left>安装<td style=text-align:left>安装打包的项目到本地仓库，以供其他项目使用<tr><td style=text-align:left>部署 deploy<td style=text-align:left>部署<td style=text-align:left>拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程</table></div><p>为了完成 default 生命周期，这些阶段（包括其他未在上面罗列的生命周期阶段）将被按顺序地执行。<p>Maven 有以下三个标准的生命周期：<p><strong>1、Clean 生命周期：</strong><ul><li><strong>clean</strong>：删除目标目录中的编译输出文件。这通常是在构建之前执行的，以确保项目从一个干净的状态开始。</ul><p><strong>2、Default 生命周期（也称为 Build 生命周期）：</strong><ul><li><strong>validate</strong>：验证项目的正确性，例如检查项目的版本是否正确。<li><strong>compile</strong>：编译项目的源代码。<li><strong>test</strong>：运行项目的单元测试。<li><strong>package</strong>：将编译后的代码打包成可分发的格式，例如 JAR 或 WAR。<li><strong>verify</strong>：对项目进行额外的检查以确保质量。<li><strong>install</strong>：将项目的构建结果安装到本地 Maven 仓库中，以供其他项目使用。<li><strong>deploy</strong>：将项目的构建结果复制到远程仓库，以供其他开发人员或团队使用。</ul><p><strong>3、Site 生命周期：</strong><ul><li><strong>site</strong>：生成项目文档和站点信息。<li><strong>deploy-site</strong>：将生成的站点信息发布到远程服务器，以便共享项目文档。</ul><h3 id=仓库><a class=headerlink href=#仓库 title=仓库></a>仓库</h3><p>在 Maven 的术语中，仓库是一个位置（place）。<p>Maven 仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。<p>在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称之为构件。<p>Maven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。<p>Maven 仓库有三种类型：<ul><li>本地（local）<li>中央（central）<li>远程（remote）</ul><p>Maven 的本地仓库，<strong>在安装 Maven 后并不会创建，它是在第一次执行 maven 命令的时候才被创建</strong>。<p>运行 Maven 的时候，Maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。<blockquote><p>默认情况下，不管Linux还是 Windows，每个用户在自己的用户目录下都有一个路径名为 .m2/repository/ 的仓库目录。</blockquote><p>Maven 本地仓库默认被创建在 %USER_HOME% 目录下。要修改默认位置，在 %M2_HOME%\conf 目录中的 Maven 的 settings.xml 文件中定义另一个路径。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>settings</span> <span class=attr>xmlns</span>=<span class=string>"http://maven.apache.org/SETTINGS/1.0.0"</span>   <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span>   <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://maven.apache.org/SETTINGS/1.0.0    http://maven.apache.org/xsd/settings-1.0.0.xsd"</span>></span>      <span class=tag><<span class=name>localRepository</span>></span>C:/MyLocalRepository<span class=tag>&LT/<span class=name>localRepository</span>></span> <span class=tag>&LT/<span class=name>settings</span>></span></span><br></pre></table></figure><p>当运行 Maven 命令，Maven 将下载依赖的文件到你指定的路径中。<p>Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。<p>中央仓库包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。<p>中央仓库的关键概念：<ul><li>这个仓库由 Maven 社区管理。<li>不需要配置。<li>需要通过网络才能访问。</ul><p>如果 Maven 在中央仓库中也找不到依赖的文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。<p>举例说明，使用下面的 pom.xml，<strong>Maven 将从远程仓库中下载该 pom.xml 中声明的所依赖的（在中央仓库中获取不到的）文件</strong>。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>project</span> <span class=attr>xmlns</span>=<span class=string>"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class=line><span class=tag>   <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>   <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class=line><span class=string><span class=tag>   http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>></span></span><br><span class=line>   <span class=tag><<span class=name>modelVersion</span>></span>4.0.0<span class=tag>&LT/<span class=name>modelVersion</span>></span></span><br><span class=line>   <span class=tag><<span class=name>groupId</span>></span>com.companyname.projectgroup<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>   <span class=tag><<span class=name>artifactId</span>></span>project<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>   <span class=tag><<span class=name>version</span>></span>1.0<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>   <span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>      <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>         <span class=tag><<span class=name>groupId</span>></span>com.companyname.common-lib<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>         <span class=tag><<span class=name>artifactId</span>></span>common-lib<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>         <span class=tag><<span class=name>version</span>></span>1.0.0<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>      <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>   <span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>   <span class=tag><<span class=name>repositories</span>></span></span><br><span class=line>      <span class=tag><<span class=name>repository</span>></span></span><br><span class=line>          <span class=comment>&LT!--自定义远程仓库--></span></span><br><span class=line>         <span class=tag><<span class=name>id</span>></span>companyname.lib1<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>      <span class=tag><<span class=name>url</span>></span>http://download.companyname.org/maven2/lib1<span class=tag>&LT/<span class=name>url</span>></span></span><br><span class=line>      <span class=tag>&LT/<span class=name>repository</span>></span></span><br><span class=line>      <span class=tag><<span class=name>repository</span>></span></span><br><span class=line>         <span class=tag><<span class=name>id</span>></span>companyname.lib2<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>         <span class=tag><<span class=name>url</span>></span>http://download.companyname.org/maven2/lib2<span class=tag>&LT/<span class=name>url</span>></span></span><br><span class=line>      <span class=tag>&LT/<span class=name>repository</span>></span></span><br><span class=line>   <span class=tag>&LT/<span class=name>repositories</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>project</span>></span></span><br></pre></table></figure><p>当执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库：<ul><li><strong>步骤 1</strong> － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。<li><strong>步骤 2</strong> － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。<li><strong>步骤 3</strong> － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。<li><strong>步骤 4</strong> － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</ul><p>Maven 仓库默认在国外， 国内使用难免很慢，我们可以更换为阿里云的仓库。<p><strong>修改 maven 根目录下的 conf 文件夹中的 settings.xml 文件</strong>，在 mirrors 节点上，添加内容如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>mirror</span>></span></span><br><span class=line>  <span class=tag><<span class=name>id</span>></span>aliyunmaven<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>  <span class=tag><<span class=name>mirrorOf</span>></span>*<span class=tag>&LT/<span class=name>mirrorOf</span>></span></span><br><span class=line>  <span class=tag><<span class=name>name</span>></span>阿里云公共仓库<span class=tag>&LT/<span class=name>name</span>></span></span><br><span class=line>  <span class=tag><<span class=name>url</span>></span>https://maven.aliyun.com/repository/public<span class=tag>&LT/<span class=name>url</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>mirror</span>></span></span><br></pre></table></figure><p>如果想使用其它代理仓库，可在 <strong><repositories></repositories></strong> 节点中加入对应的仓库使用地址。以使用 spring 代理仓为例：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>repository</span>></span></span><br><span class=line>  <span class=tag><<span class=name>id</span>></span>spring<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>  <span class=tag><<span class=name>url</span>></span>https://maven.aliyun.com/repository/spring<span class=tag>&LT/<span class=name>url</span>></span></span><br><span class=line>  <span class=tag><<span class=name>releases</span>></span></span><br><span class=line>    <span class=tag><<span class=name>enabled</span>></span>true<span class=tag>&LT/<span class=name>enabled</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>releases</span>></span></span><br><span class=line>  <span class=tag><<span class=name>snapshots</span>></span></span><br><span class=line>    <span class=tag><<span class=name>enabled</span>></span>true<span class=tag>&LT/<span class=name>enabled</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>snapshots</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>repository</span>></span></span><br></pre></table></figure><p>在你的 pom.xml 文件 <strong><denpendencies></denpendencies></strong> 节点中加入你要引用的文件信息：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>  <span class=tag><<span class=name>groupId</span>></span>[GROUP_ID]<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>  <span class=tag><<span class=name>artifactId</span>></span>[ARTIFACT_ID]<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>  <span class=tag><<span class=name>version</span>></span>[VERSION]<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><h3 id=常用命令><a class=headerlink href=#常用命令 title=常用命令></a>常用命令</h3><ol><li><strong><code>mvn clean</code></strong><ul><li>清理项目，删除 <code>target</code> 目录（该目录包含了编译和打包过程中生成的所有文件）。</ul><li><strong><code>mvn compile</code></strong><ul><li>编译项目的源代码。默认情况下，会查找 <code>src/main/java</code> 目录下的所有 <code>.java</code> 文件，并将编译后的 <code>.class</code> 文件输出到 <code>target/classes</code> 目录中。</ul><li><strong><code>mvn test</code></strong><ul><li>使用合适的单元测试框架（如 JUnit 或 TestNG）运行项目的测试代码。默认情况下，测试代码位于 <code>src/test/java</code> 目录下。</ul><li><strong><code>mvn package</code></strong><ul><li>将编译好的字节码打包成可分发的格式，例如 JAR 或 WAR 文件。这个命令首先执行 <code>compile</code> 和 <code>test</code>，然后将项目打包并存放在 <code>target</code> 目录中。</ul><li><strong><code>mvn install</code></strong><ul><li>安装打包好的构件到本地仓库（通常是用户主目录下的 <code>.m2/repository</code>），以便它可以被其他项目作为依赖使用。此命令还会执行 <code>package</code> 的所有步骤。</ul><li><strong><code>mvn deploy</code></strong><ul><li>在集成或发布阶段使用，用于将最终包复制到远程仓库，使得其他开发者或项目可以共享这个构件。</ul><li><strong><code>mvn site</code></strong><ul><li>生成关于项目的站点文档，包括测试覆盖率报告、依赖列表等信息。</ul><li><strong><code>mvn clean install</code></strong><ul><li>组合命令，先清理项目 (<code>clean</code>) 然后安装 (<code>install</code>) 到本地仓库。这是非常常见的组合，用于确保在干净环境下重新构建整个项目。</ul><li><strong><code>mvn dependency:tree</code></strong><ul><li>显示项目依赖树，有助于分析依赖冲突或了解项目依赖关系。</ul><li><strong><code>mvn archetype:generate</code></strong><ul><li>生成一个新的 Maven 项目结构，通过交互式的方式选择项目模板</ul></ol><h1 id=数据库><a class=headerlink href=#数据库 title=数据库></a>数据库</h1><h2 id=MySQL✨><a class=headerlink href=#MySQL✨ title=MySQL✨></a>MySQL✨</h2><h4 id=事务><a class=headerlink href=#事务 title=事务></a>事务</h4><p>一组操作的集合,不可分割的一个工作单位. 事务会把所有操作作为一个整体向系统提交或撤销操作,即这些操作要么同时成功,要么同时失败.<p>事务四大特性<ul><li><strong>原子性（Atomicity）</strong>：事务中的所有操作要么全部完成，要么全部不执行。<li><strong>一致性（Consistency）</strong>：事务应该将数据库从一种一致状态转换为另一种一致状态。<li><strong>隔离性（Isolation）</strong>：并发事务之间相互隔离，不会互相干扰。<li><strong>持久性（Durability）</strong>：一旦事务提交，所做的更改将是永久性的，即使系统发生故障也不会丢失。</ul><h5 id=事务并发问题><a class=headerlink href=#事务并发问题 title=事务并发问题></a>事务并发问题</h5><p>多个事务并发进行的问题<h6 id=脏读><a class=headerlink href=#脏读 title=脏读></a>脏读</h6><p>一个事务读到另外一个事务还没有提交的数据<h6 id=不可重复读><a class=headerlink href=#不可重复读 title=不可重复读></a>不可重复读</h6><p>一个事务先后读取同一条记录,但两次读取的数据不同,称之为不可重复读<h6 id=幻读><a class=headerlink href=#幻读 title=幻读></a>幻读</h6><p>一个事务按照条件查询数据时,没有对应的数据行,但是在插入数据时,又发现这行数据已经存在<h5 id=事务隔离级别><a class=headerlink href=#事务隔离级别 title=事务隔离级别></a>事务隔离级别</h5><p>MySQL 支持四种标准的事务隔离级别：<ol><li><strong>读未提交（Read Uncommitted）</strong>:最低级别的隔离，允许脏读、不可重复读和幻读。<li><strong>读已提交（Read Committed）</strong>:防止脏读，但允许不可重复读和幻读。<li><strong>可重复读（Repeatable Read）</strong>:默认级别，防止脏读和不可重复读，但允许幻读。<li><strong>串行化（Serializable）</strong>:最高级别的隔离，完全防止脏读、不可重复读和幻读，但会降低并发性能。</ol><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class=line>-- 或者</span><br><span class=line>SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br></pre></table></figure><p><strong>1. 默认情况下：事务需要显式提交</strong><ul><li>在 <code>START TRANSACTION</code> 开始一个事务后，所有对数据库的修改操作（如 <code>UPDATE</code>、<code>INSERT</code> 等）都只会暂时存在于事务的上下文中，而不会直接写入数据库。<li>这些更改对其他事务是不可见的（根据隔离级别），直到你显式调用 <code>COMMIT</code> 提交事务。<li>如果你调用 <code>ROLLBACK</code>，则所有的更改会被撤销，数据库恢复到事务开始前的状态。</ul><p><strong>2. 如果未提交且会话结束</strong><ul><li><p>如果你在事务中执行了更新语句，但没有显式调用COMMITROLLBACK</p> <p>，然后会话意外终止（例如客户端断开连接），MySQL 的行为如下：</p> <ul><li><strong>InnoDB 存储引擎</strong>（支持事务）：事务会被自动回滚，所有未提交的更改都会被撤销。<li><strong>MyISAM 存储引擎</strong>（不支持事务）：由于 MyISAM 不支持事务，所有操作会立即生效，无法回滚。</ul></ul><p><strong>3. autocommit 模式的影响</strong><ul><li>MySQL 默认开启了 <strong>autocommit 模式</strong>（<code>autocommit=1</code>）。在这种模式下，每条单独的 SQL 语句都会被视为一个独立的事务，并在执行后自动提交。<li>当你使用 <code>START TRANSACTION</code> 或 <code>BEGIN</code> 时，会临时禁用 autocommit 模式，直到事务结束（通过 <code>COMMIT</code> 或 <code>ROLLBACK</code>）。<li>如果你没有显式提交事务，而会话结束时 autocommit 模式重新启用，InnoDB 会自动回滚未提交的事务。</ul><p><img alt=image-20250326191732721 data-src=https://s2.loli.net/2025/03/26/F7Ebo35RH6XIQft.png><p><img alt=image-20250326192221989 data-src=https://s2.loli.net/2025/03/26/LjCFSxblAyBGEhd.png><h4 id=存储引擎><a class=headerlink href=#存储引擎 title=存储引擎></a>存储引擎</h4><p>join连接两个表<ul><li><strong>INNER JOIN</strong>：仅返回两个表中满足连接条件的记录。<li><strong>LEFT JOIN</strong>（或LEFT OUTER JOIN）：返回左表中的所有记录，以及右表中满足连接条件的记录。若右表无匹配记录则填充NULL。<li><strong>RIGHT JOIN</strong>（或RIGHT OUTER JOIN）：返回右表中的所有记录，以及左表中满足连接条件的记录。若左表无匹配记录则填充NULL。<li><strong>FULL JOIN</strong>（或FULL OUTER JOIN）：返回两个表中的所有记录，任何表中无匹配记录的部分用NULL填充。（注意：MySQL不直接支持此语法）<li><strong>CROSS JOIN</strong>：产生两个表的笛卡尔积。<li><strong>SELF JOIN</strong>：一个表与自身的连接，适用于查询具有层次结构的数据。</ul><p><code>%</code> 可以匹配任意长度的字符串（包括空字符串），而 <code>_</code> 总是代表一个单一字符.在SQL中，默认情况下并没有一个预设的转义字符用于 <code>LIKE</code> 查询中的通配符（如 <code>%</code> 和 <code>_</code>）转义。这意味着，如果你需要转义这些特殊字符，你必须明确指定一个转义字符，并通过 <code>ESCAPE</code> 关键字来定义它。<p>尽管没有默认的转义字符，但你可以选择一个不会出现在目标字符串中的字符作为转义字符。常用的转义字符包括反斜杠 <code>\</code> 或者感叹号 <code>!</code> 等。下面是如何使用 <code>ESCAPE</code> 来定义转义字符的例子：<p>如果想查找包含实际百分比符号 <code>%</code> 的记录，可以这样做：<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>SELECT</span> column_name </span><br><span class=line><span class=keyword>FROM</span> table_name </span><br><span class=line><span class=keyword>WHERE</span> column_name <span class=keyword>LIKE</span> <span class=string>'%\%%'</span> <span class=keyword>ESCAPE</span> <span class=string>'\'</span>;</span><br></pre></table></figure><p>在这个例子中：<ul><li><code>\%</code> 表示实际的百分号字符 <code>%</code> 而不是通配符。<li><code>ESCAPE '\'</code> 告诉数据库 <code>\</code> 是转义字符。</ul><h2 id=PostgresSQL><a class=headerlink href=#PostgresSQL title=PostgresSQL></a>PostgresSQL</h2><p><a href=https://www.postgresql.org/ rel=noopener target=_blank>PostgreSQL: The world’s most advanced open source database</a><h2 id=MongoDB><a class=headerlink href=#MongoDB title=MongoDB></a>MongoDB</h2><p><a href=https://www.mongodb.com/docs/guides/ rel=noopener target=_blank>Start with Guides - Start with Guides</a><h1 id=持久层框架><a class=headerlink href=#持久层框架 title=持久层框架></a>持久层框架</h1><h2 id=Mybatis✨><a class=headerlink href=#Mybatis✨ title=Mybatis✨></a>Mybatis✨</h2><p><a href=https://mybatis.org/mybatis-3/zh_CN/index.html rel=noopener target=_blank>MyBatis 3 | 简介 – mybatis</a><p><a href=https://www.bilibili.com/video/BV1VP4y1c7j7/ rel=noopener target=_blank>【尚硅谷】MyBatis零基础入门教程（细致全面，快速上手mybatis）_哔哩哔哩_bilibili</a><p><a href=https://www.bilibili.com/video/BV1JP4y1Z73S/ rel=noopener target=_blank>MyBatis视频零基础入门到进阶，MyBatis全套视频教程源码级深入详解_哔哩哔哩_bilibili</a><p>持久层框架,简化JDBC开发,负责数据库的读写.<p>JDBC问题:硬编码 操作繁琐<h3 id=查询单表数据整体流程><a class=headerlink href=#查询单表数据整体流程 title=查询单表数据整体流程></a>查询单表数据整体流程</h3><ol><li>创建表,插入数据<li>创建模块,导入maven<li>编写mybatis核心配置文件(替换连接信息,解决硬编码)<li>编写sql映射文件(统一管理sql语句)<li>编码: 定义POJO类 加载核心配置文件,获取sqlsessionfactory对象,执行sql语句</ol><h3 id=使用Mapper代理开发><a class=headerlink href=#使用Mapper代理开发 title=使用Mapper代理开发></a>使用Mapper代理开发</h3><blockquote><p>创建mapper类,该类名称与命名空间相同,方法申明与mapper映射xml文件相同</blockquote><p>既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>try</span> (SqlSession session = sqlSessionFactory.openSession()) {</span><br><span class=line>  Blog blog = (Blog) session.selectOne(<span class=string>"org.mybatis.example.BlogMapper.selectBlog"</span>, <span class=number>101</span>);</span><br><span class=line>}</span><br></pre></table></figure><p>诚然，这种方式能够正常工作，对使用旧版本 MyBatis 的用户来说也比较熟悉。但现在有了一种更简洁的方式——<strong>使用和指定语句的参数和返回值相匹配的接口（比如 BlogMapper.class），现在你的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换。</strong><p>例如：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>try</span> (SqlSession session = sqlSessionFactory.openSession()) {</span><br><span class=line>  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class=line>  Blog blog = mapper.selectBlog(<span class=number>101</span>);</span><br><span class=line>}</span><br></pre></table></figure><p><img alt=image-20250309134454871 data-src=https://s2.loli.net/2025/03/09/S12tudvJjEeoXTp.png><h3 id=properties><a class=headerlink href=#properties title=properties></a>properties</h3><p>这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。例如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>properties</span> <span class=attr>resource</span>=<span class=string>"org/mybatis/example/config.properties"</span>></span></span><br><span class=line>  <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"username"</span> <span class=attr>value</span>=<span class=string>"dev_user"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"password"</span> <span class=attr>value</span>=<span class=string>"F2Fa3!33TYyg"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>properties</span>></span></span><br></pre></table></figure><h3 id=settings><a class=headerlink href=#settings title=settings></a>settings</h3><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>settings</span>></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"cacheEnabled"</span> <span class=attr>value</span>=<span class=string>"true"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"lazyLoadingEnabled"</span> <span class=attr>value</span>=<span class=string>"true"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"multipleResultSetsEnabled"</span> <span class=attr>value</span>=<span class=string>"true"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"useColumnLabel"</span> <span class=attr>value</span>=<span class=string>"true"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"useGeneratedKeys"</span> <span class=attr>value</span>=<span class=string>"false"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"autoMappingBehavior"</span> <span class=attr>value</span>=<span class=string>"PARTIAL"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"autoMappingUnknownColumnBehavior"</span> <span class=attr>value</span>=<span class=string>"WARNING"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"defaultExecutorType"</span> <span class=attr>value</span>=<span class=string>"SIMPLE"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"defaultStatementTimeout"</span> <span class=attr>value</span>=<span class=string>"25"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"defaultFetchSize"</span> <span class=attr>value</span>=<span class=string>"100"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"safeRowBoundsEnabled"</span> <span class=attr>value</span>=<span class=string>"false"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"mapUnderscoreToCamelCase"</span> <span class=attr>value</span>=<span class=string>"false"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"localCacheScope"</span> <span class=attr>value</span>=<span class=string>"SESSION"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"jdbcTypeForNull"</span> <span class=attr>value</span>=<span class=string>"OTHER"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"lazyLoadTriggerMethods"</span> <span class=attr>value</span>=<span class=string>"equals,clone,hashCode,toString"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>settings</span>></span></span><br></pre></table></figure><h3 id=TypeAliases><a class=headerlink href=#TypeAliases title=TypeAliases></a>TypeAliases</h3><p>类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>&LTtypeAliases></span><br><span class=line>  &LTtypeAlias <span class=built_in>alias</span>=<span class=string>"Author"</span> <span class=built_in>type</span>=<span class=string>"domain.blog.Author"</span>/></span><br><span class=line>  &LTtypeAlias <span class=built_in>alias</span>=<span class=string>"Blog"</span> <span class=built_in>type</span>=<span class=string>"domain.blog.Blog"</span>/></span><br><span class=line>  &LTtypeAlias <span class=built_in>alias</span>=<span class=string>"Comment"</span> <span class=built_in>type</span>=<span class=string>"domain.blog.Comment"</span>/></span><br><span class=line>  &LTtypeAlias <span class=built_in>alias</span>=<span class=string>"Post"</span> <span class=built_in>type</span>=<span class=string>"domain.blog.Post"</span>/></span><br><span class=line>  &LTtypeAlias <span class=built_in>alias</span>=<span class=string>"Section"</span> <span class=built_in>type</span>=<span class=string>"domain.blog.Section"</span>/></span><br><span class=line>  &LTtypeAlias <span class=built_in>alias</span>=<span class=string>"Tag"</span> <span class=built_in>type</span>=<span class=string>"domain.blog.Tag"</span>/></span><br><span class=line>&LT/typeAliases></span><br></pre></table></figure><p>当这样配置时，<code>Blog</code> 可以用在任何使用 <code>domain.blog.Blog</code> 的地方。<p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>typeAliases</span>></span></span><br><span class=line>  <span class=tag><<span class=name>package</span> <span class=attr>name</span>=<span class=string>"domain.blog"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>typeAliases</span>></span></span><br></pre></table></figure><p>每一个在包 <code>domain.blog</code> 中的 Java Bean,<strong>在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名</strong>。 比如 <code>domain.blog.Author</code> 的别名为 <code>author</code>；若有注解，则别名为其注解值。见下面的例子：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Alias("author")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>Author</span> </span>{</span><br><span class=line>    ...</span><br><span class=line>}</span><br></pre></table></figure><h3 id=typehandlers><a class=headerlink href=#typehandlers title=typehandlers></a>typehandlers</h3><p>MyBatis 在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。<h3 id=插件（plugins）><a class=headerlink href=#插件（plugins） title=插件（plugins）></a>插件（plugins）</h3><p>MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：<ul><li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)<li>ParameterHandler (getParameterObject, setParameters)<li>ResultSetHandler (handleResultSets, handleOutputParameters)<li>StatementHandler (prepare, parameterize, batch, update, query)</ul><p>这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 发行包中的源代码。 如果你想做的不仅仅是监控方法的调用，那么你最好相当了解要重写的方法的行为。 因为在试图修改或重写已有方法的行为时，很可能会破坏 MyBatis 的核心模块。 这些都是更底层的类和方法，所以使用插件的时候要特别当心。<p>通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。<figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=comment>// ExamplePlugin.java</span></span><br><span class=line><span class=meta>@Intercepts</span>({<span class=meta>@Signature</span>(</span><br><span class=line>  <span class=keyword>type</span>= Executor.class,</span><br><span class=line>  method = <span class=string>"update"</span>,</span><br><span class=line>  args = {MappedStatement.class,<span class=built_in>Object</span>.class})})</span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ExamplePlugin</span> <span class=title>implements</span> <span class=title>Interceptor</span> </span>{</span><br><span class=line>  <span class=keyword>private</span> Properties properties = <span class=keyword>new</span> Properties();</span><br><span class=line>  <span class=keyword>public</span> <span class=built_in>Object</span> intercept(Invocation invocation) throws Throwable {</span><br><span class=line>    <span class=comment>// implement pre processing if need</span></span><br><span class=line>    <span class=built_in>Object</span> returnObject = invocation.proceed();</span><br><span class=line>    <span class=comment>// implement post processing if need</span></span><br><span class=line>    <span class=keyword>return</span> returnObject;</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>public</span> <span class=built_in>void</span> <span class=function><span class=title>setProperties</span>(<span class=params>Properties properties</span>)</span> {</span><br><span class=line>    <span class=built_in>this</span>.properties = properties;</span><br><span class=line>  }</span><br><span class=line>}</span><br><span class=line>&LT!-- mybatis-config.xml --></span><br><span class=line><span class=xml><span class=tag><<span class=name>plugins</span>></span></span></span><br><span class=line><span class=xml>  <span class=tag><<span class=name>plugin</span> <span class=attr>interceptor</span>=<span class=string>"org.mybatis.example.ExamplePlugin"</span>></span></span></span><br><span class=line><span class=xml>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"someProperty"</span> <span class=attr>value</span>=<span class=string>"100"</span>/></span></span></span><br><span class=line><span class=xml>  <span class=tag>&LT/<span class=name>plugin</span>></span></span></span><br><span class=line><span class=xml><span class=tag>&LT/<span class=name>plugins</span>></span></span></span><br></pre></table></figure><p>上面的插件将会拦截在 Executor 实例中所有的 “update” 方法调用， 这里的 Executor 是负责执行底层映射语句的内部对象。<h3 id=xml映射器><a class=headerlink href=#xml映射器 title=xml映射器></a>xml映射器</h3><p>MyBatis 的真正强大在于它的语句映射，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 致力于减少使用成本，让用户能更专注于 SQL 代码。<p>SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：<ul><li><code>cache</code> – 该命名空间的缓存配置。<li><code>cache-ref</code> – 引用其它命名空间的缓存配置。<li><code>resultMap</code> – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。<li><del><code>parameterMap</code> – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。文档中不会介绍此元素。</del><li><code>sql</code> – 可被其它语句引用的可重用语句块。<li><code>insert</code> – 映射插入语句。<li><code>update</code> – 映射更新语句。<li><code>delete</code> – 映射删除语句。<li><code>select</code> – 映射查询语句。</ul><p>常用属性<div class=table-container><table><thead><tr><th>属性<th>描述<tbody><tr><td><code>id</code><td>在命名空间中唯一的标识符，可以被用来引用这条语句。<tr><td><code>parameterType</code><td>将会传入这条语句的参数的类全限定名或别名。<strong>这个属性是可选的，因为 MyBatis 可以根据语句中实际传入的参数计算出应该使用的类型处理器</strong>（TypeHandler），默认值为未设置（unset）。<tr><td><del>parameterMap</del><td><del>用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。</del><tr><td><code>resultType</code><td>期望从这条语句中返回结果的类全限定名或别名。 注意，<strong>如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型</strong>。 resultType 和 resultMap 之间只能同时使用一个。<tr><td><code>resultMap</code><td><strong>对外部 resultMap 的命名引用</strong>。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。</table></div><p>特殊字符处理,转义或CDATA区<p>参数占位符:#{} ${}$<h3 id=参数映射><a class=headerlink href=#参数映射 title=参数映射></a>参数映射</h3><p>​ 鉴于参数类型（parameterType）会被自动设置为 <code>int</code>，这个参数可以随意命名。原始类型或简单数据类型（比如 <code>Integer</code> 和 <code>String</code>）因为没有其它属性，会用它们的值来作为参数。<p><img alt=image-20250310172440304 data-src=https://s2.loli.net/2025/03/10/u1fMijOcWHJGRTF.png><p><img alt=image-20250310182221930 data-src=https://s2.loli.net/2025/03/10/ckaRKM5JnPW9FEB.png><p><strong>不需要使用 <code>@Param</code> 的情况</strong><ol><li><p><strong>单个参数</strong>：如果你的 Mapper 方法只接受一个参数，那么你不需要使用 <code>@Param</code> 注解。MyBatis 会自动将这个参数映射到 SQL 语句中的占位符。</p> <figure class="highlight arduino"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function>List&LTUser> <span class=title>selectUserByUserName</span><span class=params>(<span class=keyword>String</span> username)</span></span>;</span><br></pre></table></figure> <p>在对应的 XML 映射文件中可以直接引用该参数：</p> <figure class="highlight n1ql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><<span class=keyword>select</span> id=<span class=string>"selectUserByUserName"</span> resultType=<span class=string>"User"</span>></span><br><span class=line>    <span class=keyword>SELECT</span> * <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> username = #{username}</span><br><span class=line>&LT/<span class=keyword>select</span>></span><br></pre></table></figure><li><p><strong>Java Bean 参数</strong>：如果你直接传递一个 Java Bean 对象作为参数，MyBatis 可以通过 OGNL 表达式访问 Bean 的属性，因此也不需要使用 <code>@Param</code>。</p> <figure class="highlight crmsh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>List<span class=tag>&LTUser></span> selectUserByCondition(<span class=keyword>User</span> <span class=title>user</span>);</span><br></pre></table></figure> <p>在 XML 文件中可以通过点符号访问属性：</p> <figure class="highlight n1ql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><<span class=keyword>select</span> id=<span class=string>"selectUserByCondition"</span> resultType=<span class=string>"User"</span>></span><br><span class=line>    <span class=keyword>SELECT</span> * <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> username = #{username} <span class=keyword>AND</span> age = #{age}</span><br><span class=line>&LT/<span class=keyword>select</span>></span><br></pre></table></figure></ol><p><strong>需要使用 <code>@Param</code> 的情况</strong><ol><li><p><strong>多个简单类型参数</strong>：如果 Mapper 方法接受多个简单类型的参数（如 <code>int</code>, <code>String</code> 等），你需要使用 <code>@Param</code> 来为每个参数指定一个名称，以便在 SQL 语句中引用它们。</p> <figure class="highlight autoit"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>List&LTUser> selectUsersByAgeAndUsername(<span class=symbol>@Param</span>(<span class=string>"age"</span>) <span class=built_in>int</span> age, <span class=symbol>@Param</span>(<span class=string>"username"</span>) <span class=built_in>String</span> username)<span class=comment>;</span></span><br></pre></table></figure> <p>在 XML 文件中可以这样引用这些参数：</p> <figure class="highlight n1ql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><<span class=keyword>select</span> id=<span class=string>"selectUsersByAgeAndUsername"</span> resultType=<span class=string>"User"</span>></span><br><span class=line>    <span class=keyword>SELECT</span> * <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> age = #{age} <span class=keyword>AND</span> username = #{username}</span><br><span class=line>&LT/<span class=keyword>select</span>></span><br></pre></table></figure><li><p><strong>为了提高代码可读性</strong>：即使只有一个参数，有时候为了增加代码的可读性和明确性，也可以选择使用 <code>@Param</code> 注解来命名参数。</p><li><p><strong>Map 类型参数</strong>：当使用 Map 传递参数时，通常也需要指定键名来访问值。在这种情况下，虽然不强制要求使用 <code>@Param</code>，但你可以通过 Map 的键来访问值。</p> <figure class="highlight coffeescript"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>List&LTUser> selectUsersByConditions(<span class=built_in>Map</span><<span class=built_in>String</span>, <span class=built_in>Object</span>> params);</span><br></pre></table></figure> <figure class="highlight n1ql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><<span class=keyword>select</span> id=<span class=string>"selectUsersByConditions"</span> resultType=<span class=string>"User"</span>></span><br><span class=line>    <span class=keyword>SELECT</span> * <span class=keyword>FROM</span> users <span class=keyword>WHERE</span> age = #{age} <span class=keyword>AND</span> username = #{username}</span><br><span class=line>&LT/<span class=keyword>select</span>></span><br></pre></table></figure></ol><p><strong>总结</strong><ul><li>如果是单个参数或者传递的是 Java Bean，则通常不需要使用 <code>@Param</code>。<li>当方法有多个简单类型参数时，必须使用 <code>@Param</code> 来为每个参数指定名称，以便在 SQL 语句中引用。<li>使用 <code>@Param</code> 还有助于提高代码的可读性和维护性，尤其是在参数较多或逻辑较为复杂的情况下。</ul><blockquote><p>Java Bean 是一种符合特定规范的 Java 类，主要用于封装数据。它是 Java 中的一种标准，旨在使对象更容易被复用和管理，尤其是在可视化开发工具中。一个典型的 Java Bean 通常具有以下特征：<p><strong>特征</strong><ol><li><strong>私有属性</strong>：类中的成员变量应该是私有的（<code>private</code>），这意味着它们不能直接从类外部访问。<li><strong>无参构造器</strong>：必须提供一个公共的无参构造函数（默认构造器），以便能够实例化对象而不需要传递任何参数。这是为了确保可以通过反射机制创建对象实例，比如在框架内部（如Spring, MyBatis）。<li><strong>getter 和 setter 方法</strong>：对于每个私有属性，应该提供公共的 getter（获取值）和 setter（设置值）方法。这允许外部代码安全地访问和修改这些属性的值。<li><strong>可序列化</strong>（可选）：如果需要在网络上传输对象或者保存到文件中，那么这个类应该实现 <code>Serializable</code> 接口。</ol></blockquote><p><img alt=image-20250310110128114 data-src=https://s2.loli.net/2025/03/10/odIl2cm87SBxpk3.png><h3 id=结果映射><a class=headerlink href=#结果映射 title=结果映射></a>结果映射</h3><p>返回结果如果包含多个值,可以使用map.<p>如果使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为领域模型。MyBatis 对两者都提供了支持。看看下面这个 JavaBean：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.someapp.model;</span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>User</span> </span>{</span><br><span class=line>  <span class=keyword>private</span> <span class=keyword>int</span> id;</span><br><span class=line>  <span class=keyword>private</span> String username;</span><br><span class=line>  <span class=keyword>private</span> String hashedPassword;</span><br><span class=line></span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=keyword>int</span> <span class=title>getId</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>return</span> id;</span><br><span class=line>  }</span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>setId</span><span class=params>(<span class=keyword>int</span> id)</span> </span>{</span><br><span class=line>    <span class=keyword>this</span>.id = id;</span><br><span class=line>  }</span><br><span class=line>  <span class=function><span class=keyword>public</span> String <span class=title>getUsername</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>return</span> username;</span><br><span class=line>  }</span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>setUsername</span><span class=params>(String username)</span> </span>{</span><br><span class=line>    <span class=keyword>this</span>.username = username;</span><br><span class=line>  }</span><br><span class=line>  <span class=function><span class=keyword>public</span> String <span class=title>getHashedPassword</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>return</span> hashedPassword;</span><br><span class=line>  }</span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>setHashedPassword</span><span class=params>(String hashedPassword)</span> </span>{</span><br><span class=line>    <span class=keyword>this</span>.hashedPassword = hashedPassword;</span><br><span class=line>  }</span><br><span class=line>}</span><br></pre></table></figure><p>基于 JavaBean 的规范，上面这个类有 3 个属性：id，username 和 hashedPassword。这些属性会对应到 select 语句中的列名。<p>这样的一个 JavaBean 可以被映射到 <code>ResultSet</code>，就像映射到 <code>HashMap</code> 一样简单。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectUsers"</span> <span class=attr>resultType</span>=<span class=string>"com.someapp.model.User"</span>></span></span><br><span class=line>  select id, username, hashedPassword</span><br><span class=line>  from some_table</span><br><span class=line>  where id = #{id}</span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><p>类型别名是你的好帮手。使用它们，你就可以不用输入类的全限定名了。比如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- mybatis-config.xml 中 --></span></span><br><span class=line><span class=tag><<span class=name>typeAlias</span> <span class=attr>type</span>=<span class=string>"com.someapp.model.User"</span> <span class=attr>alias</span>=<span class=string>"User"</span>/></span></span><br><span class=line></span><br><span class=line><span class=comment>&LT!-- SQL 映射 XML 中 --></span></span><br><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectUsers"</span> <span class=attr>resultType</span>=<span class=string>"User"</span>></span></span><br><span class=line>  select id, username, hashedPassword</span><br><span class=line>  from some_table</span><br><span class=line>  where id = #{id}</span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><p>在这些情况下，<strong>MyBatis 会在幕后自动创建一个 <code>ResultMap</code>，再根据属性名来映射列到 JavaBean 的属性上</strong>。如果列名和属性名不能匹配上，可以在 SELECT 语句中设置列别名（这是一个基本的 SQL 特性）来完成匹配。比如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectUsers"</span> <span class=attr>resultType</span>=<span class=string>"User"</span>></span></span><br><span class=line>  select</span><br><span class=line>    user_id             as "id",</span><br><span class=line>    user_name           as "userName",</span><br><span class=line>    hashed_password     as "hashedPassword"</span><br><span class=line>  from some_table</span><br><span class=line>  where id = #{id}</span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><p>在学习了上面的知识后，你会发现上面的例子没有一个需要显式配置 <code>ResultMap</code>，这就是 <code>ResultMap</code> 的优秀之处——你完全可以不用显式地配置它们。 虽然上面的例子不用显式配置 <code>ResultMap</code>。 但为了讲解，我们来看看如果在刚刚的示例中，显式使用外部的 <code>resultMap</code> 会怎样，这也是解决列名不匹配的另外一种方式。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>resultMap</span> <span class=attr>id</span>=<span class=string>"userResultMap"</span> <span class=attr>type</span>=<span class=string>"User"</span>></span></span><br><span class=line>  <span class=tag><<span class=name>id</span> <span class=attr>property</span>=<span class=string>"id"</span> <span class=attr>column</span>=<span class=string>"user_id"</span> /></span></span><br><span class=line>  <span class=tag><<span class=name>result</span> <span class=attr>property</span>=<span class=string>"username"</span> <span class=attr>column</span>=<span class=string>"user_name"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>result</span> <span class=attr>property</span>=<span class=string>"password"</span> <span class=attr>column</span>=<span class=string>"hashed_password"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>resultMap</span>></span></span><br></pre></table></figure><p>然后在引用它的语句中设置 <code>resultMap</code> 属性就行了（注意我们去掉了 <code>resultType</code> 属性）。比如:<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectUsers"</span> <span class=attr>resultMap</span>=<span class=string>"userResultMap"</span>></span></span><br><span class=line>  select user_id, user_name, hashed_password</span><br><span class=line>  from some_table</span><br><span class=line>  where id = #{id}</span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><p>sql元素可以用来定义可重用的 SQL 代码片段，以便在其它语句中使用。 参数可以静态地（在加载的时候）确定下来，并且可以在不同的 include 元素中定义不同的参数值。比如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>sql</span> <span class=attr>id</span>=<span class=string>"userColumns"</span>></span> ${alias}.id,${alias}.username,${alias}.password <span class=tag>&LT/<span class=name>sql</span>></span></span><br></pre></table></figure><p>这个 SQL 片段可以在其它语句中使用，例如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectUsers"</span> <span class=attr>resultType</span>=<span class=string>"map"</span>></span></span><br><span class=line>  select</span><br><span class=line>    <span class=tag><<span class=name>include</span> <span class=attr>refid</span>=<span class=string>"userColumns"</span>></span><span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"alias"</span> <span class=attr>value</span>=<span class=string>"t1"</span>/></span><span class=tag>&LT/<span class=name>include</span>></span>,</span><br><span class=line>    <span class=tag><<span class=name>include</span> <span class=attr>refid</span>=<span class=string>"userColumns"</span>></span><span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"alias"</span> <span class=attr>value</span>=<span class=string>"t2"</span>/></span><span class=tag>&LT/<span class=name>include</span>></span></span><br><span class=line>  from some_table t1</span><br><span class=line>    cross join some_table t2</span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><p>也可以在 include 元素的 refid 属性或内部语句中使用属性值，例如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>sql</span> <span class=attr>id</span>=<span class=string>"sometable"</span>></span></span><br><span class=line>  ${prefix}Table</span><br><span class=line><span class=tag>&LT/<span class=name>sql</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>sql</span> <span class=attr>id</span>=<span class=string>"someinclude"</span>></span></span><br><span class=line>  from</span><br><span class=line>    <span class=tag><<span class=name>include</span> <span class=attr>refid</span>=<span class=string>"${include_target}"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>sql</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"select"</span> <span class=attr>resultType</span>=<span class=string>"map"</span>></span></span><br><span class=line>  select</span><br><span class=line>    field1, field2, field3</span><br><span class=line>  <span class=tag><<span class=name>include</span> <span class=attr>refid</span>=<span class=string>"someinclude"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"prefix"</span> <span class=attr>value</span>=<span class=string>"Some"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"include_target"</span> <span class=attr>value</span>=<span class=string>"sometable"</span>/></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>include</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><p>在INSERT和UPDATE时,可以获取自增的字段值.设置useGeneratedKeys和<code>keyProperty</code><div class=table-container><table><thead><tr><th>属性<th>描述<tbody><tr><td><code>useGeneratedKeys</code><td>（仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。<tr><td><code>keyProperty</code><td>（仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（<code>unset</code>）。如果生成列不止一个，可以用逗号分隔多个属性名称。</table></div><ul><li><strong><code>&LTinsert></code></strong>：用于插入新记录，返回受影响的行数或通过配置获取自增主键。<li><strong><code>&LTupdate></code></strong>：用于更新现有记录，返回受影响的行数。<li><strong><code>&LTdelete></code></strong>：用于删除记录，返回受影响的行数。</ul><h3 id=动态SQL><a class=headerlink href=#动态SQL title=动态SQL></a>动态SQL</h3><ul><li>if<li>choose (when, otherwise)<li>trim (where, set)<li>foreach</ul><p><img alt=image-20250310114956563 data-src=https://s2.loli.net/2025/03/10/NjzLtSgZ9UKIQWC.png><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"findActiveBlogLike"</span></span></span><br><span class=line><span class=tag>     <span class=attr>resultType</span>=<span class=string>"Blog"</span>></span></span><br><span class=line>  SELECT * FROM BLOG</span><br><span class=line>  <span class=tag><<span class=name>where</span>></span></span><br><span class=line>    <span class=tag><<span class=name>if</span> <span class=attr>test</span>=<span class=string>"state != null"</span>></span></span><br><span class=line>         state = #{state}</span><br><span class=line>    <span class=tag>&LT/<span class=name>if</span>></span></span><br><span class=line>    <span class=tag><<span class=name>if</span> <span class=attr>test</span>=<span class=string>"title != null"</span>></span></span><br><span class=line>        AND title like #{title}</span><br><span class=line>    <span class=tag>&LT/<span class=name>if</span>></span></span><br><span class=line>    <span class=tag><<span class=name>if</span> <span class=attr>test</span>=<span class=string>"author != null and author.name != null"</span>></span></span><br><span class=line>        AND author_name like #{author.name}</span><br><span class=line>    <span class=tag>&LT/<span class=name>if</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>where</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><p>where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。<p>用于动态更新语句的类似解决方案叫做 <em>set</em>。<em>set</em> 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>update</span> <span class=attr>id</span>=<span class=string>"updateAuthorIfNecessary"</span>></span></span><br><span class=line>  update Author</span><br><span class=line>    <span class=tag><<span class=name>set</span>></span></span><br><span class=line>      <span class=tag><<span class=name>if</span> <span class=attr>test</span>=<span class=string>"username != null"</span>></span>username=#{username},<span class=tag>&LT/<span class=name>if</span>></span></span><br><span class=line>      <span class=tag><<span class=name>if</span> <span class=attr>test</span>=<span class=string>"password != null"</span>></span>password=#{password},<span class=tag>&LT/<span class=name>if</span>></span></span><br><span class=line>      <span class=tag><<span class=name>if</span> <span class=attr>test</span>=<span class=string>"email != null"</span>></span>email=#{email},<span class=tag>&LT/<span class=name>if</span>></span></span><br><span class=line>      <span class=tag><<span class=name>if</span> <span class=attr>test</span>=<span class=string>"bio != null"</span>></span>bio=#{bio}<span class=tag>&LT/<span class=name>if</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>set</span>></span></span><br><span class=line>  where id=#{id}</span><br><span class=line><span class=tag>&LT/<span class=name>update</span>></span></span><br></pre></table></figure><p>这个例子中，<em>set</em> 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。<p>或者，你可以通过使用<em>trim</em>元素来达到同样的效果：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>trim</span> <span class=attr>prefix</span>=<span class=string>"SET"</span> <span class=attr>suffixOverrides</span>=<span class=string>","</span>></span></span><br><span class=line>  ...</span><br><span class=line><span class=tag>&LT/<span class=name>trim</span>></span></span><br></pre></table></figure><p>注意，我们覆盖了后缀值设置，并且自定义了前缀值<blockquote><p>可以使用mybatisx插件提升开发效率</blockquote><p><strong>相关视频</strong><ol><li><a href=https://www.bilibili.com/video/BV1MT4y1k7wZ/ rel=noopener target=_blank>黑马mybatis教程全套视频教程，2天Mybatis框架从入门到精通_哔哩哔哩_bilibili</a><li><a href=https://www.bilibili.com/video/BV1G5411H7F8 rel=noopener target=_blank>快速上手mybatis</a><li><a href=https://www.bilibili.com/video/BV1VP4y1c7j7 rel=noopener target=_blank>MyBatis零基础入门教程</a></ol><h2 id=Hibernate><a class=headerlink href=#Hibernate title=Hibernate></a>Hibernate</h2><p><a href=https://www.geeksforgeeks.org/hibernate-native-sql/?ref=next_article_top rel=noopener target=_blank>Hibernate - Native SQL - GeeksforGeeks</a><p><a href=https://docs.jboss.org/hibernate/orm/6.5/quickstart/html_single/#hibernate-gsg-tutorial-annotations-entity rel=noopener target=_blank>Getting Started with Hibernate</a><p><strong>maven依赖</strong><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>org.hibernate.orm<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>hibernate-core<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>6.6.10.Final<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><p><strong>配置</strong><p>配置文件hibernate.properties<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=comment># Database connection settings</span></span><br><span class=line><span class=meta>hibernate.connection.url</span>=<span class=string>jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1</span></span><br><span class=line><span class=meta>hibernate.connection.username</span>=<span class=string>sa</span></span><br><span class=line><span class=meta>hibernate.connection.password</span>=<span class=string></span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment># Echo all executed SQL to console</span></span><br><span class=line><span class=meta>hibernate.show_sql</span>=<span class=string>true</span></span><br><span class=line><span class=meta>hibernate.format_sql</span>=<span class=string>true</span></span><br><span class=line><span class=meta>hibernate.highlight_sql</span>=<span class=string>true</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment># Automatically export the schema</span></span><br><span class=line><span class=meta>hibernate.hbm2ddl.auto</span>=<span class=string>create</span></span><br></pre></table></figure><p><strong>创建注解实体类</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Entity</span>   </span><br><span class=line><span class=meta>@Table(name = "Events")</span>   </span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>Event</span> </span>{</span><br><span class=line>   <span class=meta>@Id</span>   </span><br><span class=line><span class=meta>@GeneratedValue</span>   </span><br><span class=line><span class=keyword>private</span> Long id;</span><br><span class=line>    <span class=meta>@Column(name = "eventDate")</span>   </span><br><span class=line><span class=keyword>private</span> LocalDateTime date;</span><br><span class=line>    <span class=comment>//实体其他字段默认被认为是持久的。</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>使用sessionFactory</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>protected</span> <span class=keyword>void</span> <span class=title>setUp</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=comment>// A SessionFactory is set up once for an application!</span></span><br><span class=line>    <span class=keyword>final</span> StandardServiceRegistry registry =</span><br><span class=line>            <span class=keyword>new</span> StandardServiceRegistryBuilder()</span><br><span class=line>                    .build();     </span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>        sessionFactory =</span><br><span class=line>                <span class=keyword>new</span> MetadataSources(registry)             </span><br><span class=line>                        .addAnnotatedClass(Event.class)   </span><br><span class=line>                        .buildMetadata()                  </span><br><span class=line>                        .buildSessionFactory();           </span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>catch</span> (Exception e) {</span><br><span class=line>        <span class=comment>// The registry would be destroyed by the SessionFactory, but we</span></span><br><span class=line>        <span class=comment>// had trouble building the SessionFactory so destroy it manually.</span></span><br><span class=line>        StandardServiceRegistryBuilder.destroy(registry);</span><br><span class=line>    }</span><br><span class=line>    sessionFactory.inTransaction(session -> {   </span><br><span class=line>    session.persist(<span class=keyword>new</span> Event(<span class=string>"Our very first event!"</span>, now()));   </span><br><span class=line>    session.persist(<span class=keyword>new</span> Event(<span class=string>"A follow up event"</span>, now()));</span><br><span class=line>});</span><br><span class=line>    sessionFactory.inTransaction(session -> {</span><br><span class=line>    session.createSelectionQuery(<span class=string>"from Event"</span>, Event.class)   </span><br><span class=line>            .getResultList()   </span><br><span class=line>            .forEach(event -> out.println(<span class=string>"Event ("</span> + event.getDate() + <span class=string>") : "</span> + event.getTitle()));</span><br><span class=line>});</span><br><span class=line>}</span><br></pre></table></figure><p>上面是native hibernate APIs<p>此外还可以使用JPA标准APIs<blockquote><p>5.x版本的hibernate使用cfg和hbm提供映射,但新版本已经不用了.</blockquote><p>><blockquote><p>JPA全称为Java Persistence API（Java持久层API），它是Sun公司在JavaEE 5中提出的Java持久化规范。它为Java开发人员提供了一种对象/关联映射工具，来管理Java应用中的关系数据，JPA吸取了目前Java持久化技术的优点，旨在规范、简化Java对象的持久化工作。很多ORM框架都是实现了JPA的规范，如：Hibernate、EclipseLink。<p>需要注意的是JPA统一了Java应用程序访问ORM框架的规范<p><strong>JPA为我们提供了以下规范：</strong><ol><li>ORM映射元数据：JPA支持XML和注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中<li>JPA 的API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发人员不用再写SQL了<li>JPQL查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。</ol></blockquote><h2 id=Spring-Data-JPA><a title="Spring Data JPA" class=headerlink href=#Spring-Data-JPA></a>Spring Data JPA</h2><blockquote><p>Spring Data是Spring 社区的一个子项目，主要用于简化数据（关系型&非关系型）访问，其主要目标是使得数据库的访问变得方便快捷。<p>Spring Data JPA是在实现了JPA规范的基础上封装的一套 JPA 应用框架，虽然ORM框架都实现了JPA规范，但是在不同的ORM框架之间切换仍然需要编写不同的代码，而使用Spring Data JPA能够方便大家在不同的ORM框架之间进行切换而不需要更改代码。</blockquote><p><a href=https://docs.spring.io/spring-data/jpa/reference/repositories/core-concepts.html rel=noopener target=_blank>Core concepts :: Spring Data JPA</a><p>Spring Data JPA往往搭配Spring以及SpringBoot使用.<p><strong>使用注解创建POJO类</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Entity</span></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Person</span> </span>{</span><br><span class=line></span><br><span class=line>  <span class=meta>@Id</span> <span class=meta>@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class=line>  <span class=keyword>private</span> Long id;</span><br><span class=line>  <span class=keyword>private</span> String name;</span><br><span class=line></span><br><span class=line>  <span class=comment>// getters and setters omitted for brevity</span></span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><p><strong>声明仓库接口</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>interface</span> <span class=title>PersonRepository</span> <span class=keyword>extends</span> <span class=title>Repository</span><<span class=title>Person</span>, <span class=title>Long</span>> </span>{</span><br><span class=line></span><br><span class=line>  <span class=function>Person <span class=title>save</span><span class=params>(Person person)</span></span>;</span><br><span class=line></span><br><span class=line>  <span class=function>Optional&LTPerson> <span class=title>findById</span><span class=params>(<span class=keyword>long</span> id)</span></span>;</span><br><span class=line>}</span><br></pre></table></figure><p><strong>使用仓库</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Service;</span><br><span class=line></span><br><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserService</span> </span>{</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> UserRepository userRepository;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>addUser</span><span class=params>(String name)</span> </span>{</span><br><span class=line>        User user = <span class=keyword>new</span> User();</span><br><span class=line>        user.setName(name);</span><br><span class=line>        userRepository.save(user);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>增加自定义的CRUD方法</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>interface</span> <span class=title>UserRepository</span> <span class=keyword>extends</span> <span class=title>CrudRepository</span><<span class=title>User</span>, <span class=title>Long</span>> </span>{</span><br><span class=line>    <span class=function>List&LTUser> <span class=title>findByName</span><span class=params>(String name)</span></span>; <span class=comment>// 根据名字查找用户</span></span><br><span class=line>}</span><br></pre></table></figure><p>按照相关规范生成相应JPQL查询.<p>基本原则<ol><li><strong>实体属性作为基础</strong>：查询方法通常基于实体类中的属性名称构建。例如，如果你有一个 <code>User</code> 实体，并且这个实体有一个 <code>name</code> 属性，你可以创建一个以 <code>findByName</code> 开头的方法来查找具有特定名称的所有用户。<li><strong>关键词用于指定操作</strong>：在方法名中使用特定的关键字可以指定你想要执行的操作类型（如查找、计数等）以及查询条件（如等于、包含等）。</ol><p>对于更复杂的查询需求，如果方法名约定不能满足要求，可以使用 <code>@Query</code> 注解直接定义JPQL或原生SQL查询。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>interface</span> <span class=title>UserRepository</span> <span class=keyword>extends</span> <span class=title>JpaRepository</span><<span class=title>User</span>, <span class=title>Long</span>> </span>{</span><br><span class=line>    <span class=meta>@Query("select u from User u where u.emailAddress = ?1")</span></span><br><span class=line>    <span class=function>User <span class=title>findByEmailAddress</span><span class=params>(String emailAddress)</span></span>;</span><br><span class=line>}</span><br></pre></table></figure><p>或者使用原生SQL：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=meta>@Query(value = "SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?1", nativeQuery = true)</span></span><br><span class=line><span class=function>User <span class=title>findByEmailAddress</span><span class=params>(String emailAddress)</span></span>;</span><br></pre></table></figure><h1 id=消息组件><a class=headerlink href=#消息组件 title=消息组件></a>消息组件</h1><h2 id=Redis✨><a class=headerlink href=#Redis✨ title=Redis✨></a>Redis✨</h2><h3 id=基本操作><a class=headerlink href=#基本操作 title=基本操作></a>基本操作</h3><p><strong>Redis 的主要特性</strong><ul><li><strong>高性能</strong>：所有数据都存储在内存中，读写速度非常快。<li><strong>持久化</strong>：支持 RDB 和 AOF 两种方式将内存中的数据保存到硬盘上，以防止数据丢失。<li><strong>复制功能</strong>：支持主从复制，可以提高系统的可用性和扩展性。<li><strong>事务支持</strong>：通过 MULTI, EXEC, DISCARD 和 WATCH 等命令实现简单的事务管理。<li><strong>发布订阅模式</strong>：支持 Pub/Sub 消息传递模式。<li><strong>Lua 脚本支持</strong>：允许用户执行自定义逻辑，保证原子性。<li><strong>键过期时间</strong>：可以为每个键设置生存时间，过期后自动删除。</ul><h3 id=数据类型><a class=headerlink href=#数据类型 title=数据类型></a>数据类型</h3><p>Redis 主要支持以下几种数据类型：<ul><li><strong>string（字符串）:</strong> 基本的数据存储单元，可以存储字符串、整数或者浮点数。<li><strong>hash（哈希）:</strong>一个键值对集合，可以存储多个字段。<li><strong>list（列表）:</strong>一个简单的列表，可以存储一系列的字符串元素。<li><strong>set（集合）:</strong>一个无序集合，可以存储不重复的字符串元素。<li><strong>zset(sorted set：有序集合):</strong> 类似于集合，但是每个元素都有一个分数（score）与之关联。<li><strong>位图（Bitmaps）：</strong>基于字符串类型，可以对每个位进行操作。<li><strong>超日志（HyperLogLogs）：</strong>用于基数统计，可以估算集合中的唯一元素数量。<li><strong>地理空间（Geospatial）：</strong>用于存储地理位置信息。<li><strong>发布/订阅（Pub/Sub）：</strong>一种消息通信模式，允许客户端订阅消息通道，并接收发布到该通道的消息。<li><strong>流（Streams）：</strong>用于消息队列和日志存储，支持消息的持久化和时间排序。<li><strong>模块（Modules）：</strong>Redis 支持动态加载模块，可以扩展 Redis 的功能。</ul><h4 id=String><a class=headerlink href=#String title=String></a>String</h4><p>基本编码方式是RAW,基于简单动态字符串实现. 存储上限512MB.<p>如果存储的SDS长度小于44字节,则会采用EMBSTR,此时object head与SDSS是连续空间.<p>如果是整数值,并且在LONG_MAX之内,采用INT编码.不需要SDS部分,ptr直接指向整数.<p><img alt=image-20250326102935636 data-src=https://s2.loli.net/2025/03/26/sjPGpMUlIBCfXrg.png><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>object encoding key <span class=comment># 查询编码方式</span></span><br></pre></table></figure><h4 id=List-1><a class=headerlink href=#List-1 title=List></a>List</h4><p>从首、尾操作元素的列表<p><img alt=image-20250326103337835 data-src=https://s2.loli.net/2025/03/26/ALHs6CkcYGnB8me.png><p><img alt=image-20250326104058671 data-src=https://s2.loli.net/2025/03/26/4JMB7i9FwZpSLVW.png><h4 id=Set-1><a class=headerlink href=#Set-1 title=Set></a>Set</h4><p>单列集合,不保证有序性,保证元素唯一,求交集、并集和差集.<p>set采用HT编码(Dict),key用来存储元素,value统一为null.<p>当存储的所有数据为整数,并且元素数量不超过set-max-intset-entries时,Set会采用IntSet编码,节省内存.<p><img alt=image-20250326105453513 data-src=https://s2.loli.net/2025/03/26/sKmpPezAdXafgn4.png><h4 id=ZSet><a class=headerlink href=#ZSet title=ZSet></a>ZSet</h4><p>每个元素指定一个score值<p><img alt=image-20250326111021533 data-src=https://s2.loli.net/2025/03/26/UhEFYszHKGQjTBt.png><p><img alt=image-20250326111516132 data-src=https://s2.loli.net/2025/03/26/8d5MsA1VqQovZXc.png><p><img alt=image-20250326112849287 data-src=https://s2.loli.net/2025/03/26/n8DoQbwTMVa5FZY.png><h4 id=Hash><a class=headerlink href=#Hash title=Hash></a>Hash</h4><p><img alt=image-20250326113333031 data-src=https://s2.loli.net/2025/03/26/4BPamIhnFEviQWy.png><p><img alt=image-20250326113448318 data-src=https://s2.loli.net/2025/03/26/D25tMOAiSJjCx1n.png><h3 id=缓存穿透><a class=headerlink href=#缓存穿透 title=缓存穿透></a>缓存穿透</h3><p>缓存穿透是指客户端请求的数据在缓冲中和数据库中都不存在,这样缓存永远不会起作用,这些请求直接访问数据库.<h4 id=缓存空对象><a class=headerlink href=#缓存空对象 title=缓存空对象></a>缓存空对象</h4><p>对于查询结果为空的数据，也可以将其缓存起来（通常设置较短的过期时间），这样当同样的请求再次到来时，可以直接从缓存中获取结果而不需要访问数据库。<p><img alt=image-20250325171102410 data-src=https://s2.loli.net/2025/03/25/Xij1Npoe8xrqcS3.png><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=comment>// 示例伪代码</span></span><br><span class=line><span class=function><span class=keyword>public</span> Object <span class=title>getData</span><span class=params>(String key)</span> </span>{</span><br><span class=line>    <span class=comment>// 尝试从缓存获取数据</span></span><br><span class=line>    Object value = cache.get(key);</span><br><span class=line>    <span class=keyword>if</span> (value != <span class=keyword>null</span>) {</span><br><span class=line>        <span class=keyword>return</span> value;</span><br><span class=line>    }</span><br><span class=line>    </span><br><span class=line>    <span class=comment>// 如果缓存未命中，则尝试从数据库获取</span></span><br><span class=line>    value = db.query(key);</span><br><span class=line>    <span class=keyword>if</span> (value == <span class=keyword>null</span>) {</span><br><span class=line>        <span class=comment>// 对于不存在的数据也进行缓存，但设置较短的过期时间</span></span><br><span class=line>        cache.put(key, <span class=string>"NULL"</span>, SHORT_EXPIRE_TIME);</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>        cache.put(key, value);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> value;</span><br><span class=line>}</span><br></pre></table></figure><p>优点:实现简单,维护方便<p>缺点:额外的内存消耗,可能造成短期的不一致<h4 id=布隆过滤><a class=headerlink href=#布隆过滤 title=布隆过滤></a>布隆过滤</h4><p>使用布隆过滤器可以在内存中高效地判断一个元素是否在一个集合中。它通过多个哈希函数将元素映射到位数组中的几个点，设置这些点为1。查询时，只要有一个对应的位不是1，就可以确定该元素不在集合中。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=comment>// 示例伪代码</span></span><br><span class=line>BloomFilter&LTString> bloomFilter = BloomFilter.create(Funnels.stringFunnel(), expectedInsertions);</span><br><span class=line></span><br><span class=line><span class=comment>// 加载所有可能存在的key到布隆过滤器中</span></span><br><span class=line><span class=keyword>for</span> (String key : allPossibleKeys) {</span><br><span class=line>    bloomFilter.put(key);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>boolean</span> <span class=title>mightContain</span><span class=params>(String key)</span> </span>{</span><br><span class=line>    <span class=keyword>return</span> bloomFilter.mightContain(key);</span><br><span class=line>}</span><br></pre></table></figure><p><img alt=image-20250325173115631 data-src=https://s2.loli.net/2025/03/25/axN3ZGnYCrV2dt1.png><p>在实际应用中，你可以在查询之前先用布隆过滤器检查是否存在该键，只有当布隆过滤器认为该键可能存在时，才去数据库查询并更新缓存。<ul><li><strong>优点</strong>：节省空间且查询速度快。<li><strong>缺点</strong>：有一定的误判率，即可能存在某些元素实际上不在集合中却被认为存在的假阳性情况，但对于缓存穿透问题来说，这通常是可接受的。</ul><p>其他方法<p><strong>接口限流与用户行为分析</strong><p><strong>合理的缓存策略设计</strong><p><img alt=image-20250325175340534 data-src=https://s2.loli.net/2025/03/25/Aaehzxr8njmpCbq.png><h3 id=缓存雪崩><a class=headerlink href=#缓存雪崩 title=缓存雪崩></a>缓存雪崩</h3><p>缓存雪崩是指在某个时间段内，<strong>大量的缓存数据同时过期失效，导致大量请求直接打到后端数据库或其他数据源上</strong>，造成服务器负载急剧增加，甚至可能导致系统崩溃的现象。这种情况通常发生在缓存层突然不可用或者缓存策略设计不合理时。<h4 id=解决方案><a class=headerlink href=#解决方案 title=解决方案></a>解决方案</h4><ol><li><strong>设置不同的缓存过期时间</strong></ol><p>随机化过期时间,为避免大量缓存同时过期，可以在设定缓存的有效期时加入一定的随机性。例如，原本所有缓存的有效期都是1小时，现在可以设置成1小时±5分钟，这样可以分散缓存失效的时间点。<ol><li><strong>双缓存机制</strong></ol><p>实现两个级别的缓存，一级缓存用于快速响应请求，二级缓存则在一级缓存失效时提供支持。当一级缓存中的数据过期后，仍然可以从二级缓存中获取数据，从而减轻对数据库的压力。<p><strong>其他</strong><p>利用Redis集群提高服务可用性<p>给缓存业务添加降级限流策略<h3 id=缓存击穿><a class=headerlink href=#缓存击穿 title=缓存击穿></a>缓存击穿</h3><p><strong>缓存击穿</strong>是指一个非常热门的key，在缓存失效的瞬间，大量的请求同时访问这个key，由于此时缓存中没有该数据（已经过期或被删除），这些请求会直接打到数据库上，导致数据库压力骤增。这种情况类似于“击穿”了缓存层，直接冲击后端存储。<h4 id=解决方案-1><a class=headerlink href=#解决方案-1 title=解决方案></a>解决方案</h4><p>1, 互斥锁<p>使用互斥锁可以在缓存失效时只允许一个线程去查询数据库并更新缓存，其他线程等待该线程完成后再从缓存中读取数据。这种方法能有效避免大量线程同时访问数据库。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>public</span> Object <span class=title>getData</span><span class=params>(String key)</span> </span>{</span><br><span class=line>    String lockKey = <span class=string>"lock:"</span> + key;</span><br><span class=line>    Object value = cache.get(key);</span><br><span class=line>    <span class=keyword>if</span> (value == <span class=keyword>null</span>) { <span class=comment>// 缓存未命中</span></span><br><span class=line>        <span class=keyword>synchronized</span>(lockKey.intern()) { <span class=comment>// 使用字符串内部池作为锁对象</span></span><br><span class=line>            value = cache.get(key); <span class=comment>// 再次检查缓存，防止其他线程已经填充了缓存</span></span><br><span class=line>            <span class=keyword>if</span> (value == <span class=keyword>null</span>) {</span><br><span class=line>                value = db.query(key); <span class=comment>// 查询数据库</span></span><br><span class=line>                cache.put(key, value); <span class=comment>// 更新缓存</span></span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> value;</span><br><span class=line>}</span><br></pre></table></figure><p><img alt=image-20250325205849705 data-src=https://s2.loli.net/2025/03/25/I2n1hxzA8XteQP5.png><p>利用<code>setnx</code>实现互斥逻辑.<figure class="highlight processing"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br></pre><td class=code><pre><span class=line><span class=keyword>String</span> solvePassthrough(<span class=keyword>String</span> <span class=built_in>key</span>) {</span><br><span class=line>    <span class=comment>// 1. 查询缓存是否存在</span></span><br><span class=line>    <span class=keyword>String</span> s = redisTemplate.opsForValue().<span class=built_in>get</span>(<span class=built_in>key</span>);</span><br><span class=line>    <span class=keyword>if</span>(s != <span class=keyword>null</span>) {</span><br><span class=line>        <span class=comment>//存在直接返回</span></span><br><span class=line>        <span class=keyword>return</span> s ;</span><br><span class=line>    }<span class=keyword>else</span>{</span><br><span class=line>        <span class=comment>// 不存在 s==null,表示不存在</span></span><br><span class=line>        <span class=comment>// 2. 缓存不存在，尝试拿锁</span></span><br><span class=line>        Boolean b = tryLock(<span class=built_in>key</span>);</span><br><span class=line>        <span class=keyword>if</span>(b) {</span><br><span class=line>            <span class=comment>//3. 拿到锁，查询数据库</span></span><br><span class=line>            <span class=comment>//"select * from table where key = " + key;</span></span><br><span class=line>            <span class=keyword>String</span> result = <span class=string>"result"</span>;</span><br><span class=line>            <span class=keyword>if</span>(result == <span class=keyword>null</span>) {</span><br><span class=line>                <span class=comment>// 数据库查询 没找到数据</span></span><br><span class=line>                <span class=comment>// 设置空缓存对象 避免缓存穿透</span></span><br><span class=line>                redisTemplate.opsForValue().<span class=built_in>set</span>(<span class=built_in>key</span>, <span class=string>""</span>, <span class=number>10</span>, TimeUnit.SECONDS);</span><br><span class=line>                unlock(<span class=built_in>key</span>);</span><br><span class=line>                <span class=keyword>return</span> <span class=keyword>null</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=comment>//4. 查询数据库后，将数据放入缓存</span></span><br><span class=line>            redisTemplate.opsForValue().<span class=built_in>set</span>(<span class=built_in>key</span>, result, <span class=number>10</span>, TimeUnit.SECONDS);</span><br><span class=line>            <span class=comment>//5. 释放锁</span></span><br><span class=line>            unlock(<span class=built_in>key</span>);</span><br><span class=line>            <span class=comment>// 返回结果</span></span><br><span class=line>            <span class=keyword>return</span> result;</span><br><span class=line>        }<span class=keyword>else</span>{</span><br><span class=line>            <span class=comment>//4. 没有拿到锁,等待重试</span></span><br><span class=line>            <span class=keyword>try</span> {</span><br><span class=line>                Thread.sleep(<span class=number>1000</span>);</span><br><span class=line>                <span class=keyword>return</span> solvePassthrough(<span class=built_in>key</span>);</span><br><span class=line>            } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>                <span class=keyword>throw</span> <span class=keyword>new</span> RuntimeException(e);</span><br><span class=line>            }<span class=keyword>finally</span> {</span><br><span class=line>                unlock(<span class=built_in>key</span>);</span><br><span class=line>            }</span><br><span class=line></span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line>Boolean tryLock(<span class=keyword>String</span> <span class=built_in>key</span>) {</span><br><span class=line>    Boolean b = redisTemplate.opsForValue().setIfAbsent(<span class=built_in>key</span>, <span class=string>"1"</span>, <span class=number>2</span>, TimeUnit.SECONDS);</span><br><span class=line>    <span class=keyword>return</span> b;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>void</span> unlock(<span class=keyword>String</span> <span class=built_in>key</span>) {</span><br><span class=line>    redisTemplate.delete(<span class=built_in>key</span>);</span><br><span class=line>}</span><br></pre></table></figure><p>2.逻辑过期<p>对于一些极其重要的热点数据，可以考虑将其缓存设置为永不过期。但是这种方式需要配合后台异步任务定期刷新缓存中的数据，以确保数据的时效性。<p><img alt=image-20250325205936982 data-src=https://s2.loli.net/2025/03/25/2FKGxVs6pUu5d3g.png><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=comment>// 假设我们有一个后台任务定期执行此方法</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>refreshHotData</span><span class=params>()</span> </span>{</span><br><span class=line>    String hotKey = <span class=string>"hot_data"</span>;</span><br><span class=line>    Object newValue = db.query(hotKey); <span class=comment>// 从数据库获取最新数据</span></span><br><span class=line>    cache.put(hotKey, newValue); <span class=comment>// 更新缓存</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 在业务逻辑中获取数据时，直接从缓存读取即可</span></span><br><span class=line><span class=function><span class=keyword>public</span> Object <span class=title>getHotData</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>return</span> cache.get(<span class=string>"hot_data"</span>);</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>可以增加过期时间,在业务层进行判断,如果实际已经过期(此时Redis中仍有数据,因为没有超过TTL). 则创建线程更新数据并写入缓存(加锁),原本线程返回过期数据.</blockquote><p><img alt=image-20250325182959630 data-src=https://s2.loli.net/2025/03/25/KnfBu1UqX9DrAEW.png><h3 id=内存持久化><a class=headerlink href=#内存持久化 title=内存持久化></a>内存持久化</h3><h4 id=RDB><a class=headerlink href=#RDB title=RDB></a>RDB</h4><p>Redis <strong>SAVE</strong> 命令用于创建当前数据库的备份<p>创建 redis 备份文件也可以使用命令 <strong>BGSAVE</strong>，该命令在后台执行。<p>basave会fork主进程得到子进程,子进程共享主进程的内存数据,完成fork后读取内存数据写入RDB文件.<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line>################################ SNAPSHOTTING </span><br><span class=line>#   Note: you can disable saving completely by commenting out all "save" lines.</span><br><span class=line>#</span><br><span class=line>#   It is also possible to remove all the previously configured save</span><br><span class=line>#   points by adding a save directive with a single empty string argument</span><br><span class=line>#   like in the following example:</span><br><span class=line>#</span><br><span class=line>#   save ""</span><br><span class=line></span><br><span class=line>save 900 1</span><br><span class=line>save 300 10</span><br><span class=line>save 60 10000</span><br><span class=line>rdbcompression yes</span><br><span class=line># The filename where to dump the DB</span><br><span class=line>dbfilename dump.rdb</span><br><span class=line># The working directory.</span><br><span class=line>#</span><br><span class=line># The DB will be written inside this directory, with the filename specified</span><br><span class=line># above using the 'dbfilename' configuration directive.</span><br><span class=line>#</span><br><span class=line># The Append Only File will also be created inside this directory.</span><br><span class=line>#</span><br><span class=line># Note that you must specify a directory here, not a file name.</span><br><span class=line>dir ./</span><br></pre></table></figure><p><img alt=image-20250325220031131 data-src=https://s2.loli.net/2025/03/25/UYWLnOzjM3FitKD.png><p><img alt=image-20250325220501005 data-src=https://s2.loli.net/2025/03/25/vSzoKf3ibdCDQw2.png><p><img alt=image-20250325220624058 data-src=https://s2.loli.net/2025/03/25/ObYogUBk1F5Xi3C.png><h4 id=AOF><a class=headerlink href=#AOF title=AOF></a>AOF</h4><p>APPEND ONLY MODE<figure class="highlight coffeescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=comment>######</span><span class=comment>######</span><span class=comment>######</span><span class=comment>######</span><span class=comment>######</span> APPEND ONLY MODE <span class=comment>######</span><span class=comment>######</span><span class=comment>######</span><span class=comment>######</span><span class=comment>######</span><span class=comment>#</span></span><br><span class=line><span class=comment># still running correctly.</span></span><br><span class=line><span class=comment>#</span></span><br><span class=line><span class=comment># AOF and RDB persistence can be enabled at the same time without problems.</span></span><br><span class=line><span class=comment># If the AOF is enabled on startup Redis will load the AOF, that is the file</span></span><br><span class=line><span class=comment># with the better durability guarantees.</span></span><br><span class=line><span class=comment>#</span></span><br><span class=line><span class=comment># Please check http://redis.io/topics/persistence for more information.</span></span><br><span class=line></span><br><span class=line>appendonly <span class=literal>no</span></span><br><span class=line></span><br><span class=line><span class=comment># The name of the append only file (default: "appendonly.aof")</span></span><br><span class=line></span><br><span class=line>appendfilename <span class=string>"appendonly.aof"</span></span><br><span class=line><span class=comment># The default is "everysec", as that's usually the right compromise between</span></span><br><span class=line><span class=comment># speed and data safety. It's up to you to understand if you can relax this to</span></span><br><span class=line><span class=comment># "no" that will let the operating system flush the output buffer when</span></span><br><span class=line><span class=comment># it wants, for better performances (but if you can live with the idea of</span></span><br><span class=line><span class=comment># some data loss consider the default persistence mode that's snapshotting),</span></span><br><span class=line><span class=comment># or on the contrary, use "always" that's very slow but a bit safer than</span></span><br><span class=line><span class=comment># everysec.</span></span><br><span class=line><span class=comment>#</span></span><br><span class=line><span class=comment># More details please check the following article:</span></span><br><span class=line><span class=comment># http://antirez.com/post/redis-persistence-demystified.html</span></span><br><span class=line><span class=comment>#</span></span><br><span class=line><span class=comment># If unsure, use "everysec".</span></span><br><span class=line></span><br><span class=line><span class=comment># appendfsync always</span></span><br><span class=line>appendfsync everysec</span><br><span class=line><span class=comment># appendfsync no</span></span><br></pre></table></figure><p><img alt=image-20250325221116370 data-src=https://s2.loli.net/2025/03/25/eVhk1jS2WB9H7Za.png><p>使用<code>bgrewriteaof</code>节省AOF文件,因为记录的AOF命令可能多余(比如后面的更新了前面的值)<p><img alt=image-20250325222257850 data-src=https://s2.loli.net/2025/03/25/KvqyuzAp4XeFJE8.png><p><img alt=image-20250325222328632 data-src=https://s2.loli.net/2025/03/25/hL2vHmQEdOAuocX.png><h3 id=事务-1><a class=headerlink href=#事务-1 title=事务></a>事务</h3><p>Redis 提供了一种简单的事务机制，它<strong>允许用户将多个命令打包成一个事务进行执行</strong>。与传统数据库中的事务不同<strong>，Redis 的事务并不支持回滚（rollback）操作</strong>。<p>Redis 事务的关键命令<ul><li><strong>MULTI</strong>：标记一个事务块的开始。一旦调用了 <code>MULTI</code> 命令，客户端会进入事务模式，在这种模式下所有的后续命令都会被放入队列中等待执行，而不是立即执行。<li><strong>EXEC</strong>：执行所有在 <code>MULTI</code> 和 <code>EXEC</code> 之间的命令。当调用 <code>EXEC</code> 时，Redis 会顺序地执行事务队列中的每个命令，并返回每个命令的结果。<li><strong>DISCARD</strong>：取消事务，放弃执行事务队列中的所有命令并退出事务模式。<li><p><strong>WATCH</strong>：用于监控一个或多个键，如果这些键在事务执行之前被其他客户端修改了，则事务会被中断，<code>EXEC</code> 返回 <code>nil</code> 表示事务未成功执行。这为 Redis 提供了一种乐观锁机制。</p><li><p><strong>原子性</strong>：虽然 Redis 的事务保证了命令序列要么全部执行，要么一个都不执行，但是 Redis 并不支持回滚功能。这意味着如果有任何命令执行失败，其余命令仍将继续执行。</p><li><strong>乐观锁</strong>：通过 <code>WATCH</code> 命令实现的乐观锁机制可以在一定程度上解决并发修改的问题。例如，在对某个键进行修改前先 <code>WATCH</code> 它，然后执行一系列的操作，最后通过 <code>EXEC</code> 提交事务。如果在这期间有其他客户端修改了该键，则当前事务将被中断，<code>EXEC</code> 将返回 <code>nil</code>。</ul><blockquote><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。<p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</blockquote><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>WATCH mykey</span><br><span class=line>... <span class=comment># 其他客户端可能在此期间修改了 mykey</span></span><br><span class=line>MULTI</span><br><span class=line>SET mykey newValue</span><br><span class=line>EXEC <span class=comment># 如果 mykey 在 WATCH 后被修改过，EXEC 将返回 nil</span></span><br></pre></table></figure><h2 id=RabbitMQ✨><a class=headerlink href=#RabbitMQ✨ title=RabbitMQ✨></a>RabbitMQ✨</h2><h2 id=Kafka><a class=headerlink href=#Kafka title=Kafka></a>Kafka</h2><h2 id=RocketMQ><a class=headerlink href=#RocketMQ title=RocketMQ></a>RocketMQ</h2><h1 id=网络编程框架><a class=headerlink href=#网络编程框架 title=网络编程框架></a>网络编程框架</h1><h2 id=Netty><a class=headerlink href=#Netty title=Netty></a>Netty</h2><h1 id=Spring家族✨><a class=headerlink href=#Spring家族✨ title=Spring家族✨></a>Spring家族✨</h1><p>Spring提供依赖注入(DI),控制反转(IOC),面向切面编程等,为Java开发提供便利.而SpringMVC提供了比纯Servlet更好的开发体验.<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> org.example.MyServlets;</span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * <span class=doctag>@Author</span>: proanimer</span></span><br><span class=line><span class=comment> * <span class=doctag>@Description</span>:</span></span><br><span class=line><span class=comment> * <span class=doctag>@Date</span>: Created in 2025/3/10</span></span><br><span class=line><span class=comment> * <span class=doctag>@Modified</span> By proanimer</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line></span><br><span class=line><span class=comment>// Servlet实现web请求响应</span></span><br><span class=line><span class=keyword>import</span> jakarta.servlet.ServletException;</span><br><span class=line><span class=keyword>import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class=line><span class=keyword>import</span> jakarta.servlet.http.HttpServlet;</span><br><span class=line><span class=keyword>import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class=line><span class=keyword>import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.io.IOException;</span><br><span class=line><span class=keyword>import</span> java.io.PrintWriter;</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * <span class=doctag>@projectName</span>: workspace</span></span><br><span class=line><span class=comment> * <span class=doctag>@package</span>: org.example.MyServlets</span></span><br><span class=line><span class=comment> * <span class=doctag>@className</span>: MyServlet</span></span><br><span class=line><span class=comment> * <span class=doctag>@author</span>: proanimer</span></span><br><span class=line><span class=comment> * <span class=doctag>@description</span>:</span></span><br><span class=line><span class=comment> * <span class=doctag>@date</span>: 2025/3/10 20:01</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=meta>@WebServlet(name = "MyServlet", urlPatterns = "/hello")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>MyServlet</span> <span class=keyword>extends</span> <span class=title>HttpServlet</span> </span>{</span><br><span class=line>    <span class=keyword>private</span>  <span class=keyword>static</span> <span class=keyword>final</span> <span class=keyword>long</span> serialVersionUID = <span class=number>1L</span>;</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>MyServlet</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>super</span>();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>protected</span> <span class=keyword>void</span> <span class=title>doGet</span><span class=params>(HttpServletRequest req, HttpServletResponse resp)</span> <span class=keyword>throws</span> ServletException, IOException </span>{</span><br><span class=line>        resp.setContentType(<span class=string>"text/html;charset=UTF-8"</span>);</span><br><span class=line>        <span class=keyword>try</span>(PrintWriter out = resp.getWriter()) {</span><br><span class=line>            out.println(<span class=string>"&LThtml>"</span>);</span><br><span class=line>            out.println(<span class=string>"&LThead>"</span>);</span><br><span class=line>            out.println(<span class=string>"&LTtitle>MyServlet&LT/title>"</span>);</span><br><span class=line>            out.println(<span class=string>"&LT/head>"</span>);</span><br><span class=line>            out.println(<span class=string>"&LTbody>"</span>);</span><br><span class=line>            out.println(<span class=string>"&LTh1>MyServlet&LT/h1>"</span>);</span><br><span class=line>            out.println(<span class=string>"&LT/body>"</span>);</span><br><span class=line>            out.println(<span class=string>"&LT/html>"</span>);</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>protected</span> <span class=keyword>void</span> <span class=title>doPost</span><span class=params>(HttpServletRequest req, HttpServletResponse resp)</span> <span class=keyword>throws</span> ServletException, IOException </span>{</span><br><span class=line>       doGet(req,resp);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><h2 id=spring><a class=headerlink href=#spring title=spring></a>spring</h2><p><a href=https://spring.io/quickstart rel=noopener target=_blank>Spring | Quickstart</a><p><a href=https://www.cainiaojc.com/spring/spring-tutorial.html rel=noopener target=_blank>Spring 教程 - Spring教程 - 菜鸟教程</a><h3 id=IOC容器><a class=headerlink href=#IOC容器 title=IOC容器></a>IOC容器</h3><blockquote><p>依赖注入（DI）是 IoC 的一种特殊形式，其中对象仅通过构造函数参数、工厂方法参数或在对象实例构建或从工厂方法返回后设置的属性来定义其依赖（即它们与之一起工作的其他对象）。IoC 容器在创建 bean 时注入这些依赖。这个过程本质上是 bean 本身通过直接构建类或如Service Locator pattern等机制控制其依赖的实例化或位置的反向（因此得名，控制反转）。</blockquote><p>Spring 框架支持多种配置方式，包括<strong>基于 XML 的配置</strong>、<strong>基于注解的配置</strong>以及<strong>基于 Java 配置类</strong>的配置。<blockquote><p>spring6.x版本官方文档已经不再详细说xml配置,主流是java配置类.</blockquote><ul><li><strong>XML 配置</strong>：适用于传统的 Spring 应用程序，提供了对 Spring 容器的详细控制。<li><strong>注解配置</strong>：减少了 XML 配置的需求，使得代码更加简洁，但可能不如 XML 配置那样直观地看到整个应用程序的结构。<li><strong>Java 配置类</strong>：提供了一种类型安全的方式来配置 Spring 应用程序，尤其适合新的项目或微服务架构。</ul><p><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 包是 Spring 框架 IoC 容器的基石。 <code>BeanFactory</code> 接口提供了一种高级配置机制，能够管理任何类型的对象。 <code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口。<blockquote><p>Spring容器就是<code>ApplicationContext</code>，它是一个接口，有很多实现类，比如<code>ClassPathXmlApplicationContext</code>，表示它会自动从classpath中查找指定的XML配置文件。</blockquote><p><code>BeanFactory</code> 接口提供了一种高级配置机制，能够管理任何类型的对象，它是SpringIoC容器标准化超接口！<p><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口。它扩展了以下功能：<ul><li>更容易与 Spring 的 AOP 功能集成<li>消息资源处理（用于国际化）<li>特定于应用程序给予此接口实现，例如Web 应用程序的 <code>WebApplicationContext</code></ul><p>简而言之， <code>BeanFactory</code> 提供了配置框架和基本功能，而 <code>ApplicationContext</code> 添加了更多特定于企业的功能。 <code>ApplicationContext</code> 是 <code>BeanFactory</code> 的完整超集<p><strong>ApplicationContext容器实现类</strong>：<div class=table-container><table><thead><tr><th>类型名<th>简介<tbody><tr><td><strong>ClassPathXmlApplicationContext</strong><td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象<tr><td>FileSystemXmlApplicationContext<td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象<tr><td><strong>AnnotationConfigApplicationContext</strong><td>通过读取Java配置类创建 IOC 容器对象<tr><td>WebApplicationContext<td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</table></div><p>IoC 容器的基本职责包括：<ul><li>实例化 Bean。<li>设置 Bean 的属性值和生命周期回调。<li>管理 Bean 之间的依赖关系。<li>控制 Bean 的作用域（如 singleton, prototype 等）。</ul><p>Spring 提供了两种类型的 IoC 容器：<ul><li><strong>BeanFactory</strong>：提供了基础的功能来管理和操作 Bean，适合资源受限的环境。<li><strong>ApplicationContext</strong>：扩展了 <code>BeanFactory</code>，增加了事件发布、国际化支持、AOP 集成等功能，适用于大多数应用场合。</ul><p>通常情况下，开发者更倾向于使用 <code>ApplicationContext</code>，因为它提供了更多的功能和便利性。<p><strong>2. ApplicationContext 的实现类</strong><p>Spring 提供了几种 <code>ApplicationContext</code> 的实现类，每种都有其特定的应用场景：<ul><li><strong>ClassPathXmlApplicationContext</strong>：从类路径下的 XML 文件加载 Bean 定义。<li><strong>FileSystemXmlApplicationContext</strong>：从文件系统中指定位置的 XML 文件加载 Bean 定义。<li><strong>AnnotationConfigApplicationContext</strong>：用于基于 Java 注解的配置，不依赖于 XML 文件。<li><strong>WebApplicationContext</strong>：专为 Web 应用设计，支持 Servlet 上下文，并且可以方便地集成到 Web 应用程序中。</ul><p><strong>3. Bean 定义</strong><p>在 Spring 中，Bean 定义是描述如何创建一个 Bean 的元数据。可以通过以下方式定义 Bean：<ul><li><strong>XML 配置文件</strong>：传统方式，通过 XML 文件定义 Bean 及其依赖关系。<li><strong>注解</strong>：例如 <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code> 等，配合 <code>@Autowired</code> 或构造函数注入。<li><strong>Java 配置类</strong>：使用 <code>@Configuration</code> 和 <code>@Bean</code> 注解定义 Bean。</ul><h4 id=构造器注入><a class=headerlink href=#构造器注入 title=构造器注入></a>构造器注入</h4><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"com.example.ExampleBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>value</span>=<span class=string>"value1"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>ref</span>=<span class=string>"anotherBean"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"anotherBean"</span> <span class=attr>class</span>=<span class=string>"com.example.AnotherBean"</span>/></span></span><br></pre></table></figure><p><code>&LTconstructor-arg></code> 标签用于在 XML 配置文件中定义构造函数注入所需的参数。通过该标签，你可以指定将哪些值或 Bean 注入到目标类的构造函数中。<code>&LTconstructor-arg></code> 支持多个属性来帮助精确地匹配和注入依赖，主要包括 <code>name</code>, <code>value</code>, <code>index</code>, 和 <code>type</code> 等属性。下面详细介绍这些属性的意义：<ol><li><code>name</code></ol><ul><li><p><strong>用途</strong>：指定构造函数参数的名字。</p><li><p><strong>适用场景</strong>：当目标类的构造函数使用命名参数时，可以通过 <code>name</code> 属性明确指定要注入哪个参数。不过需要注意的是，Spring 在早期版本中并不直接支持按名称注入构造参数，而是根据类型和顺序（索引）进行匹配。从 Spring 3.0 开始，如果使用 CGLIB 来增强字节码，则可以支持基于名称的构造函数注入。</p><li><p>示例</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"com.example.ExampleClass"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>name</span>=<span class=string>"paramName"</span> <span class=attr>value</span>=<span class=string>"someValue"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure></ul><ol><li><code>value</code></ol><ul><li><p><strong>用途</strong>：直接为基本数据类型或 String 类型的构造函数参数提供值。</p><li><p><strong>适用场景</strong>：适用于需要传递简单类型的值作为构造函数参数的情况。</p><li><p>示例：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"com.example.ExampleClass"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>index</span>=<span class=string>"0"</span> <span class=attr>value</span>=<span class=string>"Hello, World!"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>这里”Hello, World!”将被作为第一个参数传递给ExampleClass的构造函数。</p></ul><ol><li><code>index</code></ol><ul><li><p><strong>用途</strong>：指定构造函数参数的位置索引，以确定向哪个参数注入值。</p><li><p><strong>适用场景</strong>：当你有多个构造函数参数并且想要精确控制哪个参数接收哪个值时非常有用。</p><li><p><strong>注意事项</strong>：索引是从 0 开始的。</p><li><p>示例：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"com.example.ExampleClass"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>index</span>=<span class=string>"0"</span> <span class=attr>value</span>=<span class=string>"First Argument"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>index</span>=<span class=string>"1"</span> <span class=attr>ref</span>=<span class=string>"anotherBean"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure></ul><ol><li><code>type</code></ol><ul><li><p><strong>用途</strong>：指定构造函数参数的数据类型，帮助 Spring 容器更准确地选择合适的构造函数（特别是在存在重载构造函数的情况下）。</p><li><p><strong>适用场景</strong>：当你有多个同名但不同类型的构造函数参数时，或者你需要确保特定类型的值被注入时使用。</p><li><p>示例：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"com.example.ExampleClass"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>type</span>=<span class=string>"java.lang.String"</span> <span class=attr>value</span>=<span class=string>"String Argument"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>type</span>=<span class=string>"int"</span> <span class=attr>value</span>=<span class=string>"123"</span>/></span></span><br></pre></table></figure></ul><p>Java配置类<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>AppConfig</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> MyRepository <span class=title>myRepository</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> MyRepositoryImpl();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> MyService <span class=title>myService</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=comment>// 使用构造函数注入</span></span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> MyServiceImpl(myRepository());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h4 id=静态工厂方法><a class=headerlink href=#静态工厂方法 title=静态工厂方法></a>静态工厂方法</h4><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"clientService"</span> <span class=attr>class</span>=<span class=string>"com.example.ClientService"</span> <span class=attr>factory-method</span>=<span class=string>"createInstance"</span>/></span></span><br></pre></table></figure><p>利用工厂类的静态方法<h4 id=实例工厂方法><a class=headerlink href=#实例工厂方法 title=实例工厂方法></a>实例工厂方法</h4><p>利用工厂的实例方法<p>首先定义工厂 Bean<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"serviceFactory"</span> <span class=attr>class</span>=<span class=string>"com.example.ServiceFactory"</span>/></span></span><br></pre></table></figure><p>然后，使用这个工厂 Bean 的方法来创建目标 Bean。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"clientService"</span> <span class=attr>factory-bean</span>=<span class=string>"serviceFactory"</span> <span class=attr>factory-method</span>=<span class=string>"createClientServiceInstance"</span>/></span></span><br></pre></table></figure><p>这里假设 <code>ServiceFactory</code> 类中有一个名为 <code>createClientServiceInstance</code> 的方法，用于创建并返回一个新的 <code>ClientService</code> 实例。<p><strong>注解方式创建工厂Bean</strong><p>用工厂模式创建Bean需要实现<code>FactoryBean</code>接口。我们观察下面的代码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ZoneIdFactoryBean</span> <span class=keyword>implements</span> <span class=title>FactoryBean</span><<span class=title>ZoneId</span>> </span>{</span><br><span class=line></span><br><span class=line>    String zone = <span class=string>"Z"</span>;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> ZoneId <span class=title>getObject</span><span class=params>()</span> <span class=keyword>throws</span> Exception </span>{</span><br><span class=line>        <span class=keyword>return</span> ZoneId.of(zone);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Class&LT?> getObjectType() {</span><br><span class=line>        <span class=keyword>return</span> ZoneId.class;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>当一个Bean实现了<code>FactoryBean</code>接口后，Spring会先实例化这个工厂，然后调用<code>getObject()</code>创建真正的Bean。<code>getObjectType()</code>可以指定创建的Bean的类型，因为指定类型不一定与实际类型一致，可以是接口或抽象类。<p>因此，如果定义了一个<code>FactoryBean</code>，要注意Spring创建的Bean实际上是这个<code>FactoryBean</code>的<code>getObject()</code>方法返回的Bean。为了和普通Bean区分，我们通常都以<code>XxxFactoryBean</code>命名。<p><strong>由于可以用<code>@Bean</code>方法创建第三方Bean，本质上<code>@Bean</code>方法就是工厂方法，所以，<code>FactoryBean</code>已经用得越来越少了</strong>。<h4 id=实例化后设置属性><a class=headerlink href=#实例化后设置属性 title=实例化后设置属性></a>实例化后设置属性</h4><p>这是最常见的 Bean 实例化方式之一，在 Bean 被实例化之后，通过 setter 方法设置其属性。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"com.example.ExampleBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"property1"</span> <span class=attr>value</span>=<span class=string>"value1"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"property2"</span> <span class=attr>ref</span>=<span class=string>"anotherBean"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"anotherBean"</span> <span class=attr>class</span>=<span class=string>"com.example.AnotherBean"</span>/></span></span><br></pre></table></figure><p>在这个例子中，<code>ExampleBean</code> 有两个属性 <code>property1</code> 和 <code>property2</code>，它们分别通过 <code>set</code> 方法被赋值<h4 id=注解Annotation配置><a class=headerlink href=#注解Annotation配置 title=注解Annotation配置></a>注解Annotation配置</h4><p>使用XML配置的优点是所有的Bean都能一目了然地列出来，并通过配置注入能直观地看到每个Bean的依赖。它的缺点是写起来非常繁琐，每增加一个组件，就必须把新的Bean配置到XML中。<p>可以使用Annotation配置，可以完全不需要XML，让Spring自动扫描Bean并组装它们。<p><code>@Component</code>注解就相当于定义了一个Bean，它有一个可选的名称，默认是<code>mailService</code>，即小写开头的类名。<h4 id=使用Java配置类><a class=headerlink href=#使用Java配置类 title=使用Java配置类></a>使用Java配置类</h4><h4 id=Bean的声明周期管理><a class=headerlink href=#Bean的声明周期管理 title=Bean的声明周期管理></a>Bean的声明周期管理</h4><p><strong>Bean 生命周期的基本流程</strong><p>一个典型的 Spring Bean 生命周期包括以下几个步骤：<ol><li><strong>实例化</strong>：根据配置元数据（如 XML 配置、Java 注解或 Java 配置类），Spring 容器首先实例化 Bean。<li><strong>设置属性值</strong>：将 Bean 实例化后，Spring 会为该 Bean 设置属性值和其他依赖注入。<li><strong>初始化前</strong>：如果实现了 <code>Aware</code> 系列接口（例如 <code>BeanNameAware</code>, <code>BeanFactoryAware</code>, <code>ApplicationContextAware</code>），则调用这些接口的方法，让 Bean 能够感知其环境信息。<li><strong>BeanPostProcessor 前处理</strong>：如果存在实现了 <code>BeanPostProcessor</code> 接口的 Bean，则调用其 <code>postProcessBeforeInitialization</code> 方法。这是对所有 Bean 都适用的一个扩展点。<li><strong>初始化</strong>：<ul><li>如果 Bean 实现了 <code>InitializingBean</code> 接口，则调用 <code>afterPropertiesSet()</code> 方法。<li>如果指定了 <code>&LTbean></code> 元素的 <code>init-method</code> 属性或使用了 <code>@PostConstruct</code> 注解，则调用指定的初始化方法。</ul><li><strong>BeanPostProcessor 后处理</strong>：接着再次调用实现了 <code>BeanPostProcessor</code> 接口的 <code>postProcessAfterInitialization</code> 方法。<li><strong>使用阶段</strong>：此时 Bean 已经准备好并可以被应用程序使用了。<li><strong>销毁阶段</strong>：<ul><li>当容器关闭时，如果 Bean 实现了 <code>DisposableBean</code> 接口，则调用 <code>destroy()</code> 方法。<li>如果指定了 <code>&LTbean></code> 元素的 <code>destroy-method</code> 属性或使用了 <code>@PreDestroy</code> 注解，则调用指定的销毁方法。</ul></ol><p><strong>2. 控制 Bean 生命周期的关键接口和注解</strong><ul><li><strong><code>Aware</code> 系列接口</strong>：用于让 Bean 感知到容器的一些信息。<ul><li><code>BeanNameAware</code>: 获取 Bean 的名称。<li><code>BeanFactoryAware</code>: 获取 BeanFactory。<li><code>ApplicationContextAware</code>: 获取 ApplicationContext。</ul><li><strong><code>BeanPostProcessor</code> 接口</strong>：提供两个方法用于前后处理 Bean 初始化逻辑。<ul><li><code>postProcessBeforeInitialization(Object bean, String beanName)</code> 在初始化之前调用。<li><code>postProcessAfterInitialization(Object bean, String beanName)</code> 在初始化之后调用。</ul><li><strong><code>InitializingBean</code> 接口</strong>：提供 <code>afterPropertiesSet()</code> 方法，在所有属性设置完成后执行自定义初始化逻辑。<li><strong><code>DisposableBean</code> 掀口</strong>：提供 <code>destroy()</code> 方法，在容器关闭时执行清理工作。<li><strong>注解支持</strong>：<ul><li><code>@PostConstruct</code>：标注在方法上，表示这是一个初始化方法。<li><code>@PreDestroy</code>：标注在方法上，表示这是一个销毁方法。</ul></ul><p>在 Spring 框架中，Bean 的作用域（Scope）决定了 Bean 实例的作用范围和生命周期。Spring 提供了多种内置的作用域类型，每种类型适用于不同的场景。理解这些作用域可以帮助你更好地控制 Bean 的行为，确保它们在应用程序中的正确使用。<p><strong>1. 常见的 Bean 作用域</strong><p><strong>(1) Singleton（单例）</strong><ul><li><strong>默认作用域</strong>：如果未指定作用域，默认为 <code>singleton</code>。<li><strong>行为</strong>：Spring 容器在整个应用上下文中只会创建一个该类型的 Bean 实例，并且所有对该 Bean 的请求都会返回这个唯一的实例。<li><strong>适用场景</strong>：大多数情况下，特别是对于无状态的服务类，如服务层、数据访问层等。</ul><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"com.example.ExampleClass"</span> <span class=attr>scope</span>=<span class=string>"singleton"</span>/></span></span><br></pre></table></figure><p>或通过注解：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Scope("singleton")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ExampleClass</span> </span>{</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>(2) Prototype（原型）</strong><ul><li><strong>行为</strong>：每次对 Bean 的请求都会创建一个新的实例。<li><strong>适用场景</strong>：当需要每次获取到的是一个新的对象实例时使用，例如命令对象、Web 控制器等。</ul><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"com.example.ExampleClass"</span> <span class=attr>scope</span>=<span class=string>"prototype"</span>/></span></span><br></pre></table></figure><p>或通过注解：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Scope("prototype")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ExampleClass</span> </span>{</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>此外还有Request,Session和Application等作用域.<h4 id=选择性实例化Bean><a class=headerlink href=#选择性实例化Bean title=选择性实例化Bean></a>选择性实例化Bean</h4><p>选择性实例化 Bean 是指根据某些条件动态决定是否创建某个 Bean 实例。Spring 提供了多种机制来实现这种功能，例如使用注解、配置文件或编程方式<p><strong>使用 <code>@Conditional</code> 注解</strong><p><code>@Conditional</code> 是 Spring 中的一个核心注解，用于根据特定条件决定是否加载某个 Bean。<p><strong>(1) 工作原理</strong><ul><li><code>@Conditional</code> 接受一个实现了 <code>Condition</code> 接口的类作为参数。<li>在运行时，Spring 会调用 <code>Condition</code> 的 <code>matches()</code> 方法，如果返回 <code>true</code>，则加载该 Bean；否则跳过。</ul><p><strong>(2) 示例代码</strong><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line>import org.springframework.context.annotation.Condition;</span><br><span class=line>import org.springframework.context.annotation.ConditionContext;</span><br><span class=line>import org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class=line></span><br><span class=line>// 自定义条件类</span><br><span class=line>public class MyCondition implements Condition {</span><br><span class=line>    @Override</span><br><span class=line>    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {</span><br><span class=line>        // 检查系统属性 "my.condition" 是否为 true</span><br><span class=line>        return Boolean.parseBoolean(System.getProperty("my.condition"));</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line>// 配置类</span><br><span class=line>import org.springframework.context.annotation.Bean;</span><br><span class=line>import org.springframework.context.annotation.Conditional;</span><br><span class=line>import org.springframework.context.annotation.Configuration;</span><br><span class=line></span><br><span class=line>@Configuration</span><br><span class=line>public class AppConfig {</span><br><span class=line></span><br><span class=line>    @Bean</span><br><span class=line>    @Conditional(MyCondition.class)</span><br><span class=line>    public MyBean myBean() {</span><br><span class=line>        return new MyBean();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment># 不加载 MyBean</span></span><br><span class=line>java -jar app.jar</span><br><span class=line></span><br><span class=line><span class=comment># 加载 MyBean</span></span><br><span class=line>java -Dmy.condition=<span class=literal>true</span> -jar app.jar</span><br></pre></table></figure><p><code>@Profile</code> 是 Spring 中的一种更简单的条件加载机制，它根据当前激活的环境（profile）来决定是否加载某个 Bean。<p><strong>(1) 工作原理</strong><ul><li>每个 <code>@Profile</code> 注解可以指定一个或多个 profile 名称。<li>只有当这些 profile 被激活时，对应的 Bean 才会被加载。</ul><p><strong>(2) 示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.context.annotation.Bean;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.Configuration;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.Profile;</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ProfileConfig</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=meta>@Profile("dev")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> MyBean <span class=title>devBean</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> MyBean(<span class=string>"Development Environment"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=meta>@Profile("prod")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> MyBean <span class=title>prodBean</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> MyBean(<span class=string>"Production Environment"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>(3) 测试</strong><p>启动程序时，可以通过指定激活的 profile 来加载不同的 Bean：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment># 激活开发环境</span></span><br><span class=line>java -Dspring.profiles.active=dev -jar app.jar</span><br><span class=line></span><br><span class=line><span class=comment># 激活生产环境</span></span><br><span class=line>java -Dspring.profiles.active=prod -jar app.jar</span><br></pre></table></figure><p><strong>使用 FactoryBean 动态创建 Bean</strong><p><code>FactoryBean</code> 是 Spring 提供的一种接口，用于动态创建 Bean 实例。<p><strong>(1) 工作原理</strong><ul><li>实现 <code>FactoryBean</code> 接口，并重写 <code>getObject()</code> 方法。<li>在运行时，Spring 会调用 <code>getObject()</code> 方法来获取实际的 Bean 实例。</ul><p><strong>(2) 示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>MyBeanFactory</span> <span class=keyword>implements</span> <span class=title>FactoryBean</span><<span class=title>MyBean</span>> </span>{</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>boolean</span> enabled;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>MyBeanFactory</span><span class=params>(<span class=keyword>boolean</span> enabled)</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.enabled = enabled;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> MyBean <span class=title>getObject</span><span class=params>()</span> <span class=keyword>throws</span> Exception </span>{</span><br><span class=line>        <span class=keyword>if</span> (!enabled) {</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> IllegalStateException(<span class=string>"Bean creation is disabled!"</span>);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> MyBean();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Class&LT?> getObjectType() {</span><br><span class=line>        <span class=keyword>return</span> MyBean.class;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>boolean</span> <span class=title>isSingleton</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>true</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>(3) 配置</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.context.annotation.Bean;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.Configuration;</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>FactoryBeanConfig</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> MyBeanFactory <span class=title>myBeanFactory</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> MyBeanFactory(Boolean.getBoolean(<span class=string>"factory.bean.enabled"</span>));</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=如何实现依赖注入><a class=headerlink href=#如何实现依赖注入 title=如何实现依赖注入></a>如何实现依赖注入</h3><p>依赖注入是 IoC 的一种实现方式，允许对象定义其依赖关系而不必自行创建或查找依赖的对象。Spring 支持三种依赖注入类型：<ul><li><strong>构造器注入</strong>：通过构造函数参数注入依赖。<li><strong>Setter 方法注入</strong>：通过 setter 方法注入依赖。<li><strong>字段注入</strong>：直接在字段上使用 <code>@Autowired</code> 注解进行注入。</ul><p>当 Spring 应用启动时，IoC 容器会根据 <code>@Autowired</code> 注解的信息去寻找相应的 Bean 并将其注入到目标对象中。以下是几种常见的注入方式：<ol><li><strong>构造函数注入</strong></ol><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ServiceUser</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> MyService myService;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Autowired</span> <span class=comment>// 自 Spring 4.3 起可以省略，如果只有一个构造函数的话</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>ServiceUser</span><span class=params>(MyService myService)</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.myService = myService;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><ul><li>在这个例子中，Spring 将会查找类型为 <code>MyService</code> 的 Bean，并将其注入到 <code>ServiceUser</code> 类的构造函数中。</ul><ol><li><strong>字段注入</strong></ol><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ServiceUser</span> </span>{</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> MyService myService; <span class=comment>// 直接注入 MyService 实例</span></span><br><span class=line>}</span><br></pre></table></figure><ul><li>字段注入是最简单的形式，但它可能会导致难以进行单元测试，因为它绕过了类的构造函数。</ul><ol><li><strong>Setter 方法注入</strong></ol><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ServiceUser</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> MyService myService;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>setMyService</span><span class=params>(MyService myService)</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.myService = myService;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><ul><li>Setter 方法注入适合于那些可选依赖或希望在运行时更改依赖的情况</ul><p><strong>Bean 查找规则</strong><p>Spring 容器按照以下顺序尝试解析依赖：<ol><li><strong>类型匹配</strong>：首先<strong>基于参数类型</strong>查找匹配的 Bean。<li><strong>名称匹配</strong>：如果<strong>有多个相同类型的 Bean 存在，则根据参数名作为 Bean 名称进行匹配</strong>。<li><strong>限定符（Qualifiers）</strong>：当存在多个相同类型的 Bean 且名称也不足以区分时，可以使用 <code>@Qualifier</code> 注解指定确切的 Bean 名称</ol><p>如果你希望给 Bean 指定一个不同于方法名的名称，可以通过 <code>@Bean</code> 注解的 <code>name</code> 属性来实现或者 <code>@Qualifier</code>。例如：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean(name = "zoneZ")</span></span><br><span class=line><span class=function>ZoneId <span class=title>createZoneOfZ</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>return</span> ZoneId.of(<span class=string>"Z"</span>);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=meta>@Bean(name = "zoneUTC8")</span></span><br><span class=line><span class=function>ZoneId <span class=title>createZoneOfUTC8</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>return</span> ZoneId.of(<span class=string>"UTC+08:00"</span>);</span><br><span class=line>}</span><br></pre></table></figure><p><code>@Autowired</code> 标记的构造函数、字段或方法会被 Spring 容器扫描，并尝试找到匹配的 Bean 来注入。如果找到多个匹配的 Bean，则可能需要通过 <code>@Qualifier</code> 注解来指定具体的 Bean。<p>Spring 提供了多种注解用于实现依赖注入。以下是常用的注入注解及其用途：<p><strong>1. 核心注入注解</strong><p><strong>(1) <code>@Autowired</code></strong><ul><li><strong>作用</strong>：自动注入依赖对象。<li>位置:<ul><li>构造器<li>方法（如 setter 方法）<li>字段<li>参数</ul><li>特点<ul><li><strong>默认按类型（byType）</strong>进行匹配。<li>如果有多个相同类型的 Bean，则会抛出异常，需要结合 <code>@Qualifier</code> 使用。 注解用在构造器,setter,属性上和方法参数上</ul></ul><p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserService</span> </span>{</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> UserRepository userRepository; <span class=comment>// 自动注入 UserRepository</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>(2) <code>@Qualifier</code></strong><ul><li><strong>作用</strong>：当存在多个相同类型的 Bean 时，指定要注入的具体 Bean。<li><strong>配合</strong>：通常与 <code>@Autowired</code> 配合使用。<li><strong>特点</strong>：<strong>通过名称（byName）</strong>来限定注入的 Bean。</ul><p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component("userRepositoryV1")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserRepositoryV1</span> <span class=keyword>implements</span> <span class=title>UserRepository</span> </span>{ }</span><br><span class=line></span><br><span class=line><span class=meta>@Component("userRepositoryV2")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserRepositoryV2</span> <span class=keyword>implements</span> <span class=title>UserRepository</span> </span>{ }</span><br><span class=line></span><br><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserService</span> </span>{</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=meta>@Qualifier("userRepositoryV1")</span></span><br><span class=line>    <span class=keyword>private</span> UserRepository userRepository; <span class=comment>// 注入 UserRepositoryV1</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>(3) <code>@Primary</code></strong><ul><li><strong>作用</strong>：<strong>标记一个 Bean 为首选 Bean，当有多个相同类型的 Bean 时优先注入该 Bean</strong>。<li><strong>特点</strong>：无需显式使用 <code>@Qualifier</code>，简化配置。</ul><p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Primary</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserRepositoryV1</span> <span class=keyword>implements</span> <span class=title>UserRepository</span> </span>{ }</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserRepositoryV2</span> <span class=keyword>implements</span> <span class=title>UserRepository</span> </span>{ }</span><br><span class=line></span><br><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserService</span> </span>{</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> UserRepository userRepository; <span class=comment>// 自动注入 UserRepositoryV1</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>(4) <code>@Resource</code></strong><ul><li><strong>作用</strong>：JSR-250 规范提供的注解，用于注入依赖。<li>特点<ul><li><strong>默认按名称（byName）</strong>进行匹配。<li><strong>如果未找到匹配的名称，则按类型（byType）匹配</strong>。</ul><li><strong>区别</strong>：<code>@Resource</code> 是 Java 的标准注解，而 <code>@Autowired</code> 是 Spring 的注解。(推荐Resource而不是Autowired) 注解用在属性上和setter上.</ul><p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component("userRepository")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserRepository</span> </span>{ }</span><br><span class=line></span><br><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserService</span> </span>{</span><br><span class=line>    <span class=meta>@Resource(name = "userRepository")</span></span><br><span class=line>    <span class=keyword>private</span> UserRepository userRepository; <span class=comment>// 按名称注入</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>(5) <code>@Inject</code></strong><ul><li><strong>作用</strong>：JSR-330 规范提供的注解，功能类似于 <code>@Autowired</code>。<li>特点:<ul><li>默认按类型（byType）进行匹配。<li>需要引入 <code>javax.inject</code> 包。</ul><li><strong>区别</strong>：<code>@Inject</code> 是 Java 的标准注解，而 <code>@Autowired</code> 是 Spring 的注解。</ul><p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> javax.inject.Inject;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserRepository</span> </span>{ }</span><br><span class=line></span><br><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserService</span> </span>{</span><br><span class=line>    <span class=meta>@Inject</span></span><br><span class=line>    <span class=keyword>private</span> UserRepository userRepository; <span class=comment>// 自动注入</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>2. 高级注入注解</strong><p><strong>(6) <code>@Value</code></strong><ul><li><strong>作用</strong>：注入简单的值（如字符串、数字）、系统属性或配置文件中的值。<li><strong>特点</strong>：支持占位符 <code>${}</code> 和 SpEL 表达式 <code>#{}</code>。</ul><p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>AppConfig</span> </span>{</span><br><span class=line>    <span class=meta>@Value("${app.name}")</span></span><br><span class=line>    <span class=keyword>private</span> String appName; <span class=comment>// 注入配置文件中的 app.name</span></span><br><span class=line></span><br><span class=line>    <span class=meta>@Value("#{2 + 3}")</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>int</span> sum; <span class=comment>// 注入表达式的计算结果 (2 + 3 = 5)</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>(7) <code>@ConfigurationProperties</code></strong><ul><li><strong>作用</strong>：批量注入配置文件中的属性到一个 Java 对象中。<li><strong>特点</strong>：适合处理复杂的配置结构。</ul><p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Component;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@ConfigurationProperties(prefix = "app")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>AppProperties</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>int</span> version;</span><br><span class=line></span><br><span class=line>    <span class=comment>// Getters and Setters</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>配置文件 (<code>application.properties</code>)：</strong><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=meta>app.name</span>=<span class=string>MyApp</span></span><br><span class=line><span class=meta>app.version</span>=<span class=string>1</span></span><br></pre></table></figure><p><strong>(8) <code>@Lookup</code></strong><ul><li><strong>作用</strong>：用于方法注入，每次调用方法时都会返回一个新的 Bean 实例。<li><strong>场景</strong>：适用于原型（Prototype）作用域的 Bean。</ul><p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Scope("prototype")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>PrototypeBean</span> </span>{ }</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=class><span class=keyword>class</span> <span class=title>SingletonBean</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Lookup</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>abstract</span> PrototypeBean <span class=title>getPrototypeBean</span><span class=params>()</span></span>; <span class=comment>// 每次调用返回新的实例</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>3. 其他相关注解</strong><p><strong>(9) <code>@Required</code></strong><ul><li><strong>作用</strong>：标记某个 setter 方法必须注入值，否则抛出异常。<li><strong>注意</strong>：从 Spring 5 开始已被废弃，推荐使用构造器注入或 <code>@Autowired(required = true)</code>。</ul><p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserService</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> UserRepository userRepository;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Required</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>setUserRepository</span><span class=params>(UserRepository userRepository)</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.userRepository = userRepository;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>(10) <code>@Lazy</code></strong><ul><li><strong>作用</strong>：延迟加载 Bean，只有在第一次使用时才会被创建。<li><strong>特点</strong>：可以减少启动时间，适用于不常用的功能。</ul><p><strong>示例代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Lazy</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>LazyBean</span> </span>{ }</span><br><span class=line></span><br><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>UserService</span> </span>{</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> LazyBean lazyBean; <span class=comment>// 延迟加载</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>4. 总结</strong><div class=table-container><table><thead><tr><th>注解<th>功能描述<th>特点<tbody><tr><td><code>@Autowired</code><td>自动注入依赖，按类型匹配<td>默认按类型，支持配合 <code>@Qualifier</code> 使用<tr><td><code>@Qualifier</code><td>指定要注入的 Bean 名称<td>按名称匹配<tr><td><code>@Primary</code><td>标记首选 Bean<td>简化多 Bean 场景下的注入<tr><td><code>@Resource</code><td>按名称或类型注入<td>JSR-250 标准注解<tr><td><code>@Inject</code><td>按类型注入<td>JSR-330 标准注解<tr><td><code>@Value</code><td>注入简单值或配置文件中的值<td>支持占位符和 SpEL<tr><td><code>@ConfigurationProperties</code><td>批量注入配置文件中的属性<td>适合复杂配置<tr><td><code>@Lookup</code><td>方法注入，每次返回新实例<td>适用于原型作用域<tr><td><code>@Required</code><td>强制要求注入<td>已废弃，推荐使用其他方式<tr><td><code>@Lazy</code><td>延迟加载 Bean<td>减少启动时间</table></div><h3 id=AOP的底层原理><a class=headerlink href=#AOP的底层原理 title=AOP的底层原理></a>AOP的底层原理</h3><p>如何把切面织入到核心逻辑中？这正是AOP需要解决的问题。换句话说，如果客户端获得了<code>BookService</code>的引用，当调用<code>bookService.createBook()</code>时，如何对调用方法进行拦截，并在拦截前后进行安全检查、日志、事务等处理，就相当于完成了所有业务功能。<p>在Java平台上，对于AOP的织入，有3种方式：<ol><li>编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ就扩展了Java编译器，使用关键字aspect来实现织入；<li>类加载器：在目标类被装载到JVM时，通过一个特殊的类加载器，对目标类的字节码重新“增强”；<li>运行期：目标对象和切面都是普通Java类，通过JVM的动态代理功能或者第三方库实现运行期动态织入。</ol><p>最简单的方式是第三种，Spring的AOP实现就是基于JVM的动态代理。由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过<a href=https://github.com/cglib/cglib rel=noopener target=_blank>CGLIB</a>或者<a href=https://www.javassist.org/ rel=noopener target=_blank>Javassist</a>这些第三方库实现。<p>AOP 的几个核心概念：<ul><li><strong>切面（Aspect）</strong>：一个模块化的关注点，例如日志记录、事务管理等。<li><strong>连接点（Join Point）</strong>：程序执行过程中的某个特定点，例如方法调用或异常抛出。<li><strong>通知（Advice）</strong>：在连接点执行的动作，分为前置通知、后置通知、环绕通知等。<li><strong>切入点（Pointcut）</strong>：定义哪些连接点会被通知。<li><strong>目标对象（Target Object）</strong>：被代理的对象。<li><strong>代理对象（Proxy Object）</strong>：由 AOP 框架创建的包装目标对象的对象。</ul><p>如果<strong>目标对象实现了接口，Spring 默认使用 JDK 动态代理</strong>。JDK 动态代理<strong>通过反射机制创建代理对象，并拦截方法调用</strong>。<p>如果目标对象没有实现接口，Spring 使用 CGLIB 动态代理。<strong>CGLIB 通过继承目标类并重写其方法来创建代理对象</strong>。<ul><li>CGLIB 是一个基于字节码生成的库，它通过 ASM 库操作字节码生成子类。<li>子类会覆盖父类的方法，并在方法调用前后插入自定义逻辑。</ul><p>Spring AOP 封装了动态代理的细节，开发者只需关注切面和通知的定义。<p><strong>(1) 定义切面和通知</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Before;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Component;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>LoggingAspect</span> </span>{</span><br><span class=line></span><br><span class=line>    <span class=meta>@Before("execution(* com.example.service.*.*(..))")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>logBefore</span><span class=params>()</span> </span>{</span><br><span class=line>        System.out.println(<span class=string>"Logging before method execution..."</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>(2) 配置 Spring AOP</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.Configuration;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableAspectJAutoProxy</span> <span class=comment>// 启用 AOP 支持</span></span><br><span class=line><span class=meta>@ComponentScan(basePackages = "com.example")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>AppConfig</span> </span>{</span><br><span class=line>}</span><br></pre></table></figure><p><strong>(3) 测试代码</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.context.ApplicationContext;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>MainApp</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        ApplicationContext context = <span class=keyword>new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class=line></span><br><span class=line>        Service service = context.getBean(Service.class);</span><br><span class=line>        service.doSomething();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><ul><li>Spring AOP 的底层依赖于动态代理技术。<li>如果目标对象实现了接口，则使用 JDK 动态代理。<li>如果目标对象未实现接口，则使用 CGLIB 动态代理。</ul><h3 id=如何管理事务><a class=headerlink href=#如何管理事务 title=如何管理事务></a>如何管理事务</h3><h3 id=如何处理循环依赖><a class=headerlink href=#如何处理循环依赖 title=如何处理循环依赖></a>如何处理循环依赖</h3><p>在 Spring 中，<strong>循环依赖</strong>是指两个或多个 Bean 在初始化过程中相互依赖。例如：<ul><li><strong>Bean A</strong> 依赖于 <strong>Bean B</strong>；<li><strong>Bean B</strong> 又依赖于 <strong>Bean A</strong>。</ul><p>Spring 容器通过一些机制来处理循环依赖问题，但并不是所有类型的循环依赖都能被解决<p>循环依赖可以分为以下几种情况：<p><strong>(1) 构造函数注入的循环依赖</strong><p>当两个 Bean 使用构造函数注入时，如果它们之间存在循环依赖，则 Spring 无法解决这种循环依赖，会抛出 <code>BeanCurrentlyInCreationException</code> 异常。<p><strong>示例代码：</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>BeanA</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> BeanB beanB;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>BeanA</span><span class=params>(BeanB beanB)</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.beanB = beanB;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>BeanB</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> BeanA beanA;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>BeanB</span><span class=params>(BeanA beanA)</span> </span>{</span><br><span class=line>        <span class=keyword>this</span>.beanA = beanA;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>在这种情况下，Spring 无法创建任何一个 Bean，因为它们互相依赖且都需要完全初始化后才能使用<p><strong>(2) Setter 方法或字段注入的循环依赖</strong><p>当两个 Bean 使用 setter 方法或字段注入时，Spring 可以解决这种循环依赖。<p><strong>示例代码：</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>BeanA</span> </span>{</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> BeanB beanB;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>BeanB</span> </span>{</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> BeanA beanA;</span><br><span class=line>}</span><br></pre></table></figure><p>Spring 能够通过提前暴露未完全初始化的 Bean 来解决这种循环依赖。<p><strong>Spring 处理循环依赖的机制</strong><p>Spring 容器通过三级缓存（singleton caches）和提前暴露未完全初始化的 Bean 来解决循环依赖问题。<p><strong>(1) 单例 Bean 的三级缓存</strong><p>Spring 容器维护了三个缓存来管理单例 Bean 的生命周期：<ol><li>一级缓存（singletonObjects）<ul><li>存储已经完全初始化完成的 Bean。<li>当 Bean 完全初始化后，会从二级缓存移动到一级缓存。</ul><li>二级缓存（earlySingletonObjects）<ul><li>存储未完全初始化但已经被提前暴露的 Bean。<li>当一个 Bean 正在初始化但还未完成时，Spring 会将其放入二级缓存中，以便其他 Bean 可以引用它。</ul><li>三级缓存（singletonFactories）<ul><li>存储 Bean 的工厂对象（ObjectFactory），用于动态生成未完全初始化的 Bean。<li>当需要提前暴露一个 Bean 时，Spring 会先将其工厂对象放入三级缓存。</ul></ol><p><strong>(2) 提前暴露未完全初始化的 Bean</strong><p>当 Spring 发现一个 Bean 正在初始化且有其他 Bean 需要引用它时，Spring 会提前暴露该 Bean 的实例（即使它还未完全初始化）。这通过以下步骤实现：<ol><li>创建 Bean 实例（调用构造函数）。<li>将 Bean 实例的工厂对象放入三级缓存。<li>如果需要提前暴露，将工厂对象生成的 Bean 放入二级缓存。<li>其他 Bean 可以从二级缓存中获取该未完全初始化的 Bean。<li>当 Bean 完全初始化后，将其移入一级缓存。</ol><p>这种方式适用于基于 setter 方法或字段注入的循环依赖。<p><strong>3. 为什么构造函数注入的循环依赖无法解决？</strong><p>构造函数注入要求 Bean 必须在完全初始化后才能被使用。因此，当两个 Bean 通过构造函数相互依赖时，Spring 无法满足它们的初始化顺序要求。以下是具体原因：<ol><li><strong>Bean A</strong> 需要 <strong>Bean B</strong> 的完全初始化实例。<li><strong>Bean B</strong> 需要 <strong>Bean A</strong> 的完全初始化实例。<li>由于两者都处于“正在初始化”状态，Spring 无法完成任意一方的初始化。</ol><p>一个 Bean 被认为是<strong>完全初始化</strong>的，当它已经通过了所有的初始化步骤，并且可以安全地用于应用程序中。这些步骤通常包括：<ul><li><strong>实例化</strong>：创建 Bean 的实例。<li><strong>属性填充</strong>：为 Bean 的属性设置值或注入依赖（通过构造函数、setter 方法或字段注入）。<li><strong>Aware 接口回调</strong>：如果 Bean 实现了特定的 <code>Aware</code> 接口（如 <code>BeanNameAware</code>, <code>BeanFactoryAware</code>, <code>ApplicationContextAware</code> 等），Spring 会调用相应的方法，让 Bean 能够访问到容器的相关信息。<li><strong>初始化方法调用</strong>：如果有定义初始化方法（通过 <code>@PostConstruct</code> 注解或 <code>&LTbean></code> 元素中的 <code>init-method</code> 属性），Spring 会在该阶段调用这些方法。</ul><p>​ 一旦所有这些步骤都完成了，这个 Bean 就被认为是完全初始化的，并被放入 Spring 容器的一级缓存（singletonObjects）中，供其他组件使用。<p>一个 Bean 被认为是<strong>未完全初始化</strong>的，是指它正处于初始化过程中的某个中间状态。例如，在某些情况下，Bean 已经被实例化并注入了一些依赖，但尚未完成所有的初始化步骤（比如还没有调用初始化方法）。这种状态下，Bean 还不能完全满足其契约要求，因此可能不适合直接使用。<p>​ 在处理循环依赖时，Spring 使用一种称为“提前暴露”的机制来解决 Setter 或字段注入引起的循环依赖问题。具体来说，当 Spring 正在初始化一个 Bean A 时，如果发现另一个 Bean B 需要引用 Bean A，而此时 Bean A 尚未完全初始化，Spring 会将 Bean A 提前暴露出来，尽管它还未经过全部的初始化步骤。这种提前暴露的 Bean 只完成了实例化和部分依赖注入，但尚未执行 Aware 接口回调、初始化方法等后续步骤。<h3 id=代理模式><a class=headerlink href=#代理模式 title=代理模式></a>代理模式</h3><h4 id=springmvc><a class=headerlink href=#springmvc title=springmvc></a>springmvc</h4><blockquote><p>拦截器<p>过滤器</blockquote><p><a href=https://springdoc.cn/spring-mvc-tutorial/ rel=noopener target=_blank>Spring MVC 教程 - spring 中文网</a><p>Spring 框架中处理模型（Model）- 视图（View）- 控制器（Controller）或 MVC 模式的一个模块。它结合了 MVC 模式的所有优点和 Spring 的便利性。<p>Spring 使用其 <code>DispatcherServlet</code> 前控制器模式实现 MVC。<p>简而言之，<code>DispatcherServlet</code> 是将请求路由到预定目的地的主要控制器。Model 只是应用的数据，而视图则由各种模板引擎来表示。<p>包含spring的依赖同时使用servlet等实现MVC架构的Web开发.<p>servlet如下<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.io.IOException;</span><br><span class=line><span class=keyword>import</span> javax.servlet.ServletException;</span><br><span class=line><span class=keyword>import</span> javax.servlet.annotation.WebServlet;</span><br><span class=line><span class=keyword>import</span> javax.servlet.http.HttpServlet;</span><br><span class=line><span class=keyword>import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=line><span class=keyword>import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=line></span><br><span class=line><span class=meta>@WebServlet("/hello")</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>HelloServlet</span> <span class=keyword>extends</span> <span class=title>HttpServlet</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>final</span> <span class=keyword>long</span> serialVersionUID = <span class=number>1L</span>;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>protected</span> <span class=keyword>void</span> <span class=title>doGet</span><span class=params>(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class=line><span class=function>            <span class=keyword>throws</span> ServletException, IOException </span>{</span><br><span class=line>        response.setContentType(<span class=string>"text/html"</span>);</span><br><span class=line>        response.getWriter().println(<span class=string>"&LTh1>Hello, World!&LT/h1>"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>springmvc的示例代码如下.<p>要通过 Java 配置类启用 Spring MVC 支持，只需添加 <code>@EnableWebMvc</code><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=meta>@EnableWebMvc</span></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>WebConfig</span> <span class=keyword>implements</span> <span class=title>WebMvcConfigurer</span> </span>{</span><br><span class=line></span><br><span class=line>   <span class=meta>@Override</span></span><br><span class=line>   <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>addViewControllers</span><span class=params>(ViewControllerRegistry registry)</span> </span>{</span><br><span class=line>      registry.addViewController(<span class=string>"/"</span>).setViewName(<span class=string>"index"</span>);</span><br><span class=line>   }</span><br><span class=line></span><br><span class=line>   <span class=meta>@Bean</span></span><br><span class=line>   <span class=function><span class=keyword>public</span> ViewResolver <span class=title>viewResolver</span><span class=params>()</span> </span>{</span><br><span class=line>      InternalResourceViewResolver bean = <span class=keyword>new</span> InternalResourceViewResolver();</span><br><span class=line></span><br><span class=line>      <span class=comment>//bean.setViewClass(JstlView.class); in older version</span></span><br><span class=line>      bean.setPrefix(<span class=string>"/WEB-INF/view/"</span>);</span><br><span class=line>      bean.setSuffix(<span class=string>".jsp"</span>);</span><br><span class=line></span><br><span class=line>      <span class=keyword>return</span> bean;</span><br><span class=line>   }</span><br><span class=line>}</span><br></pre></table></figure><p>这将设置 MVC 项目所需的基本支持，如注册处理器、映射器、类型转换器、验证支持、消息转换器和异常处理。本例中注册了一个 <code>ViewResolver</code> Bean，它从 <code>/WEB-INF/view</code> 目录返回 <code>.jsp</code> 视图。可以注册视图控制器（ViewController），使用 <code>ViewControllerRegistry</code> 在 URL 和视图名称之间创建直接映射。这样，两者之间就不需要任何 Controller 了。<p>如果想自定义扫描 Controller 类，可以使用 <code>@ComponentScan</code> 注解，并指定包含 Controller 的包。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=meta>@EnableWebMvc</span></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@ComponentScan(basePackages = { "com.baeldung.web.controller" })</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>WebConfig</span> <span class=keyword>implements</span> <span class=title>WebMvcConfigurer</span> </span>{</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>为了引导应用加载该配置，还需要一个 Initializer 类：<blockquote><p>在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。 Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。</blockquote><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>MainWebAppInitializer</span> <span class=keyword>implements</span> <span class=title>WebApplicationInitializer</span> </span>{</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>onStartup</span><span class=params>(<span class=keyword>final</span> ServletContext sc)</span> <span class=keyword>throws</span> ServletException </span>{</span><br><span class=line></span><br><span class=line>        AnnotationConfigWebApplicationContext root = </span><br><span class=line>          <span class=keyword>new</span> AnnotationConfigWebApplicationContext();</span><br><span class=line>        </span><br><span class=line>        root.scan(<span class=string>"com.baeldung"</span>);</span><br><span class=line>        sc.addListener(<span class=keyword>new</span> ContextLoaderListener(root));</span><br><span class=line></span><br><span class=line>        ServletRegistration.Dynamic appServlet = </span><br><span class=line>          sc.addServlet(<span class=string>"mvc"</span>, <span class=keyword>new</span> DispatcherServlet(<span class=keyword>new</span> GenericWebApplicationContext()));</span><br><span class=line>        appServlet.setLoadOnStartup(<span class=number>1</span>);</span><br><span class=line>        appServlet.addMapping(<span class=string>"/"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>MyWebAppInitializer</span> <span class=keyword>extends</span> <span class=title>AbstractAnnotationConfigDispatcherServletInitializer</span> </span>{</span><br><span class=line> </span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>protected</span> Class&LT?>[] getRootConfigClasses() {</span><br><span class=line>        <span class=comment>// 返回应用级别的配置类</span></span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> Class&LT?>[]{RootConfig.class};</span><br><span class=line>    }</span><br><span class=line> </span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>protected</span> Class&LT?>[] getServletConfigClasses() {</span><br><span class=line>        <span class=comment>// 返回与 DispatcherServlet 相关的配置类</span></span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> Class&LT?>[]{WebConfig.class};</span><br><span class=line>    }</span><br><span class=line> </span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>protected</span> String[] getServletMappings() {</span><br><span class=line>        <span class=comment>// 设置 DispatcherServlet 的 URL 映射</span></span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> String[]{<span class=string>"/"</span>};</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>一个基本的 Controller 示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Controller</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>SampleController</span> </span>{</span><br><span class=line>    <span class=meta>@GetMapping("/sample")</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> String <span class=title>showForm</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"sample"</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><p>相应的 JSP 资源是 <code>sample.jsp</code>：<figure class="highlight html"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>html</span>></span></span><br><span class=line>   <span class=tag><<span class=name>head</span>></span><span class=tag>&LT/<span class=name>head</span>></span></span><br><span class=line></span><br><span class=line>   <span class=tag><<span class=name>body</span>></span></span><br><span class=line>      <span class=tag><<span class=name>h1</span>></span>This is the body of the sample view<span class=tag>&LT/<span class=name>h1</span>></span></span><br><span class=line>   <span class=tag>&LT/<span class=name>body</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>html</span>></span></span><br></pre></table></figure><p>基于 <code>JSP</code> 的视图文件位于项目的 <code>/WEB-INF</code> 文件夹下，因此只有 Spring 才能访问它们，而不能直接通过 URL 访问。<p>也可以使用纯 XML 配置来代替上述 Java 配置：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>context:component-scan</span> <span class=attr>base-package</span>=<span class=string>"com.baeldung.web.controller"</span> /></span></span><br><span class=line><span class=tag><<span class=name>mvc:annotation-driven</span> /></span>    </span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"viewResolver"</span> </span></span><br><span class=line><span class=tag>      <span class=attr>class</span>=<span class=string>"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"prefix"</span> <span class=attr>value</span>=<span class=string>"/WEB-INF/view/"</span> /></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"suffix"</span> <span class=attr>value</span>=<span class=string>".jsp"</span> /></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>mvc:view-controller</span> <span class=attr>path</span>=<span class=string>"/"</span> <span class=attr>view-name</span>=<span class=string>"index"</span> /></span></span><br><span class=line></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure><p>如果想使用纯 XML 配置，还需要添加一个 <code>web.xml</code> 文件来引导应用。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>servlet</span>></span></span><br><span class=line>    <span class=tag><<span class=name>servlet-name</span>></span>dispatcher<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>    <span class=tag><<span class=name>servlet-class</span>></span></span><br><span class=line>        org.springframework.web.servlet.DispatcherServlet</span><br><span class=line>    <span class=tag>&LT/<span class=name>servlet-class</span>></span></span><br><span class=line>    <span class=tag><<span class=name>init-param</span>></span></span><br><span class=line>        <span class=tag><<span class=name>param-name</span>></span>contextConfigLocation<span class=tag>&LT/<span class=name>param-name</span>></span></span><br><span class=line>        <span class=tag><<span class=name>param-value</span>></span>/WEB-INF/spring/dispatcher-config.xml<span class=tag>&LT/<span class=name>param-value</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>init-param</span>></span></span><br><span class=line>    <span class=tag><<span class=name>load-on-startup</span>></span>1<span class=tag>&LT/<span class=name>load-on-startup</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servlet</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>servlet-mapping</span>></span></span><br><span class=line>    <span class=tag><<span class=name>servlet-name</span>></span>dispatcher<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>    <span class=tag><<span class=name>url-pattern</span>></span>/<span class=tag>&LT/<span class=name>url-pattern</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servlet-mapping</span>></span></span><br></pre></table></figure><h2 id=springboot><a class=headerlink href=#springboot title=springboot></a>springboot</h2><p><a href=https://springdoc.cn/spring-boot/ rel=noopener target=_blank>Spring Boot 中文文档</a><p><a href=https://spring.io/ rel=noopener target=_blank>Spring | Home</a><p>pring Boot 是对 Spring 平台的补充，它能让你轻松上手并创建独立的生产级应用。Spring Boot 的目的不是取代 Spring，而是让使用 Spring 变得更快、更简单。<p><strong>pring Boot Starte</strong><p>Spring Boot 提供了便捷的 Starter 依赖，这是一种依赖描述符，可以为特定功能引入所有必要的技术。<p>这样做的好处是，不再需要为每个依赖项指定版本，而是让 Starter 管理依赖。<p>最快捷的入门方法是在 <code>pom.xml</code> 中添加 <code>spring-boot-starter-parent</code>：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>parent</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>spring-boot-starter-parent<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>parent</span>></span></span><br></pre></table></figure><p>这样就能解决依赖管理问题。<p><strong>Spring Boot 入口点</strong><p>使用 Spring Boot 构建的每个应用都需定义 main 入口点。<p>这通常是一个 Java 类，带有 main 方法，并用 <code>@SpringBootApplication</code> 进行注解：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=meta>@SpringBootApplication</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>Application</span> </span>{</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        SpringApplication.run(Application.class, args);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>该注解添加了以下其他注解：<ul><li><code>@Configuration</code> 将类标记为 bean 定义的来源。<li><code>@EnableAutoConfiguration</code> 会告诉框架根据 classpath 上的依赖自动添加 Bean。<li><code>@ComponentScan</code> 会扫描与 Application 类相同包或其子包中的其他配置和 Bean。</ul><p>有了 Spring Boot，就可以使用 Thymeleaf 或 JSP 设置前端，而无需使用定义的 <code>ViewResolver</code>。在 <code>pom.xml</code> 中添加 <code>spring-boot-starter-thymeleaf</code> 依赖后，Thymeleaf 就会启用，无需额外配置。<h3 id=springcloud><a class=headerlink href=#springcloud title=springcloud></a>springcloud</h3><h1 id=日志库><a class=headerlink href=#日志库 title=日志库></a>日志库</h1><h2 id=slf4j✨><a class=headerlink href=#slf4j✨ title=slf4j✨></a>slf4j✨</h2><p><a href=https://logback.qos.ch/apidocs/index.html rel=noopener target=_blank>Overview (Logback-Parent 1.5.15 API)</a><p>SLF4J为各种日志框架（例如 java.util.logging、logback、log4j）提供了一个简单的门面或抽象，允许用户在部署时插入所需的日志框架。<h2 id=logback><a class=headerlink href=#logback title=logback></a>logback</h2><p><a href=https://logback.qos.ch/ rel=noopener target=_blank>Logback Home</a><p>Logback 旨在作为流行的 log4j 项目的继任者，从 log4j 1.x 停止的地方继续发展。<p>Logback 的架构相当通用，以便在不同情况下应用。目前，logback 分为三个模块，分别是 logback-core、logback-classic 和 logback-access。<p>logback -core模块为其他两个模块奠定了基础。logback-classic模块可以看作是 log4j 1.x 的改进版本。此外，logback-classic模块原生实现了 SLF4J API，因此您可以轻松地在logaback和其他日志框架（如 log4j 1.x 或 java.util.logging（JUL））之间切换。<h2 id=log4j><a class=headerlink href=#log4j title=log4j></a>log4j</h2><p><a href=https://logging.apache.org/log4j/2.12.x/ rel=noopener target=_blank>Log4j – Apache Log4j 2 - Apache Log4j 2</a><p>Apache Log4j 2 是 Log4j 的升级版本，在性能上对前一代 Log4j 1.x 进行了显著提升，并提供了许多 Logback 中的改进，同时修复了 Logback 架构中的一些固有缺陷。<h1 id=常用术语><a class=headerlink href=#常用术语 title=常用术语></a>常用术语</h1><p>POJO<p>VO<p>PO<p>DAO<p>DTO<p>BO</p><link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script></div><div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a href=https://www.sekyoro.top/2025/03/09/mini-java-guide/ title=mini-java-guide>https://www.sekyoro.top/2025/03/09/mini-java-guide/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div><footer class=post-footer><div class=post-nav><div class=post-nav-item><a href=/2025/02/27/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ rel=prev title=Linux网络编程入门> <i class="fa fa-chevron-left"></i> Linux网络编程入门 </a></div><div class=post-nav-item><a href=/2025/03/12/TCP-IP%E4%B8%8EHTTP%E7%BC%96%E7%A8%8B/ rel=next title=TCP/IP与HTTP编程> TCP/IP与HTTP编程 <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div><!-- 评论区 --><div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#Java%E5%9F%BA%E7%A1%80><span class=nav-number>1.</span> <span class=nav-text>Java基础</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#Java%E5%9F%BA%E7%A1%80-1><span class=nav-number>1.1.</span> <span class=nav-text>Java基础</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-java-lang><span class=nav-number>1.1.1.</span> <span class=nav-text>1. java.lang.*</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-java-util><span class=nav-number>1.1.2.</span> <span class=nav-text>2. java.util.*</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-java-io><span class=nav-number>1.1.3.</span> <span class=nav-text>3. java.io.*</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-java-nio><span class=nav-number>1.1.4.</span> <span class=nav-text>4. java.nio.*</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#5-java-net><span class=nav-number>1.1.5.</span> <span class=nav-text>5. java.net.*</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#6-java-text><span class=nav-number>1.1.6.</span> <span class=nav-text>6. java.text.*</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#7-java-time><span class=nav-number>1.1.7.</span> <span class=nav-text>7. java.time.*</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#8-%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3><span class=nav-number>1.1.8.</span> <span class=nav-text>8. 并发相关</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#9-%E5%85%B6%E4%BB%96><span class=nav-number>1.1.9.</span> <span class=nav-text>9. 其他</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%86%85%E9%83%A8%E7%B1%BB><span class=nav-number>1.1.10.</span> <span class=nav-text>内部类</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%9B%86%E5%90%88Collection%E4%B8%8EMap><span class=nav-number>1.1.11.</span> <span class=nav-text>集合Collection与Map</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#List><span class=nav-number>1.1.11.0.1.</span> <span class=nav-text>List</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Set><span class=nav-number>1.1.11.0.2.</span> <span class=nav-text>Set</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Map><span class=nav-number>1.1.11.0.3.</span> <span class=nav-text>Map</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%BC%82%E5%B8%B8%E3%80%81%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6><span class=nav-number>1.1.11.1.</span> <span class=nav-text>异常、泛型与集合框架</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%B1%BB><span class=nav-number>1.1.11.2.</span> <span class=nav-text>使用泛型类</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95><span class=nav-number>1.1.11.3.</span> <span class=nav-text>泛型方法</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3><span class=nav-number>1.1.11.4.</span> <span class=nav-text>泛型接口</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0><span class=nav-number>1.1.12.</span> <span class=nav-text>多线程与线程池</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86><span class=nav-number>1.1.13.</span> <span class=nav-text>反射、注解与动态代理</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#ClassLoader><span class=nav-number>1.1.13.1.</span> <span class=nav-text>ClassLoader</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8A%A0%E8%BD%BD%E5%99%A8><span class=nav-number>1.1.13.2.</span> <span class=nav-text>线程上下文加载器</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#JVM><span class=nav-number>1.2.</span> <span class=nav-text>JVM</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6><span class=nav-number>1.2.1.</span> <span class=nav-text>垃圾回收</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95><span class=nav-number>1.2.1.1.</span> <span class=nav-text>引用计数法</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95><span class=nav-number>1.2.1.2.</span> <span class=nav-text>可达性分析算法</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95><span class=nav-number>1.2.1.3.</span> <span class=nav-text>回收算法</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#JUC><span class=nav-number>1.3.</span> <span class=nav-text>JUC</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86><span class=nav-number>2.</span> <span class=nav-text>项目管理</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#Maven%E2%9C%A8><span class=nav-number>2.1.</span> <span class=nav-text>Maven✨</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86><span class=nav-number>2.1.1.</span> <span class=nav-text>依赖管理</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86><span class=nav-number>2.1.2.</span> <span class=nav-text>插件管理</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%85%83%E7%B4%A0><span class=nav-number>2.1.3.</span> <span class=nav-text>其他常用元素</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F><span class=nav-number>2.1.4.</span> <span class=nav-text>生命周期</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%93%E5%BA%93><span class=nav-number>2.1.5.</span> <span class=nav-text>仓库</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4><span class=nav-number>2.1.6.</span> <span class=nav-text>常用命令</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%95%B0%E6%8D%AE%E5%BA%93><span class=nav-number>3.</span> <span class=nav-text>数据库</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#MySQL%E2%9C%A8><span class=nav-number>3.1.</span> <span class=nav-text>MySQL✨</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BA%8B%E5%8A%A1><span class=nav-number>3.1.0.1.</span> <span class=nav-text>事务</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98><span class=nav-number>3.1.0.1.1.</span> <span class=nav-text>事务并发问题</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#%E8%84%8F%E8%AF%BB><span class=nav-number>3.1.0.1.1.1.</span> <span class=nav-text>脏读</span></a><li class="nav-item nav-level-6"><a class=nav-link href=#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB><span class=nav-number>3.1.0.1.1.2.</span> <span class=nav-text>不可重复读</span></a><li class="nav-item nav-level-6"><a class=nav-link href=#%E5%B9%BB%E8%AF%BB><span class=nav-number>3.1.0.1.1.3.</span> <span class=nav-text>幻读</span></a></ol><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB><span class=nav-number>3.1.0.1.2.</span> <span class=nav-text>事务隔离级别</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E><span class=nav-number>3.1.0.2.</span> <span class=nav-text>存储引擎</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#PostgresSQL><span class=nav-number>3.2.</span> <span class=nav-text>PostgresSQL</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#MongoDB><span class=nav-number>3.3.</span> <span class=nav-text>MongoDB</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6><span class=nav-number>4.</span> <span class=nav-text>持久层框架</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#Mybatis%E2%9C%A8><span class=nav-number>4.1.</span> <span class=nav-text>Mybatis✨</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%9F%A5%E8%AF%A2%E5%8D%95%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B><span class=nav-number>4.1.1.</span> <span class=nav-text>查询单表数据整体流程</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BD%BF%E7%94%A8Mapper%E4%BB%A3%E7%90%86%E5%BC%80%E5%8F%91><span class=nav-number>4.1.2.</span> <span class=nav-text>使用Mapper代理开发</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#properties><span class=nav-number>4.1.3.</span> <span class=nav-text>properties</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#settings><span class=nav-number>4.1.4.</span> <span class=nav-text>settings</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#TypeAliases><span class=nav-number>4.1.5.</span> <span class=nav-text>TypeAliases</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#typehandlers><span class=nav-number>4.1.6.</span> <span class=nav-text>typehandlers</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%8F%92%E4%BB%B6%EF%BC%88plugins%EF%BC%89><span class=nav-number>4.1.7.</span> <span class=nav-text>插件（plugins）</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#xml%E6%98%A0%E5%B0%84%E5%99%A8><span class=nav-number>4.1.8.</span> <span class=nav-text>xml映射器</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8F%82%E6%95%B0%E6%98%A0%E5%B0%84><span class=nav-number>4.1.9.</span> <span class=nav-text>参数映射</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84><span class=nav-number>4.1.10.</span> <span class=nav-text>结果映射</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8A%A8%E6%80%81SQL><span class=nav-number>4.1.11.</span> <span class=nav-text>动态SQL</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Hibernate><span class=nav-number>4.2.</span> <span class=nav-text>Hibernate</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#Spring-Data-JPA><span class=nav-number>4.3.</span> <span class=nav-text>Spring Data JPA</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%B6%88%E6%81%AF%E7%BB%84%E4%BB%B6><span class=nav-number>5.</span> <span class=nav-text>消息组件</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#Redis%E2%9C%A8><span class=nav-number>5.1.</span> <span class=nav-text>Redis✨</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C><span class=nav-number>5.1.1.</span> <span class=nav-text>基本操作</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B><span class=nav-number>5.1.2.</span> <span class=nav-text>数据类型</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#String><span class=nav-number>5.1.2.1.</span> <span class=nav-text>String</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#List-1><span class=nav-number>5.1.2.2.</span> <span class=nav-text>List</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Set-1><span class=nav-number>5.1.2.3.</span> <span class=nav-text>Set</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#ZSet><span class=nav-number>5.1.2.4.</span> <span class=nav-text>ZSet</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Hash><span class=nav-number>5.1.2.5.</span> <span class=nav-text>Hash</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F><span class=nav-number>5.1.3.</span> <span class=nav-text>缓存穿透</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%BC%93%E5%AD%98%E7%A9%BA%E5%AF%B9%E8%B1%A1><span class=nav-number>5.1.3.1.</span> <span class=nav-text>缓存空对象</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4><span class=nav-number>5.1.3.2.</span> <span class=nav-text>布隆过滤</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9><span class=nav-number>5.1.4.</span> <span class=nav-text>缓存雪崩</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88><span class=nav-number>5.1.4.1.</span> <span class=nav-text>解决方案</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF><span class=nav-number>5.1.5.</span> <span class=nav-text>缓存击穿</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1><span class=nav-number>5.1.5.1.</span> <span class=nav-text>解决方案</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%86%85%E5%AD%98%E6%8C%81%E4%B9%85%E5%8C%96><span class=nav-number>5.1.6.</span> <span class=nav-text>内存持久化</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#RDB><span class=nav-number>5.1.6.1.</span> <span class=nav-text>RDB</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#AOF><span class=nav-number>5.1.6.2.</span> <span class=nav-text>AOF</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BA%8B%E5%8A%A1-1><span class=nav-number>5.1.7.</span> <span class=nav-text>事务</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#RabbitMQ%E2%9C%A8><span class=nav-number>5.2.</span> <span class=nav-text>RabbitMQ✨</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#Kafka><span class=nav-number>5.3.</span> <span class=nav-text>Kafka</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#RocketMQ><span class=nav-number>5.4.</span> <span class=nav-text>RocketMQ</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6><span class=nav-number>6.</span> <span class=nav-text>网络编程框架</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#Netty><span class=nav-number>6.1.</span> <span class=nav-text>Netty</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#Spring%E5%AE%B6%E6%97%8F%E2%9C%A8><span class=nav-number>7.</span> <span class=nav-text>Spring家族✨</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#spring><span class=nav-number>7.1.</span> <span class=nav-text>spring</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#IOC%E5%AE%B9%E5%99%A8><span class=nav-number>7.1.1.</span> <span class=nav-text>IOC容器</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5><span class=nav-number>7.1.1.1.</span> <span class=nav-text>构造器注入</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95><span class=nav-number>7.1.1.2.</span> <span class=nav-text>静态工厂方法</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95><span class=nav-number>7.1.1.3.</span> <span class=nav-text>实例工厂方法</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%90%8E%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7><span class=nav-number>7.1.1.4.</span> <span class=nav-text>实例化后设置属性</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%B3%A8%E8%A7%A3Annotation%E9%85%8D%E7%BD%AE><span class=nav-number>7.1.1.5.</span> <span class=nav-text>注解Annotation配置</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BD%BF%E7%94%A8Java%E9%85%8D%E7%BD%AE%E7%B1%BB><span class=nav-number>7.1.1.6.</span> <span class=nav-text>使用Java配置类</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Bean%E7%9A%84%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86><span class=nav-number>7.1.1.7.</span> <span class=nav-text>Bean的声明周期管理</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%80%89%E6%8B%A9%E6%80%A7%E5%AE%9E%E4%BE%8B%E5%8C%96Bean><span class=nav-number>7.1.1.8.</span> <span class=nav-text>选择性实例化Bean</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5><span class=nav-number>7.1.2.</span> <span class=nav-text>如何实现依赖注入</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#AOP%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86><span class=nav-number>7.1.3.</span> <span class=nav-text>AOP的底层原理</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1><span class=nav-number>7.1.4.</span> <span class=nav-text>如何管理事务</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96><span class=nav-number>7.1.5.</span> <span class=nav-text>如何处理循环依赖</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F><span class=nav-number>7.1.6.</span> <span class=nav-text>代理模式</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#springmvc><span class=nav-number>7.1.6.1.</span> <span class=nav-text>springmvc</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#springboot><span class=nav-number>7.2.</span> <span class=nav-text>springboot</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#springcloud><span class=nav-number>7.2.1.</span> <span class=nav-text>springcloud</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%97%A5%E5%BF%97%E5%BA%93><span class=nav-number>8.</span> <span class=nav-text>日志库</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#slf4j%E2%9C%A8><span class=nav-number>8.1.</span> <span class=nav-text>slf4j✨</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#logback><span class=nav-number>8.2.</span> <span class=nav-text>logback</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#log4j><span class=nav-number>8.3.</span> <span class=nav-text>log4j</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD><span class=nav-number>9.</span> <span class=nav-text>常用术语</span></a></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>236</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>16</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>211</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a><li class=links-of-blogroll-item><a href=https://www.lllomh.com/ rel=noopener target=_blank title=https://www.lllomh.com/>芈渡</a><li class=links-of-blogroll-item><a href=https://protool-ten.vercel.app/ rel=noopener target=_blank title=https://protool-ten.vercel.app/>protools</a></ul></div><div class="motion-element announcement"><div class=title></div><p class=content><p class=date></div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>此文章目前无词云</h3></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2025</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>2.4m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>37:01</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer></div><script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script><script src=/lib/anime.min.js></script><script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script><script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/pisces.js></script><script src=/js/next-boot.js></script><script src=/js/bookmark.js></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	'.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script><script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script><script src=/js/algolia-search.js></script><script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script><div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div><script charset=utf-8 defer src=/js/tagcanvas.js></script><script charset=utf-8 defer src=/js/tagcloud.js></script><script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script><script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script><script src=/js/src/activate-power-mode.min.js></script><script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script>
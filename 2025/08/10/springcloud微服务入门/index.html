<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"0F9LEEVW82","apiKey":"78839e9f9be09d081c5c4da81975cd19","indexName":"sekyoblog_sec","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content="单体架构将业务所有功能集中在一个项目开发,通过打成一个包部署. 架构简单,部署成本低.但是功能之间耦合度高,而分布式架构根据业务功能对系统进行拆分,每个业务模块作为独立项目开发,有利于降低服务耦合以及服务拓展." name=description><meta content=article property=og:type><meta content=springcloud微服务入门 property=og:title><meta content=https://www.sekyoro.top/2025/08/10/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content="单体架构将业务所有功能集中在一个项目开发,通过打成一个包部署. 架构简单,部署成本低.但是功能之间耦合度高,而分布式架构根据业务功能对系统进行拆分,每个业务模块作为独立项目开发,有利于降低服务耦合以及服务拓展." property=og:description><meta content=zh_CN property=og:locale><meta content=https://cdn.xiaolincoding.com//picgo/1728721036831-d9c8124c-b9ac-4490-92c6-2e52e5636c55.png property=og:image><meta content=https://s2.loli.net/2025/08/10/zQ5VyrXtv1Gmd2B.png property=og:image><meta content=https://cdn.xiaolincoding.com//picgo/1714660128964-c3acea75-3a80-427b-aafa-8d75d2672532.png property=og:image><meta content=https://cdn.xiaolincoding.com//picgo/1714660725465-d851112c-47c6-4fa1-a383-8433555fbefb.png property=og:image><meta content=https://cdn.xiaolincoding.com//picgo/1714660846185-84b51249-3360-43d1-ab85-682094db87fc.png property=og:image><meta content=https://cdn.xiaolincoding.com//picgo/1714660900451-b154db6e-dfdf-4580-88db-2ae25bf03b69.png property=og:image><meta content=https://cdn.xiaolincoding.com//picgo/1714661434275-d83c23d2-26c7-4415-af6a-5a71d9ea0e40.png property=og:image><meta content=https://cdn.xiaolincoding.com//picgo/1741335422453-5a93e24e-d9a4-49c9-9ae8-170e7db0e387.png property=og:image><meta content=https://cdn.xiaolincoding.com//picgo/1741335463759-7880ff38-4280-47c9-ac37-a0acbaedc6c3.png property=og:image><meta content=https://cdn.xiaolincoding.com//picgo/1741336124270-c0328978-0eed-4409-bc42-dfaddf10a373.png property=og:image><meta content=https://cdn.xiaolincoding.com//picgo/1715933382453-968d55a3-059b-423d-9f67-0ebf732fc400.png property=og:image><meta content=https://s2.loli.net/2025/08/10/voKC1ztFXBRIeh5.png property=og:image><meta content=https://s2.loli.net/2025/08/10/NHRvX86mQrnxDpK.png property=og:image><meta content=https://s2.loli.net/2025/08/10/59dSqPhXMoQ8cvD.png property=og:image><meta content=https://s2.loli.net/2025/08/10/t7QDqlGs6oMVf9d.png property=og:image><meta content=https://s2.loli.net/2025/08/10/xCJktiVqD9IcgwK.png property=og:image><meta content=https://s2.loli.net/2025/08/10/SYjCDIFQaGe9knP.png property=og:image><meta content=https://s2.loli.net/2025/08/10/Gf9Dq8rRAU76p5g.png property=og:image><meta content=https://s2.loli.net/2025/08/10/9X4fNq7vQOpzsDl.png property=og:image><meta content=https://s2.loli.net/2025/08/10/cinjxrXePTu4ymS.png property=og:image><meta content=https://s2.loli.net/2025/08/10/4jGMJozcUObNIyV.png property=og:image><meta content=https://s2.loli.net/2025/08/10/v4KsJwcHV3GxQIO.png property=og:image><meta content=https://s2.loli.net/2025/08/10/NAzKq1UZCvfTFBs.png property=og:image><meta content=https://s2.loli.net/2025/08/10/K2ILHxDQukbj1Mg.png property=og:image><meta content=https://s2.loli.net/2025/08/10/QN5KFwRfBvVZcpJ.png property=og:image><meta content=https://s2.loli.net/2025/08/10/bc8Kkw3iOYqrHS2.png property=og:image><meta content=https://s2.loli.net/2025/08/10/clsJUIbdZzFCX3f.png property=og:image><meta content=https://s2.loli.net/2025/08/10/C3GAh9LzBwYSxOX.png property=og:image><meta content=https://s2.loli.net/2025/08/10/fK2CXIRe58SPQjt.png property=og:image><meta content=https://s2.loli.net/2025/08/10/OKEenToSQI31jBH.png property=og:image><meta content=2025-08-10T04:39:18.000Z property=article:published_time><meta content=2025-09-11T00:57:52.971Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content=springcloud property=article:tag><meta content=summary name=twitter:card><meta content=https://cdn.xiaolincoding.com//picgo/1728721036831-d9c8124c-b9ac-4490-92c6-2e52e5636c55.png name=twitter:image><link href=https://www.sekyoro.top/2025/08/10/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>springcloud微服务入门 | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2025/08/10/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>springcloud微服务入门</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2025-08-10 12:39:18" datetime=2025-08-10T12:39:18+08:00>2025-08-10</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-09-11 08:57:52" datetime=2025-09-11T08:57:52+08:00 itemprop=dateModified>2025-09-11</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>15k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>14 分钟</span> </span></div></header><div class=post-body itemprop=articleBody><p>单体架构将业务所有功能集中在一个项目开发,通过打成一个包部署. 架构简单,部署成本低.但是功能之间耦合度高,而<strong>分布式架构根据业务功能对系统进行拆分,每个业务模块作为独立项目开发,有利于降低服务耦合以及服务拓展</strong>.<br><span id=more></span><h1 id=分布式><a class=headerlink href=#分布式 title=分布式></a>分布式</h1><p>事务可以看作一次大的活动,可以有不同的小活动组成,这些活动要么全部成功,要么全部失败.<p>而在计算机系统中更多通过数据库来控制事务,利用数据库本身事务特性来实现,数据库通常和应用在同一个服务器,因此这种叫做本地事务. 事务本身特性ACID,原子性,一致性,隔离性与持久性.<h2 id=分布式理论><a class=headerlink href=#分布式理论 title=分布式理论></a>分布式理论</h2><p>CAP理论是分布式系统中最基础也是最重要的理论之一。它指出，一个分布式系统<strong>不可能同时满足</strong>以下三个条件：<ul><li><strong>一致性（Consistency）</strong>：所有节点在同一时间看到的数据都是一致的。<li><strong>可用性（Availability）</strong>：系统在面对部分节点失效时，仍能对外提供服务。<li><strong>分区容错性（Partition Tolerance）</strong>：系统在网络分区（节点之间无法通信）发生时，仍能正常运行。</ul><p><strong>关键点</strong>：在分布式系统中，<strong>分区容错性是必须满足的</strong>。因为网络不可靠，随时可能发生分区。因此，在实践中，你只能在 <strong>C 和 A 之间进行取舍</strong>：<ul><li><strong>CP 系统</strong>：<strong>优先保证一致性，牺牲可用性。在网络分区时，为了保证数据一致，系统会停止服务</strong>。例如，ZooKeeper、etcd。<li><strong>AP 系统</strong>：优先保证可用性，牺牲一致性<strong>。在网络分区时，系统依然对外提供服务，但可能返回不一致的数据</strong>。例如，Cassandra、DynamoDB。</ul><p>BASE 理论是 CAP 理论中 AP 系统的延伸，是针对大型互联网应用提出的。它是一种在牺牲强一致性的情况下，追求高可用性的思想。<ul><li><strong>基本可用（Basically Available）</strong>：系统可以有部分功能降级，允许在网络分区时牺牲部分非核心功能，但核心功能要保持可用。<li><strong>软状态（Soft State）</strong>：允许系统中的数据存在中间状态，这个中间状态不影响系统正常工作。<li><strong>最终一致性（Eventually Consistent）</strong>：系统中的数据可能在一段时间内是不一致的，但最终会达到一致状态。</ul><p><strong>关键点</strong>：BASE 理论是许多分布式系统的设计基础，特别是在对性能和可用性要求极高的场景中。例如，电商的购物车、社交媒体的好友列表，都可以在短时间内允许数据不一致，最终同步。<h2 id=分布式锁><a class=headerlink href=#分布式锁 title=分布式锁></a>分布式锁</h2><p>分布式锁是用于分布式环境下并发控制的一种机制，用于控制某个资源在同一时刻只能被一个应用所使用。<p>Redis 本身可以被多个客户端共享访问，正好就是一个共享存储系统，可以用来保存分布式锁，而且 Redis 的读写性能高，可以应对高并发的锁操作场景。Redis 的 SET 命令有个 NX 参数可以实现「key不存在才插入」，所以可以用它来实现分布式锁：<ul><li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；<li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</ul><p>基于 Redis 节点实现分布式锁时，对于加锁操作，我们需要满足三个条件。<ul><li>加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的方式完成，所以，我们使用 SET 命令带上 NX 选项来实现加锁；<li>锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以，我们在 SET 命令执行时加上 EX/PX 选项，设置其过期时间；<li>锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作，所以，我们使用 SET 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端；</ul><p>满足这三个条件的分布式命令如下：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>SET lock_key unique_value NX PX 10000</span><br></pre></table></figure><ul><li>lock_key 就是 key 键；<li>unique_value 是客户端生成的唯一的标识，区分来自不同客户端的锁操作；<li>NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；<li>PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。</ul><p>而解锁的过程就是将 lock_key 键删除（del lock_key），但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以，解锁的时候，我们要先判断锁的 unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除。<p>可以看到，解锁是有两个操作，这时就需要 Lua 脚本来保证解锁的原子性，因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。<figure class="highlight lua"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放</span><br><span class=line><span class=keyword>if</span> redis.call(<span class=string>"get"</span>,KEYS[<span class=number>1</span>]) == ARGV[<span class=number>1</span>] <span class=keyword>then</span></span><br><span class=line>  <span class=keyword>return</span> redis.call(<span class=string>"del"</span>,KEYS[<span class=number>1</span>])</span><br><span class=line><span class=keyword>else</span></span><br><span class=line>  <span class=keyword>return</span> <span class=number>0</span></span><br><span class=line><span class=keyword>end</span></span><br></pre></table></figure><p>这样一来，就通过使用 SET 命令和 Lua 脚本在 Redis 单节点上完成了分布式锁的加锁和解锁。<p>还可以<strong>基于zookeeper来实现分布式</strong>。<p>zookeeper是一个<strong>为分布式应用提供一致性服务的软件，它内部是一个分层的文件系统目录树结构，规定统一个目录下只能有一个唯一文件名。</strong><p>数据模型：<ul><li>永久节点：<strong>节点创建后，不会因为会话失效而消失</strong><li>临时节点：<strong>与永久节点相反，如果客户端连接失效，则立即删除节点</strong><li>顺序节点：与上述两个节点特性类似，如果指定创建这类节点时，zk会自动在节点名后加一个数字后缀，并且是有序的。</ul><p>监视器（watcher）：<ul><li><strong>当创建一个节点时，可以注册一个该节点的监视器，当节点状态发生改变时，watch被触发时，ZooKeeper将会向客户端发送且仅发送一条通知</strong>，因为watch只能被触发一次。</ul><p>利用Zookeeper的临时顺序节点和监听机制两大特性，可以帮助我们实现分布式锁。<p><img alt=img data-src=https://cdn.xiaolincoding.com//picgo/1728721036831-d9c8124c-b9ac-4490-92c6-2e52e5636c55.png><ul><li>首先得有一个持久节点<code>/locks</code>, 路径服务于某个使用场景，如果有多个使用场景建议路径不同。<li>请求进来时首先在<code>/locks</code>创建临时有序节点，所有会看到在<code>/locks</code>下面有seq-000000000, seq-00000001 等等节点。<li>然后判断当前创建得节点是不是<code>/locks</code>路径下面最小的节点，如果是，获取锁，不是，阻塞线程，同时设置监听器，监听前一个节点。<li>获取到锁以后，开始处理业务逻辑，最后delete当前节点，表示释放锁。<li>后一个节点就会收到通知，唤起线程，重复上面的判断。</ul><p>zookerper 实现的分布式锁是强一致性的，<strong>因为它底层的 ZAB协议(原子广播协议), 天然满足 CP，</strong>但是这也意味着性能的下降, 所以不站在具体数据下看 Redis 和 Zookeeper, 代表着性能和一致性的取舍。<p>如果项目没有强依赖 ZK, 使用 Redis 就好了, 因为现在 Redis 用途很广, 大部分项目中都引用了 Redis，没必要对此再引入一个新的组件, 如果业务场景对于 Redis 异步方式的同步数据造成锁丢失无法忍受, 在业务层处理就好了<h2 id=分布式事务><a class=headerlink href=#分布式事务 title=分布式事务></a>分布式事务</h2><p>分布式系统会把一个应用系统拆分为独立部署的多个服务,因此需要服务之间远程协作才能完成事务操作,这种分布式系统环境下由不同服务之间通过网络远程协作完成事务称之为分布式事务.<p>分布式事务最大问题是各个子事务的一致性问题,通过CAP定理和BASE理论<p>AP模式:各个子事务分别执行和提交,允许出现结果不一致,然后<strong>采用弥补措施</strong>恢复数据,实现<strong>最终一致性</strong><p>CP模式: <strong>各个子事务执行后互相等待,同时提交,同时回滚,达成强一致性</strong>.但事务等待过程中会出现弱可用状态.<p>解决分布式事务,各个子系统之间必须能感知到彼此的事务状态,才能保证状态一致. 因此需要一个事务协调者来协调每个事务的参与者(子系统事务,分支事务). 有关联的各个分支事务在一起称为全局事务<p><img alt=image-20250810202942753 data-src=https://s2.loli.net/2025/08/10/zQ5VyrXtv1Gmd2B.png><h2 id=分布式限流算法><a class=headerlink href=#分布式限流算法 title=分布式限流算法></a>分布式限流算法</h2><ul><li><strong>滑动窗口限流算法</strong>是对固定窗口限流算法的改进，有效解决了窗口切换时可能会产生两倍于阈值流量请求的问题。<li><strong>漏桶限流算法</strong>能够对流量起到整流的作用，让随机不稳定的流量以固定的速率流出，但是不能解决<strong>流量突发</strong>的问题。<li><strong>令牌桶算法</strong>作为漏斗算法的一种改进，除了能够起到平滑流量的作用，还允许一定程度的流量突发。</ul><blockquote><p>固定窗口限流算法</blockquote><p>固定窗口限流算法就是对一段固定时间窗口内的请求进行计数，如果请求数超过了阈值，则舍弃该请求；如果没有达到设定的阈值，则接受该请求，且计数加1。当时间窗口结束时，重置计数器为0。<p><img alt=img data-src=https://cdn.xiaolincoding.com//picgo/1714660128964-c3acea75-3a80-427b-aafa-8d75d2672532.png><p>固定窗口限流优点是实现简单，但是会有“流量吐刺”的问题，假设窗口大小为1s，限流大小为100，然后恰好在某个窗口的第999ms来了100个请求，窗口前期没有请求，所以这100个请求都会通过。再恰好，下一个窗口的第1ms有来了100个请求，也全部通过了，那也就是在2ms之内通过了200个请求，而我们设定的阈值是100，通过的请求达到了阈值的两倍，这样可能会给系统造成巨大的负载压力。<p><img alt=img data-src=https://cdn.xiaolincoding.com//picgo/1714660725465-d851112c-47c6-4fa1-a383-8433555fbefb.png><blockquote><p>滑动窗口限流算法</blockquote><p>改进固定窗口缺陷的方法是采用滑动窗口限流算法，滑动窗口就是将限流窗口内部切分成一些更小的时间片，然后在时间轴上滑动，每次滑动，滑过一个小时间片，就形成一个新的限流窗口，即滑动窗口。然后在这个滑动窗口内执行固定窗口算法即可。<p>滑动窗口可以避免固定窗口出现的放过两倍请求的问题，因为一个短时间内出现的所有请求必然在一个滑动窗口内，所以一定会被滑动窗口限流。<p><img alt=img data-src=https://cdn.xiaolincoding.com//picgo/1714660846185-84b51249-3360-43d1-ab85-682094db87fc.png><blockquote><p>漏桶限流算法</blockquote><p>漏桶限流算法是模拟水流过一个有漏洞的桶进而限流的思路，如图。<p><img alt=img data-src=https://cdn.xiaolincoding.com//picgo/1714660900451-b154db6e-dfdf-4580-88db-2ae25bf03b69.png><p>水龙头的水先流入漏桶，再通过漏桶底部的孔流出。如果流入的水量太大，底部的孔来不及流出，就会导致水桶太满溢出去。<p>从系统的角度来看，我们不知道什么时候会有请求来，也不知道请求会以多大的速率来，这就给系统的安全性埋下了隐患。但是如果加了一层漏斗算法限流之后，就能够保证请求以恒定的速率流出。在系统看来，请求永远是以平滑的传输速率过来，从而起到了保护系统的作用。<p>使用漏桶限流算法，缺点有两个：<ul><li>即使系统资源很空闲，多个请求同时到达时，漏桶也是慢慢地一个接一个地去处理请求，这其实并不符合人们的期望，因为这样就是在浪费计算资源。<li>不能解决流量突发的问题，假设漏斗速率是2个/秒，然后突然来了10个请求，受限于漏斗的容量，只有5个请求被接受，另外5个被拒绝。你可能会说，漏斗速率是2个/秒，然后瞬间接受了5个请求，这不就解决了流量突发的问题吗？不，这5个请求只是被接受了，但是没有马上被处理，处理的速度仍然是我们设定的2个/秒，所以没有解决流量突发的问题</ul><blockquote><p>令牌桶限流算法</blockquote><p>令牌桶是另一种桶限流算法，模拟一个特定大小的桶，然后向桶中以特定的速度放入令牌（token），请求到达后，必须从桶中取出一个令牌才能继续处理。如果桶中已经没有令牌了，那么当前请求就被限流。如果桶中的令牌放满了，令牌桶也会溢出。<p>放令牌的动作是持续不断进行的，如果桶中令牌数达到上限，则丢弃令牌，因此桶中可能一直持有大量的可用令牌。此时请求进来可以直接拿到令牌执行。比如设置 qps 为 100，那么限流器初始化完成 1 秒后，桶中就已经有 100 个令牌了，如果此前还没有请求过来，这时突然来了 100 个请求，该限流器可以抵挡瞬时的 100 个请求。由此可见，只有桶中没有令牌时，请求才会进行等待，最终表现的效果即为以一定的速率执行。令牌桶的示意图如下：<p><img alt=img data-src=https://cdn.xiaolincoding.com//picgo/1714661434275-d83c23d2-26c7-4415-af6a-5a71d9ea0e40.png><p>令牌桶限流算法综合效果比较好，能在最大程度利用系统资源处理请求的基础上，实现限流的目标，建议通常场景中优先使用该算法。<h2 id=分布式一致性算法><a class=headerlink href=#分布式一致性算法 title=分布式一致性算法></a>分布式一致性算法</h2><p>Raft与Paxos<p>Raft 和 Paxos 是两种经典的分布式一致性算法，旨在实现<strong>多节点状态机的高可靠一致性</strong>。两者核心目标相同（保证分布式系统数据一致性），但设计理念和实现方式有区别。<blockquote><p>raft 协议的原理</blockquote><p>Raft算法由leader节点来处理一致性问题。leader节点接收来自客户端的请求日志数据，然后同步到集群中其它节点进行复制，当日志已经同步到超过半数以上节点的时候，leader节点再通知集群中其它节点哪些日志已经被复制成功，可以提交到raft状态机中执行。<p>通过以上方式，Raft算法将要解决的一致性问题分为了以下几个子问题。<ul><li>leader选举：集群中必须存在一个leader节点。<li>日志复制：leader节点接收来自客户端的请求然后将这些请求序列化成日志数据再同步到集群中其它节点。<li>安全性：如果某个节点已经将一条提交过的数据输入raft状态机执行了，那么其它节点不可能再将相同索引 的另一条日志数据输入到raft状态机中执行。</ul><p>Raft算法需要有两个比较重要的机制<ul><li><strong>角色转换与选举机制</strong>：Raft 将系统中的节点分为三种角色：领导者（Leader）、跟随者（Follower）和候选人（Candidate）。系统启动时，所有节点都是跟随者。跟随者会定期从领导者处接收心跳信息以确认领导者的存活。如果跟随者在一段时间内（选举超时时间）没有收到领导者的心跳，它会转变为候选人，发起新一轮的选举。候选人向其他节点发送请求投票消息。其他节点根据收到的请求投票消息，决定是否为该候选人投票。当候选人获得超过半数节点的投票时，它就成为新的领导者。领导者会周期性地向所有跟随者发送心跳消息，以维持自己的领导地位。每个领导者的领导周期称为一个任期（Term），任期号是单调递增的。</ul><p><img alt=img data-src=https://cdn.xiaolincoding.com//picgo/1741335422453-5a93e24e-d9a4-49c9-9ae8-170e7db0e387.png><ul><li><strong>日志复制机制</strong>：客户端的请求会被领导者作为日志条目添加到自己的日志中。领导者将新的日志条目复制到其他跟随者节点。它会通过附加日志消息将日志条目发送给跟随者，跟随者收到消息后会将日志条目追加到自己的日志中，并向领导者发送确认消息。当领导者得知某个日志条目已经被大多数节点复制时，它会将该日志条目标记为已提交，并将其应用到状态机中。然后，领导者会通知其他节点该日志条目已提交，跟随者也会将已提交的日志条目应用到自己的状态机中。</ul><p><img alt=img data-src=https://cdn.xiaolincoding.com//picgo/1741335463759-7880ff38-4280-47c9-ac37-a0acbaedc6c3.png><blockquote><p>paxos协议的原理</blockquote><p>Paxos算法的核心思想是将一致性问题分解为多个阶段，每个阶段都有一个专门的协议来处理。Paxos算法的主要组成部分包括提议者（Proposer）、接受者（Acceptor）和投票者（Voter）。<ul><li>提议者：提议者是负责提出一致性问题的节点，它会向接受者发送提议，并等待接受者的回复。<li>接受者：接受者是负责处理提议的节点，它会接收提议者发送的提议，并对提议进行判断。如果接受者认为提议是有效的，它会向投票者发送请求，并等待投票者的回复。<li>投票者：投票者是负责决定提议是否有效的节点，它会接收接受者发送的请求，并对请求进行判断。如果投票者认为请求是有效的，它会向接受者发送投票，表示支持或反对提议。</ul><p><img alt=img data-src=https://cdn.xiaolincoding.com//picgo/1741336124270-c0328978-0eed-4409-bc42-dfaddf10a373.png><p>Paxos算法的流程如下（以Basic Paxos 算法为例子）：<ul><li>准备阶段：提议者选择一个提案编号，并向所有接受者发送准备请求。提案编号是一个全局唯一的、单调递增的数字。接受者收到准备请求后，如果提案编号大于它之前接受过的任何提案编号，它会承诺不再接受编号小于该提案编号的提案，并返回它之前接受过的最大编号的提案信息（如果有）。<li>接受阶段：如果提议者收到了超过半数接受者的响应，它会根据这些响应确定要提议的值。如果接受者返回了之前接受过的提案信息，提议者会选择编号最大的提案中的值作为要提议的值；如果没有，提议者可以选择自己的值。提议者向所有接受者发送接受请求，包含提案编号和要提议的值。<li>学习阶段：当提议者收到超过半数接受者对某个提案的接受响应时，该提案被认为达成共识。学习者通过接受者的通知得知达成共识的值。</ul><p>对比总结<ul><li><strong>Raft</strong> 更易于理解和实现，它将共识过程分解为选举和日志复制两个相对独立的子问题，并且对选举超时时间等参数进行了明确的定义和限制，降低了算法的复杂度。<li><strong>Paxos</strong> 是一种更通用、更基础的共识算法，它的理论性更强，在学术界有广泛的研究和应用。但 Paxos 的实现相对复杂，理解和调试难度较大。</ul><h2 id=微服务><a class=headerlink href=#微服务 title=微服务></a>微服务</h2><p>单体架构特点:简单方便,<strong>利于部署,高度耦合</strong>,扩展性差<p>分布式架构:<strong>松耦合,扩展性好</strong>,但架构复杂<p>微服务是一种良好架构设计的分布式架构方案,微服务架构特征:<ul><li>单一职责: 微服务拆分粒度更小,每个服务对应唯一的业务能力,做到单一职责,避免重复业务开发.<li>面向服务:对外暴露业务接口<li>自治:部署独立、数据独立、技术独立<li>隔离性强:服务调用做好隔离、容错、降级,避免出现级联问题</ul><h3 id=微服务结构><a class=headerlink href=#微服务结构 title=微服务结构></a>微服务结构</h3><p><img style="zoom: 67%;" alt=img data-src=https://cdn.xiaolincoding.com//picgo/1715933382453-968d55a3-059b-423d-9f67-0ebf732fc400.png><p>需要<strong>注册中心</strong>注册并管理服务<strong>,配置中心</strong>对服务进行集中配置,服务之间的远程调用,<strong>API服务网关</strong>进行处理请求与路由,<strong>负载均衡</strong>用于将网络流量有效地分配到多个服务实例上，以优化资源利用、最大化吞吐量并避免任何单一实例过载,以及<strong>服务监控与保护</strong>,对系统进行链路保护，避免服务雪崩的问题<p>具体微服务框架包括Dubbo,<strong>SpringCloud</strong>,SpringCloudAlibaba.<p><img alt=image-20250810133810872 data-src=https://s2.loli.net/2025/08/10/voKC1ztFXBRIeh5.png><p>Spring Boot是用于构建单个Spring应用的框架，而Spring Cloud则是用于构建分布式系统中的微服务架构的工具，Spring Cloud提供了服务注册与发现、负载均衡、断路器、网关等功能。<p><strong>服务拆分</strong><ul><li>单一职责,不同微服务,不要重复开发相同业务<li>微服务数据独立,不要访问其他微服务的数据库<li>微服务将自己的业务暴露为接口供其他微服务调用</ul><h3 id=注册中心><a class=headerlink href=#注册中心 title=注册中心></a>注册中心</h3><p>常用的注册中心组件包括Eureka以及Nacos.<p>在Eureka中,微服务角色分为eureka server和sureka client,后者分为服务提供者和服务消费者.<p><strong>消费者如何找到服务提供者</strong>,<strong>如何从多个服务进行选择</strong>,<strong>如何知道该服务提供者是否仍可用</strong><p>服务提供者启动时会像服务中心注册自身信息,服务中心会保存这些信息,消费者根据服务名称向服务中心拉取提供者信息.服务消费者利用负载均衡算法从服务列表中挑选一个.<p>服务提供者每过一段时间向Eureka Server发送心跳请求报告健康状态,然后Eureka更新记录服务列表的信息,心跳不正常会被剔除,消费者就能拉取到最新的信息.<h3 id=Eureka><a class=headerlink href=#Eureka title=Eureka></a>Eureka</h3><h4 id=服务注册><a class=headerlink href=#服务注册 title=服务注册></a>服务注册</h4><p>引入相关stater,创建eureka-server,进行配置服务端口和对应地址信息<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!--eureka服务端--></span></span><br><span class=line>    <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>        <span class=tag><<span class=name>groupId</span>></span>org.springframework.cloud<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>artifactId</span>></span>spring-cloud-starter-netflix-eureka-server<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=attr>server:</span></span><br><span class=line>  <span class=attr>port:</span> <span class=number>10086</span> <span class=comment># 服务端口</span></span><br><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>application:</span></span><br><span class=line>    <span class=attr>name:</span> <span class=string>eurekaserver</span> <span class=comment># eureka的服务名称</span></span><br><span class=line><span class=attr>eureka:</span></span><br><span class=line>  <span class=attr>client:</span></span><br><span class=line>    <span class=attr>service-url:</span>  <span class=comment># eureka的地址信息</span></span><br><span class=line>      <span class=attr>defaultZone:</span> <span class=string>http://127.0.0.1:10086/eureka</span></span><br></pre></table></figure><p>加上注解<code>@EnableEurekaServer</code><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>@EnableEurekaServer</span><br><span class=line>@SpringBootApplication</span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>EurekaApplication</span> {</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>{</span><br><span class=line>        SpringApplication.<span class=built_in>run</span>(EurekaApplication.class, args);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>客户端也类似,将相关微服务引入然后配置服务端ip与端口地址<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!--eureka客户端--></span></span><br><span class=line>    <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>        <span class=tag><<span class=name>groupId</span>></span>org.springframework.cloud<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>artifactId</span>></span>spring-cloud-starter-netflix-eureka-client<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><h4 id=服务发现与负载均衡><a class=headerlink href=#服务发现与负载均衡 title=服务发现与负载均衡></a>服务发现与负载均衡</h4><p>将其他服务硬编码的请求ip地址改为对应的服务名,同时在restTemplate的bean上加@loadBalanced注解.<p>请求会被拦截器拦截,然后解析其中的服务名拉取服务列表,得到提供相同服务的若干节点,然后做负载均衡.<p><img alt=image-20250810152040203 data-src=https://s2.loli.net/2025/08/10/NHRvX86mQrnxDpK.png><p><strong>Ribbon默认的负载均衡策略</strong><p><img alt=image-20250810152318854 data-src=https://s2.loli.net/2025/08/10/59dSqPhXMoQ8cvD.png><p>修改负载均衡策略方法:1. 创建bean 2.配置文件中配置<p>此外Eureka默认懒加载,在第一服务调用时才会去加载拉取服务中心相关服务信息.可以开启饥饿加载,启动服务中心就进行加载ribbon客户端方便负载均衡.<p><img alt=image-20250810153028389 data-src=https://s2.loli.net/2025/08/10/t7QDqlGs6oMVf9d.png><h3 id=Nacos><a class=headerlink href=#Nacos title=Nacos></a>Nacos</h3><p>相比Eureka功能更多.除了服务注册和发现,也支持集中式配置,服务降级等.<p>Nacos中客户端的服务消费者在<strong>订阅相关服务并接受推送以及定时拉取相关服务</strong>列表后会存入缓存,<p>工作流程如下：<ol><li><strong>服务注册</strong>：服务提供者启动时，会向 Nacos 服务端注册自己的实例信息（IP、端口、服务名等）。<li><strong>服务订阅</strong>：服务消费者启动时，<strong>会向 Nacos 服务端订阅它所需要调用的服务</strong>。<li><strong>推送更新</strong>：当服务提供者的实例列表发生变化（如新实例上线或旧实例下线），Nacos 服务端会实时将最新的实例列表推送给所有订阅了该服务的消费者。(Nacos相比eureka差别)<li><strong>客户端缓存</strong>：消费者客户端会维护一个本地缓存，存储最新的服务实例列表。(定时pull)<li><strong>远程调用</strong>：当消费者需要调用服务时，它会从本地缓存中获取服务实例列表，然后通过负载均衡策略（如轮询、随机等）选择一个健康的实例进行调用。这个过程通常由 <strong>OpenFeign</strong> 或 <strong>RestTemplate</strong> 这样的声明式客户端自动完成。</ol><p>与Eureka差别是,nacos将服务提供者分为<strong>临时实例和非临时实例</strong>. 临时实例采用心跳检测,服务提供者每过一段时间发送心跳给注册中心,当超时将临时实例从服务列表中剔除. 非临时实例在心跳超时后,会去主动检测,如果未响应,等待该非临时节点.<p>Nacos可以配置节点的集群属性,跟地域位置相关,因为相同地域同一集群的服务器之间通信速度更快.<p>一个服务对应多个集群,一个集群包含多个节点,可以根据服务器地域属性配置集群<p><img alt=image-20250810154729061 data-src=https://s2.loli.net/2025/08/10/xCJktiVqD9IcgwK.png><p>nacos默认有限选择与服务消费者相同地域属性的服务提供方,在本地集群的多个节点中随机选择.<p><img alt=image-20250810155533106 data-src=https://s2.loli.net/2025/08/10/SYjCDIFQaGe9knP.png><p><img alt=image-20250810162319041 data-src=https://s2.loli.net/2025/08/10/Gf9Dq8rRAU76p5g.png><h4 id=环境隔离><a class=headerlink href=#环境隔离 title=环境隔离></a>环境隔离</h4><p>Nacos支持环境隔离<p><img alt=image-20250810160607335 data-src=https://s2.loli.net/2025/08/10/9X4fNq7vQOpzsDl.png><h4 id=配置管理><a class=headerlink href=#配置管理 title=配置管理></a>配置管理</h4><ul><li>配置更改热更新</ul><p>在nacos中可以添加配置,设置配置名称(与需要的服务名称相同)与需要热更新的内容.<p>引入nacos-config的依赖,此外为了让服务启动时知道nacos地址方便读取nacos中热更新配置,需要在<code>bootstrap.yaml</code>(其优先级更高)中配置服务名称以及nacos地址等信息.<p><img alt=image-20250810164123884 data-src=https://s2.loli.net/2025/08/10/cinjxrXePTu4ymS.png><p>使用时类似使用<code>application.yaml</code>文件中的变量,使用<code>@Value</code>获取对应值.<p><img alt=image-20250810164415915 data-src=https://s2.loli.net/2025/08/10/4jGMJozcUObNIyV.png><p>为了实现配置文件变更,微服务无需重启就可以感知,还需要在@Value注解所在类加上<code>@RefreshScope</code>注解,实现在nacos中更改配置进行更新. 还可以使用<code>@ConfigurationProperties</code><strong>.</strong><p><strong>多环境配置共享</strong><p>在配置nacos文件名称时,没有后缀的配置,例如<code>userservice.yml</code>一定会被加载.如果有对应的环境,比如<code>dev</code>,就会优先读取<code>userservice-dev.yml</code>.<p><img alt=image-20250810165809462 data-src=https://s2.loli.net/2025/08/10/v4KsJwcHV3GxQIO.png><h3 id=负载均衡有哪些算法？><a class=headerlink href=#负载均衡有哪些算法？ title=负载均衡有哪些算法？></a>负载均衡有哪些算法？</h3><ul><li>简单轮询：将请求按顺序分发给后端服务器上，不关心服务器当前的状态，比如后端服务器的性能、当前的负载。<li>加权轮询：根据服务器自身的性能给服务器设置不同的权重，将请求按顺序和权重分发给后端服务器，可以让性能高的机器处理更多的请求<li>简单随机：将请求随机分发给后端服务器上，请求越多，各个服务器接收到的请求越平均<li>加权随机：根据服务器自身的性能给服务器设置不同的权重，将请求按各个服务器的权重随机分发给后端服务器<li>一致性哈希：根据请求的客户端 ip、或请求参数通过哈希算法得到一个数值，利用该数值取模映射出对应的后端服务器，这样能保证同一个客户端或相同参数的请求每次都使用同一台服务器<li>最小活跃数：统计每台服务器上当前正在处理的请求数，也就是请求活跃数，将请求分发给活跃数最少的后台服务器</ul><h3 id=如何实现一直均衡给一个用户？><a class=headerlink href=#如何实现一直均衡给一个用户？ title=如何实现一直均衡给一个用户？></a>如何实现一直均衡给一个用户？</h3><p>可以通过「一致性哈希算法」来实现，根据请求的客户端 ip、或请求参数通过哈希算法得到一个数值，利用该数值取模映射出对应的后端服务器，这样能保证同一个客户端或相同参数的请求每次都使用同一台服务器<h3 id=服务调用Feign><a class=headerlink href=#服务调用Feign title=服务调用Feign></a>服务调用Feign</h3><p><strong>Feign</strong> 是由 Netflix 开发并开源的一个声明式 HTTP 客户端。它的核心思想是让你通过定义一个接口，并使用注解来描述 HTTP 请求，而 Feign 会在运行时自动生成一个代理实现类来执行这些请求。<p><strong>OpenFeign</strong> 是在 Netflix Feign 停止维护后，由开源社区和 Spring Cloud 团队接手并继续维护和发展的项目。它是在 Feign 的基础上进行了<strong>封装和增强</strong>，使其能够更好地融入到 Spring Cloud 和 Spring Boot 的生态系统中。<p><strong>核心特点：</strong><ul><li><strong>Spring 生态集成</strong>：OpenFeign 最显著的特点是深度集成了 Spring 框架。它支持 Spring MVC 的注解（如 <code>@RequestMapping</code>, <code>@GetMapping</code> 等），这让开发者可以使用与编写 REST Controller 完全相同的注解来定义客户端接口，大大降低了学习成本。<li><strong>独立于 Netflix OSS</strong>：OpenFeign 不再强制依赖于 Netflix OSS 的组件。在 Spring Cloud 的新版本中，它与 Spring Cloud LoadBalancer（替代 Ribbon）和 Spring Cloud CircuitBreaker（替代 Hystrix）等组件无缝集成，提供了更灵活和现代化的解决方案。<li><strong>更活跃的社区</strong>：作为 Spring Cloud 官方维护的项目，OpenFeign 拥有更活跃的社区支持、更频繁的更新和更好的文档。</ul><h3 id=网关Gateway><a class=headerlink href=#网关Gateway title=网关Gateway></a>网关Gateway</h3><p>网关的主要职责是作为微服务架构的<strong>入口点</strong>，它将复杂的内部微服务结构对客户端隐藏起来。<ul><li>身份认证与权限校验<li>服务路由、负载均衡<li>请求限流</ul><p>常用的组件有Zuul以及SpringCloud Gateway.<p>引入相关以来后,进行路由配置,需要声明nacos地址,网关服务端口和名称. 然后配置路由规则,到某个服务. 配置uri与对应的路由断言<code>predicates</code>. 外部请求到达网关后,根据uri与对应规则是否匹配.比如<code>/user/**</code>. 网关路由配置内容包括:路由id,路由目的地uri,以及路由断言匹配请求地址,路由过滤器.<p><img alt=image-20250810173600658 data-src=https://s2.loli.net/2025/08/10/NAzKq1UZCvfTFBs.png><h4 id=路由过滤器配置><a class=headerlink href=#路由过滤器配置 title=路由过滤器配置></a>路由过滤器配置</h4><p>GatewayFilter对进入网关的请求和微服务响应做处理. 有添加请求头,请求参数以及响应头的过滤器.<p><img alt=image-20250810174117515 data-src=https://s2.loli.net/2025/08/10/K2ILHxDQukbj1Mg.png><p>在配置文件中添加<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=attr>routes:</span></span><br><span class=line>	<span class=string>-xxx</span></span><br><span class=line>    <span class=string>-filters:</span></span><br><span class=line>        <span class=bullet>-</span> <span class=string>AddRequestHeader=key,val</span> <span class=comment># 只对某个路由起作用</span></span><br><span class=line><span class=attr>default-filters:</span></span><br><span class=line>	<span class=bullet>-</span> <span class=string>xx</span> <span class=comment>#全局过滤器</span></span><br></pre></table></figure><h4 id=全局过滤器GlobalFilter><a class=headerlink href=#全局过滤器GlobalFilter title=全局过滤器GlobalFilter></a>全局过滤器GlobalFilter</h4><p>全局过滤器的逻辑需要自己代码实现,处理逻辑更灵活<p><img alt=image-20250810174728714 data-src=https://s2.loli.net/2025/08/10/QN5KFwRfBvVZcpJ.png><p>globalfilter声明式注明顺序,而gatewayfilter的默认执行顺序是声明时的顺序,从0开始<p><img alt=image-20250810175224223 data-src=https://s2.loli.net/2025/08/10/bc8Kkw3iOYqrHS2.png><h3 id=CORS跨域处理><a class=headerlink href=#CORS跨域处理 title=CORS跨域处理></a>CORS跨域处理</h3><p>跨域问题:<strong>浏览器</strong>禁止请求的发起者与服务端发生跨域<strong>ajax请求</strong>,请求被浏览器拦截的问题.<p>跨域: 域名不同,端口不同,协议不同.<p>在网关中进行配置<p><img alt=image-20250810180804958 data-src=https://s2.loli.net/2025/08/10/clsJUIbdZzFCX3f.png><h3 id=链路监控与保护-Sentinel><a title="链路监控与保护 Sentinel" class=headerlink href=#链路监控与保护-Sentinel></a>链路监控与保护 Sentinel</h3><p>在微服务架构中，<strong>雪崩问题（Circuit Breaker）</strong> 是一个非常严重且常见的问题。它描述了一种故障蔓延的现象：一个微服务的失败导致了整个系统的级联失败，就像雪崩一样迅速且难以控制。<p><strong>雪崩问题的形成原因</strong><p>雪崩问题通常发生在服务间的依赖调用中。它的形成主要有以下几个原因：<ol><li><strong>服务调用阻塞</strong> 当服务 A 调用服务 B 时，<strong>如果服务 B 因某种原因（如网络延迟、服务器过载）响应缓慢，那么服务 A 的请求线程就会长时间处于等待状态。如果有大量请求同时涌入，服务 A 的所有线程资源（如线程池）都可能被耗尽，导致服务 A 无法处理任何新请求</strong>，最终自身也陷入瘫痪。<li><strong>线程池耗尽</strong> 在许多微服务框架中，服务调用通常使用独立的线程池来管理。如果某个依赖的服务出现问题，所有相关的调用线程都会被阻塞。这会导致整个线程池被耗尽，进而影响到所有依赖该服务的上游服务。<li><strong>服务高负载</strong> 当某个微服务因流量突增而达到处理瓶颈时，它的响应时间会变长。这会导致上游服务的请求线程被阻塞，进而影响更多的服务，形成连锁反应。</ol><h4 id=解决雪崩问题的常见方式><a class=headerlink href=#解决雪崩问题的常见方式 title=解决雪崩问题的常见方式></a>解决雪崩问题的常见方式</h4><ol><li>超时处理,请求超过一定时间没有相应就返回错误信息<li>舱壁模式(线程隔离),限定每个业务使用的线程数,避免耗尽整个tomcat整个资源.其核心思想是<strong>为每个依赖服务分配独立的线程池</strong>。这样，即使一个服务出现故障导致其线程池被耗尽，也不会影响到调用其他服务的线程池，从而避免了故障的扩散。<li>熔断降级,由断路器统计业务执行的一场比例,超出阈值拦截该业务一切请求.当熔断器被打开或服务调用失败时，降级机制会提供一个备选方案。例如，调用服务 A 失败时，我们可以不返回一个错误，而是返回一个缓存中的数据、一个默认值或者一个友好的提示信息。这保证了用户体验，并减少了故障对整体业务的影响。<li>流量控制,限制业务访问的QPS,避免服务因流量突增而故障.</ol><p><img alt=image-20250810192830886 data-src=https://s2.loli.net/2025/08/10/C3GAh9LzBwYSxOX.png><h4 id=Sentinel><a class=headerlink href=#Sentinel title=Sentinel></a>Sentinel</h4><p>Sentinel 以<strong>流量</strong>为切入点，提供了以下几个维度的保护：<ul><li><strong>流量控制（限流）</strong>：当请求流量超过设定的阈值时，Sentinel 会对多余的请求进行限制。它可以基于 QPS（每秒查询数）、并发线程数等维度来控制流量，并提供多种控制效果，如直接拒绝、排队等待等。<li><strong>熔断降级（Circuit Breaking）</strong>：当依赖的下游服务出现故障或响应延迟过高时，为了防止故障扩散，Sentinel 会自动熔断对该服务的调用。在一段时间内，所有对该服务的请求都会直接失败，直到服务恢复正常，熔断器才会进入半开状态进行探测。<li><strong>系统自适应保护</strong>：Sentinel 不仅关注单一资源的流量，还能从整个系统的角度进行保护。当系统负载（如 CPU 使用率、Load 等）过高时，Sentinel 会自动拒绝部分请求，以确保系统不会因过载而崩溃。<li><strong>热点参数限流</strong>：针对特定的热点数据（如某个商品 ID、某个用户 ID），Sentinel 可以对其进行单独的限流，防止因单个热点数据引发的突发流量压垮系统。</ul><p><img alt=image-20250810192939284 data-src=https://s2.loli.net/2025/08/10/fK2CXIRe58SPQjt.png><p>Sentinel提供了五种核心规则来保护你的应用：<ul><li><strong>流量控制 (Flow Control)</strong>：<ul><li><strong>作用</strong>：控制一个资源的访问流量，防止突发流量压垮服务。<li><strong>关键</strong>：基于QPS（每秒请求数）或并发线程数进行限流。<li><strong>限流效果</strong>：<ul><li><strong>快速失败 (Fail-fast)</strong>：默认模式，超过阈值立即拒绝。<li><strong>排队等待 (Wait)</strong>：超过阈值的请求会进入队列，按固定速率处理，平滑流量。<li><strong>慢启动 (Warm-up)</strong>：流量阈值在一定时间内逐渐增加，给系统一个预热时间，防止冷系统被瞬间打垮。</ul></ul><li><strong>熔断降级 (Circuit Breaking)</strong>：<ul><li><strong>作用</strong>：当依赖的下游服务出现故障时，主动断开对该服务的调用，防止故障扩散。<li><strong>关键</strong>：<ul><li><strong>慢调用比率 (Slow Request Ratio)</strong>：当服务的平均响应时间（RT）超过阈值且失败比率达到一定值时，触发熔断。<li><strong>异常比率 (Error Ratio)</strong>：当服务的异常比率达到阈值时，触发熔断。<li><strong>异常数 (Error Count)</strong>：当服务的异常数在指定时间窗口内超过阈值时，触发熔断。</ul><li><strong>状态</strong>：<strong>闭合 (Closed)</strong> -> <strong>打开 (Open)</strong> -> <strong>半开 (Half-Open)</strong>。</ul><li><strong>系统自适应保护 (System Adaptive Protection)</strong>：<ul><li><strong>作用</strong>：从整个系统的角度进行保护，防止系统因过载而崩溃。<li><strong>关键</strong>：基于系统的整体负载（如CPU使用率、系统平均Load等）来动态调整限流阈值，当系统指标超过设定阈值时，拒绝新的请求。</ul><li><strong>热点参数限流 (Hotspot Parameter Flow Control)</strong>：<ul><li><strong>作用</strong>：针对资源中的热点参数进行限流，如某个商品ID、某个用户ID。<li><strong>关键</strong>：可以对单个热点参数设置独立的限流规则，避免因单个热点数据引发的流量高峰影响整个系统。</ul><li><strong>授权规则 (Authority Rules)</strong>：<ul><li><strong>作用</strong>：根据请求的来源（如IP、服务名）进行访问控制，可以设置黑名单或白名单。</ul></ul><ol><li>工作原理与架构</ol><ul><li><strong>滑动窗口（Sliding Window）</strong>：Sentinel的核心流量统计算法。它<strong>将时间窗口划分为多个小的时间片，实时统计和聚合请求数据</strong>，从而实现对QPS和并发线程数的精准控制。<li><strong>责任链模式（Slot Chain）</strong>：Sentinel的内部架构是基于责任链模式设计的。所有请求在进入和离开资源时，都会经过一系列的<code>Slot</code>（插槽），每个<code>Slot</code>负责不同的功能，如<code>统计（StatisticSlot）</code>、<code>流量控制（FlowSlot）</code>、<code>熔断降级（DegradeSlot）</code>等。<li><strong>控制台 (Dashboard)</strong>：Sentinel提供了一个轻量级的Web控制台，用于实时监控、动态配置和管理规则。它使得Sentinel的规则管理变得非常方便，无需重启应用即可生效。</ul><h2 id=Seata><a class=headerlink href=#Seata title=Seata></a>Seata</h2><p>Seata 是一款由阿里巴巴开源的<strong>分布式事务解决方案</strong>。它的核心目标是在微服务架构下，为开发者提供一种高性能、简单易用的方式来解决<strong>分布式事务</strong>带来的数据一致性问题。<p>简单来说，当一个业务操作涉及多个微服务和多个数据库时，如何保证这些操作要么全部成功，要么全部失败，这就是分布式事务要解决的问题。Seata 提供了多种事务模式来处理不同的业务场景。<h3 id=Seata-的三大核心组件><a title="Seata 的三大核心组件" class=headerlink href=#Seata-的三大核心组件></a>Seata 的三大核心组件</h3><p>Seata 的架构由三个主要组件构成，它们共同协作来管理和协调分布式事务：<ol><li><strong>Transaction Coordinator (TC)</strong>：<strong>事务协调者</strong>。这是一个独立的、中心化的服务，负责维护和协调全局事务的状态。它接收事务的注册、提交或回滚请求，并向所有参与事务的微服务发送指令。<li><strong>Transaction Manager (TM)</strong>：<strong>事务管理器</strong>。定义全局事务的范围,内嵌在业务应用中，负责向 TC 开启、提交或回滚一个<strong>全局事务</strong>。它定义了一个分布式事务的边界。<li><strong>Resource Manager (RM)</strong>：<strong>资源管理器</strong>。管理分支事务处理的资源,也内嵌在业务应用中，负责管理<strong>分支事务</strong>。它与 TC 沟通，注册和报告分支事务的状态，并根据 TC 的指令来提交或回滚本地事务。</ol><p>这三个组件形成了一个完整的分布式事务管理框架。<p><img alt=image-20250810203459835 data-src=https://s2.loli.net/2025/08/10/OKEenToSQI31jBH.png><h3 id=Seata-的关键事务模式><a title="Seata 的关键事务模式" class=headerlink href=#Seata-的关键事务模式></a>Seata 的关键事务模式</h3><p>Seata 提供了多种事务模式，每种模式都适用于不同的业务场景，它们的核心区别在于如何实现<strong>两阶段提交</strong>。<h4 id=1-AT-模式-Automatic-Transaction><a title="1. AT 模式 (Automatic Transaction)" class=headerlink href=#1-AT-模式-Automatic-Transaction></a>1. AT 模式 (Automatic Transaction)</h4><p>这是 Seata <strong>最推荐</strong>和<strong>最常用</strong>的模式，因为它对业务代码的侵入性最小。<ul><li><strong>工作原理</strong>：AT 模式基于支持本地 ACID 事务的关系型数据库。<ul><li><strong>一阶段</strong>：业务 SQL 操作和 Seata 的<strong>回滚日志</strong>在同一个本地事务中提交。在本地事务提交前，Seata 会拦截 SQL，并记录数据变更前后的镜像（before image, after image）。<li><strong>二阶段</strong>：<ul><li><strong>提交</strong>：TC 收到所有分支事务成功的消息后，直接通知 RM 提交。RM 异步批量清理回滚日志，这个过程非常快。<li><strong>回滚</strong>：如果某个分支事务失败，TC 会通知所有 RM 进行回滚。RM 会根据一阶段记录的回滚日志，自动生成补偿 SQL 来恢复数据。</ul></ul><li><strong>特点</strong>：对开发者来说几乎是透明的，就像使用本地事务一样简单。它通过全局锁来保证事务间的写隔离。</ul><h4 id=2-TCC-模式-Try-Confirm-Cancel><a title="2. TCC 模式 (Try-Confirm-Cancel)" class=headerlink href=#2-TCC-模式-Try-Confirm-Cancel></a>2. TCC 模式 (Try-Confirm-Cancel)</h4><p>TCC 模式是一种经典的分布式事务模型，它对业务代码有侵入性，需要开发者自己实现三个阶段：<ul><li><strong>Try</strong>：尝试执行。它会检查并预留业务资源，但并不真正执行业务操作。例如，预扣库存。<li><strong>Confirm</strong>：确认执行。如果所有分支事务的 <code>Try</code> 阶段都成功，TC 会通知所有 RM 执行 <code>Confirm</code> 逻辑，真正提交业务操作。<li><strong>Cancel</strong>：取消执行。如果任何一个分支事务的 <code>Try</code> 阶段失败，TC 会通知所有 RM 执行 <code>Cancel</code> 逻辑，回滚已预留的资源。<li><strong>特点</strong>：要求开发者对业务逻辑有清晰的理解，并手动实现 Try、Confirm 和 Cancel 三个方法。它的优点是性能高，可以实现更细粒度的资源控制。</ul><h4 id=3-Saga-模式><a title="3. Saga 模式" class=headerlink href=#3-Saga-模式></a>3. Saga 模式</h4><p>Saga 模式是 Seata 提供的长事务解决方案，它不依赖于两阶段提交，而是通过一系列<strong>本地事务</strong>来保证最终一致性。<ul><li><strong>工作原理</strong>：<ul><li>一个分布式事务被分解为一系列本地事务。<li>每个本地事务都有一个对应的<strong>补偿（Compensation）</strong>操作。<li>如果某个本地事务失败，它会触发前面所有已成功的本地事务执行它们的补偿操作来回滚。</ul><li><strong>特点</strong>：特别适合事务执行时间长、业务流程复杂的场景。Seata 提供了编排工具来简化 Saga 模式的实现。</ul><h4 id=4-XA-模式><a title="4. XA 模式" class=headerlink href=#4-XA-模式></a>4. XA 模式</h4><p>XA 模式是基于 XA 协议实现的，它是一个由数据库厂商支持的、严格的两阶段提交协议。<ul><li><strong>特点</strong>：XA 模式能够严格保证 ACID 特性，对业务代码零侵入，但性能相对较差，因为它在整个事务过程中会锁定数据库资源。</ul><p>此外还有<strong>配置中心</strong>(SpringCloudConfig)集中管理各节点配置文件的问题,<strong>集中式日志管理</strong>(ELK技术栈)收集各节点日志并统一管理的问题.这里不深入.<ul><li><strong>配置中心</strong>：配置中心主要解决了「<strong>如何集中管理各节点配置文件的问题</strong>」，在微服务架构下，所有的微服务节点都包含自己的各种配置文件，如jdbc配置、自定义配置、环境配置、运行参数配置等。要知道有的微服务可能可能有几十个节点，如果将这些配置文件分散存储在节点上，发生配置更改就需要逐个节点调整，将给运维人员带来巨大的压力。配置中心便由此而生，通过部署配置中心服务器，将各节点配置文件从服务中剥离，集中转存到配置中心。一般配置中心都有UI界面，方便实现大规模集群配置调整。<li><strong>集中式日志管理</strong>：集中式日志主要是解决了「<strong>如何收集各节点日志并统一管理的问题</strong>」。微服务架构默认将应用日志分别保存在部署节点上，当需要对日志数据和操作数据进行数据分析和数据统计时，必须收集所有节点的日志数据。那么怎么高效收集所有节点的日志数据呢？业内常见的方案有ELK、EFK。通过搭建独立的日志收集系统，定时抓取各节点增量日志形成有效的统计报表，为统计和分析提供数据支撑。</ul><h2 id=相关资料><a class=headerlink href=#相关资料 title=相关资料></a>相关资料</h2><ol><li><a href=https://www.bilibili.com/video/BV1LQ4y127n4 rel=noopener target=_blank>https://www.bilibili.com/video/BV1LQ4y127n4</a><li><a href=https://www.bilibili.com/video/BV1kH4y1S7wz rel=noopener target=_blank>https://www.bilibili.com/video/BV1kH4y1S7wz</a> 介绍分布式事务<li><a href=https://www.bilibili.com/video/BV1UJc2ezEFU rel=noopener target=_blank>https://www.bilibili.com/video/BV1UJc2ezEFU</a><li><a href=https://www.bilibili.com/video/BV1Q4411y7ip rel=noopener target=_blank>https://www.bilibili.com/video/BV1Q4411y7ip</a><li><a href=https://xiaolincoding.com/interview/spring.html rel=noopener target=_blank>https://xiaolincoding.com/interview/spring.html</a></ol><link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script></div><div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a href=https://www.sekyoro.top/2025/08/10/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/ title=springcloud微服务入门>https://www.sekyoro.top/2025/08/10/springcloud微服务入门/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div><footer class=post-footer><div class=post-tags><a href=/tags/springcloud/ rel=tag><i class="fa fa-tag"></i> springcloud</a></div><div class=post-nav><div class=post-nav-item><a href=/2025/07/31/c-%E5%88%B7leetcode%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/ rel=prev title=c++刷leetcode注意事项> <i class="fa fa-chevron-left"></i> c++刷leetcode注意事项 </a></div><div class=post-nav-item><a href=/2025/08/14/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%A2%98%E7%9B%AE%E4%B8%80%E8%A7%88/ rel=next title=系统设计题目一览> 系统设计题目一览 <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div><!-- 评论区 --><div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%88%86%E5%B8%83%E5%BC%8F><span class=nav-number>1.</span> <span class=nav-text>分布式</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA><span class=nav-number>1.1.</span> <span class=nav-text>分布式理论</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81><span class=nav-number>1.2.</span> <span class=nav-text>分布式锁</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1><span class=nav-number>1.3.</span> <span class=nav-text>分布式事务</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95><span class=nav-number>1.4.</span> <span class=nav-text>分布式限流算法</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95><span class=nav-number>1.5.</span> <span class=nav-text>分布式一致性算法</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%BE%AE%E6%9C%8D%E5%8A%A1><span class=nav-number>1.6.</span> <span class=nav-text>微服务</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%93%E6%9E%84><span class=nav-number>1.6.1.</span> <span class=nav-text>微服务结构</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83><span class=nav-number>1.6.2.</span> <span class=nav-text>注册中心</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Eureka><span class=nav-number>1.6.3.</span> <span class=nav-text>Eureka</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C><span class=nav-number>1.6.3.1.</span> <span class=nav-text>服务注册</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1><span class=nav-number>1.6.3.2.</span> <span class=nav-text>服务发现与负载均衡</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#Nacos><span class=nav-number>1.6.4.</span> <span class=nav-text>Nacos</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB><span class=nav-number>1.6.4.1.</span> <span class=nav-text>环境隔离</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86><span class=nav-number>1.6.4.2.</span> <span class=nav-text>配置管理</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%AE%97%E6%B3%95%EF%BC%9F><span class=nav-number>1.6.5.</span> <span class=nav-text>负载均衡有哪些算法？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E7%9B%B4%E5%9D%87%E8%A1%A1%E7%BB%99%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%EF%BC%9F><span class=nav-number>1.6.6.</span> <span class=nav-text>如何实现一直均衡给一个用户？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8Feign><span class=nav-number>1.6.7.</span> <span class=nav-text>服务调用Feign</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%BD%91%E5%85%B3Gateway><span class=nav-number>1.6.8.</span> <span class=nav-text>网关Gateway</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%B7%AF%E7%94%B1%E8%BF%87%E6%BB%A4%E5%99%A8%E9%85%8D%E7%BD%AE><span class=nav-number>1.6.8.1.</span> <span class=nav-text>路由过滤器配置</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8GlobalFilter><span class=nav-number>1.6.8.2.</span> <span class=nav-text>全局过滤器GlobalFilter</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#CORS%E8%B7%A8%E5%9F%9F%E5%A4%84%E7%90%86><span class=nav-number>1.6.9.</span> <span class=nav-text>CORS跨域处理</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%93%BE%E8%B7%AF%E7%9B%91%E6%8E%A7%E4%B8%8E%E4%BF%9D%E6%8A%A4-Sentinel><span class=nav-number>1.6.10.</span> <span class=nav-text>链路监控与保护 Sentinel</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%A7%A3%E5%86%B3%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F><span class=nav-number>1.6.10.1.</span> <span class=nav-text>解决雪崩问题的常见方式</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Sentinel><span class=nav-number>1.6.10.2.</span> <span class=nav-text>Sentinel</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Seata><span class=nav-number>1.7.</span> <span class=nav-text>Seata</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#Seata-%E7%9A%84%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6><span class=nav-number>1.7.1.</span> <span class=nav-text>Seata 的三大核心组件</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Seata-%E7%9A%84%E5%85%B3%E9%94%AE%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%BC%8F><span class=nav-number>1.7.2.</span> <span class=nav-text>Seata 的关键事务模式</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-AT-%E6%A8%A1%E5%BC%8F-Automatic-Transaction><span class=nav-number>1.7.2.1.</span> <span class=nav-text>1. AT 模式 (Automatic Transaction)</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-TCC-%E6%A8%A1%E5%BC%8F-Try-Confirm-Cancel><span class=nav-number>1.7.2.2.</span> <span class=nav-text>2. TCC 模式 (Try-Confirm-Cancel)</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-Saga-%E6%A8%A1%E5%BC%8F><span class=nav-number>1.7.2.3.</span> <span class=nav-text>3. Saga 模式</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-XA-%E6%A8%A1%E5%BC%8F><span class=nav-number>1.7.2.4.</span> <span class=nav-text>4. XA 模式</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99><span class=nav-number>1.8.</span> <span class=nav-text>相关资料</span></a></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>250</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>16</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>218</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a><li class=links-of-blogroll-item><a href=https://www.lllomh.com/ rel=noopener target=_blank title=https://www.lllomh.com/>芈渡</a><li class=links-of-blogroll-item><a href=https://protool-ten.vercel.app/ rel=noopener target=_blank title=https://protool-ten.vercel.app/>protools</a></ul></div><div class="motion-element announcement"><div class=title></div><p class=content><p class=date></div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>文章词云</h3><div class="widget tagcloud" id=myCanvasContainer><canvas height=250 id=resCanvas style=width:100% width=250><ul class=tag-list itemprop=keywords><li class=tag-list-item><a class=tag-list-link href=/tags/springcloud/ rel=tag>springcloud</a><span class=tag-list-count>1</span></ul></canvas></div></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2025</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>3.9m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>59:47</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer></div><script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script><script src=/lib/anime.min.js></script><script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script><script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/pisces.js></script><script src=/js/next-boot.js></script><script src=/js/bookmark.js></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	'.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script><script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script><script src=/js/algolia-search.js></script><script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script><div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div><script charset=utf-8 defer src=/js/tagcanvas.js></script><script charset=utf-8 defer src=/js/tagcloud.js></script><script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script><script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script><script src=/js/src/activate-power-mode.min.js></script><script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script>
<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"3G9PZZIKCH","apiKey":"8eb71f5ca3167e9ef3487882f10cfaad","indexName":"SekyoroSearch","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content=刷算法时有必要使用一些stl. name=description><meta content=article property=og:type><meta content=STL学习 property=og:title><meta content=https://www.sekyoro.top/2023/03/05/STL%E5%AD%A6%E4%B9%A0/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content=刷算法时有必要使用一些stl. property=og:description><meta content=zh_CN property=og:locale><meta content=2023-03-05T15:56:00.000Z property=article:published_time><meta content=2023-03-05T15:57:34.000Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content=cpp property=article:tag><meta content=stl property=article:tag><meta content=summary name=twitter:card><link href=https://www.sekyoro.top/2023/03/05/STL%E5%AD%A6%E4%B9%A0/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>STL学习 | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2023/03/05/STL%E5%AD%A6%E4%B9%A0/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>STL学习</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2023-03-05 23:56:00 / 修改时间：23:57:34" datetime=2023-03-05T23:56:00+08:00>2023-03-05</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>16k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>15 分钟</span> </span></div></header><div class=post-body itemprop=articleBody><p>刷算法时有必要使用一些stl.<br><span id=more></span><h2 id=容器><a class=headerlink href=#容器 title=容器></a>容器</h2><h3 id=序列式容器><a class=headerlink href=#序列式容器 title=序列式容器></a>序列式容器</h3><h4 id=array><a class=headerlink href=#array title=array></a>array</h4><p>初始化 通过如下创建 array 容器的方式，可以将所有的元素初始化为 0 或者和默认元素类型等效的值：<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>std::array<<span class=keyword>double</span>, 10> values {};</span><br></pre></table></figure><p>array 容器是 <a href=http://c.biancheng.net/cplus/ rel=noopener target=_blank>C++</a> 11 标准中新增的序列容器，简单地理解，它就是在 C++ 普通数组的基础上，添加了一些成员函数和全局函数。在使用上，它比普通数组更安全，且效率并没有因此变差。<div class=table-container><table><thead><tr><th>成员函数<th>功能<tbody><tr><td>begin()<td>返回指向容器中第一个元素的随机访问迭代器。<tr><td>end()<td>返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。<tr><td>rbegin()<td>返回指向最后一个元素的随机访问迭代器。<tr><td>rend()<td>返回指向第一个元素之前一个位置的随机访问迭代器。<tr><td>cbegin()<td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。<tr><td>cend()<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。<tr><td>crbegin()<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。<tr><td>crend()<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。<tr><td>size()<td>返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。<tr><td>max_size()<td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。<tr><td>empty()<td>判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快。<tr><td>at(n)<td>返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。<tr><td>front()<td>返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。<tr><td>back()<td>返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。<tr><td>data()<td>返回一个指向容器首个元素的<a href=http://c.biancheng.net/c/80/ rel=noopener target=_blank>指针</a>。利用该指针，可实现复制容器中所有元素等类似功能。<tr><td>fill(val)<td>将 val 这个值赋值给容器中的每个元素。<tr><td>array1.swap(array2)<td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</table></div><p>对于array相比一般的c数组,可以直接利用front,back获取前后引用,size函数获取个数,以及一般的容器迭代器等<p>同时还有at函数更加安全的获取array中的元素,但由于不能更改长度,实践中用的并不多<h4 id=vector><a class=headerlink href=#vector title=vector></a>vector</h4><div class=table-container><table><thead><tr><th>begin()<th>返回指向容器中第一个元素的迭代器。<tbody><tr><td>end()<td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。<tr><td>rbegin()<td>返回指向最后一个元素的迭代器。<tr><td>rend()<td>返回指向第一个元素所在位置前一个位置的迭代器。<tr><td>cbegin()<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。<tr><td>cend()<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。<tr><td>crbegin()<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。<tr><td>crend()<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。<tr><td>size()<td>返回实际元素个数。<tr><td>max_size()<td>返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。<tr><td>resize()<td>改变实际元素的个数。<tr><td>capacity()<td>返回当前容量。<tr><td>empty()<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。<tr><td>reserve()<td>增加容器的容量。<tr><td>shrink _to_fit()<td>将内存减少到等于当前元素实际所使用的大小。<tr><td>operator[ ]<td>重载了 [ ] 运算符，可以向访问数组中元素那样，通过下标即可访问甚至修改 vector 容器中的元素。<tr><td>at()<td>使用经过边界检查的索引访问元素。<tr><td>front()<td>返回第一个元素的引用。<tr><td>back()<td>返回最后一个元素的引用。<tr><td>data()<td>返回指向容器中第一个元素的指针。<tr><td>assign()<td>用新元素替换原有内容。<tr><td>push_back()<td>在序列的尾部添加一个元素。<tr><td>pop_back()<td>移出序列尾部的元素。<tr><td>insert()<td>在指定的位置插入一个或多个元素。<tr><td>erase()<td>移出一个元素或一段元素。<tr><td>clear()<td>移出所有的元素，容器大小变为 0。<tr><td>swap()<td>交换两个容器的所有元素。<tr><td>emplace()<td>在指定的位置直接生成一个元素。<tr><td>emplace_back()<td>在序列尾部生成一个元素。</table></div><p>可以更改大小,在内存上是连续分布的.所以可以随机访问,跟一般的数组和array类似. 可以使用reserve函数调整大小,<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>values.<span class=built_in>reserve</span>(<span class=number>20</span>);</span><br></pre></table></figure><p>这样就设置了容器的内存分配，即至少可以容纳 20 个元素。注意，如果 vector 的容量在执行此语句之前，已经大于或等于 20 个元素，那么这条语句什么也不做；另外，调用 reserve() 不会影响已存储的元素，也不会生成任何元素，即 values 容器内此时仍然没有任何元素.<p>同时使用emplace,emplace_back,erase等来增加或删除元素.<blockquote><p>emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</blockquote><p>插入元素<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span> </span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTvector></span> </span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTarray></span> </span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>    std::vector<<span class=keyword>int</span>> demo{<span class=number>1</span>,<span class=number>2</span>};</span><br><span class=line>    <span class=comment>//第一种格式用法</span></span><br><span class=line>    demo.<span class=built_in>insert</span>(demo.<span class=built_in>begin</span>() + <span class=number>1</span>, <span class=number>3</span>);<span class=comment>//{1,3,2}</span></span><br><span class=line></span><br><span class=line>    <span class=comment>//第二种格式用法</span></span><br><span class=line>    demo.<span class=built_in>insert</span>(demo.<span class=built_in>end</span>(), <span class=number>2</span>, <span class=number>5</span>);<span class=comment>//{1,3,2,5,5}</span></span><br><span class=line></span><br><span class=line>    <span class=comment>//第三种格式用法</span></span><br><span class=line>    std::array<<span class=keyword>int</span>,3>test{ <span class=number>7</span>,<span class=number>8</span>,<span class=number>9</span> };</span><br><span class=line>    demo.<span class=built_in>insert</span>(demo.<span class=built_in>end</span>(), test.<span class=built_in>begin</span>(), test.<span class=built_in>end</span>());<span class=comment>//{1,3,2,5,5,7,8,9}</span></span><br><span class=line></span><br><span class=line>    <span class=comment>//第四种格式用法</span></span><br><span class=line>    demo.<span class=built_in>insert</span>(demo.<span class=built_in>end</span>(), { <span class=number>10</span>,<span class=number>11</span> });<span class=comment>//{1,3,2,5,5,7,8,9,10,11}</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < demo.<span class=built_in>size</span>(); i++) {</span><br><span class=line>        cout << demo[i] << <span class=string>" "</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>删除元素<div class=table-container><table><thead><tr><th>函数<th>功能<tbody><tr><td>pop_back()<td>删除 vector 容器中最后一个元素，该容器的大小（size）会减 1，但容量（capacity）不会发生改变。<tr><td>erase(pos)<td>删除 vector 容器中 pos 迭代器指定位置处的元素，并返回指向被删除元素下一个位置元素的迭代器。该容器的大小（size）会减 1，但容量（capacity）不会发生改变。<tr><td>swap(beg)、pop_back()<td>先调用 swap() 函数交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back() 删除该目标元素。<tr><td>erase(beg,end)<td>删除 vector 容器中位于迭代器 [beg,end)指定区域内的所有元素，并返回指向被删除区域下一个位置元素的迭代器。该容器的大小（size）会减小，但容量（capacity）不会发生改变。<tr><td>remove()<td>删除容器中所有和指定元素值相等的元素，并返回指向最后一个元素下一个位置的迭代器。值得一提的是，调用该函数不会改变容器的大小和容量。<tr><td>clear()<td>删除 vector 容器中所有的元素，使其变成空的 vector 容器。该函数会改变 vector 的大小（变为 0），但不是改变其容量。</table></div><figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTvector></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>    std::vector<<span class=keyword>int</span>> demo{ <span class=number>1</span>,<span class=number>2</span>,<span class=number>3</span>,<span class=number>4</span>,<span class=number>5</span> };</span><br><span class=line>    <span class=comment>//删除 2、3</span></span><br><span class=line>    <span class=keyword>auto</span> iter = demo.<span class=built_in>erase</span>(demo.<span class=built_in>begin</span>()+<span class=number>1</span>, demo.<span class=built_in>end</span>() - <span class=number>2</span>);</span><br><span class=line>    cout << <span class=string>"size is :"</span> << demo.<span class=built_in>size</span>() << endl;</span><br><span class=line>    cout << <span class=string>"capacity is :"</span> << demo.<span class=built_in>capacity</span>() << endl;</span><br><span class=line></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < demo.<span class=built_in>size</span>(); i++) {</span><br><span class=line>        cout << demo[i] << <span class=string>" "</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>常用emplace,emplace_back,pop_back,erase对vector进行增删数据,使用at访问数据<h4 id=deque><a class=headerlink href=#deque title=deque></a>deque</h4><p>deque 容器和 vecotr 容器有很多相似之处，比如：<ul><li>deque 容器也擅长在序列尾部添加或删除元素（时间复杂度为<code>O(1)</code>），而不擅长在序列中间添加或删除元素。<li>deque 容器也可以根据需要修改自身的容量和大小</ul><p>和 vector 不同的是，deque 还擅长在序列头部添加或删除元素，所耗费的时间复杂度也为常数阶<code>O(1)</code>。并且更重要的一点是，deque 容器中存储元素并不能保证所有元素都存储到连续的内存空间中。<blockquote><p>当需要向序列两端频繁的添加或删除元素时，应首选 deque 容器。</blockquote><p>和 vector 相比，额外增加了实现在容器头部添加和删除元素的成员函数比如emplace_front,pop_font，同时删除了 capacity()、reserve() 和 data() 成员函数。<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTdeque></span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>    <span class=comment>//初始化一个空deque容量</span></span><br><span class=line>    deque<<span class=keyword>int</span>>d;</span><br><span class=line>    <span class=comment>//向d容器中的尾部依次添加 1，2,3</span></span><br><span class=line>    d.<span class=built_in>push_back</span>(<span class=number>1</span>); <span class=comment>//{1}</span></span><br><span class=line>    d.<span class=built_in>push_back</span>(<span class=number>2</span>); <span class=comment>//{1,2}</span></span><br><span class=line>    d.<span class=built_in>push_back</span>(<span class=number>3</span>); <span class=comment>//{1,2,3}</span></span><br><span class=line>    <span class=comment>//向d容器的头部添加 0 </span></span><br><span class=line>    d.<span class=built_in>push_front</span>(<span class=number>0</span>); <span class=comment>//{0,1,2,3}</span></span><br><span class=line></span><br><span class=line>    <span class=comment>//调用 size() 成员函数输出该容器存储的字符个数。</span></span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"元素个数为：%d\n"</span>, d.<span class=built_in>size</span>());</span><br><span class=line>   </span><br><span class=line>    <span class=comment>//使用迭代器遍历容器</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>auto</span> i = d.<span class=built_in>begin</span>(); i < d.<span class=built_in>end</span>(); i++) {</span><br><span class=line>        cout << *i << <span class=string>" "</span>;</span><br><span class=line>    }</span><br><span class=line>    cout << endl;</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><h4 id=list><a class=headerlink href=#list title=list></a>list</h4><p><a href=http://c.biancheng.net/stl/ rel=noopener target=_blank>STL</a> list 容器，又称双向链表容器，即该容器的底层是以双向链表的形式实现的。这意味着，list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。<p>list 容器具有一些其它容器（array、vector 和 deque）所不具备的优势，即它可以在序列已知的任何位置快速插入或删除元素（时间复杂度为<code>O(1)</code>）。并且在 list 容器中移动元素，也比其它容器的效率高。<p>和之前的序列容器相比，list 容器迭代器最大的不同在于，其配备的迭代器类型为双向迭代器，而不再是随机访问迭代器。<div class=table-container><table><thead><tr><th>成员函数<th>功能<tbody><tr><td>begin()<td>返回指向容器中第一个元素的双向迭代器。<tr><td>end()<td>返回指向容器中最后一个元素所在位置的下一个位置的双向迭代器。<tr><td>rbegin()<td>返回指向最后一个元素的反向双向迭代器。<tr><td>rend()<td>返回指向第一个元素所在位置前一个位置的反向双向迭代器。<tr><td>cbegin()<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。<tr><td>cend()<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。<tr><td>crbegin()<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。<tr><td>crend()<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。<tr><td>empty()<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。<tr><td>size()<td>返回当前容器实际包含的元素个数。<tr><td>max_size()<td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。<tr><td>front()<td>返回第一个元素的引用。<tr><td>back()<td>返回最后一个元素的引用。<tr><td>assign()<td>用新元素替换容器中原有内容。<tr><td>emplace_front()<td>在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。<tr><td>push_front()<td>在容器头部插入一个元素。<tr><td>pop_front()<td>删除容器头部的一个元素。<tr><td>emplace_back()<td>在容器尾部直接生成一个元素。该函数和 push_back() 的功能相同，但效率更高。<tr><td>push_back()<td>在容器尾部插入一个元素。<tr><td>pop_back()<td>删除容器尾部的一个元素。<tr><td>emplace()<td>在容器中的指定位置插入元素。该函数和 insert() 功能相同，但效率更高。<tr><td>insert()<td>在容器中的指定位置插入元素。<tr><td>erase()<td>删除容器中一个或某区域内的元素。<tr><td>swap()<td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。<tr><td>resize()<td>调整容器的大小。<tr><td>clear()<td>删除容器存储的所有元素。<tr><td>splice()<td>将一个 list 容器中的元素插入到另一个容器的指定位置。<tr><td>remove(val)<td>删除容器中所有等于 val 的元素。<tr><td>remove_if()<td>删除容器中满足条件的元素。<tr><td>unique()<td>删除容器中相邻的重复元素，只保留一个。<tr><td>merge()<td>合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的。<tr><td>sort()<td>通过更改容器中元素的位置，将它们进行排序。<tr><td>reverse()<td>反转容器中元素的顺序。</table></div><figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTlist></span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>    <span class=comment>//创建空的 list 容器</span></span><br><span class=line>    std::list<<span class=keyword>double</span>> values;</span><br><span class=line>    <span class=comment>//向容器中添加元素</span></span><br><span class=line>    values.<span class=built_in>push_back</span>(<span class=number>3.1</span>);</span><br><span class=line>    values.<span class=built_in>push_back</span>(<span class=number>2.2</span>);</span><br><span class=line>    values.<span class=built_in>push_back</span>(<span class=number>2.9</span>);</span><br><span class=line>    cout << <span class=string>"values size："</span> << values.<span class=built_in>size</span>() << endl;</span><br><span class=line>    <span class=comment>//对容器中的元素进行排序</span></span><br><span class=line>    values.<span class=built_in>sort</span>();</span><br><span class=line>    <span class=comment>//使用迭代器输出list容器中的元素</span></span><br><span class=line>    <span class=keyword>for</span> (std::list<<span class=keyword>double</span>>::iterator it = values.<span class=built_in>begin</span>(); it != values.<span class=built_in>end</span>(); ++it) {</span><br><span class=line>        std::cout << *it << <span class=string>" "</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTlist></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTarray></span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>    std::list<<span class=keyword>int</span>> values{ <span class=number>1</span>,<span class=number>2</span> };</span><br><span class=line>    <span class=comment>//第一种格式用法</span></span><br><span class=line>    values.<span class=built_in>insert</span>(values.<span class=built_in>begin</span>() , <span class=number>3</span>);<span class=comment>//{3,1,2}</span></span><br><span class=line></span><br><span class=line>    <span class=comment>//第二种格式用法</span></span><br><span class=line>    values.<span class=built_in>insert</span>(values.<span class=built_in>end</span>(), <span class=number>2</span>, <span class=number>5</span>);<span class=comment>//{3,1,2,5,5}</span></span><br><span class=line></span><br><span class=line>    <span class=comment>//第三种格式用法</span></span><br><span class=line>    std::array<<span class=keyword>int</span>, 3>test{ <span class=number>7</span>,<span class=number>8</span>,<span class=number>9</span> };</span><br><span class=line>    values.<span class=built_in>insert</span>(values.<span class=built_in>end</span>(), test.<span class=built_in>begin</span>(), test.<span class=built_in>end</span>());<span class=comment>//{3,1,2,5,5,7,8,9}</span></span><br><span class=line></span><br><span class=line>    <span class=comment>//第四种格式用法</span></span><br><span class=line>    values.<span class=built_in>insert</span>(values.<span class=built_in>end</span>(), { <span class=number>10</span>,<span class=number>11</span> });<span class=comment>//{3,1,2,5,5,7,8,9,10,11}</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>auto</span> p = values.<span class=built_in>begin</span>(); p != values.<span class=built_in>end</span>(); ++p)</span><br><span class=line>    {</span><br><span class=line>        cout << *p << <span class=string>" "</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><h3 id=关联式容器><a class=headerlink href=#关联式容器 title=关联式容器></a>关联式容器</h3><p>关联式容器在存储元素值的同时，会为各元素额外再配备一个值（又称为“键”，其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联式容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。<blockquote><p>弃用序列式容器，转而选用关联式容器存储元素，往往就是看中了关联式容器可以快速查找、读取或者删除所存储的元素，同时该类型容器插入元素的效率也比序列式容器高。</blockquote><p>也就是说，使用关联式容器存储的元素，都是一个一个的“键值对”（ <key ,value> ），这是和序列式容器最大的不同。除此之外，序列式容器中存储的元素默认都是未经过排序的，而使用关联式容器存储的元素，默认会根据各元素的键值的大小做升序排序 <div class=table-container><table><thead><tr><th>关联式容器名称<th>特点<tbody><tr><td>map<td>定义在 <map>头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根据各元素键的大小，默认进行升序排序（调用 std::less<t>）。 <tr><td>set<td>定义在 <set> 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个元素的键（其实也就是元素值）的大小进行升序排序（调用 std::less<t>）。 <tr><td>multimap<td>定义在 <map>头文件中，和 map 容器唯一的不同在于，multimap 容器中存储元素的键可以重复。 <tr><td>multiset<td>定义在 <set> 头文件中，和 set 容器唯一的不同在于，multiset 容器中存储元素的值可以重复（一旦值重复，则意味着键也是重复的）。 <figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTmap></span> <span class=comment>//使用 map 容器，必须引入该头文件</span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring></span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>    <span class=comment>//创建一个空的 map 关联式容器，该容器中存储的键值对，其中键为 string 字符串，值也为 string 字符串类型</span></span><br><span class=line>    map&LTstring, string> mymap;</span><br><span class=line>    <span class=comment>//向 mymap 容器中添加数据</span></span><br><span class=line>    mymap[<span class=string>"http://c.biancheng.net/c/"</span>] = <span class=string>"C语言教程"</span>;</span><br><span class=line>    mymap[<span class=string>"http://c.biancheng.net/python/"</span>] = <span class=string>"Python教程"</span>;</span><br><span class=line>    mymap[<span class=string>"http://c.biancheng.net/java/"</span>] = <span class=string>"Java教程"</span>;</span><br><span class=line></span><br><span class=line>    <span class=comment>//使用 map 容器的迭代器，遍历 mymap 容器，并输出其中存储的各个键值对</span></span><br><span class=line>    <span class=keyword>for</span> (map&LTstring, string>::iterator it = mymap.<span class=built_in>begin</span>(); it != mymap.<span class=built_in>end</span>(); ++it) {</span><br><span class=line>        <span class=comment>//输出各个元素中的键和值</span></span><br><span class=line>        cout << it->first << <span class=string>" => "</span> << it->second << <span class=string>'\n'</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>考虑到“键值对”并不是普通类型数据，<a href=http://c.biancheng.net/cplus/ rel=noopener target=_blank>C++</a> <a href=http://c.biancheng.net/stl/ rel=noopener target=_blank>STL</a> 标准库提供了 pair 类模板，其专门用来将 2 个普通元素 first 和 second（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素<code>&LTfirst, second></code>。通过其构成的元素格式不难看出，使用 pair 类模板来创建“键值对”形式的元素</p> <p>pair 类模板定义在<code>&LTutility></code>头文件中，所以在使用该类模板之前，需引入此头文件。另外值得一提的是，在 C++ 11 标准之前，pair 类模板中提供了以下 3 种构造函数：</p> <h1 id=1-默认构造函数，即创建空的-pair-对象pair><a title="1) 默认构造函数，即创建空的 pair 对象pair();" class=headerlink href=#1-默认构造函数，即创建空的-pair-对象pair></a>1) 默认构造函数，即创建空的 pair 对象pair();</h1><h1 id=2-直接使用-2-个元素初始化成-pair-对象pair-const-first-type-amp-a-const-second-type-amp-b><a title="2) 直接使用 2 个元素初始化成 pair 对象pair (const first_type& a, const second_type& b);" class=headerlink href=#2-直接使用-2-个元素初始化成-pair-对象pair-const-first-type-amp-a-const-second-type-amp-b></a>2) 直接使用 2 个元素初始化成 pair 对象pair (const first_type& a, const second_type& b);</h1><h1 id=3-拷贝（复制）构造函数，即借助另一个-pair-对象，创建新的-pair-对象template-pair-const-pair-amp-pr><a title="3) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象template pair (const pair& pr);" class=headerlink href=#3-拷贝（复制）构造函数，即借助另一个-pair-对象，创建新的-pair-对象template-pair-const-pair-amp-pr></a>3) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象template<class u, v> pair (const pair<u ,v>& pr);<p>在 C++ 11 标准中，在引入<a href=http://c.biancheng.net/view/439.html rel=noopener target=_blank>右值引用</a>的基础上，pair 类模板中又增添了如下 2 个构造函数：</p> <h1 id=4-移动构造函数template-pair-pair-amp-amp-pr-5-使用右值引用参数，创建-pair-对象template-pair-U-amp-amp-a-V-amp-amp-b><a title="4) 移动构造函数template pair (pair&& pr);#5) 使用右值引用参数，创建 pair 对象template pair (U&& a, V&& b);" class=headerlink href=#4-移动构造函数template-pair-pair-amp-amp-pr-5-使用右值引用参数，创建-pair-对象template-pair-U-amp-amp-a-V-amp-amp-b></a>4) 移动构造函数template<class u, v> pair (pair<u ,v>&& pr);#5) 使用右值引用参数，创建 pair 对象template<class u, v> pair (U&& a, V&& b);<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTutility></span>      <span class=comment>// pair</span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring></span>       <span class=comment>// string</span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=comment>// 调用构造函数 1，也就是默认构造函数</span></span><br><span class=line>    pair &LTstring, <span class=keyword>double</span>> pair1;</span><br><span class=line>    <span class=comment>// 调用第 2 种构造函数</span></span><br><span class=line>    pair &LTstring, string> <span class=built_in>pair2</span>(<span class=string>"STL教程"</span>,<span class=string>"http://c.biancheng.net/stl/"</span>);  </span><br><span class=line>    <span class=comment>// 调用拷贝构造函数</span></span><br><span class=line>    pair &LTstring, string> <span class=built_in>pair3</span>(pair2);</span><br><span class=line>    <span class=comment>//调用移动构造函数</span></span><br><span class=line>    pair &LTstring, string> <span class=built_in>pair4</span>(<span class=built_in>make_pair</span>(<span class=string>"C++教程"</span>, <span class=string>"http://c.biancheng.net/cplus/"</span>));</span><br><span class=line>    <span class=comment>// 调用第 5 种构造函数</span></span><br><span class=line>    pair &LTstring, string> <span class=built_in>pair5</span>(<span class=built_in>string</span>(<span class=string>"Python教程"</span>), <span class=built_in>string</span>(<span class=string>"http://c.biancheng.net/python/"</span>));  </span><br><span class=line>   </span><br><span class=line>    cout << <span class=string>"pair1: "</span> << pair1.first << <span class=string>" "</span> << pair1.second << endl;</span><br><span class=line>    cout << <span class=string>"pair2: "</span><< pair2.first << <span class=string>" "</span> << pair2.second << endl;</span><br><span class=line>    cout << <span class=string>"pair3: "</span> << pair3.first << <span class=string>" "</span> << pair3.second << endl;</span><br><span class=line>    cout << <span class=string>"pair4: "</span> << pair4.first << <span class=string>" "</span> << pair4.second << endl;</span><br><span class=line>    cout << <span class=string>"pair5: "</span> << pair5.first << <span class=string>" "</span> << pair5.second << endl;</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=map><a class=headerlink href=#map title=map></a>map</h4><figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>map&LTstring,<span class=keyword>int</span>>myMap;</span><br><span class=line>   map&LTstring,<span class=keyword>int</span>>mymap{{<span class=string>"C语言"</span>,<span class=number>10</span>},{<span class=string>"C++教程"</span>,<span class=number>20</span>}};</span><br><span class=line>   map&LTstring,string>m{<span class=built_in>make_pair</span>(<span class=string>"hi"</span>,<span class=string>"hello"</span>)};</span><br><span class=line>   map&LTstring,string>copiedmap{m};</span><br><span class=line></span><br><span class=line>   map&LTstring,<span class=keyword>int</span>,greater&LTstring> >hismap;</span><br></pre></table></figure> <p>常用的成员函数是find,count</p> <figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTmap></span>      <span class=comment>// map</span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring></span>       <span class=comment>// string</span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=comment>//创建空 map 容器，默认根据个键值对中键的值，对键值对做降序排序</span></span><br><span class=line>    std::map&LTstd::string, std::string, std::greater&LTstd::string>>myMap;</span><br><span class=line>    <span class=comment>//调用 emplace() 方法，直接向 myMap 容器中指定位置构造新键值对</span></span><br><span class=line>    myMap.<span class=built_in>emplace</span>(<span class=string>"C语言教程"</span>,<span class=string>"http://c.biancheng.net/c/"</span>);</span><br><span class=line>    myMap.<span class=built_in>emplace</span>(<span class=string>"Python教程"</span>, <span class=string>"http://c.biancheng.net/python/"</span>);</span><br><span class=line>    myMap.<span class=built_in>emplace</span>(<span class=string>"STL教程"</span>, <span class=string>"http://c.biancheng.net/stl/"</span>);</span><br><span class=line>    <span class=comment>//输出当前 myMap 容器存储键值对的个数</span></span><br><span class=line>    cout << <span class=string>"myMap size=="</span> << myMap.<span class=built_in>size</span>() << endl;</span><br><span class=line>    <span class=comment>//判断当前 myMap 容器是否为空</span></span><br><span class=line>    <span class=keyword>if</span> (!myMap.<span class=built_in>empty</span>()) {</span><br><span class=line>        <span class=comment>//借助 myMap 容器迭代器，将该容器的键值对逐个输出</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span> i = myMap.<span class=built_in>begin</span>(); i != myMap.<span class=built_in>end</span>(); ++i) {</span><br><span class=line>            cout << i->first << <span class=string>" "</span> << i->second << endl;</span><br><span class=line>        }</span><br><span class=line>    }  </span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=set><a class=headerlink href=#set title=set></a>set</h4><figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>set&LTstring> myset{<span class=string>"shit"</span>};</span><br><span class=line>    set&LTstring> set2{</span><br><span class=line>        <span class=string>"hi"</span>,</span><br><span class=line>        <span class=string>"hello"</span></span><br><span class=line>    };</span><br><span class=line>    <span class=function>set&LTstring> <span class=title>s1</span><span class=params>(set2)</span></span>;</span><br><span class=line>    s.<span class=built_in>emplace</span>(<span class=string>"hi"</span>);</span><br></pre></table></figure> <p>删除元素 erase</p> <figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTset></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring></span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>    <span class=comment>//创建并初始化 set 容器</span></span><br><span class=line>    std::set<<span class=keyword>int</span>>myset{<span class=number>1</span>,<span class=number>2</span>,<span class=number>3</span>,<span class=number>4</span>,<span class=number>5</span>};</span><br><span class=line>    cout << <span class=string>"myset size = "</span> << myset.<span class=built_in>size</span>() << endl;</span><br><span class=line>   </span><br><span class=line>    <span class=comment>//1) 调用第一种格式的 erase() 方法</span></span><br><span class=line>    <span class=keyword>int</span> num = myset.<span class=built_in>erase</span>(<span class=number>2</span>); <span class=comment>//删除元素 2，myset={1,3,4,5}</span></span><br><span class=line>    cout << <span class=string>"1、myset size = "</span> << myset.<span class=built_in>size</span>() << endl;</span><br><span class=line>    cout << <span class=string>"num = "</span> << num << endl;</span><br><span class=line></span><br><span class=line>    <span class=comment>//2) 调用第二种格式的 erase() 方法</span></span><br><span class=line>    set<<span class=keyword>int</span>>::iterator iter = myset.<span class=built_in>erase</span>(myset.<span class=built_in>begin</span>()); <span class=comment>//删除元素 1，myset={3,4,5}</span></span><br><span class=line>    cout << <span class=string>"2、myset size = "</span> << myset.<span class=built_in>size</span>() << endl;</span><br><span class=line>    cout << <span class=string>"iter->"</span> << *iter << endl;</span><br><span class=line></span><br><span class=line>    <span class=comment>//3) 调用第三种格式的 erase() 方法</span></span><br><span class=line>    set<<span class=keyword>int</span>>::iterator iter2 = myset.<span class=built_in>erase</span>(myset.<span class=built_in>begin</span>(), --myset.<span class=built_in>end</span>());<span class=comment>//删除元素 3,4，myset={5}</span></span><br><span class=line>    cout << <span class=string>"3、myset size = "</span> << myset.<span class=built_in>size</span>() << endl;</span><br><span class=line>    cout << <span class=string>"iter2->"</span> << *iter2 << endl;</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTset></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring></span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>    <span class=comment>//创建空set容器</span></span><br><span class=line>    std::set&LTstd::string> myset;</span><br><span class=line>    <span class=comment>//空set容器不存储任何元素</span></span><br><span class=line>    cout << <span class=string>"1、myset size = "</span> << myset.<span class=built_in>size</span>() << endl;</span><br><span class=line>    <span class=comment>//向myset容器中插入新元素</span></span><br><span class=line>    myset.<span class=built_in>insert</span>(<span class=string>"http://c.biancheng.net/java/"</span>);</span><br><span class=line>    myset.<span class=built_in>insert</span>(<span class=string>"http://c.biancheng.net/stl/"</span>);</span><br><span class=line>    myset.<span class=built_in>insert</span>(<span class=string>"http://c.biancheng.net/python/"</span>);</span><br><span class=line>    cout << <span class=string>"2、myset size = "</span> << myset.<span class=built_in>size</span>() << endl;</span><br><span class=line>    <span class=comment>//利用双向迭代器，遍历myset</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>auto</span> iter = myset.<span class=built_in>begin</span>(); iter != myset.<span class=built_in>end</span>(); ++iter) {</span><br><span class=line>        cout << *iter << endl;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure> <div class=table-container><table><thead><tr><th style=text-align:left>函数<th>介绍<tbody><tr><td style=text-align:left>upper_bound(val)<td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。<tr><td style=text-align:left>equal_range(val)<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。<tr><td style=text-align:left>lower_bound(val)<td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</table></div> <p>注意count,find等新的成员函数</p> <p>此外关联式容器还有multimap和multiset,这里不介绍了.</p> <h4 id=无序关联式容器><a class=headerlink href=#无序关联式容器 title=无序关联式容器></a>无序关联式容器</h4><p>和关联式容器一样，无序容器也使用键值对（pair 类型）的方式存储数据。不过，它们有本质上的不同：</p> <ul><li>关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构；<li>无序容器的底层实现采用的是哈希表的存储结构。</ul> <div class=table-container><table><thead><tr><th>无序容器<th>功能<tbody><tr><td>unordered_map<td>存储键值对 <key , value> 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。 <tr><td>unordered_multimap<td>和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。</tr> <tr><td>unordered_set<td>不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。</tr> <tr><td>unordered_multiset</tr> <p>总的来说，实际场景中如果涉及大量遍历容器的操作，建议首选关联式容器；反之，如果更多的操作是通过键获取对应的值，则应首选无序容器。</p> <figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunordered_map></span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>    <span class=comment>//创建并初始化一个 unordered_map 容器，其存储的 &LTstring,string> 类型的键值对</span></span><br><span class=line>    std::unordered_map&LTstd::string, std::string> my_uMap{</span><br><span class=line>        {<span class=string>"C语言教程"</span>,<span class=string>"http://c.biancheng.net/c/"</span>},</span><br><span class=line>        {<span class=string>"Python教程"</span>,<span class=string>"http://c.biancheng.net/python/"</span>},</span><br><span class=line>        {<span class=string>"Java教程"</span>,<span class=string>"http://c.biancheng.net/java/"</span>} };</span><br><span class=line>    <span class=comment>//查找指定键对应的值，效率比关联式容器高</span></span><br><span class=line>    string str = my_uMap.<span class=built_in>at</span>(<span class=string>"C语言教程"</span>);</span><br><span class=line>    cout << <span class=string>"str = "</span> << str << endl;</span><br><span class=line></span><br><span class=line>    <span class=comment>//使用迭代器遍历哈希容器，效率不如关联式容器</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>auto</span> iter = my_uMap.<span class=built_in>begin</span>(); iter != my_uMap.<span class=built_in>end</span>(); ++iter)</span><br><span class=line>    {</span><br><span class=line>        <span class=comment>//pair 类型键值对分为 2 部分</span></span><br><span class=line>        cout << iter->first << <span class=string>" "</span> << iter->second << endl;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure> <h2 id=迭代器><a class=headerlink href=#迭代器 title=迭代器></a>迭代器</h2><p>迭代器是cpp STL库的概念,要访问顺序容器和关联容器中的元素，需要通过“迭代器（iterator）”进行。迭代器是一个变量，相当于容器</p> <p>和操纵容器的算法之间的中介。迭代器可以指向容器中的某个元素，通过迭代器就可以读写它指向的元素。从这一点上看，迭代器和<a href=http://c.biancheng.net/c/80/ rel=noopener target=_blank>指针</a>类似.</p> <p>通过迭代器可以读取它指向的元素，<code>*迭代器名</code>就表示迭代器指向的元素。通过非常量迭代器还能修改其指向的元素。</p> <p>迭代器都可以进行<code>++</code>操作。反向迭代器和正向迭代器的区别在于：</p> <ul><li>对正向迭代器进行<code>++</code>操作时，迭代器会指向容器中的后一个元素；<li>而对反向迭代器进行<code>++</code>操作时，迭代器会指向容器中的前一个元素</ul> <h3 id=迭代器的分类><a class=headerlink href=#迭代器的分类 title=迭代器的分类></a>迭代器的分类</h3><p>常用的迭代器按功能强弱分为输入、输出、正向、双向、随机访问五种，这里只介绍常用的三种。</p> <p>1) 正向迭代器。假设 p 是一个正向迭代器，则 p 支持以下操作：++p，p++，*p。此外，两个正向迭代器可以互相赋值，还可以用<code>==</code>和<code>!=</code>运算符进行比较。</p> <p>2) 双向迭代器。双向迭代器具有正向迭代器的全部功能。除此之外，若 p 是一个双向迭代器，则<code>--p</code>和<code>p--</code>都是有定义的。<code>--p</code>使得 p 朝和<code>++p</code>相反的方向移动。</p> <p>3) 随机访问迭代器。随机访问迭代器具有双向迭代器的全部功能。若 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p> <ul><li>p+=i：使得 p 往后移动 i 个元素。<li>p-=i：使得 p 往前移动 i 个元素。<li>p+i：返回 p 后面第 i 个元素的迭代器。<li>p-i：返回 p 前面第 i 个元素的迭代器。<li>p[i]：返回 p 后面第 i 个元素的引用</ul> <div class=table-container><table><thead><tr><th>容器<th>迭代器功能<tbody><tr><td>vector<td>随机访问<tr><td>deque<td>随机访问<tr><td>list<td>双向<tr><td>set / multiset<td>双向<tr><td>map / multimap<td>双向<tr><td>stack<td>不支持迭代器<tr><td>queue<td>不支持迭代器<tr><td>priority_queue<td>不支持迭代器</table></div> <h2 id=迭代器的辅助函数><a class=headerlink href=#迭代器的辅助函数 title=迭代器的辅助函数></a>迭代器的辅助函数</h2><p>STL 中有用于操作迭代器的三个函数模板，它们是：</p> <ul><li>advance(p, n)：使迭代器 p 向前或向后移动 n 个元素。<li>dis<a href=http://c.biancheng.net/ref/tan.html rel=noopener target=_blank>tan</a>ce(p, q)：计算两个迭代器之间的距离，即迭代器 p 经过多少次 + + 操作后和迭代器 q 相等。如果调用时 p 已经指向 q 的后面，则这个函数会陷入死循环。<li>iter_swap(p, q)：用于交换两个迭代器 p、q 指向的值。</ul> <figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTlist></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTalgorithm></span> <span class=comment>//要使用操作迭代器的函数模板，需要包含此文件</span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>    <span class=keyword>int</span> a[<span class=number>5</span>] = { <span class=number>1</span>, <span class=number>2</span>, <span class=number>3</span>, <span class=number>4</span>, <span class=number>5</span> };</span><br><span class=line>    list <<span class=keyword>int</span>> <span class=built_in>lst</span>(a, a+<span class=number>5</span>);</span><br><span class=line>    list <<span class=keyword>int</span>>::iterator p = lst.<span class=built_in>begin</span>();</span><br><span class=line>    <span class=built_in>advance</span>(p, <span class=number>2</span>);  <span class=comment>//p向后移动两个元素，指向3</span></span><br><span class=line>    cout << <span class=string>"1)"</span> << *p << endl;  <span class=comment>//输出 1)3</span></span><br><span class=line>    <span class=built_in>advance</span>(p, <span class=number>-1</span>);  <span class=comment>//p向前移动一个元素，指向2</span></span><br><span class=line>    cout << <span class=string>"2)"</span> << *p << endl;  <span class=comment>//输出 2)2</span></span><br><span class=line>    list<<span class=keyword>int</span>>::iterator q = lst.<span class=built_in>end</span>();</span><br><span class=line>    q--;  <span class=comment>//q 指向 5</span></span><br><span class=line>    cout << <span class=string>"3)"</span> << <span class=built_in>distance</span>(p, q) << endl;  <span class=comment>//输出 3)3</span></span><br><span class=line>    <span class=built_in>iter_swap</span>(p, q); <span class=comment>//交换 2 和 5</span></span><br><span class=line>    cout << <span class=string>"4)"</span>;</span><br><span class=line>    <span class=keyword>for</span> (p = lst.<span class=built_in>begin</span>(); p != lst.<span class=built_in>end</span>(); ++p)</span><br><span class=line>        cout << *p << <span class=string>" "</span>;</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure> <link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script> <div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div> <div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div> <div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a href=https://www.sekyoro.top/2023/03/05/STL%E5%AD%A6%E4%B9%A0/ title=STL学习>https://www.sekyoro.top/2023/03/05/STL学习/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div> <div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div> <footer class=post-footer><div class=post-tags><a href=/tags/cpp/ rel=tag><i class="fa fa-tag"></i> cpp</a><a href=/tags/stl/ rel=tag><i class="fa fa-tag"></i> stl</a></div><div class=post-nav><div class=post-nav-item><a href=/2023/03/04/%E6%B5%8F%E8%A7%88%E5%99%A8CORS%E5%92%8CCSP%E4%BB%8B%E7%BB%8D/ rel=prev title=浏览器CORS和CSP介绍> <i class="fa fa-chevron-left"></i> 浏览器CORS和CSP介绍 </a></div><div class=post-nav-item><a href=/2023/03/22/vscode-latex%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAtex%E5%86%99%E8%AE%BA%E6%96%87/ rel=next title=vscode+latex本地搭建tex写论文> vscode+latex本地搭建tex写论文 <i class="fa fa-chevron-right"></i> </a></div></div></footer> <!-- 评论区 --> <div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div> <script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script> <div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div> <aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%AE%B9%E5%99%A8><span class=nav-number>1.</span> <span class=nav-text>容器</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8><span class=nav-number>1.1.</span> <span class=nav-text>序列式容器</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#array><span class=nav-number>1.1.1.</span> <span class=nav-text>array</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#vector><span class=nav-number>1.1.2.</span> <span class=nav-text>vector</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#deque><span class=nav-number>1.1.3.</span> <span class=nav-text>deque</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#list><span class=nav-number>1.1.4.</span> <span class=nav-text>list</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8><span class=nav-number>1.2.</span> <span class=nav-text>关联式容器</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#1-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8D%B3%E5%88%9B%E5%BB%BA%E7%A9%BA%E7%9A%84-pair-%E5%AF%B9%E8%B1%A1pair><span class=nav-number></span> <span class=nav-text>1) 默认构造函数，即创建空的 pair 对象pair();</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#2-%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-2-%E4%B8%AA%E5%85%83%E7%B4%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90-pair-%E5%AF%B9%E8%B1%A1pair-const-first-type-amp-a-const-second-type-amp-b><span class=nav-number></span> <span class=nav-text>2) 直接使用 2 个元素初始化成 pair 对象pair (const first_type& a, const second_type& b);</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#3-%E6%8B%B7%E8%B4%9D%EF%BC%88%E5%A4%8D%E5%88%B6%EF%BC%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8D%B3%E5%80%9F%E5%8A%A9%E5%8F%A6%E4%B8%80%E4%B8%AA-pair-%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84-pair-%E5%AF%B9%E8%B1%A1template-pair-const-pair-amp-pr><span class=nav-number></span> <span class=nav-text>3) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象template pair (const pair& pr);</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#4-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0template-pair-pair-amp-amp-pr-5-%E4%BD%BF%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%EF%BC%8C%E5%88%9B%E5%BB%BA-pair-%E5%AF%B9%E8%B1%A1template-pair-U-amp-amp-a-V-amp-amp-b><span class=nav-number></span> <span class=nav-text>4) 移动构造函数template pair (pair&& pr);#5) 使用右值引用参数，创建 pair 对象template pair (U&& a, V&& b);</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#map><span class=nav-number>0.0.1.</span> <span class=nav-text>map</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#set><span class=nav-number>0.0.2.</span> <span class=nav-text>set</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8><span class=nav-number>0.0.3.</span> <span class=nav-text>无序关联式容器</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%BF%AD%E4%BB%A3%E5%99%A8><span class=nav-number>1.</span> <span class=nav-text>迭代器</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB><span class=nav-number>1.1.</span> <span class=nav-text>迭代器的分类</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0><span class=nav-number>2.</span> <span class=nav-text>迭代器的辅助函数</span></a></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>173</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>17</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>187</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a><li class=links-of-blogroll-item><a href=https://www.lllomh.com/ rel=noopener target=_blank title=https://www.lllomh.com/>芈渡</a></ul></div><div class="motion-element announcement"><div class=title>注意</div><p class=content>由于最近图床更新,可能有些图片显示不了.如果发现了有些图片无法显示影响阅读的,还烦请联系我,我有空补上.<p class=date>2023-10-6</div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>文章词云</h3><div class="widget tagcloud" id=myCanvasContainer><canvas height=250 id=resCanvas style=width:100% width=250><ul class=tag-list itemprop=keywords><li class=tag-list-item><a class=tag-list-link href=/tags/cpp/ rel=tag>cpp</a><span class=tag-list-count>1</span><li class=tag-list-item><a class=tag-list-link href=/tags/stl/ rel=tag>stl</a><span class=tag-list-count>1</span></ul></canvas></div></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside> <div id=sidebar-dimmer></div> <footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>1.2m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>18:32</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer> <script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script> <script src=/lib/anime.min.js></script> <script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script> <script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script> <script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script> <script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script> <script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script> <script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script> <script src=/js/utils.js></script> <script src=/js/motion.js></script> <script src=/js/schemes/pisces.js></script> <script src=/js/next-boot.js></script> <script src=/js/bookmark.js></script> <script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	'.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script> <script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script> <script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script> <script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script> <script src=/js/algolia-search.js></script> <script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script> <div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div> <script charset=utf-8 defer src=/js/tagcanvas.js></script> <script charset=utf-8 defer src=/js/tagcloud.js></script> <script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script> <script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script> <script src=/js/src/activate-power-mode.min.js></script> <script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script> 
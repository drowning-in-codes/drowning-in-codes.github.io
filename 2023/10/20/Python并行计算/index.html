<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"3G9PZZIKCH","apiKey":"8eb71f5ca3167e9ef3487882f10cfaad","indexName":"SekyoroSearch","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content=主要是因为Python库的设计很不错,通过这门语言进一步学习并行,涉及到进程线程以及异步编程等.建议是对性能有要求的利用其他语言实现,但是基本的思想、方法是一样的. name=description><meta content=article property=og:type><meta content=Python并行计算 property=og:title><meta content=https://www.sekyoro.top/2023/10/20/Python%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content=主要是因为Python库的设计很不错,通过这门语言进一步学习并行,涉及到进程线程以及异步编程等.建议是对性能有要求的利用其他语言实现,但是基本的思想、方法是一样的. property=og:description><meta content=zh_CN property=og:locale><meta content=https://python-parallel-programmning-cookbook.readthedocs.io/zh_CN/latest/_images/event.png property=og:image><meta content=https://python-parallel-programmning-cookbook.readthedocs.io/zh_CN/latest/_images/communication-channel.png property=og:image><meta content=https://python-parallel-programmning-cookbook.readthedocs.io/zh_CN/latest/_images/pooling-management.png property=og:image><meta content=2023-10-20T12:20:56.000Z property=article:published_time><meta content=2023-10-21T08:52:53.594Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content=parallel property=article:tag><meta content=summary name=twitter:card><meta content=https://python-parallel-programmning-cookbook.readthedocs.io/zh_CN/latest/_images/event.png name=twitter:image><link href=https://www.sekyoro.top/2023/10/20/Python%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>Python并行计算 | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2023/10/20/Python%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>Python并行计算</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2023-10-20 20:20:56" datetime=2023-10-20T20:20:56+08:00>2023-10-20</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-21 16:52:53" datetime=2023-10-21T16:52:53+08:00 itemprop=dateModified>2023-10-21</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>27k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>24 分钟</span> </span></div></header><div class=post-body itemprop=articleBody><p>主要是因为Python库的设计很不错,通过这门语言进一步学习并行,涉及到进程线程以及异步编程等.建议是对性能有要求的利用其他语言实现,但是基本的思想、方法是一样的.<br><span id=more></span><h2 id=创建进程-amp-amp-线程><a class=headerlink href=#创建进程-amp-amp-线程 title=创建进程&&线程></a>创建进程&&线程</h2><ul><li>进程可以包含多个并行运行的线程。<li>通常，操作系统创建和管理线程比进程更能节省CPU的资源。线程用于一些小任务，进程用于繁重的任务——运行应用程序。<li>同一个进程下的线程共享地址空间和其他资源，进程之间相互独立</ul><p>进程有自己的地址空间，数据栈和其他的辅助数据来追踪执行过程；系统会管理所有进程的执行，通过调度程序来分配计算资源等。<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=comment>## The following modules must be imported</span></span><br><span class=line><span class=keyword>import</span> os</span><br><span class=line><span class=keyword>import</span> sys</span><br><span class=line></span><br><span class=line><span class=comment>## this is the code to execute</span></span><br><span class=line>program = <span class=string>"python"</span></span><br><span class=line><span class=built_in>print</span>(<span class=string>"Process calling"</span>)</span><br><span class=line>arguments = [<span class=string>"called_Process.py"</span>]</span><br><span class=line></span><br><span class=line><span class=comment>## we call the called_Process.py script</span></span><br><span class=line>os.execvp(program, (program,) + <span class=built_in>tuple</span>(arguments))</span><br><span class=line><span class=built_in>print</span>(<span class=string>"Good Bye!!"</span>)</span><br></pre></table></figure><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=built_in>print</span>(<span class=string>"Hello Python Parallel Cookbook!!"</span>)</span><br><span class=line>closeInput = <span class=built_in>input</span>(<span class=string>"Press ENTER to exit"</span>)</span><br><span class=line><span class=built_in>print</span><span class=string>"Closing calledProcess"</span></span><br></pre></table></figure><p>线程创建<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre><td class=code><pre><span class=line><span class=comment># To use threads you need import Thread using the following code:</span></span><br><span class=line><span class=keyword>from</span> threading <span class=keyword>import</span> Thread</span><br><span class=line><span class=comment># Also we use the sleep function to make the thread "sleep"</span></span><br><span class=line><span class=keyword>from</span> time <span class=keyword>import</span> sleep</span><br><span class=line></span><br><span class=line><span class=comment># To create a thread in Python you'll want to make your class work as a thread.</span></span><br><span class=line><span class=comment># For this, you should subclass your class from the Thread class</span></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>CookBook</span>(<span class=params>Thread</span>):</span></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>__init__</span>(<span class=params>self</span>):</span></span><br><span class=line>        Thread.__init__(self)</span><br><span class=line>        self.message = <span class=string>"Hello Parallel Python CookBook!!\n"</span></span><br><span class=line></span><br><span class=line>    <span class=comment># this method prints only the message</span></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>print_message</span>(<span class=params>self</span>):</span></span><br><span class=line>        <span class=built_in>print</span>(self.message)</span><br><span class=line></span><br><span class=line>    <span class=comment># The run method prints ten times the message</span></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>run</span>(<span class=params>self</span>):</span></span><br><span class=line>        <span class=built_in>print</span>(<span class=string>"Thread Starting\n"</span>)</span><br><span class=line>        x = <span class=number>0</span></span><br><span class=line>        <span class=keyword>while</span> (x < <span class=number>10</span>):</span><br><span class=line>            self.print_message()</span><br><span class=line>            sleep(<span class=number>2</span>)</span><br><span class=line>            x += <span class=number>1</span></span><br><span class=line>        <span class=built_in>print</span>(<span class=string>"Thread Ended\n"</span>)</span><br><span class=line></span><br><span class=line><span class=comment># start the main process</span></span><br><span class=line><span class=built_in>print</span>(<span class=string>"Process Started"</span>)</span><br><span class=line></span><br><span class=line><span class=comment># create an instance of the HelloWorld class</span></span><br><span class=line>hello_Python = CookBook()</span><br><span class=line></span><br><span class=line><span class=comment># print the message...starting the thread</span></span><br><span class=line>hello_Python.start()</span><br><span class=line></span><br><span class=line><span class=comment># end the main process</span></span><br><span class=line><span class=built_in>print</span>(<span class=string>"Process Ended"</span>)</span><br></pre></table></figure><p>Python解释器并不完全是线程安全的。为了支持多线程的Python程序，CPython使用了一个叫做全局解释器锁（Global Interpreter Lock， GIL）的技术。这意味着同一时间只有一个线程可以执行Python代码；执行某一个线程一小段时间之后，Python会自动切换到下一个线程。GIL并没有完全解决线程安全的问题，如果多个线程试图使用共享数据，还是可能导致未确定的行为。<h2 id=线程的并行><a class=headerlink href=#线程的并行 title=线程的并行></a>线程的并行</h2><blockquote><p>在软件应用中使用最广泛的并发编程范例是多线程。通常，一个应用有一个进程，分成多个独立的线程，并行运行、互相配合，执行不同类型的任务。<p>线程是独立的处理流程，可以和系统的其他线程并行或并发地执行。多线程可以共享数据和资源，利用所谓的共享内存空间。线程和进程的具体实现取决于你要运行的操作系统，但是总体来讲，我们可以说线程是包含在进程中的，同一进程的多个不同的线程可以共享相同的资源。相比而言，进程之间不会共享资源。<p>每一个线程基本上包含3个元素：程序计数器，寄存器和栈。与同一进程的其他线程共享的资源基本上包括数据和系统资源。每一个线程也有自己的运行状态，可以和其他线程同步，这点和进程一样。线程的状态大体上可以分为ready,running,blocked。线程的典型应用是应用软件的并行化——为了充分利用现代的多核处理器，使每个核心可以运行单个线程。相比于进程，使用线程的优势主要是性能。相比之下，在进程之间切换上下文要比在统一进程的多线程之间切换上下文要重的多。</blockquote><p>多线程编程一般使用共享内容空间进行线程间的通讯。这就使管理内容空间成为多线程编程的重点和难点。<p>使用Python的<code>threading</code>模块管理多线程.<p>线程被创建之后并不会马上运行，需要手动调用 <code>start()</code> ， <code>join()</code> 让调用它的线程一直等待直到执行结束<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> threading</span><br><span class=line><span class=keyword>import</span> time</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>func</span>(<span class=params>i</span>):</span></span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"function called by thread %i"</span> % i)</span><br><span class=line>    <span class=keyword>return</span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>slowProcess</span>():</span></span><br><span class=line>    time.sleep(<span class=number>3</span>)</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"slow process done"</span>)</span><br><span class=line></span><br><span class=line>t = threading.Thread(target=slowProcess, args=())</span><br><span class=line>t.start()</span><br><span class=line>t.join()</span><br><span class=line>t = threading.Thread(target=func, args=(<span class=number>1</span>,))</span><br><span class=line>t.start()</span><br><span class=line><span class=built_in>print</span>(<span class=string>"process quit"</span>)</span><br></pre></table></figure><p>设置<code>t = threading.Thread(target=slowProcess, args=(),name="slowp")</code>线程名称<p>线程被创建之后并不会马上运行，需要手动调用 <code>start()</code>.此外<code>join()</code> 让<strong>调用它的线程一直等待直到执行结束</strong>（即阻塞调用它的主线程， <code>t</code> 线程执行结束，主线程才会继续执行）<p><code>threading.current_thread().name</code>访问执行当前代码的线程的名称.<p>主线程是<code>MainThread</code>. 实现多线程可以选择继承threading.Thread类或者直接使用<code>threading.Thread</code>方法<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line>exitFlag = <span class=number>0</span></span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>myThread</span>(<span class=params>threading.Thread</span>):</span></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>__init__</span>(<span class=params>self, threadID, name, counter</span>):</span></span><br><span class=line>        threading.Thread.__init__(self)</span><br><span class=line>        self.threadID = threadID</span><br><span class=line>        self.name = name</span><br><span class=line>        self.counter = counter</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>run</span>(<span class=params>self</span>):</span></span><br><span class=line>        <span class=built_in>print</span>(<span class=string>"starting "</span> + self.name)</span><br><span class=line>        print_time(self.name, self.counter, <span class=number>5</span>)</span><br><span class=line>        <span class=built_in>print</span>(<span class=string>"exiting "</span> + self.name)</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>print_time</span>(<span class=params>threadName, delay, counter</span>):</span></span><br><span class=line>    <span class=keyword>while</span> counter:</span><br><span class=line>        <span class=keyword>if</span> exitFlag:</span><br><span class=line>            _thread.exit()</span><br><span class=line>        time.sleep(delay)</span><br><span class=line>        <span class=built_in>print</span>(<span class=string>"%s:%s"</span> % (threadName, time.ctime(time.time())))</span><br><span class=line>        counter -= <span class=number>1</span></span><br><span class=line></span><br><span class=line></span><br><span class=line>thread1 = myThread(<span class=number>1</span>, <span class=string>"thread-1"</span>, <span class=number>1</span>)</span><br><span class=line>thread2 = myThread(<span class=number>2</span>, <span class=string>"thread-2"</span>, <span class=number>2</span>)</span><br><span class=line>thread1.start()</span><br><span class=line>thread2.start()</span><br><span class=line>thread1.join()</span><br><span class=line>thread2.join()</span><br></pre></table></figure><p><code>threading</code> 模块是创建和管理线程的首选形式。每一个线程都通过一个继承 <code>Thread</code> 类，重写 <code>run()</code> 方法来实现逻辑，这个方法是线程的入口。在主程序中，我们创建了多个 <code>myThread</code> 的类型实例，然后执行 <code>start()</code> 方法启动它们。调用 <code>Thread.__init__</code> 构造器方法是必须的，通过它我们可以给线程定义一些名字或分组之类的属性。调用 <code>start()</code> 之后线程变为活跃状态，并且持续直到 <code>run()</code> 结束，或者中间出现异常。所有的线程都执行完成之后，程序结束。<h3 id=线程的同步><a class=headerlink href=#线程的同步 title=线程的同步></a>线程的同步</h3><p>当两个或以上对共享内存的操作发生在并发线程中，并且至少有一个可以改变数据，又没有同步机制的条件下，就会产生竞争条件，可能会导致执行无效代码、bug、或异常行为。<h4 id=Lock锁同步><a class=headerlink href=#Lock锁同步 title=Lock锁同步></a>Lock锁同步</h4><p>竞争条件最简单的解决方法是使用锁。锁的操作非常简单，当一个线程需要访问部分共享内存时，它必须先获得锁才能访问。此线程对这部分共享资源使用完成之后，该线程必须释放锁，然后其他线程就可以拿到这个锁并访问这部分资源了。<p>使用lock同步线程,通过它我们可以将共享资源某一时刻的访问限制在单一线程或单一类型的线程上，线程必须得到锁才能使用资源，并且之后必须允许其他线程使用相同的资源。<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> threading</span><br><span class=line></span><br><span class=line>shared_resource_with_lock = <span class=number>0</span></span><br><span class=line>shared_resource_with_no_lock = <span class=number>0</span></span><br><span class=line></span><br><span class=line>COUNT = <span class=number>1000000</span></span><br><span class=line></span><br><span class=line>shared_resource_lock = threading.Lock()</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>increment_with_lock</span>():</span></span><br><span class=line>    <span class=keyword>global</span> shared_resource_with_lock</span><br><span class=line>    <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(COUNT):</span><br><span class=line>        shared_resource_lock.acquire()</span><br><span class=line>        shared_resource_with_lock += <span class=number>1</span></span><br><span class=line>        shared_resource_lock.release()</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>decrement_with_lock</span>():</span></span><br><span class=line>    <span class=keyword>global</span> shared_resource_with_lock</span><br><span class=line>    <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(COUNT):</span><br><span class=line>        shared_resource_lock.acquire()</span><br><span class=line>        shared_resource_with_lock  -=<span class=number>1</span></span><br><span class=line>        shared_resource_lock.release()</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>increment_without_lock</span>():</span></span><br><span class=line>    <span class=keyword>global</span> shared_resource_with_no_lock</span><br><span class=line>    <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(COUNT):</span><br><span class=line>        shared_resource_with_no_lock +=<span class=number>1</span></span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>decrement_without_lock</span>():</span></span><br><span class=line>    <span class=keyword>global</span> shared_resource_with_no_lock</span><br><span class=line>    <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(COUNT):</span><br><span class=line>        shared_resource_with_no_lock -=<span class=number>1</span></span><br><span class=line></span><br><span class=line><span class=keyword>if</span> __name__ == <span class=string>"__main__"</span>:</span><br><span class=line>    t1 = threading.Thread(target=increment_with_lock)</span><br><span class=line>    t2 = threading.Thread(target=decrement_with_lock)</span><br><span class=line>    t3 = threading.Thread(target=increment_without_lock)</span><br><span class=line>    t4 = threading.Thread(target=decrement_without_lock)</span><br><span class=line>    t1.start()</span><br><span class=line>    t2.start()</span><br><span class=line>    t3.start()</span><br><span class=line>    t4.start()</span><br><span class=line>    t1.join()</span><br><span class=line>    t2.join()</span><br><span class=line>    t3.join()</span><br><span class=line>    t4.join()</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"the value of shared variable with lock management is %s"</span> % shared_resource_with_lock)</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"the value of shared variable with race condition is %s"</span> % shared_resource_with_no_lock)</span><br></pre></table></figure><ul><li>锁有两种状态： locked（被某一线程拿到）和unlocked（可用状态）<li><p>我们有两个方法来操作锁： <code>acquire()</code> 和 <code>release()</code></p><li><p>如果状态是unlocked， 可以调用 <code>acquire()</code> 将状态改为locked</p><li>如果状态是locked， <code>acquire()</code> 会被block直到另一线程调用 <code>release()</code> 释放锁<li>如果状态是unlocked， 调用 <code>release()</code> 将导致 <code>RuntimError</code> 异常<li>如果状态是locked， 可以调用 <code>release()</code> 将状态改为unlocked</ul><blockquote><p>尽管理论上行得通，但是锁的策略不仅会导致有害的僵持局面。还会对应用程序的其他方面产生负面影响。这是一种保守的方法，经常会引起不必要的开销，也会限制程序的可扩展性和可读性。更重要的是，有时候需要对多进程共享的内存分配优先级，使用锁可能和这种优先级冲突。最后，从实践的经验来看，使用锁的应用将对debug带来不小的麻烦。所以，最好使用其他可选的方法确保同步读取共享内存，避免竞争条件。</blockquote><p>事实上我执行这段代码时跟线程是否join有关,基本上上面代码是否加锁都没有出问题<h4 id=RLock锁同步><a class=headerlink href=#RLock锁同步 title=RLock锁同步></a>RLock锁同步</h4><p>如果你想让只有拿到锁的线程才能释放该锁，那么应该使用 <code>RLock()</code> 对象。和 <code>Lock()</code> 对象一样， <code>RLock()</code> 对象有两个方法： <code>acquire()</code> 和 <code>release()</code> 。当你需要在类外面保证线程安全，又要在类内使用同样方法的时候 <code>RLock()</code> 就很实用了<blockquote><p>RLock其实叫做“Reentrant Lock”，就是可以重复进入的锁，也叫做“递归锁”。这种锁对比Lock有是三个特点：1. 谁拿到谁释放。如果线程A拿到锁，线程B无法释放这个锁，只有A可以释放；2. 同一线程可以多次拿到该锁，即可以acquire多次；3. acquire多少次就必须release多少次，只有最后一次release才能改变RLock的状态为unlocked</blockquote><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> threading</span><br><span class=line><span class=keyword>import</span> time</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Box</span>:</span></span><br><span class=line>    lock = threading.RLock()</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>__init__</span>(<span class=params>self</span>):</span></span><br><span class=line>        self.total_items = <span class=number>0</span></span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>execute</span>(<span class=params>self,n</span>):</span></span><br><span class=line>        Box.lock.acquire()</span><br><span class=line>        self.total_items += n</span><br><span class=line>        Box.lock.release()</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>add</span>(<span class=params>self</span>):</span></span><br><span class=line>        Box.lock.acquire()</span><br><span class=line>        self.execute(<span class=number>1</span>)</span><br><span class=line>        Box.lock.release()</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>remove</span>(<span class=params>self</span>):</span></span><br><span class=line>        Box.lock.acquire()</span><br><span class=line>        self.execute(-<span class=number>1</span>)</span><br><span class=line>        Box.lock.release()</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>adder</span>(<span class=params>box, items</span>):</span></span><br><span class=line>    <span class=keyword>while</span> items > <span class=number>0</span>:</span><br><span class=line>        <span class=built_in>print</span>(<span class=string>"adding 1 item in the box"</span>)</span><br><span class=line>        box.add()</span><br><span class=line>        time.sleep(<span class=number>1</span>)</span><br><span class=line>        items -= <span class=number>1</span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>remover</span>(<span class=params>box, items</span>):</span></span><br><span class=line>    <span class=keyword>while</span> items > <span class=number>0</span>:</span><br><span class=line>        <span class=built_in>print</span>(<span class=string>"removing 1 item in the box"</span>)</span><br><span class=line>        box.remove()</span><br><span class=line>        time.sleep(<span class=number>1</span>)</span><br><span class=line>        items -= <span class=number>1</span></span><br><span class=line></span><br><span class=line><span class=keyword>if</span> __name__ == <span class=string>'__main__'</span>:</span><br><span class=line>    items = <span class=number>5</span></span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"putting %s items in the box "</span> % items)</span><br><span class=line>    box = Box()</span><br><span class=line>    t1 = threading.Thread(target=adder, args=(box, items))</span><br><span class=line>    t2 = threading.Thread(target=remover, args=(box, items))</span><br><span class=line>    t1.start()</span><br><span class=line>    t2.start()</span><br><span class=line>    t1.join()</span><br><span class=line>    t2.join()</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"%s items still remain in the box "</span> % Box().total_items)</span><br></pre></table></figure><p>相比于Lock有一些更稳定的设定.<h4 id=信号量同步><a class=headerlink href=#信号量同步 title=信号量同步></a>信号量同步</h4><p>信号量是一个内部数据，用于标明当前的共享资源可以有多少并发读取。<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> threading</span><br><span class=line><span class=keyword>import</span> time</span><br><span class=line><span class=keyword>import</span> random</span><br><span class=line></span><br><span class=line></span><br><span class=line>semaphore = threading.Semaphore(<span class=number>0</span>)</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>consumer</span>():</span></span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"consumer is waiting."</span>)</span><br><span class=line>    semaphore.acquire()</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"consumer notify: consumed item number %s "</span> % item)</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>producer</span>():</span></span><br><span class=line>    <span class=keyword>global</span> item</span><br><span class=line>    time.sleep(<span class=number>10</span>)</span><br><span class=line>    item = random.randint(<span class=number>0</span>, <span class=number>1000</span>)</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"producer notify:produced item number %s"</span> % item)</span><br><span class=line>    semaphore.release()</span><br><span class=line></span><br><span class=line><span class=keyword>if</span> __name__ == <span class=string>'__main__'</span>:</span><br><span class=line>    <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>0</span>,<span class=number>5</span>):</span><br><span class=line>        t1 = threading.Thread(target=producer)</span><br><span class=line>        t2 = threading.Thread(target=consumer)</span><br><span class=line>        t1.start()</span><br><span class=line>        t2.start()</span><br><span class=line>        t1.join()</span><br><span class=line>        t2.join()</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"program terminated"</span>)</span><br></pre></table></figure><blockquote><p>信号量的一个特殊用法是互斥量。互斥量是初始值为1的信号量，可以实现数据、资源的互斥访问。<p>信号量在支持多线程的编程语言中依然应用很广，然而这可能导致死锁的情况。例如，现在有一个线程t1先等待信号量s1，然后等待信号量s2，而线程t2会先等待信号量s2，然后再等待信号量s1，这样就可能会发生死锁，导致t1等待s2，但是t2在等待s1。</blockquote><h4 id=条件进行同步><a class=headerlink href=#条件进行同步 title=条件进行同步></a>条件进行同步</h4><p>条件指的是应用程序状态的改变。这是另一种同步机制，其中某些线程在等待某一条件发生，其他的线程会在该条件发生的时候进行通知。一旦条件发生，线程会拿到共享资源的唯一权限<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br></pre><td class=code><pre><span class=line><span class=keyword>from</span> threading <span class=keyword>import</span> Thread, Condition</span><br><span class=line><span class=keyword>import</span> time</span><br><span class=line></span><br><span class=line>items = []</span><br><span class=line>condition = Condition()</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>consumer</span>(<span class=params>Thread</span>):</span></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>__init__</span>(<span class=params>self</span>):</span></span><br><span class=line>        Thread.__init__(self)</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>consume</span>(<span class=params>self</span>):</span></span><br><span class=line>        <span class=keyword>global</span> condition</span><br><span class=line>        <span class=keyword>global</span> items</span><br><span class=line>        condition.acquire()</span><br><span class=line>        <span class=keyword>if</span> <span class=built_in>len</span>(items) == <span class=number>0</span>:</span><br><span class=line>            condition.wait()</span><br><span class=line>            <span class=built_in>print</span>(<span class=string>"consumer notify: no item to consume"</span>)</span><br><span class=line>        items.pop()</span><br><span class=line>        <span class=built_in>print</span>(<span class=string>"consumer notify: consumed 1 item"</span>)</span><br><span class=line>        <span class=built_in>print</span>(<span class=string>"consumer notify: items to consume are "</span> + <span class=built_in>str</span>(<span class=built_in>len</span>(items)))</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>run</span>(<span class=params>self</span>):</span></span><br><span class=line>        <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>0</span>, <span class=number>20</span>):</span><br><span class=line>            time.sleep(<span class=number>10</span>)</span><br><span class=line>            self.consume()</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>producer</span>(<span class=params>Thread</span>):</span></span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>__init__</span>(<span class=params>self</span>):</span></span><br><span class=line>        Thread.__init__(self)</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>produce</span>(<span class=params>self</span>):</span></span><br><span class=line>        <span class=keyword>global</span> condition</span><br><span class=line>        <span class=keyword>global</span> items</span><br><span class=line>        condition.acquire()</span><br><span class=line>        <span class=keyword>if</span> <span class=built_in>len</span>(items) == <span class=number>10</span>:</span><br><span class=line>            condition.wait()</span><br><span class=line>            <span class=built_in>print</span>(<span class=string>"Producer notify : items producted are "</span> + <span class=built_in>str</span>(<span class=built_in>len</span>(items)))</span><br><span class=line>            <span class=built_in>print</span>(<span class=string>"Producer notify : stop the production!!"</span>)</span><br><span class=line>        items.append(<span class=number>1</span>)</span><br><span class=line>        <span class=built_in>print</span>(<span class=string>"Producer notify : total items producted "</span> + <span class=built_in>str</span>(<span class=built_in>len</span>(items)))</span><br><span class=line>        condition.notify()</span><br><span class=line>        condition.release()</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>run</span>(<span class=params>self</span>):</span></span><br><span class=line>        <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>0</span>, <span class=number>20</span>):</span><br><span class=line>            time.sleep(<span class=number>1</span>)</span><br><span class=line>            self.produce()</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>if</span> __name__ == <span class=string>"__main__"</span>:</span><br><span class=line>    producer = producer()</span><br><span class=line>    consumer = consumer()</span><br><span class=line>    producer.start()</span><br><span class=line>    consumer.start()</span><br><span class=line>    producer.join()</span><br><span class=line>    consumer.join()</span><br><span class=line></span><br></pre></table></figure><h4 id=事件同步><a class=headerlink href=#事件同步 title=事件同步></a>事件同步</h4><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> time</span><br><span class=line><span class=keyword>from</span> threading <span class=keyword>import</span> Thread,Event</span><br><span class=line><span class=keyword>import</span> random</span><br><span class=line></span><br><span class=line>items = []</span><br><span class=line>event = Event()</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>consumer</span>(<span class=params>Thread</span>):</span></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>__init__</span>(<span class=params>self,items,event</span>):</span></span><br><span class=line>        Thread.__init__(self)</span><br><span class=line>        self.items = items</span><br><span class=line>        self.event = event</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>run</span>(<span class=params>self</span>):</span></span><br><span class=line>        <span class=keyword>while</span> <span class=literal>True</span>:</span><br><span class=line>            time.sleep(<span class=number>10</span>)</span><br><span class=line>            self.event.wait()</span><br><span class=line>            item = self.items.pop()</span><br><span class=line>            <span class=built_in>print</span>(<span class=string>"consumer notify: consumed 1 item"</span>)</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>producer</span>(<span class=params>Thread</span>):</span></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>__init__</span>(<span class=params>self, items, event</span>):</span></span><br><span class=line>        Thread.__init__(self)</span><br><span class=line>        self.items = items</span><br><span class=line>        self.event = event</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>run</span>(<span class=params>self</span>):</span></span><br><span class=line>        <span class=keyword>global</span> item</span><br><span class=line>        <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>100</span>):</span><br><span class=line>            time.sleep(<span class=number>2</span>)</span><br><span class=line>            item = random.randint(<span class=number>0</span>, <span class=number>256</span>)</span><br><span class=line>            self.items.append(item)</span><br><span class=line>            <span class=built_in>print</span>(<span class=string>'Producer notify : item N° %d appended to list by %s'</span> % (item, self.name))</span><br><span class=line>            <span class=built_in>print</span>(<span class=string>'Producer notify : event set by %s'</span> % self.name)</span><br><span class=line>            self.event.<span class=built_in>set</span>()</span><br><span class=line>            <span class=built_in>print</span>(<span class=string>'Produce notify : event cleared by %s '</span>% self.name)</span><br><span class=line>            self.event.clear()</span><br><span class=line>            </span><br><span class=line><span class=keyword>if</span> __name__ == <span class=string>'__main__'</span>:</span><br><span class=line>    t1 = producer(items, event)</span><br><span class=line>    t2 = consumer(items, event)</span><br><span class=line>    t1.start()</span><br><span class=line>    t2.start()</span><br><span class=line>    t1.join()</span><br><span class=line>    t2.join()</span><br></pre></table></figure><p><img alt=../_images/event.png data-src=https://python-parallel-programmning-cookbook.readthedocs.io/zh_CN/latest/_images/event.png style=zoom:67%;><h4 id=使用with简化><a class=headerlink href=#使用with简化 title=使用with简化></a>使用with简化</h4><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> threading</span><br><span class=line><span class=keyword>import</span> logging</span><br><span class=line>logging.basicConfig(level=logging.DEBUG, <span class=built_in>format</span>=<span class=string>'(%(threadName)-10s) %(message)s'</span>,)</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>threading_with</span>(<span class=params>statement</span>):</span></span><br><span class=line>    <span class=keyword>with</span> statement:</span><br><span class=line>        logging.debug(<span class=string>'%s acquired via with'</span> % statement)</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>threading_not_with</span>(<span class=params>statement</span>):</span></span><br><span class=line>    statement.acquire()</span><br><span class=line>    <span class=keyword>try</span>:</span><br><span class=line>        logging.debug(<span class=string>'%s acquired directly'</span> % statement )</span><br><span class=line>    <span class=keyword>finally</span>:</span><br><span class=line>        statement.release()</span><br><span class=line></span><br><span class=line><span class=keyword>if</span> __name__ == <span class=string>'__main__'</span>:</span><br><span class=line>    <span class=comment># let's create a test battery</span></span><br><span class=line>    lock = threading.Lock()</span><br><span class=line>    rlock = threading.RLock()</span><br><span class=line>    condition = threading.Condition()</span><br><span class=line>    mutex = threading.Semaphore(<span class=number>1</span>)</span><br><span class=line>    threading_synchronization_list = [lock, rlock, condition, mutex]</span><br><span class=line>    <span class=comment># in the for cycle we call the threading_with e threading_no_with function</span></span><br><span class=line>    <span class=keyword>for</span> statement <span class=keyword>in</span> threading_synchronization_list :</span><br><span class=line>       t1 = threading.Thread(target=threading_with, args=(statement,))</span><br><span class=line>       t2 = threading.Thread(target=threading_not_with, args=(statement,))</span><br><span class=line>       t1.start()</span><br><span class=line>       t2.start()</span><br><span class=line>       t1.join()</span><br><span class=line>       t2.join()</span><br></pre></table></figure><p>此外,当线程之间共享资源时,可以利用上面的原语,也可以使用queue.队列操作起来更容易，也使多线程编程更安全，因为队列可以将资源的使用通过单线程进行完全控制，并且允许使用更加整洁和可读性更高的设计模式。<p>Queue常用的方法有以下四个：<ul><li><code>put()</code>: 往queue中放一个item<li><code>get()</code>: 从queue删除一个item，并返回删除的这个item<li><code>task_done()</code>: 每次item被处理的时候需要调用这个方法<li><code>join()</code>: 所有item都被处理之前一直阻塞</ul><h3 id=进程的并行><a class=headerlink href=#进程的并行 title=进程的并行></a>进程的并行</h3><p>由父进程创建子进程。父进程既可以在产生子进程之后继续异步执行，也可以暂停等待子进程创建完成之后再继续执行.<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> multiprocessing</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>foo</span>(<span class=params>i</span>):</span></span><br><span class=line>    <span class=built_in>print</span>(<span class=string>'called function in process:%s'</span> % i)</span><br><span class=line>    <span class=keyword>return</span></span><br><span class=line></span><br><span class=line><span class=keyword>if</span> __name__ == <span class=string>'__main__'</span>:</span><br><span class=line>    Process_jobs = []</span><br><span class=line>    <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>5</span>):</span><br><span class=line>        p = multiprocessing.Process(target=foo, args=(i,))</span><br><span class=line>        Process_jobs.append(p)</span><br><span class=line>        p.start()</span><br><span class=line>        p.join()</span><br></pre></table></figure><p>使用进程对象调用 <code>join()</code> 方法。如果没有 <code>join()</code> ，主进程退出之后子进程会留在idle中，必须手动杀死它们。<p>进程名字与获取与线程类似.<h4 id=后台运行进程><a class=headerlink href=#后台运行进程 title=后台运行进程></a>后台运行进程</h4><blockquote><p>如果需要处理比较巨大的任务，又不需要人为干预，将其作为后台进程执行是个非常常用的编程模型。此进程又可以和其他进程并发执行。通过Python的multiprocessing模块的后台进程选项，我们可以让进程在后台运行</blockquote><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> multiprocessing</span><br><span class=line><span class=keyword>import</span> time</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>foo</span>():</span></span><br><span class=line>    name = multiprocessing.current_process().name</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"Starting %s \n"</span> % name)</span><br><span class=line>    time.sleep(<span class=number>3</span>)</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"Exiting %s \n"</span> % name)</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>if</span> __name__ == <span class=string>'__main__'</span>:</span><br><span class=line>    background_process = multiprocessing.Process(name=<span class=string>"background_process"</span>, target=foo)</span><br><span class=line>    background_process.daemon = <span class=literal>True</span></span><br><span class=line>    no_background_process = multiprocessing.Process(name=<span class=string>"no_background_process"</span>, target=foo)</span><br><span class=line>    no_background_process.daemon = <span class=literal>False</span></span><br><span class=line>    background_process.start()</span><br><span class=line>    no_background_process.start()</span><br></pre></table></figure><p>为了在后台运行进程，我们设置 <code>daemon</code> 参数为 <code>True</code><p>在非后台运行的进程会看到一个输出，后台运行的没有输出，<strong>后台运行进程在主进程结束之后会自动结束</strong><blockquote><p>注意，后台进程不允许创建子进程。否则，当后台进程跟随父进程退出的时候，子进程会变成孤儿进程。另外，它们并不是Unix的守护进程或服务（daemons or services），所以当非后台进程退出，它们会被终结。</blockquote><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> threading</span><br><span class=line><span class=keyword>import</span> time</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>foo</span>():</span></span><br><span class=line>    <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>3</span>):</span><br><span class=line>        <span class=built_in>print</span>(<span class=string>'i={},foo thread daemon is {}'</span>.<span class=built_in>format</span>(i, threading.current_thread().daemon))</span><br><span class=line>        time.sleep(<span class=number>1</span>)</span><br><span class=line></span><br><span class=line></span><br><span class=line>t = threading.Thread(target=foo, name=<span class=string>'foo_thread'</span>, daemon=<span class=literal>True</span>) <span class=comment># set daemon to True to make it a daemon thread which will exit when the main thread exits</span></span><br><span class=line>t.start()</span><br><span class=line><span class=comment># t.join() important otherwise the main thread will exit before the foo thread</span></span><br><span class=line><span class=built_in>print</span>(<span class=string>"Main thread daemon is {}"</span>.<span class=built_in>format</span>(threading.current_thread().daemon))</span><br><span class=line><span class=built_in>print</span>(<span class=string>"Main Thread Exit."</span>)</span><br></pre></table></figure><h4 id=杀掉进程><a class=headerlink href=#杀掉进程 title=杀掉进程></a>杀掉进程</h4><p>可以使用 <code>terminate()</code> 方法立即杀死一个进程。另外，我们可以使用 <code>is_alive()</code> 方法来判断一个进程是否还存活。<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> multiprocessing</span><br><span class=line><span class=keyword>import</span> time</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>foo</span>():</span></span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"Starting function"</span>)</span><br><span class=line>    time.sleep(<span class=number>0.1</span>)</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"Finished function"</span>)</span><br><span class=line></span><br><span class=line><span class=keyword>if</span> __name__ == <span class=string>'__main__'</span>:</span><br><span class=line>    p = multiprocessing.Process(target=foo)</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>'Process before execution:'</span>, p, p.is_alive())</span><br><span class=line>    p.start()</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>'Process running:'</span>, p, p.is_alive())</span><br><span class=line>    p.terminate()</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>'Process terminated:'</span>, p, p.is_alive())</span><br><span class=line>    p.join()</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>'Process joined:'</span>, p, p.is_alive())</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>'Process exit code:'</span>, p.exitcode)</span><br></pre></table></figure><p>进程的 <code>ExitCode</code> 状态码（status code）验证进程已经结束， <code>ExitCode</code> 可能的值如下：<ul><li>== 0: 没有错误正常退出<li>> 0: 进程有错误，并以此状态码退出<li>< 0: 进程被 <code>-1 *</code> 的信号杀死并以此作为 ExitCode 退出</ul><h4 id=子类中使用进程><a class=headerlink href=#子类中使用进程 title=子类中使用进程></a>子类中使用进程</h4><p>实现一个自定义的进程子类，需要以下三步：<ul><li>定义 <code>Process</code> 的子类<li>覆盖 <code>__init__(self [,args])</code> 方法来添加额外的参数<li>覆盖 <code>run(self, [.args])</code> 方法来实现 <code>Process</code> 启动的时候执行的任务</ul><p>创建 <code>Porcess</code> 子类之后，你可以创建它的实例并通过 <code>start()</code> 方法启动它，启动之后会运行 <code>run()</code> 方法。<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=comment># -*- coding: utf-8 -*-</span></span><br><span class=line><span class=comment># 自定义子类进程</span></span><br><span class=line><span class=keyword>import</span> multiprocessing</span><br><span class=line><span class=keyword>import</span> timeit</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>MyProcess</span>(<span class=params>multiprocessing.Process</span>):</span></span><br><span class=line>        <span class=function><span class=keyword>def</span> <span class=title>run</span>(<span class=params>self</span>):</span></span><br><span class=line>                <span class=built_in>print</span> (<span class=string>'called run method in process: %s'</span> % self.name)</span><br><span class=line>                <span class=keyword>return</span></span><br><span class=line></span><br><span class=line><span class=keyword>if</span> __name__ == <span class=string>'__main__'</span>:</span><br><span class=line>    timestart = timeit.default_timer()</span><br><span class=line>    jobs = []</span><br><span class=line>    <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>5</span>):</span><br><span class=line>            p = MyProcess()</span><br><span class=line>            jobs.append(p)</span><br><span class=line>            p.start()</span><br><span class=line>            p.join()</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>'Time elapsed:'</span>, (timeit.default_timer() - timestart))</span><br></pre></table></figure><p><code>join()</code> 命令可以让主进程等待其他进程结束最后退出。<h4 id=进程中交换对象><a class=headerlink href=#进程中交换对象 title=进程中交换对象></a>进程中交换对象</h4><blockquote><p>并行应用常常需要在进程之间交换数据。Multiprocessing库有两个Communication Channel可以交换对象：队列(queue)和管道（pipe）</blockquote><p><img alt=../_images/communication-channel.png data-src=https://python-parallel-programmning-cookbook.readthedocs.io/zh_CN/latest/_images/communication-channel.png><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> multiprocessing</span><br><span class=line><span class=keyword>import</span> random</span><br><span class=line><span class=keyword>import</span> time</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Producer</span>(<span class=params>multiprocessing.Process</span>):</span></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>__init__</span>(<span class=params>self, queue</span>):</span></span><br><span class=line>        multiprocessing.Process.__init__(self)</span><br><span class=line>        self.queue = queue</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>run</span>(<span class=params>self</span>):</span></span><br><span class=line>        <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>10</span>):</span><br><span class=line>            item = random.randint(<span class=number>0</span>, <span class=number>256</span>)</span><br><span class=line>            self.queue.put(item)</span><br><span class=line>            <span class=built_in>print</span>(<span class=string>"Process Producer : item %d appended to queue %s"</span> % (item, self.name))</span><br><span class=line>            time.sleep(<span class=number>1</span>)</span><br><span class=line>            <span class=built_in>print</span>(<span class=string>"The size of queue is %s"</span> % self.queue.qsize())</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Consumer</span>(<span class=params>multiprocessing.Process</span>):</span></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>__init__</span>(<span class=params>self, queue</span>):</span></span><br><span class=line>        multiprocessing.Process.__init__(self)</span><br><span class=line>        self.queue = queue</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>run</span>(<span class=params>self</span>):</span></span><br><span class=line>        <span class=keyword>while</span> <span class=literal>True</span>:</span><br><span class=line>            <span class=keyword>if</span> self.queue.empty():</span><br><span class=line>                <span class=built_in>print</span>(<span class=string>"the queue is empty"</span>)</span><br><span class=line>                <span class=keyword>break</span></span><br><span class=line>            <span class=keyword>else</span>:</span><br><span class=line>                time.sleep(<span class=number>2</span>)</span><br><span class=line>                item = self.queue.get()</span><br><span class=line>                <span class=built_in>print</span>(<span class=string>'Process Consumer : item %d popped from by %s \n'</span> % (item, self.name))</span><br><span class=line>                time.sleep(<span class=number>1</span>)</span><br><span class=line></span><br><span class=line><span class=keyword>if</span> __name__ == <span class=string>'__main__'</span>:</span><br><span class=line>    queue = multiprocessing.Queue()</span><br><span class=line>    process_producer = Producer(queue)</span><br><span class=line>    process_consumer = Consumer(queue)</span><br><span class=line>    process_producer.start()</span><br><span class=line>    process_consumer.start()</span><br><span class=line>    process_producer.join()</span><br><span class=line>    process_consumer.join()</span><br></pre></table></figure><p>队列还有一个 <code>JoinableQueue</code> 子类，它有以下两个额外的方法：<ul><li><code>task_done()</code>: 此方法意味着之前入队的一个任务已经完成，比如， <code>get()</code> 方法从队列取回item之后调用。所以此方法只能被队列的消费者调用。<li><code>join()</code>: 此方法将进程阻塞，直到队列中的item全部被取出并执行。</ul><p>此外还可以通过Pipe交换对象.<h4 id=进程同步><a class=headerlink href=#进程同步 title=进程同步></a>进程同步</h4><p>多个进程可以协同工作来完成一项任务。通常需要共享数据。所以在多进程之间保持数据的一致性就很重要了。需要共享数据协同的进程必须以适当的策略来读写数据。相关的同步原语和线程的库很类似。<p>进程的同步原语如下：<ul><li><strong>Lock</strong>: 这个对象可以有两种装填：锁住的（locked）和没锁住的（unlocked）。一个Lock对象有两个方法， <code>acquire()</code> 和 <code>release()</code> ，来控制共享数据的读写权限。<li><strong>Event</strong>: 实现了进程间的简单通讯，一个进程发事件的信号，另一个进程等待事件的信号。 <code>Event</code> 对象有两个方法， <code>set()</code> 和 <code>clear()</code> ，来管理自己内部的变量。<li><strong>Condition</strong>: 此对象用来同步部分工作流程，在并行的进程中，有两个基本的方法： <code>wait()</code> 用来等待进程， <code>notify_all()</code> 用来通知所有等待此条件的进程。<li><strong>Semaphore</strong>: 用来共享资源，例如，支持固定数量的共享连接。<li><strong>Rlock</strong>: 递归锁对象。其用途和方法同 <code>Threading</code> 模块一样。<li><strong>Barrier</strong>: 将程序分成几个阶段，适用于有些进程必须在某些特定进程之后执行。处于障碍（Barrier）之后的代码不能同处于障碍之前的代码并行。</ul><figure class="highlight reasonml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line>import multiprocessing</span><br><span class=line>from multiprocessing import Barrier, Lock, Process</span><br><span class=line>from time import time</span><br><span class=line>from datetime import datetime</span><br><span class=line></span><br><span class=line>def test<span class=constructor>_with_barrier(<span class=params>synchronizer</span>, <span class=params>serializer</span>)</span>:</span><br><span class=line>    name = multiprocessing.current<span class=constructor>_process()</span>.name</span><br><span class=line>    synchronizer.wait<span class=literal>()</span></span><br><span class=line>    now = time<span class=literal>()</span></span><br><span class=line>    <span class=keyword>with</span> serializer:</span><br><span class=line>        print(<span class=string>"process %s ----> %s"</span> % (name, datetime.fromtimestamp(now)))</span><br><span class=line></span><br><span class=line>def test<span class=constructor>_without_barrier()</span>:</span><br><span class=line>    name = multiprocessing.current<span class=constructor>_process()</span>.name</span><br><span class=line>    now = time<span class=literal>()</span></span><br><span class=line>    print(<span class=string>"process %s ----> %s"</span> % (name, datetime.fromtimestamp(now)))</span><br><span class=line></span><br><span class=line><span class=keyword>if</span> __name__<span class=operator> == </span>'__main__':</span><br><span class=line>    synchronizer = <span class=constructor>Barrier(2)</span></span><br><span class=line>    serializer = <span class=constructor>Lock()</span></span><br><span class=line>    <span class=constructor>Process(<span class=params>name</span>='<span class=params>p1</span> - <span class=params>test_with_barrier</span>', <span class=params>target</span>=<span class=params>test_with_barrier</span>, <span class=params>args</span>=(<span class=params>synchronizer</span>,<span class=params>serializer</span>)</span>).start<span class=literal>()</span></span><br><span class=line>    <span class=constructor>Process(<span class=params>name</span>='<span class=params>p2</span> - <span class=params>test_with_barrier</span>', <span class=params>target</span>=<span class=params>test_with_barrier</span>, <span class=params>args</span>=(<span class=params>synchronizer</span>,<span class=params>serializer</span>)</span>).start<span class=literal>()</span></span><br><span class=line>    <span class=constructor>Process(<span class=params>name</span>='<span class=params>p3</span> - <span class=params>test_without_barrier</span>', <span class=params>target</span>=<span class=params>test_without_barrier</span>)</span>.start<span class=literal>()</span></span><br><span class=line>    <span class=constructor>Process(<span class=params>name</span>='<span class=params>p4</span> - <span class=params>test_without_barrier</span>', <span class=params>target</span>=<span class=params>test_without_barrier</span>)</span>.start<span class=literal>()</span></span><br></pre></table></figure><h4 id=进程之间管理状态><a class=headerlink href=#进程之间管理状态 title=进程之间管理状态></a>进程之间管理状态</h4><p>Python的多进程模块提供了在所有的用户间管理共享信息的管理者(Manager)。一个管理者对象控制着持有Python对象的服务进程，并允许其它进程操作共享对象。<p>管理者有以下特性：<ul><li>它控制着管理共享对象的服务进程<li>它确保当某一进程修改了共享对象之后，所有的进程拿到额共享对象都得到了更新</ul><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> multiprocessing</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>worker</span>(<span class=params>dictionary,key,item</span>):</span></span><br><span class=line>    dictionary[key] = item</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"key = %d value = %d"</span> %(key,item))</span><br><span class=line></span><br><span class=line><span class=keyword>if</span> __name__ == <span class=string>'__main__'</span>:</span><br><span class=line>    mgr = multiprocessing.Manager()</span><br><span class=line>    dictionary = mgr.<span class=built_in>dict</span>()</span><br><span class=line>    jobs = [ multiprocessing.Process(target=worker,args=(dictionary,i,i*<span class=number>2</span>)) <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>10</span>)]</span><br><span class=line>    <span class=keyword>for</span> j <span class=keyword>in</span> jobs:</span><br><span class=line>        j.start()</span><br><span class=line>    <span class=keyword>for</span> j <span class=keyword>in</span>  jobs:</span><br><span class=line>        j.join()</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>'Results:'</span>,dictionary)</span><br></pre></table></figure><h4 id=使用进程池><a class=headerlink href=#使用进程池 title=使用进程池></a>使用进程池</h4><p>多进程库提供了 <code>Pool</code> 类来实现简单的多进程任务。 <code>Pool</code> 类有以下方法：<ul><li><code>apply()</code>: 直到得到结果之前一直阻塞。<li><code>apply_async()</code>: 这是 <code>apply()</code> 方法的一个变体，返回的是一个result对象。这是一个异步的操作，在所有的子类执行之前不会锁住主进程。<li><code>map()</code>: 这是内置的 <code>map()</code> 函数的并行版本。在得到结果之前一直阻塞，此方法将可迭代的数据的每一个元素作为进程池的一个任务来执行。<li><code>map_async()</code>: 这是 <code>map()</code> 方法的一个变体，返回一个result对象。如果指定了回调函数，回调函数应该是callable的，并且只接受一个参数。当result准备好时会自动调用回调函数（除非调用失败）。回调函数应该立即完成，否则，持有result的进程将被阻塞。</ul><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> multiprocessing</span><br><span class=line><span class=keyword>import</span> os</span><br><span class=line><span class=keyword>import</span> time</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>function_square</span>(<span class=params>data</span>):</span></span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"Hi"</span>)</span><br><span class=line>    time.sleep(<span class=number>12</span>)</span><br><span class=line>    result = data*data</span><br><span class=line>    <span class=built_in>print</span>(multiprocessing.current_process().pid)</span><br><span class=line>    <span class=keyword>return</span> result</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>if</span> __name__ == <span class=string>'__main__'</span>:</span><br><span class=line>    inputs = <span class=built_in>list</span>(<span class=built_in>range</span>(<span class=number>100</span>))</span><br><span class=line>    pool = multiprocessing.Pool(<span class=number>2</span>)</span><br><span class=line>    pool_outputs = pool.map_async(function_square, inputs)</span><br><span class=line>    pool.close()</span><br><span class=line>    pool.join()</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>'Pool:'</span>, pool_outputs)</span><br><span class=line>    <span class=comment># p.daemon = True</span></span><br><span class=line></span><br></pre></table></figure><h3 id=异步编程><a class=headerlink href=#异步编程 title=异步编程></a>异步编程</h3><h4 id=concurrent-futures><a class=headerlink href=#concurrent-futures title=concurrent.futures></a>concurrent.futures</h4><p><code>concurrent.futures</code> 模块，这个模块具有线程池和进程池、管理并行编程任务、处理非确定性的执行流程、进程/线程同步等功能。<p>此模块由以下部分组成：<ul><li><code>concurrent.futures.Executor</code>: 这是一个虚拟基类，提供了异步执行的方法。<li><code>submit(function, argument)</code>: 调度函数（可调用的对象）的执行，将 <code>argument</code> 作为参数传入。<li><code>map(function, argument)</code>: 将 <code>argument</code> 作为参数执行函数，以 <strong>异步</strong> 的方式。<li><code>shutdown(Wait=True)</code>: 发出让执行者释放所有资源的信号。<li><code>concurrent.futures.Future</code>: 其中包括函数的异步执行。Future对象是submit任务（即带有参数的functions）到executor的实例。</ul><p>Executor是抽象类，可以通过子类访问，即线程或进程的 <code>ExecutorPools</code> 。因为，线程或进程的实例是依赖于资源的任务，所以最好以“池”的形式将他们组织在一起，作为可以重用的launcher或executor。<blockquote><p>线程池或进程池是用于在程序中优化和简化线程/进程的使用。通过池，你可以提交任务给executor。池由两部分组成，一部分是内部的队列，存放着待执行的任务；另一部分是一系列的进程或线程，用于执行这些任务。池的概念主要目的是为了重用：让线程或进程在生命周期内可以多次使用。它减少了创建创建线程和进程的开销，提高了程序性能。重用不是必须的规则，但它是程序员在应用中使用池的主要原因。</blockquote><p><img alt=../_images/pooling-management.png data-src=https://python-parallel-programmning-cookbook.readthedocs.io/zh_CN/latest/_images/pooling-management.png style=zoom:67%;><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> concurrent.futures</span><br><span class=line><span class=keyword>import</span> time</span><br><span class=line></span><br><span class=line>number_list = [i <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>10</span>)]</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>evaluate_item</span>(<span class=params>x</span>):</span></span><br><span class=line>    result_item = count(x)</span><br><span class=line>    <span class=keyword>return</span> result_item</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>count</span>(<span class=params>number</span>):</span></span><br><span class=line>    <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>0</span>, <span class=number>10000000</span>):</span><br><span class=line>        i += <span class=number>1</span></span><br><span class=line>    <span class=keyword>return</span> i * number</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>if</span> __name__ == <span class=string>'__main__'</span>:</span><br><span class=line>    start_time = time.time()</span><br><span class=line>    <span class=keyword>for</span> item <span class=keyword>in</span> number_list:</span><br><span class=line>        <span class=built_in>print</span>(evaluate_item(item))</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"Sequential execution in "</span> + <span class=built_in>str</span>(time.time() - start_time), <span class=string>"seconds"</span>)</span><br><span class=line>    start_time_1 = time.time()</span><br><span class=line>    <span class=keyword>with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class=number>5</span>) <span class=keyword>as</span> executor:</span><br><span class=line>        futures = [executor.submit(evaluate_item, item) <span class=keyword>for</span> item <span class=keyword>in</span> number_list]</span><br><span class=line>        <span class=keyword>for</span> future <span class=keyword>in</span> concurrent.futures.as_completed(futures):</span><br><span class=line>            <span class=built_in>print</span>(future.result())</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"Thread pool execution in "</span> + <span class=built_in>str</span>(time.time() - start_time_1), <span class=string>"seconds"</span>)</span><br><span class=line>    start_time_2 = time.time()</span><br><span class=line>    <span class=keyword>with</span> concurrent.futures.ProcessPoolExecutor(max_workers=<span class=number>5</span>) <span class=keyword>as</span> executor:</span><br><span class=line>        futures = [executor.submit(evaluate_item, item) <span class=keyword>for</span> item <span class=keyword>in</span> number_list]</span><br><span class=line>        <span class=keyword>for</span> future <span class=keyword>in</span> concurrent.futures.as_completed(futures):</span><br><span class=line>            <span class=built_in>print</span>(future.result())</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"Process pool execution in "</span> + <span class=built_in>str</span>(time.time() - start_time_2), <span class=string>"seconds"</span>)</span><br><span class=line></span><br></pre></table></figure><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> concurrent.futures</span><br><span class=line></span><br><span class=line><span class=comment># 定义一个计算平方的函数</span></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>square</span>(<span class=params>x</span>):</span></span><br><span class=line>    <span class=keyword>return</span> x * x</span><br><span class=line></span><br><span class=line><span class=comment># 创建一个ThreadPoolExecutor对象，设置线程池中的线程数量为2</span></span><br><span class=line><span class=keyword>with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class=number>2</span>) <span class=keyword>as</span> executor:</span><br><span class=line>    <span class=comment># 提交任务给线程池，并获取Future对象</span></span><br><span class=line>    future1 = executor.submit(square, <span class=number>5</span>)</span><br><span class=line>    future2 = executor.submit(square, <span class=number>8</span>)</span><br><span class=line></span><br><span class=line>    <span class=comment># 获取任务的执行结果</span></span><br><span class=line>    result1 = future1.result()</span><br><span class=line>    result2 = future2.result()</span><br><span class=line></span><br><span class=line>    <span class=comment># 打印结果</span></span><br><span class=line>    <span class=built_in>print</span>(<span class=string>f"Result 1: <span class=subst>{result1}</span>"</span>)</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>f"Result 2: <span class=subst>{result2}</span>"</span>)</span><br></pre></table></figure><h4 id=Asyncio管理事件循环><a class=headerlink href=#Asyncio管理事件循环 title=Asyncio管理事件循环></a>Asyncio管理事件循环</h4><p>Python的Asyncio模块提供了管理事件、协程、任务和线程的方法，以及编写并发代码的原语。此模块的主要组件和概念包括：<ul><li><strong>事件循环</strong>: 在Asyncio模块中，每一个进程都有一个事件循环。<li><strong>协程</strong>: 这是子程序的泛化概念。协程可以在执行期间暂停，这样就可以等待外部的处理（例如IO）完成之后，从之前暂停的地方恢复执行。<li><strong>Futures</strong>: 定义了 <code>Future</code> 对象，和 <code>concurrent.futures</code> 模块一样，表示尚未完成的计算。<li><strong>Tasks</strong>: 这是Asyncio的子类，用于封装和管理并行模式下的协程。</ul><figure class="highlight isbl"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=variable><span class=keyword>while</span></span> (<span class=number>1</span>) {</span><br><span class=line>    <span class=variable>events</span> = <span class=function><span class=title>getEvents</span>();</span></span><br><span class=line><span class=function>    <span class=variable>for</span> (<span class=variable>e</span> <span class=variable><span class=keyword>in</span></span> <span class=variable>events</span>)</span></span><br><span class=line>        <span class=function><span class=title>processEvent</span>(<span class=variable>e</span>);</span></span><br><span class=line><span class=function>}</span></span><br></pre></table></figure><blockquote><p><strong>可以产生事件的实体叫做事件源</strong>，<strong>能处理事件的实体叫做事件处理者</strong>。此外，<strong>还有一些第三方实体叫做事件循环</strong>。它的作用是管理所有的事件，在整个程序运行过程中不断循环执行，追踪事件发生的顺序将它们放到队列中，当主线程空闲的时候，调用相应的事件处理者处理事件。</blockquote><p>Asyncio提供了一下方法来管理事件循环：<ul><li><code>loop = get_event_loop()</code>: 得到当前上下文的事件循环。<li><code>loop.call_later(time_delay, callback, argument)</code>: 延后 <code>time_delay</code> 秒再执行 <code>callback</code> 方法。<li><code>loop.call_soon(callback, argument)</code>: 尽可能快调用 <code>callback</code>, <code>call_soon()</code> 函数结束，主线程回到事件循环之后就会马上调用 <code>callback</code> 。<li><code>loop.time()</code>: 以float类型返回当前时间循环的内部时间。<li><code>asyncio.set_event_loop()</code>: 为当前上下文设置事件循环。<li><code>asyncio.new_event_loop()</code>: 根据此策略创建一个新的时间循环并返回。<li><code>loop.run_forever()</code>: 在调用 <code>stop()</code> 之前将一直运行。</ul><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> asyncio</span><br><span class=line><span class=keyword>import</span> datetime</span><br><span class=line><span class=keyword>import</span> time</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>function_1</span>(<span class=params>end_time,loop</span>):</span></span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"function_1 called"</span>)</span><br><span class=line>    <span class=keyword>if</span> (loop.time() + <span class=number>1.0</span>) < end_time:</span><br><span class=line>        loop.call_later(<span class=number>1</span>, function_2, end_time,loop)</span><br><span class=line>    <span class=keyword>else</span>:</span><br><span class=line>        loop.stop()</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>function_2</span>(<span class=params>end_time,loop</span>):</span></span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"function_2 called"</span>)</span><br><span class=line>    <span class=keyword>if</span> loop.time() + <span class=number>1.0</span> < end_time:</span><br><span class=line>        loop.call_later(<span class=number>1</span>, function_3, end_time,loop)</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>function_3</span>(<span class=params>end_time, loop</span>):</span></span><br><span class=line>    <span class=built_in>print</span> (<span class=string>"function_3 called"</span>)</span><br><span class=line>    <span class=keyword>if</span> (loop.time() + <span class=number>1.0</span>) < end_time:</span><br><span class=line>        loop.call_later(<span class=number>1</span>, function_1, end_time, loop)</span><br><span class=line>    <span class=keyword>else</span>:</span><br><span class=line>        loop.stop()</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>function_4</span>(<span class=params>end_time, loop</span>):</span></span><br><span class=line>    <span class=built_in>print</span> (<span class=string>"function_5 called"</span>)</span><br><span class=line>    <span class=keyword>if</span> (loop.time() + <span class=number>1.0</span>) < end_time:</span><br><span class=line>        loop.call_later(<span class=number>1</span>, function_4, end_time, loop)</span><br><span class=line>    <span class=keyword>else</span>:</span><br><span class=line>        loop.stop()</span><br><span class=line></span><br><span class=line><span class=keyword>if</span> __name__ == <span class=string>'__main__'</span>:</span><br><span class=line>    loop = asyncio.get_event_loop()</span><br><span class=line>    end_loop = loop.time() + <span class=number>9.0</span></span><br><span class=line>    loop.call_soon(function_1, end_loop,loop)</span><br><span class=line>    loop.run_forever()</span><br><span class=line>    loop.close()</span><br><span class=line></span><br></pre></table></figure><h4 id=Asyncio管理协程><a class=headerlink href=#Asyncio管理协程 title=Asyncio管理协程></a>Asyncio管理协程</h4><p>子程序不能单独执行，只能在主程序的请求下执行，主程序负责协调使用各个子程序。协程就是子程序的泛化。和子程序一样的事，协程只负责计算任务的一步<p>和子程序不一样的是，协程没有主程序来进行调度。这是因为协程通过管道连接在一起，没有监视函数负责顺序调用它们。在协程中，执行点可以被挂起，可以被从之前挂起的点恢复执行。通过协程池就可以插入到计算中：运行第一个任务，直到它返回(yield)执行权，然后运行下一个，这样顺着执行下去。<p>协程的另外一些重要特性如下：<ul><li>协程可以有多个入口点，并可以yield多次<li>协程可以将执行权交给其他协程</ul><p>yield表示协程在此暂停，并且将执行权交给其他协程。因为协程可以将值与控制权一起传递给另一个协程，所以“yield一个值”就表示将值传给下一个执行的协程<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> asyncio</span><br><span class=line><span class=keyword>import</span> time</span><br><span class=line><span class=keyword>from</span> random <span class=keyword>import</span> randint</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=function><span class=keyword>def</span> <span class=title>StartState</span>():</span></span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"Start State called \n"</span>)</span><br><span class=line>    input_value = randint(<span class=number>0</span>, <span class=number>1</span>)</span><br><span class=line>    <span class=keyword>if</span> input_value == <span class=number>0</span>:</span><br><span class=line>        result = <span class=keyword>await</span> State2(input_value)</span><br><span class=line>    <span class=keyword>else</span>:</span><br><span class=line>        result = <span class=keyword>await</span> State1(input_value)</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"Resume of the Transition : \nStart State calling "</span> + result)</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=function><span class=keyword>def</span> <span class=title>State2</span>(<span class=params>transition_value</span>):</span></span><br><span class=line>    outputValue = <span class=built_in>str</span>(<span class=string>"State 2 with transition value = %s \n"</span> % transition_value)</span><br><span class=line>    input_value = randint(<span class=number>0</span>, <span class=number>1</span>)</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"...Evaluating..."</span>)</span><br><span class=line>    <span class=keyword>if</span> (input_value == <span class=number>0</span>):</span><br><span class=line>        result = <span class=keyword>await</span> State1(input_value)</span><br><span class=line>    <span class=keyword>else</span>:</span><br><span class=line>        result = <span class=keyword>await</span> State3(input_value)</span><br><span class=line>    <span class=keyword>return</span> outputValue + <span class=built_in>str</span>(result)</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=function><span class=keyword>def</span> <span class=title>EndState</span>(<span class=params>transition_value</span>):</span></span><br><span class=line>    outputValue = <span class=built_in>str</span>(<span class=string>"End State with transition value = %s \n"</span> % transition_value)</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"...Stop Computation..."</span>)</span><br><span class=line>    <span class=keyword>return</span> outputValue</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=function><span class=keyword>def</span> <span class=title>State3</span>(<span class=params>transition_value</span>):</span></span><br><span class=line>    outputValue = <span class=built_in>str</span>(<span class=string>"State 3 with transition value = %s \n"</span> % transition_value)</span><br><span class=line>    input_value = randint(<span class=number>0</span>, <span class=number>1</span>)</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"...Evaluating..."</span>)</span><br><span class=line>    <span class=keyword>if</span> input_value == <span class=number>0</span>:</span><br><span class=line>        result = <span class=keyword>await</span> State1(input_value)</span><br><span class=line>    <span class=keyword>else</span>:</span><br><span class=line>        result = <span class=keyword>await</span> EndState(input_value)</span><br><span class=line>    <span class=keyword>return</span> outputValue + <span class=built_in>str</span>(result)</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=function><span class=keyword>def</span> <span class=title>State1</span>(<span class=params>transition_value</span>):</span></span><br><span class=line>    outputValue = <span class=built_in>str</span>(<span class=string>"State 1 with transition value = "</span> + <span class=built_in>str</span>(transition_value) + <span class=string>" \n"</span>)</span><br><span class=line>    input_value = randint(<span class=number>0</span>, <span class=number>1</span>)</span><br><span class=line>    <span class=keyword>await</span> asyncio.sleep(<span class=number>1</span>)</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>'...Evaluating...'</span>)</span><br><span class=line>    <span class=keyword>if</span> input_value == <span class=number>0</span>:</span><br><span class=line>        result = <span class=keyword>await</span> State3(input_value)</span><br><span class=line>    <span class=keyword>else</span>:</span><br><span class=line>        result = <span class=keyword>await</span> State2(input_value)</span><br><span class=line>    result = <span class=string>"State 1 calling "</span> + result</span><br><span class=line>    <span class=keyword>return</span> outputValue + <span class=built_in>str</span>(result)</span><br><span class=line></span><br><span class=line><span class=keyword>if</span> __name__ == <span class=string>'__main__'</span>:</span><br><span class=line>    loop = asyncio.get_event_loop()</span><br><span class=line>    loop.run_until_complete(StartState())</span><br><span class=line>    loop.close()</span><br><span class=line></span><br></pre></table></figure><p><code>object async_generator can't be used in 'await' expression</code> async函数中如果使用了yield相当于<code>async_generator</code>,后者中不能使用await.<h4 id=Asyncio控制任务><a class=headerlink href=#Asyncio控制任务 title=Asyncio控制任务></a>Asyncio控制任务</h4><blockquote><p>Asyncio是用来处理事件循环中的异步进程和并发任务执行的。它还提供了 <code>asyncio.Task()</code> 类，可以在任务中使用协程。它的作用是，在同一事件循环中,运行某一个任务的同时可以并发地运行多个任务。当协程被包在任务中，它会自动将任务和事件循环连接起来，当事件循环启动的时候，任务自动运行。这样就提供了一个可以自动驱动协程的机制。</blockquote><p><code>asyncio.Task(coroutine)</code> 方法来处理计算任务，它可以调度协程的执行。任务对协程对象在事件循环的执行负责。<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> asyncio</span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=function><span class=keyword>def</span> <span class=title>factorial</span>(<span class=params>number</span>):</span></span><br><span class=line>    f = <span class=number>1</span></span><br><span class=line>    <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>2</span>, number + <span class=number>1</span>):</span><br><span class=line>        <span class=built_in>print</span>(<span class=string>"Asyncio.Task: Compute factorial(%s)"</span> % (i))</span><br><span class=line>        <span class=keyword>await</span> asyncio.sleep(<span class=number>1</span>)</span><br><span class=line>        f *= i</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"Asyncio.Task: factorial(%s) = %s"</span> % (number, f))</span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=function><span class=keyword>def</span> <span class=title>fibonacci</span>(<span class=params>number</span>):</span></span><br><span class=line>    a,b = <span class=number>0</span>,<span class=number>1</span></span><br><span class=line>    <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(number):</span><br><span class=line>        <span class=built_in>print</span>(<span class=string>"Asyncio.Task: Compute fibonacci(%s)"</span> % (i))</span><br><span class=line>        <span class=keyword>await</span> asyncio.sleep(<span class=number>1</span>)</span><br><span class=line>        a,b = b, a + b</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>"Asyncio.Task: fibonacci(%s) = %s"</span> % (number, a))</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>if</span> __name__ == <span class=string>'__main__'</span>:</span><br><span class=line>    tasks = [asyncio.Task(factorial(<span class=number>10</span>)), asyncio.Task(fibonacci(<span class=number>10</span>))]</span><br><span class=line>    loop = asyncio.get_event_loop()</span><br><span class=line>    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class=line>    loop.close()</span><br></pre></table></figure><h4 id=使用asyncio和futures><a class=headerlink href=#使用asyncio和futures title=使用asyncio和futures></a>使用asyncio和futures</h4><blockquote><p>Asyncio 模块的另一个重要的组件是 <code>Future</code> 类。它和 <code>concurrent.futures.Futures</code> 很像，但是针对Asyncio的事件循环做了很多定制。 <code>asyncio.Futures</code> 类代表还未完成的结果（有可能是一个Exception）。所以综合来说，它是一种抽象，代表还没有做完的事情。</blockquote><ul><li><code>cancel()</code>: 取消future的执行，调度回调函数<li><code>result()</code>: 返回future代表的结果<li><code>exception()</code>: 返回future中的Exception<li><code>add_done_callback(fn)</code>: 添加一个回调函数，当future执行的时候会调用这个回调函数<li><code>remove_done_callback(fn)</code>: 从“call whten done”列表中移除所有callback的实例<li><code>set_result(result)</code>: 将future标为执行完成，并且设置result的值<li><code>set_exception(exception)</code>: 将future标为执行完成，并设置Exception</ul><p>类似于js的Promise?<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> asyncio</span><br><span class=line></span><br><span class=line>future = asyncio.Future</span><br><span class=line><span class=keyword>from</span> random <span class=keyword>import</span> randint</span><br><span class=line><span class=keyword>import</span> sys</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=function><span class=keyword>def</span> <span class=title>first_coroutine</span>(<span class=params>future, N</span>):</span></span><br><span class=line>    count = <span class=number>0</span></span><br><span class=line>    <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>1</span>, N + <span class=number>1</span>):</span><br><span class=line>        count += i</span><br><span class=line>    <span class=keyword>await</span> asyncio.sleep(<span class=number>3</span>)</span><br><span class=line>    future.set_result(<span class=string>"First coroutine total count: "</span> + <span class=built_in>str</span>(count))</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=function><span class=keyword>def</span> <span class=title>second_coroutine</span>(<span class=params>future, N</span>):</span></span><br><span class=line>    count = <span class=number>1</span></span><br><span class=line>    <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>2</span>, N + <span class=number>1</span>):</span><br><span class=line>        count *= i</span><br><span class=line>    <span class=keyword>await</span> asyncio.sleep(<span class=number>2</span>)</span><br><span class=line>    future.set_result(<span class=string>"Second coroutine total count: "</span> + <span class=built_in>str</span>(count))</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>def</span> <span class=title>got_result</span>(<span class=params>future</span>):</span></span><br><span class=line>    <span class=built_in>print</span>(future.result())</span><br><span class=line></span><br><span class=line><span class=keyword>if</span> __name__ == <span class=string>'__main__'</span>:</span><br><span class=line>    N = <span class=built_in>int</span>(sys.argv[<span class=number>1</span>])</span><br><span class=line>    future1 = asyncio.Future()</span><br><span class=line>    future2 = asyncio.Future()</span><br><span class=line>    tasks = [</span><br><span class=line>        first_coroutine(future1, N),</span><br><span class=line>        second_coroutine(future2, N)</span><br><span class=line>    ]</span><br><span class=line>    future1.add_done_callback(got_result)</span><br><span class=line>    future2.add_done_callback(got_result)</span><br><span class=line>    loop = asyncio.get_event_loop()</span><br><span class=line>    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class=line>    loop.close()</span><br></pre></table></figure><h2 id=参考资料><a class=headerlink href=#参考资料 title=参考资料></a>参考资料</h2><ol><li><a href=https://python-parallel-programmning-cookbook.readthedocs.io/zh_CN/latest/chapter2/01_Introduction.html rel=noopener target=_blank>1. 介绍 — python-parallel-programming-cookbook-cn 1.0 文档 (python-parallel-programmning-cookbook.readthedocs.io)</a><li><a href=https://blog.csdn.net/weixin_45665318/article/details/106686332 rel=noopener target=_blank>[Python 多线程] 详解daemon属性值None,False,True的区别_daemon=true-CSDN博客</a><li><a href=https://ruanyifeng.com/blog/2019/11/python-asyncio.html rel=noopener target=_blank>Python 异步编程入门 - 阮一峰的网络日志 (ruanyifeng.com)</a><li><a href=https://www.freecodecamp.org/chinese/news/introduction-to-python-threading/ rel=noopener target=_blank>介绍 Python 线程及其实现 (freecodecamp.org)</a><li><a href=https://medium.com/dev-bits/a-minimalistic-guide-for-understanding-asyncio-in-python-52c436c244ea rel=noopener target=_blank>A minimalistic guide for understanding asyncio in Python | by Naren Yellavula | Dev bits | Medium</a><li><a href=https://tutorialedge.net/python/concurrency/getting-started-with-asyncio-python/ rel=noopener target=_blank>Getting Started with Asyncio in Python | TutorialEdge.net</a></ol><link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script></div><div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a href=https://www.sekyoro.top/2023/10/20/Python%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/ title=Python并行计算>https://www.sekyoro.top/2023/10/20/Python并行计算/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div><footer class=post-footer><div class=post-tags><a href=/tags/parallel/ rel=tag><i class="fa fa-tag"></i> parallel</a></div><div class=post-nav><div class=post-nav-item><a href=/2023/10/17/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%AD%A6%E4%B9%A0-P2/ rel=prev title=目标检测学习_P2> <i class="fa fa-chevron-left"></i> 目标检测学习_P2 </a></div><div class=post-nav-item><a href=/2023/10/21/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B-%E5%88%9D%E8%AF%86/ rel=next title=目标检测_初识> 目标检测_初识 <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div><!-- 评论区 --><div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B-amp-amp-%E7%BA%BF%E7%A8%8B><span class=nav-number>1.</span> <span class=nav-text>创建进程&&线程</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C><span class=nav-number>2.</span> <span class=nav-text>线程的并行</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5><span class=nav-number>2.1.</span> <span class=nav-text>线程的同步</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#Lock%E9%94%81%E5%90%8C%E6%AD%A5><span class=nav-number>2.1.1.</span> <span class=nav-text>Lock锁同步</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#RLock%E9%94%81%E5%90%8C%E6%AD%A5><span class=nav-number>2.1.2.</span> <span class=nav-text>RLock锁同步</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%90%8C%E6%AD%A5><span class=nav-number>2.1.3.</span> <span class=nav-text>信号量同步</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%9D%A1%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5><span class=nav-number>2.1.4.</span> <span class=nav-text>条件进行同步</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BA%8B%E4%BB%B6%E5%90%8C%E6%AD%A5><span class=nav-number>2.1.5.</span> <span class=nav-text>事件同步</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BD%BF%E7%94%A8with%E7%AE%80%E5%8C%96><span class=nav-number>2.1.6.</span> <span class=nav-text>使用with简化</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C><span class=nav-number>2.2.</span> <span class=nav-text>进程的并行</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%BF%9B%E7%A8%8B><span class=nav-number>2.2.1.</span> <span class=nav-text>后台运行进程</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%9D%80%E6%8E%89%E8%BF%9B%E7%A8%8B><span class=nav-number>2.2.2.</span> <span class=nav-text>杀掉进程</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%AD%90%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%BF%9B%E7%A8%8B><span class=nav-number>2.2.3.</span> <span class=nav-text>子类中使用进程</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%BF%9B%E7%A8%8B%E4%B8%AD%E4%BA%A4%E6%8D%A2%E5%AF%B9%E8%B1%A1><span class=nav-number>2.2.4.</span> <span class=nav-text>进程中交换对象</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5><span class=nav-number>2.2.5.</span> <span class=nav-text>进程同步</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%AE%A1%E7%90%86%E7%8A%B6%E6%80%81><span class=nav-number>2.2.6.</span> <span class=nav-text>进程之间管理状态</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BD%BF%E7%94%A8%E8%BF%9B%E7%A8%8B%E6%B1%A0><span class=nav-number>2.2.7.</span> <span class=nav-text>使用进程池</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B><span class=nav-number>2.3.</span> <span class=nav-text>异步编程</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#concurrent-futures><span class=nav-number>2.3.1.</span> <span class=nav-text>concurrent.futures</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Asyncio%E7%AE%A1%E7%90%86%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF><span class=nav-number>2.3.2.</span> <span class=nav-text>Asyncio管理事件循环</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Asyncio%E7%AE%A1%E7%90%86%E5%8D%8F%E7%A8%8B><span class=nav-number>2.3.3.</span> <span class=nav-text>Asyncio管理协程</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Asyncio%E6%8E%A7%E5%88%B6%E4%BB%BB%E5%8A%A1><span class=nav-number>2.3.4.</span> <span class=nav-text>Asyncio控制任务</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BD%BF%E7%94%A8asyncio%E5%92%8Cfutures><span class=nav-number>2.3.5.</span> <span class=nav-text>使用asyncio和futures</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99><span class=nav-number>3.</span> <span class=nav-text>参考资料</span></a></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>159</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>17</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>179</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a></ul></div><div class="motion-element announcement"><div class=title>注意</div><p class=content>由于最近图床更新,可能有些图片显示不了.如果发现了有些图片无法显示影响阅读的,还烦请联系我,我有空补上.<p class=date>2023-10-6</div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>文章词云</h3><div class="widget tagcloud" id=myCanvasContainer><canvas height=250 id=resCanvas style=width:100% width=250><ul class=tag-list itemprop=keywords><li class=tag-list-item><a class=tag-list-link href=/tags/parallel/ rel=tag>parallel</a><span class=tag-list-count>1</span></ul></canvas></div></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>1m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>15:31</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer></div><script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script><script src=/lib/anime.min.js></script><script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script><script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/pisces.js></script><script src=/js/next-boot.js></script><script src=/js/bookmark.js></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	'.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script><script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script><script src=/js/algolia-search.js></script><script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script><div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div><script charset=utf-8 defer src=/js/tagcanvas.js></script><script charset=utf-8 defer src=/js/tagcloud.js></script><script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script><script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script><script src=/js/src/activate-power-mode.min.js></script><script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script>
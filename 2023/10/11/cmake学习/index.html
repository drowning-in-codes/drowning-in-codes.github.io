<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"3G9PZZIKCH","apiKey":"8eb71f5ca3167e9ef3487882f10cfaad","indexName":"SekyoroSearch","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content=在Windows上开发c++相比Linux还是有点不方便,这里介绍CMake,跨平台的构建工具. name=description><meta content=article property=og:type><meta content=cmake学习 property=og:title><meta content=https://www.sekyoro.top/2023/10/11/cmake%E5%AD%A6%E4%B9%A0/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content=在Windows上开发c++相比Linux还是有点不方便,这里介绍CMake,跨平台的构建工具. property=og:description><meta content=zh_CN property=og:locale><meta content=https://i.imgur.com/0mXZUbA.png property=og:image><meta content=https://i.imgur.com/cozY007.png property=og:image><meta content=2023-10-11T09:26:00.000Z property=article:published_time><meta content=2024-07-21T15:21:40.785Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content=CMake property=article:tag><meta content=summary name=twitter:card><meta content=https://i.imgur.com/0mXZUbA.png name=twitter:image><link href=https://www.sekyoro.top/2023/10/11/cmake%E5%AD%A6%E4%B9%A0/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>cmake学习 | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2023/10/11/cmake%E5%AD%A6%E4%B9%A0/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>cmake学习</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2023-10-11 17:26:00" datetime=2023-10-11T17:26:00+08:00>2023-10-11</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2024-07-21 23:21:40" datetime=2024-07-21T23:21:40+08:00 itemprop=dateModified>2024-07-21</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>29k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>27 分钟</span> </span></div></header><div class=post-body itemprop=articleBody><p>在Windows上开发c++相比Linux还是有点不方便,这里介绍CMake,跨平台的构建工具.<br><span id=more></span><h2 id=Before-cmake><a title="Before cmake" class=headerlink href=#Before-cmake></a>Before cmake</h2><p>cmake可以生成makefiles,很多时候我们也是使用的makefiles,当然它也可以生成vsproj,ninja等构建文件.这里以makefiles为例介绍一下构建系统.<blockquote><p>Makefile 用于帮助决定大型程序的哪些部分需要重新编译。 在绝大多数情况下，编译的是 C 或 C++ 文件。 其他语言通常也有自己的工具，其作用与 Make 类似。 除了编译之外，Make 还可以用于需要根据文件变化运行一系列指令的情况。</blockquote><p>流行的 C/C++ 替代构建系统有 SCons、CMake、Bazel 和 Ninja一些代码编辑器（如 Microsoft Visual Studio）也有自己的内置构建工具.<p>Java 有 Ant、Maven 和 Gradle，Go、Rust 和 TypeScript 等其他语言也有自己的构建工具。<p>Python、Ruby 和单纯的Javascript 等解释型语言不需要类似 Makefile 的工具。 Makefile 的目标是根据哪些文件发生了变化，编译哪些需要编译的文件。<p>但是，当解释型语言中的文件发生变化时，就不需要重新编译了。 程序运行时，将使用文件的最新版本。<h3 id=syntax><a class=headerlink href=#syntax title=syntax></a>syntax</h3><p>Makefile 由一系列规则组成。 一条规则通常是这样的：<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=section>targets: prerequisites</span></span><br><span class=line>	command</span><br><span class=line>	command</span><br><span class=line>	command</span><br></pre></table></figure><p>目标(targets)是文件名,用空格隔开.通常情况下,每条规则(rule)只有一个目标.<p>命令(command)是一系列通常用于创建目标的步骤,需要以制表符而不是空格开头.<p>先决条件(prerequisites)也是文件名,以空格分隔.在运行目标的命令之前,这些文件必须存在.这些文件也称为依赖项<p>以 hello world 为例开始：<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=section>hello:</span></span><br><span class=line>	echo <span class=string>"Hello, World"</span></span><br><span class=line>	echo <span class=string>"This line will print if the file hello does not exist."</span></span><br></pre></table></figure><p>有一个名为 hello 的目标，这个目标有两条命令，这个目标没有先决条件，然后运行 make hello.<p><strong>只要 hello 文件不存在，命令就会运行</strong>. 要知道hello 既是目标,也是文件.<p>这是因为两者直接联系在一起. <strong>通常情况下,当运行目标文件时（也就是运行目标文件的命令时）,命令会创建一个与目标文件同名的文件</strong>. 在这种情况下,hello 目标不会创建 hello 文件.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=section>blah: cc blah.c -o blah </span></span><br></pre></table></figure><p>运行 make 命令。 由于 make 命令的参数中没有提供目标文件，因此会运行第一个目标文件。 在本例中，只有一个目标（blah）<p>第一次运行时，blah 将被创建。 第二次运行时，你会看到 make: ‘blah’ 是最新的。 这是因为 blah 文件已经存在。 但有一个问题：如果我们修改了 blah.c，然后运行 make，什么都不会重新编译。<p>通过添加一个前提条件来解决这个问题：<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=section>blah: blah.c cc blah.c -o blah </span></span><br></pre></table></figure><p>当我们再次运行 make 时，会发生以下一系列步骤： 第一个目标被选中，因为第一个目标是默认目标<p>这个目标的前提条件是 blah.c ,Make 决定它是否应该运行 blah 目标。 <strong>只有当 blah 不存在或 blah.c 比 blah 新时，它才会运行</strong><p>最后一步至关重要，是 make 的精髓所在。 <strong>它要做的是判断自上次编译 blah 以来，blah 的先决条件是否发生了变化。 也就是说，如果 blah.c 被修改，运行 make 就应该重新编译该文件</strong>。 为了做到这一点，它会使用文件系统的时间戳作为代理来判断是否有改动。 这是一种合理的启发式方法，因为文件时间戳通常只有在文件被修改时才会发生变化。 但必须认识到，情况并非总是如此。 <strong>例如，你可以修改一个文件，然后把该文件的修改时间戳改成旧的。 如果你这样做了，Make 就会错误地认为该文件没有改动，因此可以忽略</strong>。<h3 id=more-examples><a title="more examples" class=headerlink href=#more-examples></a>more examples</h3><p>下面的 Makefile 最终会运行所有三个目标.<p>当你在终端运行 make 时,它会通过一系列步骤编译一个名为 blah 的程序:<p>Make 选择目标 blah,因为第一个目标是默认目标 blah 需要 blah.o,所以 make 搜索 blah.o<p>目标 blah.o 需要 blah.c,所以 make 搜索 blah.c<p>目标 blah.c 没有依赖关系，所以运行 echo 命令.然后运行 cc -c 命令，因为所有 blah.o 的依赖关系都已处理完毕. 然后运行 top cc 命令,因为所有 blah 的依赖关系都已处理完毕.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=section>blah: blah.o</span></span><br><span class=line>	cc blah.o -o blah <span class=comment># Runs third</span></span><br><span class=line></span><br><span class=line><span class=section>blah.o: blah.c</span></span><br><span class=line>	cc -c blah.c -o blah.o <span class=comment># Runs second</span></span><br><span class=line></span><br><span class=line><span class=comment># Typically blah.c would already exist, but I want to limit any additional required files</span></span><br><span class=line><span class=section>blah.c:</span></span><br><span class=line>	echo <span class=string>"int main() { return 0; }"</span> > blah.c <span class=comment># Runs first</span></span><br></pre></table></figure><p>如果删除 blah.c，所有三个目标都将重新运行。 如果编辑它（从而将时间戳改为比 blah.o 新），则会运行前两个目标。 如果运行 touch blah.o（从而将时间戳改为比 blah 更新），则只有第一个目标会运行。 如果什么都不改，则所有目标都不会运行<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=section>some_file: other_file</span></span><br><span class=line>	echo <span class=string>"This will always run, and runs second"</span></span><br><span class=line>	touch some_file</span><br><span class=line></span><br><span class=line><span class=section>other_file:</span></span><br><span class=line>	echo <span class=string>"This will always run, and runs first"</span></span><br></pre></table></figure><p>这个例子, 它将始终运行两个目标,因为 some_file 依赖于 other_file，而 other_file 从未创建。<h3 id=clean><a class=headerlink href=#clean title=clean></a>clean</h3><p>clean 经常被用作删除其他目标输出的目标，但在 Make 中它并不是一个特殊的词。<p>请注意,clean 在这里做了两件新事情:<strong>它不是第一个目标(默认),也不是先决条件.这意味着除非你明确调用 make clean，否则它永远不会运行</strong>. 如果你碰巧有一个名为 clean 的文件,这个目标就不会运行，这不是我们想要的. 如何解决这个问题,使用 .PHONY 😋<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=section>some_file: </span></span><br><span class=line>	touch some_file</span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -f some_file</span><br></pre></table></figure><h3 id=variables><a class=headerlink href=#variables title=variables></a>variables</h3><p>变量只能是字符串。 通常情况下，您需要使用 :=，但 = 也可以。<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>files := file1 file2</span><br><span class=line><span class=section>some_file: <span class=variable>$(files)</span></span></span><br><span class=line>	echo <span class=string>"Look at this variable: "</span> <span class=variable>$(files)</span></span><br><span class=line>	touch some_file</span><br><span class=line></span><br><span class=line><span class=section>file1:</span></span><br><span class=line>	touch file1</span><br><span class=line><span class=section>file2:</span></span><br><span class=line>	touch file2</span><br><span class=line></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -f file1 file2 some_file</span><br></pre></table></figure><p>单引号或双引号对 Make 没有任何意义。 它们只是分配给变量的字符。 不过，引号对 shell/bash 很有用，在 printf 等命令中需要用到。 在本例中,两条命令的行为是一样的：<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>a := one two<span class=comment># a is set to the string "one two"</span></span><br><span class=line>b := 'one two' <span class=comment># Not recommended. b is set to the string "'one two'"</span></span><br><span class=line><span class=section>all:</span></span><br><span class=line>	printf '$a'</span><br><span class=line>	printf $b</span><br></pre></table></figure><p>使用 ${} 或 $() 引用变量<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>x := dude</span><br><span class=line><span class=section>all:</span></span><br><span class=line>	echo <span class=variable>$(x)</span></span><br><span class=line>	echo ${x}</span><br><span class=line></span><br><span class=line>	<span class=comment># Bad practice, but works</span></span><br><span class=line>	echo $x </span><br></pre></table></figure><h3 id=Targets><a class=headerlink href=#Targets title=Targets></a>Targets</h3><p>make多个目标，并希望所有目标都运行？<p>写一个一个all。 由于这是列出的第一条规则，如果调用 make 时没有指定目标，它将默认运行。<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=section>all: one two three</span></span><br><span class=line></span><br><span class=line><span class=section>one:</span></span><br><span class=line>	touch one</span><br><span class=line><span class=section>two:</span></span><br><span class=line>	touch two</span><br><span class=line><span class=section>three:</span></span><br><span class=line>	touch three</span><br><span class=line></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -f one two three</span><br></pre></table></figure><p>当一条规则有多个目标时，将针对每个目标运行命令。 $@ 是一个自动变量，包含目标名称。<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=section>all: f1.o f2.o</span></span><br><span class=line></span><br><span class=line>f1.o f2.o:</span><br><span class=line>	echo <span class=variable>$@</span></span><br><span class=line><span class=comment># Equivalent to:</span></span><br><span class=line><span class=comment># f1.o:</span></span><br><span class=line><span class=comment>#	 echo f1.o</span></span><br><span class=line><span class=comment># f2.o:</span></span><br><span class=line><span class=comment>#	 echo f2.o</span></span><br></pre></table></figure><h3 id=automatic-variables-and-wildcards><a title="automatic variables and wildcards" class=headerlink href=#automatic-variables-and-wildcards></a>automatic variables and wildcards</h3><p>在 Make 中，<em> 和 % 都被称为通配符,但它们的含义完全不同. </em> 在文件系统中搜索匹配的文件名。<p>建议始终将其封装在<strong>通配符函数</strong>中<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=comment># Print out file information about every .c file</span></span><br><span class=line><span class=section>print: $(wildcard *.c)</span></span><br><span class=line>	ls -la  <span class=variable>$?</span></span><br></pre></table></figure><p>*可以在目标、先决条件或通配符功能中使用<p><strong>注意</strong>: 不能在变量定义中直接使用 *<p><strong>注意</strong>: 当 * 不能匹配任何文件时,它将保持原样（除非在通配符功能中运行<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line>thing_wrong := *.o <span class=comment># Don't do this! '*' will not get expanded</span></span><br><span class=line>thing_right := <span class=variable>$(<span class=built_in>wildcard</span> *.o)</span></span><br><span class=line></span><br><span class=line><span class=section>all: one two three four</span></span><br><span class=line></span><br><span class=line><span class=comment># Fails, because $(thing_wrong) is the string "*.o"</span></span><br><span class=line><span class=section>one: <span class=variable>$(thing_wrong)</span></span></span><br><span class=line></span><br><span class=line><span class=comment># Stays as *.o if there are no files that match this pattern :(</span></span><br><span class=line><span class=section>two: *.o </span></span><br><span class=line></span><br><span class=line><span class=comment># Works as you would expect! In this case, it does nothing.</span></span><br><span class=line><span class=section>three: <span class=variable>$(thing_right)</span></span></span><br><span class=line></span><br><span class=line><span class=comment># Same as rule three</span></span><br><span class=line><span class=section>four: $(wildcard *.o)</span></span><br></pre></table></figure><p>% 非常有用，但由于其使用场合多种多样，所以有些令人困惑。 <strong>在 “匹配 “模式下使用时，它会匹配字符串中的一个或多个字符</strong>，这种匹配称为词干。<p><strong>在 “替换 “模式下使用时，它会将匹配到的字符串替换为字符串中的字符串。% 最常用于规则定义和某些特定函数中</strong>。<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=section>hey: one two</span></span><br><span class=line>	<span class=comment># Outputs "hey", since this is the target name</span></span><br><span class=line>	echo <span class=variable>$@</span></span><br><span class=line></span><br><span class=line>	<span class=comment># Outputs all prerequisites newer than the target</span></span><br><span class=line>	echo <span class=variable>$?</span></span><br><span class=line></span><br><span class=line>	<span class=comment># Outputs all prerequisites</span></span><br><span class=line>	echo <span class=variable>$^</span></span><br><span class=line></span><br><span class=line>	<span class=comment># Outputs the first prerequisite</span></span><br><span class=line>	echo <span class=variable>$<</span></span><br><span class=line></span><br><span class=line>	touch hey</span><br><span class=line></span><br><span class=line><span class=section>one:</span></span><br><span class=line>	touch one</span><br><span class=line></span><br><span class=line><span class=section>two:</span></span><br><span class=line>	touch two</span><br><span class=line></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -f hey one two</span><br></pre></table></figure><h3 id=隐式规则><a class=headerlink href=#隐式规则 title=隐式规则></a>隐式规则</h3><p>下面是一个隐含规则列表：<ul><li>Compiling a C program: <code>n.o</code> is made automatically from <code>n.c</code> with a command of the form <code>$(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@</code><li>Compiling a C++ program: <code>n.o</code> is made automatically from <code>n.cc</code> or <code>n.cpp</code> with a command of the form <code>$(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $^ -o $@</code><li>Linking a single object file: <code>n</code> is made automatically from <code>n.o</code> by running the command <code>$(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@</code></ul><p>这些值默认<ul><li><code>CC</code>: Program for compiling C programs; default <code>cc</code><li><code>CXX</code>: Program for compiling C++ programs; default <code>g++</code><li><code>CFLAGS</code>: Extra flags to give to the C compiler<li><code>CXXFLAGS</code>: Extra flags to give to the C++ compiler<li><code>CPPFLAGS</code>: Extra flags to give to the C preprocessor<li><code>LDFLAGS</code>: Extra flags to give to compilers when they are supposed to invoke the linke</ul><figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>CC = gcc <span class=comment># Flag for implicit rules</span></span><br><span class=line>CFLAGS = -g <span class=comment># Flag for implicit rules. Turn on debug info</span></span><br><span class=line></span><br><span class=line><span class=comment># Implicit rule #1: blah is built via the C linker implicit rule</span></span><br><span class=line><span class=comment># Implicit rule #2: blah.o is built via the C compilation implicit rule, because blah.c exists</span></span><br><span class=line><span class=section>blah: blah.o</span></span><br><span class=line></span><br><span class=line><span class=section>blah.c:</span></span><br><span class=line>	echo <span class=string>"int main() { return 0; }"</span> > blah.c</span><br><span class=line></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -f blah*</span><br></pre></table></figure><p>静态模式规则是在 Makefile 中少写代码的另一种方法。<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=section>targets...: target-pattern: prereq-patterns ...</span></span><br><span class=line>   commands</span><br></pre></table></figure><p>其本质是通过目标模式（通过 % 通配符）匹配给定目标。 匹配到的内容称为词干。 然后，将词干代入先决条件模式，生成目标的先决条件。<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line>objects = foo.o bar.o all.o</span><br><span class=line><span class=section>all: <span class=variable>$(objects)</span></span></span><br><span class=line>	<span class=variable>$(CC)</span> <span class=variable>$^</span> -o all</span><br><span class=line></span><br><span class=line><span class=section>foo.o: foo.c</span></span><br><span class=line>	<span class=variable>$(CC)</span> -c foo.c -o foo.o</span><br><span class=line></span><br><span class=line><span class=section>bar.o: bar.c</span></span><br><span class=line>	<span class=variable>$(CC)</span> -c bar.c -o bar.o</span><br><span class=line></span><br><span class=line><span class=section>all.o: all.c</span></span><br><span class=line>	<span class=variable>$(CC)</span> -c all.c -o all.o</span><br><span class=line></span><br><span class=line><span class=section>all.c:</span></span><br><span class=line>	echo <span class=string>"int main() { return 0; }"</span> > all.c</span><br><span class=line></span><br><span class=line><span class=comment># Note: all.c does not use this rule because Make prioritizes more specific matches when there is more than one match.</span></span><br><span class=line><span class=section>%.c:</span></span><br><span class=line>	touch <span class=variable>$@</span></span><br><span class=line></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -f *.c *.o all</span><br></pre></table></figure><p>更高效的方法<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line>objects = foo.o bar.o all.o</span><br><span class=line><span class=section>all: <span class=variable>$(objects)</span></span></span><br><span class=line>	<span class=variable>$(CC)</span> <span class=variable>$^</span> -o all</span><br><span class=line></span><br><span class=line><span class=comment># Syntax - targets ...: target-pattern: prereq-patterns ...</span></span><br><span class=line><span class=comment># In the case of the first target, foo.o, the target-pattern matches foo.o and sets the "stem" to be "foo".</span></span><br><span class=line><span class=comment># It then replaces the '%' in prereq-patterns with that stem</span></span><br><span class=line><span class=variable>$(objects)</span>: %.o: %.c</span><br><span class=line>	<span class=variable>$(CC)</span> -c <span class=variable>$^</span> -o <span class=variable>$@</span></span><br><span class=line></span><br><span class=line><span class=section>all.c:</span></span><br><span class=line>	echo <span class=string>"int main() { return 0; }"</span> > all.c</span><br><span class=line></span><br><span class=line><span class=comment># Note: all.c does not use this rule because Make prioritizes more specific matches when there is more than one match.</span></span><br><span class=line><span class=section>%.c:</span></span><br><span class=line>	touch <span class=variable>$@</span></span><br><span class=line></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -f *.c *.o all</span><br></pre></table></figure><p>过滤器函数可用于静态模式规则，以匹配正确的文件。<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line>obj_files = foo.result bar.o lose.o</span><br><span class=line>src_files = foo.raw bar.c lose.c</span><br><span class=line></span><br><span class=line><span class=section>all: <span class=variable>$(obj_files)</span></span></span><br><span class=line><span class=comment># Note: PHONY is important here. Without it, implicit rules will try to build the executable "all", since the prereqs are ".o" files.</span></span><br><span class=line><span class=meta><span class=meta-keyword>.PHONY</span>: all </span></span><br><span class=line></span><br><span class=line><span class=comment># Ex 1: .o files depend on .c files. Though we don't actually make the .o file.</span></span><br><span class=line><span class=variable>$(<span class=built_in>filter</span> %.o,<span class=variable>$(obj_files)</span>)</span>: %.o: %.c</span><br><span class=line>	echo <span class=string>"target: <span class=variable>$@</span> prereq: <span class=variable>$<</span>"</span></span><br><span class=line></span><br><span class=line><span class=comment># Ex 2: .result files depend on .raw files. Though we don't actually make the .result file.</span></span><br><span class=line><span class=variable>$(<span class=built_in>filter</span> %.result,<span class=variable>$(obj_files)</span>)</span>: %.result: %.raw</span><br><span class=line>	echo <span class=string>"target: <span class=variable>$@</span> prereq: <span class=variable>$<</span>"</span> </span><br><span class=line></span><br><span class=line>%.c %.raw:</span><br><span class=line>	touch <span class=variable>$@</span></span><br><span class=line></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -f <span class=variable>$(src_files)</span></span><br></pre></table></figure><p>模式规则经常被使用，但很容易混淆。 你可以从两个方面来看待它们：<ol><li>一种定义自己的隐式规则的方法<li>一种更简单的静态模式规则形式</ol><figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=comment># Define a pattern rule that compiles every .c file into a .o file</span></span><br><span class=line>%.o : %.c</span><br><span class=line>		<span class=variable>$(CC)</span> -c <span class=variable>$(CFLAGS)</span> <span class=variable>$(CPPFLAGS)</span> <span class=variable>$<</span> -o <span class=variable>$@</span></span><br></pre></table></figure><p>模式规则在目标中包含一个”%”。 该’%’匹配任何非空字符串，其他字符则自行匹配。<p>模式规则<strong>先决条件中的”%”代表与目标中的”%”匹配的同一词干</strong>。<p>双冒号规则很少使用,但允许为同一目标定义多个规则。 如果这些规则是单冒号,则会打印警告,并且只会运行第二组命令.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=section>all: blah</span></span><br><span class=line><span class=section>blah::</span></span><br><span class=line>	echo <span class=string>"hello"</span></span><br><span class=line><span class=section>blah::</span></span><br><span class=line>	echo <span class=string>"hello again"</span></span><br></pre></table></figure><p>在命令前添加 @，以阻止命令被打印<p>也可以使用 -s 运行 make，在每一行前添加 @。<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=section>all: </span></span><br><span class=line>	@echo <span class=string>"This make line will not be printed"</span></span><br><span class=line>	echo <span class=string>"But this will"</span></span><br></pre></table></figure><p>每条命令都在一个新的 shell 中运行<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=section>all: </span></span><br><span class=line>	cd ..</span><br><span class=line>	<span class=comment># The cd above does not affect this line, because each command is effectively run in a new shell</span></span><br><span class=line>	echo `pwd`</span><br><span class=line></span><br><span class=line>	<span class=comment># This cd command affects the next because they are on the same line</span></span><br><span class=line>	cd ..;echo `pwd`</span><br><span class=line></span><br><span class=line>	<span class=comment># Same as above</span></span><br><span class=line>	cd ..; \</span><br><span class=line>	echo `pwd`</span><br></pre></table></figure><p>修改默认shell<code>/bin/sh</code><figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>SHELL=/bin/bash</span><br><span class=line></span><br><span class=line><span class=section>cool:</span></span><br><span class=line>	echo <span class=string>"Hello from bash"</span></span><br></pre></table></figure><p>如果希望字符串带有美元符号，可以使用 $$。 这就是在 bash 或 sh 中使用 shell 变量的方法，请注意 Makefile 变量和 Shell 变量之间的区别。<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>make_var = I am a make variable</span><br><span class=line><span class=section>all:</span></span><br><span class=line>	<span class=comment># Same as running "sh_var='I am a shell variable'; echo $sh_var" in the shell</span></span><br><span class=line>	sh_var='I am a shell variable'; echo $$sh_var</span><br><span class=line></span><br><span class=line>	<span class=comment># Same as running "echo I am a make variable" in the shell</span></span><br><span class=line>	echo <span class=variable>$(make_var)</span></span><br></pre></table></figure><p>在运行 make 时添加 -k，即使出现错误也能继续运行。 在命令前添加 - 可以抑制错误<p>在 make 中添加 -i 可以让每条命令都出错。<p>要递归调用 makefile，请使用特殊的 $(MAKE) 而不是 make，因为它会为你传递 make 标志，而自身不会受其影响。<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>new_contents = <span class=string>"hello:\n\ttouch inside_file"</span></span><br><span class=line><span class=section>all:</span></span><br><span class=line>	mkdir -p subdir</span><br><span class=line>	printf <span class=variable>$(new_contents)</span> | sed -e 's/^ //' > subdir/makefile</span><br><span class=line>	cd subdir && <span class=variable>$(MAKE)</span></span><br><span class=line></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -rf subdir</span><br></pre></table></figure><p>当 Make 启动时，它会<strong>自动从执行时设置的所有环境变量中创建 Make 变量</strong>。<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment># Run this with "export shell_env_var='I am an environment variable'; make"</span></span><br><span class=line><span class=section>all:</span></span><br><span class=line>	<span class=comment># Print out the Shell variable</span></span><br><span class=line>	echo $$shell_env_var</span><br><span class=line></span><br><span class=line>	<span class=comment># Print out the Make variable</span></span><br><span class=line>	echo <span class=variable>$(shell_env_var)</span></span><br></pre></table></figure><p>export指令使用一个变量，并将其设置为所有 shell 命令的环境：<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>shell_env_var=Shell env var, created inside of Make</span><br><span class=line><span class=keyword>export</span> shell_env_var</span><br><span class=line><span class=section>all:</span></span><br><span class=line>	echo <span class=variable>$(shell_env_var)</span></span><br><span class=line>	echo $$shell_env_var</span><br></pre></table></figure><p>设置一个目标导出变量<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=section>.EXPORT_ALL_VARIABLES:</span></span><br><span class=line>new_contents = <span class=string>"hello:\n\techo \$<span class=variable>$(cooly)</span>"</span></span><br><span class=line></span><br><span class=line>cooly = <span class=string>"The subdirectory can see me!"</span></span><br><span class=line><span class=comment># This would nullify the line above: unexport cooly</span></span><br><span class=line></span><br><span class=line><span class=section>all:</span></span><br><span class=line>	mkdir -p subdir</span><br><span class=line>	printf <span class=variable>$(new_contents)</span> | sed -e 's/^ //' > subdir/makefile</span><br><span class=line>	@echo <span class=string>"---MAKEFILE CONTENTS---"</span></span><br><span class=line>	@cd subdir && cat makefile</span><br><span class=line>	@echo <span class=string>"---END MAKEFILE CONTENTS---"</span></span><br><span class=line>	cd subdir && <span class=variable>$(MAKE)</span></span><br><span class=line></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -rf subdir</span><br></pre></table></figure><p>变量有两种类型：<p>递归（使用 =）—只在使用命令时查找变量，而不是在定义变量时查找。<p>简单扩展（使用 :=）—就像普通的命令式编程—只扩展目前已定义的变量。<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=comment># Recursive variable. This will print "later" below</span></span><br><span class=line>one = one ${later_variable}</span><br><span class=line><span class=comment># Simply expanded variable. This will not print "later" below</span></span><br><span class=line>two := two ${later_variable}</span><br><span class=line></span><br><span class=line>later_variable = later</span><br><span class=line></span><br><span class=line><span class=section>all: </span></span><br><span class=line>	echo <span class=variable>$(one)</span></span><br><span class=line>	echo <span class=variable>$(two)</span></span><br></pre></table></figure><p><code>?=</code> only sets variables if they have not yet been set<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>one = hello</span><br><span class=line>one ?= will not be set</span><br><span class=line>two ?= will be set</span><br><span class=line></span><br><span class=line><span class=section>all: </span></span><br><span class=line>	echo <span class=variable>$(one)</span></span><br><span class=line>	echo <span class=variable>$(two)</span></span><br></pre></table></figure><p>行尾的空格不会被删除，但行首的空格会被删除。 要使用单空格创建变量，请使用 $(nullstring)<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>with_spaces = hello   <span class=comment># with_spaces has many spaces after "hello"</span></span><br><span class=line>after = <span class=variable>$(with_spaces)</span>there</span><br><span class=line></span><br><span class=line>nullstring =</span><br><span class=line>space = <span class=variable>$(nullstring)</span> <span class=comment># Make a variable with a single space.</span></span><br><span class=line></span><br><span class=line><span class=section>all: </span></span><br><span class=line>	echo <span class=string>"<span class=variable>$(after)</span>"</span></span><br><span class=line>	echo start<span class=string>"<span class=variable>$(space)</span>"</span>end</span><br></pre></table></figure><p>未定义变量实际上是一个空字符串<p>使用<code>+=</code>添加<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>foo := start</span><br><span class=line>foo += more</span><br><span class=line></span><br><span class=line><span class=section>all: </span></span><br><span class=line>	echo <span class=variable>$(foo)</span></span><br></pre></table></figure><p>使用 override 可以覆盖命令行变量。<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment># Overrides command line arguments</span></span><br><span class=line><span class=keyword>override</span> option_one = did_override</span><br><span class=line><span class=comment># Does not override command line arguments</span></span><br><span class=line>option_two = not_override</span><br><span class=line><span class=section>all: </span></span><br><span class=line>	echo <span class=variable>$(option_one)</span></span><br><span class=line>	echo <span class=variable>$(option_two)</span></span><br></pre></table></figure><p>定义指令并不是一个函数，尽管它看起来像。 <strong>define/endef 只是创建一个变量,并将其设置为一系列命令</strong>。 请注意，这与在命令之间使用分号有点不同，因为每个命令都会在单独的 shell 中运行。<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>one = <span class=keyword>export</span> blah=<span class=string>"I was set!"</span>; echo $$blah</span><br><span class=line></span><br><span class=line><span class=keyword>define</span> two</span><br><span class=line><span class=keyword>export</span> blah=<span class=string>"I was set!"</span></span><br><span class=line>echo $$blah</span><br><span class=line><span class=keyword>endef</span></span><br><span class=line></span><br><span class=line><span class=section>all: </span></span><br><span class=line>	@echo <span class=string>"This prints 'I was set'"</span></span><br><span class=line>	@<span class=variable>$(one)</span></span><br><span class=line>	@echo <span class=string>"This does not print 'I was set' because each command runs in a separate shell"</span></span><br><span class=line>	@<span class=variable>$(two)</span></span><br></pre></table></figure><p>可为特定目标设置变量,也可以为特定目标模式设置变量<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=section>all: one = cool</span></span><br><span class=line></span><br><span class=line><span class=section>all: </span></span><br><span class=line>	echo one is defined: <span class=variable>$(one)</span></span><br><span class=line></span><br><span class=line><span class=section>other:</span></span><br><span class=line>	echo one is nothing: <span class=variable>$(one)</span></span><br><span class=line>	</span><br><span class=line><span class=section>%.c: one = cool</span></span><br><span class=line></span><br><span class=line><span class=section>blah.c: </span></span><br><span class=line>	echo one is defined: <span class=variable>$(one)</span></span><br><span class=line></span><br><span class=line><span class=section>other:</span></span><br><span class=line>	echo one is nothing: <span class=variable>$(one)</span></span><br><span class=line>	</span><br></pre></table></figure><h3 id=条件><a class=headerlink href=#条件 title=条件></a>条件</h3><figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>foo = ok</span><br><span class=line><span class=section>all:</span></span><br><span class=line><span class=keyword>ifeq</span> (<span class=variable>$(foo)</span>, ok)</span><br><span class=line>	echo <span class=string>"foo equals ok"</span></span><br><span class=line><span class=keyword>else</span></span><br><span class=line>	echo <span class=string>"nope"</span></span><br><span class=line><span class=keyword>endif</span></span><br></pre></table></figure><p>检查变量是否为空<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line>nullstring =</span><br><span class=line>foo = <span class=variable>$(nullstring)</span> <span class=comment># end of line; there is a space here</span></span><br><span class=line></span><br><span class=line><span class=section>all:</span></span><br><span class=line><span class=keyword>ifeq</span> (<span class=variable>$(<span class=built_in>strip</span> <span class=variable>$(foo)</span>)</span>,)</span><br><span class=line>	echo <span class=string>"foo is empty after being stripped"</span></span><br><span class=line><span class=keyword>endif</span></span><br><span class=line><span class=keyword>ifeq</span> (<span class=variable>$(nullstring)</span>,)</span><br><span class=line>	echo <span class=string>"nullstring doesn't even have spaces"</span></span><br><span class=line><span class=keyword>endif</span></span><br></pre></table></figure><p>ifdef 不会扩展变量引用；它只是查看是否定义了某个变量<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line>bar =</span><br><span class=line>foo = <span class=variable>$(bar)</span></span><br><span class=line></span><br><span class=line><span class=section>all:</span></span><br><span class=line><span class=keyword>ifdef</span> foo</span><br><span class=line>	echo <span class=string>"foo is defined"</span></span><br><span class=line><span class=keyword>endif</span></span><br><span class=line><span class=keyword>ifndef</span> bar</span><br><span class=line>	echo <span class=string>"but bar is not"</span></span><br><span class=line><span class=keyword>endif</span></span><br></pre></table></figure><p>查看make标志，使用 findstring 和 MAKEFLAGS 测试 make 标志。 使用 make -i 运行此示例，即可看到它打印出 echo 语句。<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=section>all:</span></span><br><span class=line><span class=comment># Search for the "-i" flag. MAKEFLAGS is just a list of single characters, one per flag. So look for "i" in this case.</span></span><br><span class=line><span class=keyword>ifneq</span> (,<span class=variable>$(<span class=built_in>findstring</span> i, <span class=variable>$(MAKEFLAGS)</span>)</span>)</span><br><span class=line>	echo <span class=string>"i was passed to MAKEFLAGS"</span></span><br><span class=line><span class=keyword>endif</span></span><br></pre></table></figure><h3 id=函数><a class=headerlink href=#函数 title=函数></a>函数</h3><p>函数主要用于文本处理. 使用 $(fn, arguments) 或 ${fn, arguments} 调用函数. Make 有大量内置函数.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>bar := ${subst not,<span class=string>"totally"</span>, <span class=string>"I am not superman"</span>}</span><br><span class=line><span class=section>all: </span></span><br><span class=line>	@echo <span class=variable>$(bar)</span></span><br></pre></table></figure><p>函数 subst 将not替换为totally.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>comma := , empty:= space := <span class=variable>$(empty)</span> <span class=variable>$(empty)</span> foo := a b c bar := <span class=variable>$(<span class=built_in>subst</span> <span class=variable>$(space)</span>, <span class=variable>$(comma)</span> , <span class=variable>$(foo)</span>)</span> <span class=comment># Watch out! all:  # Output is ", a , b , c". Notice the spaces introduced @echo $(bar)</span></span><br></pre></table></figure><p>此外还有patsubst,foreach,if,call,shell,filter等函数,<p><code>$(patsubst pattern,replacement,text)</code><p>还有一种只替换后缀的速记方法：$(text:suffix=replacement).注意:不要为这种速记方法添加额外的空格.它会被视为搜索或替换词。<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>foo := a.o b.o l.a c.o</span><br><span class=line>one := <span class=variable>$(<span class=built_in>patsubst</span> %.o,%.c,<span class=variable>$(foo)</span>)</span></span><br><span class=line><span class=comment># This is a shorthand for the above</span></span><br><span class=line>two := $(foo:%.o=%.c)</span><br><span class=line><span class=comment># This is the suffix-only shorthand, and is also equivalent to the above.</span></span><br><span class=line>three := $(foo:.o=.c)</span><br><span class=line></span><br><span class=line><span class=section>all:</span></span><br><span class=line>	echo <span class=variable>$(one)</span></span><br><span class=line>	echo <span class=variable>$(two)</span></span><br><span class=line>	echo <span class=variable>$(three)</span></span><br></pre></table></figure><p><code>$(foreach var,list,text)</code> 它将一个单词列表（用空格分隔）转换为另一个单词列表.<p>var 设置为列表中的每个单词,text 则为每个单词展开.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>foo := who are you</span><br><span class=line><span class=comment># For each "word" in foo, output that same word with an exclamation after</span></span><br><span class=line>bar := <span class=variable>$(<span class=built_in>foreach</span> wrd,<span class=variable>$(foo)</span>,<span class=variable>$(wrd)</span>!)</span></span><br><span class=line></span><br><span class=line><span class=section>all:</span></span><br><span class=line>	<span class=comment># Output is "who! are! you!"</span></span><br><span class=line>	@echo <span class=variable>$(bar)</span></span><br></pre></table></figure><p>if 检查第一个参数是否为非空。 如果是，则运行第二个参数，否则运行第三个参数<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>foo := <span class=variable>$(<span class=built_in>if</span> this-is-not-empty,then!,else!)</span></span><br><span class=line>empty :=</span><br><span class=line>bar := <span class=variable>$(<span class=built_in>if</span> <span class=variable>$(empty)</span>,then!,else!)</span></span><br><span class=line></span><br><span class=line><span class=section>all:</span></span><br><span class=line>	@echo <span class=variable>$(foo)</span></span><br><span class=line>	@echo <span class=variable>$(bar)</span></span><br></pre></table></figure><p>m ake支持创建基本函数,只需通过创建一个变量来 “定义 “函数，但要使用 (0)、(1) 等参数。 然后使用特殊的调用内置函数调用该函数。 语法是 <code>(call variable,param,param)</code>。 (0)是变量，(1)、(2)等是参数。<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>sweet_new_fn = Variable Name: $(0) First: $(1) Second: $(2) Empty Variable: $(3)</span><br><span class=line></span><br><span class=line><span class=section>all:</span></span><br><span class=line>	<span class=comment># Outputs "Variable Name: sweet_new_fn First: go Second: tigers Empty Variable:"</span></span><br><span class=line>	@echo <span class=variable>$(<span class=built_in>call</span> sweet_new_fn, go, tigers)</span></span><br></pre></table></figure><p><code>filter</code>函数用于从列表中选择符合特定模式的某些元素。 例如，这将选择 obj_files 中以 .o 结尾的所有元素。<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment># call function</span></span><br><span class=line><span class=section>all: </span></span><br><span class=line>	@echo <span class=variable>$(<span class=built_in>shell</span> ls -la)</span> <span class=comment># Very ugly because the newlines are gone!</span></span><br><span class=line>	</span><br><span class=line>obj_files = foo.result bar.o lose.o</span><br><span class=line>filtered_files = <span class=variable>$(<span class=built_in>filter</span> %.o,<span class=variable>$(obj_files)</span>)</span></span><br><span class=line></span><br><span class=line><span class=section>all:</span></span><br><span class=line>	@echo <span class=variable>$(filtered_files)</span></span><br></pre></table></figure><p>include 指令告诉 make 读取一个或多个其他 makefile。 它是 makefile 中的一行<p>这在使用 -M 等编译器标志时特别有用,这些标志会根据源代码创建 Makefile. 例如,如果某些 c 文件包含一个头文件,那么该头文件就会被添加到由 gcc 编写的 Makefile 中.<p>使用 vpath 指定存在某些先决条件集的位置。 其格式为 vpath \<pattern> <目录，空格/冒号分隔> <\pattern> 可以有一个 %，可以匹配任何 0 个或多个字符。 您也可以使用变量 VPATH 进行全局操作 <figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>vpath</span> %.h ../headers ../other-directory</span><br><span class=line></span><br><span class=line><span class=comment># Note: vpath allows blah.h to be found even though blah.h is never in the current directory</span></span><br><span class=line><span class=section>some_binary: ../headers blah.h</span></span><br><span class=line>	touch some_binary</span><br><span class=line></span><br><span class=line><span class=section>../headers:</span></span><br><span class=line>	mkdir ../headers</span><br><span class=line></span><br><span class=line><span class=comment># We call the target blah.h instead of ../headers/blah.h, because that's the prereq that some_binary is looking for</span></span><br><span class=line><span class=comment># Typically, blah.h would already exist and you wouldn't need this.</span></span><br><span class=line><span class=section>blah.h:</span></span><br><span class=line>	touch ../headers/blah.h</span><br><span class=line></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -rf ../headers</span><br><span class=line>	rm -f some_binary</span><br></pre></table></figure> <p>在目标中添加 .PHONY 可以防止 Make 将假目标与文件名混淆。 在本例中，如果创建了 clean 文件，仍将运行 make clean。</p> <p>“phony”目标的名称通常很少是文件名，在实践中很多人都会跳过这一点</p> <figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=section>some_file:</span></span><br><span class=line>	touch some_file</span><br><span class=line>	touch clean</span><br><span class=line></span><br><span class=line><span class=meta><span class=meta-keyword>.PHONY</span>: clean</span></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -f some_file</span><br><span class=line>	rm -f clean</span><br></pre></table></figure> <p>如果命令返回非零的退出状态，make 工具将停止运行规则（并返回先决条件）</p> <p>如果规则以这种方式失败，DELETE_ON_ERROR 将删除规则的目标。 这将发生在所有目标上，而不仅仅是像 PHONY 这样的目标。 尽管出于历史原因，make 并没有这样做，但最好还是一直使用这个功能。</p> <figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=section>.DELETE_ON_ERROR:</span></span><br><span class=line><span class=section>all: one two</span></span><br><span class=line></span><br><span class=line><span class=section>one:</span></span><br><span class=line>	touch one</span><br><span class=line>	false</span><br><span class=line></span><br><span class=line><span class=section>two:</span></span><br><span class=line>	touch two</span><br><span class=line>	false</span><br></pre></table></figure> <h2 id=cmake-fundamental><a title="cmake fundamental" class=headerlink href=#cmake-fundamental></a>cmake fundamental</h2><p>在Windows上可选择的构建后端有vs,codeblocks这种软件的文件结构,或者单纯的Makefiles以及Ninja.相当于忽略了几个项目构建的差异.</p> <p><img alt=image-20231013105520974 data-src=https://i.imgur.com/0mXZUbA.png style=zoom:50%;></p> <h2 id=常用变量><a class=headerlink href=#常用变量 title=常用变量></a>常用变量</h2><p><code>PROJECT_BINARY_DIR</code></p> <p>编译生成项目的目录</p> <p><code>PROJECT_SOURCE_DIR</code></p> <p>顶层目录</p> <p><code>EXECUTABLE_OUTPUT_PATH</code>以及<code>LIBRARY_OUTPUT_PATH</code></p> <p>分别用来重新定义最终结果的存放目录</p> <p><code>CMAKE_ARCHIVE_OUTPUT_DIRECTORY</code>：默认存放静态库的文件夹位置；</p> <p><code>CMAKE_LIBRARY_OUTPUT_DIRECTORY</code>：默认存放动态库的文件夹位置；</p> <p><code>LIBRARY_OUTPUT_PATH</code>：默认存放库文件的位置,如果产生的是静态库并且没有指定 CMAKE_ARCHIVE_OUTPUT_DIRECTORY 则存放在该目录下,动态库也类似；</p> <p><code>CMAKE_RUNTIME_OUTPUT_DIRECTORY</code>：存放可执行软件的目录；</p> <p><code>CMAKE_CXX_FLAGS</code>和<code>CMAKE_C_FLAGS</code></p> <p>设置C/ C++编译选项,<code>CMAKE_C_COMPILER</code>设置对应编译器路径.</p> <p><code>BUILD_SHARED_LIBS</code></p> <p>用来控制默认的库编译方式,如果不进行设置,使用ADD_LIBRARY 并没有指定库类型的情况下,默认编译生成的库都是静态库.</p> <p>此外还有一些系统信息</p> <p><img alt=image-20231013163518609 data-src=https://i.imgur.com/cozY007.png></p> <p>使用$ENV{}调用系统变量.</p> <h2 id=指定生成程序><a class=headerlink href=#指定生成程序 title=指定生成程序></a>指定生成程序</h2><figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>add_library</span>(&LTname> [STATIC | SHARED | MODULE]</span><br><span class=line>            [EXCLUDE_FROM_ALL]</span><br><span class=line>            source1 [source2 ...])</span><br></pre></table></figure> <p>将源码source构建成一个库， 供他人使用</p> <p><code>[STATIC | SHARED | MODULE]</code> ：类型有三种</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>add_executable</span>(< name> [WIN32] [MACOSX_BUNDLE]</span><br><span class=line>                [EXCLUDE_FROM_ALL]  source1 source2 … sourceN)</span><br></pre></table></figure> <p>使用给定的源文件，为工程引入一个可执行文件。引入一个名为< name>的可执行目标，该目标会由调用该命令时在源文件列表中指定的源文件来构建</p> <h2 id=添加头文件目录和库><a class=headerlink href=#添加头文件目录和库 title=添加头文件目录和库></a>添加头文件目录和库</h2><figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>include_directories</span>([AFTER|BEFORE] [SYSTEM]  dir1  dir2 ...)</span><br><span class=line><span class=keyword>target_include_directories</span>()</span><br></pre></table></figure> <p>将给定目录 dir1 dir2 加给编译器搜索到的包含文件 .默认情况下，加到目录列表的最后,target_include_directories可以指定针对目标文件添加头文件目录.</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>target_link_libraries</span>(<<span class=keyword>target</span>> [item1] [item2] [...]</span><br><span class=line>                      [[debug|optimized|general] &LTitem>] ...)</span><br></pre></table></figure> <p>该指令的作用为将目标文件与库文件进行链接。</p> <p>上述指令中的<code>&LTtarget></code>是指通过add_executable()和add_library()指令生成已经创建的目标文件.</p> <p>可以使用<code>&LTa>_FOUND</code>检查是否通过find加载成功,之后使用target_link_libraries连接.</p> <h2 id=find-package-amp-find-path-amp-find-library><a class=headerlink href=#find-package-amp-find-path-amp-find-library title=find_package&find_path&find_library></a>find_package&find_path&find_library</h2><p>find_path和find_library分别用来找头文件和库.找到之后可以使用include_directory或者target_link_libraries用来使用.</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>FIND_PATH</span>(myCeres NAMES ceress.h PATHS /ceres/<span class=keyword>include</span>/ceres NO_DEFAULT_PATH)</span><br><span class=line><span class=keyword>INCLUDE_DIRECTORIES</span>(<span class=variable>${myCeres}</span>)</span><br></pre></table></figure> <h2 id=编译时消息输出><a class=headerlink href=#编译时消息输出 title=编译时消息输出></a>编译时消息输出</h2><figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>MESSAGE</span>(STATUS <span class=string>"HELLO"</span>)</span><br></pre></table></figure> <h2 id=设置变量><a class=headerlink href=#设置变量 title=设置变量></a>设置变量</h2><figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class=variable>${CMAKE_SOURCE_DIR}</span>/lib/x86)</span><br></pre></table></figure> <p>set设置变量,后续使用${}使用变量</p> <h2 id=控制结构><a class=headerlink href=#控制结构 title=控制结构></a>控制结构</h2><p>if elseif else endif</p> <p>文件中可以使用条件,循环等控制语句.可以用来判断构建时系统的一些环境.</p> <p>比如</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment># include dynamic link path</span></span><br><span class=line><span class=keyword>if</span>(CMAKE_SYSTEM_PROCESSOR <span class=keyword>MATCHES</span> <span class=string>"x86"</span>)</span><br><span class=line>    <span class=keyword>link_directories</span>(<span class=variable>${CMAKE_CURRENT_SOURCE_DIR}</span>/../nwpu_std_msgs/lib/x86)</span><br><span class=line>    <span class=keyword>link_directories</span>(<span class=variable>${CMAKE_CURRENT_SOURCE_DIR}</span>/../nwpucutils/lib/x86)</span><br><span class=line><span class=keyword>elseif</span>(CMAKE_SYSTEM_PROCESSOR <span class=keyword>MATCHES</span> <span class=string>"arm"</span>)</span><br><span class=line>    <span class=keyword>link_directories</span>(<span class=variable>${CMAKE_CURRENT_SOURCE_DIR}</span>/../nwpu_std_msgs/lib/arm)</span><br><span class=line>    <span class=keyword>link_directories</span>(<span class=variable>${CMAKE_CURRENT_SOURCE_DIR}</span>/../nwpucutils/lib/arm)</span><br><span class=line><span class=keyword>endif</span>()</span><br></pre></table></figure> <h2 id=添加其他子目录><a class=headerlink href=#添加其他子目录 title=添加其他子目录></a>添加其他子目录</h2><figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>add_subdirectory</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL] [SYSTEM])</span><br></pre></table></figure> <p><strong>添加一个子目录并构建该子目录</strong>。source_dir指定源CMakeLists.txt和代码文件所在的目录。</p> <p>一般用在嵌套的项目中,顶层CMakeLists.txt文件添加子目录,让子目录先构建完成之后添加其中生成的库和头文件.</p> <h2 id=获取文件><a class=headerlink href=#获取文件 title=获取文件></a>获取文件</h2><figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>FILE</span> (GLOB ALL_SOURCES <span class=string>"*.cpp"</span> <span class=string>"*.c"</span> <span class=string>"./AFolder/*.cpp"</span> )</span><br></pre></table></figure> <p>使用正则匹配响应文件并存到一个变量中</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>aux_source_directory</span>(dir VAR) </span><br></pre></table></figure> <p>发现一个目录下所有的<strong>源代码文件</strong>并将列表存储在一个变量中.</p> <h2 id=vs中显示头文件><a class=headerlink href=#vs中显示头文件 title=vs中显示头文件></a>vs中显示头文件</h2><figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>file</span>(GLOB_RECURSE pipe_header_files  <span class=variable>${CMAKE_CURRENT_SOURCE_DIR}</span>/<span class=keyword>include</span>/*.h )</span><br><span class=line><span class=keyword>source_group</span>(<span class=string>"Header Files"</span> FILES <span class=variable>${pipe_header_files}</span>) </span><br></pre></table></figure> <p>使用source_group增加文件</p> <p>并添加到生成目标中</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>add_library</span>( lib_pipe_shared SHARED <span class=variable>${pipe_src}</span> <span class=variable>${pipe_header_files}</span>)</span><br></pre></table></figure> <h2 id=option与add-definitions><a class=headerlink href=#option与add-definitions title=option与add_definitions></a>option与add_definitions</h2><figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>option</span>(&LTvariable> <span class=string>"&LThelp_text>"</span> [value])</span><br></pre></table></figure> <p>可以在cmake命令中指定该值.</p> <p>而add_definition用于指定编译器参数，比如<code>add_definitions("-Wall -g")</code>,此外更推荐使用add_compile_definitions将预处理器定义添加到编译器命令行,使用add_compile_options命令添加其它选项。</p> <p>比如下面文件,使用add_definition定义了TEST_DEBUG,option定义为OFF并在cmake执行时指定为on,然后在cmake文件中指定option为on,这样就执行了<code>add_definitions(-DTEST_DEBUG)</code>,定义了该宏.</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>#!/bin/sh</span></span><br><span class=line></span><br><span class=line>cmake -DTEST_DEBUG=ON .</span><br><span class=line>cmake --build .</span><br><span class=line></span><br></pre></table></figure> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>project</span>(<span class=keyword>test</span>)</span><br><span class=line></span><br><span class=line><span class=keyword>option</span>(TEST_DEBUG <span class=string>"option for debug"</span> <span class=keyword>OFF</span>)</span><br><span class=line><span class=keyword>if</span> (TEST_DEBUG)</span><br><span class=line><span class=keyword>add_definitions</span>(-DTEST_DEBUG)</span><br><span class=line><span class=keyword>endif</span>()</span><br></pre></table></figure> <figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>"test.h"</span></span></span><br><span class=line></span><br><span class=line><span class=meta>#<span class=meta-keyword>ifdef</span> TEST_DEBUG</span></span><br><span class=line>...</span><br><span class=line><span class=meta>#<span class=meta-keyword>endif</span></span></span><br></pre></table></figure> <p>CMake中的命令特别多,事实上并不需要去一个一个记住,通常只要知道一个项目的大致构建流程以及可能需要的命令就行了.</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>target_compile_definitions</span>(foo PUBLIC FOO)</span><br><span class=line><span class=keyword>target_compile_definitions</span>(foo PUBLIC -DFOO)  <span class=comment># -D removed</span></span><br><span class=line><span class=keyword>target_compile_definitions</span>(foo PUBLIC <span class=string>""</span> FOO) <span class=comment># "" ignored</span></span><br><span class=line><span class=keyword>target_compile_definitions</span>(foo PUBLIC -D FOO) <span class=comment># -D becomes "", then ignored</span></span><br></pre></table></figure> <h3 id=生成器表示><a class=headerlink href=#生成器表示 title=生成器表示></a>生成器表示</h3><p>生成器表达式是在构建的配置阶段进行的语句。<strong>大多数函数允许使用生成器表达式，只有少数例外。以 $ 的形式使用，其中 OPERATOR 或直接使用，或与 VALUE 进行比 较。</strong></p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>target_compile_options</span>(my_target PRIVATE</span><br><span class=line><span class=string>"$<$&LTCXX_COMPILER_ID:GNU,Clang,AppleClang>:-Wall>"</span>)</span><br><span class=line></span><br></pre></table></figure> <p>若 CXX_COMPILER_ID 变量匹配 GNU, Clang, AppleClang 列表中任意一个，则附加-Wall 选 项到目标——也就是 my_target。生成器表达式在编写独立于平台和编译器的 CMake 文件时非常方便。</p> <p>除了查询值，生成器表达式还可以用于转换字符串和列表:</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>$&LTLOWER_CASE:CMake></span><br></pre></table></figure> <p>这将输出“cmake”。</p> <h2 id=Advanced-cmake><a title="Advanced cmake" class=headerlink href=#Advanced-cmake></a>Advanced cmake</h2><p>cmake在c++中用的太多了,</p> <p>最近在看别人项目的时候看见了一些比较高级的cmake使用方法.</p> <p><strong>macro</strong></p> <p>定义一个名为 \<name> 的宏，该宏接收名为 \<arg1>, … 的参数。 <p>CMake 宏使用 macro()/endmacro() 定义，有点像函数function。不同的是，函数参数是真变量，而 在宏中是字符串替换。这意味着必须使用大括号访问宏的所有参数。 另一个区别是，通过调用函数，作用区域转移到函数内部。执行宏时，就好像宏的主体粘贴到 调用位置一样，宏不会创建变量和控制流的作用域。因此，避免在宏中调用 return()。</p> <p><strong>function</strong></p> <p>函数由 function()/endfunction() 定义。函数为变量创建了一个新的作用域，因此所有 在内部定义的变量都不能从外部访问，除非将 PARENT_SCOPE 选项传递给 set()。 函数不区分大小写，通过 function 后的名称加上圆括号来使用函数</p> <h4 id=Effective-CMake><a title="Effective CMake" class=headerlink href=#Effective-CMake></a>Effective CMake</h4><ul><li><a href=https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1 rel=noopener target=_blank>Effective Modern CMake (github.com)</a><li><a href=https://github.com/xiaoweiChen/CMake-Best-Practices rel=noopener target=_blank>xiaoweiChen/CMake-Best-Practices: 《CMake Best Practices》的非专业个人翻译 (github.com)</a><li><a href=https://llvm.org/docs/CMakePrimer.html rel=noopener target=_blank>CMake Primer — LLVM 19.0.0git documentation</a></ul> <h5 id=通用><a class=headerlink href=#通用 title=通用></a>通用</h5><p>使用CMake版本大于3.0.0</p> <p>将CMake视为代码,像对待任何其他编程语言一样，保持CMakeLists.txt和模块的代码清晰、结构良好。</p> <p>全局定义项目属性,在顶层CMakeLists.txt文件中定义如<strong>编译器警告、代码标准等全局项目属性</strong>，确保所有目标使用相同的标准，避免因依赖目标间的编译选项不一致导致的问题</p> <blockquote><p>例如，一个项目可能会使用一组通用的编译器警告。 在顶层 CMakeLists.txt 文件中全局定义此类属性，可避免因依赖目标使用更严格的编译器选项而导致依赖目标的公共头文件无法编译的情况。 全局定义此类项目属性可以更方便地管理项目及其所有目标。</blockquote> <p>直接操作目标(targets),不要使用<code>add_compile_options</code>, <code>include_directories</code>, <code>link_directories</code>, <code>link_libraries</code>等命令，因为它们作用于目录级别，可能引入隐含的依赖关系。相反，直接对特定的目标使用<code>target_compile_options</code>, <code>target_include_directories</code>, <code>target_link_directories</code>, <code>target_link_libraries</code>等命令。</p> <p>不要直接操作CMAKE_CXX_FLAGS,不同的编译器有不同的命令行参数格式。通过CMAKE_CXX_FLAGS设置C++标准（如<code>-std=c++14</code>）可能会在未来版本的编译器上失效，因为这些要求也可能在其他标准（如C++17）中满足，而且老编译器的选项可能不同。因此，<strong>应该告诉CMake所需的编译特性，让CMake根据具体情况选择适当的编译器选项。</strong></p> <p>合理使用usage requirements,例如,不要将<code>-Wall</code>（开启所有警告）添加到目标的PUBLIC或INTERFACE段的<code>target_compile_options</code>中，因为这不是构建依赖目标所必需的,这样做可能导致不必要的警告信息。</p> <h5 id=模块Modules><a class=headerlink href=#模块Modules title=模块Modules></a>模块Modules</h5><p>使用声明导出目标的现代查找模块。</p> <p>从 CMake 3.4 开始，越来越多的查找模块导出了可通过 target_link_libraries 使用的目标。</p> <p>使用外部软件包的导出目标。 不要重蹈 CMake 使用外部软件包定义的变量的覆辙。 而应通过 target_link_libraries 使用导出的目标。</p> <p>对于不支持客户端使用 CMake 的第三方库，请使用查找模块。 CMake 为第三方库提供了一系列查找模块。</p> <p>例如，Boost 不支持 CMake。 相反，CMake 提供了一个查找模块，以便在 CMake 中使用 Boost。</p> <p>如果某个库不支持客户端使用 CMake，请将其作为 bug 报告给第三方库作者。 如果该库是一个开源项目，请考虑发送补丁。 CMake 在业界占主导地位。 如果库作者不支持 CMake，那就麻烦了。</p> <p>为不支持客户端使用 CMake 的第三方库编写查找模块。 可以改造查找模块，将目标正确导出到不支持 CMake 的外部软件包。</p> <p>如果您是库作者，请导出库的INTERFACE</p> <h5 id=项目Projects><a class=headerlink href=#项目Projects title=项目Projects></a>项目Projects</h5><ul><li><p>避免在项目命令参数中使用自定义变量。 保持简单。 不要引入不必要的自定义变量。 不要使用 add_library(a ${MY_HEADERS} ${MY_SOURCES})，而应使用 add_library(a b.h b.cpp)。</p><li><p>不要在项目中使用 file(GLOB),CMake 是一个编译系统生成器，而不是一个编译系统。 在生成构建系统时，它会将 GLOB 表达式求值为一个文件列表。 然后，联编系统会对该文件列表进行操作。 CMake 无法将 GLOB 表达式转发给联编系统，以便在联编时对表达式进行评估。 CMake 希望成为所支持的联编系统的公分母。 并非所有的构建系统都支持这一点，因此 CMake 也无法支持。</p><li>将特定于 CI 的设置放在 CTest 脚本中，而不是项目中，这样会让事情更简单。<li>测试名称应遵循命名约定。 这样可以简化通过 CTest 运行测试时的 regex 过滤。</ul> <h5 id=目标-Targets-及其属性-Properties><a class=headerlink href=#目标-Targets-及其属性-Properties title=目标(Targets)及其属性(Properties)></a>目标(Targets)及其属性(Properties)</h5><p><strong>从目标和属性的角度思考</strong></p> <p>通过从目标的角度定义属性（即编译定义、编译选项、编译特性、包含目录和库依赖关系,compile definitions, compile options, compile features, include directories, and library dependencies），可以帮助开发人员在目标级别对系统进行推理。 开发人员不需要了解整个系统，就能对单个目标进行推理。 构建系统可处理反向性。</p> <p><strong>将目标想象成对象</strong></p> <p>调用成员函数会修改对象的成员变量。</p> <p>与构造函数类比：add_executable add_library</p> <p>与成员变量类比：target properties（太多，这里不一一列举）</p> <p>与成员函数类比：target_compile_definitions target_compile_features target_compile_options target_include_directories target_link_libraries target_sources get_target_property set_target_property</p> <p>如果目标需要内部属性（如编译定义、编译选项、编译特性、包含目录和库依赖关系），请将它们添加到 target_* 命令的 PRIVATE 部分。</p> <p><strong>使用 target_compile_definitions 声明编译定义</strong></p> <p>可将编译定义与目标的可见性（PRIVATE、PUBLIC、INTERFACE）关联起来。 这比使用 add_compile_definitions 更好，因为 add_compile_definitions 与目标没有关联。</p> <p><strong>使用 target_compile_options 声明编译选项</strong></p> <p>这与编译选项与目标的可见性（PRIVATE、PUBLIC、INTERFACE）相关联。 这比使用 add_compile_options 要好，因为 add_compile_options 与目标没有关联。</p> <p>但要注意不要声明会影响 ABI 的编译选项。 请全局声明这些选项。</p> <p>target_compile_features同</p> <p><strong>使用 target_include_directories 声明 include 目录</strong></p> <p>这将 include 目录与目标的可见性（PRIVATE、PUBLIC、INTERFACE）相关联。 这比使用 include_directories 更好，因为 include_directories 与目标没有关联。</p> <p><strong>使用 target_link_libraries 声明直接依赖关系</strong>，这将把使用要求从依赖目标传播到被依赖目标。 该命令还能解决传递依赖关系。</p> <p><strong>不要在组件目录之外的路径下使用 target_include_directories</strong></p> <p>在组件目录之外使用路径是一种隐藏的依赖关系。 相反，应使用 target_include_directories 通过 target_link_directories 将包含目录作为使用要求传播给依赖目标。</p> <p>使用 target_* 时，始终明确声明属性 PUBLIC、PRIVATE 或 INTERFACE。 明确声明可减少无意中引入隐藏依赖关系的机会。</p> <p>不要使用 target_compile_options 设置会影响 ABI 的选项。 对多个目标使用不同的编译选项可能会影响 ABI 兼容性。 防止此类问题的最简单解决方案是全局定义编译选项。</p> <p>使用在同一 CMake 树中定义的库应与使用外部库相同。 在同一 CMake 树中定义的软件包可直接访问。 通过 CMAKE_PREFIX_PATH 获取预编译库。 如果软件包定义在同一个编译树中，那么使用 find_package 查找该软件包就不会有任何问题。 在将目标 Bar 导出到命名空间 Foo 时，还可以通过 add_library(Foo::Bar ALIAS Bar) 创建别名 Foo::Bar。 创建一个变量，列出所有子项目。 定义 find_package 宏来封装原来的 find_package 命令（现在可通过 _find_package 访问）。 如果变量包含软件包的名称，宏将禁止调用 _find_package。</p> <h5 id=函数与宏><a class=headerlink href=#函数与宏 title=函数与宏></a>函数与宏</h5><p>除了基于目录的作用域外，CMake 函数也有自己的作用域。 这意味着在函数中设置的变量在父作用域中不可见。 宏则不然。</p> <p>宏只能用于定义很小的功能，或用于封装有输出参数的命令。 函数有自己的作用域，宏没有。</p> <p>宏的参数不会被设置为变量，而是在执行宏之前在宏中解析对参数的引用。 这可能会在使用未引用变量时导致意外行为。 一般来说，这个问题并不常见，因为它需要使用名称在父作用域中重叠的非参引变量，但必须注意，因为它可能导致微妙的错误。</p> <p>不要使用会影响目录树中所有目标的宏，如 include_directories、add_definitions 或 link_libraries。 这些宏是邪恶的。 如果在顶层使用宏，所有目标都可以使用宏定义的属性。 例如，所有目标都可以使用（即 #include）include_directories 所定义的头文件。 如果目标不需要链接（如接口库、内联模板），在这种情况下甚至不会出现编译器错误。 使用这些宏很容易意外地通过其他目标创建隐藏的依赖关系。</p> <p><strong>建议使用 cmake_parse_arguments 来处理任何函数中基于参数的复杂行为或可选参数。</strong></p> <h5 id=循环><a class=headerlink href=#循环 title=循环></a>循环</h5><ul><li><code>foreach(var IN ITEMS foo bar baz) ...</code><li><code>foreach(var IN LISTS my_list) ...</code><li><code>foreach(var IN LISTS my_list ITEMS foo bar baz) ...</code></ul> <h5 id=包><a class=headerlink href=#包 title=包></a>包</h5><p>使用 CPack 创建软件包.</p> <p>CPack 是 CMake 的一部分,并与 CMake 完美集成。</p> <p>编写 CPackConfig.cmake,其中包括 CMake 生成的 CPackConfig.cmake,这样就可以设置无需出现在项目中的其他变量。</p> <h5 id=交叉编译><a class=headerlink href=#交叉编译 title=交叉编译></a>交叉编译</h5><p>使用工具链文件进行交叉编译。工具链文件封装了用于交叉编译的工具链。</p> <p>保持工具链文件的简洁，这样更易于理解和使用。 不要在工具链文件中加入逻辑。 为每个平台创建一个工具链文件。</p> <h5 id=警告与报错><a class=headerlink href=#警告与报错 title=警告与报错></a>警告与报错</h5><p>正确对待构建错误、修复错误、拒绝拉取请求、暂缓发布。</p> <p><strong>将警告视为错误</strong></p> <p>要将警告视为错误，切勿向编译器传递 -Werror。 如果这样做，编译器就会将警告视为错误。</p> <ul><li>You cannot enable <code>-Werror</code> unless you already reached zero warnings.<li>You cannot increase the warning level unless you already fixed all warnings introduced by that level.<li>You cannot upgrade your compiler unless you already fixed all new warnings that the compiler reports at your warning level.<li>You cannot update your dependencies unless you already ported your code away from any symbols that are now <code>[[deprecated]]</code>.<li><p>You cannot <code>[[deprecated]]</code> your internal code as long as it is still used. But once it is no longer used, you can as well just remove it.</p> <p><strong>将新的警告视为错误</strong></p></ul> <ol><li>At the beginning of a development cycle (e.g., sprint), allow new warnings to be introduced.<ul><li>Increase warning level, enable new warnings explicitly.<li>Update the compiler.<li>Update dependencies.<li>Mark symbols as <code>[[deprecated]]</code>.</ul><li>Burn down the number of warnings.<li>Repeat.</ol> <p>使用多个支持的分析器：clang-tidy (\<lang>_CLANG_TIDY)、cpplint (\<lang>_CPPLINT)、include-what-you-use (\<lang>_INCLUDE_WHAT_YOU_USE) 和 LINK_WHAT_YOU_USE 可帮助您发现代码中的问题。 这些工具的诊断输出将显示在构建输出和集成开发环境中。 <p>对于每个头文件，都必须有一个关联的源文件，该源文件 #includes 头文件在顶部，即使该源文件本来是空的。 大多数分析工具都会报告当前源文件和关联头文件的诊断结果。 没有关联源文件的头文件不会被分析。 您也许可以设置自定义头文件过滤器，但这样头文件可能会被分析多次。</p> <h2 id=实战><a class=headerlink href=#实战 title=实战></a>实战</h2><h3 id=项目结构><a class=headerlink href=#项目结构 title=项目结构></a>项目结构</h3><figure class="highlight reasonml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>├── <span class=module-access><span class=module><span class=identifier>CMakeLists</span>.</span></span>txt</span><br><span class=line>├── build</span><br><span class=line>├── <span class=keyword>include</span>/project_name</span><br><span class=line>└── src</span><br></pre></table></figure> <p>最小的项目结构中有三个文件夹和一个文件</p> <p>• build: 放置构建文件和二进制文件的文件夹。</p> <p>• include/project_name: 此 文 件 夹 包 含 从 项 目 外 部 公 开 访 问 的 所 有 头 文 件， 包 含 使它更容易看出头文件来自哪个库。</p> <p>• src: 此文件夹包含所有私有的源文件和头文件</p> <p>• CMakeLists.txt: 这是主 CMake 文件</p> <p>构建文件夹可以放置在任何地方，放在项目根目录最方便，但强烈建议不要选择任何非空文件 夹作为构建文件夹。特别是将构建好的文件放入 include 或 src 中，这是一种糟糕的实践。其他文件 夹，如 test 或 doc，在组织测试项目和文档页面时就很方便</p> <p><strong>嵌套项目</strong></p> <figure class="highlight reasonml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>├── <span class=module-access><span class=module><span class=identifier>CMakeLists</span>.</span></span>txt</span><br><span class=line>├── build</span><br><span class=line>├── <span class=keyword>include</span>/project_name</span><br><span class=line>├── src</span><br><span class=line>└── subproject</span><br><span class=line>├── <span class=module-access><span class=module><span class=identifier>CMakeLists</span>.</span></span>txt</span><br><span class=line>├── <span class=keyword>include</span></span><br><span class=line>│ └── subproject</span><br><span class=line>└── src</span><br></pre></table></figure> <figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=built_in>cmake_minimum_required</span>(VERSION <span class=number>3.21</span>)</span><br><span class=line><span class=built_in>project</span>(</span><br><span class=line>hello_world_standalone</span><br><span class=line>VERSION <span class=number>1.0</span></span><br><span class=line>DESCRIPTION<span class=string>"A simple C++ project"</span></span><br><span class=line>HOMEPAGE_URL https:<span class=comment>//github.com/PacktPublishing/CMake-BestPractices</span></span><br><span class=line>LANGUAGES CXX</span><br><span class=line>)</span><br><span class=line><span class=built_in>add_executable</span>(hello_world)</span><br><span class=line><span class=built_in>target_sources</span>(hello_world PRIVATE src/main.cpp)</span><br><span class=line></span><br></pre></table></figure> <p>第一行，cmake_minimum_required(VERSION 3.21)，期望看到的 CMake 的版本，以及 CMake 将启用哪些特性。本书的例子中都使用 CMake 3.21，但是出于兼容性的原因，读者们可以选 择一个较低的版本。</p> <p>对于本例，3.1 版本将是绝对的最小值，因为在此之前，target_sources 不可用。将 cmake_minimum_required 指令放在每个 CMakeLists.txt 文件的顶部是一个很好的做法。</p> <p>接下来，使用 project() 指令设置项目。第一个参数是项目的名称——我们的例子中为 “hello_world_standalone”。 接下来，版本设置为 1.0。下面是一个简短的描述和主页的 URL。</p> <p>最后，LANGUAGES CXX 属 性指定正在构建一个 C++ 项目。除了项目名称之外，所有参数都可选。 调用 add_executable(hello_world) 指令，会创建一个名为 hello_world 的目标。这也将 是可执行的文件名。 现在已经创建了目标，使用 target_sources 完成了向目标添加 C++ 源文件。Chapter3 是目标名，在 add_executable 中指定。</p> <p>PRIVATE 定义源仅用于构建此目标，而不用于依赖的目 标。在范围说明符之后，有一个相对于当前 CMakeLists.txt 文件路径的源文件列表。如果需要，当 前处理的 CMakeLists txt 文件的位置可以通过 CMAKE_CURRENT_SOURCE_DIR 得到。</p> <p>源码可以直接添加到 add_executable，也可以单独使用 target_sources，将它们与 target_sources 一起添加。通过使用 PRIVATE、PUBLIC 或 INTERFACE，可以显式地定义在何 处使用源码。但是，<strong>指定 PRIVATE 以外的内容只对库目标有意义</strong>。</p> <h3 id=创建库><a class=headerlink href=#创建库 title=创建库></a>创建库</h3><figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>cmake_minimum_required</span>(VERSION <span class=number>3.21</span>)</span><br><span class=line><span class=keyword>project</span>(</span><br><span class=line>ch3.hello_lib</span><br><span class=line>VERSION <span class=number>1.0</span></span><br><span class=line>DESCRIPTION</span><br><span class=line><span class=string>"A simple C++ project to demonstrate creating executables</span></span><br><span class=line><span class=string>and libraries in CMake"</span></span><br><span class=line>LANGUAGES CXX)</span><br><span class=line><span class=keyword>add_library</span>(hello)</span><br><span class=line><span class=keyword>target_sources</span>(</span><br><span class=line>hello</span><br><span class=line>PRIVATE src/hello.cpp src/internal.cpp)</span><br><span class=line><span class=keyword>target_compile_features</span>(hello PUBLIC cxx_std_17)</span><br><span class=line><span class=keyword>target_include_directories</span>(</span><br><span class=line>hello</span><br><span class=line>PRIVATE src/hello</span><br><span class=line>PUBLIC <span class=keyword>include</span>)</span><br></pre></table></figure> <p>源文件使用 PRIVATE 添加，PRIVATE 和 PUBLIC 关键字指定在何处使用源代码进行编译。PRIVATE 指定的源文件将只在目标 hello 中使用</p> <p>若使用 PUBLIC，那么源文件也会将附加到 hello 和依赖 hello 的目标上，这通常不是想要的结果。</p> <p><strong>INTERFACE 关键字说明源文件不会添加到 hello 目标中，而是会添加到依赖到 hello 的目标上</strong>。</p> <p>通常,为目标指定为 PRIVATE 的内容都可以视为构建需求.最后,包含目录使用 target_include_directories 设置.该指令指定的文件夹内的所有文件都可以使用 #include (带尖括号) 来访问</p> <h3 id=接口和纯头文件><a class=headerlink href=#接口和纯头文件 title=接口和纯头文件></a>接口和纯头文件</h3><p>纯头文件的库有点特殊，因为不需要编译; 相反，可以导出它们的头文件，以便直接包含在其 他库中。</p> <p>大多数情况下，头文件库的工作方式与普通库类似，但是头文件使用 INTERFACE，而非 PUBLIC。</p> <p>由于仅包含头文件的库不需要编译，因此不会向目标添加源文件。</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>project</span>(</span><br><span class=line>ch3_hello_header_only</span><br><span class=line>VERSION <span class=number>1.0</span></span><br><span class=line>DESCRIPTION <span class=string>"Chapter 3 header-only example"</span></span><br><span class=line>LANGUAGES CXX)</span><br><span class=line><span class=keyword>add_library</span>(hello_header_only INTERFACE)</span><br><span class=line><span class=keyword>target_include_directories</span>(hello_header_only INTERFACE <span class=keyword>include</span>/)</span><br><span class=line><span class=keyword>target_compile_features</span>(hello_header_only INTERFACE cxx_std_17)</span><br></pre></table></figure> <h3 id=对象库><a class=headerlink href=#对象库 title=对象库></a>对象库</h3><p>有时，可能想要<strong>分离代码，以便部分代码可以重用</strong>，而不需要创建完整的库。当想在可执行测 试和单元测试中使用某些代码时，通常的做法是不需要重新编译所有代码两次。为此，CMake 提 供了对象库，其中的源代码是编译的，但不进行归档或链接。通过 <code>add_library(MyLibrary object)</code> 创建对象库。</p> <p>自 CMake 3.12 起， 这 些 对 象 可 以 像 普 通 库 一 样 使 用， 只 需 将 它 们 添 加 到 target_link_libraries 函数中。3.12 版本之前，对象库需要添加生成器表达式，也就 是 $。这将在生成构建系统期间扩展为一个对象列表。这种方式现 在还可以用，但不推荐这样做，因为这很快就变得不可维护，特别是在一个项目中有多个对象库的 情况下。</p> <h3 id=使用库><a class=headerlink href=#使用库 title=使用库></a>使用库</h3><p>可 以 把 add_library 放 在 同 一 个 CMakeLists.txt 文 件 中， 或 者 使 用 add_subdirectory 将其整合起来。两者都是有效的选项，并取决于项目的设置方式</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>add_subdirectory</span>(hello_lib)</span><br><span class=line><span class=keyword>add_subdirectory</span>(hello_header_only)</span><br><span class=line><span class=keyword>add_subdirectory</span>(hello_object)</span><br><span class=line><span class=keyword>add_executable</span>(chapter3)</span><br><span class=line><span class=keyword>target_sources</span>(chapter3 PRIVATE src/main.cpp)</span><br><span class=line><span class=keyword>target_link_libraries</span>(chapter3 PRIVATE hello_header_only hello</span><br><span class=line>hello_object)</span><br></pre></table></figure> <p>target_link_libraries 的目标也可以是另一个库。同样，库的链接说明符，可以是以下 任意一个:</p> <p>• PRIVATE: 用于链接库，但不是公共接口的一部分。只有在构建目标时才需要链接库。</p> <p>• INTERFACE: 没有链接到库，但是公共接口的一部分。当在其他地方使用目标时，链接库是必需的。这通常仅限头文件库时使用。</p> <p>• PUBLIC: 链接到库，是公共接口的一部分。因此，该库既是构建依赖项，也是使用依赖项。</p> <h3 id=设置编译器和链接器选项><a class=headerlink href=#设置编译器和链接器选项 title=设置编译器和链接器选项></a>设置编译器和链接器选项</h3><p>C++ 编译器有很多选项来设置一些常见的标志，从外部设置预处理器定义也是一种常见的做 法。CMake 中，这些是使用 target_compile_options 传递，使用 target_link_options 更改链接器行为，但编译器和链接器可能有不同的设置标志的方法。例如，在 GCC 和 Clang 中，选 项用减号 (-) 传递，而 Microsoft 编译器将斜杠 (/) 作为选项的前缀。但是<strong>通过生成器表达式，可以很容易地在 CMake 中处理这个问题</strong>:</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>target_link_options</span>(</span><br><span class=line>hello</span><br><span class=line>PRIVATE $<$&LTCXX_COMPILER_ID:MSVC>:/SomeOption></span><br><span class=line>$<$&LTCXX_COMPILER_ID:GNU,Clang,AppleClang>:-</span><br><span class=line>someOption></span><br><span class=line>)</span><br></pre></table></figure> <p>$<a href=$:/SomeOption>$:/SomeOption</a> 是 一 个 嵌 套 的 生 成 器 表 达 式， 由 内 而 外 求 值。 生 成 器 表 达 式 在 生 成 阶 段 进 行 计 算。</p> <p>首 先， 当 C++ 编 译 器 等 于 MSVC 时为 true。若是这种情况，那么外部表达式将返回/SomeOption， 然后传递给编译器。若内部表达式的计算结果为 false，则不传递。 $<$:-fopenmp> 的工作原理类似，但不是只检查 单个值，而是传递一个包含 GNU，Clang，AppleClang 的列表。若 CXX_COMPILER_ID 匹配其中 任何一个，内部表达式计算为 true，someOption 会传递给编译器。 将编译器或链接器选项传递为 PRIVATE，将其标记为与库接口不需要的此目标的构建需求。</p> <p>若 使用 PUBLIC，那么编译选项也成为构建需求，所有依赖于原始目标的目标将使用相同的编译选项。 将编译器选项暴露给依赖的目标是需要谨慎做的事情。</p> <p>若编译器选项只用于使用目标而不用于构建目标，则可以使用关键字 INTERFACE。在构建纯头文件库时，这是最常见的情况。 编 译 器 选 项 的 特 殊 情 况 是 编 译 定 义， 其 会 传 递 给 底 层 程 序。 这 通 过 target_compile_definitions 进行传递。</p> <h3 id=调试编译器选项><a class=headerlink href=#调试编译器选项 title=调试编译器选项></a>调试编译器选项</h3><p>要查看所有编译选项，可以查看生成的构建文件，例如 Makefiles 或 Visual Studio 项目。更方便 的方法是让 CMake 将所有编译命令导出为 JSON。 通 过 使 用 CMAKE_EXPORT_COMPILE_COMMANDS， 将 生 成 一 个 名 为 compile_commands.json 的文件，其包含用于编译的完整命令。</p> <h3 id=库别名><a class=headerlink href=#库别名 title=库别名></a>库别名</h3><p>库别名是在不创建新的构建目标的情况下引用库的一种方法，有时称为命名空间。常见的模式 是为从项目中安装的每个库以 MyProject::library 的形式创建一个库别名，可以用于对多个目标进行 语义分组。有助于避免命名方面的冲突，特别是当项目包含公共目标时，比如名为 utils 的库、helper 和类似的库。</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>add_library</span>(Chapter3::hello ALIAS hello)</span><br><span class=line>...</span><br><span class=line><span class=keyword>target_link_libraries</span>(SomeLibrary PRIVATE Chapter3::hello)</span><br></pre></table></figure> <h3 id=打包、部署和安装><a class=headerlink href=#打包、部署和安装 title=打包、部署和安装></a>打包、部署和安装</h3><p>install() 指令 install(…) 指令是一个内置的 CMake 命令，允许生成用于安装目标、文件、目录等的构建 系统说明。CMake 不会生成安装指令，除非明确地说明。因此，安装总是在开发者的控制中。来看 下它的基本用法。</p> <p>要使 CMake 目标可安装，必须用至少一个参数指定 TARGETS 参数。指令的签名如下所示:</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>install</span>(TARGETS ... [...])</span><br></pre></table></figure> <h3 id=参考资料><a class=headerlink href=#参考资料 title=参考资料></a>参考资料</h3><ol><li><a href=https://blog.csdn.net/llffss/article/details/120121617 rel=noopener target=_blank>cmake指令汇总_cmake命令大全_nuosen123的博客-CSDN博客</a><li><a href=https://www.runoob.com/w3cnote/cpp-static-library-and-dynamic-library.html rel=noopener target=_blank>C++静态库与动态库 | 菜鸟教程 (runoob.com)</a><li><a href=https://zhuanlan.zhihu.com/p/578843962 rel=noopener target=_blank>使用C++创建并调用动态链接库(dll) - 知乎 (zhihu.com)</a><li><a href=https://blog.csdn.net/Op_chaos/article/details/110476264?spm=1001.2101.3001.6650.7&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-7-110476264-blog-120121617.235^v38^pc_relevant_anti_t3_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-7-110476264-blog-120121617.235^v38^pc_relevant_anti_t3_base&utm_relevant_index=11 rel=noopener target=_blank>CMake指令详解_cmake -d-CSDN博客</a><li><a href=https://blog.csdn.net/qq_25160757/article/details/79813428 rel=noopener target=_blank>VS的包含目录、库目录、引用目录、可执行目录解释_vs包含目录和引用目录-CSDN博客</a><li><a href=https://www.cnblogs.com/pandamohist/p/13674438.html rel=noopener target=_blank>cmake之Visual studio无法显示头文件 - mohist - 博客园 (cnblogs.com)</a><li><a href=https://blog.csdn.net/sandalphon4869/article/details/100589747 rel=noopener target=_blank>Linux之cmake的指令以及内部构建和外部构建_cmake 外部编译-CSDN博客</a><li><a href=https://www.cnblogs.com/guoshuai-ouc/p/cmake_variable.html rel=noopener target=_blank>cmake 常用变量和常用环境变量 - 小果子啊 - 博客园 (cnblogs.com)</a><li><a href=https://blog.csdn.net/qq_38410730/article/details/102477162 rel=noopener target=_blank>【CMake】CMakeLists.txt的超傻瓜手把手教程（附实例源码）_【cmake】cmakelists.txt的超傻瓜手把手教程(附实例源码)-CSDN博客</a><li><a href=https://developer.aliyun.com/article/243229#:~:text=官网不推荐使用l,aries使用。 rel=noopener target=_blank>make的link_directories命令不起作用-阿里云开发者社区 (aliyun.com)</a><li><a href=https://cmake.org/cmake/help/latest/ rel=noopener target=_blank>CMake Reference Documentation — CMake 3.28.0-rc1 Documentation</a><li><a href=https://blog.csdn.net/afei__/article/details/81201039 rel=noopener target=_blank>CMakeLists.txt 语法介绍与实例演练-CSDN博客</a><li><a href=https://www.bookstack.cn/read/Modern-CMake-CN-Modern-CMake-zh_CN/701c8402c6158612.md rel=noopener target=_blank>现代的 CMake 的介绍 - 《Modern CMake 简体中文版》 - 书栈网 · BookStack</a><li><a href=https://cmakebyexample.dev/ rel=noopener target=_blank>CMake by Example</a><li><a href=https://makefiletutorial.com/#makefile-cookbook rel=noopener target=_blank>Makefile Tutorial By Example</a><li><a href=https://www.youtube.com/watch?v=bsXLMQ6WgIk&ab_channel=CppNow rel=noopener target=_blank>C ++现在2017年：丹尼尔·菲费尔“有效的CMake” (youtube.com)</a></ol> <link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script> <div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div> <div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div> <div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a href=https://www.sekyoro.top/2023/10/11/cmake%E5%AD%A6%E4%B9%A0/ title=cmake学习>https://www.sekyoro.top/2023/10/11/cmake学习/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div> <div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div> <footer class=post-footer><div class=post-tags><a href=/tags/CMake/ rel=tag><i class="fa fa-tag"></i> CMake</a></div><div class=post-nav><div class=post-nav-item><a href=/2023/10/04/stable-diffusion%E5%AD%A6%E4%B9%A0/ rel=prev title=stable_diffusion学习> <i class="fa fa-chevron-left"></i> stable_diffusion学习 </a></div><div class=post-nav-item><a title="目标检测(Object Detection)学习_P1" href=/2023/10/11/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B-Object-Detection-%E5%AD%A6%E4%B9%A0/ rel=next> 目标检测(Object Detection)学习_P1 <i class="fa fa-chevron-right"></i> </a></div></div></footer> <!-- 评论区 --> <div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div> <script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script> <div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div> <aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#Before-cmake><span class=nav-number>1.</span> <span class=nav-text>Before cmake</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#syntax><span class=nav-number>1.1.</span> <span class=nav-text>syntax</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#more-examples><span class=nav-number>1.2.</span> <span class=nav-text>more examples</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#clean><span class=nav-number>1.3.</span> <span class=nav-text>clean</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#variables><span class=nav-number>1.4.</span> <span class=nav-text>variables</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Targets><span class=nav-number>1.5.</span> <span class=nav-text>Targets</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#automatic-variables-and-wildcards><span class=nav-number>1.6.</span> <span class=nav-text>automatic variables and wildcards</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%9A%90%E5%BC%8F%E8%A7%84%E5%88%99><span class=nav-number>1.7.</span> <span class=nav-text>隐式规则</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%9D%A1%E4%BB%B6><span class=nav-number>1.8.</span> <span class=nav-text>条件</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%87%BD%E6%95%B0><span class=nav-number>1.9.</span> <span class=nav-text>函数</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#cmake-fundamental><span class=nav-number>2.</span> <span class=nav-text>cmake fundamental</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%B8%B8%E7%94%A8%E5%8F%98%E9%87%8F><span class=nav-number>3.</span> <span class=nav-text>常用变量</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%8C%87%E5%AE%9A%E7%94%9F%E6%88%90%E7%A8%8B%E5%BA%8F><span class=nav-number>4.</span> <span class=nav-text>指定生成程序</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%B7%BB%E5%8A%A0%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%92%8C%E5%BA%93><span class=nav-number>5.</span> <span class=nav-text>添加头文件目录和库</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#find-package-amp-find-path-amp-find-library><span class=nav-number>6.</span> <span class=nav-text>find_package&find_path&find_library</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%BC%96%E8%AF%91%E6%97%B6%E6%B6%88%E6%81%AF%E8%BE%93%E5%87%BA><span class=nav-number>7.</span> <span class=nav-text>编译时消息输出</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%AE%BE%E7%BD%AE%E5%8F%98%E9%87%8F><span class=nav-number>8.</span> <span class=nav-text>设置变量</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84><span class=nav-number>9.</span> <span class=nav-text>控制结构</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%B7%BB%E5%8A%A0%E5%85%B6%E4%BB%96%E5%AD%90%E7%9B%AE%E5%BD%95><span class=nav-number>10.</span> <span class=nav-text>添加其他子目录</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6><span class=nav-number>11.</span> <span class=nav-text>获取文件</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#vs%E4%B8%AD%E6%98%BE%E7%A4%BA%E5%A4%B4%E6%96%87%E4%BB%B6><span class=nav-number>12.</span> <span class=nav-text>vs中显示头文件</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#option%E4%B8%8Eadd-definitions><span class=nav-number>13.</span> <span class=nav-text>option与add_definitions</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E7%A4%BA><span class=nav-number>13.1.</span> <span class=nav-text>生成器表示</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Advanced-cmake><span class=nav-number>14.</span> <span class=nav-text>Advanced cmake</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#Effective-CMake><span class=nav-number>14.0.1.</span> <span class=nav-text>Effective CMake</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E9%80%9A%E7%94%A8><span class=nav-number>14.0.1.1.</span> <span class=nav-text>通用</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%A8%A1%E5%9D%97Modules><span class=nav-number>14.0.1.2.</span> <span class=nav-text>模块Modules</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E9%A1%B9%E7%9B%AEProjects><span class=nav-number>14.0.1.3.</span> <span class=nav-text>项目Projects</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%9B%AE%E6%A0%87-Targets-%E5%8F%8A%E5%85%B6%E5%B1%9E%E6%80%A7-Properties><span class=nav-number>14.0.1.4.</span> <span class=nav-text>目标(Targets)及其属性(Properties)</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AE%8F><span class=nav-number>14.0.1.5.</span> <span class=nav-text>函数与宏</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%BE%AA%E7%8E%AF><span class=nav-number>14.0.1.6.</span> <span class=nav-text>循环</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%8C%85><span class=nav-number>14.0.1.7.</span> <span class=nav-text>包</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91><span class=nav-number>14.0.1.8.</span> <span class=nav-text>交叉编译</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E8%AD%A6%E5%91%8A%E4%B8%8E%E6%8A%A5%E9%94%99><span class=nav-number>14.0.1.9.</span> <span class=nav-text>警告与报错</span></a></ol></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%AE%9E%E6%88%98><span class=nav-number>15.</span> <span class=nav-text>实战</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84><span class=nav-number>15.1.</span> <span class=nav-text>项目结构</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%88%9B%E5%BB%BA%E5%BA%93><span class=nav-number>15.2.</span> <span class=nav-text>创建库</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BA%AF%E5%A4%B4%E6%96%87%E4%BB%B6><span class=nav-number>15.3.</span> <span class=nav-text>接口和纯头文件</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AF%B9%E8%B1%A1%E5%BA%93><span class=nav-number>15.4.</span> <span class=nav-text>对象库</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BD%BF%E7%94%A8%E5%BA%93><span class=nav-number>15.5.</span> <span class=nav-text>使用库</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AE%BE%E7%BD%AE%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E9%93%BE%E6%8E%A5%E5%99%A8%E9%80%89%E9%A1%B9><span class=nav-number>15.6.</span> <span class=nav-text>设置编译器和链接器选项</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%B0%83%E8%AF%95%E7%BC%96%E8%AF%91%E5%99%A8%E9%80%89%E9%A1%B9><span class=nav-number>15.7.</span> <span class=nav-text>调试编译器选项</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%BA%93%E5%88%AB%E5%90%8D><span class=nav-number>15.8.</span> <span class=nav-text>库别名</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%89%93%E5%8C%85%E3%80%81%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%89%E8%A3%85><span class=nav-number>15.9.</span> <span class=nav-text>打包、部署和安装</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99><span class=nav-number>15.10.</span> <span class=nav-text>参考资料</span></a></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>205</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>17</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>196</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a><li class=links-of-blogroll-item><a href=https://www.lllomh.com/ rel=noopener target=_blank title=https://www.lllomh.com/>芈渡</a><li class=links-of-blogroll-item><a href=https://protool-ten.vercel.app/ rel=noopener target=_blank title=https://protool-ten.vercel.app/>protools</a></ul></div><div class="motion-element announcement"><div class=title></div><p class=content><p class=date></div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>文章词云</h3><div class="widget tagcloud" id=myCanvasContainer><canvas height=250 id=resCanvas style=width:100% width=250><ul class=tag-list itemprop=keywords><li class=tag-list-item><a class=tag-list-link href=/tags/CMake/ rel=tag>CMake</a><span class=tag-list-count>1</span></ul></canvas></div></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside> <div id=sidebar-dimmer></div> <footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>1.7m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>25:28</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer> <script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script> <script src=/lib/anime.min.js></script> <script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script> <script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script> <script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script> <script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script> <script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script> <script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script> <script src=/js/utils.js></script> <script src=/js/motion.js></script> <script src=/js/schemes/pisces.js></script> <script src=/js/next-boot.js></script> <script src=/js/bookmark.js></script> <script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	'.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script> <script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script> <script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script> <script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script> <script src=/js/algolia-search.js></script> <script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script> <div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div> <script charset=utf-8 defer src=/js/tagcanvas.js></script> <script charset=utf-8 defer src=/js/tagcloud.js></script> <script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script> <script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script> <script src=/js/src/activate-power-mode.min.js></script> <script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script> 
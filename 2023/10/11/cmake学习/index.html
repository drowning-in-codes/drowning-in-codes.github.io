<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"3G9PZZIKCH","apiKey":"8eb71f5ca3167e9ef3487882f10cfaad","indexName":"SekyoroSearch","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content=在Windows上开发c++相比Linux还是有点不方便,这里介绍CMake,跨平台的构建工具. name=description><meta content=article property=og:type><meta content=cmake学习 property=og:title><meta content=https://www.sekyoro.top/2023/10/11/cmake%E5%AD%A6%E4%B9%A0/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content=在Windows上开发c++相比Linux还是有点不方便,这里介绍CMake,跨平台的构建工具. property=og:description><meta content=zh_CN property=og:locale><meta content=https://i.imgur.com/0mXZUbA.png property=og:image><meta content=https://i.imgur.com/cozY007.png property=og:image><meta content=https://s2.loli.net/2024/07/23/T2xNuyIMd9ZaPRH.png property=og:image><meta content=https://s2.loli.net/2024/07/24/2dorRDC4hYVsbj7.png property=og:image><meta content=https://s2.loli.net/2024/07/25/KifydlhZsekbLva.png property=og:image><meta content=https://s2.loli.net/2024/07/25/SLxahKDtwsZ6dMz.png property=og:image><meta content=https://s2.loli.net/2024/07/25/N3yYAxsBnIatMJ4.png property=og:image><meta content=2023-10-11T09:26:00.000Z property=article:published_time><meta content=2024-07-25T13:15:56.222Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content=CMake property=article:tag><meta content=summary name=twitter:card><meta content=https://i.imgur.com/0mXZUbA.png name=twitter:image><link href=https://www.sekyoro.top/2023/10/11/cmake%E5%AD%A6%E4%B9%A0/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>cmake学习 | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2023/10/11/cmake%E5%AD%A6%E4%B9%A0/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>cmake学习</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2023-10-11 17:26:00" datetime=2023-10-11T17:26:00+08:00>2023-10-11</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2024-07-25 21:15:56" datetime=2024-07-25T21:15:56+08:00 itemprop=dateModified>2024-07-25</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>53k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>48 分钟</span> </span></div></header><div class=post-body itemprop=articleBody><p>在Windows上开发c++相比Linux还是有点不方便,这里介绍CMake,跨平台的构建工具.<br><span id=more></span><h2 id=Before-cmake><a title="Before cmake" class=headerlink href=#Before-cmake></a>Before cmake</h2><p>cmake可以生成makefiles,很多时候我们也是使用的makefiles,当然它也可以生成vsproj,ninja等构建文件.这里以makefiles为例介绍一下构建系统.<blockquote><p>Makefile 用于帮助决定大型程序的哪些部分需要重新编译. 在绝大多数情况下,编译的是 C 或 C++ 文件. 其他语言通常也有自己的工具,其作用与 Make 类似. 除了编译之外,Make 还可以用于需要根据文件变化运行一系列指令的情况.</blockquote><p>流行的 C/C++ 替代构建系统有 SCons、CMake、Bazel 和 Ninja一些代码编辑器（如 Microsoft Visual Studio）也有自己的内置构建工具.<p>Java 有 Ant、Maven 和 Gradle,Go、Rust 和 TypeScript 等其他语言也有自己的构建工具.<p>Python、Ruby 和单纯的Javascript 等解释型语言不需要类似 Makefile 的工具. Makefile 的目标是根据哪些文件发生了变化,编译哪些需要编译的文件.<p>但是,当解释型语言中的文件发生变化时,就不需要重新编译了. 程序运行时,将使用文件的最新版本.<h3 id=syntax><a class=headerlink href=#syntax title=syntax></a>syntax</h3><p>Makefile 由一系列规则组成. 一条规则通常是这样的：<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=section>targets: prerequisites</span></span><br><span class=line>	command</span><br><span class=line>	command</span><br><span class=line>	command</span><br></pre></table></figure><p>目标(targets)是文件名,用空格隔开.通常情况下,每条规则(rule)只有一个目标.<p>命令(command)是一系列通常用于创建目标的步骤,需要以制表符而不是空格开头.<p>先决条件(prerequisites)也是文件名,以空格分隔.在运行目标的命令之前,这些文件必须存在.这些文件也称为依赖项<p>以 hello world 为例开始：<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=section>hello:</span></span><br><span class=line>	echo <span class=string>"Hello, World"</span></span><br><span class=line>	echo <span class=string>"This line will print if the file hello does not exist."</span></span><br></pre></table></figure><p>有一个名为 hello 的目标,这个目标有两条命令,这个目标没有先决条件,然后运行 make hello.<p><strong>只要 hello 文件不存在,命令就会运行</strong>. 要知道hello 既是目标,也是文件.<p>这是因为两者直接联系在一起. <strong>通常情况下,当运行目标文件时（也就是运行目标文件的命令时）,命令会创建一个与目标文件同名的文件</strong>. 在这种情况下,hello 目标不会创建 hello 文件.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=section>blah: cc blah.c -o blah </span></span><br></pre></table></figure><p>运行 make 命令. 由于 make 命令的参数中没有提供目标文件,因此会运行第一个目标文件. 在本例中,只有一个目标（blah）<p>第一次运行时,blah 将被创建. 第二次运行时,你会看到 make: ‘blah’ 是最新的. 这是因为 blah 文件已经存在. 但有一个问题：如果我们修改了 blah.c,然后运行 make,什么都不会重新编译.<p>通过添加一个前提条件来解决这个问题：<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=section>blah: blah.c cc blah.c -o blah </span></span><br></pre></table></figure><p>当我们再次运行 make 时,会发生以下一系列步骤： 第一个目标被选中,因为第一个目标是默认目标<p>这个目标的前提条件是 blah.c ,Make 决定它是否应该运行 blah 目标. <strong>只有当 blah 不存在或 blah.c 比 blah 新时,它才会运行</strong><p>最后一步至关重要,是 make 的精髓所在. <strong>它要做的是判断自上次编译 blah 以来,blah 的先决条件是否发生了变化. 也就是说,如果 blah.c 被修改,运行 make 就应该重新编译该文件</strong>. 为了做到这一点,它会使用文件系统的时间戳作为代理来判断是否有改动. 这是一种合理的启发式方法,因为文件时间戳通常只有在文件被修改时才会发生变化. 但必须认识到,情况并非总是如此. <strong>例如,你可以修改一个文件,然后把该文件的修改时间戳改成旧的. 如果你这样做了,Make 就会错误地认为该文件没有改动,因此可以忽略</strong>.<h3 id=more-examples><a title="more examples" class=headerlink href=#more-examples></a>more examples</h3><p>下面的 Makefile 最终会运行所有三个目标.<p>当你在终端运行 make 时,它会通过一系列步骤编译一个名为 blah 的程序:<p>Make 选择目标 blah,因为第一个目标是默认目标 blah 需要 blah.o,所以 make 搜索 blah.o<p>目标 blah.o 需要 blah.c,所以 make 搜索 blah.c<p>目标 blah.c 没有依赖关系,所以运行 echo 命令.然后运行 cc -c 命令,因为所有 blah.o 的依赖关系都已处理完毕. 然后运行 top cc 命令,因为所有 blah 的依赖关系都已处理完毕.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=section>blah: blah.o</span></span><br><span class=line>	cc blah.o -o blah <span class=comment># Runs third</span></span><br><span class=line></span><br><span class=line><span class=section>blah.o: blah.c</span></span><br><span class=line>	cc -c blah.c -o blah.o <span class=comment># Runs second</span></span><br><span class=line></span><br><span class=line><span class=comment># Typically blah.c would already exist, but I want to limit any additional required files</span></span><br><span class=line><span class=section>blah.c:</span></span><br><span class=line>	echo <span class=string>"int main() { return 0; }"</span> > blah.c <span class=comment># Runs first</span></span><br></pre></table></figure><p>如果删除 blah.c,所有三个目标都将重新运行. 如果编辑它（从而将时间戳改为比 blah.o 新）,则会运行前两个目标. 如果运行 touch blah.o（从而将时间戳改为比 blah 更新）,则只有第一个目标会运行. 如果什么都不改,则所有目标都不会运行<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=section>some_file: other_file</span></span><br><span class=line>	echo <span class=string>"This will always run, and runs second"</span></span><br><span class=line>	touch some_file</span><br><span class=line></span><br><span class=line><span class=section>other_file:</span></span><br><span class=line>	echo <span class=string>"This will always run, and runs first"</span></span><br></pre></table></figure><p>这个例子, 它将始终运行两个目标,因为 some_file 依赖于 other_file,而 other_file 从未创建.<h3 id=clean><a class=headerlink href=#clean title=clean></a>clean</h3><p>clean 经常被用作删除其他目标输出的目标,但在 Make 中它并不是一个特殊的词.<p>请注意,clean 在这里做了两件新事情:<strong>它不是第一个目标(默认),也不是先决条件.这意味着除非你明确调用 make clean,否则它永远不会运行</strong>. 如果你碰巧有一个名为 clean 的文件,这个目标就不会运行,这不是我们想要的. 如何解决这个问题,使用 .PHONY 😋<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=section>some_file: </span></span><br><span class=line>	touch some_file</span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -f some_file</span><br></pre></table></figure><h3 id=variables><a class=headerlink href=#variables title=variables></a>variables</h3><p>变量只能是字符串. 通常情况下,您需要使用 :=,但 = 也可以.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>files := file1 file2</span><br><span class=line><span class=section>some_file: <span class=variable>$(files)</span></span></span><br><span class=line>	echo <span class=string>"Look at this variable: "</span> <span class=variable>$(files)</span></span><br><span class=line>	touch some_file</span><br><span class=line></span><br><span class=line><span class=section>file1:</span></span><br><span class=line>	touch file1</span><br><span class=line><span class=section>file2:</span></span><br><span class=line>	touch file2</span><br><span class=line></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -f file1 file2 some_file</span><br></pre></table></figure><p>单引号或双引号对 Make 没有任何意义. 它们只是分配给变量的字符. 不过,引号对 shell/bash 很有用,在 printf 等命令中需要用到. 在本例中,两条命令的行为是一样的：<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>a := one two<span class=comment># a is set to the string "one two"</span></span><br><span class=line>b := 'one two' <span class=comment># Not recommended. b is set to the string "'one two'"</span></span><br><span class=line><span class=section>all:</span></span><br><span class=line>	printf '$a'</span><br><span class=line>	printf $b</span><br></pre></table></figure><p>使用 ${} 或 $() 引用变量<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>x := dude</span><br><span class=line><span class=section>all:</span></span><br><span class=line>	echo <span class=variable>$(x)</span></span><br><span class=line>	echo ${x}</span><br><span class=line></span><br><span class=line>	<span class=comment># Bad practice, but works</span></span><br><span class=line>	echo $x </span><br></pre></table></figure><h3 id=Targets><a class=headerlink href=#Targets title=Targets></a>Targets</h3><p>make多个目标,并希望所有目标都运行？<p>写一个一个all. 由于这是列出的第一条规则,如果调用 make 时没有指定目标,它将默认运行.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=section>all: one two three</span></span><br><span class=line></span><br><span class=line><span class=section>one:</span></span><br><span class=line>	touch one</span><br><span class=line><span class=section>two:</span></span><br><span class=line>	touch two</span><br><span class=line><span class=section>three:</span></span><br><span class=line>	touch three</span><br><span class=line></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -f one two three</span><br></pre></table></figure><p>当一条规则有多个目标时,将针对每个目标运行命令. $@ 是一个自动变量,包含目标名称.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=section>all: f1.o f2.o</span></span><br><span class=line></span><br><span class=line>f1.o f2.o:</span><br><span class=line>	echo <span class=variable>$@</span></span><br><span class=line><span class=comment># Equivalent to:</span></span><br><span class=line><span class=comment># f1.o:</span></span><br><span class=line><span class=comment>#	 echo f1.o</span></span><br><span class=line><span class=comment># f2.o:</span></span><br><span class=line><span class=comment>#	 echo f2.o</span></span><br></pre></table></figure><h3 id=automatic-variables-and-wildcards><a title="automatic variables and wildcards" class=headerlink href=#automatic-variables-and-wildcards></a>automatic variables and wildcards</h3><p>在 Make 中,<em> 和 % 都被称为通配符,但它们的含义完全不同. </em> 在文件系统中搜索匹配的文件名.<p>建议始终将其封装在<strong>通配符函数</strong>中<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=comment># Print out file information about every .c file</span></span><br><span class=line><span class=section>print: $(wildcard *.c)</span></span><br><span class=line>	ls -la  <span class=variable>$?</span></span><br></pre></table></figure><p>*可以在目标、先决条件或通配符功能中使用<p><strong>注意</strong>: 不能在变量定义中直接使用 *<p><strong>注意</strong>: 当 * 不能匹配任何文件时,它将保持原样（除非在通配符功能中运行<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line>thing_wrong := *.o <span class=comment># Don't do this! '*' will not get expanded</span></span><br><span class=line>thing_right := <span class=variable>$(<span class=built_in>wildcard</span> *.o)</span></span><br><span class=line></span><br><span class=line><span class=section>all: one two three four</span></span><br><span class=line></span><br><span class=line><span class=comment># Fails, because $(thing_wrong) is the string "*.o"</span></span><br><span class=line><span class=section>one: <span class=variable>$(thing_wrong)</span></span></span><br><span class=line></span><br><span class=line><span class=comment># Stays as *.o if there are no files that match this pattern :(</span></span><br><span class=line><span class=section>two: *.o </span></span><br><span class=line></span><br><span class=line><span class=comment># Works as you would expect! In this case, it does nothing.</span></span><br><span class=line><span class=section>three: <span class=variable>$(thing_right)</span></span></span><br><span class=line></span><br><span class=line><span class=comment># Same as rule three</span></span><br><span class=line><span class=section>four: $(wildcard *.o)</span></span><br></pre></table></figure><p>% 非常有用,但由于其使用场合多种多样,所以有些令人困惑. <strong>在 “匹配 “模式下使用时,它会匹配字符串中的一个或多个字符</strong>,这种匹配称为词干.<p><strong>在 “替换 “模式下使用时,它会将匹配到的字符串替换为字符串中的字符串.% 最常用于规则定义和某些特定函数中</strong>.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=section>hey: one two</span></span><br><span class=line>	<span class=comment># Outputs "hey", since this is the target name</span></span><br><span class=line>	echo <span class=variable>$@</span></span><br><span class=line></span><br><span class=line>	<span class=comment># Outputs all prerequisites newer than the target</span></span><br><span class=line>	echo <span class=variable>$?</span></span><br><span class=line></span><br><span class=line>	<span class=comment># Outputs all prerequisites</span></span><br><span class=line>	echo <span class=variable>$^</span></span><br><span class=line></span><br><span class=line>	<span class=comment># Outputs the first prerequisite</span></span><br><span class=line>	echo <span class=variable>$<</span></span><br><span class=line></span><br><span class=line>	touch hey</span><br><span class=line></span><br><span class=line><span class=section>one:</span></span><br><span class=line>	touch one</span><br><span class=line></span><br><span class=line><span class=section>two:</span></span><br><span class=line>	touch two</span><br><span class=line></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -f hey one two</span><br></pre></table></figure><h3 id=隐式规则><a class=headerlink href=#隐式规则 title=隐式规则></a>隐式规则</h3><p>下面是一个隐含规则列表：<ul><li>Compiling a C program: <code>n.o</code> is made automatically from <code>n.c</code> with a command of the form <code>$(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@</code><li>Compiling a C++ program: <code>n.o</code> is made automatically from <code>n.cc</code> or <code>n.cpp</code> with a command of the form <code>$(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $^ -o $@</code><li>Linking a single object file: <code>n</code> is made automatically from <code>n.o</code> by running the command <code>$(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@</code></ul><p>这些值默认<ul><li><code>CC</code>: Program for compiling C programs; default <code>cc</code><li><code>CXX</code>: Program for compiling C++ programs; default <code>g++</code><li><code>CFLAGS</code>: Extra flags to give to the C compiler<li><code>CXXFLAGS</code>: Extra flags to give to the C++ compiler<li><code>CPPFLAGS</code>: Extra flags to give to the C preprocessor<li><code>LDFLAGS</code>: Extra flags to give to compilers when they are supposed to invoke the linke</ul><figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>CC = gcc <span class=comment># Flag for implicit rules</span></span><br><span class=line>CFLAGS = -g <span class=comment># Flag for implicit rules. Turn on debug info</span></span><br><span class=line></span><br><span class=line><span class=comment># Implicit rule #1: blah is built via the C linker implicit rule</span></span><br><span class=line><span class=comment># Implicit rule #2: blah.o is built via the C compilation implicit rule, because blah.c exists</span></span><br><span class=line><span class=section>blah: blah.o</span></span><br><span class=line></span><br><span class=line><span class=section>blah.c:</span></span><br><span class=line>	echo <span class=string>"int main() { return 0; }"</span> > blah.c</span><br><span class=line></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -f blah*</span><br></pre></table></figure><p>静态模式规则是在 Makefile 中少写代码的另一种方法.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=section>targets...: target-pattern: prereq-patterns ...</span></span><br><span class=line>   commands</span><br></pre></table></figure><p>其本质是通过目标模式（通过 % 通配符）匹配给定目标. 匹配到的内容称为词干. 然后,将词干代入先决条件模式,生成目标的先决条件.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line>objects = foo.o bar.o all.o</span><br><span class=line><span class=section>all: <span class=variable>$(objects)</span></span></span><br><span class=line>	<span class=variable>$(CC)</span> <span class=variable>$^</span> -o all</span><br><span class=line></span><br><span class=line><span class=section>foo.o: foo.c</span></span><br><span class=line>	<span class=variable>$(CC)</span> -c foo.c -o foo.o</span><br><span class=line></span><br><span class=line><span class=section>bar.o: bar.c</span></span><br><span class=line>	<span class=variable>$(CC)</span> -c bar.c -o bar.o</span><br><span class=line></span><br><span class=line><span class=section>all.o: all.c</span></span><br><span class=line>	<span class=variable>$(CC)</span> -c all.c -o all.o</span><br><span class=line></span><br><span class=line><span class=section>all.c:</span></span><br><span class=line>	echo <span class=string>"int main() { return 0; }"</span> > all.c</span><br><span class=line></span><br><span class=line><span class=comment># Note: all.c does not use this rule because Make prioritizes more specific matches when there is more than one match.</span></span><br><span class=line><span class=section>%.c:</span></span><br><span class=line>	touch <span class=variable>$@</span></span><br><span class=line></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -f *.c *.o all</span><br></pre></table></figure><p>更高效的方法<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line>objects = foo.o bar.o all.o</span><br><span class=line><span class=section>all: <span class=variable>$(objects)</span></span></span><br><span class=line>	<span class=variable>$(CC)</span> <span class=variable>$^</span> -o all</span><br><span class=line></span><br><span class=line><span class=comment># Syntax - targets ...: target-pattern: prereq-patterns ...</span></span><br><span class=line><span class=comment># In the case of the first target, foo.o, the target-pattern matches foo.o and sets the "stem" to be "foo".</span></span><br><span class=line><span class=comment># It then replaces the '%' in prereq-patterns with that stem</span></span><br><span class=line><span class=variable>$(objects)</span>: %.o: %.c</span><br><span class=line>	<span class=variable>$(CC)</span> -c <span class=variable>$^</span> -o <span class=variable>$@</span></span><br><span class=line></span><br><span class=line><span class=section>all.c:</span></span><br><span class=line>	echo <span class=string>"int main() { return 0; }"</span> > all.c</span><br><span class=line></span><br><span class=line><span class=comment># Note: all.c does not use this rule because Make prioritizes more specific matches when there is more than one match.</span></span><br><span class=line><span class=section>%.c:</span></span><br><span class=line>	touch <span class=variable>$@</span></span><br><span class=line></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -f *.c *.o all</span><br></pre></table></figure><p>过滤器函数可用于静态模式规则,以匹配正确的文件.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line>obj_files = foo.result bar.o lose.o</span><br><span class=line>src_files = foo.raw bar.c lose.c</span><br><span class=line></span><br><span class=line><span class=section>all: <span class=variable>$(obj_files)</span></span></span><br><span class=line><span class=comment># Note: PHONY is important here. Without it, implicit rules will try to build the executable "all", since the prereqs are ".o" files.</span></span><br><span class=line><span class=meta><span class=meta-keyword>.PHONY</span>: all </span></span><br><span class=line></span><br><span class=line><span class=comment># Ex 1: .o files depend on .c files. Though we don't actually make the .o file.</span></span><br><span class=line><span class=variable>$(<span class=built_in>filter</span> %.o,<span class=variable>$(obj_files)</span>)</span>: %.o: %.c</span><br><span class=line>	echo <span class=string>"target: <span class=variable>$@</span> prereq: <span class=variable>$<</span>"</span></span><br><span class=line></span><br><span class=line><span class=comment># Ex 2: .result files depend on .raw files. Though we don't actually make the .result file.</span></span><br><span class=line><span class=variable>$(<span class=built_in>filter</span> %.result,<span class=variable>$(obj_files)</span>)</span>: %.result: %.raw</span><br><span class=line>	echo <span class=string>"target: <span class=variable>$@</span> prereq: <span class=variable>$<</span>"</span> </span><br><span class=line></span><br><span class=line>%.c %.raw:</span><br><span class=line>	touch <span class=variable>$@</span></span><br><span class=line></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -f <span class=variable>$(src_files)</span></span><br></pre></table></figure><p>模式规则经常被使用,但很容易混淆. 你可以从两个方面来看待它们：<ol><li>一种定义自己的隐式规则的方法<li>一种更简单的静态模式规则形式</ol><figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=comment># Define a pattern rule that compiles every .c file into a .o file</span></span><br><span class=line>%.o : %.c</span><br><span class=line>		<span class=variable>$(CC)</span> -c <span class=variable>$(CFLAGS)</span> <span class=variable>$(CPPFLAGS)</span> <span class=variable>$<</span> -o <span class=variable>$@</span></span><br></pre></table></figure><p>模式规则在目标中包含一个”%”. 该’%’匹配任何非空字符串,其他字符则自行匹配.<p>模式规则<strong>先决条件中的”%”代表与目标中的”%”匹配的同一词干</strong>.<p>双冒号规则很少使用,但允许为同一目标定义多个规则. 如果这些规则是单冒号,则会打印警告,并且只会运行第二组命令.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=section>all: blah</span></span><br><span class=line><span class=section>blah::</span></span><br><span class=line>	echo <span class=string>"hello"</span></span><br><span class=line><span class=section>blah::</span></span><br><span class=line>	echo <span class=string>"hello again"</span></span><br></pre></table></figure><p>在命令前添加 @,以阻止命令被打印<p>也可以使用 -s 运行 make,在每一行前添加 @.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=section>all: </span></span><br><span class=line>	@echo <span class=string>"This make line will not be printed"</span></span><br><span class=line>	echo <span class=string>"But this will"</span></span><br></pre></table></figure><p>每条命令都在一个新的 shell 中运行<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=section>all: </span></span><br><span class=line>	cd ..</span><br><span class=line>	<span class=comment># The cd above does not affect this line, because each command is effectively run in a new shell</span></span><br><span class=line>	echo `pwd`</span><br><span class=line></span><br><span class=line>	<span class=comment># This cd command affects the next because they are on the same line</span></span><br><span class=line>	cd ..;echo `pwd`</span><br><span class=line></span><br><span class=line>	<span class=comment># Same as above</span></span><br><span class=line>	cd ..; \</span><br><span class=line>	echo `pwd`</span><br></pre></table></figure><p>修改默认shell<code>/bin/sh</code><figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>SHELL=/bin/bash</span><br><span class=line></span><br><span class=line><span class=section>cool:</span></span><br><span class=line>	echo <span class=string>"Hello from bash"</span></span><br></pre></table></figure><p>如果希望字符串带有美元符号,可以使用 $$. 这就是在 bash 或 sh 中使用 shell 变量的方法,请注意 Makefile 变量和 Shell 变量之间的区别.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>make_var = I am a make variable</span><br><span class=line><span class=section>all:</span></span><br><span class=line>	<span class=comment># Same as running "sh_var='I am a shell variable'; echo $sh_var" in the shell</span></span><br><span class=line>	sh_var='I am a shell variable'; echo $$sh_var</span><br><span class=line></span><br><span class=line>	<span class=comment># Same as running "echo I am a make variable" in the shell</span></span><br><span class=line>	echo <span class=variable>$(make_var)</span></span><br></pre></table></figure><p>在运行 make 时添加 -k,即使出现错误也能继续运行. 在命令前添加 - 可以抑制错误<p>在 make 中添加 -i 可以让每条命令都出错.<p>要递归调用 makefile,请使用特殊的 $(MAKE) 而不是 make,因为它会为你传递 make 标志,而自身不会受其影响.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>new_contents = <span class=string>"hello:\n\ttouch inside_file"</span></span><br><span class=line><span class=section>all:</span></span><br><span class=line>	mkdir -p subdir</span><br><span class=line>	printf <span class=variable>$(new_contents)</span> | sed -e 's/^ //' > subdir/makefile</span><br><span class=line>	cd subdir && <span class=variable>$(MAKE)</span></span><br><span class=line></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -rf subdir</span><br></pre></table></figure><p>当 Make 启动时,它会<strong>自动从执行时设置的所有环境变量中创建 Make 变量</strong>.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment># Run this with "export shell_env_var='I am an environment variable'; make"</span></span><br><span class=line><span class=section>all:</span></span><br><span class=line>	<span class=comment># Print out the Shell variable</span></span><br><span class=line>	echo $$shell_env_var</span><br><span class=line></span><br><span class=line>	<span class=comment># Print out the Make variable</span></span><br><span class=line>	echo <span class=variable>$(shell_env_var)</span></span><br></pre></table></figure><p>export指令使用一个变量,并将其设置为所有 shell 命令的环境：<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>shell_env_var=Shell env var, created inside of Make</span><br><span class=line><span class=keyword>export</span> shell_env_var</span><br><span class=line><span class=section>all:</span></span><br><span class=line>	echo <span class=variable>$(shell_env_var)</span></span><br><span class=line>	echo $$shell_env_var</span><br></pre></table></figure><p>设置一个目标导出变量<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=section>.EXPORT_ALL_VARIABLES:</span></span><br><span class=line>new_contents = <span class=string>"hello:\n\techo \$<span class=variable>$(cooly)</span>"</span></span><br><span class=line></span><br><span class=line>cooly = <span class=string>"The subdirectory can see me!"</span></span><br><span class=line><span class=comment># This would nullify the line above: unexport cooly</span></span><br><span class=line></span><br><span class=line><span class=section>all:</span></span><br><span class=line>	mkdir -p subdir</span><br><span class=line>	printf <span class=variable>$(new_contents)</span> | sed -e 's/^ //' > subdir/makefile</span><br><span class=line>	@echo <span class=string>"---MAKEFILE CONTENTS---"</span></span><br><span class=line>	@cd subdir && cat makefile</span><br><span class=line>	@echo <span class=string>"---END MAKEFILE CONTENTS---"</span></span><br><span class=line>	cd subdir && <span class=variable>$(MAKE)</span></span><br><span class=line></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -rf subdir</span><br></pre></table></figure><p>变量有两种类型：<p>递归（使用 =）—只在使用命令时查找变量,而不是在定义变量时查找.<p>简单扩展（使用 :=）—就像普通的命令式编程—只扩展目前已定义的变量.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=comment># Recursive variable. This will print "later" below</span></span><br><span class=line>one = one ${later_variable}</span><br><span class=line><span class=comment># Simply expanded variable. This will not print "later" below</span></span><br><span class=line>two := two ${later_variable}</span><br><span class=line></span><br><span class=line>later_variable = later</span><br><span class=line></span><br><span class=line><span class=section>all: </span></span><br><span class=line>	echo <span class=variable>$(one)</span></span><br><span class=line>	echo <span class=variable>$(two)</span></span><br></pre></table></figure><p><code>?=</code> only sets variables if they have not yet been set<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>one = hello</span><br><span class=line>one ?= will not be set</span><br><span class=line>two ?= will be set</span><br><span class=line></span><br><span class=line><span class=section>all: </span></span><br><span class=line>	echo <span class=variable>$(one)</span></span><br><span class=line>	echo <span class=variable>$(two)</span></span><br></pre></table></figure><p>行尾的空格不会被删除,但行首的空格会被删除. 要使用单空格创建变量,请使用 $(nullstring)<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>with_spaces = hello   <span class=comment># with_spaces has many spaces after "hello"</span></span><br><span class=line>after = <span class=variable>$(with_spaces)</span>there</span><br><span class=line></span><br><span class=line>nullstring =</span><br><span class=line>space = <span class=variable>$(nullstring)</span> <span class=comment># Make a variable with a single space.</span></span><br><span class=line></span><br><span class=line><span class=section>all: </span></span><br><span class=line>	echo <span class=string>"<span class=variable>$(after)</span>"</span></span><br><span class=line>	echo start<span class=string>"<span class=variable>$(space)</span>"</span>end</span><br></pre></table></figure><p>未定义变量实际上是一个空字符串<p>使用<code>+=</code>添加<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>foo := start</span><br><span class=line>foo += more</span><br><span class=line></span><br><span class=line><span class=section>all: </span></span><br><span class=line>	echo <span class=variable>$(foo)</span></span><br></pre></table></figure><p>使用 override 可以覆盖命令行变量.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment># Overrides command line arguments</span></span><br><span class=line><span class=keyword>override</span> option_one = did_override</span><br><span class=line><span class=comment># Does not override command line arguments</span></span><br><span class=line>option_two = not_override</span><br><span class=line><span class=section>all: </span></span><br><span class=line>	echo <span class=variable>$(option_one)</span></span><br><span class=line>	echo <span class=variable>$(option_two)</span></span><br></pre></table></figure><p>定义指令并不是一个函数,尽管它看起来像. <strong>define/endef 只是创建一个变量,并将其设置为一系列命令</strong>. 请注意,这与在命令之间使用分号有点不同,因为每个命令都会在单独的 shell 中运行.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>one = <span class=keyword>export</span> blah=<span class=string>"I was set!"</span>; echo $$blah</span><br><span class=line></span><br><span class=line><span class=keyword>define</span> two</span><br><span class=line><span class=keyword>export</span> blah=<span class=string>"I was set!"</span></span><br><span class=line>echo $$blah</span><br><span class=line><span class=keyword>endef</span></span><br><span class=line></span><br><span class=line><span class=section>all: </span></span><br><span class=line>	@echo <span class=string>"This prints 'I was set'"</span></span><br><span class=line>	@<span class=variable>$(one)</span></span><br><span class=line>	@echo <span class=string>"This does not print 'I was set' because each command runs in a separate shell"</span></span><br><span class=line>	@<span class=variable>$(two)</span></span><br></pre></table></figure><p>可为特定目标设置变量,也可以为特定目标模式设置变量<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=section>all: one = cool</span></span><br><span class=line></span><br><span class=line><span class=section>all: </span></span><br><span class=line>	echo one is defined: <span class=variable>$(one)</span></span><br><span class=line></span><br><span class=line><span class=section>other:</span></span><br><span class=line>	echo one is nothing: <span class=variable>$(one)</span></span><br><span class=line>	</span><br><span class=line><span class=section>%.c: one = cool</span></span><br><span class=line></span><br><span class=line><span class=section>blah.c: </span></span><br><span class=line>	echo one is defined: <span class=variable>$(one)</span></span><br><span class=line></span><br><span class=line><span class=section>other:</span></span><br><span class=line>	echo one is nothing: <span class=variable>$(one)</span></span><br><span class=line>	</span><br></pre></table></figure><h3 id=条件><a class=headerlink href=#条件 title=条件></a>条件</h3><figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>foo = ok</span><br><span class=line><span class=section>all:</span></span><br><span class=line><span class=keyword>ifeq</span> (<span class=variable>$(foo)</span>, ok)</span><br><span class=line>	echo <span class=string>"foo equals ok"</span></span><br><span class=line><span class=keyword>else</span></span><br><span class=line>	echo <span class=string>"nope"</span></span><br><span class=line><span class=keyword>endif</span></span><br></pre></table></figure><p>检查变量是否为空<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line>nullstring =</span><br><span class=line>foo = <span class=variable>$(nullstring)</span> <span class=comment># end of line; there is a space here</span></span><br><span class=line></span><br><span class=line><span class=section>all:</span></span><br><span class=line><span class=keyword>ifeq</span> (<span class=variable>$(<span class=built_in>strip</span> <span class=variable>$(foo)</span>)</span>,)</span><br><span class=line>	echo <span class=string>"foo is empty after being stripped"</span></span><br><span class=line><span class=keyword>endif</span></span><br><span class=line><span class=keyword>ifeq</span> (<span class=variable>$(nullstring)</span>,)</span><br><span class=line>	echo <span class=string>"nullstring doesn't even have spaces"</span></span><br><span class=line><span class=keyword>endif</span></span><br></pre></table></figure><p>ifdef 不会扩展变量引用；它只是查看是否定义了某个变量<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line>bar =</span><br><span class=line>foo = <span class=variable>$(bar)</span></span><br><span class=line></span><br><span class=line><span class=section>all:</span></span><br><span class=line><span class=keyword>ifdef</span> foo</span><br><span class=line>	echo <span class=string>"foo is defined"</span></span><br><span class=line><span class=keyword>endif</span></span><br><span class=line><span class=keyword>ifndef</span> bar</span><br><span class=line>	echo <span class=string>"but bar is not"</span></span><br><span class=line><span class=keyword>endif</span></span><br></pre></table></figure><p>查看make标志,使用 findstring 和 MAKEFLAGS 测试 make 标志. 使用 make -i 运行此示例,即可看到它打印出 echo 语句.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=section>all:</span></span><br><span class=line><span class=comment># Search for the "-i" flag. MAKEFLAGS is just a list of single characters, one per flag. So look for "i" in this case.</span></span><br><span class=line><span class=keyword>ifneq</span> (,<span class=variable>$(<span class=built_in>findstring</span> i, <span class=variable>$(MAKEFLAGS)</span>)</span>)</span><br><span class=line>	echo <span class=string>"i was passed to MAKEFLAGS"</span></span><br><span class=line><span class=keyword>endif</span></span><br></pre></table></figure><h3 id=函数><a class=headerlink href=#函数 title=函数></a>函数</h3><p>函数主要用于文本处理. 使用 $(fn, arguments) 或 ${fn, arguments} 调用函数. Make 有大量内置函数.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>bar := ${subst not,<span class=string>"totally"</span>, <span class=string>"I am not superman"</span>}</span><br><span class=line><span class=section>all: </span></span><br><span class=line>	@echo <span class=variable>$(bar)</span></span><br></pre></table></figure><p>函数 subst 将not替换为totally.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>comma := , empty:= space := <span class=variable>$(empty)</span> <span class=variable>$(empty)</span> foo := a b c bar := <span class=variable>$(<span class=built_in>subst</span> <span class=variable>$(space)</span>, <span class=variable>$(comma)</span> , <span class=variable>$(foo)</span>)</span> <span class=comment># Watch out! all:  # Output is ", a , b , c". Notice the spaces introduced @echo $(bar)</span></span><br></pre></table></figure><p>此外还有patsubst,foreach,if,call,shell,filter等函数,<p><code>$(patsubst pattern,replacement,text)</code><p>还有一种只替换后缀的速记方法：$(text:suffix=replacement).注意:不要为这种速记方法添加额外的空格.它会被视为搜索或替换词.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>foo := a.o b.o l.a c.o</span><br><span class=line>one := <span class=variable>$(<span class=built_in>patsubst</span> %.o,%.c,<span class=variable>$(foo)</span>)</span></span><br><span class=line><span class=comment># This is a shorthand for the above</span></span><br><span class=line>two := $(foo:%.o=%.c)</span><br><span class=line><span class=comment># This is the suffix-only shorthand, and is also equivalent to the above.</span></span><br><span class=line>three := $(foo:.o=.c)</span><br><span class=line></span><br><span class=line><span class=section>all:</span></span><br><span class=line>	echo <span class=variable>$(one)</span></span><br><span class=line>	echo <span class=variable>$(two)</span></span><br><span class=line>	echo <span class=variable>$(three)</span></span><br></pre></table></figure><p><code>$(foreach var,list,text)</code> 它将一个单词列表（用空格分隔）转换为另一个单词列表.<p>var 设置为列表中的每个单词,text 则为每个单词展开.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>foo := who are you</span><br><span class=line><span class=comment># For each "word" in foo, output that same word with an exclamation after</span></span><br><span class=line>bar := <span class=variable>$(<span class=built_in>foreach</span> wrd,<span class=variable>$(foo)</span>,<span class=variable>$(wrd)</span>!)</span></span><br><span class=line></span><br><span class=line><span class=section>all:</span></span><br><span class=line>	<span class=comment># Output is "who! are! you!"</span></span><br><span class=line>	@echo <span class=variable>$(bar)</span></span><br></pre></table></figure><p>if 检查第一个参数是否为非空. 如果是,则运行第二个参数,否则运行第三个参数<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>foo := <span class=variable>$(<span class=built_in>if</span> this-is-not-empty,then!,else!)</span></span><br><span class=line>empty :=</span><br><span class=line>bar := <span class=variable>$(<span class=built_in>if</span> <span class=variable>$(empty)</span>,then!,else!)</span></span><br><span class=line></span><br><span class=line><span class=section>all:</span></span><br><span class=line>	@echo <span class=variable>$(foo)</span></span><br><span class=line>	@echo <span class=variable>$(bar)</span></span><br></pre></table></figure><p>m ake支持创建基本函数,只需通过创建一个变量来 “定义 “函数,但要使用 (0)、(1) 等参数. 然后使用特殊的调用内置函数调用该函数. 语法是 <code>(call variable,param,param)</code>. (0)是变量,(1)、(2)等是参数.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>sweet_new_fn = Variable Name: $(0) First: $(1) Second: $(2) Empty Variable: $(3)</span><br><span class=line></span><br><span class=line><span class=section>all:</span></span><br><span class=line>	<span class=comment># Outputs "Variable Name: sweet_new_fn First: go Second: tigers Empty Variable:"</span></span><br><span class=line>	@echo <span class=variable>$(<span class=built_in>call</span> sweet_new_fn, go, tigers)</span></span><br></pre></table></figure><p><code>filter</code>函数用于从列表中选择符合特定模式的某些元素. 例如,这将选择 obj_files 中以 .o 结尾的所有元素.<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment># call function</span></span><br><span class=line><span class=section>all: </span></span><br><span class=line>	@echo <span class=variable>$(<span class=built_in>shell</span> ls -la)</span> <span class=comment># Very ugly because the newlines are gone!</span></span><br><span class=line>	</span><br><span class=line>obj_files = foo.result bar.o lose.o</span><br><span class=line>filtered_files = <span class=variable>$(<span class=built_in>filter</span> %.o,<span class=variable>$(obj_files)</span>)</span></span><br><span class=line></span><br><span class=line><span class=section>all:</span></span><br><span class=line>	@echo <span class=variable>$(filtered_files)</span></span><br></pre></table></figure><p>include 指令告诉 make 读取一个或多个其他 makefile. 它是 makefile 中的一行<p>这在使用 -M 等编译器标志时特别有用,这些标志会根据源代码创建 Makefile. 例如,如果某些 c 文件包含一个头文件,那么该头文件就会被添加到由 gcc 编写的 Makefile 中.<p>使用 vpath 指定存在某些先决条件集的位置. 其格式为 vpath \<pattern> <目录,空格/冒号分隔> <\pattern> 可以有一个 %,可以匹配任何 0 个或多个字符. 您也可以使用变量 VPATH 进行全局操作 <figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>vpath</span> %.h ../headers ../other-directory</span><br><span class=line></span><br><span class=line><span class=comment># Note: vpath allows blah.h to be found even though blah.h is never in the current directory</span></span><br><span class=line><span class=section>some_binary: ../headers blah.h</span></span><br><span class=line>	touch some_binary</span><br><span class=line></span><br><span class=line><span class=section>../headers:</span></span><br><span class=line>	mkdir ../headers</span><br><span class=line></span><br><span class=line><span class=comment># We call the target blah.h instead of ../headers/blah.h, because that's the prereq that some_binary is looking for</span></span><br><span class=line><span class=comment># Typically, blah.h would already exist and you wouldn't need this.</span></span><br><span class=line><span class=section>blah.h:</span></span><br><span class=line>	touch ../headers/blah.h</span><br><span class=line></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -rf ../headers</span><br><span class=line>	rm -f some_binary</span><br></pre></table></figure> <p>在目标中添加 .PHONY 可以防止 Make 将假目标与文件名混淆. 在本例中,如果创建了 clean 文件,仍将运行 make clean.</p> <p>“phony”目标的名称通常很少是文件名,在实践中很多人都会跳过这一点</p> <figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=section>some_file:</span></span><br><span class=line>	touch some_file</span><br><span class=line>	touch clean</span><br><span class=line></span><br><span class=line><span class=meta><span class=meta-keyword>.PHONY</span>: clean</span></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -f some_file</span><br><span class=line>	rm -f clean</span><br></pre></table></figure> <p>如果命令返回非零的退出状态,make 工具将停止运行规则（并返回先决条件）</p> <p>如果规则以这种方式失败,DELETE_ON_ERROR 将删除规则的目标. 这将发生在所有目标上,而不仅仅是像 PHONY 这样的目标. 尽管出于历史原因,make 并没有这样做,但最好还是一直使用这个功能.</p> <figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=section>.DELETE_ON_ERROR:</span></span><br><span class=line><span class=section>all: one two</span></span><br><span class=line></span><br><span class=line><span class=section>one:</span></span><br><span class=line>	touch one</span><br><span class=line>	false</span><br><span class=line></span><br><span class=line><span class=section>two:</span></span><br><span class=line>	touch two</span><br><span class=line>	false</span><br></pre></table></figure> <h2 id=cmake-fundamental><a title="cmake fundamental" class=headerlink href=#cmake-fundamental></a>cmake fundamental</h2><p>在Windows上可选择的构建后端有vs,codeblocks这种软件的文件结构,或者单纯的Makefiles以及Ninja.相当于忽略了几个项目构建的差异.</p> <p><img alt=image-20231013105520974 data-src=https://i.imgur.com/0mXZUbA.png style=zoom:50%;></p> <h2 id=常用变量><a class=headerlink href=#常用变量 title=常用变量></a>常用变量</h2><p><code>PROJECT_BINARY_DIR</code></p> <p>编译生成项目的目录</p> <p><code>PROJECT_SOURCE_DIR</code></p> <p>顶层目录</p> <p><code>EXECUTABLE_OUTPUT_PATH</code>以及<code>LIBRARY_OUTPUT_PATH</code></p> <p>分别用来重新定义最终结果的存放目录</p> <p><code>CMAKE_ARCHIVE_OUTPUT_DIRECTORY</code>：默认存放静态库的文件夹位置；</p> <p><code>CMAKE_LIBRARY_OUTPUT_DIRECTORY</code>：默认存放动态库的文件夹位置；</p> <p><code>LIBRARY_OUTPUT_PATH</code>：默认存放库文件的位置,如果产生的是静态库并且没有指定 CMAKE_ARCHIVE_OUTPUT_DIRECTORY 则存放在该目录下,动态库也类似；</p> <p><code>CMAKE_RUNTIME_OUTPUT_DIRECTORY</code>：存放可执行软件的目录；</p> <p><code>CMAKE_CXX_FLAGS</code>和<code>CMAKE_C_FLAGS</code></p> <p>设置C/ C++编译选项,<code>CMAKE_C_COMPILER</code>设置对应编译器路径.</p> <p><code>BUILD_SHARED_LIBS</code></p> <p>用来控制默认的库编译方式,如果不进行设置,使用ADD_LIBRARY 并没有指定库类型的情况下,默认编译生成的库都是静态库.</p> <p>此外还有一些系统信息</p> <p><img alt=image-20231013163518609 data-src=https://i.imgur.com/cozY007.png></p> <p>使用$ENV{}调用系统变量.</p> <h2 id=指定生成程序><a class=headerlink href=#指定生成程序 title=指定生成程序></a>指定生成程序</h2><figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>add_library</span>(&LTname> [STATIC | SHARED | MODULE]</span><br><span class=line>            [EXCLUDE_FROM_ALL]</span><br><span class=line>            source1 [source2 ...])</span><br></pre></table></figure> <p>将源码source构建成一个库, 供他人使用</p> <p><code>[STATIC | SHARED | MODULE]</code> ：类型有三种</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>add_executable</span>(< name> [WIN32] [MACOSX_BUNDLE]</span><br><span class=line>                [EXCLUDE_FROM_ALL]  source1 source2 … sourceN)</span><br></pre></table></figure> <p>使用给定的源文件,为工程引入一个可执行文件.引入一个名为< name>的可执行目标,该目标会由调用该命令时在源文件列表中指定的源文件来构建</p> <h2 id=添加头文件目录和库><a class=headerlink href=#添加头文件目录和库 title=添加头文件目录和库></a>添加头文件目录和库</h2><figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>include_directories</span>([AFTER|BEFORE] [SYSTEM]  dir1  dir2 ...)</span><br><span class=line><span class=keyword>target_include_directories</span>()</span><br></pre></table></figure> <p>将给定目录 dir1 dir2 加给编译器搜索到的包含文件 .默认情况下,加到目录列表的最后,target_include_directories可以指定针对目标文件添加头文件目录.</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>target_link_libraries</span>(<<span class=keyword>target</span>> [item1] [item2] [...]</span><br><span class=line>                      [[debug|optimized|general] &LTitem>] ...)</span><br></pre></table></figure> <p>该指令的作用为将目标文件与库文件进行链接.</p> <p>上述指令中的<code>&LTtarget></code>是指通过add_executable()和add_library()指令生成已经创建的目标文件.</p> <p>可以使用<code>&LTa>_FOUND</code>检查是否通过find加载成功,之后使用target_link_libraries连接.</p> <h2 id=find-package-amp-find-path-amp-find-library><a class=headerlink href=#find-package-amp-find-path-amp-find-library title=find_package&find_path&find_library></a>find_package&find_path&find_library</h2><p>find_path和find_library分别用来找头文件和库.找到之后可以使用include_directory或者target_link_libraries用来使用.</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>FIND_PATH</span>(myCeres NAMES ceress.h PATHS /ceres/<span class=keyword>include</span>/ceres NO_DEFAULT_PATH)</span><br><span class=line><span class=keyword>INCLUDE_DIRECTORIES</span>(<span class=variable>${myCeres}</span>)</span><br></pre></table></figure> <h2 id=编译时消息输出><a class=headerlink href=#编译时消息输出 title=编译时消息输出></a>编译时消息输出</h2><figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>MESSAGE</span>(STATUS <span class=string>"HELLO"</span>)</span><br></pre></table></figure> <h2 id=设置变量><a class=headerlink href=#设置变量 title=设置变量></a>设置变量</h2><figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class=variable>${CMAKE_SOURCE_DIR}</span>/lib/x86)</span><br></pre></table></figure> <p>set设置变量,后续使用${}使用变量</p> <h2 id=控制结构><a class=headerlink href=#控制结构 title=控制结构></a>控制结构</h2><p>if elseif else endif</p> <p>文件中可以使用条件,循环等控制语句.可以用来判断构建时系统的一些环境.</p> <p>比如</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment># include dynamic link path</span></span><br><span class=line><span class=keyword>if</span>(CMAKE_SYSTEM_PROCESSOR <span class=keyword>MATCHES</span> <span class=string>"x86"</span>)</span><br><span class=line>    <span class=keyword>link_directories</span>(<span class=variable>${CMAKE_CURRENT_SOURCE_DIR}</span>/../nwpu_std_msgs/lib/x86)</span><br><span class=line>    <span class=keyword>link_directories</span>(<span class=variable>${CMAKE_CURRENT_SOURCE_DIR}</span>/../nwpucutils/lib/x86)</span><br><span class=line><span class=keyword>elseif</span>(CMAKE_SYSTEM_PROCESSOR <span class=keyword>MATCHES</span> <span class=string>"arm"</span>)</span><br><span class=line>    <span class=keyword>link_directories</span>(<span class=variable>${CMAKE_CURRENT_SOURCE_DIR}</span>/../nwpu_std_msgs/lib/arm)</span><br><span class=line>    <span class=keyword>link_directories</span>(<span class=variable>${CMAKE_CURRENT_SOURCE_DIR}</span>/../nwpucutils/lib/arm)</span><br><span class=line><span class=keyword>endif</span>()</span><br></pre></table></figure> <h2 id=添加其他子目录><a class=headerlink href=#添加其他子目录 title=添加其他子目录></a>添加其他子目录</h2><figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>add_subdirectory</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL] [SYSTEM])</span><br></pre></table></figure> <p><strong>添加一个子目录并构建该子目录</strong>.source_dir指定源CMakeLists.txt和代码文件所在的目录.</p> <p>一般用在嵌套的项目中,顶层CMakeLists.txt文件添加子目录,让子目录先构建完成之后添加其中生成的库和头文件.</p> <h2 id=获取文件><a class=headerlink href=#获取文件 title=获取文件></a>获取文件</h2><figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>FILE</span> (GLOB ALL_SOURCES <span class=string>"*.cpp"</span> <span class=string>"*.c"</span> <span class=string>"./AFolder/*.cpp"</span> )</span><br></pre></table></figure> <p>使用正则匹配响应文件并存到一个变量中</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>aux_source_directory</span>(dir VAR) </span><br></pre></table></figure> <p>发现一个目录下所有的<strong>源代码文件</strong>并将列表存储在一个变量中.</p> <h2 id=vs中显示头文件><a class=headerlink href=#vs中显示头文件 title=vs中显示头文件></a>vs中显示头文件</h2><figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>file</span>(GLOB_RECURSE pipe_header_files  <span class=variable>${CMAKE_CURRENT_SOURCE_DIR}</span>/<span class=keyword>include</span>/*.h )</span><br><span class=line><span class=keyword>source_group</span>(<span class=string>"Header Files"</span> FILES <span class=variable>${pipe_header_files}</span>) </span><br></pre></table></figure> <p>使用source_group增加文件</p> <p>并添加到生成目标中</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>add_library</span>( lib_pipe_shared SHARED <span class=variable>${pipe_src}</span> <span class=variable>${pipe_header_files}</span>)</span><br></pre></table></figure> <h2 id=option与add-definitions><a class=headerlink href=#option与add-definitions title=option与add_definitions></a>option与add_definitions</h2><figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>option</span>(&LTvariable> <span class=string>"&LThelp_text>"</span> [value])</span><br></pre></table></figure> <p>可以在cmake命令中指定该值.</p> <p>而add_definition用于指定编译器参数,比如<code>add_definitions("-Wall -g")</code>,此外更推荐使用add_compile_definitions将预处理器定义添加到编译器命令行,使用add_compile_options命令添加其它选项.</p> <p>比如下面文件,使用add_definition定义了TEST_DEBUG,option定义为OFF并在cmake执行时指定为on,然后在cmake文件中指定option为on,这样就执行了<code>add_definitions(-DTEST_DEBUG)</code>,定义了该宏.</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>#!/bin/sh</span></span><br><span class=line></span><br><span class=line>cmake -DTEST_DEBUG=ON .</span><br><span class=line>cmake --build .</span><br><span class=line></span><br></pre></table></figure> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>project</span>(<span class=keyword>test</span>)</span><br><span class=line></span><br><span class=line><span class=keyword>option</span>(TEST_DEBUG <span class=string>"option for debug"</span> <span class=keyword>OFF</span>)</span><br><span class=line><span class=keyword>if</span> (TEST_DEBUG)</span><br><span class=line><span class=keyword>add_definitions</span>(-DTEST_DEBUG)</span><br><span class=line><span class=keyword>endif</span>()</span><br></pre></table></figure> <figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>"test.h"</span></span></span><br><span class=line></span><br><span class=line><span class=meta>#<span class=meta-keyword>ifdef</span> TEST_DEBUG</span></span><br><span class=line>...</span><br><span class=line><span class=meta>#<span class=meta-keyword>endif</span></span></span><br></pre></table></figure> <p>CMake中的命令特别多,事实上并不需要去一个一个记住,通常只要知道一个项目的大致构建流程以及可能需要的命令就行了.</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>target_compile_definitions</span>(foo PUBLIC FOO)</span><br><span class=line><span class=keyword>target_compile_definitions</span>(foo PUBLIC -DFOO)  <span class=comment># -D removed</span></span><br><span class=line><span class=keyword>target_compile_definitions</span>(foo PUBLIC <span class=string>""</span> FOO) <span class=comment># "" ignored</span></span><br><span class=line><span class=keyword>target_compile_definitions</span>(foo PUBLIC -D FOO) <span class=comment># -D becomes "", then ignored</span></span><br></pre></table></figure> <h3 id=生成器表示><a class=headerlink href=#生成器表示 title=生成器表示></a>生成器表示</h3><p>生成器表达式是在构建的配置阶段进行的语句.<strong>大多数函数允许使用生成器表达式,只有少数例外.以 $ 的形式使用,其中 OPERATOR 或直接使用,或与 VALUE 进行比 较.</strong></p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>target_compile_options</span>(my_target PRIVATE</span><br><span class=line><span class=string>"$<$&LTCXX_COMPILER_ID:GNU,Clang,AppleClang>:-Wall>"</span>)</span><br><span class=line></span><br></pre></table></figure> <p>若 CXX_COMPILER_ID 变量匹配 GNU, Clang, AppleClang 列表中任意一个,则附加-Wall 选 项到目标——也就是 my_target.生成器表达式在编写独立于平台和编译器的 CMake 文件时非常方便.</p> <p>除了查询值,生成器表达式还可以用于转换字符串和列表:</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>$&LTLOWER_CASE:CMake></span><br></pre></table></figure> <p>这将输出“cmake”.</p> <h2 id=Advanced-cmake><a title="Advanced cmake" class=headerlink href=#Advanced-cmake></a>Advanced cmake</h2><p>cmake在c++中用的太多了,</p> <p>最近在看别人项目的时候看见了一些比较高级的cmake使用方法.</p> <p><strong>macro</strong></p> <p>定义一个名为 \<name> 的宏,该宏接收名为 \<arg1>, … 的参数. <p>CMake 宏使用 macro()/endmacro() 定义,有点像函数function.不同的是,函数参数是真变量,而 在宏中是字符串替换.这意味着必须使用大括号访问宏的所有参数. 另一个区别是,通过调用函数,作用区域转移到函数内部.执行宏时,就好像宏的主体粘贴到 调用位置一样,宏不会创建变量和控制流的作用域.因此,避免在宏中调用 return().</p> <p><strong>function</strong></p> <p>函数由 function()/endfunction() 定义.函数为变量创建了一个新的作用域,因此所有 在内部定义的变量都不能从外部访问,除非将 PARENT_SCOPE 选项传递给 set(). 函数不区分大小写,通过 function 后的名称加上圆括号来使用函数</p> <h4 id=Effective-CMake><a title="Effective CMake" class=headerlink href=#Effective-CMake></a>Effective CMake</h4><ul><li><a href=https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1 rel=noopener target=_blank>Effective Modern CMake (github.com)</a><li><a href=https://github.com/xiaoweiChen/CMake-Best-Practices rel=noopener target=_blank>xiaoweiChen/CMake-Best-Practices: 《CMake Best Practices》的非专业个人翻译 (github.com)</a><li><a href=https://llvm.org/docs/CMakePrimer.html rel=noopener target=_blank>CMake Primer — LLVM 19.0.0git documentation</a></ul> <h5 id=通用><a class=headerlink href=#通用 title=通用></a>通用</h5><p>使用CMake版本大于3.0.0</p> <p>将CMake视为代码,像对待任何其他编程语言一样,保持CMakeLists.txt和模块的代码清晰、结构良好.</p> <p>全局定义项目属性,在顶层CMakeLists.txt文件中定义如<strong>编译器警告、代码标准等全局项目属性</strong>,确保所有目标使用相同的标准,避免因依赖目标间的编译选项不一致导致的问题</p> <blockquote><p>例如,一个项目可能会使用一组通用的编译器警告. 在顶层 CMakeLists.txt 文件中全局定义此类属性,可避免因依赖目标使用更严格的编译器选项而导致依赖目标的公共头文件无法编译的情况. 全局定义此类项目属性可以更方便地管理项目及其所有目标.</blockquote> <p>直接操作目标(targets),不要使用<code>add_compile_options</code>, <code>include_directories</code>, <code>link_directories</code>, <code>link_libraries</code>等命令,因为它们作用于目录级别,可能引入隐含的依赖关系.相反,直接对特定的目标使用<code>target_compile_options</code>, <code>target_include_directories</code>, <code>target_link_directories</code>, <code>target_link_libraries</code>等命令.</p> <p>不要直接操作CMAKE_CXX_FLAGS,不同的编译器有不同的命令行参数格式.通过CMAKE_CXX_FLAGS设置C++标准（如<code>-std=c++14</code>）可能会在未来版本的编译器上失效,因为这些要求也可能在其他标准（如C++17）中满足,而且老编译器的选项可能不同.因此,<strong>应该告诉CMake所需的编译特性,让CMake根据具体情况选择适当的编译器选项.</strong></p> <p>合理使用usage requirements,例如,不要将<code>-Wall</code>（开启所有警告）添加到目标的PUBLIC或INTERFACE段的<code>target_compile_options</code>中,因为这不是构建依赖目标所必需的,这样做可能导致不必要的警告信息.</p> <h5 id=模块Modules><a class=headerlink href=#模块Modules title=模块Modules></a>模块Modules</h5><p>使用声明导出目标的现代查找模块.</p> <p>从 CMake 3.4 开始,越来越多的查找模块导出了可通过 target_link_libraries 使用的目标.</p> <p>使用外部软件包的导出目标. 不要重蹈 CMake 使用外部软件包定义的变量的覆辙. 而应通过 target_link_libraries 使用导出的目标.</p> <p>对于不支持客户端使用 CMake 的第三方库,请使用查找模块. CMake 为第三方库提供了一系列查找模块.</p> <p>例如,Boost 不支持 CMake. 相反,CMake 提供了一个查找模块,以便在 CMake 中使用 Boost.</p> <p>如果某个库不支持客户端使用 CMake,请将其作为 bug 报告给第三方库作者. 如果该库是一个开源项目,请考虑发送补丁. CMake 在业界占主导地位. 如果库作者不支持 CMake,那就麻烦了.</p> <p>为不支持客户端使用 CMake 的第三方库编写查找模块. 可以改造查找模块,将目标正确导出到不支持 CMake 的外部软件包.</p> <p>如果您是库作者,请导出库的INTERFACE</p> <h5 id=项目Projects><a class=headerlink href=#项目Projects title=项目Projects></a>项目Projects</h5><ul><li><p>避免在项目命令参数中使用自定义变量. 保持简单. 不要引入不必要的自定义变量. 不要使用 add_library(a ${MY_HEADERS} ${MY_SOURCES}),而应使用 add_library(a b.h b.cpp).</p><li><p>不要在项目中使用 file(GLOB),CMake 是一个编译系统生成器,而不是一个编译系统. 在生成构建系统时,它会将 GLOB 表达式求值为一个文件列表. 然后,联编系统会对该文件列表进行操作. CMake 无法将 GLOB 表达式转发给联编系统,以便在联编时对表达式进行评估. CMake 希望成为所支持的联编系统的公分母. 并非所有的构建系统都支持这一点,因此 CMake 也无法支持.</p><li>将特定于 CI 的设置放在 CTest 脚本中,而不是项目中,这样会让事情更简单.<li>测试名称应遵循命名约定. 这样可以简化通过 CTest 运行测试时的 regex 过滤.</ul> <h5 id=目标-Targets-及其属性-Properties><a class=headerlink href=#目标-Targets-及其属性-Properties title=目标(Targets)及其属性(Properties)></a>目标(Targets)及其属性(Properties)</h5><p><strong>从目标和属性的角度思考</strong></p> <p>通过从目标的角度定义属性（即编译定义、编译选项、编译特性、包含目录和库依赖关系,compile definitions, compile options, compile features, include directories, and library dependencies）,可以帮助开发人员在目标级别对系统进行推理. 开发人员不需要了解整个系统,就能对单个目标进行推理. 构建系统可处理反向性.</p> <p><strong>将目标想象成对象</strong></p> <p>调用成员函数会修改对象的成员变量.</p> <p>与构造函数类比：add_executable add_library</p> <p>与成员变量类比：target properties（太多,这里不一一列举）</p> <p>与成员函数类比：target_compile_definitions target_compile_features target_compile_options target_include_directories target_link_libraries target_sources get_target_property set_target_property</p> <p>如果目标需要内部属性（如编译定义、编译选项、编译特性、包含目录和库依赖关系）,请将它们添加到 target_* 命令的 PRIVATE 部分.</p> <p><strong>使用 target_compile_definitions 声明编译定义</strong></p> <p>可将编译定义与目标的可见性（PRIVATE、PUBLIC、INTERFACE）关联起来. 这比使用 add_compile_definitions 更好,因为 add_compile_definitions 与目标没有关联.</p> <p><strong>使用 target_compile_options 声明编译选项</strong></p> <p>这与编译选项与目标的可见性（PRIVATE、PUBLIC、INTERFACE）相关联. 这比使用 add_compile_options 要好,因为 add_compile_options 与目标没有关联.</p> <p>但要注意不要声明会影响 ABI 的编译选项. 请全局声明这些选项.</p> <p>target_compile_features同</p> <p><strong>使用 target_include_directories 声明 include 目录</strong></p> <p>这将 include 目录与目标的可见性（PRIVATE、PUBLIC、INTERFACE）相关联. 这比使用 include_directories 更好,因为 include_directories 与目标没有关联.</p> <p><strong>使用 target_link_libraries 声明直接依赖关系</strong>,这将把使用要求从依赖目标传播到被依赖目标. 该命令还能解决传递依赖关系.</p> <p><strong>不要在组件目录之外的路径下使用 target_include_directories</strong></p> <p>在组件目录之外使用路径是一种隐藏的依赖关系. 相反,应使用 target_include_directories 通过 target_link_directories 将包含目录作为使用要求传播给依赖目标.</p> <p>使用 target_* 时,始终明确声明属性 PUBLIC、PRIVATE 或 INTERFACE. 明确声明可减少无意中引入隐藏依赖关系的机会.</p> <p>不要使用 target_compile_options 设置会影响 ABI 的选项. 对多个目标使用不同的编译选项可能会影响 ABI 兼容性. 防止此类问题的最简单解决方案是全局定义编译选项.</p> <p>使用在同一 CMake 树中定义的库应与使用外部库相同. 在同一 CMake 树中定义的软件包可直接访问. 通过 CMAKE_PREFIX_PATH 获取预编译库. 如果软件包定义在同一个编译树中,那么使用 find_package 查找该软件包就不会有任何问题. 在将目标 Bar 导出到命名空间 Foo 时,还可以通过 add_library(Foo::Bar ALIAS Bar) 创建别名 Foo::Bar. 创建一个变量,列出所有子项目. 定义 find_package 宏来封装原来的 find_package 命令（现在可通过 _find_package 访问）. 如果变量包含软件包的名称,宏将禁止调用 _find_package.</p> <h5 id=函数与宏><a class=headerlink href=#函数与宏 title=函数与宏></a>函数与宏</h5><p>除了基于目录的作用域外,CMake 函数也有自己的作用域. 这意味着在函数中设置的变量在父作用域中不可见. 宏则不然.</p> <p>宏只能用于定义很小的功能,或用于封装有输出参数的命令. 函数有自己的作用域,宏没有.</p> <p>宏的参数不会被设置为变量,而是在执行宏之前在宏中解析对参数的引用. 这可能会在使用未引用变量时导致意外行为. 一般来说,这个问题并不常见,因为它需要使用名称在父作用域中重叠的非参引变量,但必须注意,因为它可能导致微妙的错误.</p> <p>不要使用会影响目录树中所有目标的宏,如 include_directories、add_definitions 或 link_libraries. 这些宏是邪恶的. 如果在顶层使用宏,所有目标都可以使用宏定义的属性. 例如,所有目标都可以使用（即 #include）include_directories 所定义的头文件. 如果目标不需要链接（如接口库、内联模板）,在这种情况下甚至不会出现编译器错误. 使用这些宏很容易意外地通过其他目标创建隐藏的依赖关系.</p> <p><strong>建议使用 cmake_parse_arguments 来处理任何函数中基于参数的复杂行为或可选参数.</strong></p> <h5 id=循环><a class=headerlink href=#循环 title=循环></a>循环</h5><ul><li><code>foreach(var IN ITEMS foo bar baz) ...</code><li><code>foreach(var IN LISTS my_list) ...</code><li><code>foreach(var IN LISTS my_list ITEMS foo bar baz) ...</code></ul> <h5 id=包><a class=headerlink href=#包 title=包></a>包</h5><p>使用 CPack 创建软件包.</p> <p>CPack 是 CMake 的一部分,并与 CMake 完美集成.</p> <p>编写 CPackConfig.cmake,其中包括 CMake 生成的 CPackConfig.cmake,这样就可以设置无需出现在项目中的其他变量.</p> <h5 id=交叉编译><a class=headerlink href=#交叉编译 title=交叉编译></a>交叉编译</h5><p>使用工具链文件进行交叉编译.工具链文件封装了用于交叉编译的工具链.</p> <p>保持工具链文件的简洁,这样更易于理解和使用. 不要在工具链文件中加入逻辑. 为每个平台创建一个工具链文件.</p> <h5 id=警告与报错><a class=headerlink href=#警告与报错 title=警告与报错></a>警告与报错</h5><p>正确对待构建错误、修复错误、拒绝拉取请求、暂缓发布.</p> <p><strong>将警告视为错误</strong></p> <p>要将警告视为错误,切勿向编译器传递 -Werror. 如果这样做,编译器就会将警告视为错误.</p> <ul><li>You cannot enable <code>-Werror</code> unless you already reached zero warnings.<li>You cannot increase the warning level unless you already fixed all warnings introduced by that level.<li>You cannot upgrade your compiler unless you already fixed all new warnings that the compiler reports at your warning level.<li>You cannot update your dependencies unless you already ported your code away from any symbols that are now <code>[[deprecated]]</code>.<li><p>You cannot <code>[[deprecated]]</code> your internal code as long as it is still used. But once it is no longer used, you can as well just remove it.</p> <p><strong>将新的警告视为错误</strong></p></ul> <ol><li>At the beginning of a development cycle (e.g., sprint), allow new warnings to be introduced.<ul><li>Increase warning level, enable new warnings explicitly.<li>Update the compiler.<li>Update dependencies.<li>Mark symbols as <code>[[deprecated]]</code>.</ul><li>Burn down the number of warnings.<li>Repeat.</ol> <p>使用多个支持的分析器：clang-tidy (\<lang>_CLANG_TIDY)、cpplint (\<lang>_CPPLINT)、include-what-you-use (\<lang>_INCLUDE_WHAT_YOU_USE) 和 LINK_WHAT_YOU_USE 可帮助您发现代码中的问题. 这些工具的诊断输出将显示在构建输出和集成开发环境中. <p>对于每个头文件,都必须有一个关联的源文件,该源文件 #includes 头文件在顶部,即使该源文件本来是空的. 大多数分析工具都会报告当前源文件和关联头文件的诊断结果. 没有关联源文件的头文件不会被分析. 您也许可以设置自定义头文件过滤器,但这样头文件可能会被分析多次.</p> <h2 id=实战><a class=headerlink href=#实战 title=实战></a>实战</h2><p>CMake 中存在两个逻辑文件夹.一个是源文件夹,包含项目的层次结构集；另一个是构建文件夹,包含构建指令、缓存,以及所有生成的二进制文件和工件.</p> <p>源文件夹是 CMakeLists.txt 文件所在的位置.构建文件夹可以放在源文件夹中,也可以将其放在另一个位置.两种方式都可以;</p> <p>构建文件夹通命名为 build,但也可以使用其他名称,包括不同平台的前缀和后缀.当在源 代码树中使用构建文件夹时,最好将其添加到.gitignore 中. 当配置 CMake 项目时,将在构建文件夹中重新创建源文件夹的项目和文件夹结构,以便所有构 建工件都位于相同的位置.每个文件夹中,都有一个名为 CMakeFiles 的子文件夹,其中包含 CMake 配置步骤生成的信息.</p> <p>CMake 项目的文件结构会映射到 build 文件夹中.<strong>每个包含 CMakeLists.txt 文件的文件夹将进行映射,将创建一个名为 CMakeFiles 的子文件夹</strong>,其中包含用 于构建的信息</p> <p>变量的作用域可以通过以下方式确定:</p> <p>• 函数作用域: 在函数内部设置的变量只在函数内部可见.</p> <p>• 目录作用域: 源树中的每个子目录绑定变量,并包括来自父目录的变量.</p> <p>• 持久缓存: 缓存的变量可以是系统的,也可以是用户定义的.在多次运行中保持它们的值不变.</p> <p>将 PARENT_SCOPE 选项传递给 set() 会使变量在父作用域中可见</p> <p><a href=https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html rel=noopener target=_blank>cmake-variables(7) — CMake 3.30.1 Documentation</a></p> <h3 id=项目结构><a class=headerlink href=#项目结构 title=项目结构></a>项目结构</h3><figure class="highlight reasonml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>├── <span class=module-access><span class=module><span class=identifier>CMakeLists</span>.</span></span>txt</span><br><span class=line>├── build</span><br><span class=line>├── <span class=keyword>include</span>/project_name</span><br><span class=line>└── src</span><br></pre></table></figure> <p>最小的项目结构中有三个文件夹和一个文件</p> <p>• build: 放置构建文件和二进制文件的文件夹.</p> <p>• include/project_name: 此 文 件 夹 包 含 从 项 目 外 部 公 开 访 问 的 所 有 头 文 件, 包 含 使它更容易看出头文件来自哪个库.</p> <p>• src: 此文件夹包含所有私有的源文件和头文件</p> <p>• CMakeLists.txt: 这是主 CMake 文件</p> <p>构建文件夹可以放置在任何地方,放在项目根目录最方便,但强烈建议不要选择任何非空文件 夹作为构建文件夹.特别是将构建好的文件放入 include 或 src 中,这是一种糟糕的实践.其他文件 夹,如 test 或 doc,在组织测试项目和文档页面时就很方便</p> <p><strong>嵌套项目</strong></p> <figure class="highlight reasonml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>├── <span class=module-access><span class=module><span class=identifier>CMakeLists</span>.</span></span>txt</span><br><span class=line>├── build</span><br><span class=line>├── <span class=keyword>include</span>/project_name</span><br><span class=line>├── src</span><br><span class=line>└── subproject</span><br><span class=line>├── <span class=module-access><span class=module><span class=identifier>CMakeLists</span>.</span></span>txt</span><br><span class=line>├── <span class=keyword>include</span></span><br><span class=line>│ └── subproject</span><br><span class=line>└── src</span><br></pre></table></figure> <figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=built_in>cmake_minimum_required</span>(VERSION <span class=number>3.21</span>)</span><br><span class=line><span class=built_in>project</span>(</span><br><span class=line>hello_world_standalone</span><br><span class=line>VERSION <span class=number>1.0</span></span><br><span class=line>DESCRIPTION<span class=string>"A simple C++ project"</span></span><br><span class=line>HOMEPAGE_URL https:<span class=comment>//github.com/PacktPublishing/CMake-BestPractices</span></span><br><span class=line>LANGUAGES CXX</span><br><span class=line>)</span><br><span class=line><span class=built_in>add_executable</span>(hello_world)</span><br><span class=line><span class=built_in>target_sources</span>(hello_world PRIVATE src/main.cpp)</span><br><span class=line></span><br></pre></table></figure> <p>第一行,cmake_minimum_required(VERSION 3.21),期望看到的 CMake 的版本,以及 CMake 将启用哪些特性.本书的例子中都使用 CMake 3.21,但是出于兼容性的原因,读者们可以选 择一个较低的版本.</p> <p>对于本例,3.1 版本将是绝对的最小值,因为在此之前,target_sources 不可用.将 cmake_minimum_required 指令放在每个 CMakeLists.txt 文件的顶部是一个很好的做法.</p> <p>接下来,使用 project() 指令设置项目.第一个参数是项目的名称——我们的例子中为 “hello_world_standalone”. 接下来,版本设置为 1.0.下面是一个简短的描述和主页的 URL.</p> <p>最后,LANGUAGES CXX 属 性指定正在构建一个 C++ 项目.除了项目名称之外,所有参数都可选. 调用 add_executable(hello_world) 指令,会创建一个名为 hello_world 的目标.这也将 是可执行的文件名. 现在已经创建了目标,使用 target_sources 完成了向目标添加 C++ 源文件.Chapter3 是目标名,在 add_executable 中指定.</p> <p>PRIVATE 定义源仅用于构建此目标,而不用于依赖的目 标.在范围说明符之后,有一个相对于当前 CMakeLists.txt 文件路径的源文件列表.如果需要,当 前处理的 CMakeLists txt 文件的位置可以通过 CMAKE_CURRENT_SOURCE_DIR 得到.</p> <p>源码可以直接添加到 add_executable,也可以单独使用 target_sources,将它们与 target_sources 一起添加.通过使用 PRIVATE、PUBLIC 或 INTERFACE,可以显式地定义在何 处使用源码.但是,<strong>指定 PRIVATE 以外的内容只对库目标有意义</strong>.</p> <h3 id=创建库><a class=headerlink href=#创建库 title=创建库></a>创建库</h3><figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>cmake_minimum_required</span>(VERSION <span class=number>3.21</span>)</span><br><span class=line><span class=keyword>project</span>(</span><br><span class=line>ch3.hello_lib</span><br><span class=line>VERSION <span class=number>1.0</span></span><br><span class=line>DESCRIPTION</span><br><span class=line><span class=string>"A simple C++ project to demonstrate creating executables</span></span><br><span class=line><span class=string>and libraries in CMake"</span></span><br><span class=line>LANGUAGES CXX)</span><br><span class=line><span class=keyword>add_library</span>(hello)</span><br><span class=line><span class=keyword>target_sources</span>(</span><br><span class=line>hello</span><br><span class=line>PRIVATE src/hello.cpp src/internal.cpp)</span><br><span class=line><span class=keyword>target_compile_features</span>(hello PUBLIC cxx_std_17)</span><br><span class=line><span class=keyword>target_include_directories</span>(</span><br><span class=line>hello</span><br><span class=line>PRIVATE src/hello</span><br><span class=line>PUBLIC <span class=keyword>include</span>)</span><br></pre></table></figure> <p>源文件使用 PRIVATE 添加,PRIVATE 和 PUBLIC 关键字指定在何处使用源代码进行编译.PRIVATE 指定的源文件将只在目标 hello 中使用</p> <p>若使用 PUBLIC,那么源文件也会将附加到 hello 和依赖 hello 的目标上,这通常不是想要的结果.</p> <p><strong>INTERFACE 关键字说明源文件不会添加到 hello 目标中,而是会添加到依赖到 hello 的目标上</strong>.</p> <p>通常,为目标指定为 PRIVATE 的内容都可以视为构建需求.最后,包含目录使用 target_include_directories 设置.该指令指定的文件夹内的所有文件都可以使用 #include (带尖括号) 来访问</p> <h3 id=命名库><a class=headerlink href=#命名库 title=命名库></a>命名库</h3><p>当使用 add_library() 创建库时,库名称在项目中必须全局唯一.默认情况下,库 的实际文件名是根据平台上的约定构造的,例如 lib.在 Linux 上为 .a,在 Windows 上为 < 名称 >.lib.通过设置目标的 OUTPUT_NAME 属性,可以更改文件的名称</p> <p>动态库的常用命名约定是在文件名中添加版本以指定构建版本和 API 版本,通过指定 VERSION 和 SOVERSION 属性,CMake 将在构建和安装库时创建必要的文件名和符号链接</p> <p>项目中经常看到的另一种约定,是为各种构建配置的文件名添加不同的后缀.CMake 通过设 置 CMAKE__POSTFIX 全局变量或添加 _POSTFIX 属性来处理这个问题.若 设置了此变量,后缀将自动添加到非可执行目标.</p> <figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line>add_library(ch3_hello)</span><br><span class=line>set_target_properties(</span><br><span class=line>ch3_hello</span><br><span class=line>PROPERTIES OUTPUT_NAME hello</span><br><span class=line>)</span><br><span class=line>set_target_properties(</span><br><span class=line>hello</span><br><span class=line>PROPERTIES VERSION <span class=variable>${PROJECT_VERSION}</span> <span class=comment># Contains 1.2.3</span></span><br><span class=line>SOVERSION <span class=variable>${PROJECT_VERSION_MAJOR}</span> <span class=comment># Contains only 1</span></span><br><span class=line>)</span><br><span class=line></span><br><span class=line>set_target_properties(</span><br><span class=line>hello</span><br><span class=line>PROPERTIES DEBUG_POSTFIX d)</span><br><span class=line></span><br><span class=line>set_target_properties(</span><br><span class=line>hello</span><br><span class=line>PROPERTIES DEBUG_POSTFIX d)</span><br></pre></table></figure> <p>这将使库文件和符号链接命名为 libhellod</p> <h3 id=动态库的符号可见性><a class=headerlink href=#动态库的符号可见性 title=动态库的符号可见性></a>动态库的符号可见性</h3><p>要链接到动态库,链接器必须知道哪些符号可以从库外部使用.这些符号可以是类、函数、类 型等,使它们可见的过程称为导出.</p> <p>指定符号可见性时,编译器有不同的方式和默认行为,这使得以独立于平台的方式 指定符号可见性有点麻烦.</p> <p>从默认的编译器可见性开始;g<strong>cc 和 clang 假设所有的符号都 是可见的</strong>,而 <strong>Visual Studio 编译器默认情况下会隐藏所有的符号,除非显式导出</strong>.</p> <p>设置 CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS,可以改变 MSVC 的默认行为,这是一种暴力的 解决方法,只有当库的所有符号都应该导出时才能使用</p> <h3 id=更改默认可见性><a class=headerlink href=#更改默认可见性 title=更改默认可见性></a>更改默认可见性</h3><p>暴露库的内部符号会暴露本应隐藏的东西,所以设置动态库时最好更改默认可见性并暴露需要的类、函数.</p> <p>要更改符号的默认可见性,请将 _VISIBILITY_PRESET 属性设置为 HIDDEN.此 属性可以全局设置,也可以针对单个库目标设置. 会替换为编写库的语言,例如：CXX 替 换为 C++,C 替换为 C.</p> <p>若所有要导出的符号都是隐藏符号,必须在代码中特别标记.最常见的方法是指定一个预处理器定义来确定一个符号是否可见</p> <p>CMake 提供了 generate_export_header 宏,由 GenerateExportHeader 模块导入.下面的例子中,hello 库的符号默认设置为隐藏.然后,通过使用 generate_export_header 宏再次单独启用.另外,本例将 VISIBILITY_INLINES_HIDDEN 属性设置为 TRUE,通过隐藏内联 类成员函数进一步减少导出的符号表</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>add_library</span>(hello SHARED)</span><br><span class=line><span class=keyword>set_property</span>(<span class=keyword>TARGET</span> hello PROPERTY CXX_VISIBILITY_PRESET <span class=string>"hidden"</span>)</span><br><span class=line><span class=keyword>set_property</span>(<span class=keyword>TARGET</span> hello PROPERTY VISIBILITY_INLINES_HIDDEN <span class=keyword>TRUE</span>)</span><br><span class=line><span class=keyword>include</span>(GenerateExportHeader)</span><br><span class=line>generate_export_header(hello EXPORT_FILE_NAME <span class=keyword>export</span>/hello/ export_hello.hpp)</span><br><span class=line><span class=keyword>target_include_directories</span>(hello PUBLIC <span class=string>"${CMAKE_CURRENT_BINARY_DIR}/export"</span>)</span><br></pre></table></figure> <h3 id=接口和纯头文件库><a class=headerlink href=#接口和纯头文件库 title=接口和纯头文件库></a>接口和纯头文件库</h3><p>纯头文件的库有点特殊,因为不需要编译; 相反,可以导出它们的头文件,以便直接包含在其 他库中.</p> <p>大多数情况下,头文件库的工作方式与普通库类似,但是头文件使用 INTERFACE,而非 PUBLIC.</p> <p>由于仅包含头文件的库不需要编译,因此不会向目标添加源文件.</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>project</span>(</span><br><span class=line>ch3_hello_header_only</span><br><span class=line>VERSION <span class=number>1.0</span></span><br><span class=line>DESCRIPTION <span class=string>"Chapter 3 header-only example"</span></span><br><span class=line>LANGUAGES CXX)</span><br><span class=line><span class=keyword>add_library</span>(hello_header_only INTERFACE)</span><br><span class=line><span class=keyword>target_include_directories</span>(hello_header_only INTERFACE <span class=keyword>include</span>/)</span><br><span class=line><span class=keyword>target_compile_features</span>(hello_header_only INTERFACE cxx_std_17)</span><br></pre></table></figure> <h3 id=对象库><a class=headerlink href=#对象库 title=对象库></a>对象库</h3><p>有时,可能想要<strong>分离代码,以便部分代码可以重用</strong>,而不需要创建完整的库.当想在可执行测 试和单元测试中使用某些代码时,通常的做法是不需要重新编译所有代码两次.为此,CMake 提 供了对象库,其中的源代码是编译的,但不进行归档或链接.通过 <code>add_library(MyLibrary object)</code> 创建对象库.</p> <p>自 CMake 3.12 起, 这 些 对 象 可 以 像 普 通 库 一 样 使 用, 只 需 将 它 们 添 加 到 target_link_libraries 函数中.3.12 版本之前,对象库需要添加生成器表达式,也就 是 $.这将在生成构建系统期间扩展为一个对象列表.这种方式现 在还可以用,但不推荐这样做,因为这很快就变得不可维护,特别是在一个项目中有多个对象库的 情况下.</p> <h3 id=使用库><a class=headerlink href=#使用库 title=使用库></a>使用库</h3><p>可 以 把 add_library 放 在 同 一 个 CMakeLists.txt 文 件 中, 或 者 使 用 add_subdirectory 将其整合起来.两者都是有效的选项,并取决于项目的设置方式</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>add_subdirectory</span>(hello_lib)</span><br><span class=line><span class=keyword>add_subdirectory</span>(hello_header_only)</span><br><span class=line><span class=keyword>add_subdirectory</span>(hello_object)</span><br><span class=line><span class=keyword>add_executable</span>(chapter3)</span><br><span class=line><span class=keyword>target_sources</span>(chapter3 PRIVATE src/main.cpp)</span><br><span class=line><span class=keyword>target_link_libraries</span>(chapter3 PRIVATE hello_header_only hello</span><br><span class=line>hello_object)</span><br></pre></table></figure> <p>target_link_libraries 的目标也可以是另一个库.同样,库的链接说明符,可以是以下 任意一个:</p> <p>• PRIVATE: 用于链接库,但不是公共接口的一部分.只有在构建目标时才需要链接库.</p> <p>• INTERFACE: 没有链接到库,但是公共接口的一部分.当在其他地方使用目标时,链接库是必需的.这通常仅限头文件库时使用.</p> <p>• PUBLIC: 链接到库,是公共接口的一部分.因此,该库既是构建依赖项,也是使用依赖项.</p> <h3 id=设置编译器和链接器选项><a class=headerlink href=#设置编译器和链接器选项 title=设置编译器和链接器选项></a>设置编译器和链接器选项</h3><p>C++ 编译器有很多选项来设置一些常见的标志,从外部设置预处理器定义也是一种常见的做 法.CMake 中,这些是使用 target_compile_options 传递,使用 target_link_options 更改链接器行为,但编译器和链接器可能有不同的设置标志的方法.例如,在 GCC 和 Clang 中,选 项用减号 (-) 传递,而 Microsoft 编译器将斜杠 (/) 作为选项的前缀.但是<strong>通过生成器表达式,可以很容易地在 CMake 中处理这个问题</strong>:</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>target_link_options</span>(</span><br><span class=line>hello</span><br><span class=line>PRIVATE $<$&LTCXX_COMPILER_ID:MSVC>:/SomeOption></span><br><span class=line>$<$&LTCXX_COMPILER_ID:GNU,Clang,AppleClang>:-</span><br><span class=line>someOption></span><br><span class=line>)</span><br></pre></table></figure> <p>$<a href=$:/SomeOption>$:/SomeOption</a> 是 一 个 嵌 套 的 生 成 器 表 达 式, 由 内 而 外 求 值. 生 成 器 表 达 式 在 生 成 阶 段 进 行 计 算.</p> <p>首 先, 当 C++ 编 译 器 等 于 MSVC 时为 true.若是这种情况,那么外部表达式将返回/SomeOption, 然后传递给编译器.若内部表达式的计算结果为 false,则不传递. $<$:-fopenmp> 的工作原理类似,但不是只检查 单个值,而是传递一个包含 GNU,Clang,AppleClang 的列表.若 CXX_COMPILER_ID 匹配其中 任何一个,内部表达式计算为 true,someOption 会传递给编译器. 将编译器或链接器选项传递为 PRIVATE,将其标记为与库接口不需要的此目标的构建需求.</p> <p>若 使用 PUBLIC,那么编译选项也成为构建需求,所有依赖于原始目标的目标将使用相同的编译选项. 将编译器选项暴露给依赖的目标是需要谨慎做的事情.</p> <p>若编译器选项只用于使用目标而不用于构建目标,则可以使用关键字 INTERFACE.在构建纯头文件库时,这是最常见的情况. 编 译 器 选 项 的 特 殊 情 况 是 编 译 定 义, 其 会 传 递 给 底 层 程 序. 这 通 过 target_compile_definitions 进行传递.</p> <h3 id=调试编译器选项><a class=headerlink href=#调试编译器选项 title=调试编译器选项></a>调试编译器选项</h3><p>要查看所有编译选项,可以查看生成的构建文件,例如 Makefiles 或 Visual Studio 项目.更方便 的方法是让 CMake 将所有编译命令导出为 JSON. 通 过 使 用 CMAKE_EXPORT_COMPILE_COMMANDS, 将 生 成 一 个 名 为 compile_commands.json 的文件,其包含用于编译的完整命令.</p> <h3 id=库别名><a class=headerlink href=#库别名 title=库别名></a>库别名</h3><p>库别名是在不创建新的构建目标的情况下引用库的一种方法,有时称为命名空间.常见的模式 是为从项目中安装的每个库以 MyProject::library 的形式创建一个库别名,可以用于对多个目标进行 语义分组.有助于避免命名方面的冲突,特别是当项目包含公共目标时,比如名为 utils 的库、helper 和类似的库.</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>add_library</span>(Chapter3::hello ALIAS hello)</span><br><span class=line>...</span><br><span class=line><span class=keyword>target_link_libraries</span>(SomeLibrary PRIVATE Chapter3::hello)</span><br></pre></table></figure> <h3 id=使用预设值维护构建配置><a class=headerlink href=#使用预设值维护构建配置 title=使用预设值维护构建配置></a>使用预设值维护构建配置</h3><p>构建信息可以存储在 CMakePresets.json 文件中,放在项目的根目录中.此外,每个用户都可以将他们配置添加到 CMakeUserPresets.json 文 件中.基本预设通常置于版本控制之下</p> <figure class="highlight json"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>{</span><br><span class=line><span class=attr>"version"</span>: <span class=number>3</span>,</span><br><span class=line><span class=attr>"cmakeMinimumRequired"</span>: {</span><br><span class=line><span class=attr>"major"</span>: <span class=number>3</span>,</span><br><span class=line><span class=attr>"minor"</span>: <span class=number>21</span>,</span><br><span class=line><span class=attr>"patch"</span>: <span class=number>0</span></span><br><span class=line>},</span><br><span class=line><span class=attr>"configurePresets"</span>: [...],</span><br><span class=line><span class=attr>"buildPresets"</span>: [...],</span><br><span class=line><span class=attr>"testPresets"</span>: [...]</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure> <p>要查看项目中配置了哪些预设值,请运行 cmake —list-presets 查看可用预设值的列表. 要使用预设进行生成,请执行 cmake —build —preset name</p> <h3 id=打包、部署和安装><a class=headerlink href=#打包、部署和安装 title=打包、部署和安装></a>打包、部署和安装</h3><p>install() 指令 install(…) 指令是一个内置的 CMake 命令,允许生成用于安装目标、文件、目录等的构建系统说明.<strong>CMake 不会生成安装指令,除非明确地说明</strong>.因此,安装总是在开发者的控制中.</p> <p>要使 CMake 目标可安装,必须用至少一个参数指定 TARGETS 参数.指令的签名如下所示:</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>install</span>(TARGETS ... [...])</span><br></pre></table></figure> <p>TARGETS 参数表示 install 可以接受一组 CMake 目标,以便为其生成安装代码,只安装目 标的输出构件.最常见的目标输出工件定义如下:</p> <p>• ARCHIVE (静态库、DLL 导入库和链接器导入文件): – 除了在 macOS 中标记为 FRAMEWORK 的目标</p> <p>• LIBRARY (动态库): – 除了在 macOS 中标记为 FRAMEWORK 的目标 – 除了 dll (Windows)</p> <p>• RUNTIME (可执行文件和 dll): – 除了在 macOS 中标记为 MACOSX_BUNDLE 的目标</p> <p>这些目录的默认值由 CMake 提供,具体取决于目标类 型.提供默认安装路径信息的 CMake 模块称为 GNUInstallDirs 模块.GNUInstallDirs 模块定义了各 种 CMAKE<em>INSTALL</em>的路径.默认安装目录如下表所示:</p> <p><img alt=image-20240723111850609 data-src=https://s2.loli.net/2024/07/23/T2xNuyIMd9ZaPRH.png></p> <p>覆盖内置默认值,在 install(…) 指令中需要使用 DESTINATION 参数.</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>install</span>(TARGETS ch4_ex01_executable</span><br><span class=line>RUNTIME DESTINATION qbin</span><br><span class=line>)</span><br></pre></table></figure> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>add_library</span>(ch4_ex02_static STATIC)</span><br><span class=line><span class=keyword>target_sources</span>(ch4_ex02_static PRIVATE src/lib.cpp)</span><br><span class=line><span class=keyword>target_include_directories</span>(ch4_ex02_static PUBLIC <span class=keyword>include</span>)</span><br><span class=line><span class=keyword>target_compile_features</span>(ch4_ex02_static PRIVATE cxx_std_11)</span><br><span class=line><span class=keyword>include</span>(GNUInstallDirs) <span class=comment># 引入模块使得修改默认安装位置</span></span><br><span class=line><span class=keyword>install</span>(TARGETS ch4_ex02_static)</span><br><span class=line><span class=keyword>install</span> (</span><br><span class=line>DIRECTORY <span class=keyword>include</span>/</span><br><span class=line>DESTINATION <span class=string>"${CMAKE_INSTALL_INCLUDEDIR}"</span></span><br><span class=line>)</span><br></pre></table></figure> <p><strong>多一个 DIRECTORY 参数,这是使静态库的头文 件可安装</strong>.这样做的原因是 CMake 不会安装任何非输出工件,而 STATIC 库目标只生成一个二进制 文件作为输出工件.头文件不是输出工件,应该单独安装</p> <h4 id=安装文件><a class=headerlink href=#安装文件 title=安装文件></a>安装文件</h4><p>安装的东西并不总是目标输出构件的一部分.它们可能是目标的运行时依赖项,例如图片、源文件、脚本和配置文件</p> <p>install(FILES…) 指令接受一个或多个文件作为参数,还需要 TYPE 或 DESTINATION 参 数,这两个参数用于确定指定文件的目标目录.</p> <p>TYPE 用于指示哪些文件将使用该文件类型的默认路径作为安装目录,可以通过设置相关的 GNUInstallDirs 变量来重写默认值</p> <p><img alt=image-20240724193228436 data-src=https://s2.loli.net/2024/07/24/2dorRDC4hYVsbj7.png></p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>install</span>(FILES <span class=string>"${CMAKE_CURRENT_LIST_DIR}/chapter4_greeter_content"</span></span><br><span class=line>DESTINATION <span class=string>"${CMAKE_INSTALL_BINDIR}"</span>)</span><br><span class=line><span class=keyword>install</span>(PROGRAMS <span class=string>"${CMAKE_CURRENT_LIST_DIR}/chapter4_greeter.py"</span></span><br><span class=line>DESTINATION <span class=string>"${CMAKE_INSTALL_BINDIR}"</span> RENAME chapter4_greeter)</span><br><span class=line></span><br></pre></table></figure> <h4 id=安装目录><a class=headerlink href=#安装目录 title=安装目录></a>安装目录</h4><p>install(DIRECTORY…) 指令用于安装目录,目录的结构将按原样复制到目标.目录既可以 作为一个整体安装,也可以有选择地安装.</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>install</span>(DIRECTORY dir1 dir2 dir3 TYPE LOCALSTATE)</span><br></pre></table></figure> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>include</span>(GNUInstallDirs)</span><br><span class=line><span class=keyword>install</span>(DIRECTORY dir1 DESTINATION <span class=variable>${CMAKE_INSTALL_</span></span><br><span class=line><span class=variable>LOCALSTATEDIR}</span> FILES_MATCHING PATTERN <span class=string>"*.x"</span>)</span><br><span class=line><span class=keyword>install</span>(DIRECTORY dir2 DESTINATION <span class=variable>${CMAKE_INSTALL_</span></span><br><span class=line><span class=variable>LOCALSTATEDIR}</span> FILES_MATCHING PATTERN <span class=string>"*.hpp"</span></span><br><span class=line>EXCLUDE PATTERN <span class=string>"*"</span>)</span><br><span class=line><span class=keyword>install</span>(DIRECTORY dir3 DESTINATION <span class=variable>${CMAKE_INSTALL_</span></span><br><span class=line><span class=variable>LOCALSTATEDIR}</span> PATTERN <span class=string>"bin"</span> EXCLUDE)</span><br></pre></table></figure> <p><strong>DESTINATION</strong> 这个参数允许 install(…) 指定安装目录,目录可以是相对路径,也可以是绝对路径.相对路径是相对于 CMAKE_INSTALL_PREFIX 的,建议使用相对路径使安装可重定位.</p> <p>另外,使用相对路径进行打包也很重要,因为 cpack 要求安装路径是相对路径.最好使用以相关 GNUInstallDirs 变量开始的路径,以便包维护人员在需要时覆盖安装目标.</p> <p>DESTINATION 参数可以与 TARGETS, FILES,IMPORTED_RUNTIME_ARTIFACTS,EXPORT 和 DIRECTORY 安装类型一起使用. <strong>PERMISSIONS</strong> 此 参 数 允 许 在 支 持 的 平 台 上 更 改 已 安 装 文 件 的 权 限. 可 用 权 限 为:OWNER_READ、 OWNER_WRITE、OWNER_EXECUTE、GROUP_READ、GROUP_WRITE、GROUP_EXECUTE、 WORLD_READ、WORLD_WRITE、WORLD_EXECUTE、SETUID 和 SETGID.PERMISSIONS 参 数可以与 TARGETS, FILES, IMPORTED_RUNTIME_ARTIFACTS, EXPORT 和 DIRECTORY 安装 类型一起使用.</p> <p><strong>CONFIGURATIONS</strong> 允许指定构建配置时限制参数的应用.</p> <p><strong>OPTIONAL</strong> 此参数使要安装的文件为可选文件,因此当文件不存在时,安装不会失败.可选参数可以与 TARGETS, FILES, IMPORTED_RUNTIME_ARTIFACTS 和 DIRECTORY 安装类型一起使用.</p> <h4 id=提供项目配置信息><a class=headerlink href=#提供项目配置信息 title=提供项目配置信息></a>提供项目配置信息</h4><p>若交付一个库,也必须很容易导入到一个项目——特别是 CMake 项目.</p> <p>CMake 使用依赖的首选方式是通过包.包为基于 CMake 的构建系统传递依赖信息,包可以是 Config-file 包、Find-module 包或 pkg-config 包.所有的包类型都可以通过 find_package() 找到并使用</p> <p>有 两 种 类 型 的 配 置 文 件 —— 包 配 置 文 件 和 可 选 的 包 版 本 文 件, 两 个 文 件 都 必 须 有 一 个 特 定 的 命 名.比如分别为Config.cmake,ConfigVersion.cmake</p> <p>包 配 置 文 件的内容可能如下,主要设置包含头文件和库:</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>set</span>(Foo_INCLUDE_DIRS <span class=variable>${PREFIX}</span>/<span class=keyword>include</span>/foo-<span class=number>1.2</span>) </span><br><span class=line><span class=keyword>set</span>(Foo_LIBRARIES <span class=variable>${PREFIX}</span>/lib/foo-<span class=number>1.2</span>/libfoo.a)</span><br></pre></table></figure> <p>搜索包时,find_package(…) 会查找 ${CMAKE_PREFIX_PATH}$/cmake 目录.</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>include</span>(GNUInstallDirs)</span><br><span class=line><span class=keyword>set</span>(ch4_ex05_lib_INSTALL_CMAKEDIR cmake CACHE PATH</span><br><span class=line><span class=string>"Installation directory for config-file package cmake files"</span>)</span><br></pre></table></figure> <p>include(GNUInstallDirs) 用 于 包 含 GNUInstallDirs 模 块. 这 提 供 了 CMAKE_INSTALL_INCLUDEDIR 变 量, set(ch4_ex05_lib_INSTALL_CMAKEDIR…) 是一个用户定义的变量,是导出目标的安装路径.</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>/*省略 前面<span class=keyword>add_library</span>*/</span><br><span class=line><span class=keyword>target_include_directories</span>(ch4_ex05_lib PUBLIC</span><br><span class=line>$&LTBUILD_INTERFACE:<span class=variable>${CMAKE_CURRENT_SOURCE_DIR}</span>/<span class=keyword>include</span>></span><br><span class=line>)</span><br><span class=line><span class=keyword>target_compile_features</span>(ch4_ex05_lib PUBLIC cxx_std_11)</span><br></pre></table></figure> <p>上面设置好了目标包含头文件,,因为在将目标导入到另一个 项目时,不存在构建时包含路径,其使用生成器表达式来区分构建时包含目录和安装时包含目录</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>install</span>(TARGETS ch4_ex05_lib</span><br><span class=line><span class=keyword>EXPORT</span> ch4_ex05_lib_export</span><br><span class=line>INCLUDES DESTINATION <span class=variable>${CMAKE_INSTALL_INCLUDEDIR}</span></span><br><span class=line>)</span><br><span class=line><span class=keyword>install</span> (</span><br><span class=line>DIRECTORY <span class=variable>${PROJECT_SOURCE_DIR}</span>/<span class=keyword>include</span>/</span><br><span class=line>DESTINATION <span class=variable>${CMAKE_INSTALL_INCLUDEDIR}</span> <span class=comment># 头文件安装目录</span></span><br><span class=line>)</span><br></pre></table></figure> <p>EXPORT 参 数, 用 于 从 给 定 的 install(…) 目 标 创 建 一 个 导 出 名 称. 然 后, 可 以 使 用 此 导 出 名 称 导 出 这 些 目 标. 使 用 INCLUDES DESTINATION 参 数 指 定 的 路 径, 将 用 于 填 充 导 出 目 标 的 INTERFACE_INCLUDE_DIRECTORIES 属 性, 并 自 动 使 用 安 装 前 缀 路 径 作 为 前 缀(就是安装头文件,因为其不会被显示安装或导入)</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>install</span>(<span class=keyword>EXPORT</span> ch4_ex05_lib_export</span><br><span class=line><span class=keyword>FILE</span> ch4_ex05_lib-config.cmake</span><br><span class=line>NAMESPACE ch4_ex05_lib::</span><br><span class=line>DESTINATION <span class=variable>${ch4_ex05_lib_INSTALL_CMAKEDIR}</span></span><br><span class=line>)</span><br></pre></table></figure> <p>EXPORT 参数接受现有的导出名 称来进行导出,它引用的是 ch4_ex05_lib_export 导出名称,在之前的 install(TARGETS…) 中创建的.</p> <p><strong>FILE 用于确定导出的文件名,</strong>并设置为 ch4_ex05_lib-config.cmake.</p> <p><strong>NAMESPACE 用于 为所有导出的目标添加命名空间前缀</strong>.这允许将所有导出的目标连接到通用的命名空间下,并避免 与具有相似目标名称的包发生冲突.</p> <p>最后,DESTINATION 确定生成导出文件的安装路径.设置为 ${ch4_ex05_lib_INSTALL_CMAKEDIR} 以便 find_package() 发现它</p> <p>要实现对 find_package(…) 的完全支持,还需要生成包版本文件.</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>include</span>(CMakePackageConfigHelpers)</span><br><span class=line>write_basic_package_version_file(</span><br><span class=line><span class=string>"ch4_ex05_lib-config-version.cmake"</span></span><br><span class=line><span class=comment># Package compatibility strategy. SameMajorVersion is</span></span><br><span class=line>essentially 'semantic versioning'.</span><br><span class=line>COMPATIBILITY SameMajorVersion</span><br><span class=line>)</span><br><span class=line><span class=keyword>install</span>(FILES</span><br><span class=line><span class=string>"${CMAKE_CURRENT_BINARY_DIR}/ch4_ex05_lib-config-version.</span></span><br><span class=line><span class=string>cmake"</span></span><br><span class=line>DESTINATION <span class=string>"${ch4_ex05_lib_INSTALL_CMAKEDIR}"</span></span><br><span class=line>)</span><br></pre></table></figure> <p>使用 include(CMakePackageConfigHelpers),导入 CMakePackageConfigHelpers 模块.这个模块 提供了 write_basic_package_version_file(…) 函数,用于根据给定的参数自动生成包版本文件</p> <blockquote><p>简单来说,通过生成包配置和包版本文件,方便find_package导入.<p>而包配置文件需要通过install(export )安装,包版本文件利用write_basic_package_version_file从项目版本获取导出版本,匹配find_package中的版本</blockquote> <p><strong>如何使用</strong></p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>if</span>(<span class=keyword>NOT</span> PROJECT_IS_TOP_LEVEL)</span><br><span class=line><span class=keyword>message</span>(FATAL_ERROR <span class=string>"The chapter-4, ex05_consumer project is</span></span><br><span class=line><span class=string>intended to be a standalone, top-level project. Do not</span></span><br><span class=line><span class=string>include this directory."</span>)</span><br><span class=line><span class=keyword>endif</span>()</span><br><span class=line><span class=keyword>find_package</span>(ch4_ex05_lib <span class=number>1</span> CONFIG REQUIRED) <span class=comment># 找到包配置或包版本文件,设置包含头文件和库</span></span><br><span class=line><span class=keyword>add_executable</span>(ch4_ex05_consumer src/main.cpp)</span><br><span class=line><span class=keyword>target_compile_features</span>(ch4_ex05_consumer PRIVATE cxx_std_11)</span><br><span class=line><span class=keyword>target_link_libraries</span>(ch4_ex05_consumer ch4_ex05_lib::ch4_ex05_</span><br><span class=line>lib) <span class=comment># 链接库</span></span><br></pre></table></figure> <figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTchapter4/ex05/lib.hpp></span> # 引入头文件</span></span><br><span class=line> <span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>(<span class=keyword>void</span>)</span></span>{</span><br><span class=line> chapter4::ex05::greeter g;</span><br><span class=line> g.<span class=built_in>greet</span>();</span><br><span class=line> }</span><br></pre></table></figure> <h4 id=创建安装包><a class=headerlink href=#创建安装包 title=创建安装包></a>创建安装包</h4><p>CMake 的打包工具 CPack 默认随 CMake 安装一起提供,可以利用现有的 CMake 代码来生成特定于平台的安装和包</p> <p><img alt=image-20240725113947270 data-src=https://s2.loli.net/2024/07/25/KifydlhZsekbLva.png></p> <p>CPack 使用 CPackConfig.cmake 中的配置细 节,CPackSourceConfig.Cmake 文件生成包.这些文件可以手动填写,也可以由 CMake 在 CPack 模块的帮助下自动生成.</p> <p>包含 CPack 模块会生成 <strong>CPackConfig.cmake</strong> 和 <strong>CPackSourceConfig.cmake</strong> 文件,这是打包项目所需的 CPack 配置</p> <p>当 CMake 或用户正确设置了 CPack 配置文 件,就可以使用 CPack.CPack 模块允许定制包装过程,从而可以设置大量的 CPack 变量.这些变 量分为两组——普通变量和生成器特定变量.公共变量影响所有包生成器,而生成器特定的变量只 影响特定类型的生成器</p> <p><img alt=image-20240725113958063 data-src=https://s2.loli.net/2024/07/25/SLxahKDtwsZ6dMz.png></p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=keyword>cmake_minimum_required</span>(VERSION <span class=number>3.21</span>)</span><br><span class=line><span class=keyword>project</span>(</span><br><span class=line>ch4_ex06_pack</span><br><span class=line>VERSION <span class=number>1.0</span></span><br><span class=line>DESCRIPTION <span class=string>"Chapter 4 Example 06, Packaging with CPack"</span></span><br><span class=line>LANGUAGES CXX)</span><br><span class=line><span class=keyword>if</span>(<span class=keyword>NOT</span> PROJECT_IS_TOP_LEVEL)</span><br><span class=line><span class=keyword>message</span>(FATAL_ERROR <span class=string>"The chapter-4, ex06_pack project is</span></span><br><span class=line><span class=string>intended to be a standalone, top-level project.</span></span><br><span class=line><span class=string>Do not include this directory."</span>)</span><br><span class=line><span class=keyword>endif</span>()</span><br><span class=line><span class=keyword>add_subdirectory</span>(executable)</span><br><span class=line><span class=keyword>add_subdirectory</span>(library)</span><br><span class=line><span class=keyword>set</span>(CPACK_PACKAGE_VENDOR <span class=string>"CTT Authors"</span>)</span><br><span class=line><span class=keyword>set</span>(CPACK_GENERATOR <span class=string>"DEB;RPM;TBZ2"</span>)</span><br><span class=line><span class=keyword>set</span>(CPACK_THREADS <span class=number>0</span>)</span><br><span class=line><span class=keyword>set</span>(CPACK_DEBIAN_PACKAGE_MAINTAINER <span class=string>"CTT Authors"</span>)</span><br><span class=line><span class=keyword>include</span>(CPack)</span><br></pre></table></figure> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>cmake –S . -B build/</span><br></pre></table></figure> <p>项目配置完成后,CpackConfig.cmake 和 CpackConfigSource.cmake 文件将生成到 build/CPack* 目录下</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>cmake --build build/</span><br><span class=line>cpack --config build/CPackConfig.cmake -B build/</span><br></pre></table></figure> <p>参数—config 是 CPack 命令的主要输入.参数-B 修改了默认的包目录,CPack 将把它的工 件写入该目录</p> <h4 id=寻找包和文件><a class=headerlink href=#寻找包和文件 title=寻找包和文件></a>寻找包和文件</h4><figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>find_package</span>(PackageName [version] [EXACT | QUIET | NO_MODULE | NO_CMAKE_PATH | NO_CMAKE_ENVIRONMENT | NO_SYSTEM_ENVIRONMENT | NO_CMAKE_SYSTEM_PATH | CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH] [REQUIRED | OPTIONAL] [COMPONENTS component1 component2 ...] [CONFIG | MODULE])</span><br></pre></table></figure> <p>CMake 能够查找定义目标、包括路径和包特定变量的整个包.更多细节请参考 CMake 项目部 分中的库. 有五个 find_…指令,它们选项和行为非常相似:</p> <p>• find_file: 定位单个文件.</p> <p>• find_path: 查找包含特定文件的目录.</p> <p>• find_library: 查找库文件.</p> <p>• find_program: 查找可执行程序.</p> <p>• find_package: 查找完整的包</p> <p><strong>find_pacakge</strong></p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>find_package</span>(&LTPackageName> [version] [EXACT] [QUIET] [MODULE]</span><br><span class=line>[REQUIRED] [[COMPONENTS] [components...]]</span><br><span class=line>[OPTIONAL_COMPONENTS components...]</span><br><span class=line>[NO_POLICY_SCOPE])</span><br></pre></table></figure> <p>find_package 有两个签名: 一个基本签名或短签名,一个完整签名或长签名.通常, 使用短签名就足以找到正在寻找的包,因为它更容易维护,应该是首选.<strong>短格式同时支持模块和配置包</strong>,而长格式只支持配置模式</p> <ul><li>在<strong>模块模式</strong>下运行时,find_package 会搜索名为 Find\<packagename>.cmake 的文件; 首先会 在 CMAKE_MODULE_PATH 指定的路径中搜索,然后是在外部提供的路径中查找模块. <li><strong>在配置模式下运行时,find_package 会搜索以下的文件</strong>:</li> <p>• -config.cmake</p> <p>• Config.cmake</p> <p>• -config-version.cmake (若指定了版本详细信息)</p> <p>• ConfigVersion.cmake (若指定了版本详细信息)</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>find_package</span>(OpenSSL REQUIRED COMPONENTS SSL)</span><br><span class=line><span class=keyword>add_executable</span>(find_package_example)</span><br><span class=line><span class=keyword>target_link_libraries</span>(find_package_example PRIVATE OpenSSL::SSL)</span><br></pre></table></figure> <p>find_package搜索的目录顺序</p> <p><img alt=image-20240725144118496 data-src=https://s2.loli.net/2024/07/25/N3yYAxsBnIatMJ4.png></p> <p>配置模式下搜索路径如下</p> <figure class="highlight awk"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>&LTprefix>/</span><br><span class=line>&LTprefix><span class=regexp>/(cmake|CMake)/</span></span><br><span class=line>&LTprefix><span class=regexp>/&LTpackageName>*/</span></span><br><span class=line>&LTprefix><span class=regexp>/&LTpackageName>*/</span>(cmake|CMake)/</span><br><span class=line>&LTprefix><span class=regexp>/(lib/</span>&LTarch>|lib*|share)<span class=regexp>/cmake/</span>&LTpackageName>*/</span><br><span class=line>&LTprefix><span class=regexp>/(lib/</span>&LTarch>|lib*|share)<span class=regexp>/&LTpackageName>*/</span></span><br><span class=line>&LTprefix><span class=regexp>/(lib/</span>&LTarch>|lib*|share)<span class=regexp>/&LTpackageName>*/</span>(cmake|CMake)/</span><br><span class=line>&LTprefix><span class=regexp>/&LTpackageName>*/</span>(lib<span class=regexp>/&LTarch>|lib*|share)/</span>cmake/</span><br><span class=line>&LTpackageName>*/</span><br><span class=line>&LTprefix><span class=regexp>/&LTpackageName>*/</span>(lib<span class=regexp>/&LTarch>|lib*|share)/</span>&LTpackageName>*/</span><br><span class=line>&LTprefix><span class=regexp>/&LTpackageName>*/</span>(lib<span class=regexp>/&LTarch>|lib*|share)/</span>&LTpackageName>*/</span><br><span class=line>(cmake|CMake)/</span><br></pre></table></figure> <p><strong>编写查找模块(如果想使用的库没有cmake)</strong></p> <p>目前仍然有很多库没有使用 CMake 管理,或者不导出 CMake 包.若可以将它们安装在系统的默认位置,找到这些库通常也不是问题.当使用仅为某个项目所需的专有第三方库,或者使用从系 统包管理器安装的库构建的不同版本的库时,使用对应版本的库就成了件麻烦事.</p> <figure class="highlight reasonml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>├── dep &LT-- The folder where we locally keep dependencies</span><br><span class=line>├── cmake</span><br><span class=line>│ └── <span class=module-access><span class=module><span class=identifier>FindLibImagePipeline</span>.</span></span>cmake &LT-- This is what we need <span class=keyword>to</span> write</span><br><span class=line>├── <span class=module-access><span class=module><span class=identifier>CMakeLists</span>.</span></span>txt &LT-- Main <span class=module-access><span class=module><span class=identifier>CmakeLists</span>.</span></span>txt</span><br><span class=line>├── src</span><br><span class=line>│ ├── *.cpp files</span><br><span class=line></span><br></pre></table></figure> <p>find 模块如何找到<strong>必要的头文件和二进制文件</strong>,以及为 CMake 创建导入目标的指令.<strong>当使用 find_package 时,CMake 在 CMAKE_MODULE_PATH 中搜索名为 Find\<packagename>.cmake 的文件 <p>处理逻辑是首先在CMAKE_MODULE_PATH中添加.cmake,然后添加library和path,然后判断目标有没有,如果没有就构建库,并设置库的属性. 其中利用了find_package_handle_standard_args 检查传递的LIBRARY 和 INCLUDE_DIR 变量是否有效,从而会设置 _FOUND 变量.</p> <h4 id=包管理器><a class=headerlink href=#包管理器 title=包管理器></a>包管理器</h4><p><strong>Conan</strong></p> <p>Conan 最强大的特性是可以为多个平台、配置和版本创建和管理二进制包.创建包时,使用 conanfile.py 文件描述它们,该文件列出了所有依赖项、源和构建指令.</p> <p>用 CMake 使用 Conan 的方法是使用 CMake 本身的 Conan,若不想这样做,可以在外部使用 Conan,但建议在使用 Conan 之前使用 find_program 检查 Conan 程序是否存在</p> <p>CMake与Conan搭配集成很好,直接在CMakeLists.txt中包含conan.cmake(没有直接下载),然后include并使用conan的一系列命令进行安装.</p> <p><strong>vcpkg</strong></p> <p>流行的开源包管理器是微软的 vcpkg,工作方式类似于 Conan,使用客户机/服务器架构. 最初构建它是为了与 Visual Studio 编译器环境一起工作,后来添加了 CMake.</p> <blockquote><p>当以清单模式运行时,项目的依赖项在 vcpkg.json 中定义,文件在项目的根目录下,清单模式 有一个很大的优势,可以更好地与 CMake 集成,因此请尽可能使用清单模式<p>若以经典模式运行, 则必须在运行 CMake 之前手动安装这些包,当传递 vcpkg 工具链文件时,可以使用 find_package 和 target_link_libraries 使用已安装的包,</blockquote> <figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>Cmake -S &LTsource_dir> -D &LTbinary_dir> -DCMAKE_TOOLCHAIN_</span><br><span class=line>FILE=[vcpkg root]/scripts/buildsystems/vcpkg.cmake</span><br></pre></table></figure> <p>设置工具链文件可能会在交叉编译时导致问题,因为 CMAKE_TOOLCHAIN_FILE 可能已经 指向一个不同的文件,所以第二个工具链文件可以通过 VCPKG_CHAINLOAD_TOOLCHAIN_FILE 传递</p> <figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>cmake -S &LTsource_dir> -D &LTbinary_dir> -DCMAKE_TOOLCHAIN_</span><br><span class=line>FILE=[vcpkg root]/scripts/buildsystems/vcpkg.cmake -DVCPKG</span><br><span class=line>_CHAINLOAD_TOOLCHAIN_FILE=/path/to/other/toolchain.cmake</span><br></pre></table></figure> <p>主要是要让cmake知道包管理器安装了哪些库并指定cmake安装哪些库,可以通过<code>CMakePresets.json</code>进行配置</p> <h4 id=获取依赖项源代码><a class=headerlink href=#获取依赖项源代码 title=获取依赖项源代码></a>获取依赖项源代码</h4><p>对于构建的外部项目,使用 FetchContent 模块是添加源依赖项的一种方法.对于二进制依 赖,使用 find_package的方式仍是首选.</p> <blockquote><p>下载并将第三方软件的副本集成到产品中的做法,称为供应商方式.优点是常常使构建软件 变得容易,但在打包库方面产生了问题</blockquote> <p><strong>FetchContent</strong></p> <p>FetchContent 提供了一系列函数来拉取源依赖项,主要是 <strong>FetchContent_Declare</strong>,它定 义了下载和构建 <strong>FetchContent_MakeAvailable</strong> 的参数,<strong>FetchContent_MakeAvailable</strong> 填充依赖项的目标,并使它们可用于构建</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>include</span>(FetchContent)</span><br><span class=line>FetchContent_Declare(</span><br><span class=line>bertrand</span><br><span class=line>GIT_REPOSITORY https://github.com/bernedom/bertrand.git</span><br><span class=line>GIT_TAG <span class=number>0.0</span>.<span class=number>17</span>)</span><br><span class=line>FetchContent_MakeAvailable(bertrand)</span><br><span class=line><span class=keyword>add_executable</span>(fetch_content_example)</span><br><span class=line><span class=keyword>target_link_libraries</span>(</span><br><span class=line>fetch_content_example</span><br><span class=line>PRIVATE bertrand::bertrand</span><br><span class=line>)</span><br></pre></table></figure> <h3 id=自动生成文档><a class=headerlink href=#自动生成文档 title=自动生成文档></a>自动生成文档</h3><p>Doxygen 是一个非常流行的 C++ 项目文档软件,允许从代码生成文档.,Doxygen 要求注释采用预定义的一组格式, 还需要一个 Doxyfile,其包含文档生成的所有参数,比如输出格式、排除的文件模式、 项目名称等,因为配置参数太多,开始配置 Doxygen 可能会让人望而生畏,但 CMake 可以自动生 成 Doxyfile.</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>find_package</span>(Doxygen)</span><br><span class=line><span class=keyword>set</span>(DOXYGEN_OUTPUT_DIRECTORY<span class=string>"${CMAKE_CURRENT_BINARY_DIR}/docs"</span>)</span><br><span class=line><span class=keyword>set</span>(DOXYGEN_GENERATE_HTML YES)</span><br><span class=line><span class=keyword>set</span>(DOXYGEN_GENERATE_MAN YES)</span><br><span class=line><span class=keyword>set</span>(DOXYGEN_MARKDOWN_SUPPORT YES)</span><br><span class=line><span class=keyword>set</span>(DOXYGEN_AUTOLINK_SUPPORT YES)</span><br><span class=line><span class=keyword>set</span>(DOXYGEN_HAVE_DOT YES)</span><br><span class=line><span class=keyword>set</span>(DOXYGEN_COLLABORATION_GRAPH YES)</span><br><span class=line><span class=keyword>set</span>(DOXYGEN_CLASS_GRAPH YES)</span><br><span class=line><span class=keyword>set</span>(DOXYGEN_UML_LOOK YES)</span><br><span class=line><span class=keyword>set</span>(DOXYGEN_DOT_UML_DETAILS YES)</span><br><span class=line><span class=keyword>set</span>(DOXYGEN_DOT_WRAP_THRESHOLD <span class=number>100</span>)</span><br><span class=line><span class=keyword>set</span>(DOXYGEN_CALL_GRAPH YES)</span><br><span class=line><span class=keyword>set</span>(DOXYGEN_QUIET YES)</span><br><span class=line></span><br></pre></table></figure> <ul><li>DOXYGEN_OUTPUT_DIRECTORY: 设置 Doxygen 的输出目录,<li>DOXYGEN_GENERATE_HTML: 生成超文本标记语言 (HTML)<li>DOXYGEN_GENERATE_MAN: 生成 MAN 页面,<li>DOXYGEN_AUTOLINK_SUPPORT: Doxygen 自动链接语言符号和文件名到相关文档页面 (若 可用),<li>DOXYGEN_HAVE_DOT: Doxygen 环境有可用的 dot,该命令可用于生成图像,这将使 Doxygen 能够使用依赖关系图、继承图和协作图来丰富生成的文档,<li>DOXYGEN_COLLABORATION_GRAPH: 为类生成协作图<li>DOXYGEN_CLASS_GRAPH: 生成类图,<li>DOXYGEN_UML_LOOK: Instructs 生成类似统一建模语言 (UML) 的图,<li>DOXYGEN_DOT_UML_DETAILS: 将类型和参数信息添加到 UML 图中,<li>DOXYGEN_DOT_WRAP_THRESHOLD: 为 UML 图设置行换行阈值,<li>DOXYGEN_CALL_GRAPH: 为函数文档中的函数生成调用图,<li>DOXYGEN_QUIET: 静默生成到标准输出 (stdout) 的 Doxygen 输出</ul> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>doxygen_add_docs(</span><br><span class=line>ch6_ex01_doxdocgen_generate_docs</span><br><span class=line><span class=string>"${CMAKE_CURRENT_LIST_DIR}"</span></span><br><span class=line>ALL</span><br><span class=line>COMMENT <span class=string>"Generating documentation for Chapter 6 - Example</span></span><br><span class=line><span class=string>01 with Doxygen"</span></span><br><span class=line>)</span><br></pre></table></figure> <p>使用 doxygen_add_docs(…) 来生成文档,该函数将生成一个名为 targetName 的自定义目标</p> <p>参数列表 filesOrDirs, 包含<strong>生成文档的代码的文件或目录的列表</strong></p> <p>ALL 参数用于使 CMake 的 ALL 元目标依赖于 doxygen_add_docs(…) 创建的文档目标,因此在构建 ALL 元目标时自动生成文档</p> <p>COMMENT 参数用于让 CMake 在构建目标时输出一条消息</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=keyword>function</span>(pro_BuildDoc doxyfilein)</span><br><span class=line>  <span class=keyword>if</span>(<span class=keyword>TARGET</span> Doxygen::doxygen)</span><br><span class=line>    <span class=keyword>set</span>(doxyfileout <span class=variable>${CMAKE_CURRENT_BINARY_DIR}</span>/<span class=variable>${doxyfilein}</span>)</span><br><span class=line>    <span class=keyword>configure_file</span>(<span class=variable>${doxyfilein}</span> <span class=variable>${doxyfileout}</span> @ONLY)</span><br><span class=line>    <span class=keyword>set</span>(targetName <span class=string>"${CMAKE_PROJECT_NAME}_doc"</span>)</span><br><span class=line>    <span class=keyword>add_custom_target</span>(<span class=variable>${targetName}</span> <span class=keyword>COMMAND</span> Doxygen::doxygen <span class=variable>${doxyfileout}</span></span><br><span class=line>                                  WORKING_DIRECTORY <span class=variable>${CMAKE_CURRENT_SOURCE_DIR}</span></span><br><span class=line>                                  COMMENT <span class=string>"Generating API documentation with Doxygen"</span> VERBATIM</span><br><span class=line>                              SOURCES <span class=variable>${doxyfilein}</span> <span class=variable>${doxyfileout}</span>)</span><br><span class=line></span><br><span class=line>    <span class=keyword>set_target_properties</span>(<span class=variable>${targetName}</span> PROPERTIES FOLDER <span class=variable>${CMAKE_PROJECT_NAME}</span>)</span><br><span class=line>    <span class=keyword>source_group</span>(doxyfile_input FILES <span class=variable>${doxyfilein}</span>)</span><br><span class=line>    <span class=keyword>source_group</span>(doxyfile_output FILES <span class=variable>${doxyfileout}</span>)</span><br><span class=line>  <span class=keyword>else</span>()</span><br><span class=line>    <span class=keyword>message</span>(STATUS <span class=string>"not have doxygen, ignore"</span>)</span><br><span class=line>  <span class=keyword>endif</span>()</span><br><span class=line><span class=keyword>endfunction</span>()</span><br><span class=line></span><br></pre></table></figure> <p><strong>CPack打包文档</strong></p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>include</span>(GNUInstallDirs)</span><br><span class=line><span class=keyword>install</span>(DIRECTORY <span class=string>"${CMAKE_CURRENT_BINARY_DIR}/docs/html/"</span></span><br><span class=line>DESTINATION <span class=string>"${CMAKE_INSTALL_DOCDIR}"</span> COMPONENT</span><br><span class=line>ch6_ex01_html)</span><br><span class=line><span class=keyword>install</span>(DIRECTORY <span class=string>"${CMAKE_CURRENT_BINARY_DIR}/docs/man/"</span></span><br><span class=line>DESTINATION <span class=string>"${CMAKE_INSTALL_MANDIR}"</span> COMPONENT</span><br><span class=line>ch6_ex01_man)</span><br></pre></table></figure> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>set</span>(CPACK_PACKAGE_NAME cbp_chapter6_example01)</span><br><span class=line><span class=keyword>set</span>(CPACK_PACKAGE_VENDOR <span class=string>"CBP Authors"</span>)</span><br><span class=line><span class=keyword>set</span>(CPACK_GENERATOR <span class=string>"DEB;RPM;TBZ2"</span>)</span><br><span class=line><span class=keyword>set</span>(CPACK_DEBIAN_PACKAGE_MAINTAINER <span class=string>"CBP Authors"</span>)</span><br><span class=line><span class=keyword>include</span>(CPack)</span><br></pre></table></figure> <h3 id=集成代码质量工具><a class=headerlink href=#集成代码质量工具 title=集成代码质量工具></a>集成代码质量工具</h3><h4 id=代码测试><a class=headerlink href=#代码测试 title=代码测试></a>代码测试</h4><p>通过 CTest,CMake 可以以内置的方法来执行测试,设置 enable_testing(),并使用 add_test() 添加了测试的 CMake 项目都支持运行测试,</p> <p>enable_testing() 将在当前目录和其子目录中启用,并添加测试,</p> <p>因此在使用 add_subdirectory 前,通常将其设置在顶层的 CMakeLists.txt 中,若使用 <strong>include(CTest),CMake 的 CTest 模块会自动设置 enable_testing</strong>, 除非 BUILD_TESTING 为 OFF,</p> <blockquote><p>根据 BUILD_TESTING 选项禁用构建和运行测试也是一种很好的实践,<p>这里的常用模式是将项目中与测试相关的所有部分放在其子文件夹中,并且只在 BUILD_TESTING 设置为 ON 时包含子 文件夹,</blockquote> <p>CTest 将使用有关测试的信息并执行它们,通过独立运行 ctest 或作为 CMake 构建步骤的一部 分,来执行测试,以下两个命令都可执行测试:</p> <figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>ctest --test-dir  &LTbuild_dir></span><br><span class=line>cmake --build &LTbuild_dir> --target <span class=built_in>test</span></span><br></pre></table></figure> <p>有选择地执行测试的另一种方法是使用 LABELS 属性进行标记,然后使用 CTest 的-L选项选 择要运行的标签,一个测试可以有多个用分号分隔的标签</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>add_test</span>(NAME labeled_test_1 <span class=keyword>COMMAND</span> someTest)</span><br><span class=line><span class=keyword>set_tests_properties</span>(labeled_test PROPERTIES LABELS <span class=string>"example"</span>)</span><br><span class=line><span class=keyword>add_test</span>(NAME labeled_test_2 <span class=keyword>COMMAND</span> anotherTest)</span><br><span class=line><span class=keyword>set_tests_properties</span>(labeled_test_2 PROPERTIES LABELS <span class=string>"will_fail"</span> )</span><br><span class=line><span class=keyword>add_test</span>(NAME labeled_test_3 <span class=keyword>COMMAND</span> YetAnotherText)</span><br><span class=line><span class=keyword>set_tests_properties</span>(labeled_test_3 PROPERTIES LABELS <span class=string>"example;will_fail"</span>)</span><br><span class=line></span><br></pre></table></figure> <p>-L 命令行选项接受一个正则表达式来过滤标签</p> <figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>ctest -L <span class=string>"example|will_fail"</span></span><br></pre></table></figure> <p>更好的测试库比如使用googleTest.</p> <p>此外还有代码静态检查(包括格式化,语法检查等)、覆盖率以及代码消杀等工具,但其实其中一些功能已经由其他程序代替了(比如IDE和一些编辑器),这里不做描述</p> <h3 id=执行自定义任务><a class=headerlink href=#执行自定义任务 title=执行自定义任务></a>执行自定义任务</h3><p><strong>构建时执行自定义任务</strong></p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>add_custom_target</span>(Name [ALL] [command1 [args1...]]</span><br><span class=line>[<span class=keyword>COMMAND</span> command2 [args2...] ...]</span><br><span class=line>[DEPENDS depend depend depend ... ]</span><br><span class=line>[BYPRODUCTS [files...]]</span><br><span class=line>[WORKING_DIRECTORY dir]</span><br><span class=line>[COMMENT comment]</span><br><span class=line>[JOB_POOL job_pool]</span><br><span class=line>[VERBATIM] [USES_TERMINAL]</span><br><span class=line>[COMMAND_EXPAND_LISTS]</span><br><span class=line>[SOURCES src1 [src2...]])</span><br></pre></table></figure> <p><code>add_custom_target</code> 用于定义一个自定义的目标,这个目标可以运行一个命令或一组命令</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>add_executable</span>(SomeExe)</span><br><span class=line><span class=keyword>add_custom_target</span>(CreateHash ALL <span class=keyword>COMMAND</span> Somehasher</span><br><span class=line>$&LTTARGET_FILE:SomeExe>)</span><br></pre></table></figure> <p>定义一个自定义的目标,该目标本身不是一个可执行文件或库,而是一个独立的任务,比如清理操作、生成文档等,</p> <p><strong>add_custom_command</strong></p> <p>在构建目标时可能需要执行外部任务,CMake 中可以使用 add_custom_command 来 实现这一点,它有两个签名,一个用于将命令与现有目标挂钩,而另一个用于生成文件,</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>add_executable</span>(MyExecutable)</span><br><span class=line><span class=keyword>add_custom_command</span>(<span class=keyword>TARGET</span> MyExecutable</span><br><span class=line>POST_BUILD</span><br><span class=line><span class=keyword>COMMAND</span> hasher $&LTTARGET_FILE:ch8_custom_command_example></span><br><span class=line><span class=variable>${CMAKE_CURRENT_BINARY_DIR}</span>/MyExecutable.sha256</span><br><span class=line>COMMENT <span class=string>"Creating hash for MyExecutable"</span></span><br><span class=line>)</span><br></pre></table></figure> <p><code>add_custom_command</code> 用于定义一个命令,该命令会在构建过程中运行,并可以与一个目标关联.</p> <p>它可以用来生成源文件或执行其他任务,希望自定义任务产生特定的输出文件,这可以通过定义自定义目标,并在目标之间设置 必要的依赖项来实现</p> <ul><li>PRE_BUILD: 在 Visual Studio 中,此命令在执行其他构建步骤之前执行,当使用其他生成器 时,会在 PRE_LINK 命令之前运行,<li>PRE_LINK: 此命令将在编译源代码之后运行,在可执行文件或存档工具链接到静态库之前运行,<li>POS_BUILD: 这将在执行所有其他构建规则后运行该命令,</ul> <p>主要用于对目标进行读写,或是生成一些文件</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>add_custom_command</span>(OUTPUT archive.tar.gz</span><br><span class=line><span class=keyword>COMMAND</span> cmake -E tar czf <span class=variable>${CMAKE_CURRENT_BINARY_DIR}</span>/archive.tar.gz</span><br><span class=line>$&LTTARGET_FILE:MyTarget></span><br><span class=line>COMMENT <span class=string>"Creating Archive for MyTarget"</span></span><br><span class=line>VERBATIM</span><br><span class=line>)</span><br><span class=line><span class=keyword>add_custom_command</span>(OUTPUT archive.tar.gz</span><br><span class=line><span class=keyword>COMMAND</span> cmake -E tar czf <span class=variable>${CMAKE_CURRENT_BINARY_DIR}</span>/archive.</span><br><span class=line>tar.gz</span><br><span class=line><span class=variable>${CMAKE_CURRENT_SOURCE_DIR}</span>/SomeFile.txt</span><br><span class=line>APPEND</span><br><span class=line>)</span><br></pre></table></figure> <p><code>VERBATIM</code> 是一个关键字,用于控制如何解释 <code>add_custom_command</code> 或 <code>add_custom_target</code> 中定义的命令行,当你在命令中使用 <code>VERBATIM</code> 关键字时,CMake 会将整个命令行作为单个字符串传递给构建系统,而不是尝试解析其中的变量或表达式</p> <p><strong>配置时执行自定义任务</strong></p> <p>生成在构建前需要的信息,或者 需要更新文件以重新运行 CMake,另一个情况是在配置步骤中生成 CMakeLists.txt 文件或其他输入 文件,也可以通过 configure_file 实现</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>execute_process</span>(</span><br><span class=line><span class=keyword>COMMAND</span> SomeExecutable</span><br><span class=line><span class=keyword>COMMAND</span> AnotherExecutable</span><br><span class=line>COMMAND_ERROR_IS_FATAL_ANY</span><br><span class=line>)</span><br><span class=line></span><br></pre></table></figure> <p>构建软件时,常见的任务是在构建前将一些文件复制到特定位置或进行修改,解决方案是使用 configure_file 指令,可以将文件从一个位置复制到 另一个位置,</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>configure_file</span>(&LTinput> &LToutput></span><br><span class=line>NO_SOURCE_PERMISSIONS | USE_SOURCE_PERMISSIONS |</span><br><span class=line>FILE_PERMISSIONS &LTpermissions>...]</span><br><span class=line>[COPYONLY] [ESCAPE_QUOTES] [@ONLY]</span><br><span class=line>[NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ])</span><br></pre></table></figure> <p>configure_file 将\<input> 文件复制到\<output>文件,将创建输出文件的路径,路径可以是相对路径或绝对路径,若使用相对路径,则将从当前源目录搜索输入文件,但<strong>输出文件的路径将相对于当前构建目录</strong>, <p>若不能写入输出文件,命令失败,配置停止,通常,输出文件与 目标文件具有相同的权限,若当前用户与输入文件所属的用户不同,所有权可能会发生变化, 若添加了 NO_SOURCE_PERMISSION,则权限不会转移,输出文件将获得默认权限：rw-r—r—, 也可以使用 FILE_PERMISSIONS 选项手动指定权限,该选项接受一个三位数的数字作为参数, USE_SOURCE_PERMISSION 已经是默认选项,这个选项只是为了更明确地进行说明</p> <h3 id=可复制的构建环境><a class=headerlink href=#可复制的构建环境 title=可复制的构建环境></a>可复制的构建环境</h3><p>为了使用预设,项目的顶层目录必须包含名为 CMakePresets.json 或 CMakeUserPresets.json 的文 件,若两个文件都存在,将先解析 CMakePresets.json,再解析 CMakeUserPresets.json,这两个文件 有相同的格式,但使用方式略有不同:</p> <ul><li>CMakePresets.json 由项目本身提供,并处理项目特定的事情,比如运行 CI 构建,或若项目本 身需要哪些工具链,应该使用哪些工具链进行交叉编译,CMakePresets.json 用于特定的项目, 不应该引用项目结构外的文件或路径,由于这些预设与项目紧密相连,通常也处于版本控制 中,<li>CMakeUserPresets.json 通常由开发人员定义,以便在自己的机器或构建环境中使用, CMakeUserPresets.json 可以尽可能的具体,包含项目之外的路径或特定系统设置特有的路径, 因此,项目不应提供此文件,也不应将其置于版本控制中,</ul> <p>预设是将缓存变量、编译器标志等移出 CMakeLists.txt 文件的好方法,同时以一种可以在 CMake 中使用的方式保持可用的信息,从而提高项目的可移植性</p> <p>若预置可用,通过命令 cmake —listpresets 可以从源目录中列出预设</p> <figure class="highlight json"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>{</span><br><span class=line><span class=attr>"version"</span>: <span class=number>3</span>,</span><br><span class=line><span class=attr>"cmakeMinimumRequired"</span>: {<span class=attr>"major"</span>: <span class=number>3</span>,<span class=attr>"minor"</span>: <span class=number>21</span>,<span class=attr>"patch"</span>:</span><br><span class=line><span class=number>0</span> },</span><br><span class=line><span class=attr>"configurePresets"</span>: [...],</span><br><span class=line><span class=attr>"buildPresets"</span>: [...],</span><br><span class=line><span class=attr>"testPresets"</span>: [...],</span><br><span class=line><span class=attr>"vendor"</span>: {</span><br><span class=line><span class=attr>"microsoft.com/VisualStudioSettings/CMake/1.9"</span>:</span><br><span class=line>{ <span class=attr>"intelliSenseMode"</span>: <span class=string>"windows-msvc-x64"</span></span><br><span class=line>} }</span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight json"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line>{</span><br><span class=line><span class=attr>"version"</span>: <span class=number>3</span>,</span><br><span class=line><span class=attr>"configurePresets"</span>: [</span><br><span class=line>{</span><br><span class=line><span class=attr>"name"</span>: <span class=string>"ninja"</span>,</span><br><span class=line><span class=attr>"displayName"</span>: <span class=string>"Ninja Debug"</span>,</span><br><span class=line><span class=attr>"description"</span>: <span class=string>"build in debug mode using Ninja generator"</span>,</span><br><span class=line><span class=attr>"generator"</span>: <span class=string>"Ninja"</span>,</span><br><span class=line><span class=attr>"binaryDir"</span>: <span class=string>"build"</span>,</span><br><span class=line><span class=attr>"cacheVariables"</span>: { <span class=attr>"CMAKE_BUILD_TYPE"</span>: <span class=string>"Debug"</span> }</span><br><span class=line>}</span><br><span class=line>]</span><br><span class=line>}</span><br></pre></table></figure> <p>可以使用inherits字段进行继承</p> <figure class="highlight json"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line>{</span><br><span class=line><span class=attr>"version"</span>: <span class=number>3</span>,</span><br><span class=line><span class=attr>"configurePresets"</span>: [</span><br><span class=line>{</span><br><span class=line><span class=attr>"name"</span>: <span class=string>"ci-ninja"</span>,</span><br><span class=line><span class=attr>"generator"</span>: <span class=string>"Ninja"</span>,</span><br><span class=line><span class=attr>"hidden"</span>: <span class=literal>true</span>,</span><br><span class=line><span class=attr>"binaryDir"</span>: <span class=string>"build"</span></span><br><span class=line>},</span><br><span class=line>{</span><br><span class=line><span class=attr>"name"</span>: <span class=string>"ci-ninja-debug"</span>,</span><br><span class=line><span class=attr>"inherits"</span>: <span class=string>"ci-ninja"</span>,</span><br><span class=line><span class=attr>"cacheVariables"</span>: {</span><br><span class=line><span class=attr>"CMAKE_BUILD_TYPE"</span>: <span class=string>"Debug"</span></span><br><span class=line>}</span><br><span class=line>},</span><br><span class=line>{</span><br><span class=line><span class=attr>"name"</span>: <span class=string>"ci-ninja-release"</span>,</span><br><span class=line><span class=attr>"inherits"</span>: <span class=string>"ci-ninja"</span>,</span><br><span class=line><span class=attr>"cacheVariables"</span>: {</span><br><span class=line><span class=attr>"CMAKE_BUILD_TYPE"</span>: <span class=string>"Release"</span></span><br><span class=line>}</span><br><span class=line>}</span><br><span class=line>]</span><br><span class=line>}</span><br></pre></table></figure> <h3 id=基本模块><a class=headerlink href=#基本模块 title=基本模块></a>基本模块</h3><p><strong>函数</strong></p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>function</span>(git_get_branch_name result_var_name)</span><br><span class=line><span class=keyword>execute_process</span>(</span><br><span class=line><span class=keyword>COMMAND</span> git symbolic-ref -q --short HEAD</span><br><span class=line>WORKING_DIRECTORY <span class=string>"${CMAKE_CURRENT_SOURCE_DIR}"</span></span><br><span class=line>OUTPUT_VARIABLE git_current_branch_name</span><br><span class=line>OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class=line>ERROR_QUIET</span><br><span class=line>)</span><br><span class=line><span class=keyword>set</span>(<span class=variable>${result_var_name}</span> <span class=variable>${git_current_branch_name}</span></span><br><span class=line>PARENT_SCOPE)</span><br><span class=line><span class=keyword>endfunction</span>()</span><br></pre></table></figure> <p>函数定义了一个新的变量作用域,因此对 CMake 变量所做的更改只在函数体中可见,独立作 用域是函数最重要的属性,有了新的作用域就能避免意外地将变量暴露给使用者,除非我们想这样做</p> <p>大多数时候,我们希望在<strong>函数的作用域中包含更改</strong>,并且<strong>只将函数的结果反映给使用者</strong>,由于 CMake 没有返回值的概念,我们将采用在调用者的作用域方法中定义一个变量来将函数结果返回给使用者</p> <p><strong>宏</strong></p> <p>宏不定义新的变量作用域</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>macro</span>(git_get_branch_name_m result_var_name)</span><br><span class=line><span class=keyword>execute_process</span>(</span><br><span class=line><span class=keyword>COMMAND</span> git symbolic-ref -q --short HEAD</span><br><span class=line>WORKING_DIRECTORY <span class=string>"${CMAKE_CURRENT_SOURCE_DIR}"</span></span><br><span class=line>OUTPUT_VARIABLE <span class=variable>${result_var_name}</span></span><br><span class=line>OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class=line>ERROR_QUIET</span><br><span class=line>)</span><br><span class=line><span class=keyword>endmacro</span>()</span><br></pre></table></figure> <h2 id=具体项目><a class=headerlink href=#具体项目 title=具体项目></a>具体项目</h2><p>参考<a href=https://github.com/Ubpa/UCMake/blob/master/cmake/UbpaBasic.cmake rel=noopener target=_blank>UCMake/cmake/UbpaBasic.cmake at master · Ubpa/UCMake (github.com)</a></p> <p>首先介绍一下其中用到的方法,搭一个cmake项目,主要逻辑是利用include和add_subdirectory增加模块,同时设置更多变脸. 使用function和macro写一些工具方法.</p> <figure class="highlight cmake"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>cmake_parse_arguments</span>(PREFIX  [<span class=keyword>OPTION</span> names]  [ONE_VALUE names]  [MULTI_VALUE names]  [UNPARSED_ARGUMENTS var]  [args...] )</span><br></pre></table></figure> <p>参数解释</p> <ul><li><strong>PREFIX</strong>：一个字符串,用于前缀命名解析出来的变量.<li><strong>OPTION</strong>：可选关键字参数列表,每个参数只接受或不接受一个值,通常用于开关选项.<li><strong>ONE_VALUE</strong>：关键字参数列表,每个参数接受一个值.<li><strong>MULTI_VALUE</strong>：关键字参数列表,每个参数可以接受一个或多个值.<li><strong>UNPARSED_ARGUMENTS</strong>：一个变量名,未解析的参数将被存储在这个变量中.<li><strong>args…</strong>：传递给<code>cmake_parse_arguments()</code>的实际参数列表</ul> <p><code>CMAKE_MODULE_PATH</code>是CMake中的一个环境变量,用于指定CMake应该搜索额外模块文件的目录列表.这些模块文件通常包含自定义的CMake函数和宏,或者包含用于查找特定库、包的配置文件.</p> <p>需要在开始设置的属性比较多,包括编译器及其版本,输出目标目录,构建类型等等</p> <p>这些其实可以在CMAKE -D中设置</p> <figure class="highlight autoit"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>CMAKE_BUILD_TYPE:<span class=built_in>STRING</span> <span class=meta>#构建类型</span></span><br><span class=line>CMAKE_CXX_COMPILER <span class=meta>#修改编译器</span></span><br><span class=line>DCMAKE_CXX_FLAGS:<span class=built_in>STRING</span>=<span class=string>"-Wall</span></span><br><span class=line><span class=string>  -Werror"</span>  <span class=meta># 构建标志</span></span><br></pre></table></figure> <blockquote><p>CMAKE_BUILD_TYPE 变量只对单配置生成器有意义,例如 Unix Makefiles 和 Ninja.在多配 置生成器中,例如 Visual Studio,<strong>构建类型是一个构建时参数,不是一个配置时参数,因此 不能通过使用 CMAKE_BUILD_TYPE 来配置</strong></blockquote> <p>CMake 本身提供了四种构建类型:</p> <p>• Debug: 未优化,包含所有调试符号,所有的断言都是启用的.这与 GCC 和 Clang 设置-O0 -g 是一样的.</p> <p>• Release: 对运行速度进行优化,没有调试符号和断言禁用.通常,这是用于交付的构建类型. 这与-O3 -DNDEBUG 相同.</p> <p>• RelWithDebInfo: 提供优化,并包括调试符号,禁用断言,这与-O2 -g -DNDEBUG 相同.</p> <p>• MinSizeRel: 这和 Release 是一样的,但优化了二进制大小,而不是速度,这与-Os -DNDEBUG 相同.注意,并不是所有平台上的生成器都支持此配置.</p> <p>构建标志可以为每个构建类型定制,方法是在它们后面加上大写的构建类型字符串.有四个变 量用于四个不同的构建类型,它们对于根据编译器标志指定构建类型非常有用.这些变量中指定的 标志只在配置构建类型匹配时有效: 1. CMAKE__FLAGS_DEBUG 2. CMAKE<strong>FLAGS_RELEASE 3. CMAKE\</strong>FLAGS_RELWITHDEBINFO 4. CMAKE__FLAGS_MINSIZEREL</p> <h3 id=参考资料><a class=headerlink href=#参考资料 title=参考资料></a>参考资料</h3><ol><li><a href=https://blog.csdn.net/llffss/article/details/120121617 rel=noopener target=_blank>cmake指令汇总_cmake命令大全_nuosen123的博客-CSDN博客</a><li><a href=https://www.runoob.com/w3cnote/cpp-static-library-and-dynamic-library.html rel=noopener target=_blank>C++静态库与动态库 | 菜鸟教程 (runoob.com)</a><li><a href=https://zhuanlan.zhihu.com/p/578843962 rel=noopener target=_blank>使用C++创建并调用动态链接库(dll) - 知乎 (zhihu.com)</a><li><a href=https://blog.csdn.net/Op_chaos/article/details/110476264?spm=1001.2101.3001.6650.7&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-7-110476264-blog-120121617.235^v38^pc_relevant_anti_t3_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-7-110476264-blog-120121617.235^v38^pc_relevant_anti_t3_base&utm_relevant_index=11 rel=noopener target=_blank>CMake指令详解_cmake -d-CSDN博客</a><li><a href=https://blog.csdn.net/qq_25160757/article/details/79813428 rel=noopener target=_blank>VS的包含目录、库目录、引用目录、可执行目录解释_vs包含目录和引用目录-CSDN博客</a><li><a href=https://www.cnblogs.com/pandamohist/p/13674438.html rel=noopener target=_blank>cmake之Visual studio无法显示头文件 - mohist - 博客园 (cnblogs.com)</a><li><a href=https://blog.csdn.net/sandalphon4869/article/details/100589747 rel=noopener target=_blank>Linux之cmake的指令以及内部构建和外部构建_cmake 外部编译-CSDN博客</a><li><a href=https://www.cnblogs.com/guoshuai-ouc/p/cmake_variable.html rel=noopener target=_blank>cmake 常用变量和常用环境变量 - 小果子啊 - 博客园 (cnblogs.com)</a><li><a href=https://blog.csdn.net/qq_38410730/article/details/102477162 rel=noopener target=_blank>【CMake】CMakeLists.txt的超傻瓜手把手教程（附实例源码）_【cmake】cmakelists.txt的超傻瓜手把手教程(附实例源码)-CSDN博客</a><li><a href=https://developer.aliyun.com/article/243229#:~:text=官网不推荐使用l,aries使用. rel=noopener target=_blank>make的link_directories命令不起作用-阿里云开发者社区 (aliyun.com)</a><li><a href=https://cmake.org/cmake/help/latest/ rel=noopener target=_blank>CMake Reference Documentation — CMake 3.28.0-rc1 Documentation</a><li><a href=https://blog.csdn.net/afei__/article/details/81201039 rel=noopener target=_blank>CMakeLists.txt 语法介绍与实例演练-CSDN博客</a><li><a href=https://www.bookstack.cn/read/Modern-CMake-CN-Modern-CMake-zh_CN/701c8402c6158612.md rel=noopener target=_blank>现代的 CMake 的介绍 - 《Modern CMake 简体中文版》 - 书栈网 · BookStack</a><li><a href=https://cmakebyexample.dev/ rel=noopener target=_blank>CMake by Example</a><li><a href=https://makefiletutorial.com/#makefile-cookbook rel=noopener target=_blank>Makefile Tutorial By Example</a><li><a href=https://www.youtube.com/watch?v=bsXLMQ6WgIk&ab_channel=CppNow rel=noopener target=_blank>C ++现在2017年：丹尼尔·菲费尔“有效的CMake” (youtube.com)</a></ol> <link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script> <div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div> <div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div> <div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a href=https://www.sekyoro.top/2023/10/11/cmake%E5%AD%A6%E4%B9%A0/ title=cmake学习>https://www.sekyoro.top/2023/10/11/cmake学习/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div> <div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div> <footer class=post-footer><div class=post-tags><a href=/tags/CMake/ rel=tag><i class="fa fa-tag"></i> CMake</a></div><div class=post-nav><div class=post-nav-item><a href=/2023/10/04/stable-diffusion%E5%AD%A6%E4%B9%A0/ rel=prev title=stable_diffusion学习> <i class="fa fa-chevron-left"></i> stable_diffusion学习 </a></div><div class=post-nav-item><a title="目标检测(Object Detection)学习_P1" href=/2023/10/11/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B-Object-Detection-%E5%AD%A6%E4%B9%A0/ rel=next> 目标检测(Object Detection)学习_P1 <i class="fa fa-chevron-right"></i> </a></div></div></footer> <!-- 评论区 --> <div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div> <script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script> <div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div> <aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#Before-cmake><span class=nav-number>1.</span> <span class=nav-text>Before cmake</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#syntax><span class=nav-number>1.1.</span> <span class=nav-text>syntax</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#more-examples><span class=nav-number>1.2.</span> <span class=nav-text>more examples</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#clean><span class=nav-number>1.3.</span> <span class=nav-text>clean</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#variables><span class=nav-number>1.4.</span> <span class=nav-text>variables</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Targets><span class=nav-number>1.5.</span> <span class=nav-text>Targets</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#automatic-variables-and-wildcards><span class=nav-number>1.6.</span> <span class=nav-text>automatic variables and wildcards</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%9A%90%E5%BC%8F%E8%A7%84%E5%88%99><span class=nav-number>1.7.</span> <span class=nav-text>隐式规则</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%9D%A1%E4%BB%B6><span class=nav-number>1.8.</span> <span class=nav-text>条件</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%87%BD%E6%95%B0><span class=nav-number>1.9.</span> <span class=nav-text>函数</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#cmake-fundamental><span class=nav-number>2.</span> <span class=nav-text>cmake fundamental</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%B8%B8%E7%94%A8%E5%8F%98%E9%87%8F><span class=nav-number>3.</span> <span class=nav-text>常用变量</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%8C%87%E5%AE%9A%E7%94%9F%E6%88%90%E7%A8%8B%E5%BA%8F><span class=nav-number>4.</span> <span class=nav-text>指定生成程序</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%B7%BB%E5%8A%A0%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%92%8C%E5%BA%93><span class=nav-number>5.</span> <span class=nav-text>添加头文件目录和库</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#find-package-amp-find-path-amp-find-library><span class=nav-number>6.</span> <span class=nav-text>find_package&find_path&find_library</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%BC%96%E8%AF%91%E6%97%B6%E6%B6%88%E6%81%AF%E8%BE%93%E5%87%BA><span class=nav-number>7.</span> <span class=nav-text>编译时消息输出</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%AE%BE%E7%BD%AE%E5%8F%98%E9%87%8F><span class=nav-number>8.</span> <span class=nav-text>设置变量</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84><span class=nav-number>9.</span> <span class=nav-text>控制结构</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%B7%BB%E5%8A%A0%E5%85%B6%E4%BB%96%E5%AD%90%E7%9B%AE%E5%BD%95><span class=nav-number>10.</span> <span class=nav-text>添加其他子目录</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6><span class=nav-number>11.</span> <span class=nav-text>获取文件</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#vs%E4%B8%AD%E6%98%BE%E7%A4%BA%E5%A4%B4%E6%96%87%E4%BB%B6><span class=nav-number>12.</span> <span class=nav-text>vs中显示头文件</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#option%E4%B8%8Eadd-definitions><span class=nav-number>13.</span> <span class=nav-text>option与add_definitions</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E7%A4%BA><span class=nav-number>13.1.</span> <span class=nav-text>生成器表示</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Advanced-cmake><span class=nav-number>14.</span> <span class=nav-text>Advanced cmake</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#Effective-CMake><span class=nav-number>14.0.1.</span> <span class=nav-text>Effective CMake</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E9%80%9A%E7%94%A8><span class=nav-number>14.0.1.1.</span> <span class=nav-text>通用</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%A8%A1%E5%9D%97Modules><span class=nav-number>14.0.1.2.</span> <span class=nav-text>模块Modules</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E9%A1%B9%E7%9B%AEProjects><span class=nav-number>14.0.1.3.</span> <span class=nav-text>项目Projects</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%9B%AE%E6%A0%87-Targets-%E5%8F%8A%E5%85%B6%E5%B1%9E%E6%80%A7-Properties><span class=nav-number>14.0.1.4.</span> <span class=nav-text>目标(Targets)及其属性(Properties)</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AE%8F><span class=nav-number>14.0.1.5.</span> <span class=nav-text>函数与宏</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%BE%AA%E7%8E%AF><span class=nav-number>14.0.1.6.</span> <span class=nav-text>循环</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%8C%85><span class=nav-number>14.0.1.7.</span> <span class=nav-text>包</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91><span class=nav-number>14.0.1.8.</span> <span class=nav-text>交叉编译</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E8%AD%A6%E5%91%8A%E4%B8%8E%E6%8A%A5%E9%94%99><span class=nav-number>14.0.1.9.</span> <span class=nav-text>警告与报错</span></a></ol></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%AE%9E%E6%88%98><span class=nav-number>15.</span> <span class=nav-text>实战</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84><span class=nav-number>15.1.</span> <span class=nav-text>项目结构</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%88%9B%E5%BB%BA%E5%BA%93><span class=nav-number>15.2.</span> <span class=nav-text>创建库</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%91%BD%E5%90%8D%E5%BA%93><span class=nav-number>15.3.</span> <span class=nav-text>命名库</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%8F%AF%E8%A7%81%E6%80%A7><span class=nav-number>15.4.</span> <span class=nav-text>动态库的符号可见性</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4%E5%8F%AF%E8%A7%81%E6%80%A7><span class=nav-number>15.5.</span> <span class=nav-text>更改默认可见性</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BA%AF%E5%A4%B4%E6%96%87%E4%BB%B6%E5%BA%93><span class=nav-number>15.6.</span> <span class=nav-text>接口和纯头文件库</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AF%B9%E8%B1%A1%E5%BA%93><span class=nav-number>15.7.</span> <span class=nav-text>对象库</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BD%BF%E7%94%A8%E5%BA%93><span class=nav-number>15.8.</span> <span class=nav-text>使用库</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AE%BE%E7%BD%AE%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E9%93%BE%E6%8E%A5%E5%99%A8%E9%80%89%E9%A1%B9><span class=nav-number>15.9.</span> <span class=nav-text>设置编译器和链接器选项</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%B0%83%E8%AF%95%E7%BC%96%E8%AF%91%E5%99%A8%E9%80%89%E9%A1%B9><span class=nav-number>15.10.</span> <span class=nav-text>调试编译器选项</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%BA%93%E5%88%AB%E5%90%8D><span class=nav-number>15.11.</span> <span class=nav-text>库别名</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BD%BF%E7%94%A8%E9%A2%84%E8%AE%BE%E5%80%BC%E7%BB%B4%E6%8A%A4%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE><span class=nav-number>15.12.</span> <span class=nav-text>使用预设值维护构建配置</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%89%93%E5%8C%85%E3%80%81%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%89%E8%A3%85><span class=nav-number>15.13.</span> <span class=nav-text>打包、部署和安装</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%AE%89%E8%A3%85%E6%96%87%E4%BB%B6><span class=nav-number>15.13.1.</span> <span class=nav-text>安装文件</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95><span class=nav-number>15.13.2.</span> <span class=nav-text>安装目录</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%8F%90%E4%BE%9B%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF><span class=nav-number>15.13.3.</span> <span class=nav-text>提供项目配置信息</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%88%9B%E5%BB%BA%E5%AE%89%E8%A3%85%E5%8C%85><span class=nav-number>15.13.4.</span> <span class=nav-text>创建安装包</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%AF%BB%E6%89%BE%E5%8C%85%E5%92%8C%E6%96%87%E4%BB%B6><span class=nav-number>15.13.5.</span> <span class=nav-text>寻找包和文件</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8><span class=nav-number>15.13.6.</span> <span class=nav-text>包管理器</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%8E%B7%E5%8F%96%E4%BE%9D%E8%B5%96%E9%A1%B9%E6%BA%90%E4%BB%A3%E7%A0%81><span class=nav-number>15.13.7.</span> <span class=nav-text>获取依赖项源代码</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3><span class=nav-number>15.14.</span> <span class=nav-text>自动生成文档</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%9B%86%E6%88%90%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%B7%A5%E5%85%B7><span class=nav-number>15.15.</span> <span class=nav-text>集成代码质量工具</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95><span class=nav-number>15.15.1.</span> <span class=nav-text>代码测试</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%89%A7%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%BB%E5%8A%A1><span class=nav-number>15.16.</span> <span class=nav-text>执行自定义任务</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8F%AF%E5%A4%8D%E5%88%B6%E7%9A%84%E6%9E%84%E5%BB%BA%E7%8E%AF%E5%A2%83><span class=nav-number>15.17.</span> <span class=nav-text>可复制的构建环境</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97><span class=nav-number>15.18.</span> <span class=nav-text>基本模块</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%85%B7%E4%BD%93%E9%A1%B9%E7%9B%AE><span class=nav-number>16.</span> <span class=nav-text>具体项目</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99><span class=nav-number>16.1.</span> <span class=nav-text>参考资料</span></a></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>206</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>17</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>196</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a><li class=links-of-blogroll-item><a href=https://www.lllomh.com/ rel=noopener target=_blank title=https://www.lllomh.com/>芈渡</a><li class=links-of-blogroll-item><a href=https://protool-ten.vercel.app/ rel=noopener target=_blank title=https://protool-ten.vercel.app/>protools</a></ul></div><div class="motion-element announcement"><div class=title></div><p class=content><p class=date></div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>文章词云</h3><div class="widget tagcloud" id=myCanvasContainer><canvas height=250 id=resCanvas style=width:100% width=250><ul class=tag-list itemprop=keywords><li class=tag-list-item><a class=tag-list-link href=/tags/CMake/ rel=tag>CMake</a><span class=tag-list-count>1</span></ul></canvas></div></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside> <div id=sidebar-dimmer></div> <footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>1.7m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>25:53</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer> <script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script> <script src=/lib/anime.min.js></script> <script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script> <script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script> <script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script> <script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script> <script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script> <script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script> <script src=/js/utils.js></script> <script src=/js/motion.js></script> <script src=/js/schemes/pisces.js></script> <script src=/js/next-boot.js></script> <script src=/js/bookmark.js></script> <script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	'.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script> <script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script> <script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script> <script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script> <script src=/js/algolia-search.js></script> <script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script> <div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div> <script charset=utf-8 defer src=/js/tagcanvas.js></script> <script charset=utf-8 defer src=/js/tagcloud.js></script> <script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script> <script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script> <script src=/js/src/activate-power-mode.min.js></script> <script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script>
<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"0F9LEEVW82","apiKey":"78839e9f9be09d081c5c4da81975cd19","indexName":"sekyoblog_sec","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content=容器、智能指针与正则表达式. name=description><meta content=article property=og:type><meta content="modern cpp learning(二)" property=og:title><meta content=https://www.sekyoro.top/2024/06/09/modern-cpp-learning-%E4%BA%8C/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content=容器、智能指针与正则表达式. property=og:description><meta content=zh_CN property=og:locale><meta content=https://changkun.de/modern-cpp/assets/figures/pointers1.png property=og:image><meta content=https://changkun.de/modern-cpp/assets/figures/pointers2.png property=og:image><meta content=2024-06-09T04:46:41.000Z property=article:published_time><meta content=2024-06-17T03:33:58.680Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content=cpp property=article:tag><meta content=summary name=twitter:card><meta content=https://changkun.de/modern-cpp/assets/figures/pointers1.png name=twitter:image><link href=https://www.sekyoro.top/2024/06/09/modern-cpp-learning-%E4%BA%8C/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>modern cpp learning(二) | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2024/06/09/modern-cpp-learning-%E4%BA%8C/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>modern cpp learning(二)</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-06-09 12:46:41" datetime=2024-06-09T12:46:41+08:00>2024-06-09</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2024-06-17 11:33:58" datetime=2024-06-17T11:33:58+08:00 itemprop=dateModified>2024-06-17</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>18k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>16 分钟</span> </span></div></header><div class=post-body itemprop=articleBody><p>容器、智能指针与正则表达式.<br><span id=more></span><h2 id=容器><a class=headerlink href=#容器 title=容器></a>容器</h2><p>常用的容器如下:<ol><li><strong>std::vector</strong>:<ul><li>动态数组容器,支持随机访问。<li>可以动态增加或减少容器大小。<li>适用于需要快速随机访问的场景。</ul><li><strong>std::list</strong>:<ul><li>双向链表容器,支持高效的插入和删除操作。<li>不支持随机访问,但在需要频繁插入/删除的场景下性能更好。<li>适用于需要频繁插入/删除的数据结构,如栈、队列等。</ul><li><strong>std::deque</strong>(双端队列):<ul><li>双端队列容器,支持在头尾快速插入和删除。<li>实现上结合了数组和链表的优点。<li>适用于需要在头尾高效插入/删除的场景。</ul><li><strong>std::set</strong>/<strong>std::unordered_set</strong>:<ul><li>有序集合和无序集合容器,自动排序/散列存储元素。<li>支持高效的查找、插入和删除操作。<li>适用于需要去重和快速查找的场景。</ul><li><strong>std::map</strong>/<strong>std::unordered_map</strong>:<ul><li>关联数组容器,以键-值对的形式存储元素。<li>有序映射和无序映射,支持高效的查找、插入和删除。<li>适用于需要快速查找或存储键值对的场景。</ul><li><strong>std::stack</strong>/<strong>std::queue</strong>:<ul><li>栈和队列容器,提供先进先出(FIFO)和后进先出(LIFO)的操作。<li>基于其他容器(如 <code>std::deque</code>)实现。<li>适用于需要实现栈和队列数据结构的场景。</ul></ol><p>主要的 STL 算法:<ol><li><strong>排序算法</strong>:<ul><li><code>std::sort()</code>: 使用快速排序算法对元素进行排序。<li><code>std::stable_sort()</code>: 使用稳定排序算法(如归并排序)对元素进行排序。<li><code>std::partial_sort()</code>: 将前 N 个元素排序,其他元素保持原有顺序。<li><code>std::nth_element()</code>: 将第 N 个元素放到正确的位置,其他元素的相对顺序不变。</ul><li><strong>查找算法</strong>:<ul><li><code>std::find()</code>: 在序列中查找指定元素。<li><code>std::find_if()</code>: 使用自定义条件在序列中查找元素。<li><code>std::binary_search()</code>: 在已排序的序列中进行二分查找。<li><code>std::lower_bound()</code>: 返回指向序列中第一个不小于给定值的元素的迭代器。<li><code>std::upper_bound()</code>: 返回指向序列中第一个大于给定值的元素的迭代器。</ul><li><strong>修改算法</strong>:<ul><li><code>std::transform()</code>: 对序列中的每个元素应用给定的函数。<li><code>std::replace()</code>: 用新值替换序列中满足条件的元素。<li><code>std::reverse()</code>: 反转序列中的元素。<li><code>std::rotate()</code>: 将序列中的元素循环移动指定的距离。</ul><li><strong>数值算法</strong>:<ul><li><code>std::accumulate()</code>: 计算序列中元素的累加和。<li><code>std::inner_product()</code>: 计算两个序列的点积。<li><code>std::partial_sum()</code>: 计算序列中前 N 个元素的累加和。</ul><li><strong>集合算法</strong>:<ul><li><code>std::merge()</code>: 将两个有序序列合并成一个有序序列。<li><code>std::set_union()</code>: 计算两个集合的并集。<li><code>std::set_intersection()</code>: 计算两个集合的交集。<li><code>std::set_difference()</code>: 计算两个集合的差集。</ul></ol><p><strong>常用头文件</strong><ol><li>容器:<ul><li><code>std::vector</code>: <code>&LTvector></code><li><code>std::list</code>: <code>&LTlist></code><li><code>std::deque</code>: <code>&LTdeque></code><li><code>std::set</code>: <code>&LTset></code><li><code>std::unordered_set</code>: <code>&LTunordered_set></code><li><code>std::map</code>: <code>&LTmap></code><li><code>std::unordered_map</code>: <code>&LTunordered_map></code><li><code>std::stack</code>: <code>&LTstack></code><li><code>std::queue</code>: <code>&LTqueue></code></ul><li>算法:<ul><li><code>std::sort</code>: <code>&LTalgorithm></code><li><code>std::find</code>: <code>&LTalgorithm></code><li><code>std::accumulate</code>: <code>&LTnumeric></code><li><code>std::transform</code>: <code>&LTalgorithm></code><li><code>std::copy</code>: <code>&LTalgorithm></code></ul><li>其他常用头文件:<ul><li><code>&LTiostream></code>: 用于输入输出<li><code>&LTstring></code>: 用于字符串操作<li><code>&LTmemory></code>: 用于智能指针<li><code>&LTfunctional></code>: 用于函数对象和 lambda 表达式</ul></ol><h3 id=线性容器><a class=headerlink href=#线性容器 title=线性容器></a>线性容器</h3><h4 id=std-array><a class=headerlink href=#std-array title=std::array></a>std::array</h4><p>为什么要使用这个?<ul><li>节省内存<li>相比于普通数组更加现代化</ul><p>与 <code>std::vector</code> 不同，<code>std::array</code> 对象的大小是固定的，如果容器大小是固定的，那么可以优先考虑使用 <code>std::array</code> 容器。 另外由于 <code>std::vector</code> 是自动扩容的，当存入大量的数据后，并且对容器进行了删除操作， 容器并不会自动归还被删除元素相应的内存，这时候就需要手动运行 <code>shrink_to_fit()</code> 释放这部分内存<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line>  std::vector<<span class=keyword>int</span>> v;</span><br><span class=line>  std::cout << <span class=string>"size:"</span> << v.<span class=built_in>size</span>() << std::endl;</span><br><span class=line>  std::cout << <span class=string>"capacity:"</span> << v.<span class=built_in>capacity</span>() << std::endl;</span><br><span class=line>  v.<span class=built_in>push_back</span>(<span class=number>1</span>);</span><br><span class=line>  v.<span class=built_in>push_back</span>(<span class=number>2</span>);</span><br><span class=line>  v.<span class=built_in>push_back</span>(<span class=number>3</span>);</span><br><span class=line>  std::cout << <span class=string>"size:"</span> << v.<span class=built_in>size</span>() << std::endl;  <span class=comment>// 输出 3</span></span><br><span class=line>  std::cout << <span class=string>"capacity:"</span> << v.<span class=built_in>capacity</span>() << std::endl;</span><br><span class=line></span><br><span class=line>  v.<span class=built_in>clear</span>();</span><br><span class=line>  std::cout << <span class=string>"size:"</span> << v.<span class=built_in>size</span>() << std::endl;  <span class=comment>// 输出 3</span></span><br><span class=line>  std::cout << <span class=string>"capacity:"</span> << v.<span class=built_in>capacity</span>() << std::endl;</span><br><span class=line>v.<span class=built_in>shrink_to_fit</span>();</span><br><span class=line>std::cout << <span class=string>"size:"</span> << v.<span class=built_in>size</span>() << std::endl;         <span class=comment>// 输出 0</span></span><br><span class=line>std::cout << <span class=string>"capacity:"</span> << v.<span class=built_in>capacity</span>() << std::endl; </span><br></pre></table></figure><p>使用 <code>std::array</code> 能够让代码变得更加“现代化”，而且封装了一些操作函数，比如获取数组大小以及检查是否非空，同时还能够友好的使用标准库中的容器算法，比如 <code>std::sort</code><figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line>std::array<<span class=keyword>int</span>, 4> arr = {<span class=number>1</span>, <span class=number>2</span>, <span class=number>3</span>, <span class=number>4</span>};</span><br><span class=line></span><br><span class=line>arr.<span class=built_in>empty</span>(); <span class=comment>// 检查容器是否为空</span></span><br><span class=line>arr.<span class=built_in>size</span>();  <span class=comment>// 返回容纳的元素数</span></span><br><span class=line></span><br><span class=line><span class=comment>// 迭代器支持</span></span><br><span class=line><span class=keyword>for</span> (<span class=keyword>auto</span> &i : arr)</span><br><span class=line>{</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 用 lambda 表达式排序</span></span><br><span class=line>std::<span class=built_in>sort</span>(arr.<span class=built_in>begin</span>(), arr.<span class=built_in>end</span>(), [](<span class=keyword>int</span> a, <span class=keyword>int</span> b) {</span><br><span class=line>    <span class=keyword>return</span> b < a;</span><br><span class=line>});</span><br><span class=line></span><br><span class=line><span class=comment>// 数组大小参数必须是常量表达式</span></span><br><span class=line><span class=keyword>constexpr</span> <span class=keyword>int</span> len = <span class=number>4</span>;</span><br><span class=line>std::array<<span class=keyword>int</span>, len> arr = {<span class=number>1</span>, <span class=number>2</span>, <span class=number>3</span>, <span class=number>4</span>};</span><br><span class=line></span><br><span class=line><span class=comment>// 非法,不同于 C 风格数组，std::array 不会自动退化成 T*</span></span><br><span class=line><span class=comment>// int *arr_p = arr;</span></span><br></pre></table></figure><p>当我们开始用上了 <code>std::array</code> 时，难免会遇到要将其兼容 C 风格的接口，这里有三种做法：<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>void</span> <span class=title>foo</span><span class=params>(<span class=keyword>int</span> *p, <span class=keyword>int</span> len)</span> </span>{</span><br><span class=line>    <span class=keyword>return</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line>std::array<<span class=keyword>int</span>, 4> arr = {<span class=number>1</span>,<span class=number>2</span>,<span class=number>3</span>,<span class=number>4</span>};</span><br><span class=line></span><br><span class=line><span class=comment>// C 风格接口传参</span></span><br><span class=line><span class=comment>// foo(arr, arr.size()); // 非法, 无法隐式转换</span></span><br><span class=line><span class=built_in>foo</span>(&arr[<span class=number>0</span>], arr.<span class=built_in>size</span>());</span><br><span class=line><span class=built_in>foo</span>(arr.<span class=built_in>data</span>(), arr.<span class=built_in>size</span>());</span><br><span class=line></span><br><span class=line><span class=comment>// 使用 `std::sort`</span></span><br><span class=line>std::<span class=built_in>sort</span>(arr.<span class=built_in>begin</span>(), arr.<span class=built_in>end</span>());</span><br></pre></table></figure><h4 id=std-forward-list><a class=headerlink href=#std-forward-list title=std::forward_list></a>std::forward_list</h4><p><code>std::forward_list</code> 是一个列表容器，使用方法和 <code>std::list</code> 基本类似<p>需要知道的是，和 <code>std::list</code> 的双向链表的实现不同，<code>std::forward_list</code> <strong>使用单向链表进行实现， 提供了 <code>O(1)</code> 复杂度的元素插入，不支持快速随机访问</strong>（这也是链表的特点）， 也是标准库容器中唯一一个不提供 <code>size()</code> 方法的容器。<strong>当不需要双向迭代时，具有比 <code>std::list</code> 更高的空间利用率</strong><h3 id=无序容器><a class=headerlink href=#无序容器 title=无序容器></a>无序容器</h3><p>我们已经熟知了传统 C++ 中的有序容器 <code>std::map</code>/<code>std::set</code>，这些元素内部通过红黑树进行实现， 插入和搜索的平均复杂度均为 <strong><code>O(log(size))</code></strong>。<strong>在插入元素时候，会根据 <code><</code> 操作符比较元素大小并判断元素是否相同， 并选择合适的位置插入到容器中。</strong>当对这个容器中的元素进行遍历时，输出结果会按照 <code><</code> 操作符的顺序来逐个遍历。<p>而无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 <code>O(constant)</code>， 在不关心容器内部元素顺序时，能够获得显著的性能提升.<p>C++11 引入了的两组无序容器分别是：<code>std::unordered_map</code>/<code>std::unordered_multimap</code> 和 <code>std::unordered_set</code>/<code>std::unordered_multiset</code>,它们的用法和原有的 <code>std::map</code>/<code>std::multimap</code>/<code>std::set</code>/<code>set::multiset</code> 基本类似<blockquote><p>无序容器插入和搜索元素的平均复杂度O(1),所以不需要排序时可以考虑使用</blockquote><figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunordered_map></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTmap></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=comment>// 两组结构按同样的顺序初始化</span></span><br><span class=line>    std::unordered_map<<span class=keyword>int</span>, std::string> u = {</span><br><span class=line>        {<span class=number>1</span>, <span class=string>"1"</span>},</span><br><span class=line>        {<span class=number>3</span>, <span class=string>"3"</span>},</span><br><span class=line>        {<span class=number>2</span>, <span class=string>"2"</span>}</span><br><span class=line>    };</span><br><span class=line>    std::map<<span class=keyword>int</span>, std::string> v = {</span><br><span class=line>        {<span class=number>1</span>, <span class=string>"1"</span>},</span><br><span class=line>        {<span class=number>3</span>, <span class=string>"3"</span>},</span><br><span class=line>        {<span class=number>2</span>, <span class=string>"2"</span>}</span><br><span class=line>    };</span><br><span class=line></span><br><span class=line>    <span class=comment>// 分别对两组结构进行遍历</span></span><br><span class=line>    std::cout << <span class=string>"std::unordered_map"</span> << std::endl;</span><br><span class=line>    <span class=keyword>for</span>( <span class=keyword>const</span> <span class=keyword>auto</span> & n : u)</span><br><span class=line>        std::cout << <span class=string>"Key:["</span> << n.first << <span class=string>"] Value:["</span> << n.second << <span class=string>"]\n"</span>;</span><br><span class=line></span><br><span class=line>    std::cout << std::endl;</span><br><span class=line>    std::cout << <span class=string>"std::map"</span> << std::endl;</span><br><span class=line>    <span class=keyword>for</span>( <span class=keyword>const</span> <span class=keyword>auto</span> & n : v)</span><br><span class=line>        std::cout << <span class=string>"Key:["</span> << n.first << <span class=string>"] Value:["</span> << n.second << <span class=string>"]\n"</span>;</span><br><span class=line>}</span><br></pre></table></figure><h3 id=元组><a class=headerlink href=#元组 title=元组></a>元组</h3><p>纵观传统 C++ 中的容器，除了 <code>std::pair</code> 外， 似乎没有现成的结构能够用来存放不同类型的数据（通常我们会自己定义结构）。 但 <code>std::pair</code> 的缺陷是显而易见的，只能保存两个元素。<p><strong>核心操作</strong><p>关于元组的使用有三个核心的函数：<ol><li><code>std::make_tuple</code>: 构造元组(装包)<li><code>std::get</code>: 获得元组某个位置的值<li><code>std::tie</code>: 元组拆包</ol><figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTtuple></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>auto</span> <span class=title>get_student</span><span class=params>(<span class=keyword>int</span> id)</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>    <span class=comment>// 返回类型被推断为 std::tuple&LTdouble, char, std::string></span></span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (id == <span class=number>0</span>)</span><br><span class=line>        <span class=keyword>return</span> std::<span class=built_in>make_tuple</span>(<span class=number>3.8</span>, <span class=string>'A'</span>, <span class=string>"张三"</span>);</span><br><span class=line>    <span class=keyword>if</span> (id == <span class=number>1</span>)</span><br><span class=line>        <span class=keyword>return</span> std::<span class=built_in>make_tuple</span>(<span class=number>2.9</span>, <span class=string>'C'</span>, <span class=string>"李四"</span>);</span><br><span class=line>    <span class=keyword>if</span> (id == <span class=number>2</span>)</span><br><span class=line>        <span class=keyword>return</span> std::<span class=built_in>make_tuple</span>(<span class=number>1.7</span>, <span class=string>'D'</span>, <span class=string>"王五"</span>);</span><br><span class=line>    <span class=keyword>return</span> std::<span class=built_in>make_tuple</span>(<span class=number>0.0</span>, <span class=string>'D'</span>, <span class=string>"null"</span>);</span><br><span class=line>    <span class=comment>// 如果只写 0 会出现推断错误, 编译失败</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>    <span class=keyword>auto</span> student = <span class=built_in>get_student</span>(<span class=number>0</span>);</span><br><span class=line>    std::cout << <span class=string>"ID: 0, "</span></span><br><span class=line>    << <span class=string>"GPA: "</span> << std::get<<span class=number>0</span>>(student) << <span class=string>", "</span></span><br><span class=line>    << <span class=string>"成绩: "</span> << std::get<<span class=number>1</span>>(student) << <span class=string>", "</span></span><br><span class=line>    << <span class=string>"姓名: "</span> << std::get<<span class=number>2</span>>(student) << <span class=string>'\n'</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>double</span> gpa;</span><br><span class=line>    <span class=keyword>char</span> grade;</span><br><span class=line>    std::string name;</span><br><span class=line></span><br><span class=line>    <span class=comment>// 元组进行拆包</span></span><br><span class=line>    std::<span class=built_in>tie</span>(gpa, grade, name) = <span class=built_in>get_student</span>(<span class=number>1</span>);</span><br><span class=line>    std::cout << <span class=string>"ID: 1, "</span></span><br><span class=line>    << <span class=string>"GPA: "</span> << gpa << <span class=string>", "</span></span><br><span class=line>    << <span class=string>"成绩: "</span> << grade << <span class=string>", "</span></span><br><span class=line>    << <span class=string>"姓名: "</span> << name << <span class=string>'\n'</span>;</span><br></pre></table></figure><p><code>std::get</code> 除了使用常量获取元组对象外，C++14 增加了<strong>使用类型来获取元组中的对象</strong>：<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=function>std::tuple&LTstd::string, <span class=keyword>double</span>, <span class=keyword>double</span>, <span class=keyword>int</span>> <span class=title>t</span><span class=params>(<span class=string>"123"</span>, <span class=number>4.5</span>, <span class=number>6.7</span>, <span class=number>8</span>)</span></span>;</span><br><span class=line>std::cout << std::get&LTstd::string>(t) << std::endl;</span><br><span class=line>std::cout << std::get<<span class=keyword>double</span>>(t) << std::endl; <span class=comment>// 非法, 引发编译期错误</span></span><br><span class=line>std::cout << std::get<<span class=number>3</span>>(t) << std::endl;</span><br></pre></table></figure><h4 id=运行期索引><a class=headerlink href=#运行期索引 title=运行期索引></a>运行期索引</h4><p>如果你仔细思考一下可能就会发现上面代码的问题，<code>std::get<></code> 依赖一个编译期的常量，所以下面的方式是不合法的：<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>int</span> index = <span class=number>1</span>;</span><br><span class=line>std::get&LTindex>(t);</span><br></pre></table></figure><blockquote><p>可以通过constexpr解决这个问题</blockquote><p>如果想通过运行期要怎么处理？答案是，使用 <code>std::variant<></code>（C++ 17 引入），提供给 <code>variant<></code> 的类型模板参数 可以让一个 <code>variant<></code> 从而容纳提供的几种类型的变量（在其他语言，例如 Python/JavaScript 等，<strong>表现为动态类型</strong>）：<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTvariant></span></span></span><br><span class=line><span class=keyword>template</span> <<span class=keyword>size_t</span> n, <span class=keyword>typename</span>... T></span><br><span class=line><span class=keyword>constexpr</span> std::variant&LTT...> _tuple_index(<span class=keyword>const</span> std::tuple&LTT...>& tpl, <span class=keyword>size_t</span> i) {</span><br><span class=line>    <span class=function><span class=keyword>if</span> <span class=title>constexpr</span> <span class=params>(n >= <span class=keyword>sizeof</span>...(T))</span></span></span><br><span class=line><span class=function>        <span class=keyword>throw</span> <span class=title>std::out_of_range</span><span class=params>(<span class=string>"越界."</span>)</span></span>;</span><br><span class=line>    <span class=keyword>if</span> (i == n)</span><br><span class=line>        <span class=keyword>return</span> std::variant&LTT...>{ std::in_place_index&LTn>, std::get&LTn>(tpl) };</span><br><span class=line>    <span class=keyword>return</span> _tuple_index<(n < <span class=keyword>sizeof</span>...(T)<span class=number>-1</span> ? n+<span class=number>1</span> : <span class=number>0</span>)>(tpl, i);</span><br><span class=line>}</span><br><span class=line><span class=keyword>template</span> <<span class=keyword>typename</span>... T></span><br><span class=line><span class=function><span class=keyword>constexpr</span> std::variant&LTT...> <span class=title>tuple_index</span><span class=params>(<span class=keyword>const</span> std::tuple&LTT...>& tpl, <span class=keyword>size_t</span> i)</span> </span>{</span><br><span class=line>    <span class=keyword>return</span> _tuple_index<<span class=number>0</span>>(tpl, i);</span><br><span class=line>}</span><br><span class=line><span class=keyword>template</span> <<span class=keyword>typename</span> T0, <span class=keyword>typename</span> ... Ts></span><br><span class=line>std::ostream & <span class=keyword>operator</span><< (std::ostream & s, std::variant&LTT0, Ts...> <span class=keyword>const</span> & v) { </span><br><span class=line>    std::<span class=built_in>visit</span>([&](<span class=keyword>auto</span> && x){ s << x;}, v); </span><br><span class=line>    <span class=keyword>return</span> s;</span><br><span class=line>}</span><br></pre></table></figure><p>这样我们就能：<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>int</span> i = <span class=number>1</span>;</span><br><span class=line>std::cout << <span class=built_in>tuple_index</span>(t, i) << std::endl;</span><br></pre></table></figure><h4 id=元组合并与遍历><a class=headerlink href=#元组合并与遍历 title=元组合并与遍历></a>元组合并与遍历</h4><p>还有一个常见的需求就是<strong>合并两个元组</strong>，这可以通过 <code>std::tuple_cat</code> 来实现：<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>std::tuple t = std::<span class=built_in>make_tuple</span>(<span class=number>1</span>, <span class=number>2.0</span>, <span class=string>"3"</span>);</span><br><span class=line> <span class=keyword>auto</span> new_tuple = std::<span class=built_in>tuple_cat</span>(<span class=built_in>get_student</span>(<span class=number>1</span>), std::<span class=built_in>move</span>(t));</span><br></pre></table></figure><p>马上就能够发现，应该如何快速遍历一个元组？但是我们刚才介绍了如何在运行期通过非常数索引一个 <code>tuple</code> 那么遍历就变得简单了， 首先我们需要知道一个元组的长度，可以：<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>template</span> <<span class=keyword>typename</span> T></span><br><span class=line><span class=function><span class=keyword>auto</span> <span class=title>tuple_len</span><span class=params>(T &tpl)</span> </span>{</span><br><span class=line>    <span class=keyword>return</span> std::tuple_size&LTT>::value;</span><br><span class=line>}</span><br></pre></table></figure><p>这样就能够对元组进行迭代了：<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>// 迭代</span></span><br><span class=line><span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>0</span>; i != <span class=built_in>tuple_len</span>(new_tuple); ++i)</span><br><span class=line>    <span class=comment>// 运行期索引</span></span><br><span class=line>    std::cout << <span class=built_in>tuple_index</span>(new_tuple, i) << std::endl;</span><br></pre></table></figure><h2 id=智能指针和内存管理><a class=headerlink href=#智能指针和内存管理 title=智能指针和内存管理></a>智能指针和内存管理</h2><p>在传统 C++ 中，『记得』手动释放资源，总不是最佳实践。因为我们很有可能就忘记了去释放资源而导致泄露。 所以通常的做法是对于一个对象而言，我们<strong>在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间</strong>， 也就是我们常说的 RAII 资源获取即初始化技术。<p>凡事都有例外，<strong>我们总会有需要将对象在自由存储上分配的需求</strong>(堆空间,指针等)，在传统 C++ 里我们只好使用 <code>new</code> 和 <code>delete</code> 去 『记得』对资源进行释放。而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。 这些智能指针包括 <code>std::shared_ptr</code>/<code>std::unique_ptr</code>/<code>std::weak_ptr</code>，使用它们需要包含头文件 <code>&LTmemory></code>。<blockquote><p>注意：<strong>引用计数不是垃圾回收，引用计数能够尽快收回不再被使用的对象</strong>，同时在回收的过程中也不会造成长时间的等待， 更能够清晰明确的表明资源的生命周期。</blockquote><h4 id=std-shared-ptr><a class=headerlink href=#std-shared-ptr title=std::shared_ptr></a>std::shared_ptr</h4><p><code>std::shared_ptr</code> 是一种智能指针，它能够记录多少个 <code>shared_ptr</code> 共同指向一个对象，从而消除显式的调用 <code>delete</code>，当引用计数变为零的时候就会将对象自动删除。<p>但还不够，因为使用 <code>std::shared_ptr</code> 仍然需要使用 <code>new</code> 来调用，这使得代码出现了某种程度上的不对称。<p><code>std::make_shared</code> 就能够用来消除显式的使用 <code>new</code>，所以<code>std::make_shared</code> 会分配创建传入参数中的对象， 并返回这个对象类型的<code>std::shared_ptr</code>指针。例如：<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTmemory></span></span></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>foo</span><span class=params>(std::shared_ptr<<span class=keyword>int</span>> i)</span> </span>{</span><br><span class=line>    (*i)++;</span><br><span class=line>}</span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=comment>// auto pointer = new int(10); // illegal, no direct assignment</span></span><br><span class=line>    <span class=comment>// Constructed a std::shared_ptr</span></span><br><span class=line>    <span class=keyword>auto</span> pointer = std::make_shared<<span class=keyword>int</span>>(<span class=number>10</span>);</span><br><span class=line>    <span class=built_in>foo</span>(pointer);</span><br><span class=line>    std::cout << *pointer << std::endl; <span class=comment>// 11</span></span><br><span class=line>    <span class=comment>// The shared_ptr will be destructed before leaving the scope</span></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><p><code>std::shared_ptr</code> 可以通过 <code>get()</code> 方法来获取原始指针，通过 <code>reset()</code> 来减少一个引用计数， 并通过<code>use_count()</code>来查看一个对象的引用计数。例如：<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=keyword>auto</span> pointer = std::make_shared<<span class=keyword>int</span>>(<span class=number>10</span>);</span><br><span class=line><span class=keyword>auto</span> pointer2 = pointer; <span class=comment>// 引用计数+1</span></span><br><span class=line><span class=keyword>auto</span> pointer3 = pointer; <span class=comment>// 引用计数+1</span></span><br><span class=line><span class=keyword>int</span> *p = pointer.<span class=built_in>get</span>();  <span class=comment>// 这样不会增加引用计数</span></span><br><span class=line>std::cout << <span class=string>"pointer.use_count() = "</span> << pointer.<span class=built_in>use_count</span>() << std::endl;   <span class=comment>// 3</span></span><br><span class=line>std::cout << <span class=string>"pointer2.use_count() = "</span> << pointer2.<span class=built_in>use_count</span>() << std::endl; <span class=comment>// 3</span></span><br><span class=line>std::cout << <span class=string>"pointer3.use_count() = "</span> << pointer3.<span class=built_in>use_count</span>() << std::endl; <span class=comment>// 3</span></span><br><span class=line></span><br><span class=line>pointer2.<span class=built_in>reset</span>();</span><br><span class=line>std::cout << <span class=string>"reset pointer2:"</span> << std::endl;</span><br><span class=line>std::cout << <span class=string>"pointer.use_count() = "</span> << pointer.<span class=built_in>use_count</span>() << std::endl;   <span class=comment>// 2</span></span><br><span class=line>std::cout << <span class=string>"pointer2.use_count() = "</span></span><br><span class=line>          << pointer2.<span class=built_in>use_count</span>() << std::endl;           <span class=comment>// pointer2 已 reset; 0</span></span><br><span class=line>std::cout << <span class=string>"pointer3.use_count() = "</span> << pointer3.<span class=built_in>use_count</span>() << std::endl; <span class=comment>// 2</span></span><br><span class=line>pointer3.<span class=built_in>reset</span>();</span><br><span class=line>std::cout << <span class=string>"reset pointer3:"</span> << std::endl;</span><br><span class=line>std::cout << <span class=string>"pointer.use_count() = "</span> << pointer.<span class=built_in>use_count</span>() << std::endl;   <span class=comment>// 1</span></span><br><span class=line>std::cout << <span class=string>"pointer2.use_count() = "</span> << pointer2.<span class=built_in>use_count</span>() << std::endl; <span class=comment>// 0</span></span><br><span class=line>std::cout << <span class=string>"pointer3.use_count() = "</span></span><br><span class=line>          << pointer3.<span class=built_in>use_count</span>() << std::endl;           <span class=comment>// pointer3 已 reset; 0</span></span><br></pre></table></figure><h4 id=std-unique-ptr><a class=headerlink href=#std-unique-ptr title=std::unique_ptr></a>std::unique_ptr</h4><p><code>std::unique_ptr</code> 是一种独占的智能指针，它<strong>禁止其他智能指针与其共享同一个对象</strong>，从而保证代码的安全<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>std::unique_ptr<<span class=keyword>int</span>> pointer = std::make_unique<<span class=keyword>int</span>>(<span class=number>10</span>); <span class=comment>// make_unique 从 C++14 引入std::unique_ptr&LTint> pointer2 = pointer; // 非法</span></span><br></pre></table></figure><p>C++11 没有提供 <code>std::make_unique</code>，可以自行实现：<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>template</span><<span class=keyword>typename</span> T, <span class=keyword>typename</span> ...Args></span></span><br><span class=line><span class=function>std::unique_ptr&LTT> <span class=title>make_unique</span><span class=params>( Args&& ...args )</span> </span>{</span><br><span class=line>  <span class=keyword>return</span> std::unique_ptr&LTT>( <span class=keyword>new</span> <span class=built_in>T</span>( std::forward&LTArgs>(args)... ) );</span><br><span class=line>}</span><br></pre></table></figure><p>既然是独占，换句话说就是不可复制。但是，我们可<strong>以利用 <code>std::move</code> 将其转移给其他的 <code>unique_ptr</code></strong>，例如：<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTmemory></span></span></span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>Foo</span> {</span></span><br><span class=line>    <span class=built_in>Foo</span>() { std::cout << <span class=string>"Foo::Foo"</span> << std::endl; }</span><br><span class=line>    ~<span class=built_in>Foo</span>() { std::cout << <span class=string>"Foo::~Foo"</span> << std::endl; }</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>foo</span><span class=params>()</span> </span>{ std::cout << <span class=string>"Foo::foo"</span> << std::endl; }</span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>f</span><span class=params>(<span class=keyword>const</span> Foo &)</span> </span>{</span><br><span class=line>    std::cout << <span class=string>"f(const Foo&)"</span> << std::endl;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=function>std::unique_ptr&LTFoo> <span class=title>p1</span><span class=params>(std::make_unique&LTFoo>())</span></span>;</span><br><span class=line>    <span class=comment>// p1 不空, 输出</span></span><br><span class=line>    <span class=keyword>if</span> (p1) p1-><span class=built_in>foo</span>();</span><br><span class=line>    {</span><br><span class=line>        <span class=function>std::unique_ptr&LTFoo> <span class=title>p2</span><span class=params>(std::move(p1))</span></span>;</span><br><span class=line>        <span class=comment>// p2 不空, 输出</span></span><br><span class=line>        <span class=built_in>f</span>(*p2);</span><br><span class=line>        <span class=comment>// p2 不空, 输出</span></span><br><span class=line>        <span class=keyword>if</span>(p2) p2-><span class=built_in>foo</span>();</span><br><span class=line>        <span class=comment>// p1 为空, 无输出</span></span><br><span class=line>        <span class=keyword>if</span>(p1) p1-><span class=built_in>foo</span>();</span><br><span class=line>        p1 = std::<span class=built_in>move</span>(p2);</span><br><span class=line>        <span class=comment>// p2 为空, 无输出</span></span><br><span class=line>        <span class=keyword>if</span>(p2) p2-><span class=built_in>foo</span>();</span><br><span class=line>        std::cout << <span class=string>"p2 被销毁"</span> << std::endl;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// p1 不空, 输出</span></span><br><span class=line>    <span class=keyword>if</span> (p1) p1-><span class=built_in>foo</span>();</span><br><span class=line>    <span class=comment>// Foo 的实例会在离开作用域时被销毁</span></span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>使用 <code>std::move(p1)</code> 将 <code>p1</code> 的所有权转移给 <code>p2</code> 时, <code>p1</code> 会变为空指针的原因如下:<ol><li><code>std::unique_ptr</code> 是一种独占式的智能指针,这意味着一个 <code>std::unique_ptr</code> 对象只能拥有一个动态分配的对象的所有权。<li>当你使用 <code>std::move(p1)</code> 时, <code>p1</code> 的所有权被转移给了 <code>p2</code>。这是因为 <code>std::move</code> 函数将 <code>p1</code> 转换为一个右值引用,从而使所有权从 <code>p1</code> 转移到 <code>p2</code>。<li>一旦所有权被转移,<code>p1</code> 就不再拥有任何动态分配的对象。因此, <code>p1</code> 被设置为空指针,以确保它不会被用于访问已经被转移所有权的对象。</ol><p>这种行为是 <code>std::unique_ptr</code> 设计的一部分,旨在确保程序员不会意外地使用已经失去所有权的指针。这样可以帮助我们避免悬空指针和内存泄漏等常见的错误</blockquote><p>上面代码可以看出unique_ptr存在作用域,在作用域内如果被转移到其他unque_ptr上离开作用域被销毁,同时原本的在其他作用域内不受影响.<h3 id=std-weak-ptr><a class=headerlink href=#std-weak-ptr title=std::weak_ptr></a>std::weak_ptr</h3><p>如果你仔细思考 <code>std::shared_ptr</code> 就会发现依然存在着资源无法释放的问题。看下面这个例子：<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>A</span>;</span></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>B</span>;</span></span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>A</span> {</span></span><br><span class=line>    std::shared_ptr&LTB> pointer;</span><br><span class=line>    ~<span class=built_in>A</span>() {</span><br><span class=line>        std::cout << <span class=string>"A 被销毁"</span> << std::endl;</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>B</span> {</span></span><br><span class=line>    std::shared_ptr&LTA> pointer;</span><br><span class=line>    ~<span class=built_in>B</span>() {</span><br><span class=line>        std::cout << <span class=string>"B 被销毁"</span> << std::endl;</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>auto</span> a = std::make_shared&LTA>();</span><br><span class=line>    <span class=keyword>auto</span> b = std::make_shared&LTB>();</span><br><span class=line>    a->pointer = b;</span><br><span class=line>    b->pointer = a;</span><br><span class=line>}</span><br></pre></table></figure><p>运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 <code>a,b</code>，这使得 <code>a,b</code> 的引用计数均变为了 2，而离开作用域时，<code>a,b</code> 智能指针被析构，却只能造成这块区域的引用计数减一，这样就导致了 <code>a,b</code> 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了内存泄露<p><img alt="图 5.1" data-src=https://changkun.de/modern-cpp/assets/figures/pointers1.png><p>解决这个问题的办法就是使用弱引用指针 <code>std::weak_ptr</code>，<code>std::weak_ptr</code>是一种弱引用（相比较而言 <code>std::shared_ptr</code> 就是一种强引用）。<strong>弱引用不会引起引用计数增加，当换用弱引用时候</strong>，最终的释放流程如图.<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>AA</span>;</span></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>B</span>;</span></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>AA</span> {</span></span><br><span class=line>  std::weak_ptr&LTB> pointer;</span><br><span class=line>  ~<span class=built_in>AA</span>() { std::cout << <span class=string>"AA::~AA"</span> << std::endl; }</span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>B</span> {</span></span><br><span class=line>  std::weak_ptr&LTAA> pointer;</span><br><span class=line>  ~<span class=built_in>B</span>() { std::cout << <span class=string>"B::~B"</span> << std::endl; }</span><br><span class=line>};</span><br></pre></table></figure><p><img alt="图 5.2" data-src=https://changkun.de/modern-cpp/assets/figures/pointers2.png style=zoom:67%;><blockquote><p><code>std::weak_ptr</code> 不会增加引用计数,使得a,b释放后原本对象没有了引用.</blockquote><p>最后一步只剩下 B，而 B 并没有任何智能指针引用它，因此这块内存资源也会被释放。<p><strong><code>std::weak_ptr</code> 没有 <code>*</code> 运算符和 <code>-></code> 运算符</strong>，所以不能够对资源进行操作，它可以用于检查 <code>std::shared_ptr</code> 是否存在，其 <strong><code>expired()</code> 方法能在资源未被释放时，会返回 <code>false</code>，否则返回 <code>true</code></strong>；除此之外，它也可以用于获取指向原始对象的 <code>std::shared_ptr</code> 指针，其 <strong><code>lock()</code> 方法在原始对象未被释放时，返回一个指向原始对象的 <code>std::shared_ptr</code> 指针，进而访问原始对象的资源，否则返回<code>nullptr</code>。</strong><figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>auto</span> aa = std::make_shared&LTAA>();</span><br><span class=line> <span class=keyword>auto</span> bb = std::make_shared&LTB>();</span><br><span class=line> aa->pointer = bb;</span><br><span class=line> bb->pointer = aa;</span><br><span class=line> <span class=keyword>if</span> (!aa->pointer.<span class=built_in>expired</span>()) {</span><br><span class=line>   <span class=keyword>auto</span> shared = aa->pointer.<span class=built_in>lock</span>();</span><br><span class=line>   std::cout << <span class=string>"shared:"</span> << shared.<span class=built_in>use_count</span>() << std::endl;</span><br><span class=line> }</span><br></pre></table></figure><h2 id=正则表达式><a class=headerlink href=#正则表达式 title=正则表达式></a>正则表达式</h2><p>正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求：<ol><li><strong>检查一个串是否包含</strong>某种形式的子串；<li>将匹配的<strong>子串替换</strong>；<li>从<strong>某个串中取出符合条件的子串</strong>。</ol><blockquote><p>检查包含,替换字串,取出字串</blockquote><p>正则表达式是由普通字符（例如 a 到 z）以及特殊字符组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。 正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。<h4 id=普通字符><a class=headerlink href=#普通字符 title=普通字符></a>普通字符</h4><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。<h4 id=特殊字符><a class=headerlink href=#特殊字符 title=特殊字符></a>特殊字符</h4><p>特殊字符是正则表达式里有特殊含义的字符，也是正则表达式的核心匹配语法。参见下表：<div class=table-container><table><thead><tr><th style=text-align:left>特别字符<th style=text-align:left>描述<tbody><tr><td style=text-align:left><code>$</code><td style=text-align:left>匹配输入字符串的结尾位置。<tr><td style=text-align:left><code>(</code>,<code>)</code><td style=text-align:left>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。<tr><td style=text-align:left><code>*</code><td style=text-align:left>匹配前面的子表达式零次或多次。<tr><td style=text-align:left><code>+</code><td style=text-align:left>匹配前面的子表达式一次或多次。<tr><td style=text-align:left><code>.</code><td style=text-align:left>匹配除换行符 <code>\n</code> 之外的任何单字符。<tr><td style=text-align:left><code>[</code><td style=text-align:left>标记一个中括号表达式的开始。<tr><td style=text-align:left><code>?</code><td style=text-align:left>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。<tr><td style=text-align:left><code>\</code><td style=text-align:left>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， <code>n</code> 匹配字符 <code>n</code>。<code>\n</code> 匹配换行符。序列 <code>\\</code> 匹配 <code>'\'</code> 字符，而 <code>\(</code> 则匹配 <code>'('</code> 字符。<tr><td style=text-align:left><code>^</code><td style=text-align:left>匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。<tr><td style=text-align:left><code>{</code><td style=text-align:left>标记限定符表达式的开始。<tr><td style=text-align:left>`<td style=text-align:left>`<td>指明两项之间的一个选择</table></div><p>一些正则表达式示例:<ul><li><p><code>\s</code> 是<strong>匹配所有空白符,包括换行</strong>,\S 非空白符,不包括换行</p><li><p><code>\d+</code>: 匹配一个或多个数字</p><li><code>\b</code> 匹配一个单词边界，也就是指单词和空格间的位置.例如, ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’.<li><code>\w+</code>: 匹配一个或多个字母、数字或下划线字符<li><code>\s+</code>: 匹配一个或多个空白字符<li><code>[aeiou]</code>: 匹配任意一个元音字母<li><code>[a-zA-Z0-9_]+</code>: 匹配一个或多个字母、数字或下划线<li><code>\b\w+\b</code>: 匹配独立的单词<li><code>^[a-z]+$</code>: 匹配全部由小写字母组成的字符串.</ul><div class=table-container><table><thead><tr><th>匹配<th>解释<tbody><tr><td>(pattern)<td><strong>匹配 pattern 并获取这一匹配</strong>。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。<tr><td>(?:pattern)<td><strong>匹配 pattern 但不获取匹配结果</strong>，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (\<td>) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y\<td>ies) 就是一个比 ‘industry\<td>industries’ 更简略的表达式。<tr><td>(?=pattern)<td>正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95\<td>98\<td>NT\<td>2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。<strong>预查不消耗字符</strong>，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。<tr><td>(?!pattern)<td>正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95\<td>98\<td>NT\<td>2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。<strong>预查不消耗字符</strong>，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。<tr><td>(?<=pattern)<td>反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”`(?<=95<td>98<td>NT<td>2000)Windows<code>"能匹配"</code>2000Windows<code>"中的"</code>Windows<code>"，但不能匹配"</code>3.1Windows<code>"中的"</code>Windows`”。<tr><td>(?&LT!pattern)<td>反向否定预查，与正向否定预查类似，只是方向相反。例如”`(?&LT!95<td>98<td>NT<td>2000)Windows<code>"能匹配"</code>3.1Windows<code>"中的"</code>Windows<code>"，但不能匹配"</code>2000Windows<code>"中的"</code>Windows`”。</table></div><h4 id=限定符><a class=headerlink href=#限定符 title=限定符></a>限定符</h4><p>限定符用来指定<strong>正则表达式的一个给定的组件必须要出现多少次才能满足匹配</strong>。见下表：<div class=table-container><table><thead><tr><th style=text-align:left>字符<th style=text-align:left>描述<tbody><tr><td style=text-align:left><code>*</code><td style=text-align:left>匹配前面的子表达式零次或多次。例如，<code>foo*</code> 能匹配 <code>fo</code> 以及 <code>foooo</code>。<code>*</code> 等价于<code>{0,}</code>。<tr><td style=text-align:left><code>+</code><td style=text-align:left>匹配前面的子表达式一次或多次。例如，<code>foo+</code> 能匹配 <code>foo</code> 以及 <code>foooo</code>，但不能匹配 <code>fo</code>。<code>+</code> 等价于 <code>{1,}</code>。<tr><td style=text-align:left><code>?</code><td style=text-align:left>匹配前面的子表达式零次或一次。例如，<code>Your(s)?</code> 可以匹配 <code>Your</code> 或 <code>Yours</code> 中的<code>Your</code> 。<code>?</code> 等价于 <code>{0,1}</code>。<tr><td style=text-align:left><code>{n}</code><td style=text-align:left><code>n</code> 是一个非负整数。匹配确定的 <code>n</code> 次。例如，<code>o{2}</code> 不能匹配 <code>for</code> 中的 <code>o</code>，但是能匹配 <code>foo</code> 中的两个 <code>o</code>。<tr><td style=text-align:left><code>{n,}</code><td style=text-align:left><code>n</code> 是一个非负整数。至少匹配 <code>n</code> 次。例如，<code>o{2,}</code> 不能匹配 <code>for</code> 中的 <code>o</code>，但能匹配 <code>foooooo</code> 中的所有 <code>o</code>。<code>o{1,}</code> 等价于 <code>o+</code>。<code>o{0,}</code> 则等价于 <code>o*</code>。<tr><td style=text-align:left><code>{n,m}</code><td style=text-align:left><code>m</code> 和 <code>n</code> 均为非负整数，其中 <code>n</code> 小于等于 <code>m</code>。最少匹配 <code>n</code> 次且最多匹配 <code>m</code> 次。例如，<code>o{1,3}</code> 将匹配 <code>foooooo</code> 中的前三个 <code>o</code>。<code>o{0,1}</code> 等价于 <code>o?</code>。注意，在逗号和两个数之间不能有空格。</table></div><h3 id=std-regex-及其相关><a title="std::regex 及其相关" class=headerlink href=#std-regex-及其相关></a>std::regex 及其相关</h3><p>对字符串内容进行匹配的最常见手段就是使用正则表达式。 可惜<strong>在传统 C++ 中正则表达式一直没有得到语言层面的支持，没有纳入标准库</strong>， 而 C++ 作为一门高性能语言，在后台服务的开发中，对 URL 资源链接进行判断时， 使用正则表达式也是工业界最为成熟的普遍做法。<p>一般的解决方案就是使用 <code>boost</code> 的正则表达式库。 而 <strong>C++11 正式将正则表达式的的处理方法纳入标准库的行列</strong>，从语言级上提供了标准的支持， 不再依赖第三方。<p>C++11 提供的正则表达式库操作 <code>std::string</code> 对象， 模式 <code>std::regex</code> (本质是 <code>std::basic_regex</code>)进行初始化， 通过 <code>std::regex_match</code> 进行匹配， 从而产生 <code>std::smatch</code> （本质是 <code>std::match_results</code> 对象）<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>std::string fnames[] = {<span class=string>"foot.txt"</span>, <span class=string>"bar.txt"</span>, <span class=string>"test.txt"</span>, <span class=string>"a0.txt"</span>};</span><br><span class=line>  <span class=function>std::regex <span class=title>txt_regex</span><span class=params>(<span class=string>"[a-z]+\\.txt"</span>)</span></span>;</span><br><span class=line>  <span class=keyword>for</span> (<span class=keyword>const</span> <span class=keyword>auto</span>& fname : fnames) {</span><br><span class=line>    std::cout << fname << <span class=string>": "</span> << std::<span class=built_in>regex_match</span>(fname, txt_regex)</span><br><span class=line>              << std::endl;</span><br><span class=line>  }</span><br></pre></table></figure><p>另一种常用的形式就是依次传入 <code>std::string</code>/<code>std::smatch</code>/<code>std::regex</code> 三个参数， 其中 <code>std::smatch</code> 的本质其实是 <code>std::match_results</code>。 故而在标准库的实现中， <code>std::smatch</code> 被定义为了 <code>std::match_results&LTstd::string::const_iterator></code>， 也就是一个子串迭代器类型的 <code>match_results</code>。 使用 <code>std::smatch</code> 可以方便的对匹配的结果进行获取，例如：<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=function>std::regex <span class=title>base_regex</span><span class=params>(<span class=string>"([a-z]+)\\.txt"</span>)</span></span>;</span><br><span class=line>std::smatch base_match;</span><br><span class=line><span class=keyword>for</span>(<span class=keyword>const</span> <span class=keyword>auto</span> &fname: fnames) {</span><br><span class=line>    <span class=keyword>if</span> (std::<span class=built_in>regex_match</span>(fname, base_match, base_regex)) {</span><br><span class=line>        <span class=comment>// std::smatch 的第一个元素匹配整个字符串</span></span><br><span class=line>        <span class=comment>// std::smatch 的第二个元素匹配了第一个括号表达式</span></span><br><span class=line>        <span class=keyword>if</span> (base_match.<span class=built_in>size</span>() == <span class=number>2</span>) {</span><br><span class=line>            std::string base = base_match[<span class=number>1</span>].<span class=built_in>str</span>();</span><br><span class=line>            std::cout << <span class=string>"sub-match[0]: "</span> << base_match[<span class=number>0</span>].<span class=built_in>str</span>() << std::endl;</span><br><span class=line>            std::cout << fname << <span class=string>" sub-match[1]: "</span> << base << std::endl;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script></div><div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div class=popular-posts-header>相关文章</div><ul class=popular-posts><li class=popular-posts-item><div class=popular-posts-title><a href=\2024\09\30\Just-For-Fun-学习c-之后可以尝试的框架-工具\ rel=bookmark>Just For Fun: 学习c++之后可以尝试的框架/工具</a></div><li class=popular-posts-item><div class=popular-posts-title><a href=\2024\09\26\现代cpp多线程与并发初探\ rel=bookmark>现代cpp多线程与并发初探</a></div><li class=popular-posts-item><div class=popular-posts-title><a href=\2024\09\16\完整的C-项目构建注意事项\ rel=bookmark>完整的C++项目构建注意事项</a></div><li class=popular-posts-item><div class=popular-posts-title><a href=\2024\07\21\BTMC-重返Modern-Cpp\ rel=bookmark>BTMC:重返Modern Cpp</a></div><li class=popular-posts-item><div class=popular-posts-title><a href=\2024\06\10\modern-cpp-learning-三\ rel=bookmark>modern cpp learning(三)</a></div></ul><div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a title="modern cpp learning(二)" href=https://www.sekyoro.top/2024/06/09/modern-cpp-learning-%E4%BA%8C/>https://www.sekyoro.top/2024/06/09/modern-cpp-learning-二/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div><footer class=post-footer><div class=post-tags><a href=/tags/cpp/ rel=tag><i class="fa fa-tag"></i> cpp</a></div><div class=post-nav><div class=post-nav-item><a href=/2024/06/08/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%9A%84%E8%8B%A5%E5%B9%B2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/ rel=prev title=跨平台应用开发的若干解决方案> <i class="fa fa-chevron-left"></i> 跨平台应用开发的若干解决方案 </a></div><div class=post-nav-item><a title="modern cpp learning(三)" href=/2024/06/10/modern-cpp-learning-%E4%B8%89/ rel=next> modern cpp learning(三) <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div><!-- 评论区 --><div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%AE%B9%E5%99%A8><span class=nav-number>1.</span> <span class=nav-text>容器</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%BA%BF%E6%80%A7%E5%AE%B9%E5%99%A8><span class=nav-number>1.1.</span> <span class=nav-text>线性容器</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#std-array><span class=nav-number>1.1.1.</span> <span class=nav-text>std::array</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#std-forward-list><span class=nav-number>1.1.2.</span> <span class=nav-text>std::forward_list</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8><span class=nav-number>1.2.</span> <span class=nav-text>无序容器</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%85%83%E7%BB%84><span class=nav-number>1.3.</span> <span class=nav-text>元组</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%B4%A2%E5%BC%95><span class=nav-number>1.3.1.</span> <span class=nav-text>运行期索引</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%85%83%E7%BB%84%E5%90%88%E5%B9%B6%E4%B8%8E%E9%81%8D%E5%8E%86><span class=nav-number>1.3.2.</span> <span class=nav-text>元组合并与遍历</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86><span class=nav-number>2.</span> <span class=nav-text>智能指针和内存管理</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#std-shared-ptr><span class=nav-number>2.0.1.</span> <span class=nav-text>std::shared_ptr</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#std-unique-ptr><span class=nav-number>2.0.2.</span> <span class=nav-text>std::unique_ptr</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#std-weak-ptr><span class=nav-number>2.1.</span> <span class=nav-text>std::weak_ptr</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F><span class=nav-number>3.</span> <span class=nav-text>正则表达式</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%99%AE%E9%80%9A%E5%AD%97%E7%AC%A6><span class=nav-number>3.0.1.</span> <span class=nav-text>普通字符</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6><span class=nav-number>3.0.2.</span> <span class=nav-text>特殊字符</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%99%90%E5%AE%9A%E7%AC%A6><span class=nav-number>3.0.3.</span> <span class=nav-text>限定符</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#std-regex-%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3><span class=nav-number>3.1.</span> <span class=nav-text>std::regex 及其相关</span></a></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>225</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>16</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>206</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a><li class=links-of-blogroll-item><a href=https://www.lllomh.com/ rel=noopener target=_blank title=https://www.lllomh.com/>芈渡</a><li class=links-of-blogroll-item><a href=https://protool-ten.vercel.app/ rel=noopener target=_blank title=https://protool-ten.vercel.app/>protools</a></ul></div><div class="motion-element announcement"><div class=title></div><p class=content><p class=date></div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>文章词云</h3><div class="widget tagcloud" id=myCanvasContainer><canvas height=250 id=resCanvas style=width:100% width=250><ul class=tag-list itemprop=keywords><li class=tag-list-item><a class=tag-list-link href=/tags/cpp/ rel=tag>cpp</a><span class=tag-list-count>8</span></ul></canvas></div></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2025</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>2.2m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>33:22</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer></div><script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script><script src=/lib/anime.min.js></script><script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script><script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/pisces.js></script><script src=/js/next-boot.js></script><script src=/js/bookmark.js></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	'.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script><script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script><script src=/js/algolia-search.js></script><script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script><div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div><script charset=utf-8 defer src=/js/tagcanvas.js></script><script charset=utf-8 defer src=/js/tagcloud.js></script><script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script><script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script><script src=/js/src/activate-power-mode.min.js></script><script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script>
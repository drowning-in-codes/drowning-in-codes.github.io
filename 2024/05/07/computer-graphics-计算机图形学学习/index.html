<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"0F9LEEVW82","apiKey":"78839e9f9be09d081c5c4da81975cd19","indexName":"sekyoblog_sec","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content=简简单单学个概念. name=description><meta content=article property=og:type><meta content="computer graphics:计算机图形学学习" property=og:title><meta content=https://www.sekyoro.top/2024/05/07/computer-graphics-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content=简简单单学个概念. property=og:description><meta content=zh_CN property=og:locale><meta content=https://learnopengl-cn.github.io/img/01/04/pipeline.png property=og:image><meta content=https://s2.loli.net/2024/05/12/36b2pEjwCWGf7N8.png property=og:image><meta content=https://s2.loli.net/2024/05/12/rA39m7M5WTFwQRD.png property=og:image><meta content=https://s2.loli.net/2024/05/12/OxDF2GB7sUk8iRt.png property=og:image><meta content=https://s2.loli.net/2024/05/12/yNZU6TEMkJw8vS5.png property=og:image><meta content=https://s2.loli.net/2024/05/12/LjWzDSbx2McfVpa.png property=og:image><meta content=https://s2.loli.net/2024/05/19/yApJSIKMls4CZzF.png property=og:image><meta content=https://s2.loli.net/2024/05/19/U5DBHQOvcAd2wqp.png property=og:image><meta content=https://s2.loli.net/2024/05/19/9EodBgHcTr5J874.png property=og:image><meta content=https://s2.loli.net/2024/05/19/niHmVGBdhUIR2qv.png property=og:image><meta content=https://s2.loli.net/2024/05/19/ucndILDTHwEMpmW.png property=og:image><meta content=https://s2.loli.net/2024/05/19/t85cSLD7JZ6Vaep.png property=og:image><meta content=https://s2.loli.net/2024/05/19/Hl7XgyvkEi8Gen9.png property=og:image><meta content=https://s2.loli.net/2024/05/19/Rv2IMdrlYDpk9Tq.png property=og:image><meta content=https://s2.loli.net/2024/05/19/N5qEdQ7yZGDzgKn.png property=og:image><meta content=https://s2.loli.net/2024/05/19/V6DlLH2M4jmpgXZ.png property=og:image><meta content=https://s2.loli.net/2024/05/19/PLHMImvQDRfVTUW.png property=og:image><meta content=https://s2.loli.net/2024/05/19/vuFnfNzxKCAotEl.png property=og:image><meta content=https://s2.loli.net/2024/05/19/rasPKwzLBvY7SUk.png property=og:image><meta content=https://s2.loli.net/2024/05/24/f5SoqHvmld8UpDV.png property=og:image><meta content=https://s2.loli.net/2024/05/24/LCIpUV8lKBtJRAD.png property=og:image><meta content=https://s2.loli.net/2024/05/24/zsNxrbOg79kwHAy.png property=og:image><meta content=https://s2.loli.net/2024/05/24/8nHkRoxrWDL7QTK.png property=og:image><meta content=https://s2.loli.net/2024/05/24/HT3ogl5RuJWtbLz.png property=og:image><meta content=https://s2.loli.net/2024/05/24/xp6UaqQC7lscWmV.png property=og:image><meta content=https://s2.loli.net/2024/05/24/IXzWOyn49Y5JpVE.png property=og:image><meta content=https://s2.loli.net/2024/05/25/3ZsDz6MlRxehIfP.png property=og:image><meta content=https://s2.loli.net/2024/05/24/elFT8BIydC3XLEw.png property=og:image><meta content=https://s2.loli.net/2024/05/24/PIprAbJe1HD9SvE.png property=og:image><meta content=https://s2.loli.net/2024/05/24/3fKa4mPENFXgz9o.png property=og:image><meta content=https://s2.loli.net/2024/05/24/LpxJqyRU2u7rd19.png property=og:image><meta content=https://s2.loli.net/2024/05/24/oFExtZaYjLsqD7I.png property=og:image><meta content=https://s2.loli.net/2024/05/24/i47jFfRGB3t9Lx8.png property=og:image><meta content=https://s2.loli.net/2024/05/24/XnR9HyYvdjcSpox.png property=og:image><meta content=https://s2.loli.net/2024/05/24/QhGcYsCd1ny8e3D.png property=og:image><meta content=https://s2.loli.net/2024/05/24/PpGrA8hL17vcmBF.png property=og:image><meta content=https://s2.loli.net/2024/05/24/SMDGjIbdVWiUFYa.png property=og:image><meta content=https://s2.loli.net/2024/05/25/YLGaUhMpVnyrTSE.png property=og:image><meta content=https://s2.loli.net/2024/05/25/39j5Q6aWqIZr87X.png property=og:image><meta content=https://s2.loli.net/2024/05/25/ZwzPhiv72LuEHJp.png property=og:image><meta content=https://s2.loli.net/2024/05/25/D5L4jirsAwNCfI7.png property=og:image><meta content=https://s2.loli.net/2024/05/25/R8Uj61yvnXmoIbc.png property=og:image><meta content=https://s2.loli.net/2024/05/25/ysCe1ApBbnlkqZR.png property=og:image><meta content=https://s2.loli.net/2024/05/25/OWIxDR7yqBC5uen.png property=og:image><meta content=https://s2.loli.net/2024/05/25/YhmLPEoxGZjJ7wn.png property=og:image><meta content=https://s2.loli.net/2024/05/25/Tm2kfgzHxyO1b5S.png property=og:image><meta content=https://s2.loli.net/2024/05/25/XkthROUmr3TzDaq.png property=og:image><meta content=https://s2.loli.net/2024/05/25/vVYOIxGN6bmPuow.png property=og:image><meta content=https://s2.loli.net/2024/05/25/UIFbenyzPNkY782.png property=og:image><meta content=https://s2.loli.net/2024/05/25/M6kJeFrKCiPWYd9.png property=og:image><meta content=https://s2.loli.net/2024/05/26/hAqye8oJLWr2RI3.png property=og:image><meta content=https://s2.loli.net/2024/05/26/GEkQeCXYNxbMqJ7.png property=og:image><meta content=https://s2.loli.net/2024/05/26/sYHdUhBcTq5tw17.png property=og:image><meta content=https://s2.loli.net/2024/05/26/rhK4ZOqMtGzNu2X.png property=og:image><meta content=https://s2.loli.net/2024/05/26/O8xQhoubFZafzD9.png property=og:image><meta content=https://s2.loli.net/2024/05/26/t6yMUePEfpdZ25w.png property=og:image><meta content=https://s2.loli.net/2024/05/28/FdiBq6fVnyUm7wg.png property=og:image><meta content=https://s2.loli.net/2024/05/26/bISzRwqsTp3BhAj.png property=og:image><meta content=https://s2.loli.net/2024/05/26/93tqJlgfBMupFIC.png property=og:image><meta content=https://s2.loli.net/2024/05/26/HvDeG2loYQ6E4Kf.png property=og:image><meta content=https://s2.loli.net/2024/05/28/DRq8BcZVJI9OeaM.png property=og:image><meta content=https://s2.loli.net/2024/05/28/SjqaQ59pxYfIH2E.png property=og:image><meta content=https://s2.loli.net/2024/05/28/IZsbODHYcXngwt6.png property=og:image><meta content=https://s2.loli.net/2024/05/28/EI7yp4GToHrVsXb.png property=og:image><meta content=https://s2.loli.net/2024/05/28/bZOxpmvrok3MQeV.png property=og:image><meta content=https://s2.loli.net/2024/05/28/jltgudeDTN9mQzs.png property=og:image><meta content=https://s2.loli.net/2024/05/28/mR8edIxybTEYkBU.png property=og:image><meta content=https://s2.loli.net/2024/05/28/qL38YXn9dE1WiUK.png property=og:image><meta content=https://s2.loli.net/2024/05/28/o51pJvBfFK9zDeZ.png property=og:image><meta content=https://s2.loli.net/2024/05/28/EAhgOXmBbc2l5yW.png property=og:image><meta content=https://s2.loli.net/2024/05/28/e1MHiZQhqJW4jow.png property=og:image><meta content=https://s2.loli.net/2024/05/28/yGVeQkYPOg3j6zs.png property=og:image><meta content=https://s2.loli.net/2024/05/28/Rgu7eK4kMxSHI2L.png property=og:image><meta content=https://s2.loli.net/2024/05/28/L235usfSm9aliGZ.png property=og:image><meta content=https://s2.loli.net/2024/05/31/elBK7zRus5wXCE4.png property=og:image><meta content=https://s2.loli.net/2024/06/01/PYjBZp936Kq2QVl.png property=og:image><meta content=https://s2.loli.net/2024/06/01/8D2tV9AEnzIh3mH.png property=og:image><meta content=https://s2.loli.net/2024/06/01/WCjEBS4LIXgKYhk.png property=og:image><meta content=https://s2.loli.net/2024/06/01/nDaNxQ2GTb3iUfW.png property=og:image><meta content=https://s2.loli.net/2024/06/01/ZCQs6uEma59rGJx.png property=og:image><meta content=https://s2.loli.net/2024/06/01/cBWnDoLRqmEM1rs.png property=og:image><meta content=https://s2.loli.net/2024/06/01/F6riHxW9OvYPB52.png property=og:image><meta content=https://s2.loli.net/2024/06/01/kQfWdLwKM8JEAO6.png property=og:image><meta content=https://s2.loli.net/2024/06/01/SdR4eM9Lzmqx83u.png property=og:image><meta content=https://s2.loli.net/2024/06/01/dEh2QYDNBZq4Gmw.png property=og:image><meta content=https://s2.loli.net/2024/06/01/Lt8SdEIrph3s7wC.png property=og:image><meta content=https://s2.loli.net/2024/06/02/UHw3QStEyLeJvcg.png property=og:image><meta content=https://s2.loli.net/2024/06/02/b2unaV1cI5EjAGO.png property=og:image><meta content=https://s2.loli.net/2024/06/02/m6cLVeHiUGlbMfZ.png property=og:image><meta content=https://s2.loli.net/2024/06/02/xD2i9V1WznUTF4q.png property=og:image><meta content=https://s2.loli.net/2024/06/02/OMtKHV5yo8TWziU.png property=og:image><meta content=https://s2.loli.net/2024/06/02/NJcHQwevWK9ZO1z.png property=og:image><meta content=https://s2.loli.net/2024/06/02/2lu7SGBX5qcUTbr.png property=og:image><meta content=https://s2.loli.net/2024/06/02/hjSAJr1gxt7Bmep.png property=og:image><meta content=https://s2.loli.net/2024/06/02/DofShqERXKj6wPJ.png property=og:image><meta content=https://s2.loli.net/2024/06/02/nSJchK5OdA4fpNt.png property=og:image><meta content=https://s2.loli.net/2024/06/02/xv3qSwf4XlWAGQs.png property=og:image><meta content=https://s2.loli.net/2024/06/02/gsSYMKUADz4Xp3b.png property=og:image><meta content=https://s2.loli.net/2024/06/02/L1fjxdF4gEzKbpM.png property=og:image><meta content=https://s2.loli.net/2024/06/02/snL4oXfVMKzmqxR.png property=og:image><meta content=https://s2.loli.net/2024/06/02/BRbCeu6IHMSpiFL.png property=og:image><meta content=https://pic3.zhimg.com/v2-c9128ac3f985a48f1c42ea7f12803f8e_b.jpg property=og:image><meta content=https://s2.loli.net/2024/06/02/FEoybKz31a5Mpc6.png property=og:image><meta content=https://pic3.zhimg.com/v2-1df15bb2a394315d869b916c594e1fb2_b.jpg property=og:image><meta content=https://s2.loli.net/2024/06/02/IAHsizpe86rmSCo.png property=og:image><meta content=https://s2.loli.net/2024/06/02/xKZpAtQFj8yimU4.png property=og:image><meta content=https://s2.loli.net/2024/06/02/EhnZtXl7cMkPb2a.png property=og:image><meta content=https://s2.loli.net/2024/06/02/NufB9EKD4wZOPU6.png property=og:image><meta content=https://s2.loli.net/2024/06/02/Fowx9kp7sRbHdMY.png property=og:image><meta content=https://s2.loli.net/2024/06/02/li1ahLZm26DvMru.png property=og:image><meta content=https://s2.loli.net/2024/06/02/NugfonpHmWKzX1V.png property=og:image><meta content=https://s2.loli.net/2024/06/02/CwaPL4fyJtV8uc7.png property=og:image><meta content=https://s2.loli.net/2024/06/02/t2TL8lFwkCp4XfK.png property=og:image><meta content=https://s2.loli.net/2024/06/02/4vfesAZGRpgjChi.png property=og:image><meta content=https://s2.loli.net/2024/06/02/y8Wdgb4t2TJY9qZ.png property=og:image><meta content=https://iewug.github.io/book/img/15renderingEquation.png property=og:image><meta content=https://iewug.github.io/book/img/18.png property=og:image><meta content=https://s2.loli.net/2024/06/24/6UpBiyaDNRWGFws.png property=og:image><meta content=https://s2.loli.net/2024/06/24/bSJjU1PMziDhyg2.png property=og:image><meta content=https://s2.loli.net/2024/06/24/CBP6qkOpLA21a5z.png property=og:image><meta content=https://s2.loli.net/2024/06/24/ieFozQaEGCmhxd9.png property=og:image><meta content=https://iewug.github.io/book/img/19coc.png property=og:image><meta content=https://iewug.github.io/book/img/19dof.png property=og:image><meta content=https://s2.loli.net/2024/06/24/yrHGxeBONiDd2Pz.png property=og:image><meta content=https://s2.loli.net/2024/06/24/Hx2PZirjtD4Lw5d.png property=og:image><meta content=https://s2.loli.net/2024/06/24/nf1QyZV5pgU9BHi.png property=og:image><meta content=https://s2.loli.net/2024/06/24/4pGTPO6Ws1wUvdf.png property=og:image><meta content=https://s2.loli.net/2024/06/24/ErmvTYSaBPXUnMu.png property=og:image><meta content=https://s2.loli.net/2024/06/24/25FQh4KbNSsTrey.png property=og:image><meta content=https://s2.loli.net/2024/06/24/prX2HEvQnexuTPm.png property=og:image><meta content=2024-05-07T10:46:32.000Z property=article:published_time><meta content=2024-06-25T02:49:39.344Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content="个人博客 技术学习 计算机 互联网 人工智能" property=article:tag><meta content=summary name=twitter:card><meta content=https://learnopengl-cn.github.io/img/01/04/pipeline.png name=twitter:image><link href=https://www.sekyoro.top/2024/05/07/computer-graphics-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>computer graphics:计算机图形学学习 | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2024/05/07/computer-graphics-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>computer graphics:计算机图形学学习</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-05-07 18:46:32" datetime=2024-05-07T18:46:32+08:00>2024-05-07</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2024-06-25 10:49:39" datetime=2024-06-25T10:49:39+08:00 itemprop=dateModified>2024-06-25</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>25k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>23 分钟</span> </span></div></header><div class=post-body itemprop=articleBody><p>简简单单学个概念.<br><span id=more></span><p>早期的OpenGL使用立即渲染模式（Immediate mode，也就是固定渲染管线），这个模式下绘制图形很方便。OpenGL的大多数功能都被库隐藏起来，开发者很少有控制OpenGL如何进行计算的自由。而开发者迫切希望能有更多的灵活性。随着时间推移，规范越来越灵活，开发者对绘图细节有了更多的掌控。立即渲染模式确实容易使用和理解，但是效率太低。<strong>因此从OpenGL3.2开始，规范文档开始废弃立即渲染模式，并鼓励开发者在OpenGL的核心模式(Core-profile)下进行开发</strong>，这个分支的规范完全移除了旧的特性。<p>当使用OpenGL的核心模式时，OpenGL迫使我们使用现代的函数。当我们试图使用一个已废弃的函数时，OpenGL会抛出一个错误并终止绘图。现代函数的优势是更高的灵活性和效率，然而也更难于学习。立即渲染模式从OpenGL<strong>实际</strong>运作中抽象掉了很多细节，因此它在易于学习的同时，也很难让人去把握OpenGL具体是如何运作的。现代函数要求使用者真正理解OpenGL和图形编程，它有一些难度，然而提供了更多的灵活性，更高的效率，更重要的是可以更深入的理解图形编程<p>使用GLAD和GLFW作为版本和窗口管理库.<ul><li><p>glfwWindowShouldClose函数在我们每次循环的开始前检查一次GLFW是否被要求退出，如果是的话，该函数返回<code>true</code>，渲染循环将停止运行，之后我们就可以关闭应用程序。</p><li><p>glfwPollEvents函数检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调方法手动设置）。</p><li><p>glfwSwapBuffers函数会交换颜色缓冲（它是一个储存着GLFW窗口每一个像素颜色值的大缓冲），它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。</p></ul><p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，<strong>实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的</strong>。图形渲染管线可以被划分为两个主要部分：<strong>第一部分把你的3D坐标转换为2D坐标</strong>，<strong>第二部分是把2D坐标转变为实际的有颜色的像素</strong>。<p><strong>图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出</strong>。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，<strong>它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)</strong>。<p>有些着色器可以由开发者配置，因为允许用自己写的着色器来代替默认的，所以能够更细致地控制图形渲染管线中的特定部分了。因为它们运行在GPU上，所以节省了宝贵的CPU时间。<strong>OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写成的</strong><p><img style="zoom: 67%;" alt=img data-src=https://learnopengl-cn.github.io/img/01/04/pipeline.png><p><strong>图形渲染管线包含很多部分，每个部分都将在转换顶点数据到最终像素这一过程中处理各自特定的阶段</strong><p>图形渲染管线的第一个部分是<strong>顶点着色器</strong>(Vertex Shader)，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标，同时顶点着色器允许我们对顶点属性进行一些基本处理<p>顶点着色器阶段的输出可以选择性地传递给<strong>几何着色器</strong>(Geometry Shader)。几何着色器将一组顶点作为输入，<strong>这些顶点形成图元，并且能够通过发出新的顶点来形成新的(或其他)图元来生成其他形状</strong>。在这个例子中，它从给定的形状中生成第二个三角形。<blockquote><p>为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？<strong>做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP</strong>。</blockquote><p><strong>图元装配</strong>(Primitive Assembly)阶段将顶点着色器（或几何着色器）输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并将所有的点装配成指定图元的形状<p>图元装配阶段的输出会被传入光栅化阶段(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。<p>片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色<p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做Alpha测试和混合(Blending)阶段。这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同<p><strong>然而，对于大多数场合，我们只需要配置顶点和片段着色器就行了。几何着色器是可选的，通常使用它默认的着色器就行了。</strong><p>在现代OpenGL中，我们<strong>必须</strong>定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）。出于这个原因，刚开始学习现代OpenGL的时候可能会非常困难，因为在你能够渲染自己的第一个三角形之前已经需要了解一大堆知识了。在本节结束你最终渲染出你的三角形的时候，你也会了解到非常多的图形编程知识。<p>OpenGL是一个3D图形库，所以在OpenGL中我们指定的所有坐标都是3D坐标（x、y和z）。OpenGL不是简单地把<strong>所有的</strong>3D坐标变换为屏幕上的2D像素；<strong>OpenGL仅当3D坐标在3个轴（x、y和z）上-1.0到1.0的范围内时才处理它</strong>。所有在这个范围内的坐标叫做标准化设备坐标(Normalized Device Coordinates)，此范围内的坐标最终显示在屏幕上（在这个范围以外的坐标则不会显示）。<p>通常深度可以理解为z坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。<p>通过使用由glViewport函数提供的数据，进行视口变换(Viewport Transform)，标准化设备坐标(Normalized Device Coordinates)会变换为屏幕空间坐标(Screen-space Coordinates)。所得的屏幕空间坐标又会被变换为片段输入到片段着色器中。 定义这样的顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。<p>我们通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> VBO;</span><br><span class=line><span class=built_in>glGenBuffers</span>(<span class=number>1</span>, &VBO);</span><br><span class=line><span class=built_in>glBindBuffer</span>(GL_ARRAY_BUFFER, VBO); </span><br><span class=line><span class=built_in>glBufferData</span>(GL_ARRAY_BUFFER, <span class=built_in><span class=keyword>sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></table></figure><p>现在我们已经把顶点数据储存在显卡的内存中，用VBO这个顶点缓冲对象管理。下面我们会创建一个顶点着色器和片段着色器来真正处理这些数据。。<p>顶点着色器(Vertex Shader)是几个可编程着色器中的一个。如果我们打算做渲染的话，现代OpenGL需要我们至少设置一个<strong>顶点和一个片段着色器</strong>。<figure class="highlight glsl"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>#version 330 core</span></span><br><span class=line><span class=keyword>layout</span> (<span class=keyword>location</span> = <span class=number>0</span>) <span class=keyword>in</span> <span class=type>vec3</span> aPos;</span><br><span class=line></span><br><span class=line><span class=type>void</span> main()</span><br><span class=line>{</span><br><span class=line>    <span class=built_in>gl_Position</span> = <span class=type>vec4</span>(aPos.x, aPos.y, aPos.z, <span class=number>1.0</span>);</span><br><span class=line>}</span><br></pre></table></figure><p>使用<code>in</code>关键字，在顶点着色器中声明所有的输入顶点属性(Input Vertex Attribute)。现在我们只关心位置(Position)数据，所以我们只需要一个顶点属性。GLSL有一个向量数据类型，它包含1到4个<code>float</code>分量，包含的数量可以从它的后缀数字看出来<p>每个顶点都有一个3D坐标，我们就创建一个<code>vec3</code>输入变量aPos。我们同样也通过<code>layout (location = 0)</code>设定了输入变量的位置值(Location)你后面会看到为什么我们会需要这个位置值.<p>写好glsl后,首先创建一个着色器对象，注意还是用ID来引用的。所以我们储存这个顶点着色器为<code>unsigned int</code>，然后用glCreateShader创建这个着色器<h3 id=GAMES101><a class=headerlink href=#GAMES101 title=GAMES101></a>GAMES101</h3><h4 id=转换><a class=headerlink href=#转换 title=转换></a>转换</h4><p>使用homegeneous coordinates,因为<strong>Translation cannot be represented in matrix form</strong><p><img alt=image-20240512215001385 data-src=https://s2.loli.net/2024/05/12/36b2pEjwCWGf7N8.png><p><img alt=image-20240512223828687 data-src=https://s2.loli.net/2024/05/12/rA39m7M5WTFwQRD.png><p><img alt=image-20240512225758095 data-src=https://s2.loli.net/2024/05/12/OxDF2GB7sUk8iRt.png><p><img alt=image-20240512231120803 data-src=https://s2.loli.net/2024/05/12/yNZU6TEMkJw8vS5.png><p><img alt=image-20240512231103788 data-src=https://s2.loli.net/2024/05/12/LjWzDSbx2McfVpa.png><h4 id=assignment><a class=headerlink href=#assignment title=assignment></a>assignment</h4><h5 id=HW0><a class=headerlink href=#HW0 title=HW0></a>HW0</h5><p>学习Eigen库,二维和三维的空间变换,都可以拆成旋转,放缩和平移,但是平移无法使用与坐标维数相同的转换矩阵,可以通过homogeneous coordinates.<h5 id=HW1><a class=headerlink href=#HW1 title=HW1></a>HW1</h5><p>观测转换,视图和投影转换. 投影转换又可以分为正交和透视投影.<p>view transformation就是相机的摆放,包括位置,朝向和向上的方向.<p><img alt=image-20240519160531237 data-src=https://s2.loli.net/2024/05/19/yApJSIKMls4CZzF.png><p>又叫做ModelView Transformation.<p>相当于将相机连着物体一起做变换,使得相机朝着-Z,位置在原点,向上方向在Y.<p><img alt=image-20240519163320086 data-src=https://s2.loli.net/2024/05/19/U5DBHQOvcAd2wqp.png><p>一般做view transformation就是先平移后旋转.<p><img alt=image-20240519164238487 data-src=https://s2.loli.net/2024/05/19/9EodBgHcTr5J874.png><p>然后做投影,也就是将3D变为2D,先做透视再做正交. 做透视因为符合视觉系统,做正交将物体归一化并放在中心.<p><img alt=image-20240519164611669 data-src=https://s2.loli.net/2024/05/19/niHmVGBdhUIR2qv.png><p>做正交矩阵如下.<p><img alt=image-20240519164927743 data-src=https://s2.loli.net/2024/05/19/ucndILDTHwEMpmW.png><p><img alt=image-20240519164732598 data-src=https://s2.loli.net/2024/05/19/t85cSLD7JZ6Vaep.png><p>做投影如下,<p><img alt=image-20240519164510132 data-src=https://s2.loli.net/2024/05/19/Hl7XgyvkEi8Gen9.png><p>重点是关于透视矩阵的推理,首先因为等比例的坐标缩放,<p><img alt=image-20240519181537968 data-src=https://s2.loli.net/2024/05/19/Rv2IMdrlYDpk9Tq.png></p><script type="math/tex; mode=display">
\begin{pmatrix}x\\y\\z\\1\end{pmatrix}\Rightarrow\begin{pmatrix}nx/z\\ny/z\\\text{unknown}\\1\end{pmatrix}\overset{\text{mult by z}}{\operatorname*{==}}\begin{pmatrix}nx\\ny\\\text{still unknown}\\z\end{pmatrix}</script><p>这样就知道透视投影矩阵的三行信息</p><script type="math/tex; mode=display">
M_{persp\to ortho}^{(4\times4)}\begin{pmatrix}x\\y\\z\\1\end{pmatrix}=\begin{pmatrix}nx\\ny\\\text{unknown}\\z\end{pmatrix} \\
M_{persp\to ortho}=\begin{pmatrix}n&0&0&0\\0&n&0&0\\?&?&?&?\\0&0&1&0\end{pmatrix}</script><p>此外,有两点:在near plane也就是投影到的平面上的坐标经过这个矩阵转换后依然不变,而far plane上的坐标经过透视投影后z坐标不变.<p>对于near plane(x,y,n,1),由于转换后坐标相同得到(nx,ny,n^2^,n).</p><script type="math/tex; mode=display">
\begin{pmatrix}0&0&A&B\end{pmatrix}\begin{pmatrix}x\\y\\n\\1\end{pmatrix}=n^2</script><p>所以第三行的值必须是(0,0,A,B).即有An+B=n^2^.<p>假设far plane上的一个点坐标是(x,y,f,1),也有Af+B=f^2^.解得</p><script type="math/tex; mode=display">
\begin{aligned}An+B&=n^2\\Af+B&=f^2\end{aligned}\quad\begin{array}{c}A=n+f\\B=-nf\end{array}</script><p>所以透视矩阵如下,其中n是near plane上的点的z坐标,f是随便一个点的z坐标.</p><script type="math/tex; mode=display">
M_{persp\to ortho}=\begin{pmatrix}n&0&0&0\\0&n&0&0\\0&0&n+f&-nf\\0&0&1&0\end{pmatrix}</script><p>有了透视矩阵后,正交矩阵比较简单.在进行投影时先透视后正交就得到投影矩阵了. 如果有了near plane的四个点坐标就方便进行视口变换,或者通过fovY和aspect ratio,前者是一个角度,可以通过这个角度知道视点与near plane平面的距离,aspect ratio是平面宽度/高度.<p><img alt=image-20240519231541738 data-src=https://s2.loli.net/2024/05/19/N5qEdQ7yZGDzgKn.png><p><img alt=image-20240519224805373 data-src=https://s2.loli.net/2024/05/19/V6DlLH2M4jmpgXZ.png></p><script type="math/tex; mode=display">
\tan\frac{fovY}2=\frac t{|n|}\\aspect=\frac rt</script><p><img alt=image-20240519224814121 data-src=https://s2.loli.net/2024/05/19/PLHMImvQDRfVTUW.png><p>在图形学的MVP(model transformation,view transformation,project transformation)之后,得到了规范的2D投影.然后需要将规范的cube转到screen上(视口转换),screen就是一个pixel的数组,大小是分辨率.raster就是screen.<p>因为坐标已经归一到[-1,1],再转到[0,width]x[0,height],线性转换即可.z坐标不用管<p><img alt=image-20240519225110452 data-src=https://s2.loli.net/2024/05/19/vuFnfNzxKCAotEl.png><p><img alt=image-20240519225120720 data-src=https://s2.loli.net/2024/05/19/rasPKwzLBvY7SUk.png><p><img alt=image-20240524111542315 data-src=https://s2.loli.net/2024/05/24/f5SoqHvmld8UpDV.png><p>提升题<p>绕任意过原点的轴的旋转变换矩阵。<p><img alt=image-20240524171158093 data-src=https://s2.loli.net/2024/05/24/LCIpUV8lKBtJRAD.png><h5 id=HW2><a class=headerlink href=#HW2 title=HW2></a>HW2</h5><p>上面的就画出了一个线框,但是为了画出完整三角形,线框里的值还需要光栅化.首先需要判定点是否在线框内,涉及到cross products和使用bounding box. 如果在内部,还需要判断内部点的深度.如果当前点更靠近相机,设置像素颜色并更新depth buffer.<p><img alt=image-20240524213309445 data-src=https://s2.loli.net/2024/05/24/zsNxrbOg79kwHAy.png><p><img alt=image-20240524213330256 data-src=https://s2.loli.net/2024/05/24/8nHkRoxrWDL7QTK.png><p>首先bounding box比较简单,直接获得x,y的最小值最大值即可 .<p>判定点是否在三角形内,在三角形内还需要使用重心插值得到z-buffering,这里越小表示越近,如果更小就设置颜色.<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>for</span> (<span class=keyword>int</span> x = <span class=built_in>floor</span>(lb_x); x < <span class=built_in>ceil</span>(rt_x); x++) {</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> y = <span class=built_in>floor</span>(lb_y); y < <span class=built_in>ceil</span>(rt_y); y++) {</span><br><span class=line>            <span class=keyword>if</span> (<span class=built_in>insideTriangle</span>(x+<span class=number>0.5</span>, y+<span class=number>0.5</span>, t.v)) {</span><br><span class=line>                <span class=keyword>auto</span>[alpha, beta, gamma] = <span class=built_in>computeBarycentric2D</span>(x, y, t.v);</span><br><span class=line>                <span class=keyword>float</span> w_reciprocal = <span class=number>1.0</span>/(alpha / v[<span class=number>0</span>].<span class=built_in>w</span>() + beta / v[<span class=number>1</span>].<span class=built_in>w</span>() + gamma / v[<span class=number>2</span>].<span class=built_in>w</span>());</span><br><span class=line>                <span class=keyword>float</span> z_interpolated = alpha * v[<span class=number>0</span>].<span class=built_in>z</span>() / v[<span class=number>0</span>].<span class=built_in>w</span>() + beta * v[<span class=number>1</span>].<span class=built_in>z</span>() / v[<span class=number>1</span>].<span class=built_in>w</span>() + gamma * v[<span class=number>2</span>].<span class=built_in>z</span>() / v[<span class=number>2</span>].<span class=built_in>w</span>();</span><br><span class=line>                z_interpolated *= w_reciprocal;</span><br><span class=line>                <span class=keyword>int</span> index = <span class=built_in>get_index</span>(x, y);</span><br><span class=line>                <span class=keyword>if</span> (z_interpolated < depth_buf[index]) {</span><br><span class=line>                    depth_buf[index] = z_interpolated;</span><br><span class=line>                    <span class=built_in>set_pixel</span>(<span class=built_in>Vector3f</span>(x, y, <span class=number>1.0f</span>), t.<span class=built_in>getColor</span>());</span><br><span class=line></span><br><span class=line>                }</span><br><span class=line></span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br></pre></table></figure><p><img alt=image-20240524175457757 data-src=https://s2.loli.net/2024/05/24/HT3ogl5RuJWtbLz.png><p><img alt=image-20240524202223373 data-src=https://s2.loli.net/2024/05/24/xp6UaqQC7lscWmV.png style=zoom:50%;><p>为了解决锯齿问题(antialiasing),可以先进行卷积,也可以进行supersamping,这里使用super-samping,对每个像素进行2x2采样.<p>方法是<ol><li>Take NxN samples in each pixel.<li>Average the NxN samples “inside” each pixel</ol><p>具体做的时候针对每个pixel,需要保存两个 sample list里面存着周围几个元素的颜色与depth. 然后算color的均值.<p>super-sampling时,会对一个像素结合多个强度(颜色),也就是均值.采样的值太大图像会变糊.<p><img alt=image-20240524212850965 data-src=https://s2.loli.net/2024/05/24/IXzWOyn49Y5JpVE.png><h5 id=HW3><a class=headerlink href=#HW3 title=HW3></a>HW3</h5><p>之前涉及到了MVP,视口转换以及Raster、=-Z-buffer. 现在到了shading<p>Shading:The process of applying a material to an object.The darkening or coloring of an illustration or diagram with parallel lines or a block of color<p>这里Shading介绍了Blinn-Phong反射模型,包括漫反射,高光反射和环境光.<p><img alt=image-20240525212040023 data-src=https://s2.loli.net/2024/05/25/3ZsDz6MlRxehIfP.png><p><img alt=image-20240524220535971 data-src=https://s2.loli.net/2024/05/24/elFT8BIydC3XLEw.png><p><strong>漫反射</strong><p><img alt=image-20240524215603681 data-src=https://s2.loli.net/2024/05/24/PIprAbJe1HD9SvE.png>与看的方向无关,与距离和入射角度有关. kd对漫反射影响如下.<p><img alt=image-20240524221426912 data-src=https://s2.loli.net/2024/05/24/3fKa4mPENFXgz9o.png><p><strong>高光反射</strong><p><img alt=image-20240524220408626 data-src=https://s2.loli.net/2024/05/24/LpxJqyRU2u7rd19.png><p>与看的角度有关,角度跟入射角相等时最大.<p><img alt=image-20240524220506998 data-src=https://s2.loli.net/2024/05/24/oFExtZaYjLsqD7I.png><p>半程向量就是以l和v向量为边的中线,而p叫做cosine power plots,越大相同角度下越小.<p>ks和p对高光反射影响如下<p><img alt=image-20240524221457998 data-src=https://s2.loli.net/2024/05/24/i47jFfRGB3t9Lx8.png><p><strong>环境光</strong><p><img alt=image-20240524221924122 data-src=https://s2.loli.net/2024/05/24/XnR9HyYvdjcSpox.png><p>不依赖于任何东西,相当于加点环境噪音<p>所以最后在Blinn-Phong反射模型中,着色如下<p><img alt=image-20240524222152219 data-src=https://s2.loli.net/2024/05/24/QhGcYsCd1ny8e3D.png><p>此外shading还跟着色频率有关,分为三种类型,包括flat shading,gouraud shading,Phong shading<p><strong>flat shading</strong><ul><li>Triangle face is flat — one normal vector<li>Not good for smooth surfaces</ul><p>对于每个三角形做shading,每个三角形就一个normal vector<p><strong>gouraud shading</strong><ul><li>Interpolate colors from vertices across triangle<li>Each vertex has a normal vector</ul><p>对于每个vertex做,每个vertex搞出来一个normal vector.<p><strong>Phong shading</strong><ul><li>Interpolate normal vectors across each triangle<li>Compute full shading model at each pixel</ul><p>对于每个pixel做.<p><img alt=image-20240524230245562 data-src=https://s2.loli.net/2024/05/24/PpGrA8hL17vcmBF.png><p><strong>重心插值</strong><p><img alt=image-20240524230332105 data-src=https://s2.loli.net/2024/05/24/SMDGjIbdVWiUFYa.png><p><img alt=image-20240525114414968 data-src=https://s2.loli.net/2024/05/25/YLGaUhMpVnyrTSE.png><p><img alt=image-20240525200857191 data-src=https://s2.loli.net/2024/05/25/39j5Q6aWqIZr87X.png><p>重心坐标系是指平面上任意一点可以用三角形的三个顶点的坐标的线性组合表示,其中三个系数的和为1。<p><strong>Texture mapping</strong><p>apply textures = sampling<p><img alt=image-20240525134129545 data-src=https://s2.loli.net/2024/05/25/ZwzPhiv72LuEHJp.png><p>应用texture的方法,对于每个screen的点,得到对应的texture coords(u,v)然后sample出一个颜色,设置这个颜色为点的颜色,常作为漫反射的系数kd<p><img alt=image-20240525114612818 data-src=https://s2.loli.net/2024/05/25/D5L4jirsAwNCfI7.png><p>每个vertex rasterize之后坐标与贴图上某个坐标对应<p><img alt=image-20240525112721794 data-src=https://s2.loli.net/2024/05/25/R8Uj61yvnXmoIbc.png><p><img alt=image-20240525112703661 data-src=https://s2.loli.net/2024/05/25/ysCe1ApBbnlkqZR.png><p><strong>Texture magnification</strong><blockquote><p>当纹理图像的分辨率低于显示屏上需要的分辨率时，就会出现纹理放大的情况。例如，当你将一个小纹理贴图拉伸到一个较大的表面上时，就会遇到纹理放大。这个过程需要决定如何在纹理中插值以生成更多的像素</blockquote><p>如果texture分辨率太小的解决方法.<p>放大纹理时常用的插值方法有：<ol><li><strong>最近邻插值（Nearest Neighbor Interpolation）</strong>：这种方法简单高效，但通常会产生锯齿状的边缘，因为它只是选择最接近的纹理像素。<li><strong>双线性插值（Bilinear Interpolation）</strong>：这种方法通过对周围的四个纹理像素进行加权平均，可以生成较为平滑的结果。<li><strong>三线性插值（Trilinear Interpolation）</strong>：在双线性插值的基础上，加入了对不同MIP贴图层次的线性插值，以进一步提高质量。</ol><p><img alt=image-20240525115208103 data-src=https://s2.loli.net/2024/05/25/OWIxDR7yqBC5uen.png><p><img alt=image-20240525124210774 data-src=https://s2.loli.net/2024/05/25/YhmLPEoxGZjJ7wn.png><p><img alt=image-20240525131324085 data-src=https://s2.loli.net/2024/05/25/Tm2kfgzHxyO1b5S.png><p>如果texture太大,需要将多个texel取均值分给一个pixel.<p><img alt=image-20240525141722341 data-src=https://s2.loli.net/2024/05/25/XkthROUmr3TzDaq.png><p><strong>Texture minification</strong><blockquote><p>纹理缩小发生在纹理图像的分辨率高于显示屏上需要的分辨率时。例如，当你将一个大纹理贴图缩小到一个较小的表面上时，就会遇到纹理缩小。这个过程需要决定如何对纹理进行采样，以避免混叠效应（aliasing）</blockquote><p>缩小纹理时常用的方法有：<ol><li><strong>MIP贴图（Mipmapping）</strong>：这是最常用的方法，它预先生成一系列缩小分辨率的纹理图像（MIP层），在渲染时根据需要选择合适的层进行采样，以减少混叠效应。MIP贴图通常与三线性插值结合使用。<li><strong>各向异性过滤（Anisotropic Filtering）</strong>：在MIP贴图的基础上，这种方法进一步提高了纹理在不同角度下的清晰度，特别是在视角较大时效果明显。</ol><p><strong>Mipmap</strong><p>mipmap是一种多级纹理映射技术.它通过预先生成并存储一系列逐渐降低分辨率的纹理图像来实现.每个降低分辨率的纹理图像称为一个MIP层<p><img alt=image-20240525145752235 data-src=https://s2.loli.net/2024/05/25/vVYOIxGN6bmPuow.png><p><img alt=image-20240525152604833 data-src=https://s2.loli.net/2024/05/25/UIFbenyzPNkY782.png><p>将得到的D四舍五入<p>在mipmap上再进行插值,<p><img alt=image-20240525152427773 data-src=https://s2.loli.net/2024/05/25/M6kJeFrKCiPWYd9.png><p>作业要求实现normal_fragment_shader,利用了(法向量+1)/2作为颜色.还有Blinn-Phong反射模型,以及纹理.<p><strong>normal_fragment_shader</strong>比较简单,直接穿法向量即可.<p><strong>Blinn-Phong反射模型</strong>按照公式写即可.<p>纹理模型主要需要使用对应uv位置的颜色,将原本使用的颜色替换用来算diffuse light.<p>实现纹理时可以考虑texture magnification的双线性插值,以及minification的mipmap.<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=function>Eigen::Vector3f <span class=title>getColorBilinear</span><span class=params>(<span class=keyword>float</span> u, <span class=keyword>float</span> v)</span> </span>{</span><br><span class=line>  <span class=keyword>auto</span> u_img = u * width;</span><br><span class=line>  <span class=keyword>auto</span> v_img = (<span class=number>1</span> - v) * height;</span><br><span class=line>  <span class=keyword>float</span> v11 = <span class=built_in>ceil</span>(v_img);</span><br><span class=line>  <span class=keyword>float</span> v01 = <span class=built_in>floor</span>(v_img);</span><br><span class=line></span><br><span class=line>  <span class=keyword>float</span> u01 = <span class=built_in>floor</span>(u_img);</span><br><span class=line>  <span class=keyword>float</span> u11 = <span class=built_in>ceil</span>(u_img);</span><br><span class=line></span><br><span class=line>  <span class=keyword>auto</span> rightBottomColor = image_data.at&LTcv::Vec3b>(v01, u11);</span><br><span class=line>  <span class=keyword>auto</span> leftBottomColor = image_data.at&LTcv::Vec3b>(v01, u01);</span><br><span class=line>  <span class=keyword>auto</span> rightTopColor = image_data.at&LTcv::Vec3b>(v11, u11);</span><br><span class=line>  <span class=keyword>auto</span> leftTopColor = image_data.at&LTcv::Vec3b>(v11, u01);</span><br><span class=line>  <span class=keyword>float</span> s = (u_img - u01) / (u11 - u01);</span><br><span class=line>  <span class=keyword>float</span> t = (v_img - v01) / (v11 - v01);</span><br><span class=line>  <span class=keyword>auto</span> topColor = leftTopColor + s * (rightTopColor - leftTopColor);</span><br><span class=line>  <span class=keyword>auto</span> bottomColor =</span><br><span class=line>      leftBottomColor + s * (rightBottomColor - leftBottomColor);</span><br><span class=line>  <span class=keyword>auto</span> final_color = bottomColor + t * (topColor - bottomColor);</span><br><span class=line>  <span class=keyword>return</span> Eigen::<span class=built_in>Vector3f</span>(final_color[<span class=number>0</span>], final_color[<span class=number>1</span>], final_color[<span class=number>2</span>]);</span><br><span class=line>}</span><br></pre></table></figure><p>进阶方法包括Bump mapping,有了凹凸效果,还有displacement mapping.<p><img alt=image-20240526161155111 data-src=https://s2.loli.net/2024/05/26/hAqye8oJLWr2RI3.png><p>Bump mapping算法<h5 id=HW4><a class=headerlink href=#HW4 title=HW4></a><img alt=image-20240526164218979 data-src=https://s2.loli.net/2024/05/26/GEkQeCXYNxbMqJ7.png>HW4</h5><p>Geometry 表示几何形状的几种方法,包括显示和隐式.<p><img alt=image-20240526193619807 data-src=https://s2.loli.net/2024/05/26/sYHdUhBcTq5tw17.png><p>隐式描述优点:<ul><li>描述简洁（如函数）<li>便于某些查询（物体内部、与表面的距离）<li>适用于射线与曲面的交叉（稍后详述）<li>对于简单形状，可精确描述/无采样误差<li>易于处理拓扑结构的变化（如流体</ul><p>缺点<ul><li>难以模拟复杂形状</ul><p>显示模型包括点云,多边形网格(polygon mesh),<p>点云<ul><li>最简单的表示方法：点列表（x,y,z）<li>可轻松表示任何几何图形<li>适用于大型数据集（>>1 点/像素）<li>通常转换为多边形网格<li>难以绘制采样不足的区域</ul><p>多边形网格<ul><li>存储顶点和多边形（通常为三角形或四边形）<li>更易于处理/模拟、自适应采样<li>数据结构更复杂<li>可能是图形中最常见的表示法</ul><p><strong>曲线</strong><p>Bézier Curves<p><img alt=image-20240526213851885 data-src=https://s2.loli.net/2024/05/26/rhK4ZOqMtGzNu2X.png style=zoom:67%;><p>还有cubic贝塞尔曲线,其实就是order更高.<p>这些曲线都可以归结为多项式.de Casteljau算法<p><img alt=image-20240526220606516 data-src=https://s2.loli.net/2024/05/26/O8xQhoubFZafzD9.png style=zoom:50%;><p><img alt=image-20240526221101195 data-src=https://s2.loli.net/2024/05/26/t6yMUePEfpdZ25w.png><p><img alt=image-20240528205956947 data-src=https://s2.loli.net/2024/05/28/FdiBq6fVnyUm7wg.png><p>贝塞尔曲线特点<p>内插端点<br>与端点相切<br>仿射变换特性<ul><li>通过变换控制点来变换曲线<br>convex hull property<li>曲线位于控制点的凸边内</ul><p>利用Piecewise Bézier Curves,将连续的低阶贝塞尔曲线连在一起.<p>曲线除了贝塞尔曲线,还有splines和B-splines.<p><strong>Bézier Surfaces</strong><p><img alt=image-20240526225234591 data-src=https://s2.loli.net/2024/05/26/bISzRwqsTp3BhAj.png style=zoom:50%;><p><img alt=image-20240526230516215 data-src=https://s2.loli.net/2024/05/26/93tqJlgfBMupFIC.png><p><strong>Mesh</strong><p>对mesh的操作包括subdivision,simplification以及regularization.<p>subdivision就是将三角形split然后根据一些权重重新分配三角形位置.<p>此外还有catmull-clark subdivison.<p>simplification<p><img alt=image-20240526231621354 data-src=https://s2.loli.net/2024/05/26/HvDeG2loYQ6E4Kf.png><p>shadow mapping<p>不在阴影中的点必须同时被灯光和摄像机看到<p>作业就是画贝塞尔曲线并反走样.通过[0,1]的t值确定曲线点。naive的方法就是使用多项式直接算,更好的方法是,根据四个点反复的插值得到曲线点. 反走样就是antialiasing,将曲线点的附近点的值赋值,可以根据距离.<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br></pre><td class=code><pre><span class=line><span class=function>cv::Point2f <span class=title>recursive_bezier</span><span class=params>(<span class=keyword>const</span> std::vector&LTcv::Point2f> &control_points,</span></span></span><br><span class=line><span class=params><span class=function>                             <span class=keyword>float</span> t)</span> </span>{</span><br><span class=line>  <span class=comment>// <span class=doctag>TODO:</span> Implement de Casteljau's algorithm</span></span><br><span class=line>  <span class=comment>// 首先，将相邻的点连接起来以形成线段</span></span><br><span class=line>  <span class=keyword>if</span> (control_points.<span class=built_in>size</span>() == <span class=number>1</span>) {</span><br><span class=line>    <span class=keyword>return</span> control_points[<span class=number>0</span>];</span><br><span class=line>  }</span><br><span class=line>  std::vector&LTcv::Point2f> points;</span><br><span class=line>  <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < control_points.<span class=built_in>size</span>() - <span class=number>1</span>; i++) {</span><br><span class=line>    <span class=keyword>auto</span> point = t * control_points[i] + (<span class=number>1</span> - t) * control_points[i + <span class=number>1</span>];</span><br><span class=line>    points.<span class=built_in>push_back</span>(point);</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>return</span> <span class=built_in>recursive_bezier</span>(points, t);</span><br><span class=line>  <span class=comment>//  用 t : (1 − t) 的比例细分每个线段，并找到该分割点</span></span><br><span class=line></span><br><span class=line>  <span class=comment>// 得到的分割点作为新的控制点序列，新序列的长度会减少一。</span></span><br><span class=line>  <span class=comment>// 如果序列只包含一个点，则返回该点并终止。否则，使用新的控制点序列并</span></span><br><span class=line>  <span class=comment>// 转到步骤 1。</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>bezier</span><span class=params>(<span class=keyword>const</span> std::vector&LTcv::Point2f> &control_points, cv::Mat &window)</span> </span>{</span><br><span class=line>  <span class=comment>// <span class=doctag>TODO:</span> Iterate through all t = 0 to t = 1 with small steps, and call de</span></span><br><span class=line>  <span class=comment>// Casteljau's recursive Bezier algorithm.</span></span><br><span class=line>  <span class=keyword>float</span> max_dist = <span class=number>1.5f</span> * <span class=built_in>sqrt</span>(<span class=number>2</span>);</span><br><span class=line>  <span class=keyword>for</span> (<span class=keyword>float</span> t = <span class=number>0</span>; t <= <span class=number>1.0f</span>; t += <span class=number>0.001</span>) {</span><br><span class=line>    <span class=keyword>auto</span> point = <span class=built_in>recursive_bezier</span>(control_points, t);</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=built_in>round</span>(point.x) - <span class=number>1</span>; i < <span class=built_in>round</span>(point.x) + <span class=number>2</span>; i++) {</span><br><span class=line>      <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=built_in>round</span>(point.y) - <span class=number>1</span>; j < <span class=built_in>round</span>(point.y) + <span class=number>2</span>; j++) {</span><br><span class=line>        <span class=keyword>auto</span> samplePoint = cv::<span class=built_in>Point2f</span>(i, j);</span><br><span class=line>        <span class=keyword>float</span> d = cv::<span class=built_in>norm</span>(samplePoint - point);</span><br><span class=line>        <span class=keyword>float</span> color = <span class=number>255.0f</span> * (<span class=number>1</span> - d / max_dist);</span><br><span class=line>        window.at&LTcv::Vec3b>(samplePoint.y, samplePoint.x)[<span class=number>2</span>] =</span><br><span class=line>            std::<span class=built_in>max</span>(window.at&LTcv::Vec3b>(samplePoint.y, samplePoint.x)[<span class=number>2</span>],</span><br><span class=line>                     (uchar)color);</span><br><span class=line>      }</span><br><span class=line>      <span class=comment>// window.at&LTcv::Vec3b>(point.y, point.x)[1] = 255;</span></span><br><span class=line>    }</span><br><span class=line>  }</span><br><span class=line>}</span><br></pre></table></figure><h5 id=HW5><a class=headerlink href=#HW5 title=HW5></a>HW5</h5><p>走过了Rasterization和Geometry,终于到了也令人激动的Ray tracing.<p>在计算机图形学渲染中,我们通常会模拟Light Rays的传播过程,以计算光照效果。主要方法包括:<ol><li>光线追踪(Ray Tracing): 从观察者视角发射光线,模拟其在场景中的传播过程。<li>光栅化(Rasterization): 直接计算每个像素的颜色,不追踪光线的具体传播过程。<li>辐射度函数(Radiance Function): 利用数学模型描述Light Rays在空间中的传播特性。</ol><p>光栅化的缺点:不能处理全局的效果,光反射会超过一次.<p>Ray tracing is accurate, but is very slow<p>Ray-Tracing的算法<p><strong>Light Rays</strong><p>Light Rays的主要特点如下:<ol><li>传播方向: Light Rays沿直线传播,遵循光线传播的直线性质。<li>强度衰减: Light Rays的强度随着传播距离的增加而衰减,遵循逆平方定律。<li>反射和折射: 当Light Rays遇到物体表面时,可能会发生反射或折射,遵循光学定律。</ol><p><img alt=image-20240528211704213 data-src=https://s2.loli.net/2024/05/28/DRq8BcZVJI9OeaM.png><p><strong>Ray Casting</strong><p><img alt=image-20240528212212368 data-src=https://s2.loli.net/2024/05/28/SjqaQ59pxYfIH2E.png><p><img alt=image-20240528212339608 data-src=https://s2.loli.net/2024/05/28/IZsbODHYcXngwt6.png><p>Shadow Rays是光线追踪算法中一个非常重要的技术,它用于计算物体在三维场景中投射出的阴影.<p><img alt=image-20240528213753449 data-src=https://s2.loli.net/2024/05/28/EI7yp4GToHrVsXb.png><p>在光线追踪渲染过程中,<strong>当一条光线与场景中的物体发生相交时,通常需要判断该点是否位于阴影中。为此,我们会发射一条从交点出发指向光源的shadow ray.</strong><p>如果这条shadow ray在到达光源之前与任何其他物体相交,那么该交点就位于阴影中.<p><strong>Ray-Surface Intersection</strong><p>Ray is defined by its origin and a direction vector<p><img alt=image-20240528213710912 data-src=https://s2.loli.net/2024/05/28/bZOxpmvrok3MQeV.png style=zoom:67%;><p><img alt=image-20240528213858434 data-src=https://s2.loli.net/2024/05/28/jltgudeDTN9mQzs.png><p><img alt=image-20240528214148744 data-src=https://s2.loli.net/2024/05/28/mR8edIxybTEYkBU.png><p>与隐式表示的surface相交的ray计算.<p><img alt=image-20240528214431784 data-src=https://s2.loli.net/2024/05/28/qL38YXn9dE1WiUK.png><p>与三角形mesh交叉<p><img alt=image-20240528214803254 data-src=https://s2.loli.net/2024/05/28/o51pJvBfFK9zDeZ.png><p>简单的想法是让ray与每一个triangle交叉,ray-plane交叉,看点是否在三角形内部.<p>平面由法向量和面上的一个点定义.<p><img alt=image-20240528215109831 data-src=https://s2.loli.net/2024/05/28/EAhgOXmBbc2l5yW.png><p><img alt=image-20240528215650898 data-src=https://s2.loli.net/2024/05/28/e1MHiZQhqJW4jow.png><p><strong>Möller Trumbore Algorithm</strong><p><img alt=image-20240528220838253 data-src=https://s2.loli.net/2024/05/28/yGVeQkYPOg3j6zs.png><p><strong>Bounding Volumes</strong><p>使用这东西来看有没有相交.<p><strong>box is the intersection of 3 pairs of slabs</strong><p><img alt=image-20240528222129198 data-src=https://s2.loli.net/2024/05/28/Rgu7eK4kMxSHI2L.png><p>这样做的好处<p>简单的光线-场景交点求解<ul><li>穷尽地测试每个三角形与光线的交点<li>找到最近的交点(即最小的t值)</ul><p>问题:<ul><li>朴素算法 = #像素 ⨉ # 三角形 (⨉ #反射次数)<li>非常慢!</ul><p>快速避免交点的方法:<strong>用简单的体积包围复杂物体</strong><ul><li>物体完全包含在该体积中<li>如果光线没有击中该体积,就不会击中该物体<li>所以先测试包围体积,如果击中了,再测试物体本身</ul><p><img alt=image-20240528230330356 data-src=https://s2.loli.net/2024/05/28/L235usfSm9aliGZ.png><p>Render的方法,其实就是坐标系的一个变换以及castRay算反射以及阴影等.<p>计算Render的过程:<ol><li>首先需要使用帧的尺寸来对像素位置进行归一化。<li>归一化后的像素坐标被称为NDC空间(Normalized Device Coordinates)。<li>在将像素坐标转换到NDC空间时,我们需要在原始坐标上加上0.5的偏移量。这是为了确保最终的相机光线穿过像素的中心。<li>NDC空间中的像素坐标范围是[0, 1]。这与光栅化领域中NDC空间的范围[-1, 1]不同。<li>由于成像平面是以世界坐标系的原点为中心的,因此我们需要进一步将[0, 1]范围的NDC坐标映射到[-1, 1]的范围内。这样做可以确保左侧像素有负的x坐标,右侧像素有正的x坐标,上面的像素有正的y坐标,下面的像素有负的y坐标。<li>当图像的长宽比不是1:1时,我们需要考虑图像的宽高比。<li>对于一个7x5像素的图像,宽高比是1.4。<li>在屏幕空间(NDC空间)中,像素坐标范围仍然是[-1, 1]。但由于横向有更多像素,所以像素会被拉伸变形。<li>为了让像素保持正方形,我们需要将x坐标乘以图像的宽高比1.4。这样可以将x坐标范围拉伸到[-1.4, 1.4]。<li>这个操作不会影响y坐标,它仍然在[-1, 1]范围内。</ol><p>rayTriangleIntersect判断是否相交以及是否在三角形内部,公式如下:<p><img alt=image-20240531232626151 data-src=https://s2.loli.net/2024/05/31/elBK7zRus5wXCE4.png><h5 id=HW6><a class=headerlink href=#HW6 title=HW6></a>HW6</h5><p>主要是为了加速ray-tracing的rayTriangle intersection. 进行分割.<p>包括uniform grid和spatial partitions,前者就是均匀分块,后者包括Oct-Tree,KD-Tree,BSP-Tree多种,还有Bounding Volume Hierarchy的方法.<p><img alt=image-20240601202540887 data-src=https://s2.loli.net/2024/06/01/PYjBZp936Kq2QVl.png><p><img alt=image-20240601174238696 data-src=https://s2.loli.net/2024/06/01/8D2tV9AEnzIh3mH.png><p><img alt=image-20240601174248719 data-src=https://s2.loli.net/2024/06/01/WCjEBS4LIXgKYhk.png><p><img alt=image-20240601174312126 data-src=https://s2.loli.net/2024/06/01/nDaNxQ2GTb3iUfW.png><p><img alt=image-20240601174320918 data-src=https://s2.loli.net/2024/06/01/ZCQs6uEma59rGJx.png><p><img alt=image-20240601174336245 data-src=https://s2.loli.net/2024/06/01/cBWnDoLRqmEM1rs.png><p>确定ray是否与AABB相交<p><img alt=image-20240601224405331 data-src=https://s2.loli.net/2024/06/01/F6riHxW9OvYPB52.png style=zoom:50%;><p>再确定ray是否与三角形相交,与上一次作业类似.在判断,判断是否与box相交,不相交则没有交点,如果相交,看是否是叶子节点,如果是叶子节点,看是否与其中的object相交,如果不是在分别判断.<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=function>Intersection <span class=title>BVHAccel::getIntersection</span><span class=params>(BVHBuildNode* node,</span></span></span><br><span class=line><span class=params><span class=function>                                       <span class=keyword>const</span> Ray& ray)</span> <span class=keyword>const</span> </span>{</span><br><span class=line>  <span class=comment>// TODO Traverse the BVH to find intersection</span></span><br><span class=line>  Intersection isect;</span><br><span class=line>  <span class=keyword>if</span> (!node || !node->bounds.<span class=built_in>IntersectP</span>(ray, ray.direction_inv, {<span class=number>0</span>, <span class=number>0</span>, <span class=number>0</span>})) {</span><br><span class=line>    <span class=keyword>return</span> isect;</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>if</span> (node->left == <span class=literal>nullptr</span> && node->right == <span class=literal>nullptr</span>) {</span><br><span class=line>    <span class=keyword>return</span> node->object-><span class=built_in>getIntersection</span>(ray);</span><br><span class=line>  }</span><br><span class=line>  Intersection left = <span class=built_in>getIntersection</span>(node->left, ray);</span><br><span class=line>  Intersection right = <span class=built_in>getIntersection</span>(node->right, ray);</span><br><span class=line>  <span class=keyword>if</span> (left.distance < right.distance) {</span><br><span class=line>    <span class=keyword>return</span> left;</span><br><span class=line>  } <span class=keyword>else</span> {</span><br><span class=line>    <span class=keyword>return</span> right;</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>return</span> isect;</span><br><span class=line>}</span><br></pre></table></figure><p>BVH的构造如下<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line>BVHAccel::<span class=built_in>BVHAccel</span>(std::vector&LTObject*> p, <span class=keyword>int</span> maxPrimsInNode,</span><br><span class=line>                   SplitMethod splitMethod)</span><br><span class=line>    : <span class=built_in>maxPrimsInNode</span>(std::<span class=built_in>min</span>(<span class=number>255</span>, maxPrimsInNode)),</span><br><span class=line>      <span class=built_in>splitMethod</span>(splitMethod),</span><br><span class=line>      <span class=built_in>primitives</span>(std::<span class=built_in>move</span>(p)) {</span><br><span class=line>  <span class=keyword>time_t</span> start, stop;</span><br><span class=line>  <span class=built_in>time</span>(&start);</span><br><span class=line>  <span class=keyword>if</span> (primitives.<span class=built_in>empty</span>()) <span class=keyword>return</span>;</span><br><span class=line></span><br><span class=line>  root = <span class=built_in>recursiveBuild</span>(primitives);</span><br><span class=line></span><br><span class=line>  <span class=built_in>time</span>(&stop);</span><br><span class=line>  <span class=keyword>double</span> diff = <span class=built_in>difftime</span>(stop, start);</span><br><span class=line>  <span class=keyword>int</span> hrs = (<span class=keyword>int</span>)diff / <span class=number>3600</span>;</span><br><span class=line>  <span class=keyword>int</span> mins = ((<span class=keyword>int</span>)diff / <span class=number>60</span>) - (hrs * <span class=number>60</span>);</span><br><span class=line>  <span class=keyword>int</span> secs = (<span class=keyword>int</span>)diff - (hrs * <span class=number>3600</span>) - (mins * <span class=number>60</span>);</span><br><span class=line></span><br><span class=line>  <span class=built_in>printf</span>(</span><br><span class=line>      <span class=string>"\rBVH Generation complete: \nTime Taken: %i hrs, %i mins, %i secs\n\n"</span>,</span><br><span class=line>      hrs, mins, secs);</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br></pre><td class=code><pre><span class=line><span class=function>BVHBuildNode* <span class=title>BVHAccel::recursiveBuild</span><span class=params>(std::vector&LTObject*> objects)</span> </span>{</span><br><span class=line>  BVHBuildNode* node = <span class=keyword>new</span> <span class=built_in>BVHBuildNode</span>();</span><br><span class=line></span><br><span class=line>  <span class=comment>// Compute bounds of all primitives in BVH node</span></span><br><span class=line>  Bounds3 bounds;</span><br><span class=line>  <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < objects.<span class=built_in>size</span>(); ++i)</span><br><span class=line>    bounds = <span class=built_in>Union</span>(bounds, objects[i]-><span class=built_in>getBounds</span>());</span><br><span class=line>  <span class=keyword>if</span> (objects.<span class=built_in>size</span>() == <span class=number>1</span>) {</span><br><span class=line>    <span class=comment>// Create leaf _BVHBuildNode_</span></span><br><span class=line>    node->bounds = objects[<span class=number>0</span>]-><span class=built_in>getBounds</span>();</span><br><span class=line>    node->object = objects[<span class=number>0</span>];</span><br><span class=line>    node->left = <span class=literal>nullptr</span>;</span><br><span class=line>    node->right = <span class=literal>nullptr</span>;</span><br><span class=line>    <span class=keyword>return</span> node;</span><br><span class=line>  } <span class=keyword>else</span> <span class=keyword>if</span> (objects.<span class=built_in>size</span>() == <span class=number>2</span>) {</span><br><span class=line>    node->left = <span class=built_in>recursiveBuild</span>(std::vector{objects[<span class=number>0</span>]});</span><br><span class=line>    node->right = <span class=built_in>recursiveBuild</span>(std::vector{objects[<span class=number>1</span>]});</span><br><span class=line></span><br><span class=line>    node->bounds = <span class=built_in>Union</span>(node->left->bounds, node->right->bounds);</span><br><span class=line>    <span class=keyword>return</span> node;</span><br><span class=line>  } <span class=keyword>else</span> {</span><br><span class=line>    Bounds3 centroidBounds;</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < objects.<span class=built_in>size</span>(); ++i)</span><br><span class=line>      centroidBounds =</span><br><span class=line>          <span class=built_in>Union</span>(centroidBounds, objects[i]-><span class=built_in>getBounds</span>().<span class=built_in>Centroid</span>());</span><br><span class=line>    <span class=keyword>int</span> dim = centroidBounds.<span class=built_in>maxExtent</span>();</span><br><span class=line>    <span class=built_in><span class=keyword>switch</span></span> (dim) {</span><br><span class=line>      <span class=keyword>case</span> <span class=number>0</span>:</span><br><span class=line>        std::<span class=built_in>sort</span>(objects.<span class=built_in>begin</span>(), objects.<span class=built_in>end</span>(), [](<span class=keyword>auto</span> f1, <span class=keyword>auto</span> f2) {</span><br><span class=line>          <span class=keyword>return</span> f1-><span class=built_in>getBounds</span>().<span class=built_in>Centroid</span>().x < f2-><span class=built_in>getBounds</span>().<span class=built_in>Centroid</span>().x;</span><br><span class=line>        });</span><br><span class=line>        <span class=keyword>break</span>;</span><br><span class=line>      <span class=keyword>case</span> <span class=number>1</span>:</span><br><span class=line>        std::<span class=built_in>sort</span>(objects.<span class=built_in>begin</span>(), objects.<span class=built_in>end</span>(), [](<span class=keyword>auto</span> f1, <span class=keyword>auto</span> f2) {</span><br><span class=line>          <span class=keyword>return</span> f1-><span class=built_in>getBounds</span>().<span class=built_in>Centroid</span>().y < f2-><span class=built_in>getBounds</span>().<span class=built_in>Centroid</span>().y;</span><br><span class=line>        });</span><br><span class=line>        <span class=keyword>break</span>;</span><br><span class=line>      <span class=keyword>case</span> <span class=number>2</span>:</span><br><span class=line>        std::<span class=built_in>sort</span>(objects.<span class=built_in>begin</span>(), objects.<span class=built_in>end</span>(), [](<span class=keyword>auto</span> f1, <span class=keyword>auto</span> f2) {</span><br><span class=line>          <span class=keyword>return</span> f1-><span class=built_in>getBounds</span>().<span class=built_in>Centroid</span>().z < f2-><span class=built_in>getBounds</span>().<span class=built_in>Centroid</span>().z;</span><br><span class=line>        });</span><br><span class=line>        <span class=keyword>break</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>auto</span> beginning = objects.<span class=built_in>begin</span>();</span><br><span class=line>    <span class=keyword>auto</span> middling = objects.<span class=built_in>begin</span>() + (objects.<span class=built_in>size</span>() / <span class=number>2</span>);</span><br><span class=line>    <span class=keyword>auto</span> ending = objects.<span class=built_in>end</span>();</span><br><span class=line></span><br><span class=line>    <span class=keyword>auto</span> leftshapes = std::vector&LTObject*>(beginning, middling);</span><br><span class=line>    <span class=keyword>auto</span> rightshapes = std::vector&LTObject*>(middling, ending);</span><br><span class=line></span><br><span class=line>    <span class=built_in>assert</span>(objects.<span class=built_in>size</span>() == (leftshapes.<span class=built_in>size</span>() + rightshapes.<span class=built_in>size</span>()));</span><br><span class=line></span><br><span class=line>    node->left = <span class=built_in>recursiveBuild</span>(leftshapes);</span><br><span class=line>    node->right = <span class=built_in>recursiveBuild</span>(rightshapes);</span><br><span class=line></span><br><span class=line>    node->bounds = <span class=built_in>Union</span>(node->left->bounds, node->right->bounds);</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=keyword>return</span> node;</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><p>上面是BVH,再看SAH.<p><img alt=image-20240601230318319 data-src=https://s2.loli.net/2024/06/01/kQfWdLwKM8JEAO6.png><p><img alt=image-20240601225049873 data-src=https://s2.loli.net/2024/06/01/SdR4eM9Lzmqx83u.png><p><img alt=image-20240601230545159 data-src=https://s2.loli.net/2024/06/01/dEh2QYDNBZq4Gmw.png><p><img alt=image-20240601230754416 data-src=https://s2.loli.net/2024/06/01/Lt8SdEIrph3s7wC.png><h5 id=HW7><a class=headerlink href=#HW7 title=HW7></a>HW7</h5><p><strong>radiometry</strong><p>Radiant flux, intensity, irradiance, radiance<p><strong>辐射能</strong>(Radiant energy)是电磁 辐射能。它以焦耳为单位<p>Q [J = Joule]<p><strong>辐射通量</strong>（功率）是单位时间内发射、反射、传输或接收的能量、<br>单位时间内反射、传输或接收的能量</p><script type="math/tex; mode=display">
\Phi\equiv\frac{\mathrm{d}Q}{\mathrm{d}t}\text{ [W=Watt] [lm=lumen]}</script><p><img alt=image-20240602161533270 data-src=https://s2.loli.net/2024/06/02/UHw3QStEyLeJvcg.png><p>有三个衡量指标,包括intensiry,irradiance和radiance.<p><img alt=image-20240602161706417 data-src=https://s2.loli.net/2024/06/02/b2unaV1cI5EjAGO.png><p>实心角：球面上被摄面积与半径平方的比值：球面面积与半径平方之比 ,球有4Π steradians<p><img alt=image-20240602163911047 data-src=https://s2.loli.net/2024/06/02/m6cLVeHiUGlbMfZ.png style=zoom:67%;><p><img alt=image-20240602164606816 data-src=https://s2.loli.net/2024/06/02/xD2i9V1WznUTF4q.png><p><img alt=image-20240602164655440 data-src=https://s2.loli.net/2024/06/02/OMtKHV5yo8TWziU.png><p><img alt=image-20240602165849277 data-src=https://s2.loli.net/2024/06/02/NJcHQwevWK9ZO1z.png><p>辐照度(irradiance)是入射到表面点的单位面积功率<p><img alt=image-20240602170041748 data-src=https://s2.loli.net/2024/06/02/2lu7SGBX5qcUTbr.png><p>表面的辐照度与光照方向和表面法线之间夹角的余弦成正比。<p><img alt=image-20240602170804889 data-src=https://s2.loli.net/2024/06/02/hjSAJr1gxt7Bmep.png><p><img alt=image-20240602171113537 data-src=https://s2.loli.net/2024/06/02/DofShqERXKj6wPJ.png style=zoom:67%;><p>辐射度(Radiance)是描述光在环境中分布的基本场量<ul><li>辐照度是与光线相关的量<li>渲染就是计算辐射度</ul><p><img alt=image-20240602172100181 data-src=https://s2.loli.net/2024/06/02/nSJchK5OdA4fpNt.png><p><img alt=image-20240602172146849 data-src=https://s2.loli.net/2024/06/02/xv3qSwf4XlWAGQs.png><p>Incident radiance:入射辐射度是到达表面的单位固角辐照度<p>Exiting Radiance:离开表面辐射度是离开表面的单位投影面积强度。<p><strong>Bidirectional Reflectance Distribution Function</strong><p>双向反射分布函数（BRDF）表示从每个入射方向反射到每个出射方向的光量<p><img alt=image-20240602173440574 data-src=https://s2.loli.net/2024/06/02/gsSYMKUADz4Xp3b.png><p><img alt=image-20240602174423412 data-src=https://s2.loli.net/2024/06/02/L1fjxdF4gEzKbpM.png><p><img alt=image-20240602205209811 data-src=https://s2.loli.net/2024/06/02/snL4oXfVMKzmqxR.png><p><img alt=image-20240602174856955 data-src=https://s2.loli.net/2024/06/02/BRbCeu6IHMSpiFL.png><p><img alt=img data-src=https://pic3.zhimg.com/v2-c9128ac3f985a48f1c42ea7f12803f8e_b.jpg><p><img alt=image-20240602211917267 data-src=https://s2.loli.net/2024/06/02/FEoybKz31a5Mpc6.png><p>将L~i~转为经过反射后的光L~r~再经过简化.<ul><li>此时我们令相机接受到的直接光照为：e(u)<li>最终接收到的光为:l(u)<li>其他表面弹过来的光为:l(v)<li>BRDF那些式子为：K（u，v）</ul><p><img alt=img data-src=https://pic3.zhimg.com/v2-1df15bb2a394315d869b916c594e1fb2_b.jpg><p><img alt=image-20240602212016496 data-src=https://s2.loli.net/2024/06/02/IAHsizpe86rmSCo.png><p><strong>Monte Carlo Integration</strong><p><img alt=image-20240602214239624 data-src=https://s2.loli.net/2024/06/02/xKZpAtQFj8yimU4.png><p><strong>Path Tracing</strong><p>光线追踪<ul><li>始终执行镜面反射/折射<li>在漫反射表面停止反弹</ul><p>使用Monte Carlo Integration解决反射公式.<p><img alt=image-20240602215544122 data-src=https://s2.loli.net/2024/06/02/EhnZtXl7cMkPb2a.png><p><img alt=image-20240602220952675 data-src=https://s2.loli.net/2024/06/02/NufB9EKD4wZOPU6.png><p><img alt=image-20240602222734803 data-src=https://s2.loli.net/2024/06/02/Fowx9kp7sRbHdMY.png style=zoom:67%;><p>存在的两个问题:<p><strong>Explosion of #rays as #bounces go up</strong><p>由于反射,在反射时需要通过蒙特卡洛方法计算多个值,这样多次反射计算量增加.<p>所以只取一个方向作为入射,但在每个pixel上采样多个值取平均.<p><img alt=image-20240602230032888 data-src=https://s2.loli.net/2024/06/02/li1ahLZm26DvMru.png><p><strong>The recursive algorithm will never stop</strong><p>光会无数次反弹. 解决方法:俄罗斯轮盘赌 Russian Roulette (RR)<p><img alt=image-20240602230335879 data-src=https://s2.loli.net/2024/06/02/NugfonpHmWKzX1V.png><p><img alt=image-20240602230436474 data-src=https://s2.loli.net/2024/06/02/CwaPL4fyJtV8uc7.png style=zoom:50%;><p>此外N=1的采样还存在问题:即低采样率的问题，由于我们将平均放到了像素块处用接收到的光线来替代平均着色点的光线，但如果对于一个场景就没有或存在很少的间接光照，主要是直接光照的时候，那这个平均也无法消除误差噪声。<blockquote><p>如果光源面积很小，则均匀采样就需要很大的N才能保证采样到光源方向。也就是这里问题来自两个第一个是均匀抽样方法浪费了很多光源不存在的角度</blockquote><p>对光采样<p><img alt=image-20240602232512769 data-src=https://s2.loli.net/2024/06/02/t2TL8lFwkCp4XfK.png><p><img alt=z data-src=https://s2.loli.net/2024/06/02/4vfesAZGRpgjChi.png><p><img alt=image-20240602232751423 data-src=https://s2.loli.net/2024/06/02/y8Wdgb4t2TJY9qZ.png><p><img alt=img data-src=https://iewug.github.io/book/img/15renderingEquation.png><p>渲染公式通过BRDF得到<p>演进过程:渲染公式->使用蒙特卡洛方式积分解->引入全局光照,碰到物体会反射->由于反射太多,直接每次只会反射一根光线->由于只反射一根光线,采样不够,在一个pixel上采样更多次->此外这个算法会无穷的进行下去(因为最后只在打到灯光后停止),每次反射通过俄罗斯转盘减少能量->此外还是不够有效,考虑sample the light,sample light本身是dA,需要从dw转到dA->现在选择一个区域作为light source直接照射,另外区域都是间接的<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br></pre><td class=code><pre><span class=line><span class=comment>// 总体流程如下：</span></span><br><span class=line><span class=comment>// 从像素打出射线，检查射线是否命中，命中则继续下一步，反之结束</span></span><br><span class=line><span class=comment>// 对光源表面进行采样，得到一个采样的交点 Intersection 和光源的 pdf</span></span><br><span class=line><span class=comment>// 检查光源采样点和像素射线交点，两点之间是否有其他物体遮挡，没有遮挡则可计算直接光</span></span><br><span class=line><span class=comment>// 计算俄罗斯轮盘赌概率，如果成功进行下一步</span></span><br><span class=line><span class=comment>// 按照像素射线交点材质的性质，给定像素射线入射方向与交点法向量，用某种分布采样一个出射方向，这里是漫反射</span></span><br><span class=line><span class=comment>// 有了出射方向和交点，得到新的射线，计算是否有命中</span></span><br><span class=line><span class=comment>// 如果命中了非光源，计算新射线命中交点给原来像素射线交点带来的间接光</span></span><br><span class=line><span class=comment>// 最后将直接光和间接光结合，得到最初命中的位置的颜色</span></span><br><span class=line><span class=comment>// Implementation of Path Tracing</span></span><br><span class=line><span class=function>Vector3f <span class=title>Scene::castRay</span><span class=params>(<span class=keyword>const</span> Ray &ray, <span class=keyword>int</span> depth)</span> <span class=keyword>const</span> </span>{</span><br><span class=line>  <span class=comment>// TO DO Implement Path Tracing Algorithm here</span></span><br><span class=line>  Vector3f l_indir{<span class=number>0.f</span>};</span><br><span class=line>  Vector3f l_dir{<span class=number>0.f</span>};</span><br><span class=line>  Intersection ray_inter = <span class=built_in>intersect</span>(ray);</span><br><span class=line>  <span class=keyword>if</span> (!ray_inter.happened) {</span><br><span class=line>    <span class=comment>// 没有与任何物体相碰</span></span><br><span class=line>    <span class=keyword>return</span> l_dir + l_indir;</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>float</span> pdf_light;</span><br><span class=line>  Intersection light_inter;</span><br><span class=line>  <span class=built_in>sampleLight</span>(light_inter, pdf_light);</span><br><span class=line></span><br><span class=line>  Vector3f N = ray_inter.normal;</span><br><span class=line>  Vector3f x = light_inter.coords;</span><br><span class=line>  Vector3f wo = ray.direction;</span><br><span class=line>  Vector3f p = ray_inter.coords;</span><br><span class=line>  Vector3f ws = (x - p).<span class=built_in>normalized</span>();</span><br><span class=line>  <span class=comment>// shoot a ray from p to x</span></span><br><span class=line>  Ray ray_light_to_p = <span class=built_in>Ray</span>(p + EPSILON * N, ws);</span><br><span class=line>  <span class=keyword>auto</span> rpx_inter = <span class=built_in>intersect</span>(ray_light_to_p);</span><br><span class=line>  Vector3f NN = rpx_inter.normal;</span><br><span class=line>  Material *m = ray_inter.m;</span><br><span class=line>  <span class=comment>// if the ray is not blocked in the middle</span></span><br><span class=line>  <span class=keyword>if</span> (rpx_inter.happened && rpx_inter.m-><span class=built_in>hasEmission</span>()) {</span><br><span class=line>    l_dir = rpx_inter.m-><span class=built_in>getEmission</span>() * m-><span class=built_in>eval</span>(wo, ws, N) *</span><br><span class=line>            <span class=built_in>dotProduct</span>(ws, N) * <span class=built_in>dotProduct</span>(-ws, NN) / (rpx_inter.distance) /</span><br><span class=line>            pdf_light;</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=keyword>if</span> (<span class=built_in>get_random_float</span>() < RussianRoulette) {</span><br><span class=line>    Vector3f wi = (m-><span class=built_in>sample</span>(wo, N)).<span class=built_in>normalized</span>();</span><br><span class=line>    <span class=function>Ray <span class=title>rpwi</span><span class=params>(p, wi)</span></span>;</span><br><span class=line>    <span class=keyword>auto</span> rpwi_inter = <span class=built_in>intersect</span>(rpwi);</span><br><span class=line>    <span class=keyword>if</span> (rpwi_inter.happened && !rpwi_inter.m-><span class=built_in>hasEmission</span>()) {</span><br><span class=line>      l_indir = <span class=built_in>castRay</span>(rpwi, depth + <span class=number>1</span>) * m-><span class=built_in>eval</span>(wo, wi, N) *</span><br><span class=line>                <span class=built_in>dotProduct</span>(wi, N) / m-><span class=built_in>pdf</span>(wo, wi, N) / RussianRoulette;</span><br><span class=line>    }</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>return</span> m-><span class=built_in>getEmission</span>() + l_dir + l_indir; <span class=comment>//物体表面的emission和直接从光发射的和反射的</span></span><br><span class=line>}</span><br></pre></table></figure><p>from <a href=https://iewug.github.io/book/GAMES101.html#19-cameras-lenses-and-light-fields rel=noopener target=_blank>GAMES101笔记 (iewug.github.io)</a><p><img alt=img data-src=https://iewug.github.io/book/img/18.png><h5 id=相机与透镜><a class=headerlink href=#相机与透镜 title=相机与透镜></a>相机与透镜</h5><p><img alt="Controlled by lens aperture and focal length " data-src=https://s2.loli.net/2024/06/24/6UpBiyaDNRWGFws.png><p>Shutter Exposes Sensor For Precise Duration<p>Sensor Accumulates Irradiance During Exposure<p><img alt=image-20240624205234472 data-src=https://s2.loli.net/2024/06/24/bSJjU1PMziDhyg2.png><p><img alt=image-20240624205208978 data-src=https://s2.loli.net/2024/06/24/CBP6qkOpLA21a5z.png><p><img alt=image-20240624205321605 data-src=https://s2.loli.net/2024/06/24/ieFozQaEGCmhxd9.png style=zoom:67%;><p><img alt=img data-src=https://iewug.github.io/book/img/19coc.png><p><img alt=img data-src=https://iewug.github.io/book/img/19dof.png><p>一些概念:focal length,FOV,exposure,ISO(感光度),F-step(焦距除以口径的直径),CoC大小(当物体远离Focal Plane，原本的一个点落在sensor plane上就会变成一个圆),景深,指的是在相机拍摄过程中,成像清晰的范围或深度。<h5 id=光场、颜色与感知><a class=headerlink href=#光场、颜色与感知 title=光场、颜色与感知></a>光场、颜色与感知</h5><p><strong>光场</strong>（<strong>light field</strong>或称为<strong>lumigraph</strong>），即是空间中任意点发出的任意方向的光的集合<p><img alt data-src=https://s2.loli.net/2024/06/24/yrHGxeBONiDd2Pz.png><p><img alt data-src=https://s2.loli.net/2024/06/24/Hx2PZirjtD4Lw5d.png><h5 id=HW8><a class=headerlink href=#HW8 title=HW8></a>HW8</h5><p><strong>Mass Spring System</strong> 质量-弹簧系统<p><img alt=image-20240624220439532 data-src=https://s2.loli.net/2024/06/24/nf1QyZV5pgU9BHi.png><p><img alt=image-20240624220852340 data-src=https://s2.loli.net/2024/06/24/4pGTPO6Ws1wUvdf.png><p><img alt=image-20240624221049069 data-src=https://s2.loli.net/2024/06/24/ErmvTYSaBPXUnMu.png><p><strong>粒子系统</strong><p>将动态系统建模为大量粒子的集合<br>大量粒子的集合,每个粒子的运动由一组<br>物理（或非物理）力<br>图形和游戏中的流行技术<ul><li>易于理解和实施<li>可扩展：粒子数量越少速度越快，粒子数量越多<br>以提高复杂性<br>挑战<li>可能需要很多粒子（如流体）<li>可能需要加速结构（如<br>找到最近的粒子进行交互）</ul><p>吸引力和斥力<ul><li>重力、电磁力、…<li>弹簧、推进力 …<br>阻尼力<li>摩擦力、空气阻力、粘滞力 …<br>碰撞<li>墙壁、容器、固定物体、 …<li><p>动态物体、角色身体部位</p><li><p><strong>正向运动学</strong>（forward kinematics）：已知初始的关键点位置和相对旋转，计算最终的关键点位置。唯一解</p><li><strong>反向运动学</strong>（inverse kinematics）：根据初始的关键点位置和最终关键点位置，计算相对旋转的数学过程。无解或无穷多解（ill-posed problem）。</ul><p><strong>Rigging(绑定)</strong><p>装配是对角色进行更高级别的控制，可以更快、更直观地修改角色的姿势、变形和表情等。<br>更快、更直观地修改姿势、变形和表情等。<ul><li>就像木偶上的线<li>捕捉所有有意义的角色的变化<li>因角色而异<li>角色制作成本高<li>手工制作<li>需要艺术和技术培训</ul><p>代替骨架，直接在曲面之间插值<br>例如，建立面部表情集合模型<br>表情模型：<br>最简单的方案：对顶点位置进行线性组合<br>使用样条曲线控制随时间变化的权重选择<p><strong>Motion Capture(动捕)</strong><p>创建动画序列的数据驱动方法<ul><li>记录真实世界中的表演（例如，人在执行一项活动）<li>从收集到的数据中提取姿势与时间的函数关系</ul><p><strong>Single Particle Simulation</strong><p><img alt=image-20240624222909275 data-src=https://s2.loli.net/2024/06/24/25FQh4KbNSsTrey.png>首先，假设粒子的运动由速度矢量场决定，速度矢量场是位置和时间的函数：v(x, t)计算粒子随时间变化的位置 需要求解一个一阶常微分方程： “一阶 “指的是导数。”普通 “意味着没有 “偏” 导数,即x只是t的函数.<p>在给定粒子初始位置 x0 的条件下，我们可以通过正向数值积分来求解 ODE<p>欧拉法（又称前向欧拉法、显式欧拉法）<ul><li>简单迭代法<li>常用<li>非常不准确<li>经常不稳定</ul><p><img alt=image-20240624223202577 data-src=https://s2.loli.net/2024/06/24/prX2HEvQnexuTPm.png style=zoom:67%;><p><strong>消除不稳定因素</strong><p>中点法/修正欧拉法<ul><li>起点和终点的平均速度<br>自适应步长<li>递归比较一步和两个半步，直到<br>误差可接受<br>隐式方法<li>使用下一时间步的速度（困难）<br>基于位置/Verlet 积分<li>在时间步后约束粒子的位置和速度步</ul><figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br></pre><td class=code><pre><span class=line>Rope::<span class=built_in>Rope</span>(Vector2D start, Vector2D end, <span class=keyword>int</span> num_nodes, <span class=keyword>float</span> node_mass,</span><br><span class=line>           <span class=keyword>float</span> k, vector<<span class=keyword>int</span>> pinned_nodes) {</span><br><span class=line>  <span class=comment>// TODO (Part 1): Create a rope starting at `start`, ending at `end`, and</span></span><br><span class=line>  <span class=comment>// containing `num_nodes` nodes.</span></span><br><span class=line>  <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < num_nodes; i++) {</span><br><span class=line>    Vector2D pos =</span><br><span class=line>        start + (end - start) * ((<span class=keyword>double</span>)i / ((<span class=keyword>double</span>)num_nodes - <span class=number>1.0</span>));</span><br><span class=line>    masses.<span class=built_in>push_back</span>(<span class=keyword>new</span> <span class=built_in>Mass</span>(pos, node_mass, <span class=literal>false</span>));</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < num_nodes - <span class=number>1</span>; i++) {</span><br><span class=line>    springs.<span class=built_in>push_back</span>(<span class=keyword>new</span> <span class=built_in>Spring</span>(masses[i], masses[i + <span class=number>1</span>], k));</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>for</span> (<span class=keyword>auto</span> &i : pinned_nodes) {</span><br><span class=line>    masses[i]->pinned = <span class=literal>true</span>;</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=comment>//        for (auto &i : pinned_nodes) {</span></span><br><span class=line>  <span class=comment>//            masses[i]->pinned = true;</span></span><br><span class=line>  <span class=comment>//        }</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>Rope::simulateEuler</span><span class=params>(<span class=keyword>float</span> <span class=keyword>delta_t</span>, Vector2D gravity)</span> </span>{</span><br><span class=line>  <span class=keyword>for</span> (<span class=keyword>auto</span> &s : springs) {</span><br><span class=line>    <span class=comment>// （solving constraints)</span></span><br><span class=line>    <span class=keyword>auto</span> mod_ab = (s->m1->position - s->m2->position).<span class=built_in>norm</span>();</span><br><span class=line>    s->m1->forces += -s->k * (s->m1->position - s->m2->position) / mod_ab *</span><br><span class=line>                     (mod_ab - s->rest_length);</span><br><span class=line>    s->m2->forces += -s->k * (s->m2->position - s->m1->position) / mod_ab *</span><br><span class=line>                     (mod_ab - s->rest_length);</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=keyword>for</span> (<span class=keyword>auto</span> &m : masses) {</span><br><span class=line>    <span class=keyword>if</span> (!m->pinned) {</span><br><span class=line>      <span class=keyword>auto</span> a = m->forces / m->mass + gravity;</span><br><span class=line>      m->position += m->velocity * <span class=keyword>delta_t</span>;  <span class=comment>//  explicit</span></span><br><span class=line>      m->velocity += a * <span class=keyword>delta_t</span>;</span><br><span class=line>      m->position += m->velocity * <span class=keyword>delta_t</span>;  <span class=comment>//  implicit</span></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// Reset all forces on each mass</span></span><br><span class=line>    m->forces = <span class=built_in>Vector2D</span>(<span class=number>0</span>, <span class=number>0</span>);</span><br><span class=line>  }</span><br><span class=line>}</span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>Rope::simulateVerlet</span><span class=params>(<span class=keyword>float</span> <span class=keyword>delta_t</span>, Vector2D gravity)</span> </span>{</span><br><span class=line>  <span class=keyword>for</span> (<span class=keyword>auto</span> &s : springs) {</span><br><span class=line>    <span class=comment>// TODO (Part 3): Simulate one timestep of the rope using explicit Verlet</span></span><br><span class=line>    <span class=comment>// （solving constraints)</span></span><br><span class=line>    <span class=keyword>auto</span> mod_ab = (s->m1->position - s->m2->position).<span class=built_in>norm</span>();</span><br><span class=line>    s->m1->forces += -s->k * (s->m1->position - s->m2->position) / mod_ab *</span><br><span class=line>                     (mod_ab - s->rest_length);</span><br><span class=line>    s->m2->forces += -s->k * (s->m2->position - s->m1->position) / mod_ab *</span><br><span class=line>                     (mod_ab - s->rest_length);</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=keyword>for</span> (<span class=keyword>auto</span> &m : masses) {</span><br><span class=line>    <span class=keyword>if</span> (!m->pinned) {</span><br><span class=line>      Vector2D temp_position = m->position;</span><br><span class=line>      <span class=comment>// TODO (Part 3.1): Set the new position of the rope mass</span></span><br><span class=line>      <span class=keyword>auto</span> a = m->forces / m->mass + gravity;</span><br><span class=line>      <span class=comment>// TODO (Part 4): Add global Verlet damping</span></span><br><span class=line>      m->position = temp_position + (temp_position - m->last_position) +</span><br><span class=line>                    a * <span class=keyword>delta_t</span> * <span class=keyword>delta_t</span>;</span><br><span class=line>      m->last_position = temp_position;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// Reset all forces on each mass</span></span><br><span class=line>    m->forces = <span class=built_in>Vector2D</span>(<span class=number>0</span>, <span class=number>0</span>);</span><br><span class=line>  }</span><br><span class=line>}</span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>Rope::simulateVerlet</span><span class=params>(<span class=keyword>float</span> <span class=keyword>delta_t</span>, Vector2D gravity)</span> </span>{</span><br><span class=line>  <span class=keyword>for</span> (<span class=keyword>auto</span> &s : springs) {</span><br><span class=line>    <span class=comment>// TODO (Part 3): Simulate one timestep of the rope using explicit Verlet</span></span><br><span class=line>    <span class=comment>// （solving constraints)</span></span><br><span class=line>    <span class=keyword>auto</span> mod_ab = (s->m1->position - s->m2->position).<span class=built_in>norm</span>();</span><br><span class=line>    s->m1->forces += -s->k * (s->m1->position - s->m2->position) / mod_ab *</span><br><span class=line>                     (mod_ab - s->rest_length);</span><br><span class=line>    s->m2->forces += -s->k * (s->m2->position - s->m1->position) / mod_ab *</span><br><span class=line>                     (mod_ab - s->rest_length);</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=keyword>float</span> damping_factor = <span class=number>0.00005</span>;</span><br><span class=line>  <span class=keyword>for</span> (<span class=keyword>auto</span> &m : masses) {</span><br><span class=line>    <span class=keyword>if</span> (!m->pinned) {</span><br><span class=line>      Vector2D temp_position = m->position;</span><br><span class=line>      <span class=comment>// TODO (Part 3.1): Set the new position of the rope mass</span></span><br><span class=line>      <span class=keyword>auto</span> a = m->forces / m->mass + gravity;</span><br><span class=line>      <span class=comment>// TODO (Part 4): Add global Verlet damping</span></span><br><span class=line>      m->position = temp_position +</span><br><span class=line>                    (<span class=number>1</span> - damping_factor) * (temp_position - m->last_position) +</span><br><span class=line>                    a * <span class=keyword>delta_t</span> * <span class=keyword>delta_t</span>;</span><br><span class=line>      m->last_position = temp_position;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// Reset all forces on each mass</span></span><br><span class=line>    m->forces = <span class=built_in>Vector2D</span>(<span class=number>0</span>, <span class=number>0</span>);</span><br><span class=line>  }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=名词解释><a class=headerlink href=#名词解释 title=名词解释></a>名词解释</h3><h4 id=缓冲对象><a class=headerlink href=#缓冲对象 title=缓冲对象></a>缓冲对象</h4><p>比如顶点缓冲对象,顶点数组对象.<p>定义顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：<strong>顶点着色器</strong>。它<strong>会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡</strong>。顶点着色器接着会处理我们在内存中指定数量的顶点。<p>通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。<h4 id=缓冲对象类型><a class=headerlink href=#缓冲对象类型 title=缓冲对象类型></a>缓冲对象类型</h4><p>比如顶点缓冲对象类型,创建好的缓冲可以绑定到某种对象类型上.<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> VBO;</span><br><span class=line><span class=built_in>glGenBuffers</span>(<span class=number>1</span>, &VBO);</span><br><span class=line><span class=built_in>glBindBuffer</span>(GL_ARRAY_BUFFER, VBO); </span><br></pre></table></figure><p>从这一刻起，我们使用的任何（在GL_ARRAY_BUFFER目标上的）缓冲调用都会用来配置当前绑定的缓冲(VBO)。然后我们可以调用glBufferData函数，它会把之前定义的顶点数据复制到缓冲的显存中<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>glBufferData</span>(GL_ARRAY_BUFFER, <span class=built_in><span class=keyword>sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></table></figure><h4 id=shader与GLSL><a class=headerlink href=#shader与GLSL title=shader与GLSL></a>shader与GLSL</h4><p><strong>图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出</strong>。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，<strong>它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)</strong>。<p>包括顶点着色器等等<h4 id=VAO><a class=headerlink href=#VAO title=VAO></a>VAO</h4><p>顶点数组对象(又称 VAO)可以像顶点缓冲区对象一样绑定,此后的顶点属性调用都将存储在 VAO 中.<h3 id=书籍和网站推荐><a class=headerlink href=#书籍和网站推荐 title=书籍和网站推荐></a>书籍和网站推荐</h3><p><strong>解题参考</strong><p><a href=https://www.cnblogs.com/lawliet12/p/17719365.html rel=noopener target=_blank>Games101现代计算机图形学入门 - 作业1~8 集合含提高项总结 - lawliet9 - 博客园 (cnblogs.com)</a><p><strong>书籍</strong><ol><li>Fundamentals of Computer Graphics<a href=https://github.com/FCG-Translators/FundamentalsOfComputerGraphics-CN rel=noopener target=_blank>FCG-Translators/FundamentalsOfComputerGraphics-CN: 计算机图形学基础（中文译本） (github.com)</a><li><a href=https://book.douban.com/subject/35221845/ rel=noopener target=_blank>OpenGL超级宝典（第7版） (豆瓣) (douban.com)</a></ol><p><strong>网站</strong><ol><li><a href=https://learnopengl.com/ rel=noopener target=_blank>Learn OpenGL, extensive tutorial resource for learning Modern OpenGL</a><li><a href=https://www.scratchapixel.com/ rel=noopener target=_blank>Scratchapixel 4.0, Learn Computer Graphics Programming</a><li><a href=https://ogldev.org/ rel=noopener target=_blank>OpenGL Step by Step - OpenGL Development (ogldev.org)</a><li><a href=https://cs184.eecs.berkeley.edu/ rel=noopener target=_blank>https://cs184.eecs.berkeley.edu/</a><li><a href=http://15462.courses.cs.cmu.edu/fall2022/ rel=noopener target=_blank>15-462/662 Fall 2022 (cmu.edu)</a></ol><link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script></div><div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a title="computer graphics:计算机图形学学习" href=https://www.sekyoro.top/2024/05/07/computer-graphics-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/>https://www.sekyoro.top/2024/05/07/computer-graphics-计算机图形学学习/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div><footer class=post-footer><div class=post-nav><div class=post-nav-item><a href=/2024/05/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AE%80%E5%8D%95JS%E9%80%86%E5%90%91Tricks/ rel=prev title=浏览器简单JS逆向Tricks> <i class="fa fa-chevron-left"></i> 浏览器简单JS逆向Tricks </a></div><div class=post-nav-item><a href=/2024/05/17/%E5%8D%8F%E5%90%8C%E6%84%9F%E7%9F%A5%E7%AE%97%E6%B3%95-%E4%BA%8C/ rel=next title=协同感知学习(二)> 协同感知学习(二) <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div><!-- 评论区 --><div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-3"><a class=nav-link href=#GAMES101><span class=nav-number>1.</span> <span class=nav-text>GAMES101</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%BD%AC%E6%8D%A2><span class=nav-number>1.1.</span> <span class=nav-text>转换</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#assignment><span class=nav-number>1.2.</span> <span class=nav-text>assignment</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#HW0><span class=nav-number>1.2.1.</span> <span class=nav-text>HW0</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#HW1><span class=nav-number>1.2.2.</span> <span class=nav-text>HW1</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#HW2><span class=nav-number>1.2.3.</span> <span class=nav-text>HW2</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#HW3><span class=nav-number>1.2.4.</span> <span class=nav-text>HW3</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#HW4><span class=nav-number>1.2.5.</span> <span class=nav-text>HW4</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#HW5><span class=nav-number>1.2.6.</span> <span class=nav-text>HW5</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#HW6><span class=nav-number>1.2.7.</span> <span class=nav-text>HW6</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#HW7><span class=nav-number>1.2.8.</span> <span class=nav-text>HW7</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%9B%B8%E6%9C%BA%E4%B8%8E%E9%80%8F%E9%95%9C><span class=nav-number>1.2.9.</span> <span class=nav-text>相机与透镜</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%85%89%E5%9C%BA%E3%80%81%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5><span class=nav-number>1.2.10.</span> <span class=nav-text>光场、颜色与感知</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#HW8><span class=nav-number>1.2.11.</span> <span class=nav-text>HW8</span></a></ol></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A><span class=nav-number>2.</span> <span class=nav-text>名词解释</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%BC%93%E5%86%B2%E5%AF%B9%E8%B1%A1><span class=nav-number>2.1.</span> <span class=nav-text>缓冲对象</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%BC%93%E5%86%B2%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B><span class=nav-number>2.2.</span> <span class=nav-text>缓冲对象类型</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#shader%E4%B8%8EGLSL><span class=nav-number>2.3.</span> <span class=nav-text>shader与GLSL</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#VAO><span class=nav-number>2.4.</span> <span class=nav-text>VAO</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%B9%A6%E7%B1%8D%E5%92%8C%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90><span class=nav-number>3.</span> <span class=nav-text>书籍和网站推荐</span></a></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>242</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>16</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>214</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a><li class=links-of-blogroll-item><a href=https://www.lllomh.com/ rel=noopener target=_blank title=https://www.lllomh.com/>芈渡</a><li class=links-of-blogroll-item><a href=https://protool-ten.vercel.app/ rel=noopener target=_blank title=https://protool-ten.vercel.app/>protools</a></ul></div><div class="motion-element announcement"><div class=title></div><p class=content><p class=date></div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>此文章目前无词云</h3></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2025</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>2.8m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>41:43</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer></div><script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script><script src=/lib/anime.min.js></script><script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script><script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/pisces.js></script><script src=/js/next-boot.js></script><script src=/js/bookmark.js></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	'.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script><script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script><script src=/js/algolia-search.js></script><script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script><div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div><script charset=utf-8 defer src=/js/tagcanvas.js></script><script charset=utf-8 defer src=/js/tagcloud.js></script><script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script><script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script><script src=/js/src/activate-power-mode.min.js></script><script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script>
<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"0F9LEEVW82","apiKey":"78839e9f9be09d081c5c4da81975cd19","indexName":"sekyoblog_sec","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content=从手动设置顶点坐标到加载模型以及OpenGL高级技巧 name=description><meta content=article property=og:type><meta content="Learn OpenGL(二):模型加载与高级OpenGL" property=og:title><meta content=https://www.sekyoro.top/2024/12/27/Learn-OpenGL-%E4%BA%8C/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content=从手动设置顶点坐标到加载模型以及OpenGL高级技巧 property=og:description><meta content=zh_CN property=og:locale><meta content=https://learnopengl-cn.github.io/img/03/01/assimp_structure.png property=og:image><meta content=https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20241228205757945.png property=og:image><meta content=https://learnopengl-cn.github.io/img/04/01/depth_linear_graph.png property=og:image><meta content=https://learnopengl-cn.github.io/img/04/01/depth_non_linear_graph.png property=og:image><meta content=https://learnopengl-cn.github.io/img/04/03/blending_equation_mixed.png property=og:image><meta content=https://learnopengl-cn.github.io/img/04/06/cubemaps_sampling.png property=og:image><meta content=https://learnopengl-cn.github.io/img/04/06/cubemaps_reflection_theory.png property=og:image><meta content=https://s2.loli.net/2025/01/05/kCJ4toqla1Vy8FL.png property=og:image><meta content=https://learnopengl-cn.github.io/img/04/06/cubemaps_refraction_theory.png property=og:image><meta content=https://s2.loli.net/2025/01/05/qVRmaAPHS14loCg.png property=og:image><meta content=2024-12-27T14:19:31.000Z property=article:published_time><meta content=2025-01-07T13:59:29.911Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content=OpenGL property=article:tag><meta content="computer graphics" property=article:tag><meta content=summary name=twitter:card><meta content=https://learnopengl-cn.github.io/img/03/01/assimp_structure.png name=twitter:image><link href=https://www.sekyoro.top/2024/12/27/Learn-OpenGL-%E4%BA%8C/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>Learn OpenGL(二):模型加载与高级OpenGL | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2024/12/27/Learn-OpenGL-%E4%BA%8C/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>Learn OpenGL(二):模型加载与高级OpenGL</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-12-27 22:19:31" datetime=2024-12-27T22:19:31+08:00>2024-12-27</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-01-07 21:59:29" datetime=2025-01-07T21:59:29+08:00 itemprop=dateModified>2025-01-07</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>26k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>24 分钟</span> </span></div></header><div class=post-body itemprop=articleBody><p>从手动设置顶点坐标到加载模型以及OpenGL高级技巧<br><span id=more></span><h2 id=模型加载><a class=headerlink href=#模型加载 title=模型加载></a>模型加载</h2><p>通过一些建模软件,比如Blender,可以方便地对一些复杂物体进行建模并导出为模型,而这些模型文件包含许多信息,比如顶点坐标,法线以及纹理坐标.<p>不同的模型文件格式封装的信息也不同.常见的有<code>.obj</code>，<code>.fbx</code>,<code>s.tl</code>等等<p>通常使用<code>Assimp</code>加载模型,Assimp能够导入很多种不同的模型文件格式（并也能够导出部分的格式），<strong>它会将所有的模型数据加载至Assimp的通用数据结构中</strong>。当Assimp加载完模型之后就能够从Assimp的数据结构中提取我们所需的所有数据了。<p>由于Assimp的数据结构保持不变，不论导入的是什么种类的文件格式，它都能够将我们从这些不同的文件格式中抽象出来，用同一种方式访问需要的数据。<p>当使用Assimp导入一个模型的时候，它通常会将整个模型加载进一个<strong>场景</strong>(Scene)对象，它会包含导入的模型/场景中的所有数据。Assimp会将场景载入为一系列的节点(Node)，每个节点包含了场景对象中所储存数据的索引，每个节点都可以有任意数量的子节点。<p><img alt=img data-src=https://learnopengl-cn.github.io/img/03/01/assimp_structure.png><ul><li>和材质,网格(Mesh)一样，所有的场景/模型数据都包含在Scene对象中。Scene对象也包含了场景根节点的引用。<li>场景的Root node（根节点）可能包含子节点（和其它的节点一样），它会有一系列指向场景对象中mMeshes数组中储存的网格数据的索引。Scene下的mMeshes数组储存了真正的Mesh对象，节点中的mMeshes数组保存的只是场景中网格数组的索引。<li>一个Mesh对象本身包含了渲染所需要的所有相关数据，像是顶点位置、法向量、纹理坐标、面(Face)和物体的材质。<li>一个网格包含了多个面。Face代表的是物体的渲染图元(Primitive)（三角形、方形、点）。一个面包含了组成图元的顶点的索引。由于顶点和索引是分开的，使用一个索引缓冲来渲染是非常简单的<li>最后，一个网格也包含了一个Material对象，它包含了一些函数能让我们获取物体的材质属性，比如说颜色和纹理贴图（比如漫反射和镜面光贴图）</ul><p>使用Assimp可以加载不同的模型到程序中，但是载入后它们都被储存为Assimp的数据结构。最终仍要将这些数据转换为OpenGL能够理解的格式，这样才能渲染这个物体。我们从上一节中学到，网格(Mesh)代表的是单个的可绘制实体<p><img alt=image-20241228205757945 data-src=https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20241228205757945.png><p>一个网格应该至少需要一系列的顶点，每个顶点包含一个位置向量、一个法向量和一个纹理坐标向量。一个网格还应该包含用于索引绘制的索引以及纹理形式的材质数据（漫反射/镜面光贴图）。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>Vertex</span> {</span></span><br><span class=line>  glm::vec3 position;</span><br><span class=line>   glm::vec3 norm;</span><br><span class=line>    glm::vec2 textcoord;</span><br><span class=line>};</span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>Texture</span> {</span></span><br><span class=line>    <span class=keyword>unsigned</span> <span class=keyword>int</span> id;</span><br><span class=line>    std::string type;</span><br><span class=line>    aiString dir;</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>Mesh</span> {</span></span><br><span class=line>    <span class=keyword>public</span>:</span><br><span class=line>    std::vector&LTVertex> vertices;</span><br><span class=line>    std::vector&LTTexture> textures;</span><br><span class=line>    std::vector<<span class=keyword>unsigned</span> <span class=keyword>int</span>> indices;</span><br><span class=line>    	<span class=comment>// 处理方法</span></span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>Model</span>{</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>	std::vector&LTMesh> meshes;</span><br><span class=line>    std::vector&LTTextures> loadad_textures;</span><br><span class=line>   	<span class=comment>// 处理方法</span></span><br><span class=line>}</span><br></pre></table></figure><h2 id=深度测试><a class=headerlink href=#深度测试 title=深度测试></a>深度测试</h2><blockquote><p><strong>提前深度测试</strong><p>提前深度测试允许深度测试<strong>在片段着色器之前运行。只要清楚一个片段永远不会是可见的（它在其他物体之后），我们就能提前丢弃这个片段。</strong><p>片段着色器通常开销都是很大的，所以我们应该尽可能避免运行它们。<strong>当使用提前深度测试时，片段着色器的一个限制是你不能写入片段的深度值。如果一个片段着色器对它的深度值进行了写入，提前深度测试是不可能的。</strong>OpenGL不能提前知道深度值。</blockquote><p>​ <strong>深度缓冲就像颜色缓冲(Color Buffer)（储存所有的片段颜色：视觉输出）一样，在每个片段中储存了信息</strong>，并且（通常）和颜色缓冲有着一样的宽度和高度。<strong>深度缓冲是由窗口系统自动创建的，它会以16、24或32位float的形式储存它的深度值</strong>。在大部分的系统中，深度缓冲的精度都是24位的。<p>​ 当深度测试(Depth Testing)被启用的时候，<strong>OpenGL会将一个片段的深度值与深度缓冲的内容进行对比。OpenGL会执行一个深度测试，如果这个测试通过了的话，深度缓冲将会更新为新的深度值</strong>。如果深度测试失败了，片段将会被丢弃。<p>​ <strong>深度缓冲是在片段着色器运行之后（以及模板测试(Stencil Testing)运行之后）在屏幕空间中运行的。</strong>屏幕空间坐标与通过OpenGL的glViewport所定义的视口密切相关，并且可以<strong>直接使用GLSL内建变量gl_FragCoord从片段着色器中直接访问</strong>。gl_FragCoord的x和y分量代表了片段的屏幕空间坐标（其中(0, 0)位于左下角）。gl_FragCoord中也包含了一个z分量，它包含了片段真正的深度值。z值就是需要与深度缓冲内容所对比的那个值。<p>深度测试默认是禁用的，所以如果要启用深度测试的话用GL_DEPTH_TEST选项来启用它<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>glEnable</span>(GL_DEPTH_TEST);</span><br></pre></table></figure><p>当它启用的时候，如果一个片段通过了深度测试的话，OpenGL会在深度缓冲中储存该片段的z值；如果没有通过深度缓冲，则会丢弃该片段。如果你启用了深度缓冲，你还应该在每个渲染迭代之前使用GL_DEPTH_BUFFER_BIT来清除深度缓冲，否则会仍在使用上一次渲染迭代中的写入的深度值<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br></pre></table></figure><p>在某些情况下你会需要对所有片段都执行深度测试并丢弃相应的片段，但<strong>不</strong>希望更新深度缓冲。基本上来说，你在使用一个只读的(Read-only)深度缓冲。<strong>OpenGL允许禁用深度缓冲的写入，只需要设置它的深度掩码</strong>(Depth Mask)设置为<code>GL_FALSE</code>就可以了：<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=built_in>glEnable</span>(GL_DEPTH_TEST);</span><br><span class=line><span class=built_in>glDepthMask</span>(GL_FALSE);</span><br></pre></table></figure><p>注意这只在深度测试被启用的时候才有效果。<p>OpenGL允许修改深度测试中使用的比较运算符。这允许我们来控制OpenGL什么时候该通过或丢弃一个片段，什么时候去更新深度缓冲。可以调用glDepthFunc函数来设置比较运算符（或者说深度函数(Depth Function)）<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>glDepthFunc</span>(GL_LESS);</span><br></pre></table></figure><p>默认情况下使用的深度函数是GL_LESS，它将会丢弃深度值大于等于当前深度缓冲值的所有片段<div class=table-container><table><thead><tr><th style=text-align:left>函数<th style=text-align:left>描述<tbody><tr><td style=text-align:left>GL_ALWAYS<td style=text-align:left>永远通过深度测试<tr><td style=text-align:left>GL_NEVER<td style=text-align:left>永远不通过深度测试<tr><td style=text-align:left>GL_LESS<td style=text-align:left>在片段深度值小于缓冲的深度值时通过测试<tr><td style=text-align:left>GL_EQUAL<td style=text-align:left>在片段深度值等于缓冲区的深度值时通过测试<tr><td style=text-align:left>GL_LEQUAL<td style=text-align:left>在片段深度值小于等于缓冲区的深度值时通过测试<tr><td style=text-align:left>GL_GREATER<td style=text-align:left>在片段深度值大于缓冲区的深度值时通过测试<tr><td style=text-align:left>GL_NOTEQUAL<td style=text-align:left>在片段深度值不等于缓冲区的深度值时通过测试<tr><td style=text-align:left>GL_GEQUAL<td style=text-align:left>在片段深度值大于等于缓冲区的深度值时通过测试</table></div><h4 id=深度值精度><a class=headerlink href=#深度值精度 title=深度值精度></a>深度值精度</h4><p>深度缓冲包含了一个介于0.0和1.0之间的深度值，它将会与观察者视角所看见的场景中所有物体的z值进行比较。观察空间的z值可能是投影平截头体的<strong>近平面</strong>(Near)和<strong>远平面</strong>(Far)之间的任何值。<p>在透视矩阵中的znear和zfar决定了哪些坐标在视锥体中,我们将处在这个范围的顶点坐标z值转换到[0,1]之间. 一种简单的方式就是使用线性变换</p><script type="math/tex; mode=display">
F_{\text {depth }}=\frac{z-n e a r}{f a r-n e a r}</script><p><img alt=img data-src=https://learnopengl-cn.github.io/img/04/01/depth_linear_graph.png><p>在实践中是几乎永远不会使用这样的线性深度缓冲(Linear Depth Buffer)的。要想有正确的投影性质，需要使用一个非线性的深度方程，它是与 1/z 成正比的。它做的就是在z值很小的时候提供非常高的精度，而在z值很远的时候提供更少的精度</p><script type="math/tex; mode=display">
F_{\text {depth }}=\frac{1 / z-1 / \text { near }}{1 / \text { far }-1 / \text { near }}</script><p>深度值很大一部分是由很小的z值所决定的，这给了近处的物体很大的深度精度。这个（从观察者的视角）变换z值的方程是嵌入在投影矩阵中的，所以当我们想将一个顶点坐标从观察空间至裁剪空间的时候这个非线性方程就被应用了。<p><img alt=img data-src=https://learnopengl-cn.github.io/img/04/01/depth_non_linear_graph.png><p>可以将本身的非线性深度值转为线性深度值<figure class="highlight glsl"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=meta>#version 330 core</span></span><br><span class=line><span class=keyword>out</span> <span class=type>vec4</span> FragColor;</span><br><span class=line></span><br><span class=line><span class=type>float</span> near = <span class=number>0.1</span>; </span><br><span class=line><span class=type>float</span> far  = <span class=number>100.0</span>; </span><br><span class=line></span><br><span class=line><span class=type>float</span> LinearizeDepth(<span class=type>float</span> depth) </span><br><span class=line>{</span><br><span class=line>    <span class=type>float</span> z = depth * <span class=number>2.0</span> - <span class=number>1.0</span>; <span class=comment>// back to NDC </span></span><br><span class=line>    <span class=keyword>return</span> (<span class=number>2.0</span> * near * far) / (far + near - z * (far - near));    </span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=type>void</span> main()</span><br><span class=line>{             </span><br><span class=line>    <span class=type>float</span> depth = LinearizeDepth(<span class=built_in>gl_FragCoord</span>.z) / far; <span class=comment>// 为了演示除以 far</span></span><br><span class=line>    FragColor = <span class=type>vec4</span>(<span class=type>vec3</span>(depth), <span class=number>1.0</span>);</span><br><span class=line>}</span><br></pre></table></figure><h4 id=深度冲突><a class=headerlink href=#深度冲突 title=深度冲突></a>深度冲突</h4><p>一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生，<strong>深度缓冲没有足够的精度来决定两个形状哪个在前面</strong>。结果就是这两个形状不断地在切换前后顺序，这会导致很奇怪的花纹。这个现象叫做深度冲突(Z-fighting)，因为它看起来像是这两个形状在争夺(Fight)谁该处于顶端。<p>​ 箱子被放置在地板的同一高度上，这也就意味着箱子的底面和地板是共面的(Coplanar)。这两个面的深度值都是一样的，所以深度测试没有办法决定应该显示哪一个。<p>​ 深度冲突是深度缓冲的一个常见问题，<strong>当物体在远处时效果会更明显（因为深度缓冲在z值比较大的时候有着更小的精度）。深度冲突不能够被完全避免，但一般会有一些技巧有助于在你的场景中减轻或者完全避免深度冲突</strong><p><strong>防止深度冲突</strong><p>第一个也是最重要的技巧是<strong>永远不要把多个物体摆得太靠近，以至于它们的一些三角形会重叠</strong>。通过在两个物体之间设置一个用户无法注意到的偏移值，你可以完全避免这两个物体之间的深度冲突。在箱子和地板的例子中，<strong>可以将箱子沿着正y轴稍微移动一点。箱子位置的这点微小改变将不太可能被注意到，但它能够完全减少深度冲突的发生</strong>。然而，这需要对每个物体都手动调整，并且需要进行彻底的测试来保证场景中没有物体会产生深度冲突。<p>第二个技巧是<strong>尽可能将近平面设置远一些</strong>。精度在靠近<strong>近</strong>平面时是非常高的，<strong>所以如果我们将近平面远离观察者，我们将会对整个平截头体有着更大的精度</strong>。然而，将近平面设置太远将会导致近处的物体被裁剪掉，所以这通常需要实验和微调来决定最适合你的场景的<strong>近</strong>平面距离。<p>另外一个很好的技巧是牺牲一些性能，<strong>使用更高精度的深度缓冲</strong>。大部分深度缓冲的精度都是24位的，但现在大部分的显卡都支持32位的深度缓冲，这将会极大地提高精度。所以，牺牲掉一些性能，你就能获得更高精度的深度测试，减少深度冲突。<h2 id=模板测试><a class=headerlink href=#模板测试 title=模板测试></a>模板测试</h2><p>​ 当片段着色器处理完一个片段之后，模板测试(Stencil Test)会开始执行，和深度测试一样，它也可能会丢弃片段。接下来，被保留的片段会进入深度测试，它可能会丢弃更多的片段。<strong>模板测试是根据又一个缓冲来进行的，它叫做模板缓冲(Stencil Buffer)，可以在渲染的时候更新它来获得一些很有意思的效果。</strong><p>​ <strong>一个模板缓冲中，（通常）每个模板值(Stencil Value)是8位的。所以每个像素/片段一共能有256种不同的模板值</strong>。我们可以将这些模板值设置为我们想要的值，然后当某一个片段有某一个模板值的时候，我们就可以选择丢弃或是保留这个片段了<blockquote><p>每个窗口库都需要为你配置一个模板缓冲。GLFW自动做了这件事，所以我们不需要告诉GLFW来创建一个，但其它的窗口库可能不会默认给你创建一个模板库，所以记得要查看库的文档。</blockquote><p>模板缓冲操作允许在渲染片段时将模板缓冲设定为一个特定的值。通过在渲染时修改模板缓冲的内容，我们<strong>写入</strong>了模板缓冲。在同一个（或者接下来的）渲染迭代中，可以<strong>读取</strong>这些值，来决定丢弃还是保留某个片段。使用模板缓冲的时候你可以尽情发挥，但大体的步骤如下：<ul><li>启用模板缓冲的写入。<li>渲染物体，更新模板缓冲的内容。<li>禁用模板缓冲的写入。<li>渲染（其它）物体，这次根据模板缓冲的内容丢弃特定的片段。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=built_in>glEnable</span>(GL_STENCIL_TEST);</span><br><span class=line><span class=built_in>glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);</span><br></pre></table></figure><p>和深度测试的glDepthMask函数一样，模板缓冲也有一个类似的函数。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=built_in>glStencilMask</span>(<span class=number>0xFF</span>); <span class=comment>// 每一位写入模板缓冲时都保持原样</span></span><br><span class=line><span class=built_in>glStencilMask</span>(<span class=number>0x00</span>); <span class=comment>// 每一位在写入模板缓冲时都会变成0（禁用写入）</span></span><br></pre></table></figure><p>glStencilMask允许我们设置一个位掩码(Bitmask)，它会与将要写入缓冲的模板值进行与(AND)运算。默认情况下设置的位掩码所有位都为1，不影响输出，但如果我们将它设置为<code>0x00</code>，写入缓冲的所有模板值最后都会变成0.这与深度测试中的glDepthMask(GL_FALSE)是等价的<h3 id=模板函数><a class=headerlink href=#模板函数 title=模板函数></a>模板函数</h3><p>一共有两个函数能够用来配置模板测试：glStencilFunc和glStencilOp<p>glStencilFunc(GLenum func, GLint ref, GLuint mask)一共包含三个参数：<ul><li><code>func</code>：设置模板测试函数(Stencil Test Function)。这个测试函数将会应用到已储存的模板值上和glStencilFunc函数的<code>ref</code>值上。可用的选项有：GL_NEVER、GL_LESS、GL_LEQUAL、GL_GREATER、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL和GL_ALWAYS。它们的语义和深度缓冲的函数类似。<li><code>ref</code>：设置了模板测试的参考值(Reference Value)。模板缓冲的内容将会与这个值进行比较。<li><code>mask</code>：设置一个掩码，它将会与参考值和储存的模板值在测试比较它们之前进行与(AND)运算。初始情况下所有位都为1</ul><p>如何更新缓冲就需要glStencilOp函数<p>glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)一共包含三个选项，能够设定每个选项应该采取的行为：<ul><li><code>sfail</code>：模板测试失败时采取的行为。<li><code>dpfail</code>：模板测试通过，但深度测试失败时采取的行为。<li><code>dppass</code>：模板测试和深度测试都通过时采取的行为。</ul><div class=table-container><table><thead><tr><th style=text-align:left>行为<th style=text-align:left>描述<tbody><tr><td style=text-align:left>GL_KEEP<td style=text-align:left>保持当前储存的模板值<tr><td style=text-align:left>GL_ZERO<td style=text-align:left>将模板值设置为0<tr><td style=text-align:left>GL_REPLACE<td style=text-align:left>将模板值设置为glStencilFunc函数设置的<code>ref</code>值<tr><td style=text-align:left>GL_INCR<td style=text-align:left>如果模板值小于最大值则将模板值加1<tr><td style=text-align:left>GL_INCR_WRAP<td style=text-align:left>与GL_INCR一样，但如果模板值超过了最大值则归零<tr><td style=text-align:left>GL_DECR<td style=text-align:left>如果模板值大于最小值则将模板值减1<tr><td style=text-align:left>GL_DECR_WRAP<td style=text-align:left>与GL_DECR一样，但如果模板值小于0则将其设置为最大值<tr><td style=text-align:left>GL_INVERT<td style=text-align:left>按位翻转当前的模板缓冲值</table></div><p>默认情况下glStencilOp是设置为<code>(GL_KEEP, GL_KEEP, GL_KEEP)</code>的，所以不论任何测试的结果是如何，模板缓冲都会保留它的值。默认的行为不会更新模板缓冲，所以如果你想写入模板缓冲的话，你需要至少对其中一个选项设置不同的值。<p>通过使用glStencilFunc和glStencilOp，我们可以精确地指定更新模板缓冲的时机与行为了，我们也可以指定什么时候该让模板缓冲通过，即什么时候片段需要被丢弃<h3 id=物体轮廓><a class=headerlink href=#物体轮廓 title=物体轮廓></a>物体轮廓</h3><p>模板测试的一个重要应用就是人为选择需要绘制的区域. 如果要绘制一个物体的轮廓,画这个物体时更新模板缓冲为1,然后画一个更大的物体,设置模板缓冲函数,让模板测试是不等于1的位置. 则只会显示轮廓区域.<p>重要的几点:<ol><li>先进行模板测试后进行深度测试. 在这两个测试都开启时且不使用glDepthMask则在后面的物体是无法通过模板函数显示在前面的<li>模板测试的glStencilFunc设置的是模板测试成功条件,也就是怎样才能显示图形以及显示哪一部分图形. 比如设置当模板缓冲的值大于1时则模板测试通过. glStencilOp设置的是如何更新模板缓冲.</ol><p>注意:<ol><li>模板掩码(Stencil Mask)对 glClear 的影响:</ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>// 设置模板掩码</span></span><br><span class=line><span class=built_in>glStencilMask</span>(<span class=number>0xFF</span>);  <span class=comment>// 允许写入所有位</span></span><br><span class=line><span class=built_in>glClear</span>(GL_STENCIL_BUFFER_BIT);  <span class=comment>// 正常清除</span></span><br><span class=line></span><br><span class=line><span class=built_in>glStencilMask</span>(<span class=number>0x00</span>);  <span class=comment>// 禁止写入</span></span><br><span class=line><span class=built_in>glClear</span>(GL_STENCIL_BUFFER_BIT);  <span class=comment>// 不会清除模板缓冲</span></span><br></pre></table></figure><ol><li>清除模板缓冲区的值设置:</ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>// 设置清除值</span></span><br><span class=line><span class=built_in>glClearStencil</span>(<span class=number>1</span>);  <span class=comment>// 设置清除值为1</span></span><br><span class=line><span class=built_in>glClear</span>(GL_STENCIL_BUFFER_BIT);  <span class=comment>// 用1填充模板缓冲区</span></span><br><span class=line></span><br><span class=line><span class=comment>// 多缓冲区同时清除</span></span><br><span class=line><span class=built_in>glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);</span><br></pre></table></figure><ol><li><p>```c++<br>// 错误示范<br>glStencilMask(0x00);<br>glClear(GL_STENCIL_BUFFER_BIT); // 无效的清除</p> <p>// 正确做法<br>glStencilMask(0xFF); // 确保清除前设置正确的掩码<br>glClear(GL_STENCIL_BUFFER_BIT);<br>glStencilMask(0x00); // 之后再改回所需的掩码值</p> <figure class="highlight glsl"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line></span><br><span class=line><span class=meta>## 混合</span></span><br><span class=line></span><br><span class=line>​	OpenGL中，混合(Blending)通常是实现物体透明度(Transparency)的一种技术。透明就是说一个物体（或者其中的一部分）不是纯色(Solid Color)的，它的颜色是物体本身的颜色和它背后其它物体的颜色的不同强度结合。</span><br><span class=line></span><br><span class=line>​	**一个有色玻璃窗是一个透明的物体，玻璃有它自己的颜色，但它最终的颜色还包含了玻璃之后所有物体的颜色**。这也是混合这一名字的出处，混合(Blend)（不同物体的）多种颜色为一种颜色。所以透明度能让我们看穿物体。 Alpha通道表示不透明度,值越大越不透明.</span><br><span class=line></span><br><span class=line><span class=meta>### 丢弃片段</span></span><br><span class=line></span><br><span class=line>如果你有一个纹理，其中某些部分是完全透明的，你可以根据纹理的颜色 alpha 分量来决定是否丢弃片段。例如，对于 alpha 值小于某个阈值的片段，你可以选择将其丢弃，从而实现不规则形状的物体渲染。</span><br><span class=line></span><br><span class=line>此外,有时你可能想要根据一些条件裁剪掉不需要的部分。比如，在绘制树叶或草地的时候，可能会根据距离相机的距离或者其他条件来决定是否绘制特定的片段。</span><br><span class=line></span><br><span class=line>加载纹理之后,如果纹理带有alpha通道,可以通过通道值选择是否渲染这个片段. </span><br><span class=line></span><br><span class=line>```glsl</span><br><span class=line><span class=meta>#version 330 core</span></span><br><span class=line><span class=keyword>out</span> <span class=type>vec4</span> FragColor;</span><br><span class=line></span><br><span class=line><span class=keyword>in</span> <span class=type>vec2</span> TexCoords;</span><br><span class=line></span><br><span class=line><span class=keyword>uniform</span> <span class=type>sampler2D</span> texture1;</span><br><span class=line></span><br><span class=line><span class=type>void</span> main()</span><br><span class=line>{             </span><br><span class=line>    <span class=type>vec4</span> texColor = <span class=built_in>texture</span>(texture1, TexCoords);</span><br><span class=line>    <span class=keyword>if</span>(texColor.a < <span class=number>0.1</span>)</span><br><span class=line>        <span class=keyword>discard</span>;</span><br><span class=line>    FragColor = texColor;</span><br><span class=line>}</span><br></pre></table></figure></ol><p>设置距离丢弃条件,太远就丢弃<figure class="highlight glsl"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=meta>#version 400 core</span></span><br><span class=line><span class=keyword>in</span> <span class=type>vec2</span>  TextCoord;</span><br><span class=line><span class=keyword>in</span> <span class=type>vec3</span> Normal;</span><br><span class=line><span class=keyword>in</span> <span class=type>vec3</span> FragPos;</span><br><span class=line><span class=keyword>uniform</span> <span class=type>vec3</span> viewPos;</span><br><span class=line><span class=keyword>out</span> <span class=type>vec4</span> FragColor;</span><br><span class=line><span class=keyword>uniform</span> <span class=type>sampler2D</span> texture1;</span><br><span class=line><span class=type>void</span> main(){</span><br><span class=line>    <span class=type>vec4</span> textColor = <span class=built_in>texture</span>(texture1,TextCoord);</span><br><span class=line>    <span class=keyword>if</span> (textColor.a < <span class=number>0.1</span>) {</span><br><span class=line>        <span class=keyword>discard</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=type>float</span> dis = <span class=built_in>distance</span>(FragPos,viewPos);</span><br><span class=line>    <span class=keyword>if</span>(dis> <span class=number>15.0</span>){</span><br><span class=line>        <span class=keyword>discard</span>;</span><br><span class=line>    }</span><br><span class=line>    FragColor = textColor;</span><br><span class=line>}</span><br></pre></table></figure><p>注意，当采样纹理的边缘的时候，OpenGL<strong>会对边缘的值和纹理下一个重复的值进行插值</strong>（因为我们将它的环绕方式设置为了GL_REPEAT。这通常是没问题的，但是由于我们使用了透明值，纹理图像的顶部将会与底部边缘的纯色值进行插值。这样的结果是一个半透明的有色边框，你可能会看见它环绕着你的纹理四边形。要想避免这个，每当你alpha纹理的时候，请将纹理的环绕方式设置为GL_CLAMP_TO_EDGE：<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=built_in>glTexParameteri</span>( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class=line><span class=built_in>glTexParameteri</span>( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br></pre></table></figure><h3 id=混合><a class=headerlink href=#混合 title=混合></a>混合</h3><p>虽然直接丢弃片段很好，但它不能让我们渲染半透明的图像。我们要么渲染一个片段，要么完全丢弃它。要想渲染有多个透明度级别的图像，我们需要启用混合(Blending)。和OpenGL大多数的功能一样，可以启用GL_BLEND来启用混合<p>OpenGL中的混合是通过下面这个方程来实现的：</p><script type="math/tex; mode=display">
\bar{C}_{\text {result }}=\bar{C}_{\text {source }} * F_{\text {source }}+\bar{C}_{\text {destination }} * F_{\text {destination }}</script><p><img alt=img data-src=https://learnopengl-cn.github.io/img/04/03/blending_equation_mixed.png><ul><li>C_source：源颜色向量。这是<strong>源自纹理的颜色向量</strong>。<li>C_destination：目标颜色向量。这是<strong>当前储存在颜色缓冲中的颜色向量</strong>。<li>F_source：源因子值。指定了alpha值对源颜色的影响。<li>F_destination：目标因子值。指定了alpha值对目标颜色的影响</ul><p>使用<code>glBlendFunc</code>设置因子值,glBlendFunc(GLenum sfactor, GLenum dfactor)函数接受两个参数，来设置源和目标因子。OpenGL为我们定义了很多个选项，我们将在下面列出大部分最常用的选项。注意常数颜色向量C¯constantC¯constant可以通过glBlendColor函数来另外设置。<div class=table-container><table><thead><tr><th style=text-align:left>选项<th style=text-align:left>值<tbody><tr><td style=text-align:left><code>GL_ZERO</code><td style=text-align:left>因子等于00<tr><td style=text-align:left><code>GL_ONE</code><td style=text-align:left>因子等于11<tr><td style=text-align:left><code>GL_SRC_COLOR</code><td style=text-align:left>因子等于源颜色向量C¯sourceC¯source<tr><td style=text-align:left><code>GL_ONE_MINUS_SRC_COLOR</code><td style=text-align:left>因子等于1−C¯source1−C¯source<tr><td style=text-align:left><code>GL_DST_COLOR</code><td style=text-align:left>因子等于目标颜色向量C¯destinationC¯destination<tr><td style=text-align:left><code>GL_ONE_MINUS_DST_COLOR</code><td style=text-align:left>因子等于1−C¯destination1−C¯destination<tr><td style=text-align:left><code>GL_SRC_ALPHA</code><td style=text-align:left>因子等于C¯sourceC¯source的alphaalpha分量<tr><td style=text-align:left><code>GL_ONE_MINUS_SRC_ALPHA</code><td style=text-align:left>因子等于1−1− C¯sourceC¯source的alphaalpha分量<tr><td style=text-align:left><code>GL_DST_ALPHA</code><td style=text-align:left>因子等于C¯destinationC¯destination的alphaalpha分量<tr><td style=text-align:left><code>GL_ONE_MINUS_DST_ALPHA</code><td style=text-align:left>因子等于1−1− C¯destinationC¯destination的alphaalpha分量<tr><td style=text-align:left><code>GL_CONSTANT_COLOR</code><td style=text-align:left>因子等于常数颜色向量C¯constantC¯constant<tr><td style=text-align:left><code>GL_ONE_MINUS_CONSTANT_COLOR</code><td style=text-align:left>因子等于1−C¯constant1−C¯constant<tr><td style=text-align:left><code>GL_CONSTANT_ALPHA</code><td style=text-align:left>因子等于C¯constantC¯constant的alphaalpha分量<tr><td style=text-align:left><code>GL_ONE_MINUS_CONSTANT_ALPHA</code><td style=text-align:left>因子等于1−1− C¯constantC¯constant的alphaalpha分量</table></div><p>注意常数颜色向量C_constant可以通过glBlendColor函数来另外设置。<p>为了获得之前两个方形的混合结果，我们需要使用源颜色向量的alpha作为源因子，使用1−alpha作为目标因子。这将会产生以下的glBlendFunc：<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br></pre></table></figure><p>也可以使用glBlendFuncSeparate为RGB和alpha通道分别设置不同的选项：<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>glBlendFuncSeparate</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);</span><br></pre></table></figure><p>允许我们改变方程中源和目标部分的运算符。当前源和目标是相加的，但如果愿意的话，我们也可以让它们相减。glBlendEquation(GLenum mode)允许我们设置运算符，它提供了三个选项：<ul><li>GL_FUNC_ADD：默认选项，将两个分量相加：<li>GL_FUNC_SUBTRACT：将两个分量相减：<li>GL_FUNC_REVERSE_SUBTRACT：将两个分量相减，但顺序相反：</ul><p>通常都可以省略调用glBlendEquation<h3 id=渲染半透明纹理><a class=headerlink href=#渲染半透明纹理 title=渲染半透明纹理></a>渲染半透明纹理</h3><p>初始化时我们启用混合，并设定相应的混合函数：<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=built_in>glEnable</span>(GL_BLEND);</span><br><span class=line><span class=built_in>glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br></pre></table></figure><p>由于启用了混合，我们就不需要丢弃片段了，所以我们把片段着色器还原：<figure class="highlight glsl"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>#version 330 core</span></span><br><span class=line><span class=keyword>out</span> <span class=type>vec4</span> FragColor;</span><br><span class=line></span><br><span class=line><span class=keyword>in</span> <span class=type>vec2</span> TexCoords;</span><br><span class=line></span><br><span class=line><span class=keyword>uniform</span> <span class=type>sampler2D</span> texture1;</span><br><span class=line></span><br><span class=line><span class=type>void</span> main()</span><br><span class=line>{             </span><br><span class=line>    FragColor = <span class=built_in>texture</span>(texture1, TexCoords);</span><br><span class=line>}</span><br></pre></table></figure><p>但是可能跟绘图顺序有关.深度测试和混合一起使用的话会产生一些麻烦。当<strong>写入深度缓冲时，深度缓冲不会检查片段是否是透明的，所以透明的部分会和其它值一样写入到深度缓冲中</strong>。结果就是窗户的整个四边形不论透明度都会进行深度测试。即使透明的部分应该显示背后的窗户，深度测试仍然丢弃了它们。 也就是说<p>要想保证窗户中能够显示它们背后的物体，我们需要首先绘制背后的这部分物体。这也就是说在绘制的时候，必须先手动将窗户按照最远到最近来排序，再按照顺序渲染.<blockquote><p>注意，对于草这种全透明的物体，可以选择丢弃透明的片段而不是混合它们，这样就解决了这些头疼的问题（没有深度问题）</blockquote><h3 id=不要打扰顺序><a class=headerlink href=#不要打扰顺序 title=不要打扰顺序></a>不要打扰顺序</h3><p>​ <strong>要想让混合在多个物体上工作，需要最先绘制最远的物体，最后绘制最近的物体</strong>。<p>​ 普通<strong>不需要混合的物体仍然可以使用深度缓冲正常绘制，所以它们不需要排序</strong>。但<strong>仍要保证它们在绘制（排序的）透明物体之前已经绘制完毕了</strong>。当绘制一个有不透明和透明物体的场景的时候，大体的原则如下：<ol><li><p>先绘制所有不透明的物体。</p><li><p>对所有透明的物体排序。</p><li><p>按顺序绘制所有透明的物体</p></ol><p>​ 排序透明物体的一种方法是，<strong>从观察者视角获取物体的距离。这可以通过计算摄像机位置向量和物体的位置向量之间的距离所获得</strong>。<p>​ 接下来把距离和它对应的位置向量存储到一个STL库的map数据结构中。map会自动根据键值(Key)对它的值排序，所以只要添加了所有的位置，并以它的距离作为键，它们就会自动根据距离值排序了。<p>​ 在渲染的时候以逆序（从远到近）从map中获取值，之后以正确的顺序绘制对应的窗户.<p>​ 虽然按照距离排序物体这种方法对这个场景能够正常工作，<strong>但它并没有考虑旋转、缩放或者其它的变换，奇怪形状的物体需要一个不同的计量，而不是仅仅一个位置向量。</strong><p>​ 在场景中排序物体是一个很困难的技术，很大程度上由场景的类型所决定，更别说它额外需要消耗的处理能力了。<strong>完整渲染一个包含不透明和透明物体的场景并不是那么容易。更高级的技术还有次序无关透明度</strong>(Order Independent Transparency, OIT)<h2 id=面剔除><a class=headerlink href=#面剔除 title=面剔除></a>面剔除</h2><p>想象任何一个闭合形状，它的每一个面都有两侧，每一侧要么<strong>面向</strong>用户，要么背对用户。如果我们能够只绘制<strong>面向</strong>观察者的面呢？<p>这正是面剔除(Face Culling)所做的。OpenGL能够检查所有面向(Front Facing)观察者的面，并渲染它们，而丢弃那些背向(Back Facing)的面，节省我们很多的片段着色器调用（它们的开销很大！）。但仍要告诉OpenGL哪些面是正向面(Front Face)，哪些面是背向面(Back Face)。OpenGL使用了一个很聪明的技巧，<strong>分析顶点数据的环绕顺序(Winding Order)。</strong><h4 id=环绕顺序><a class=headerlink href=#环绕顺序 title=环绕顺序></a>环绕顺序</h4><p>当我们定义一组三角形顶点时，我们会以特定的环绕顺序来定义它们，可能是顺时针(Clockwise)的，也可能是逆时针(Counter-clockwise)的。每个三角形由3个顶点所组成，会从三角形中间来看，为这3个顶点设定一个环绕顺序。<p><strong>每组组成三角形图元的三个顶点就包含了一个环绕顺序</strong>。OpenGL在渲染图元的时候将使用这个信息来决定一个三角形是一个正向三角形还是背向三角形。<p><strong>默认情况下，逆时针顶点所定义的三角形将会被处理为正向三角形。</strong>当你定义顶点顺序的时候，你应该想象对应的三角形是面向你的，所以你定义的三角形从正面看去应该是逆时针的。这样定义顶点很棒的一点是，实际的环绕顺序是在光栅化阶段进行的，也就是顶点着色器运行之后。这些顶点就是从<strong>观察者视角</strong>所见的了。<h4 id=面剔除-1><a class=headerlink href=#面剔除-1 title=面剔除></a>面剔除</h4><p>OpenGL能够丢弃那些渲染为背向三角形的三角形图元。既然已经知道如何设置顶点的环绕顺序了，我们就可以使用OpenGL的面剔除选项了，它默认是禁用状态的。<p>在之前教程中使用的立方体顶点数据并不是按照逆时针环绕顺序定义的，所以顶点数据反映了环绕顺序从而反应是正向面和背向面.<p>要想启用面剔除，我们只需要启用OpenGL的GL_CULL_FACE选项：<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>glEnable</span>(GL_CULL_FACE);</span><br></pre></table></figure><p>从这一句代码之后，所有背向面都将被丢弃（尝试飞进立方体内部，看看所有的内面是不是都被丢弃了）。目前我们在渲染片段的时候能够节省50%以上的性能，但注意这只对像立方体这样的封闭形状有效。<p>OpenGL允许我们改变需要剔除的面的类型。我们可以调用glCullFace来定义这一行为：<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>glCullFace</span>(GL_FRONT);</span><br></pre></table></figure><p>glCullFace函数有三个可用的选项：<ul><li><code>GL_BACK</code>：只剔除背向面。<li><code>GL_FRONT</code>：只剔除正向面。<li><code>GL_FRONT_AND_BACK</code>：剔除正向面和背向面。</ul><p>glCullFace的初始值是GL_BACK。除了需要剔除的面之外，也可以通过调用glFrontFace，告诉OpenGL我们希望将顺时针的面（而不是逆时针的面）定义为正向面：<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>glFrontFace</span>(GL_CCW);</span><br></pre></table></figure><p>默认值是GL_CCW，它代表的是逆时针的环绕顺序，另一个选项是GL_CW，它（显然）代表的是顺时针顺序。<p>我们可以来做一个实验，告诉OpenGL现在顺时针顺序代表的是正向面：<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=built_in>glEnable</span>(GL_CULL_FACE);</span><br><span class=line><span class=built_in>glCullFace</span>(GL_BACK);</span><br><span class=line><span class=built_in>glFrontFace</span>(GL_CW);</span><br></pre></table></figure><h2 id=帧缓冲><a class=headerlink href=#帧缓冲 title=帧缓冲></a>帧缓冲</h2><p>​ 现在已经使用了很多屏幕缓冲了：用于<strong>写入颜色值的颜色缓冲</strong>、用于<strong>写入深度信息的深度缓冲</strong>和允许我们<strong>根据一些条件丢弃特定片段的模板缓冲</strong>。这些缓冲<strong>结合起来叫做帧缓冲(</strong>Framebuffer)<p>​ 它被<strong>储存在GPU内存</strong>中的某处。<strong>OpenGL允许我们定义我们自己的帧缓冲，也就是说能够定义我们自己的颜色缓冲，甚至是深度缓冲和模板缓冲</strong>。<p>​ 目前所做的<strong>所有操作都是在默认帧缓冲的渲染缓冲上进行的</strong>。默认的帧缓冲是在你创建窗口的时候生成和配置的（GLFW帮我们做了这些）。通过创建自己的帧缓冲，我们可以获得额外的渲染目标(target)。<p>渲染你的场景到不同的帧缓冲能够让我们在场景中加入类似镜子的东西，或者做出很酷的后期处理效果<h4 id=创建帧缓冲><a class=headerlink href=#创建帧缓冲 title=创建帧缓冲></a>创建帧缓冲</h4><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>Gluint fbo;</span><br><span class=line><span class=built_in>glGenFramebuffers</span>(<span class=number>1</span>,&fbo);</span><br><span class=line><span class=built_in>glBindFrameBuffer</span>(GL_FRAMEBUFFER，fbo);</span><br></pre></table></figure><p>在绑定到GL_FRAMEBUFFER目标之后，所有的<strong>读取</strong>和<strong>写入</strong>帧缓冲的操作将会影响当前绑定的帧缓冲。<strong>也可以使用GL_READ_FRAMEBUFFER或GL_DRAW_FRAMEBUFFER，将一个帧缓冲分别绑定到读取目标或写入目标</strong>。绑定到GL_READ_FRAMEBUFFER的帧缓冲将会使用在所有像是glReadPixels的读取操作中，而绑定到GL_DRAW_FRAMEBUFFER的帧缓冲将会被用作渲染、清除等写入操作的目标。大部分情况你都不需要区分它们，通常都会使用GL_FRAMEBUFFER，绑定到两个上<p>一个完整的帧缓冲需要满足以下的条件：<ul><li>附加至少一个缓冲（颜色、深度或模板缓冲）。<li>至少有一个颜色附件(Attachment)。<li>所有的附件都必须是完整的（保留了内存）。<li>每个缓冲都应该有相同的样本数(sample)</ul><p>​ 需要为帧缓冲创建一些附件，并将附件附加到帧缓冲上。在完成所有的条件之后，我们可以以GL_FRAMEBUFFER为参数调用glCheckFramebufferStatus，检查帧缓冲是否完整。它将会检测当前绑定的帧缓冲，并返回规范中这些值的其中之一。如果它返回的是GL_FRAMEBUFFER_COMPLETE，帧缓冲就是完整的了<p>​ <strong>之后所有的渲染操作将会渲染到当前绑定帧缓冲的附件中</strong>。由于帧缓冲不是默认帧缓冲，<strong>渲染指令将不会对窗口的视觉输出有任何影响</strong>。出于这个原因，<strong>渲染到一个不同的帧缓冲被叫做离屏渲染(Off-screen Rendering)。要保证所有的渲染操作在主窗口中有视觉效果，我们需要再次激活默认帧缓冲，将它绑定到<code>0</code>。</strong><p>​ 在完整性检查执行之前，<strong>需要给帧缓冲附加一个附件。附件是一个内存位置，它能够作为帧缓冲的一个缓冲</strong>，可以将它想象为一个图像。当创建一个附件的时候我们有两个选项：纹理或渲染缓冲对象(Renderbuffer Object)。<h4 id=纹理附件><a class=headerlink href=#纹理附件 title=纹理附件></a>纹理附件</h4><p>想象帧缓冲(FBO)是一个画框，纹理附件就是可以放进这个画框的”画布”。这些”画布”可以用来：<ul><li>存储颜色(类似照片)<li>存储深度(物体的远近信息)<li>存储模板值(用于特效)</ul><p>当把一个纹理附加到帧缓冲的时候，所有的渲染指令将会写入到这个纹理中，就像它是一个普通的颜色/深度或模板缓冲一样。使用纹理的优点是，<strong>所有渲染操作的结果将会被储存在一个纹理图像中，之后可以在着色器中很方便地使用它。</strong><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> texture;</span><br><span class=line><span class=built_in>glGenTextures</span>(<span class=number>1</span>,&texture);</span><br><span class=line><span class=built_in>glBindTexture</span>(GL_TEXTURE_2D,texture);</span><br><span class=line><span class=built_in>glTexImage2D</span>(GL_TEXTURE_2D,<span class=number>0</span>,GL_RGB,<span class=number>800</span>,<span class=number>600</span>,<span class=number>0</span>,GL_RGB,GL_UNSIGNED_BYTE,<span class=literal>NULL</span>);</span><br><span class=line><span class=built_in>glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=line><span class=built_in>glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class=line><span class=comment>// 添加颜色纹理附件</span></span><br><span class=line><span class=built_in>glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, <span class=number>0</span>);</span><br></pre></table></figure><p>对于深度和模板缓冲格式不同<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=built_in>glTexImage2D</span>(GL_TEXTURE_2D,<span class=number>0</span>,GL_DEPTH_COMPONENT,<span class=number>800</span>,<span class=number>600</span>,<span class=number>0</span>,GL_DEPTH_COMPONENT,GL_UNSIGNED_BYTE,<span class=literal>NULL</span>);</span><br><span class=line><span class=comment>// 添加深度纹理附件</span></span><br><span class=line><span class=built_in>glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, texture, <span class=number>0</span>);</span><br></pre></table></figure><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=built_in>glTexImage2D</span>(GL_TEXTURE_2D,<span class=number>0</span>,GL_STENCIL_INDEX,<span class=number>800</span>,<span class=number>600</span>,<span class=number>0</span>,GL_STENCIL_INDEX,GL_UNSIGNED_BYTE,<span class=literal>NULL</span>);</span><br><span class=line><span class=comment>// 添加模板纹理附件</span></span><br><span class=line><span class=built_in>glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, <span class=number>0</span>);</span><br></pre></table></figure><h4 id=渲染缓冲对象附件><a class=headerlink href=#渲染缓冲对象附件 title=渲染缓冲对象附件></a>渲染缓冲对象附件</h4><p>​ 和纹理图像一样，渲染缓冲对象是一个真正的缓冲，即一系列的字节、整数、像素等。渲染缓冲对象附加的好处是，<strong>它会将数据储存为OpenGL原生的渲染格式，它是为离屏渲染到帧缓冲优化过的。</strong><p>​ <strong>渲染缓冲对象直接将所有的渲染数据储存到它的缓冲中，不会做任何针对纹理格式的转换，让它变为一个更快的可写储存介质。</strong>然而，渲染缓冲对象通常都是只写的，所以你不能读取它们（比如使用纹理访问）。当然你仍然还是能够使用glReadPixels来读取它，这会从当前绑定的帧缓冲，而不是附件本身，中返回特定区域的像素。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> rbo;</span><br><span class=line><span class=built_in>glGenRenderbuffers</span>(<span class=number>1</span>,&rbo);</span><br><span class=line><span class=built_in>glBindRenderbuffer</span>(GL_RENDERBUFFER,rbo);</span><br><span class=line><span class=built_in>glRenderbufferStorage</span>(GL_RENDERBUFFER,GL_DEPTH24_STENCIL8,<span class=number>800</span>,<span class=number>600</span>);</span><br><span class=line><span class=built_in>glFramebufferRenderbuffer</span>(GL_FRAMEBUFFER,GL_DEPTH_STENCIL_ATTACHMENT,GL_RENDERBUFFER,rbo);</span><br></pre></table></figure><p>由于<strong>渲染缓冲对象通常都是只写的，它们会经常用于深度和模板附件，因为大部分时间都不需要从深度和模板缓冲中读取值</strong>，只关心深度和模板测试。我们<strong>需要</strong>深度和模板值用于测试，但不需要对它们进行<strong>采样</strong>，所以渲染缓冲对象非常适合它们。当我们不需要从这些缓冲中采样的时候，通常都会选择渲染缓冲对象，因为它会更优化一点。<h4 id=渲染到纹理><a class=headerlink href=#渲染到纹理 title=渲染到纹理></a>渲染到纹理</h4><p>要想绘制场景到一个纹理上，我需要采取以下的步骤：<ol><li>将新的帧缓冲绑定为激活的帧缓冲，和往常一样渲染场景<li>绑定默认的帧缓冲<li>绘制一个横跨整个屏幕的四边形，将帧缓冲的颜色缓冲作为它的纹理。</ol><p>将帧缓冲的颜色渲染到默认缓冲的纹理上<h4 id=反相><a class=headerlink href=#反相 title=反相></a>反相</h4><p>将纹理颜色反相<figure class="highlight glsl"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=type>void</span> main()</span><br><span class=line>{</span><br><span class=line>    FragColor = <span class=type>vec4</span>(<span class=type>vec3</span>(<span class=number>1.0</span> - <span class=built_in>texture</span>(screenTexture, TexCoords)), <span class=number>1.0</span>);</span><br><span class=line>}</span><br></pre></table></figure><h4 id=灰度><a class=headerlink href=#灰度 title=灰度></a>灰度</h4><figure class="highlight glsl"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=type>void</span> main()</span><br><span class=line>{</span><br><span class=line>    FragColor = <span class=built_in>texture</span>(screenTexture, TexCoords);</span><br><span class=line>    <span class=type>float</span> average = <span class=number>0.2126</span> * FragColor.r + <span class=number>0.7152</span> * FragColor.g + <span class=number>0.0722</span> * FragColor.b;</span><br><span class=line>    FragColor = <span class=type>vec4</span>(average, average, average, <span class=number>1.0</span>);</span><br><span class=line>}</span><br></pre></table></figure><h4 id=核效果><a class=headerlink href=#核效果 title=核效果></a>核效果</h4><figure class="highlight glsl"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br></pre><td class=code><pre><span class=line><span class=keyword>const</span> <span class=type>float</span> <span class=keyword>offset</span> = <span class=number>1.0</span> / <span class=number>300.0</span>;  </span><br><span class=line></span><br><span class=line><span class=type>void</span> main()</span><br><span class=line>{</span><br><span class=line>    <span class=type>vec2</span> offsets[<span class=number>9</span>] = <span class=type>vec2</span>[](</span><br><span class=line>        <span class=type>vec2</span>(-<span class=keyword>offset</span>,  <span class=keyword>offset</span>), <span class=comment>// 左上</span></span><br><span class=line>        <span class=type>vec2</span>( <span class=number>0.0</span>f,    <span class=keyword>offset</span>), <span class=comment>// 正上</span></span><br><span class=line>        <span class=type>vec2</span>( <span class=keyword>offset</span>,  <span class=keyword>offset</span>), <span class=comment>// 右上</span></span><br><span class=line>        <span class=type>vec2</span>(-<span class=keyword>offset</span>,  <span class=number>0.0</span>f),   <span class=comment>// 左</span></span><br><span class=line>        <span class=type>vec2</span>( <span class=number>0.0</span>f,    <span class=number>0.0</span>f),   <span class=comment>// 中</span></span><br><span class=line>        <span class=type>vec2</span>( <span class=keyword>offset</span>,  <span class=number>0.0</span>f),   <span class=comment>// 右</span></span><br><span class=line>        <span class=type>vec2</span>(-<span class=keyword>offset</span>, -<span class=keyword>offset</span>), <span class=comment>// 左下</span></span><br><span class=line>        <span class=type>vec2</span>( <span class=number>0.0</span>f,   -<span class=keyword>offset</span>), <span class=comment>// 正下</span></span><br><span class=line>        <span class=type>vec2</span>( <span class=keyword>offset</span>, -<span class=keyword>offset</span>)  <span class=comment>// 右下</span></span><br><span class=line>    );</span><br><span class=line></span><br><span class=line>    <span class=type>float</span> kernel[<span class=number>9</span>] = <span class=type>float</span>[](</span><br><span class=line>        <span class=number>-1</span>, <span class=number>-1</span>, <span class=number>-1</span>,</span><br><span class=line>        <span class=number>-1</span>,  <span class=number>9</span>, <span class=number>-1</span>,</span><br><span class=line>        <span class=number>-1</span>, <span class=number>-1</span>, <span class=number>-1</span></span><br><span class=line>    );</span><br><span class=line></span><br><span class=line>    <span class=type>vec3</span> sampleTex[<span class=number>9</span>];</span><br><span class=line>    <span class=keyword>for</span>(<span class=type>int</span> i = <span class=number>0</span>; i < <span class=number>9</span>; i++)</span><br><span class=line>    {</span><br><span class=line>        sampleTex[i] = <span class=type>vec3</span>(<span class=built_in>texture</span>(screenTexture, TexCoords.st + offsets[i]));</span><br><span class=line>    }</span><br><span class=line>    <span class=type>vec3</span> col = <span class=type>vec3</span>(<span class=number>0.0</span>);</span><br><span class=line>    <span class=keyword>for</span>(<span class=type>int</span> i = <span class=number>0</span>; i < <span class=number>9</span>; i++)</span><br><span class=line>        col += sampleTex[i] * kernel[i];</span><br><span class=line></span><br><span class=line>    FragColor = <span class=type>vec4</span>(col, <span class=number>1.0</span>);</span><br><span class=line>}</span><br></pre></table></figure><p>此外还有模糊、边缘检测等效果,都是利用卷积核.<h2 id=立方体贴图><a class=headerlink href=#立方体贴图 title=立方体贴图></a>立方体贴图</h2><p>立方体贴图(Cube Map)是将多个纹理组合起来映射到一张纹理上的一种纹理类型.<p>立方体贴图的坐标至关重要,通过一个方向向量进行索引. 方向向量原点位于立方体中心<p><img alt=img data-src=https://learnopengl-cn.github.io/img/04/06/cubemaps_sampling.png><p>假设将这样的立方体贴图应用到一个立方体上，采样立方体贴图所使用的方向向量将和立方体（插值的）顶点位置非常相像。这样子，只要立方体的中心位于原点，我们就能使用立方体的实际位置向量来对立方体贴图进行采样了。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> textureID;</span><br><span class=line><span class=built_in>glGenTextures</span>(<span class=number>1</span>, &textureID);</span><br><span class=line><span class=built_in>glBindTexture</span>(GL_TEXTURE_CUBE_MAP, textureID);</span><br><span class=line></span><br><span class=line><span class=keyword>int</span> width, height, nrChannels;</span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>char</span> *data;  </span><br><span class=line><span class=keyword>for</span>(<span class=keyword>unsigned</span> <span class=keyword>int</span> i = <span class=number>0</span>; i < textures_faces.<span class=built_in>size</span>(); i++)</span><br><span class=line>{</span><br><span class=line>    data = <span class=built_in>stbi_load</span>(textures_faces[i].<span class=built_in>c_str</span>(), &width, &height, &nrChannels, <span class=number>0</span>);</span><br><span class=line>    <span class=built_in>glTexImage2D</span>(</span><br><span class=line>        GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, </span><br><span class=line>        <span class=number>0</span>, GL_RGB, width, height, <span class=number>0</span>, GL_RGB, GL_UNSIGNED_BYTE, data</span><br><span class=line>    );</span><br><span class=line>}</span><br><span class=line><span class=built_in>glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class=line><span class=built_in>glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=line><span class=built_in>glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class=line><span class=built_in>glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class=line><span class=built_in>glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);</span><br></pre></table></figure><p>立方体纹理最常用的就是天空盒,而天空盒的核心就是将贴图用在一个立方体上并通过深度测试将贴图作为背景. 一个简单的方法就是利用<code>glDepthMask</code>,首先渲染天空盒,在绘制其他物体之前再启动Mask,更新深度缓冲.<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=built_in>glDepthMask</span>(GL_FALSE);</span><br><span class=line>skyboxShader.<span class=built_in>use</span>();</span><br><span class=line><span class=comment>// ... 设置观察和投影矩阵</span></span><br><span class=line><span class=built_in>glBindVertexArray</span>(skyboxVAO);</span><br><span class=line><span class=built_in>glBindTexture</span>(GL_TEXTURE_CUBE_MAP, cubemapTexture);</span><br><span class=line><span class=built_in>glDrawArrays</span>(GL_TRIANGLES, <span class=number>0</span>, <span class=number>36</span>);</span><br><span class=line><span class=built_in>glDepthMask</span>(GL_TRUE);</span><br><span class=line><span class=comment>// ... 绘制剩下的场景</span></span><br></pre></table></figure><p>注意到天空盒的大部分可能会被其他物体覆盖,通过提前深度测试,将已知的深度较大的物体在之后绘制,这样在片段着色器运行之前就直到被其他物体””盖住”了. 因为天空盒总是在最后,设置其z在透视变换后为1即可,在片段着色器中设置其z为w.<figure class="highlight glsl"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>vec4</span> pos = projection * view * <span class=type>vec4</span>(position, <span class=number>1.0</span>); <span class=comment>// view矩阵取消了移动,projection矩阵只对z进行了缩放,而之后通过透视除法将z设置为了1</span></span><br><span class=line>   <span class=built_in>gl_Position</span> = pos.xyww;</span><br></pre></table></figure><h3 id=环境映射><a class=headerlink href=#环境映射 title=环境映射></a>环境映射</h3><p>我们现在<strong>将整个环境映射到了一个纹理对象</strong>上了，能利用这个信息的不仅仅只有天空盒。通过使用环境的立方体贴图，<strong>可以给物体反射和折射的属性。这样使用环境立方体贴图的技术叫做环境映射</strong>(Environment Mapping)，其中最流行的两个是反射(Reflection)和折射(Refraction)。<p><img alt=img data-src=https://learnopengl-cn.github.io/img/04/06/cubemaps_reflection_theory.png><p>反射通过眼睛与物体法线向量得到的反射向量对立方体纹理采样<figure class="highlight glsl"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>uniform</span> <span class=type>vec3</span> viewPos;</span><br><span class=line><span class=keyword>uniform</span> <span class=type>samplerCube</span> skybox;</span><br><span class=line><span class=keyword>in</span> <span class=type>vec3</span> Normal;</span><br><span class=line><span class=keyword>in</span> <span class=type>vec3</span> FragPos;</span><br><span class=line><span class=type>vec3</span> CalcEnvReflectLight(<span class=type>vec3</span> viewDir,<span class=type>vec3</span> norm) {</span><br><span class=line>    <span class=keyword>return</span> <span class=type>vec3</span>(<span class=built_in>texture</span>(skybox,<span class=built_in>reflect</span>(-viewDir,norm)));</span><br><span class=line>}</span><br></pre></table></figure><p>当反射应用到一整个物体上时，这个物体看起来就像是钢或者铬这样的高反射性材质. 在现实中大部分的模型都不具有完全反射性。<strong>可以引入反射贴图(Reflection Map)，来给模型更多的细节。与漫反射和镜面光贴图一样，反射贴图也是可以采样的纹理图像，它决定这片段的反射性</strong>。通过使用反射贴图，可以知道模型的哪些部分该以什么强度显示反射。<p><img alt=image-20250105144159047 data-src=https://s2.loli.net/2025/01/05/kCJ4toqla1Vy8FL.png><p>环境映射的另一种形式是折射，它和反射很相似。折射是光线由于传播介质的改变而产生的方向变化。在常见的类水表面上所产生的现象就是折射，光线不是直直地传播，而是弯曲了一点。将你的半只胳膊伸进水里，观察出来的就是这种效果。<p><img alt=img data-src=https://learnopengl-cn.github.io/img/04/06/cubemaps_refraction_theory.png><p>折射率是光在真空中的传播速度与光在该介质中的传播速度之比,光从介质1射入介质2发生折射时，入射角与折射角的正弦之比叫做介质2相对介质1的折射率. 折射率越大,光线扭曲程度越大. 有一个观察向量I¯，一个法向量N¯，而这次是折射向量R¯。<p>观察向量的方向轻微弯曲了。弯折后的向量R¯R¯将会用来从立方体贴图中采样。折射可以使用GLSL的内建refract函数来轻松实现，它需要一个法向量、一个观察方向和两个材质之间的折射率(Refractive Index)。<p>假设看向水面,折射率就是在空气中的折射率/在水中的折射率.<p><img alt=image-20250105144121316 data-src=https://s2.loli.net/2025/01/05/qVRmaAPHS14loCg.png><h4 id=动态环境贴图><a class=headerlink href=#动态环境贴图 title=动态环境贴图></a>动态环境贴图</h4><p>​ 现在使用的都是静态图像的组合来作为天空盒，看起来很不错，但它<strong>没有在场景中包括可移动的物体</strong>。我们一直都没有注意到这一点，因为我们只使用了一个物体。如果我们有一个镜子一样的物体，周围还有多个物体，镜子中可见的只有天空盒，看起来就像它是场景中唯一一个物体一样。<p>​ <strong>通过使用帧缓冲能够为物体的6个不同角度创建出场景的纹理，并在每个渲染迭代中将它们储存到一个立方体贴图中。之后我们就可以使用这个（动态生成的）立方体贴图来创建出更真实的，包含其它物体的，反射和折射表面了。这就叫做动态环境映射(Dynamic Environment Mapping)，因为动态创建了物体周围的立方体贴图，并将其用作环境贴图。</strong><p>​ 但它有一个很大的缺点：<strong>需要为使用环境贴图的物体渲染场景6次，这是对程序是非常大的性能开销。现代的程序通常会尽可能使用天空盒，并在可能的时候使用预编译的立方体贴图</strong>，只要它们能产生一点动态环境贴图的效果。虽然动态环境贴图是一个很棒的技术，但是要想在不降低性能的情况下让它工作还是需要非常多的技巧的。<h2 id=高级数据><a class=headerlink href=#高级数据 title=高级数据></a>高级数据</h2><p>缓冲有不同的类型,比如GL_ARRAY_BUFFER,GL_ELEMENT_BUFFER. 不同缓冲有不同用处. 当<code>glGenBuffers()</code>创建缓冲对象后,需要绑定相应类型才有意义.<h3 id=填充缓冲数据><a class=headerlink href=#填充缓冲数据 title=填充缓冲数据></a>填充缓冲数据</h3><p>glBufferData函数来填充缓冲对象所管理的内存，这个函数会分配一块内存，并将数据添加到这块内存中。如果我们将它的<code>data</code>参数设置为<code>NULL</code>，那么这个函数将只会分配内存，但不进行填充。这在我们需要<strong>预留</strong>(Reserve)特定大小的内存，之后回到这个缓冲一点一点填充的时候会很有用。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=built_in>glBufferData</span>(GL_ARRAY_BUFFER,,<span class=built_in><span class=keyword>sizeof</span></span>(vertices),<span class=literal>NULL</span>,GL_STATIC_DRAW);</span><br><span class=line><span class=built_in>glBufferSubData</span>(GL_ARRAY_BUFFER,<span class=number>24</span>,<span class=built_in><span class=keyword>sizeof</span></span>(data),&data);</span><br></pre></table></figure><p>除了使用一次函数调用填充整个缓冲之外，也可以使用glBufferSubData，填充缓冲的特定区域。这个函数需要一个缓冲目标、一个偏移量、数据的大小和数据本身作为它的参数。这个函数不同的地方在于，我们可以提供一个偏移量，指定从<strong>何处</strong>开始填充这个缓冲。这能够让我们插入或者更新缓冲内存的某一部分。要注意的是，缓冲需要有足够的已分配内存，所以对一个缓冲调用glBufferSubData之前必须要先调用glBufferData。<p>此外可以获得指向内存的指针,通过一些内存函数进行操作<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>float</span> data[] = {</span><br><span class=line>  <span class=number>0.5f</span>, <span class=number>1.0f</span>, <span class=number>-0.35f</span></span><br><span class=line>  ...</span><br><span class=line>};</span><br><span class=line><span class=built_in>glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class=line><span class=comment>// 获取指针</span></span><br><span class=line><span class=keyword>void</span> *ptr = <span class=built_in>glMapBuffer</span>(GL_ARRAY_BUFFER, GL_WRITE_ONLY);</span><br><span class=line><span class=comment>// 复制数据到内存</span></span><br><span class=line><span class=built_in>memcpy</span>(ptr, data, <span class=built_in><span class=keyword>sizeof</span></span>(data));</span><br><span class=line><span class=comment>// 记得告诉OpenGL我们不再需要这个指针了</span></span><br><span class=line><span class=built_in>glUnmapBuffer</span>(GL_ARRAY_BUFFER);</span><br><span class=line></span><br><span class=line><span class=comment>// in modern c++ </span></span><br><span class=line>  <span class=keyword>auto</span> ptr = <span class=built_in>glMapBuffer</span>(GL_ARRAY_BUFFER, GL_READ_WRITE);</span><br><span class=line>  std::<span class=built_in>copy</span>(std::<span class=built_in>begin</span>(skyboxVertices), std::<span class=built_in>end</span>(skyboxVertices),</span><br><span class=line>            <span class=keyword>static_cast</span><<span class=keyword>float</span> *>(ptr));</span><br><span class=line>  <span class=built_in>glUnmapBuffer</span>(GL_ARRAY_BUFFER);</span><br></pre></table></figure><p>使用glUnmapBuffer函数，告诉OpenGL我们已经完成指针操作之后，OpenGL就会知道你已经完成了。<strong>在解除映射(Unmapping)之后，指针将会不再可用，并且如果OpenGL能够成功将您的数据映射到缓冲中，这个函数将会返回GL_TRUE</strong><h3 id=分批顶点属性><a class=headerlink href=#分批顶点属性 title=分批顶点属性></a>分批顶点属性</h3><p>假设数据如下,表示一个点的三种属性,通过glBufferData加载<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>float</span> vertices[] = {</span><br><span class=line>      <span class=comment>// positions          // normals           // texture coords</span></span><br><span class=line>      <span class=number>-0.5f</span>, <span class=number>-0.5f</span>, <span class=number>-0.5f</span>, <span class=number>0.0f</span>,  <span class=number>0.0f</span>,  <span class=number>-1.0f</span>, <span class=number>0.0f</span>,  <span class=number>0.0f</span>,  <span class=number>0.5f</span>,  <span class=number>-0.5f</span>,</span><br><span class=line>      <span class=number>-0.5f</span>, <span class=number>0.0f</span>,  <span class=number>0.0f</span>,  <span class=number>-1.0f</span>, <span class=number>1.0f</span>,  <span class=number>0.0f</span>,  <span class=number>0.5f</span>,  <span class=number>0.5f</span>,  <span class=number>-0.5f</span>, <span class=number>0.0f</span>,</span><br><span class=line>      <span class=number>0.0f</span>,  <span class=number>-1.0f</span>, <span class=number>1.0f</span>,  <span class=number>1.0f</span>,  <span class=number>0.5f</span>,  <span class=number>0.5f</span>,  <span class=number>-0.5f</span>, <span class=number>0.0f</span>,  <span class=number>0.0f</span>,  <span class=number>-1.0f</span>,</span><br><span class=line>      <span class=number>1.0f</span>,  <span class=number>1.0f</span>,  <span class=number>-0.5f</span>, <span class=number>0.5f</span>,  <span class=number>-0.5f</span>, <span class=number>0.0f</span>,  <span class=number>0.0f</span>,  <span class=number>-1.0f</span>, <span class=number>0.0f</span>,  <span class=number>1.0f</span>,</span><br><span class=line>      <span class=number>-0.5f</span>, <span class=number>-0.5f</span>, <span class=number>-0.5f</span>, <span class=number>0.0f</span>,  <span class=number>0.0f</span>,  <span class=number>-1.0f</span>, <span class=number>0.0f</span>,  <span class=number>0.0f</span>,</span><br><span class=line>}</span><br><span class=line>  <span class=built_in>glBufferData</span>(GL_ARRAY_BUFFER, <span class=built_in><span class=keyword>sizeof</span></span>(vertices), vertices, GL_STREAM_DRAW);</span><br><span class=line>  <span class=built_in>glEnableVertexAttribArray</span>(<span class=number>0</span>);</span><br><span class=line> <span class=built_in>glVertexAttribPointer</span>(<span class=number>0</span>, <span class=number>3</span>, GL_FLOAT, GL_FALSE, <span class=number>8</span> * <span class=built_in><span class=keyword>sizeof</span></span>(<span class=keyword>float</span>), (<span class=keyword>void</span> *)<span class=number>0</span>);</span><br><span class=line>  <span class=built_in>glEnableVertexAttribArray</span>(<span class=number>1</span>);</span><br><span class=line> <span class=built_in>glVertexAttribPointer</span>(<span class=number>1</span>, <span class=number>3</span>, GL_FLOAT, GL_FALSE, <span class=number>8</span> * <span class=built_in><span class=keyword>sizeof</span></span>(<span class=keyword>float</span>), (<span class=keyword>void</span> *)(<span class=number>3</span> * <span class=built_in><span class=keyword>sizeof</span></span>(<span class=keyword>float</span>)));</span><br><span class=line>  <span class=built_in>glEnableVertexAttribArray</span>(<span class=number>2</span>);</span><br><span class=line>  <span class=built_in>glVertexAttribPointer</span>(<span class=number>2</span>, <span class=number>2</span>, GL_FLOAT, GL_FALSE, <span class=number>8</span> * <span class=built_in><span class=keyword>sizeof</span></span>(<span class=keyword>float</span>),(<span class=keyword>void</span> *)(<span class=number>6</span> * <span class=built_in><span class=keyword>sizeof</span></span>(<span class=keyword>float</span>)));</span><br></pre></table></figure><p>glVertexAttribPointer设置了解析这些数据的方式,其中3表示这个属性有几个值,8*sizeof(float)表示下一个点的相同属性的距离,0是偏移量.<p>假设读入数据布局不同,比如<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>float</span> vertices[] = {</span><br><span class=line>      <span class=comment>// positions                 </span></span><br><span class=line>     <span class=number>-0.5f</span>, <span class=number>-0.5f</span>, <span class=number>-0.5f</span>,</span><br><span class=line>       <span class=number>-0.5f</span>, <span class=number>0.0f</span>,  <span class=number>0.0f</span>,</span><br><span class=line>      <span class=number>0.5f</span>,  <span class=number>0.5f</span>,  <span class=number>-0.5f</span>,</span><br><span class=line>       <span class=comment>// normals </span></span><br><span class=line>      <span class=number>0.0f</span>,  <span class=number>0.0f</span>,  <span class=number>-1.0f</span>, </span><br><span class=line>      <span class=number>0.0f</span>,  <span class=number>0.0f</span>,  <span class=number>0.5f</span>, </span><br><span class=line>      <span class=number>-0.5f</span>, <span class=number>-1.0f</span>, <span class=number>1.0f</span>, </span><br><span class=line>       <span class=comment>// texture coords</span></span><br><span class=line>      <span class=number>-1.0f</span>, <span class=number>1.0f</span>,   </span><br><span class=line>      <span class=number>0.5f</span>,  <span class=number>0.5f</span>,   </span><br><span class=line>      <span class=number>0.0f</span>,  <span class=number>0.0f</span>, ,}</span><br></pre></table></figure><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=built_in>glVertexAttribPointer</span>(<span class=number>0</span>, <span class=number>3</span>, GL_FLOAT, GL_FALSE, <span class=number>3</span> * <span class=built_in><span class=keyword>sizeof</span></span>(<span class=keyword>float</span>),(<span class=keyword>void</span> *)<span class=number>0</span>);</span><br><span class=line><span class=built_in>glVertexAttribPointer</span>(<span class=number>1</span>, <span class=number>3</span>, GL_FLOAT, GL_FALSE, <span class=number>3</span> * <span class=built_in><span class=keyword>sizeof</span></span>(<span class=keyword>float</span>),(<span class=keyword>void</span> *)(<span class=number>9</span>*<span class=built_in><span class=keyword>sizeof</span></span>(<span class=keyword>float</span>)));</span><br><span class=line><span class=built_in>glVertexAttribPointer</span>(<span class=number>2</span>, <span class=number>2</span>, GL_FLOAT, GL_FALSE, <span class=number>2</span> * <span class=built_in><span class=keyword>sizeof</span></span>(<span class=keyword>float</span>),(<span class=keyword>void</span> *)(<span class=number>18</span>*<span class=built_in><span class=keyword>sizeof</span></span>(<span class=keyword>float</span>)));</span><br></pre></table></figure><p>此外可以通过<code>glBufferSubData</code>将数据从分别的数据加载到缓冲中<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>float</span> positions[] = { ... };</span><br><span class=line><span class=keyword>float</span> normals[] = { ... };</span><br><span class=line><span class=keyword>float</span> tex[] = { ... };</span><br><span class=line><span class=comment>// 填充缓冲</span></span><br><span class=line><span class=built_in>glBufferSubData</span>(GL_ARRAY_BUFFER, <span class=number>0</span>, <span class=built_in><span class=keyword>sizeof</span></span>(positions), &positions);</span><br><span class=line><span class=built_in>glBufferSubData</span>(GL_ARRAY_BUFFER, <span class=built_in><span class=keyword>sizeof</span></span>(positions), <span class=built_in><span class=keyword>sizeof</span></span>(normals), &normals);</span><br><span class=line><span class=built_in>glBufferSubData</span>(GL_ARRAY_BUFFER, <span class=built_in><span class=keyword>sizeof</span></span>(positions) + <span class=built_in><span class=keyword>sizeof</span></span>(normals), <span class=built_in><span class=keyword>sizeof</span></span>(tex), &tex);</span><br></pre></table></figure><h4 id=复制缓冲><a class=headerlink href=#复制缓冲 title=复制缓冲></a>复制缓冲</h4><p>当你的缓冲已经填充好数据之后，你可能会想与其它的缓冲共享其中的数据，或者想要将缓冲的内容复制到另一个缓冲当中。 这可以通过刚才的glMapBuffer实现.<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line>GLuint vbo1, vbo2;</span><br><span class=line><span class=built_in>glGenBuffers</span>(<span class=number>1</span>, &vbo1);</span><br><span class=line><span class=built_in>glGenBuffers</span>(<span class=number>1</span>, &vbo2);</span><br><span class=line><span class=built_in>glBindBuffer</span>(GL_ARRAY_BUFFER, vbo1);</span><br><span class=line><span class=keyword>float</span> data[] ={<span class=number>1.f</span>, <span class=number>0.f</span>, <span class=number>0.f</span>, <span class=number>1.f</span>, <span class=number>0.f</span>, <span class=number>0.f</span>, <span class=number>1.f</span>, <span class=number>0.f</span>, <span class=number>0.f</span>, <span class=number>1.f</span>, <span class=number>0.f</span>, <span class=number>0.f</span>};</span><br><span class=line><span class=keyword>auto</span> ptr = <span class=built_in>glMapBuffer</span>(GL_ARRAY_BUFFER, GL_WRITE_ONLY);</span><br><span class=line>std::<span class=built_in>copy</span>(std::<span class=built_in>begin</span>(data), std::<span class=built_in>end</span>(data), <span class=keyword>static_cast</span><<span class=keyword>float</span> *>(ptr));</span><br><span class=line><span class=built_in>glUnmapBuffer</span>(GL_ARRAY_BUFFER);</span><br><span class=line><span class=built_in>glBindBuffer</span>(GL_ARRAY_BUFFER, vbo2);</span><br><span class=line>ptr = <span class=built_in>glMapBuffer</span>(GL_ARRAY_BUFFER, GL_READ_ONLY);</span><br><span class=line><span class=keyword>float</span> data1[<span class=number>12</span>];</span><br><span class=line>std::<span class=built_in>copy</span>(data1, data1 + <span class=number>12</span>, <span class=keyword>static_cast</span><<span class=keyword>float</span> *>(ptr));</span><br><span class=line><span class=built_in>glUnmapBuffer</span>(GL_ARRAY_BUFFER);</span><br><span class=line>ptr = <span class=built_in>glMapBuffer</span>(GL_ARRAY_BUFFER, GL_WRITE_ONLY);</span><br><span class=line>std::<span class=built_in>copy</span>(std::<span class=built_in>begin</span>(data), std::<span class=built_in>end</span>(data), <span class=keyword>static_cast</span><<span class=keyword>float</span> *>(ptr));</span><br><span class=line><span class=built_in>glUnmapBuffer</span>(GL_ARRAY_BUFFER);</span><br></pre></table></figure><p>但通过<code>glCopyBufferSubData</code>更方便.<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>void</span> <span class=title>glCopyBufferSubData</span><span class=params>(GLenum readtarget, GLenum writetarget, GLintptr readoffset,</span></span></span><br><span class=line><span class=params><span class=function>                         GLintptr writeoffset, GLsizeiptr size)</span></span>;</span><br></pre></table></figure><p><code>readtarget</code>和<code>writetarget</code>参数需要填入复制源和复制目标的缓冲目标。比如可以将VERTEX_ARRAY_BUFFER缓冲复制到VERTEX_ELEMENT_ARRAY_BUFFER缓冲，分别将这些缓冲目标设置为读和写的目标。当前绑定到这些缓冲目标的缓冲将会被影响到。<p>但如果我们想读写数据的两个不同缓冲都为顶点数组缓冲该怎么办呢？我们不能同时将两个缓冲绑定到同一个缓冲目标上。<strong>OpenGL提供另外两个缓冲目标，叫做GL_COPY_READ_BUFFER和GL_COPY_WRITE_BUFFER。</strong>接下来就可以将需要的缓冲绑定到这两个缓冲目标上，并将这两个目标作为<code>readtarget</code>和<code>writetarget</code>参数<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>float</span> vertexData[] = { ... };</span><br><span class=line><span class=built_in>glBindBuffer</span>(GL_COPY_READ_BUFFER, vbo1);</span><br><span class=line><span class=built_in>glBindBuffer</span>(GL_COPY_WRITE_BUFFER, vbo2);</span><br><span class=line><span class=built_in>glCopyBufferSubData</span>(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, <span class=number>0</span>, <span class=number>0</span>, <span class=built_in><span class=keyword>sizeof</span></span>(vertexData));</span><br></pre></table></figure><p>也可以只将<code>writetarget</code>缓冲绑定为新的缓冲目标类型之一：<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>float</span> vertexData[] = { ... };</span><br><span class=line><span class=built_in>glBindBuffer</span>(GL_ARRAY_BUFFER, vbo1);</span><br><span class=line><span class=built_in>glBindBuffer</span>(GL_COPY_WRITE_BUFFER, vbo2);</span><br><span class=line><span class=built_in>glCopyBufferSubData</span>(GL_ARRAY_BUFFER, GL_COPY_WRITE_BUFFER, <span class=number>0</span>, <span class=number>0</span>, <span class=built_in><span class=keyword>sizeof</span></span>(vertexData));</span><br></pre></table></figure><h3 id=几何着色器><a class=headerlink href=#几何着色器 title=几何着色器></a>几何着色器</h3><p>​ <strong>在顶点和片段着色器之间有一个可选的几何着色器(Geometry Shader)，几何着色器的输入是一个图元（如点或三角形）的一组顶点</strong>。几何着色器可以在顶点发送到下一着色器阶段之前对它们随意变换。然而，几何着色器最有趣的地方在于，<strong>它能够将（这一组）顶点变换为完全不同的图元，并且还能生成比原来更多的顶点。</strong><p>首先定义在c++中绘画命令指定的图元类型,比如<code>GLDrawArrays(GL_POINTS,0,4)</code>绘画点图元,而几何着色器能够作为顶点和片段着色器之间的桥梁,能够增删/修改点的属性. out定义输出的图元以及最多的定点数.<figure class="highlight glsl"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=meta>#version 330 core</span></span><br><span class=line><span class=keyword>layout</span> (<span class=keyword>points</span>) <span class=keyword>in</span>;</span><br><span class=line><span class=keyword>layout</span> (<span class=keyword>line_strip</span>, <span class=keyword>max_vertices</span> = <span class=number>2</span>) <span class=keyword>out</span>;</span><br><span class=line></span><br><span class=line><span class=type>void</span> main() {    </span><br><span class=line>    <span class=built_in>gl_Position</span> = <span class=built_in>gl_in</span>[<span class=number>0</span>].<span class=built_in>gl_Position</span> + <span class=type>vec4</span>(<span class=number>-0.1</span>, <span class=number>0.0</span>, <span class=number>0.0</span>, <span class=number>0.0</span>); </span><br><span class=line>    <span class=built_in>EmitVertex</span>();</span><br><span class=line></span><br><span class=line>    <span class=built_in>gl_Position</span> = <span class=built_in>gl_in</span>[<span class=number>0</span>].<span class=built_in>gl_Position</span> + <span class=type>vec4</span>( <span class=number>0.1</span>, <span class=number>0.0</span>, <span class=number>0.0</span>, <span class=number>0.0</span>);</span><br><span class=line>    <span class=built_in>EmitVertex</span>();</span><br><span class=line></span><br><span class=line>    <span class=built_in>EndPrimitive</span>();</span><br><span class=line>}</span><br></pre></table></figure><p>几何着色器需要声明输入和输出的图元类型，以处理从顶点着色器接收的数据并生成新的几何图形。对于输入图元类型，在<code>in</code>关键字前使用布局修饰符（Layout Qualifier），可接收如下图元：<ul><li><code>points</code>：用于单个点。图元所包含的最小顶点数 1<li><code>lines</code>：用于线段或线带。<li><code>lines_adjacency</code>：用于带有相邻信息的线段或线带。<li><code>triangles</code>：用于三角形、三角形带或三角形扇。<li><code>triangles_adjacency</code>：用于带有相邻信息的三角形或三角形带。</ul><p>括号中的数字表示构成该图元所需的最小顶点数。<p>对于输出图元类型，在<code>out</code>关键字前同样使用布局修饰符，可设置为：<ul><li><code>points</code><li><code>line_strip</code><li><code>triangle_strip</code></ul><p>​ 这些输出图元允许几何着色器创建各种形状。例如，为了生成一个三角形，可以将输出定义为<code>triangle_strip</code>并提供3个顶点。<p>此外，几何着色器还要求指定其能输出的最大顶点数量，防止超出限制导致OpenGL忽略额外的顶点。此最大值也在<code>out</code>布局修饰符中设定。例如，若要输出一条线段，则应将最大顶点数设为2。<p>线条（Line Strip）是由一系列点组成的连续线段，至少需要两个点来形成。每增加一个点，就会与前一个点之间形成一条新的线段。例如，如果有5个顶点，它们会依次相连形成4条线段。<p>​ 当使用几何着色器时，如果最大输出顶点数设为2，则只能输出一条线段。为了生成更复杂的形状，几何着色器可以通过GLSL提供的内置变量<code>gl_in[]</code>访问来自上一阶段（如顶点着色器）的顶点数据。<code>gl_in[]</code>是一个接口块，它包含了每个输入顶点的位置和其他信息，如<code>gl_Position</code>等。<p>​ 几何着色器通过调用<code>EmitVertex()</code>函数来发射一个新的顶点，并最终通过<code>EndPrimitive()</code>函数来完成一个图元的定义。代码修改了原始顶点的位置，创建了两个新位置，然后发射了这两个顶点，最后通过调用<code>EndPrimitive()</code>将它们合成为一个线条图元。这样就创建了一条从原始顶点位置向左和向右各平移0.1单位的新线段。<p>​ <strong>线条是由连续的点组成，几何着色器可以访问先前阶段的顶点数据并通过发射顶点和结束图元的方法来创建新的几何图形</strong><h3 id=爆破物体><a class=headerlink href=#爆破物体 title=爆破物体></a>爆破物体</h3><p>当我们说<strong>爆破</strong>一个物体时，我们并不是指要将宝贵的顶点集给炸掉，我们是要将每个三角形沿着法向量的方向移动一小段时间。效果就是，整个物体看起来像是沿着每个三角形的法线向量<strong>爆炸</strong>一样。<p>做法就是在几何着色器中计算一个三角形面的法向量(通过面上的三个点得到两个向量并计算叉乘),在几何着色器中改变顶点位置.<h3 id=法向量可视化><a class=headerlink href=#法向量可视化 title=法向量可视化></a>法向量可视化</h3><p>​ 可以作为一种Debug工具,当编写光照着色器时，你可能会最终会得到一些奇怪的视觉输出，但又很难确定导致问题的原因。<strong>光照错误很常见的原因就是法向量错误，这可能是由于不正确加载顶点数据、错误地将它们定义为顶点属性或在着色器中不正确地管理所导致的</strong>。想要的是使用某种方式来检测提供的法向量是正确的。检测法向量是否正确的一个很好的方式就是对它们进行可视化，几何着色器正是实现这一目的非常有用的工具。<p>​ 首先不使用几何着色器正常绘制场景。然后再次绘制场景，但这次只显示通过几何着色器生成法向量。几何着色器接收一个三角形图元，并沿着法向量生成三条线——每个顶点一个法向量。<h3 id=实例化><a class=headerlink href=#实例化 title=实例化></a>实例化</h3><p>如果我们需要渲染大量物体时，代码看起来会像这样：<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>for</span>(<span class=keyword>unsigned</span> <span class=keyword>int</span> i = <span class=number>0</span>; i < amount_of_models_to_draw; i++)</span><br><span class=line>{</span><br><span class=line>    <span class=built_in>DoSomePreparations</span>(); <span class=comment>// 绑定VAO，绑定纹理，设置uniform等</span></span><br><span class=line>    <span class=built_in>glDrawArrays</span>(GL_TRIANGLES, <span class=number>0</span>, amount_of_vertices);</span><br><span class=line>}</span><br></pre></table></figure><p>如果像这样绘制模型的大量实例(Instance)，你很快就会因为绘制调用过多而达到性能瓶颈。与绘制顶点本身相比，使用glDrawArrays或glDrawElements函数告诉GPU去绘制你的顶点数据会消耗更多的性能，因为<strong>OpenGL在绘制顶点数据之前需要做很多准备工作（比如告诉GPU该从哪个缓冲读取数据，从哪寻找顶点属性，而且这些都是在相对缓慢的CPU到GPU总线(CPU to GPU Bus)上进行的）</strong>。所以，即便渲染顶点非常快，命令GPU去渲染却未必。<p>如果<strong>能够将数据一次性发送给GPU，然后使用一个绘制函数让OpenGL利用这些数据绘制多个物体，就会更方便了。这就是实例化(Instancing)</strong>。</p><link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script></div><div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div class=popular-posts-header>相关文章</div><ul class=popular-posts><li class=popular-posts-item><div class=popular-posts-title><a href=\2024\04\03\DiveintoCpp-from-OpenGL\ rel=bookmark>DiveintoCpp:from OpenGL(一):入门与光照</a></div></ul><div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a title="Learn OpenGL(二):模型加载与高级OpenGL" href=https://www.sekyoro.top/2024/12/27/Learn-OpenGL-%E4%BA%8C/>https://www.sekyoro.top/2024/12/27/Learn-OpenGL-二/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div><footer class=post-footer><div class=post-tags><a href=/tags/OpenGL/ rel=tag><i class="fa fa-tag"></i> OpenGL</a><a href=/tags/computer-graphics/ rel=tag><i class="fa fa-tag"></i> computer graphics</a></div><div class=post-nav><div class=post-nav-item><a title="Agentic RAG and LLMs-based assistant" href=/2024/12/26/Agentic-RAG-and-LLMs-based-assistant/ rel=prev> <i class="fa fa-chevron-left"></i> Agentic RAG and LLMs-based assistant </a></div><div class=post-nav-item><a title="An intro to Websocket and SSE" href=/2024/12/31/An-intro-to-Websocket-and-SSE/ rel=next> An intro to Websocket and SSE <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div><!-- 评论区 --><div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD><span class=nav-number>1.</span> <span class=nav-text>模型加载</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95><span class=nav-number>2.</span> <span class=nav-text>深度测试</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%B7%B1%E5%BA%A6%E5%80%BC%E7%B2%BE%E5%BA%A6><span class=nav-number>2.0.1.</span> <span class=nav-text>深度值精度</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%B7%B1%E5%BA%A6%E5%86%B2%E7%AA%81><span class=nav-number>2.0.2.</span> <span class=nav-text>深度冲突</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95><span class=nav-number>3.</span> <span class=nav-text>模板测试</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0><span class=nav-number>3.1.</span> <span class=nav-text>模板函数</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%89%A9%E4%BD%93%E8%BD%AE%E5%BB%93><span class=nav-number>3.2.</span> <span class=nav-text>物体轮廓</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%B7%B7%E5%90%88><span class=nav-number>3.3.</span> <span class=nav-text>混合</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%B8%B2%E6%9F%93%E5%8D%8A%E9%80%8F%E6%98%8E%E7%BA%B9%E7%90%86><span class=nav-number>3.4.</span> <span class=nav-text>渲染半透明纹理</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%B8%8D%E8%A6%81%E6%89%93%E6%89%B0%E9%A1%BA%E5%BA%8F><span class=nav-number>3.5.</span> <span class=nav-text>不要打扰顺序</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%9D%A2%E5%89%94%E9%99%A4><span class=nav-number>4.</span> <span class=nav-text>面剔除</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%8E%AF%E7%BB%95%E9%A1%BA%E5%BA%8F><span class=nav-number>4.0.1.</span> <span class=nav-text>环绕顺序</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%9D%A2%E5%89%94%E9%99%A4-1><span class=nav-number>4.0.2.</span> <span class=nav-text>面剔除</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%B8%A7%E7%BC%93%E5%86%B2><span class=nav-number>5.</span> <span class=nav-text>帧缓冲</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%88%9B%E5%BB%BA%E5%B8%A7%E7%BC%93%E5%86%B2><span class=nav-number>5.0.1.</span> <span class=nav-text>创建帧缓冲</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%BA%B9%E7%90%86%E9%99%84%E4%BB%B6><span class=nav-number>5.0.2.</span> <span class=nav-text>纹理附件</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%B8%B2%E6%9F%93%E7%BC%93%E5%86%B2%E5%AF%B9%E8%B1%A1%E9%99%84%E4%BB%B6><span class=nav-number>5.0.3.</span> <span class=nav-text>渲染缓冲对象附件</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%B8%B2%E6%9F%93%E5%88%B0%E7%BA%B9%E7%90%86><span class=nav-number>5.0.4.</span> <span class=nav-text>渲染到纹理</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8F%8D%E7%9B%B8><span class=nav-number>5.0.5.</span> <span class=nav-text>反相</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%81%B0%E5%BA%A6><span class=nav-number>5.0.6.</span> <span class=nav-text>灰度</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%A0%B8%E6%95%88%E6%9E%9C><span class=nav-number>5.0.7.</span> <span class=nav-text>核效果</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%AB%8B%E6%96%B9%E4%BD%93%E8%B4%B4%E5%9B%BE><span class=nav-number>6.</span> <span class=nav-text>立方体贴图</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84><span class=nav-number>6.1.</span> <span class=nav-text>环境映射</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8A%A8%E6%80%81%E7%8E%AF%E5%A2%83%E8%B4%B4%E5%9B%BE><span class=nav-number>6.1.1.</span> <span class=nav-text>动态环境贴图</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE><span class=nav-number>7.</span> <span class=nav-text>高级数据</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A1%AB%E5%85%85%E7%BC%93%E5%86%B2%E6%95%B0%E6%8D%AE><span class=nav-number>7.1.</span> <span class=nav-text>填充缓冲数据</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%88%86%E6%89%B9%E9%A1%B6%E7%82%B9%E5%B1%9E%E6%80%A7><span class=nav-number>7.2.</span> <span class=nav-text>分批顶点属性</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%A4%8D%E5%88%B6%E7%BC%93%E5%86%B2><span class=nav-number>7.2.1.</span> <span class=nav-text>复制缓冲</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8><span class=nav-number>7.3.</span> <span class=nav-text>几何着色器</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%88%86%E7%A0%B4%E7%89%A9%E4%BD%93><span class=nav-number>7.4.</span> <span class=nav-text>爆破物体</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%B3%95%E5%90%91%E9%87%8F%E5%8F%AF%E8%A7%86%E5%8C%96><span class=nav-number>7.5.</span> <span class=nav-text>法向量可视化</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AE%9E%E4%BE%8B%E5%8C%96><span class=nav-number>7.6.</span> <span class=nav-text>实例化</span></a></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>233</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>16</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>207</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a><li class=links-of-blogroll-item><a href=https://www.lllomh.com/ rel=noopener target=_blank title=https://www.lllomh.com/>芈渡</a><li class=links-of-blogroll-item><a href=https://protool-ten.vercel.app/ rel=noopener target=_blank title=https://protool-ten.vercel.app/>protools</a></ul></div><div class="motion-element announcement"><div class=title></div><p class=content><p class=date></div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>文章词云</h3><div class="widget tagcloud" id=myCanvasContainer><canvas height=250 id=resCanvas style=width:100% width=250><ul class=tag-list itemprop=keywords><li class=tag-list-item><a class=tag-list-link href=/tags/OpenGL/ rel=tag>OpenGL</a><span class=tag-list-count>1</span><li class=tag-list-item><a class=tag-list-link href=/tags/computer-graphics/ rel=tag>computer graphics</a><span class=tag-list-count>2</span></ul></canvas></div></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2025</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>2.3m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>34:50</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer></div><script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script><script src=/lib/anime.min.js></script><script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script><script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/pisces.js></script><script src=/js/next-boot.js></script><script src=/js/bookmark.js></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	'.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script><script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script><script src=/js/algolia-search.js></script><script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script><div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div><script charset=utf-8 defer src=/js/tagcanvas.js></script><script charset=utf-8 defer src=/js/tagcloud.js></script><script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script><script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script><script src=/js/src/activate-power-mode.min.js></script><script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script>
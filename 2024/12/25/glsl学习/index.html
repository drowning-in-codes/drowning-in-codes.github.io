<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"0F9LEEVW82","apiKey":"78839e9f9be09d081c5c4da81975cd19","indexName":"sekyoblog_sec","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content="在OpenGL中着色器的编程语言叫做GLSL,类似C语言但是内置了许多有用的函数. 这里简单学习其基础语法和包含特殊函数." name=description><meta content=article property=og:type><meta content=OpenGL中不可忽视的部分:glsl、glm、assimp以及更多 property=og:title><meta content=https://www.sekyoro.top/2024/12/25/glsl%E5%AD%A6%E4%B9%A0/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content="在OpenGL中着色器的编程语言叫做GLSL,类似C语言但是内置了许多有用的函数. 这里简单学习其基础语法和包含特殊函数." property=og:description><meta content=zh_CN property=og:locale><meta content=https://s2.loli.net/2024/12/26/RenYMiV8qSGBm4y.png property=og:image><meta content=https://learnopengl-cn.github.io/img/04/08/advanced_glsl_binding_points.png property=og:image><meta content=2024-12-25T14:15:40.000Z property=article:published_time><meta content=2025-01-06T14:17:57.605Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content=GLSL编程 property=article:tag><meta content=summary name=twitter:card><meta content=https://s2.loli.net/2024/12/26/RenYMiV8qSGBm4y.png name=twitter:image><link href=https://www.sekyoro.top/2024/12/25/glsl%E5%AD%A6%E4%B9%A0/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>OpenGL中不可忽视的部分:glsl、glm、assimp以及更多 | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2024/12/25/glsl%E5%AD%A6%E4%B9%A0/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>OpenGL中不可忽视的部分:glsl、glm、assimp以及更多</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-12-25 22:15:40" datetime=2024-12-25T22:15:40+08:00>2024-12-25</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-01-06 22:17:57" datetime=2025-01-06T22:17:57+08:00 itemprop=dateModified>2025-01-06</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>20k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>18 分钟</span> </span></div></header><div class=post-body itemprop=articleBody><p>在OpenGL中着色器的编程语言叫做GLSL,类似C语言但是内置了许多有用的函数. 这里简单学习其基础语法和包含特殊函数.<br><span id=more></span><h2 id=GLSL><a class=headerlink href=#GLSL title=GLSL></a>GLSL</h2><p>着色器编程语言,在GPU下编程<h3 id=开发环境搭建><a class=headerlink href=#开发环境搭建 title=开发环境搭建></a>开发环境搭建</h3><p>这里使用vscode进行开发,由于着色器语言不像C++,Java这种通用语言,它的语法检查和Lint没有这么丰富. 在vscode主要下载两个插件,一个是语法高亮<a href=https://marketplace.visualstudio.com/items?itemName=slevesque.shader rel=noopener target=_blank>Shader languages support for VS Code - Visual Studio Marketplace</a>,另一个是Lint<a href=https://github.com/hsimpson/vscode-glsllint?tab=readme-ov-file rel=noopener target=_blank>hsimpson/vscode-glsllint: VSCode extension to lint GLSL shading language files</a>.<p><img alt=image-20241226175503864 data-src=https://s2.loli.net/2024/12/26/RenYMiV8qSGBm4y.png><p>此外Lint的插件本身不提供Linter,需要自己下载<a href=https://github.com/KhronosGroup/glslang rel=noopener target=_blank>KhronosGroup/glslang: Khronos-reference front end for GLSL/ESSL, partial front end for HLSL, and a SPIR-V generator.</a><p>语法提示规则与文件名后缀相关<p>The applied stage-specific rules are based on the file extension:<ul><li><code>.vert</code> for a vertex shader<li><code>.tesc</code> for a tessellation control shader<li><code>.tese</code> for a tessellation evaluation shader<li><code>.geom</code> for a geometry shader<li><code>.frag</code> for a fragment shader<li><code>.comp</code> for a compute shader</ul><p>For ray tracing pipeline shaders:<ul><li><code>.rgen</code> for a ray generation shader<li><code>.rint</code> for a ray intersection shader<li><code>.rahit</code> for a ray any-hit shader<li><code>.rchit</code> for a ray closest-hit shader<li><code>.rmiss</code> for a ray miss shader<li><code>.rcall</code> for a callable shader</ul><p>此外还可以配置代码片段<a href=https://gist.github.com/lewislepton/8b17f56baa7f1790a70284e7520f9623 rel=noopener target=_blank>GLSL snippets for visual studio code/kode studio</a>,输入缩写即可提示.<h3 id=数据类型><a class=headerlink href=#数据类型 title=数据类型></a>数据类型</h3><p>float,int,bool,vec,mat, struct,[]<h3 id=重要辅助函数><a class=headerlink href=#重要辅助函数 title=重要辅助函数></a>重要辅助函数</h3><h4 id=向量和矩阵运算><a class=headerlink href=#向量和矩阵运算 title=向量和矩阵运算></a>向量和矩阵运算</h4><p>dot,cross,normalize,transpose,inverse<h4 id=纹理采样><a class=headerlink href=#纹理采样 title=纹理采样></a>纹理采样</h4><p>texture,mix<h4 id=光照计算><a class=headerlink href=#光照计算 title=光照计算></a>光照计算</h4><p>clamp,mix,reflect<h3 id=高级GLSL><a class=headerlink href=#高级GLSL title=高级GLSL></a>高级GLSL</h3><p>glsl定义了几个以<code>gl_</code>为前缀的变量，它们能提供给我们更多的方式来读取/写入数据。比如顶点着色器的输出向量gl_Position和片段着色器的gl_FragCoord。<h4 id=顶点着色器><a class=headerlink href=#顶点着色器 title=顶点着色器></a>顶点着色器</h4><p><strong>gl_PointSize</strong><p>通过gl_PointSize设置GL_POINT图元的大小,在顶点着色器中修改点大小的功能默认是禁用的，如果你需要启用它的话，需要启用OpenGL的GL_PROGRAM_POINT_SIZE：<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>glEnable</span>(GL_PROGRAM_POINT_SIZE);</span><br></pre></table></figure><p><strong>gl_VertexID</strong><p>gl_Position和gl_PointSize都是<strong>输出变量</strong>，因为它们的值是作为顶点着色器的输出被读取的。可以对它们进行写入，来改变结果。<p>顶点着色器还提供了一个有趣的<strong>输入变量</strong>，只能对它进行读取，它叫做gl_VertexID。<p>整型变量gl_VertexID储存了正在绘制顶点的当前ID。<strong>当使用glDrawElements进行索引渲染的时候，这个变量会存储正在绘制顶点的当前索引</strong>。当使用glDrawArrays不使用索引进行绘制的时候，这个变量会储存从渲染调用开始的已处理顶点数量。<h4 id=片段着色器><a class=headerlink href=#片段着色器 title=片段着色器></a>片段着色器</h4><p>GLSL提供给两个输入变量：gl_FragCoord和gl_FrontFacing。<p><strong>gl_FragCoord</strong><p>gl_FragCoord的x和y分量是片段的窗口空间(Window-space)坐标，其原点为窗口的左下角。 可以利用它的z值(也就是深度)和xy空间坐标(屏幕空间,归一到[0,1])<figure class="highlight glsl"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=type>void</span> main()</span><br><span class=line>{             </span><br><span class=line>    <span class=keyword>if</span>(<span class=built_in>gl_FragCoord</span>.x < <span class=number>400</span>)</span><br><span class=line>        FragColor = <span class=type>vec4</span>(<span class=number>1.0</span>, <span class=number>0.0</span>, <span class=number>0.0</span>, <span class=number>1.0</span>);</span><br><span class=line>    <span class=keyword>else</span></span><br><span class=line>        FragColor = <span class=type>vec4</span>(<span class=number>0.0</span>, <span class=number>1.0</span>, <span class=number>0.0</span>, <span class=number>1.0</span>);        </span><br><span class=line>}</span><br></pre></table></figure><p><strong>gl_FrontFacing</strong><p>提到OpenGL根据顶点的环绕顺序来决定一个面是正向还是背向面。如果我们不（启用GL_FACE_CULL来）使用面剔除，那么<strong>gl_FrontFacing将会告诉我们当前片段是属于正向面的一部分还是背向面的一部分</strong>。<p>gl_FrontFacing变量是一个bool，如果当前片段是正向面的一部分那么就是<code>true</code>，否则就是<code>false</code><p>如果开启了面剔除，就看不到箱子内部的面了，再使用gl_FrontFacing就没有意义了。<p><strong>gl_FragDepth</strong><p>输入变量gl_FragCoord的深度值是一个只读(Read-only)变量,不能修改片段的窗口空间坐标，但实际上<strong>修改片段的深度值还是可能的</strong>。<strong>GLSL提供一个叫做gl_FragDepth的输出变量，可以使用它来在着色器内设置片段的深度值。</strong><p>要想设置深度值，直接写入一个0.0到1.0之间的float值到输出变量就可以了：<figure class="highlight glsl"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>gl_FragDepth</span> = <span class=number>0.0</span>; <span class=comment>// 这个片段现在的深度值为 0.0</span></span><br></pre></table></figure><p>如果着色器没有写入值到gl_FragDepth，它会自动取用<code>gl_FragCoord.z</code>的值。但是只要我们在片段着色器中对gl_FragDepth进行写入，OpenGL就会<strong>禁用所有的提前深度测试</strong>(Early Depth Testing)。它被禁用的原因是，OpenGL无法在片段着色器运行<strong>之前</strong>得知片段将拥有的深度值，因为片段着色器可能会完全修改这个深度值。<p>从4.2起,在片段着色器的顶部使用深度条件(Depth Condition)重新声明gl_FragDepth变量：<figure class="highlight glsl"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>layout</span> (depth_&LTcondition>) <span class=keyword>out</span> <span class=type>float</span> <span class=built_in>gl_FragDepth</span>;</span><br></pre></table></figure><p><code>condition</code>可以为下面的值：<div class=table-container><table><thead><tr><th style=text-align:left>条件<th style=text-align:left>描述<tbody><tr><td style=text-align:left><code>any</code><td style=text-align:left>默认值。提前深度测试是禁用的，你会损失很多性能<tr><td style=text-align:left><code>greater</code><td style=text-align:left>你只能让深度值比<code>gl_FragCoord.z</code>更大<tr><td style=text-align:left><code>less</code><td style=text-align:left>你只能让深度值比<code>gl_FragCoord.z</code>更小<tr><td style=text-align:left><code>unchanged</code><td style=text-align:left>如果你要写入<code>gl_FragDepth</code>，你将只能写入<code>gl_FragCoord.z</code>的值</table></div><figure class="highlight glsl"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>#version 420 core</span></span><br><span class=line><span class=keyword>layout</span>(<span class=keyword>depth_less</span>) <span class=keyword>out</span> <span class=type>float</span> <span class=built_in>gl_FragDepth</span>;</span><br><span class=line>voif main{</span><br><span class=line>    <span class=built_in>gl_FragDepth</span> = <span class=built_in>gl_FragCoord</span>.z+<span class=number>1</span>;</span><br><span class=line>}</span><br></pre></table></figure><h4 id=接口块><a class=headerlink href=#接口块 title=接口块></a>接口块</h4><p>为了方便在着色器之间传递数据,可以定义in out块,类似结构体<figure class="highlight glsl"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=meta>#version 330 core</span></span><br><span class=line><span class=keyword>layout</span> (<span class=keyword>location</span> = <span class=number>0</span>) <span class=keyword>in</span> <span class=type>vec3</span> aPos;</span><br><span class=line><span class=keyword>layout</span> (<span class=keyword>location</span> = <span class=number>1</span>) <span class=keyword>in</span> <span class=type>vec2</span> aTexCoords;</span><br><span class=line></span><br><span class=line><span class=keyword>uniform</span> <span class=type>mat4</span> model;</span><br><span class=line><span class=keyword>uniform</span> <span class=type>mat4</span> view;</span><br><span class=line><span class=keyword>uniform</span> <span class=type>mat4</span> projection;</span><br><span class=line></span><br><span class=line><span class=keyword>out</span> VS_OUT</span><br><span class=line>{</span><br><span class=line>    <span class=type>vec2</span> TexCoords;</span><br><span class=line>} vs_out;</span><br><span class=line></span><br><span class=line><span class=type>void</span> main()</span><br><span class=line>{</span><br><span class=line>    <span class=built_in>gl_Position</span> = projection * view * model * <span class=type>vec4</span>(aPos, <span class=number>1.0</span>);    </span><br><span class=line>    vs_out.TexCoords = aTexCoords;</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><figure class="highlight glsl"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=meta>#version 330 core</span></span><br><span class=line><span class=keyword>out</span> <span class=type>vec4</span> FragColor;</span><br><span class=line></span><br><span class=line><span class=keyword>in</span> VS_OUT</span><br><span class=line>{</span><br><span class=line>    <span class=type>vec2</span> TexCoords;</span><br><span class=line>} fs_in;</span><br><span class=line></span><br><span class=line><span class=keyword>uniform</span> <span class=type>sampler2D</span> <span class=built_in>texture</span>;</span><br><span class=line></span><br><span class=line><span class=type>void</span> main()</span><br><span class=line>{             </span><br><span class=line>    FragColor = <span class=built_in>texture</span>(<span class=built_in>texture</span>, fs_in.TexCoords);   </span><br><span class=line>}</span><br></pre></table></figure><p>只要两个接口块的名字一样，它们对应的输入和输出将会匹配起来.它在几何着色器这样穿插特定着色器阶段的场景下会很有用。<h4 id=Uniform缓冲对象><a class=headerlink href=#Uniform缓冲对象 title=Uniform缓冲对象></a>Uniform缓冲对象</h4><p>假设多个着色器都包含一个uniform变量,它们的值相同,为了不重复地设置,可以使用Uniform缓冲对象.<strong>允许定义一系列在多个着色器程序中相同的全局Uniform变量</strong>。当<strong>使用Uniform缓冲对象的时候，只需要设置相关的uniform一次</strong>。当然，我们仍需要手动设置每个着色器中不同的uniform。并且创建和配置Uniform缓冲对象会有一点繁琐。<figure class="highlight glsl"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=meta>#version 330 core</span></span><br><span class=line><span class=keyword>layout</span> (<span class=keyword>location</span> = <span class=number>0</span>) <span class=keyword>in</span> <span class=type>vec3</span> aPos;</span><br><span class=line></span><br><span class=line><span class=keyword>layout</span> (<span class=keyword>std140</span>) <span class=keyword>uniform</span> Matrices</span><br><span class=line>    <span class=comment>// 定义的Uniform块对它的内容使用一个特定的内存布局。这个语句设置了Uniform块布局(Uniform Block Layout)。</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>mat4</span> projection;</span><br><span class=line>    <span class=type>mat4</span> view;</span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=keyword>uniform</span> <span class=type>mat4</span> model;</span><br><span class=line></span><br><span class=line><span class=type>void</span> main()</span><br><span class=line>{</span><br><span class=line>    <span class=built_in>gl_Position</span> = projection * view * model * <span class=type>vec4</span>(aPos, <span class=number>1.0</span>);</span><br><span class=line>}</span><br></pre></table></figure><p>这个Uniform块储存了两个4x4矩阵。<strong>Uniform块中的变量可以直接访问，不需要加块名作为前缀。</strong> 每个声明了这个Uniform块的着色器都能够访问这些矩阵。<h4 id=Uniform块布局><a class=headerlink href=#Uniform块布局 title=Uniform块布局></a>Uniform块布局</h4><p>Uniform块的内容是储存在一个缓冲对象中的，它实际上只是一块预留内存。因为这块内存并不会保存它具体保存的是什么类型的数据，我们还需要告诉OpenGL内存的哪一部分对应着着色器中的哪一个uniform变量。<p>假设着色器中有以下的这个Uniform块：<figure class="highlight glsl"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>layout</span> (<span class=keyword>std140</span>) <span class=keyword>uniform</span> ExampleBlock</span><br><span class=line>{</span><br><span class=line>    <span class=type>float</span> value;</span><br><span class=line>    <span class=type>vec3</span>  vector;</span><br><span class=line>    <span class=type>mat4</span>  matrix;</span><br><span class=line>    <span class=type>float</span> values[<span class=number>3</span>];</span><br><span class=line>    <span class=type>bool</span>  boolean;</span><br><span class=line>    <span class=type>int</span>   integer;</span><br><span class=line>};</span><br></pre></table></figure><p>我们需要知道的是每个变量的大小（字节）和（从块起始位置的）偏移量，来让我们能够按顺序将它们放进缓冲中。<strong>每个元素的大小都是在OpenGL中有清楚地声明的，而且直接对应C++数据类型</strong>，其中向量和矩阵都是大的float数组。OpenGL没有声明的是这些变量间的间距(Spacing)。这允许硬件能够在它认为合适的位置放置变量。比如说，一些硬件可能会将一个vec3放置在float边上。不是所有的硬件都能这样处理，可能会在附加这个float之前，先将vec3填充(Pad)为一个4个float的数组。这个特性本身很棒，但是会造成麻烦。<p><strong>默认情况下，GLSL会使用一个叫做共享(Shared)布局的Uniform内存布局，共享是因为一旦硬件定义了偏移量，它们在多个程序中是共享并一致的</strong>。使用共享布局时，GLSL是<strong>可以为了优化而对uniform变量的位置进行变动的，只要变量的顺序保持不变</strong>。<strong>因为无法知道每个uniform变量的偏移量，我们也就不知道如何准确地填充Uniform缓冲</strong>了。我们能够使用像是<strong>glGetUniformIndices这样的函数来查询这个信息</strong><p>虽然共享布局给了我们很多节省空间的优化，但是我们需要查询每个uniform变量的偏移量，这会产生非常多的工作量。通常的做法是，不使用共享布局，而是使用std140布局。std140布局声明了每个变量的偏移量都是由一系列规则所决定的，这<strong>显式地</strong>声明了每个变量类型的内存布局。由于这是显式提及的，我们可以手动计算出每个变量的偏移量。<p>每个变量都有一个基准对齐量(Base Alignment)，它等于一个变量在Uniform块中所占据的空间（包括填充量(Padding)），这个基准对齐量是使用std140布局的规则计算出来的。接下来，对每个变量，我们再计算它的对齐偏移量(Aligned Offset)，它是一个变量从块起始位置的字节偏移量。<strong>一个变量的对齐字节偏移量必须等于基准对齐量的倍数。</strong><p>GLSL中的每个变量，比如说int、float和bool，都被定义为4字节量。每4个字节将会用一个<code>N</code>来表示。<div class=table-container><table><thead><tr><th style=text-align:left>类型<th style=text-align:left>布局规则<tbody><tr><td style=text-align:left>标量，比如int和bool<td style=text-align:left>每个标量的基准对齐量为N。<tr><td style=text-align:left>向量<td style=text-align:left>2N或者4N。这意味着vec3的基准对齐量为4N。<tr><td style=text-align:left>标量或向量的数组<td style=text-align:left>每个元素的基准对齐量与vec4的相同。<tr><td style=text-align:left>矩阵<td style=text-align:left>储存为列向量的数组，每个向量的基准对齐量与vec4的相同。<tr><td style=text-align:left>结构体<td style=text-align:left>等于所有元素根据规则计算后的大小，但会填充到vec4大小的倍数。</table></div><p>使用计算后的偏移量值，根据std140布局的规则，我们就能使用像是glBufferSubData的函数将变量数据按照偏移量填充进缓冲中了。<strong>虽然std140布局不是最高效的布局，但它保证了内存布局在每个声明了这个Uniform块的程序中是一致的。</strong><p><strong>通过在Uniform块定义之前添加<code>layout (std140)</code>语句，告诉OpenGL这个Uniform块使用的是std140布局。</strong>除此之外<strong>还可以选择两个布局，但它们都需要我们在填充缓冲之前先查询每个偏移量</strong>。<p>​ 我们已经见过<code>shared</code>布局了，剩下的一个布局是<code>packed</code>。<strong>当使用紧凑(Packed)布局时，是不能保证这个布局在每个程序中保持不变的（即非共享），因为它允许编译器去将uniform变量从Uniform块中优化掉，这在每个着色器中都可能是不同的。</strong><h4 id=使用Uniform缓冲><a class=headerlink href=#使用Uniform缓冲 title=使用Uniform缓冲></a>使用Uniform缓冲</h4><p>我们已经讨论了如何在着色器中定义Uniform块，并设定它们的内存布局了，但我们还没有讨论该如何使用它们。<p>首先，我们需要调用glGenBuffers，创建一个Uniform缓冲对象。一旦我们有了一个缓冲对象，我们需要将它绑定到GL_UNIFORM_BUFFER目标，并调用glBufferData，分配足够的内存。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> uboExampleBlock;</span><br><span class=line><span class=built_in>glGenBuffers</span>(<span class=number>1</span>, &uboExampleBlock); <span class=comment>//创建uniform buffer对象</span></span><br><span class=line><span class=built_in>glBindBuffer</span>(GL_UNIFORM_BUFFER, uboExampleBlock);</span><br><span class=line><span class=built_in>glBufferData</span>(GL_UNIFORM_BUFFER, <span class=number>152</span>, <span class=literal>NULL</span>, GL_STATIC_DRAW); <span class=comment>// 分配152字节的内存</span></span><br><span class=line><span class=built_in>glBindBuffer</span>(GL_UNIFORM_BUFFER, <span class=number>0</span>);</span><br></pre></table></figure><p>每当我们需要对缓冲更新或者插入数据，我们都会绑定到uboExampleBlock，并使用glBufferSubData来更新它的内存。我们只需要更新这个Uniform缓冲一次，所有使用这个缓冲的着色器就都使用的是更新后的数据了<p>在OpenGL上下文中，定义了一些绑定点(Binding Point)，我们可以将一个Uniform缓冲链接至它。在创建Uniform缓冲之后，我们将它绑定到其中一个绑定点上，并将着色器中的Uniform块绑定到相同的绑定点，把它们连接到一起。下面的这个图示展示了这个：<p><img alt=img data-src=https://learnopengl-cn.github.io/img/04/08/advanced_glsl_binding_points.png><p>你可以看到，我们可以绑定多个Uniform缓冲到不同的绑定点上。因为着色器A和着色器B都有一个链接到绑定点0的Uniform块，它们的Uniform块将会共享相同的uniform数据，uboMatrices，前提条件是两个着色器都定义了相同的Matrices Uniform块。<p>为了将Uniform块绑定到一个特定的绑定点中，我们需要调用glUniformBlockBinding函数，它的第一个参数是一个程序对象，之后是一个Uniform块索引和链接到的绑定点。Uniform块索引(Uniform Block Index)是着色器中已定义Uniform块的位置值索引。这可以通过调用glGetUniformBlockIndex来获取，它接受一个程序对象和Uniform块的名称<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> lights_index = <span class=built_in>glGetUniformBlockIndex</span>(shaderA.ID, <span class=string>"Lights"</span>);   </span><br><span class=line><span class=built_in>glUniformBlockBinding</span>(shaderA.ID, lights_index, <span class=number>2</span>);</span><br></pre></table></figure><p>从OpenGL 4.2版本起，也可以添加一个布局标识符，显式地将Uniform块的绑定点储存在着色器中，这样就不用再调用glGetUniformBlockIndex和glUniformBlockBinding了。下面的代码显式地设置了Lights Uniform块的绑定点。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>layout</span>(std140, binding = <span class=number>2</span>) uniform Lights { ... };</span><br></pre></table></figure><p>接下来，我们还需要绑定Uniform缓冲对象到相同的绑定点上，这可以使用glBindBufferBase或glBindBufferRange来完成。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=built_in>glBindBufferBase</span>(GL_UNIFORM_BUFFER, <span class=number>2</span>, uboExampleBlock); </span><br><span class=line><span class=comment>// 或</span></span><br><span class=line><span class=built_in>glBindBufferRange</span>(GL_UNIFORM_BUFFER, <span class=number>2</span>, uboExampleBlock, <span class=number>0</span>, <span class=number>152</span>);</span><br></pre></table></figure><p>glBindbufferBase需要一个目标，一个绑定点索引和一个Uniform缓冲对象作为它的参数。这个函数将uboExampleBlock链接到绑定点2上，自此，绑定点的两端都链接上了。你也可以使用glBindBufferRange函数，它需要一个附加的偏移量和大小参数，这样子你可以绑定Uniform缓冲的特定一部分到绑定点中。通过使用glBindBufferRange函数，你可以让多个不同的Uniform块绑定到同一个Uniform缓冲对象上。<p>现在，所有的东西都配置完毕了，我们可以开始向Uniform缓冲中添加数据了。只要我们需要，就可以使用glBufferSubData函数，用一个字节数组添加所有的数据，或者更新缓冲的一部分。要想更新uniform变量boolean，我们可以用以下方式更新Uniform缓冲对象：<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=built_in>glBindBuffer</span>(GL_UNIFORM_BUFFER, uboExampleBlock);</span><br><span class=line><span class=keyword>int</span> b = <span class=literal>true</span>; <span class=comment>// GLSL中的bool是4字节的，所以我们将它存为一个integer</span></span><br><span class=line><span class=built_in>glBufferSubData</span>(GL_UNIFORM_BUFFER, <span class=number>144</span>, <span class=number>4</span>, &b); </span><br><span class=line><span class=built_in>glBindBuffer</span>(GL_UNIFORM_BUFFER, <span class=number>0</span>);</span><br></pre></table></figure><p>同样的步骤也能应用到Uniform块中其它的uniform变量上，但需要使用不同的范围参数。<p>Uniform缓冲对象比起独立的uniform有很多好处。第一，<strong>一次设置很多uniform会比一个一个设置多个uniform要快很多</strong>。第二，<strong>比起在多个着色器中修改同样的uniform，在Uniform缓冲中修改一次会更容易一些</strong>。最后一个好处可能不会立即显现，<strong>如果使用Uniform缓冲对象的话，你可以在着色器中使用更多的uniform</strong>。OpenGL限制了它能够处理的uniform数量，这可以通过GL_MAX_VERTEX_UNIFORM_COMPONENTS来查询。当<strong>使用Uniform缓冲对象时，最大的数量会更高。</strong>所以，当你达到了uniform的最大数量时（比如再做骨骼动画(Skeletal Animation)的时候），总是可以选择使用Uniform缓冲对象。<h2 id=GLM><a class=headerlink href=#GLM title=GLM></a>GLM</h2><p>与opengl向适应的向量计算库<ol><li><strong>向量类</strong>:<ul><li><code>glm::vec2</code>: 2D 向量。<li><code>glm::vec3</code>: 3D 向量。<li><code>glm::vec4</code>: 4D 向量（通常用于颜色或齐次坐标）。</ul><li><strong>矩阵类</strong>:<ul><li><code>glm::mat2</code>: 2x2 矩阵。<li><code>glm::mat3</code>: 3x3 矩阵。<li><code>glm::mat4</code>: 4x4 矩阵（常用于变换矩阵）。</ul><li><strong>四元数类</strong>:<ul><li><code>glm::quat</code>: 四元数，用于表示旋转。</ul></ol><h3 id=常用方法><a class=headerlink href=#常用方法 title=常用方法></a>常用方法</h3><h4 id=向量操作><a class=headerlink href=#向量操作 title=向量操作></a>向量操作</h4><ul><li><p><strong>创建向量</strong>:</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function>glm::vec3 <span class=title>v</span><span class=params>(<span class=number>1.0f</span>, <span class=number>2.0f</span>, <span class=number>3.0f</span>)</span></span>;</span><br></pre></table></figure><li><p><strong>向量加法</strong>:</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>glm::vec3 sum = v1 + v2;</span><br></pre></table></figure><li><p><strong>向量减法</strong>:</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>glm::vec3 difference = v1 - v2;</span><br></pre></table></figure><li><p><strong>标量乘法</strong>:</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>glm::vec3 scaled = v * scalar;</span><br></pre></table></figure><li><p><strong>点积</strong> (<code>dot product</code>):</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>float</span> dotProduct = glm::<span class=built_in>dot</span>(v1, v2);</span><br></pre></table></figure><li><p><strong>叉积</strong> (<code>cross product</code>) - 仅适用于3D向量:</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>glm::vec3 crossProduct = glm::<span class=built_in>cross</span>(v1, v2);</span><br></pre></table></figure><li><p><strong>长度/模</strong> (<code>length/magnitude</code>):</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>float</span> length = glm::<span class=built_in>length</span>(v);</span><br></pre></table></figure><li><p><strong>标准化</strong> (<code>normalize</code>):</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>glm::vec3 normalizedV = glm::<span class=built_in>normalize</span>(v);</span><br></pre></table></figure></ul><h4 id=矩阵操作><a class=headerlink href=#矩阵操作 title=矩阵操作></a>矩阵操作</h4><ul><li><p><strong>创建单位矩阵</strong>:</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>glm::mat4 identity = glm::<span class=built_in>mat4</span>(<span class=number>1.0f</span>);</span><br></pre></table></figure><li><p><strong>平移矩阵</strong>:</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>glm::mat4 translateMatrix = glm::<span class=built_in>translate</span>(glm::<span class=built_in>mat4</span>(<span class=number>1.0f</span>), glm::<span class=built_in>vec3</span>(x, y, z));</span><br></pre></table></figure><li><p><strong>缩放矩阵</strong>:</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>glm::mat4 scaleMatrix = glm::<span class=built_in>scale</span>(glm::<span class=built_in>mat4</span>(<span class=number>1.0f</span>), glm::<span class=built_in>vec3</span>(sx, sy, sz));</span><br></pre></table></figure><li><p><strong>旋转矩阵</strong>:</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>glm::mat4 rotateMatrix = glm::<span class=built_in>rotate</span>(glm::<span class=built_in>mat4</span>(<span class=number>1.0f</span>), angle, glm::<span class=built_in>vec3</span>(axisX, axisY, axisZ));</span><br></pre></table></figure><li><p><strong>组合变换</strong>:</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>glm::mat4 model = glm::<span class=built_in>translate</span>(glm::<span class=built_in>mat4</span>(<span class=number>1.0f</span>), translation) *</span><br><span class=line>                  glm::<span class=built_in>rotate</span>(glm::<span class=built_in>mat4</span>(<span class=number>1.0f</span>), rotationAngle, rotationAxis) *</span><br><span class=line>                  glm::<span class=built_in>scale</span>(glm::<span class=built_in>mat4</span>(<span class=number>1.0f</span>), scale);</span><br></pre></table></figure><li><p><strong>视图矩阵</strong> (<code>lookAt</code>):</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>glm::mat4 view = glm::<span class=built_in>lookAt</span>(cameraPosition, cameraTarget, upVector);</span><br></pre></table></figure><li><p><strong>投影矩阵</strong> (<code>perspective</code> 和 <code>orthographic</code>):</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>glm::mat4 projection = glm::<span class=built_in>perspective</span>(glm::<span class=built_in>radians</span>(fov), aspectRatio, nearPlane, farPlane);</span><br><span class=line><span class=comment>// 或者正交投影</span></span><br><span class=line>glm::mat4 orthoProjection = glm::<span class=built_in>ortho</span>(left, right, bottom, top, nearPlane, farPlane);</span><br></pre></table></figure></ul><h4 id=四元数操作><a class=headerlink href=#四元数操作 title=四元数操作></a>四元数操作</h4><ul><li><p><strong>创建四元数</strong>:</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>glm::quat q = glm::<span class=built_in>quat</span>(angle, glm::<span class=built_in>vec3</span>(axisX, axisY, axisZ));</span><br></pre></table></figure><li><p><strong>从旋转矩阵转换到四元数</strong>:</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>glm::quat qFromMat = glm::<span class=built_in>quat_cast</span>(rotationMatrix);</span><br></pre></table></figure><li><p><strong>四元数插值</strong> (<code>slerp</code>):</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>glm::quat interpolatedQ = glm::<span class=built_in>slerp</span>(q1, q2, t);</span><br></pre></table></figure><li><p><strong>四元数转欧拉角</strong>:</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>glm::vec3 eulerAngles = glm::<span class=built_in>eulerAngles</span>(q);</span><br></pre></table></figure><li><p><strong>四元数转旋转矩阵</strong>:</p> <figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>glm::mat4 matFromQuat = glm::<span class=built_in>mat4_cast</span>(q);</span><br></pre></table></figure></ul><h2 id=Assimp><a class=headerlink href=#Assimp title=Assimp></a>Assimp</h2><p>模型加载库<h3 id=读取文件><a class=headerlink href=#读取文件 title=读取文件></a>读取文件</h3><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>Assimp::Importer::<span class=built_in>ReadFile</span>()</span><br></pre></table></figure><p>​ 该类将读取文件并处理其数据，将导入的数据作为指向一个对象的指针返回。现在可以从文件中提取所需的数据。<p>​ 导入器为自己管理所有资源。如果导入器被销毁，那么由它创建/读取的所有数据也将被销毁。因此，使用Importer最简单的方法是在本地创建一个实例，使用它的结果，然<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTassimp/Importer.hpp></span>      <span class=comment>// C++ importer interface</span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTassimp/scene.h></span>           <span class=comment>// Output data structure</span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTassimp/postprocess.h></span>     <span class=comment>// Post processing flags</span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>bool</span> <span class=title>DoTheImportThing</span><span class=params>( <span class=keyword>const</span> std::string& pFile)</span> </span>{</span><br><span class=line>  <span class=comment>// Create an instance of the Importer class</span></span><br><span class=line>  Assimp::Importer importer;</span><br><span class=line></span><br><span class=line>  <span class=comment>// And have it read the given file with some example postprocessing</span></span><br><span class=line>  <span class=comment>// Usually - if speed is not the most important aspect for you - you'll</span></span><br><span class=line>  <span class=comment>// probably to request more postprocessing than we do in this example.</span></span><br><span class=line>  <span class=keyword>const</span> aiScene* scene = importer.<span class=built_in>ReadFile</span>( pFile,</span><br><span class=line>    aiProcess_CalcTangentSpace       |</span><br><span class=line>    aiProcess_Triangulate            |</span><br><span class=line>    aiProcess_JoinIdenticalVertices  |</span><br><span class=line>    aiProcess_SortByPType);</span><br><span class=line></span><br><span class=line>  <span class=comment>// If the import failed, report it</span></span><br><span class=line>  <span class=keyword>if</span> (<span class=literal>nullptr</span> == scene) {</span><br><span class=line>    <span class=built_in>DoTheErrorLogging</span>( importer.<span class=built_in>GetErrorString</span>());</span><br><span class=line>    <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=comment>// Now we can access the file's contents.</span></span><br><span class=line>  <span class=built_in>DoTheSceneProcessing</span>( scene);</span><br><span class=line></span><br><span class=line>  <span class=comment>// We're done. Everything will be cleaned up by the importer destructor</span></span><br><span class=line>  <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>后简单地让它离开作用域。<h3 id=数据结构><a class=headerlink href=#数据结构 title=数据结构></a>数据结构</h3><p>以结构集合的形式返回导入的数据。aiScene形成数据的根，从这里可以访问从导入文件中<strong>读取的所有节点，网格，材质，动画或纹理</strong>。<p>默认情况下，所有3D数据都以右手坐标系提供，例如OpenGL使用的坐标系。在这个坐标系中，+X指向右侧，+Y指向上方，+Z指向屏幕外的观察者<p>输出面顺序为逆时针方向<h5 id=Scene><a class=headerlink href=#Scene title=Scene></a>Scene</h5><p>场景包含一个rootNode用于遍历以及mesh和material,通过node中的mesh索引获得具体mesh,通过mesh中的material索引获得具体material,mesh还包括faces,一个face就是一个primitive.<ol><li><strong><code>mFlags</code></strong>: 这个标志表示场景的一些特性，例如是否是不完整的 (<code>AI_SCENE_FLAGS_INCOMPLETE</code>) 或者是否有无效的数据 (<code>AI_SCENE_FLAGS_INVALID_DATA</code>)。<li><strong><code>mRootNode</code></strong>: 指向场景根节点的指针。每个场景都有一个根节点，所有其他节点都是它的子节点。通过遍历这个节点树，你可以获取场景的所有几何信息。<li><strong><code>mNumMeshes</code> 和 <code>mMeshes</code></strong>: 分别表示场景中网格的数量和指向网格数组的指针。网格包含了顶点、面和其他几何数据。<li><strong><code>mNumMaterials</code> 和 <code>mMaterials</code></strong>: 分别表示场景中材质的数量和指向材质数组的指针。材质定义了网格的外观属性。<li><strong><code>mNumTextures</code> 和 <code>mTextures</code></strong>: 分别表示场景中文本贴图的数量和指向文本贴图数组的指针。请注意，不是所有的模型格式都支持直接导出纹理，所以这个成员可能为空。<li><strong><code>mNumCameras</code> 和 <code>mCameras</code></strong>: 分别表示场景中相机的数量和指向相机数组的指针。并不是所有模型文件都会包含相机信息。<li><strong><code>mNumLights</code> 和 <code>mLights</code></strong>: 分别表示场景中光源的数量和指向光源数组的指针。同样地，并非所有模型文件都包含光源信息。<li><strong><code>mMetaData</code></strong>: 包含有关场景的元数据。这可以包括版本号、作者等信息</ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br></pre><td class=code><pre><span class=line><span class=comment>// 假设我们已经有一个 aiScene* scene</span></span><br><span class=line></span><br><span class=line><span class=comment>// 访问根节点</span></span><br><span class=line>aiNode* rootNode = scene->mRootNode;</span><br><span class=line></span><br><span class=line><span class=comment>// 遍历所有网格</span></span><br><span class=line><span class=keyword>for</span> (<span class=keyword>unsigned</span> <span class=keyword>int</span> i = <span class=number>0</span>; i < scene->mNumMeshes; ++i) {</span><br><span class=line>    aiMesh* mesh = scene->mMeshes[i];</span><br><span class=line>    <span class=comment>// 处理网格...</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 遍历所有材质</span></span><br><span class=line><span class=keyword>for</span> (<span class=keyword>unsigned</span> <span class=keyword>int</span> i = <span class=number>0</span>; i < scene->mNumMaterials; ++i) {</span><br><span class=line>    aiMaterial* material = scene->mMaterials[i];</span><br><span class=line>    <span class=comment>// 处理材质...</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 如果有纹理，遍历它们</span></span><br><span class=line><span class=keyword>if</span> (scene->mNumTextures > <span class=number>0</span>) {</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>unsigned</span> <span class=keyword>int</span> i = <span class=number>0</span>; i < scene->mNumTextures; ++i) {</span><br><span class=line>        aiTexture* texture = scene->mTextures[i];</span><br><span class=line>        <span class=comment>// 处理纹理...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 如果有相机，遍历它们</span></span><br><span class=line><span class=keyword>if</span> (scene->mNumCameras > <span class=number>0</span>) {</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>unsigned</span> <span class=keyword>int</span> i = <span class=number>0</span>; i < scene->mNumCameras; ++i) {</span><br><span class=line>        aiCamera* camera = scene->mCameras[i];</span><br><span class=line>        <span class=comment>// 处理相机...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 如果有光源，遍历它们</span></span><br><span class=line><span class=keyword>if</span> (scene->mNumLights > <span class=number>0</span>) {</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>unsigned</span> <span class=keyword>int</span> i = <span class=number>0</span>; i < scene->mNumLights; ++i) {</span><br><span class=line>        aiLight* light = scene->mLights[i];</span><br><span class=line>        <span class=comment>// 处理光源...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h5 id=Nodes><a class=headerlink href=#Nodes title=Nodes></a>Nodes</h5><p>节点是场景中名字不大的实体，相对于它们的父节点有一个位置和方向。从场景的根节点开始，所有节点可以有0到x个子节点，从而形成一个层次结构。<ol><li><strong><code>mTransformation</code></strong>:<ul><li>类型: <code>aiMatrix4x4</code><li>描述: 表示节点的本地变换矩阵，它定义了该节点相对于其父节点的位置、旋转和缩放。</ul><li><strong><code>mNumMeshes</code> 和 <code>mMeshes</code></strong>:<ul><li>类型: <code>unsigned int</code> 和 <code>unsigned int*</code><li>描述: <code>mNumMeshes</code> 表示此节点直接关联的网格数量；<code>mMeshes</code> 是一个索引数组，指向 <code>aiScene</code> 的 <code>mMeshes</code> 数组中的相应网格。如果 <code>mNumMeshes</code> 为 0，则该节点没有直接关联的网格。</ul><li><strong><code>mParent</code></strong>:<ul><li>类型: <code>aiNode*</code><li>描述: 指向该节点的父节点的指针。根节点的 <code>mParent</code> 为 <code>nullptr</code>。</ul><li><strong><code>mNumChildren</code> 和 <code>mChildren</code></strong>:<ul><li>类型: <code>unsigned int</code> 和 <code>aiNode**</code><li>描述: <code>mNumChildren</code> 表示该节点的子节点数量；<code>mChildren</code> 是一个指针数组，指向该节点的所有子节点。</ul><li><strong><code>mName</code></strong>:<ul><li>类型: <code>aiString</code><li>描述: 节点的名字。在某些情况下，这个名字可能被用来标识特定的节点或作为动画等的参考</ul></ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=comment>// 假设我们有一个 aiNode* node</span></span><br><span class=line></span><br><span class=line><span class=comment>// 获取节点的变换矩阵</span></span><br><span class=line>aiMatrix4x4 transformation = node->mTransformation;</span><br><span class=line></span><br><span class=line><span class=comment>// 遍历所有与该节点关联的网格</span></span><br><span class=line><span class=keyword>for</span> (<span class=keyword>unsigned</span> <span class=keyword>int</span> i = <span class=number>0</span>; i < node->mNumMeshes; ++i) {</span><br><span class=line>    <span class=keyword>unsigned</span> <span class=keyword>int</span> meshIndex = node->mMeshes[i];</span><br><span class=line>    aiMesh* mesh = scene->mMeshes[meshIndex];</span><br><span class=line>    <span class=comment>// 处理网格...</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 获取父节点</span></span><br><span class=line><span class=keyword>if</span> (node->mParent != <span class=literal>nullptr</span>) {</span><br><span class=line>    aiNode* parentNode = node->mParent;</span><br><span class=line>    <span class=comment>// 处理父节点...</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 遍历所有子节点</span></span><br><span class=line><span class=keyword>for</span> (<span class=keyword>unsigned</span> <span class=keyword>int</span> i = <span class=number>0</span>; i < node->mNumChildren; ++i) {</span><br><span class=line>    aiNode* childNode = node->mChildren[i];</span><br><span class=line>    <span class=comment>// 处理子节点...</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 获取节点名称</span></span><br><span class=line><span class=function>std::string <span class=title>nodeName</span><span class=params>(node->mName.C_Str())</span></span>;</span><br></pre></table></figure><h5 id=Mesh><a class=headerlink href=#Mesh title=Mesh></a>Mesh</h5><ol><li><strong><code>mPrimitiveTypes</code></strong>:<ul><li>类型: <code>unsigned int</code><li>描述: 表示该网格中包含的图元类型，例如点 (<code>aiPrimitiveType_POINT</code>)、线 (<code>aiPrimitiveType_LINE</code>) 或三角形 (<code>aiPrimitiveType_TRIANGLE</code>)。</ul><li><strong><code>mNumVertices</code> 和 <code>mVertices</code></strong>:<ul><li>类型: <code>unsigned int</code> 和 <code>aiVector3D*</code><li>描述: <code>mNumVertices</code> 表示顶点的数量；<code>mVertices</code> 是指向 <code>aiVector3D</code> 数组的指针，每个元素代表一个顶点的位置。</ul><li><strong><code>mNormals</code></strong>:<ul><li>类型: <code>aiVector3D*</code><li>描述: 指向法线数组的指针。如果网格包含法线数据，则每个顶点都有一个对应的法线向量。</ul><li><strong><code>mTextureCoords</code></strong>:<ul><li>类型: <code>aiVector3D**</code><li>描述: 指向纹理坐标数组的二维数组指针。第一维是纹理坐标集的数量（最多8个），第二维是实际的纹理坐标。如果某个顶点有纹理坐标，则可以通过这个成员访问。</ul><li><strong><code>mColors</code></strong>:<ul><li>类型: <code>aiColor4D**</code><li>描述: 指向颜色数组的二维数组指针。第一维是颜色集的数量（最多8个），第二维是实际的颜色值。如果顶点有色值，则可以在这里找到。</ul><li><strong><code>mNumFaces</code> 和 <code>mFaces</code></strong>:<ul><li>类型: <code>unsigned int</code> 和 <code>aiFace*</code><li>描述: <code>mNumFaces</code> 表示面的数量；<code>mFaces</code> 是指向 <code>aiFace</code> 数组的指针，每个 <code>aiFace</code> 定义了一个由若干顶点组成的多边形（通常是三角形）。</ul><li><strong><code>mMaterialIndex</code></strong>:<ul><li>类型: <code>unsigned int</code><li>描述: 网格使用的材质在场景的 <code>mMaterials</code> 数组中的索引。通过这个索引，你可以获取与该网格关联的 <code>aiMaterial</code> 对象。</ul><li><strong><code>mNumBones</code> 和 <code>mBones</code></strong>:<ul><li>类型: <code>unsigned int</code> 和 <code>aiBone**</code><li>描述: 如果网格支持骨骼动画，则 <code>mBones</code> 包含了指向 <code>aiBone</code> 数组的指针，每个 <code>aiBone</code> 定义了一个影响顶点位置的骨骼。<code>mNumBones</code> 是骨骼的数量。</ul><li><strong><code>mName</code></strong>:<ul><li>类型: <code>aiString</code><li>描述: 网格的名字。某些情况下，这个名字可能是有意义的，比如用于标识特定的网格或作为其他资源的引用。</ul></ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br></pre><td class=code><pre><span class=line><span class=comment>// 假设我们有一个 aiMesh* mesh 和 aiScene* scene</span></span><br><span class=line></span><br><span class=line><span class=comment>// 获取网格的材质</span></span><br><span class=line>aiMaterial* material = scene->mMaterials[mesh->mMaterialIndex];</span><br><span class=line></span><br><span class=line><span class=comment>// 遍历所有顶点</span></span><br><span class=line><span class=keyword>for</span> (<span class=keyword>unsigned</span> <span class=keyword>int</span> i = <span class=number>0</span>; i < mesh->mNumVertices; ++i) {</span><br><span class=line>    aiVector3D position = mesh->mVertices[i];</span><br><span class=line>    <span class=comment>// 处理顶点位置...</span></span><br><span class=line>    </span><br><span class=line>    <span class=keyword>if</span> (mesh-><span class=built_in>HasNormals</span>()) {</span><br><span class=line>        aiVector3D normal = mesh->mNormals[i];</span><br><span class=line>        <span class=comment>// 处理法线...</span></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (mesh-><span class=built_in>HasTextureCoords</span>(<span class=number>0</span>)) { <span class=comment>// 假设使用第0个纹理坐标集</span></span><br><span class=line>        aiVector3D texCoord = mesh->mTextureCoords[<span class=number>0</span>][i];</span><br><span class=line>        <span class=comment>// 处理纹理坐标...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 遍历所有面</span></span><br><span class=line><span class=keyword>for</span> (<span class=keyword>unsigned</span> <span class=keyword>int</span> i = <span class=number>0</span>; i < mesh->mNumFaces; ++i) {</span><br><span class=line>    aiFace face = mesh->mFaces[i];</span><br><span class=line>    <span class=comment>// 处理面...</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>unsigned</span> <span class=keyword>int</span> j = <span class=number>0</span>; j < face.mNumIndices; ++j) {</span><br><span class=line>        <span class=keyword>unsigned</span> <span class=keyword>int</span> vertexIndex = face.mIndices[j];</span><br><span class=line>        <span class=comment>// 使用顶点索引...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 如果有骨骼信息，遍历它们</span></span><br><span class=line><span class=keyword>if</span> (mesh-><span class=built_in>HasBones</span>()) {</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>unsigned</span> <span class=keyword>int</span> i = <span class=number>0</span>; i < mesh->mNumBones; ++i) {</span><br><span class=line>        aiBone* bone = mesh->mBones[i];</span><br><span class=line>        <span class=comment>// 处理骨骼...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><code>aiMesh</code> 还提供了一些辅助函数来检查网格是否包含特定的数据类型：<ul><li><strong><code>HasPositions()</code></strong>: 返回网格是否有顶点位置。<li><strong><code>HasNormals()</code></strong>: 返回网格是否有法线数据。<li><strong><code>HasTangentsAndBitangents()</code></strong>: 返回网格是否有切线和副切线数据。<li><strong><code>HasTextureCoords(unsigned int)</code></strong>: 接受一个参数指定纹理坐标集的索引，返回网格是否有对应的纹理坐标。<li><strong><code>HasVertexColors(unsigned int)</code></strong>: 接受一个参数指定颜色集的索引，返回网格是否有对应的顶点颜色。<li><strong><code>HasFaces()</code></strong>: 返回网格是否有面数据。<li><strong><code>HasBones()</code></strong>: 返回网格是否有骨骼信息。</ul><h5 id=Material><a class=headerlink href=#Material title=Material></a>Material</h5><h6 id=颜色属性><a class=headerlink href=#颜色属性 title=颜色属性></a>颜色属性</h6><ul><li><strong><code>AI_MATKEY_COLOR_DIFFUSE</code></strong>: 扩散（漫反射）颜色。<li><strong><code>AI_MATKEY_COLOR_AMBIENT</code></strong>: 环境光颜色。<li><strong><code>AI_MATKEY_COLOR_SPECULAR</code></strong>: 高光（镜面反射）颜色。<li><strong><code>AI_MATKEY_COLOR_EMISSIVE</code></strong>: 发射光颜色。<li><strong><code>AI_MATKEY_COLOR_TRANSPARENT</code></strong>: 透明颜色。<li><strong><code>AI_MATKEY_COLOR_REFLECTIVE</code></strong>: 反射颜色。</ul><h6 id=浮点数属性><a class=headerlink href=#浮点数属性 title=浮点数属性></a>浮点数属性</h6><ul><li><strong><code>AI_MATKEY_SHININESS</code></strong>: 高光强度。<li><strong><code>AI_MATKEY_SHININESS_STRENGTH</code></strong>: 高光强度因子。<li><strong><code>AI_MATKEY_REFRACTI</code></strong>: 折射率。</ul><h6 id=布尔属性><a class=headerlink href=#布尔属性 title=布尔属性></a>布尔属性</h6><ul><li><strong><code>AI_MATKEY_ENABLE_WIREFRAME</code></strong>: 是否启用线框模式。</ul><h6 id=纹理属性><a class=headerlink href=#纹理属性 title=纹理属性></a>纹理属性</h6><ul><li><strong><code>AI_MATKEY_TEXTURE_BASE</code></strong>: 基础纹理。<li><strong><code>AI_MATKEY_TEXTURE_DIFFUSE</code></strong>: 扩散（漫反射）纹理。<li><strong><code>AI_MATKEY_TEXTURE_SPECULAR</code></strong>: 高光（镜面反射）纹理。<li><strong><code>AI_MATKEY_TEXTURE_AMBIENT</code></strong>: 环境光纹理。<li><strong><code>AI_MATKEY_TEXTURE_EMISSIVE</code></strong>: 发射光纹理。<li><strong><code>AI_MATKEY_TEXTURE_HEIGHT</code></strong>: 高度图。<li><strong><code>AI_MATKEY_TEXTURE_NORMALS</code></strong>: 法线贴图。<li><strong><code>AI_MATKEY_TEXTURE_SHININESS</code></strong>: 高光贴图。<li><strong><code>AI_MATKEY_TEXTURE_OPACITY</code></strong>: 不透明度贴图。<li><strong><code>AI_MATKEY_TEXTURE_DISPLACEMENT</code></strong>: 位移贴图。<li><strong><code>AI_MATKEY_TEXTURE_LIGHTMAP</code></strong>: 光照贴图。<li><strong><code>AI_MATKEY_TEXTURE_REFLECTION</code></strong>: 反射贴图。</ul><h6 id=方法><a class=headerlink href=#方法 title=方法></a>方法</h6><p>为了访问上述属性，<code>aiMaterial</code> 提供了一系列的 <code>Get</code> 和 <code>Set</code> 函数。最常用的 <code>Get</code> 函数包括：<ol><li><strong><code>Get(AI_MATKEY key, aiColor4D& out)</code></strong>:<ul><li>获取指定键的颜色值。</ul><li><strong><code>Get(AI_MATKEY key, float& out)</code></strong>:<ul><li>获取指定键的浮点数值。</ul><li><strong><code>Get(AI_MATKEY key, bool& out)</code></strong>:<ul><li>获取指定键的布尔值。</ul><li><strong><code>GetTexture(aiTextureType type, unsigned int index, aiString\* path)</code></strong>:<ul><li>获取指定类型的纹理路径。<code>index</code> 参数允许你访问同一类型下的多个纹理（例如，多层扩散纹理）。</ul><li><strong><code>HasProperty(const char\* key)</code></strong>:<ul><li>检查材质是否具有给定键的属性。</ul><li><strong><code>Get(AI_MATKEY key, unsigned int& out)</code></strong>:<ul><li>获取指定键的无符号整数值（例如，用于获取纹理的数量）</ul></ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=comment>// 假设我们有一个 aiMaterial* material</span></span><br><span class=line></span><br><span class=line><span class=comment>// 获取扩散颜色</span></span><br><span class=line>aiColor4D diffuseColor;</span><br><span class=line><span class=keyword>if</span> (AI_SUCCESS == material-><span class=built_in>Get</span>(AI_MATKEY_COLOR_DIFFUSE, diffuseColor)) {</span><br><span class=line>    <span class=comment>// 使用 diffuseColor...</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 获取高光强度</span></span><br><span class=line><span class=keyword>float</span> shininess;</span><br><span class=line><span class=keyword>if</span> (AI_SUCCESS == material-><span class=built_in>Get</span>(AI_MATKEY_SHININESS, shininess)) {</span><br><span class=line>    <span class=comment>// 使用 shininess...</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 获取第一个扩散纹理路径</span></span><br><span class=line>aiString texturePath;</span><br><span class=line><span class=keyword>if</span> (AI_SUCCESS == material-><span class=built_in>GetTexture</span>(aiTextureType_DIFFUSE, <span class=number>0</span>, &texturePath)) {</span><br><span class=line>    <span class=comment>// 使用 texturePath.C_Str()...</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 检查是否有环境光颜色</span></span><br><span class=line><span class=keyword>if</span> (material-><span class=built_in>HasProperty</span>(AI_MATKEY_COLOR_AMBIENT)) {</span><br><span class=line>    aiColor4D ambientColor;</span><br><span class=line>    <span class=keyword>if</span> (AI_SUCCESS == material-><span class=built_in>Get</span>(AI_MATKEY_COLOR_AMBIENT, ambientColor)) {</span><br><span class=line>        <span class=comment>// 使用 ambientColor...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h5 id=Texture><a class=headerlink href=#Texture title=Texture></a>Texture</h5><p>通常，资源使用的纹理存储在单独的文件中，但是也有文件格式将纹理直接嵌入到模型文件中。这样的纹理被加载到aittexture结构中<ol><li><strong><code>mWidth</code> 和 <code>mHeight</code></strong>:<ul><li>类型: <code>unsigned int</code><li>描述: 分别表示纹理图像的宽度和高度（以像素为单位）。对于非图像格式（例如程序生成的纹理），这些值可能为0。</ul><li><strong><code>mData</code></strong>:<ul><li>类型: <code>unsigned char*</code><li>描述: 指向包含纹理数据的缓冲区。注意，并不是所有情况下都会提供实际的纹理数据；某些导入器可能会直接返回文件路径而不是加载图像数据到内存中。</ul><li><strong><code>mHeight</code></strong>:<ul><li>类型: <code>unsigned int</code><li>描述: 纹理的高度（以像素为单位）。</ul><li><strong><code>achFormatHint</code></strong>:<ul><li>类型: <code>char[AI_TEXTURE_FORMAT_MAX]</code><li>描述: 提供关于纹理格式的提示字符串，例如 <code>"jpg"</code> 或 <code>"png"</code>。这可以帮助你确定如何正确地解码纹理数据。</ul><li><strong><code>mFilename</code></strong>:<ul><li>类型: <code>aiString</code><li>描述: 包含纹理文件的相对或绝对路径名。这是最常用的方式来获取纹理资源的位置。</ul></ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=comment>// 假设我们有一个 aiTexture* texture</span></span><br><span class=line></span><br><span class=line><span class=comment>// 获取纹理文件名</span></span><br><span class=line><span class=function>std::string <span class=title>filename</span><span class=params>(texture->mFilename.C_Str())</span></span>;</span><br><span class=line>std::cout << <span class=string>"Texture filename: "</span> << filename << std::endl;</span><br><span class=line></span><br><span class=line><span class=comment>// 如果有纹理数据，可以尝试读取其大小</span></span><br><span class=line><span class=keyword>if</span> (texture->mWidth > <span class=number>0</span> && texture->mHeight > <span class=number>0</span>) {</span><br><span class=line>    std::cout << <span class=string>"Texture dimensions: "</span> << texture->mWidth << <span class=string>"x"</span> << texture->mHeight << std::endl;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 根据格式提示来决定如何处理纹理数据</span></span><br><span class=line><span class=function>std::string <span class=title>formatHint</span><span class=params>(texture->achFormatHint)</span></span>;</span><br><span class=line><span class=keyword>if</span> (!formatHint.<span class=built_in>empty</span>()) {</span><br><span class=line>    std::cout << <span class=string>"Texture format hint: "</span> << formatHint << std::endl;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 如果有纹理数据，可以直接使用指针访问</span></span><br><span class=line><span class=keyword>if</span> (texture->mData != <span class=literal>nullptr</span>) {</span><br><span class=line>    <span class=comment>// 注意：这里只是示例，通常你需要根据具体的格式解码这些数据</span></span><br><span class=line>    <span class=keyword>unsigned</span> <span class=keyword>char</span>* data = texture->mData;</span><br><span class=line>    <span class=comment>// 使用纹理数据...</span></span><br><span class=line>}</span><br></pre></table></figure><h2 id=stb-image><a class=headerlink href=#stb-image title=stb_image></a>stb_image</h2><p>加载图像库,通过<code>stbi_load</code>读取图像的宽高和通道<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br></pre><td class=code><pre><span class=line><span class=function>GLuint <span class=title>LoadTexture</span><span class=params>(<span class=keyword>const</span> <span class=keyword>char</span> *path, <span class=keyword>bool</span> clip)</span> </span>{</span><br><span class=line>  <span class=comment>// 生成纹理</span></span><br><span class=line>  GLuint texture;</span><br><span class=line>  <span class=built_in>glGenTextures</span>(<span class=number>1</span>, &texture);</span><br><span class=line>  <span class=built_in>stbi_set_flip_vertically_on_load</span>(<span class=literal>true</span>);</span><br><span class=line>  <span class=comment>// 加载图像</span></span><br><span class=line>  <span class=keyword>int</span> img_width, img_height, nrChannels;</span><br><span class=line>  <span class=keyword>unsigned</span> <span class=keyword>char</span> *data =</span><br><span class=line>      <span class=built_in>stbi_load</span>(path, &img_width, &img_height, &nrChannels, <span class=number>0</span>);</span><br><span class=line>  <span class=keyword>if</span> (data) {</span><br><span class=line>    GLenum format;</span><br><span class=line>    <span class=keyword>if</span> (nrChannels == <span class=number>1</span>) {</span><br><span class=line>      format = GL_RED;</span><br><span class=line>    } <span class=keyword>else</span> <span class=keyword>if</span> (nrChannels == <span class=number>3</span>) {</span><br><span class=line>      format = GL_RGB;</span><br><span class=line>    } <span class=keyword>else</span> <span class=keyword>if</span> (nrChannels == <span class=number>4</span>) {</span><br><span class=line>      format = GL_RGBA;</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>      <span class=keyword>throw</span> std::<span class=built_in>runtime_error</span>(<span class=string>"No available format."</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=built_in>glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class=line>    <span class=built_in>glTexImage2D</span>(GL_TEXTURE_2D, <span class=number>0</span>, format, img_width, img_height, <span class=number>0</span>, format,</span><br><span class=line>                 GL_UNSIGNED_BYTE, data);</span><br><span class=line>    <span class=built_in>glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class=line>    <span class=keyword>if</span> (clip) {</span><br><span class=line>      <span class=built_in>glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class=line>      <span class=built_in>glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>      <span class=built_in>glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class=line>      <span class=built_in>glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class=line>    }</span><br><span class=line>    <span class=built_in>glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,</span><br><span class=line>                    GL_LINEAR_MIPMAP_LINEAR);</span><br><span class=line>    <span class=built_in>glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class=line></span><br><span class=line>  } <span class=keyword>else</span> {</span><br><span class=line>    std::cerr << <span class=string>"Failed to load texture"</span> << std::endl;</span><br><span class=line>    std::cout << <span class=string>"Error: Failed to load the image because "</span></span><br><span class=line>              << <span class=built_in>stbi_failure_reason</span>();</span><br><span class=line>    <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=built_in>stbi_image_free</span>(data);</span><br><span class=line>  <span class=keyword>return</span> texture;</span><br><span class=line>}</span><br></pre></table></figure><link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script></div><div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a href=https://www.sekyoro.top/2024/12/25/glsl%E5%AD%A6%E4%B9%A0/ title=OpenGL中不可忽视的部分:glsl、glm、assimp以及更多>https://www.sekyoro.top/2024/12/25/glsl学习/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div><footer class=post-footer><div class=post-tags><a href=/tags/GLSL%E7%BC%96%E7%A8%8B/ rel=tag><i class="fa fa-tag"></i> GLSL编程</a></div><div class=post-nav><div class=post-nav-item><a href=/2024/12/09/%E4%BB%8EC-%E6%A8%A1%E6%9D%BF%E8%B0%88%E8%B5%B7/ rel=prev title=从C++模板谈起> <i class="fa fa-chevron-left"></i> 从C++模板谈起 </a></div><div class=post-nav-item><a title="Agentic RAG and LLMs-based assistant" href=/2024/12/26/Agentic-RAG-and-LLMs-based-assistant/ rel=next> Agentic RAG and LLMs-based assistant <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div><!-- 评论区 --><div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#GLSL><span class=nav-number>1.</span> <span class=nav-text>GLSL</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA><span class=nav-number>1.1.</span> <span class=nav-text>开发环境搭建</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B><span class=nav-number>1.2.</span> <span class=nav-text>数据类型</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%87%8D%E8%A6%81%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0><span class=nav-number>1.3.</span> <span class=nav-text>重要辅助函数</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97><span class=nav-number>1.3.1.</span> <span class=nav-text>向量和矩阵运算</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%BA%B9%E7%90%86%E9%87%87%E6%A0%B7><span class=nav-number>1.3.2.</span> <span class=nav-text>纹理采样</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%85%89%E7%85%A7%E8%AE%A1%E7%AE%97><span class=nav-number>1.3.3.</span> <span class=nav-text>光照计算</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%AB%98%E7%BA%A7GLSL><span class=nav-number>1.4.</span> <span class=nav-text>高级GLSL</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8><span class=nav-number>1.4.1.</span> <span class=nav-text>顶点着色器</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8><span class=nav-number>1.4.2.</span> <span class=nav-text>片段着色器</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%8E%A5%E5%8F%A3%E5%9D%97><span class=nav-number>1.4.3.</span> <span class=nav-text>接口块</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Uniform%E7%BC%93%E5%86%B2%E5%AF%B9%E8%B1%A1><span class=nav-number>1.4.4.</span> <span class=nav-text>Uniform缓冲对象</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Uniform%E5%9D%97%E5%B8%83%E5%B1%80><span class=nav-number>1.4.5.</span> <span class=nav-text>Uniform块布局</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BD%BF%E7%94%A8Uniform%E7%BC%93%E5%86%B2><span class=nav-number>1.4.6.</span> <span class=nav-text>使用Uniform缓冲</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#GLM><span class=nav-number>2.</span> <span class=nav-text>GLM</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95><span class=nav-number>2.1.</span> <span class=nav-text>常用方法</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%90%91%E9%87%8F%E6%93%8D%E4%BD%9C><span class=nav-number>2.1.1.</span> <span class=nav-text>向量操作</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C><span class=nav-number>2.1.2.</span> <span class=nav-text>矩阵操作</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%9B%9B%E5%85%83%E6%95%B0%E6%93%8D%E4%BD%9C><span class=nav-number>2.1.3.</span> <span class=nav-text>四元数操作</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Assimp><span class=nav-number>3.</span> <span class=nav-text>Assimp</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6><span class=nav-number>3.1.</span> <span class=nav-text>读取文件</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84><span class=nav-number>3.2.</span> <span class=nav-text>数据结构</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#Scene><span class=nav-number>3.2.0.1.</span> <span class=nav-text>Scene</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Nodes><span class=nav-number>3.2.0.2.</span> <span class=nav-text>Nodes</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Mesh><span class=nav-number>3.2.0.3.</span> <span class=nav-text>Mesh</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Material><span class=nav-number>3.2.0.4.</span> <span class=nav-text>Material</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#%E9%A2%9C%E8%89%B2%E5%B1%9E%E6%80%A7><span class=nav-number>3.2.0.4.1.</span> <span class=nav-text>颜色属性</span></a><li class="nav-item nav-level-6"><a class=nav-link href=#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%B1%9E%E6%80%A7><span class=nav-number>3.2.0.4.2.</span> <span class=nav-text>浮点数属性</span></a><li class="nav-item nav-level-6"><a class=nav-link href=#%E5%B8%83%E5%B0%94%E5%B1%9E%E6%80%A7><span class=nav-number>3.2.0.4.3.</span> <span class=nav-text>布尔属性</span></a><li class="nav-item nav-level-6"><a class=nav-link href=#%E7%BA%B9%E7%90%86%E5%B1%9E%E6%80%A7><span class=nav-number>3.2.0.4.4.</span> <span class=nav-text>纹理属性</span></a><li class="nav-item nav-level-6"><a class=nav-link href=#%E6%96%B9%E6%B3%95><span class=nav-number>3.2.0.4.5.</span> <span class=nav-text>方法</span></a></ol><li class="nav-item nav-level-5"><a class=nav-link href=#Texture><span class=nav-number>3.2.0.5.</span> <span class=nav-text>Texture</span></a></ol></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#stb-image><span class=nav-number>4.</span> <span class=nav-text>stb_image</span></a></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>248</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>16</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>217</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a><li class=links-of-blogroll-item><a href=https://www.lllomh.com/ rel=noopener target=_blank title=https://www.lllomh.com/>芈渡</a><li class=links-of-blogroll-item><a href=https://protool-ten.vercel.app/ rel=noopener target=_blank title=https://protool-ten.vercel.app/>protools</a></ul></div><div class="motion-element announcement"><div class=title></div><p class=content><p class=date></div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>文章词云</h3><div class="widget tagcloud" id=myCanvasContainer><canvas height=250 id=resCanvas style=width:100% width=250><ul class=tag-list itemprop=keywords><li class=tag-list-item><a class=tag-list-link href=/tags/GLSL%E7%BC%96%E7%A8%8B/ rel=tag>GLSL编程</a><span class=tag-list-count>1</span></ul></canvas></div></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2025</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>3.4m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>51:46</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer></div><script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script><script src=/lib/anime.min.js></script><script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script><script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/pisces.js></script><script src=/js/next-boot.js></script><script src=/js/bookmark.js></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	'.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script><script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script><script src=/js/algolia-search.js></script><script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script><div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div><script charset=utf-8 defer src=/js/tagcanvas.js></script><script charset=utf-8 defer src=/js/tagcloud.js></script><script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script><script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script><script src=/js/src/activate-power-mode.min.js></script><script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script>
<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"0F9LEEVW82","apiKey":"78839e9f9be09d081c5c4da81975cd19","indexName":"sekyoblog_sec","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content=很早之间就想学学传说中的cs61a/b/c了,这里花两三天时间过一遍cs61c(2020). name=description><meta content=article property=og:type><meta content=打实基础:cs61c学习 property=og:title><meta content=https://www.sekyoro.top/2024/10/01/%E6%89%93%E5%AE%9E%E5%9F%BA%E7%A1%80-cs61c%E5%AD%A6%E4%B9%A0/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content=很早之间就想学学传说中的cs61a/b/c了,这里花两三天时间过一遍cs61c(2020). property=og:description><meta content=zh_CN property=og:locale><meta content=https://s2.loli.net/2024/10/01/vy67mZfx5C9RIok.png property=og:image><meta content=https://s2.loli.net/2024/10/01/iKzPvVZAfa1pCnG.png property=og:image><meta content=https://s2.loli.net/2024/10/02/2QKgjTAZU48rXcP.png property=og:image><meta content=https://s2.loli.net/2024/10/02/VFjKlRYLwc826qb.png property=og:image><meta content=https://s2.loli.net/2024/10/02/MG3ecRyFif1njkb.png property=og:image><meta content=https://s2.loli.net/2024/10/02/q8GXlWucIeimaCz.png property=og:image><meta content=https://s2.loli.net/2024/10/02/HAY1F6ZsJbhjix7.png property=og:image><meta content=https://s2.loli.net/2024/10/02/DZFX7x5wgIiQHCK.png property=og:image><meta content=https://s2.loli.net/2024/10/03/nkSE5IHOro7KWYV.png property=og:image><meta content=2024-10-01T06:18:42.000Z property=article:published_time><meta content=2024-10-03T06:36:03.157Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content=c property=article:tag><meta content=summary name=twitter:card><meta content=https://s2.loli.net/2024/10/01/vy67mZfx5C9RIok.png name=twitter:image><link href=https://www.sekyoro.top/2024/10/01/%E6%89%93%E5%AE%9E%E5%9F%BA%E7%A1%80-cs61c%E5%AD%A6%E4%B9%A0/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>打实基础:cs61c学习 | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2024/10/01/%E6%89%93%E5%AE%9E%E5%9F%BA%E7%A1%80-cs61c%E5%AD%A6%E4%B9%A0/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>打实基础:cs61c学习</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-10-01 14:18:42" datetime=2024-10-01T14:18:42+08:00>2024-10-01</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2024-10-03 14:36:03" datetime=2024-10-03T14:36:03+08:00 itemprop=dateModified>2024-10-03</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>14k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>12 分钟</span> </span></div></header><div class=post-body itemprop=articleBody><p>很早之间就想学学传说中的cs61a/b/c了,这里花两三天时间过一遍cs61c(2020).</p><span id=more></span><p>整个课程做起来最大的问题是,过去的课程目前不开放给校外人员了,现有的资料没有保存图片,所以lab没有图片..<h2 id=Labs><a class=headerlink href=#Labs title=Labs></a>Labs</h2><h3 id=00><a class=headerlink href=#00 title=00></a>00</h3><p>学习常用指令,我个人常用(由于我目前使用windows,许多指令都没有)find,grep,ps,kill等指令<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>ps aux | grep <span class=string>"xxx"</span></span><br><span class=line>find ./ -<span class=built_in>type</span> f -<span class=built_in>exec</span> grep <span class=string>"xx"</span> {} +</span><br></pre></table></figure><p>现在Linux上有许多重写的更好用的工具,比如<code>ripgrep</code>,<code>btop</code>等等<h3 id=01><a class=headerlink href=#01 title=01></a>01</h3><p>使用gdb和valgrind<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>gcc -g -o hello hello.c</span><br><span class=line>gdb hello</span><br><span class=line>b <span class=comment># set breakpoint</span></span><br><span class=line>bt <span class=comment># backtrace </span></span><br><span class=line>p expr <span class=comment># display value</span></span><br><span class=line>c <span class=comment># continue running</span></span><br><span class=line>n <span class=comment># next line,stepping over function calls</span></span><br><span class=line>s <span class=comment># next line,stepping into function calls</span></span><br></pre></table></figure><p>详情查看manual<a href=https://www.learncs.site/assets/files/gdb5-refcard-89fdebb2475f348ded03071dd13271df.pdf rel=noopener target=_blank>gdb5-refcard-89fdebb2475f348ded03071dd13271df.pdf (learncs.site)</a><p><img alt=image-20241001160602317 data-src=https://s2.loli.net/2024/10/01/vy67mZfx5C9RIok.png><p>运行时内存错误可以使用valgrind. Valgrind是一个程序,模拟你的CPU和跟踪你的内存访问<p>此外写一个检查链表是否有循环的c代码<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>"ll_cycle.h"</span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstddef.h></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>ll_has_cycle</span><span class=params>(node *head)</span> </span>{</span><br><span class=line>  <span class=comment>/* your code here */</span></span><br><span class=line>  <span class=keyword>if</span> (head == <span class=literal>NULL</span> || head->next == <span class=literal>NULL</span>) {</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>  }</span><br><span class=line>  node *tortoise = head;</span><br><span class=line>  node *hare = tortoise->next->next;</span><br><span class=line>  <span class=keyword>while</span> (hare != <span class=literal>NULL</span>) {</span><br><span class=line>    tortoise = tortoise->next;</span><br><span class=line>    <span class=keyword>if</span> (hare == tortoise) {</span><br><span class=line>      <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>if</span> (hare->next == <span class=literal>NULL</span>) {</span><br><span class=line>      <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>    }</span><br><span class=line>    hare = hare->next->next;</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><h3 id=02><a class=headerlink href=#02 title=02></a>02</h3><p>学习使用Makefile(虽然我现在基本使用CMake或者直接用visual studio(当然vs仙子啊也支持了cmake))<blockquote><p>makefile是代码目录中的一个文本文件(字面上标记为“makefile”)，其中包含一组规则，每个规则都有为其编译C程序的命令。每个makefile可以包含多个规则，每个规则编译一个或多个目标(例如可执行文件)或执行不同的目标。要编译一个目标，程序员只需要在他们的命令终端输入“make</blockquote><p>使用位操作分别获取,设置,翻转一个值的某位.<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>unsigned</span> <span class=title>get_bit</span><span class=params>(<span class=keyword>unsigned</span> x, <span class=keyword>unsigned</span> n)</span> </span>{</span><br><span class=line>  <span class=comment>// YOUR CODE HERE</span></span><br><span class=line>  <span class=comment>// Returning -1 is a placeholder (it makes</span></span><br><span class=line>  <span class=comment>// no sense, because get_bit only returns</span></span><br><span class=line>  <span class=comment>// 0 or 1)</span></span><br><span class=line>  <span class=keyword>int</span> mask = <span class=number>1</span> << n; <span class=comment>// e.g. n  = 5, 000100000</span></span><br><span class=line>  <span class=keyword>return</span> (x & mask) >> n;</span><br><span class=line>}</span><br><span class=line><span class=comment>// Set the nth bit of the value of x to v.</span></span><br><span class=line><span class=comment>// Assume 0 <= n <= 31, and v is 0 or 1</span></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>set_bit</span><span class=params>(<span class=keyword>unsigned</span> *x, <span class=keyword>unsigned</span> n, <span class=keyword>unsigned</span> v)</span> </span>{</span><br><span class=line>  <span class=comment>// YOUR CODE HERE</span></span><br><span class=line>  <span class=keyword>int</span> mask = <span class=number>1</span> << n;</span><br><span class=line>  <span class=keyword>if</span> (v == <span class=number>1</span>) {</span><br><span class=line>    *x = *x | mask;</span><br><span class=line>  } <span class=keyword>else</span> {</span><br><span class=line>    *x = *x & ~mask;</span><br><span class=line>  }</span><br><span class=line>}</span><br><span class=line><span class=comment>// Flip the nth bit of the value of x.</span></span><br><span class=line><span class=comment>// Assume 0 <= n <= 31</span></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>flip_bit</span><span class=params>(<span class=keyword>unsigned</span> *x, <span class=keyword>unsigned</span> n)</span> </span>{</span><br><span class=line>  <span class=comment>// YOUR CODE HERE</span></span><br><span class=line>  <span class=keyword>int</span> mask = <span class=number>1</span> << n;</span><br><span class=line>  *x = *x ^ mask;</span><br><span class=line>}</span><br></pre></table></figure><p>实现线性反馈移位寄存器<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>void</span> <span class=title>lfsr_calculate</span><span class=params>(<span class=keyword>uint16_t</span> *reg)</span> </span>{</span><br><span class=line>  <span class=comment>/* YOUR CODE HERE */</span></span><br><span class=line>  <span class=keyword>int</span> bit0 = *reg & <span class=number>1</span>;</span><br><span class=line>  <span class=keyword>int</span> bit2 = (*reg >> <span class=number>2</span>) & <span class=number>1</span>;</span><br><span class=line>  <span class=keyword>int</span> bit3 = (*reg >> <span class=number>3</span>) & <span class=number>1</span>;</span><br><span class=line>  <span class=keyword>int</span> bit5 = (*reg >> <span class=number>5</span>) & <span class=number>1</span>;</span><br><span class=line>  <span class=keyword>int</span> new_bit = bit0 ^ bit2 ^ bit3 ^ bit5;</span><br><span class=line>  *reg = *reg >> <span class=number>1</span>;</span><br><span class=line>  <span class=keyword>int</span> mask = new_bit << <span class=number>15</span>;</span><br><span class=line>  *reg = *reg | mask;</span><br><span class=line>}</span><br></pre></table></figure><p>然后实现一个动态长度array,其实就是利用<code>malloc</code>,<code>free</code>分配内存,这些内存往往在堆上.<figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>typedef</span> <span class=class><span class=keyword>struct</span> {</span></span><br><span class=line>  usize capacity;</span><br><span class=line>  uszie size;</span><br><span class=line>  <span class=keyword>int</span>* data;</span><br><span class=line>} DArray;</span><br></pre></table></figure><p>初始化和free时主要需要分别malloc整个结构和存储的data数据,<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>vector_t</span> *<span class=title>vector_new</span><span class=params>()</span> </span>{</span><br><span class=line>  <span class=comment>/* Declare what this function will return */</span></span><br><span class=line>  <span class=keyword>vector_t</span> *retval;</span><br><span class=line></span><br><span class=line>  <span class=comment>/* First, we need to allocate memory on the heap for the struct */</span></span><br><span class=line>  retval = (<span class=keyword>vector_t</span> *)<span class=built_in>malloc</span>(<span class=keyword>sizeof</span>(<span class=keyword>vector_t</span>)); <span class=comment>/* YOUR CODE HERE */</span></span><br><span class=line></span><br><span class=line>  <span class=comment>/* Check our return value to make sure we got memory */</span></span><br><span class=line>  <span class=keyword>if</span> (retval == <span class=literal>NULL</span>) {</span><br><span class=line>    allocation_failed();</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=comment>/* Now we need to initialize our data.</span></span><br><span class=line><span class=comment>     Since retval->data should be able to dynamically grow,</span></span><br><span class=line><span class=comment>     what do you need to do? */</span></span><br><span class=line>  retval->size = <span class=number>1</span> <span class=comment>/* YOUR CODE HERE */</span>;</span><br><span class=line>  retval->data = (<span class=keyword>int</span> *)<span class=built_in>malloc</span>(retval->size * <span class=keyword>sizeof</span>(<span class=keyword>int</span>)) <span class=comment>/* YOUR CODE HERE */</span>;</span><br><span class=line></span><br><span class=line>  <span class=comment>/* Check the data attribute of our vector to make sure we got memory */</span></span><br><span class=line>  <span class=keyword>if</span> (retval->data == <span class=literal>NULL</span>) {</span><br><span class=line>    <span class=built_in>free</span>(retval); <span class=comment>// Why is this line necessary?</span></span><br><span class=line>    allocation_failed();</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=comment>/* Complete the initialization by setting the single component to zero */</span></span><br><span class=line>  retval->data[<span class=number>0</span>] = <span class=number>0</span>;</span><br><span class=line></span><br><span class=line>  <span class=comment>/* and return... */</span></span><br><span class=line>  <span class=keyword>return</span> retval;</span><br><span class=line>}</span><br></pre></table></figure><h3 id=03><a class=headerlink href=#03 title=03></a>03</h3><p>RISCV汇编,<p>.data段落包含初始化的全局和静态变量, .word段用于分配和初始化内存(通常4字节)<p>.text段落包括程序的可执行指令,x0寄存器中值始终为0<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line>.text</span><br><span class=line>main:</span><br><span class=line>    add t0, x0, x0 # curr_fib = 0</span><br><span class=line>    addi t1, x0, 1 # next_fib = 1</span><br><span class=line>la t3, n # load the address of the label n</span><br><span class=line>lw t3, 0(t3) # get the value that is stored at the adddress denoted by the label n</span><br><span class=line>fib:</span><br><span class=line>    beq t3, x0, finish # exit loop once we have completed n iterations</span><br><span class=line>    add t2, t1, t0 # new_fib = curr_fib + next_fib;</span><br><span class=line>    mv t0, t1 # curr_fib = next_fib;</span><br><span class=line>    mv t1, t2 # next_fib = new_fib;</span><br><span class=line>    addi t3, t3, -1 # decrement counter</span><br><span class=line>    j fib # loop</span><br><span class=line>finish:</span><br><span class=line>    addi a0, x0, 1 # argument to ecall to execute print integer</span><br><span class=line>    addi a1, t0, 0 # argument to ecall, the value to be printed</span><br><span class=line>    ecall # print integer ecall</span><br></pre></table></figure><p><code>ecall</code>是系统调用,要传递参数，需要将其放入参数寄存器(a0-a7)。当函数执行时，它将在这些寄存器中查找参数。第一个参数应该放在a0中，第二个参数应该放在a1中，以此类推。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=keyword>int</span> source[] = {<span class=number>3</span>, <span class=number>1</span>, <span class=number>4</span>, <span class=number>1</span>, <span class=number>5</span>, <span class=number>9</span>, <span class=number>0</span>};</span><br><span class=line><span class=keyword>int</span> dest[<span class=number>10</span>];</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>fun</span><span class=params>(<span class=keyword>int</span> x)</span> </span>{</span><br><span class=line>	<span class=keyword>return</span> -x * (x + <span class=number>1</span>);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> k;</span><br><span class=line>    <span class=keyword>int</span> sum = <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>for</span> (k = <span class=number>0</span>; source[k] != <span class=number>0</span>; k++) {</span><br><span class=line>        dest[k] = fun(source[k]);</span><br><span class=line>        sum += dest[k];</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> sum;</span><br><span class=line>}</span><br></pre></table></figure><p>上面c代码转为汇编,全局变量使用<code>.data</code>和<code>.word</code>分配,只写t和a寄存器(临时寄存器和参数寄存器),s寄存器在调用函数前注意保存<p><img alt=image-20241001195355718 data-src=https://s2.loli.net/2024/10/01/iKzPvVZAfa1pCnG.png><ul><li><p><strong><code>li</code> 指令</strong>：将立即数加载到寄存器中。</p><li><p><strong><code>la</code> 指令</strong>：加载变量的地址到寄存器中。</p><li><p><strong><code>lw</code> 指令</strong>：从内存中加载一个 32 位字到寄存器中。</p><li><p><strong><code>sw</code> 指令</strong>：将寄存器中的 32 位字存储到内存中。</p><li><p><strong><code>sw</code> 指令</strong>：将寄存器中的 32 位字存储到内存中。</p><li><p><strong><code>sh</code> 指令</strong>：将寄存器中的 16 位半字存储到内存中。</p><li><p><strong><code>sb</code> 指令</strong>：将寄存器中的 8 位字节存储到内存中</p> <p>内存地址主要就是寄存器offset寻址</p></ul><h4 id=RISC-V-调用约定><a title="RISC-V 调用约定" class=headerlink href=#RISC-V-调用约定></a>RISC-V 调用约定</h4><p>RISC-V 的调用约定规定了哪些寄存器在函数调用时需要保存，哪些寄存器可以被修改。以下是一些主要的约定：<ol><li><strong>临时寄存器（Temporary Registers）</strong>：<ul><li><strong><code>t0</code> 至 <code>t6</code></strong>：这些寄存器可以在函数调用时被修改，调用者不需要保存这些寄存器的值。<li><strong><code>a0</code> 至 <code>a7</code></strong>：这些寄存器用于传递函数参数，也可以在函数调用时被修改，调用者不需要保存这些寄存器的值。</ul><li><strong>保存寄存器（Saved Registers）</strong>：<ul><li><strong><code>s0</code> 至 <code>s11</code></strong>：这些寄存器在函数调用时需要保存，被调用者必须在返回前恢复这些寄存器的值。<li><strong><code>ra</code></strong>：返回地址寄存器，被调用者必须在返回前恢复 <code>ra</code> 的值。</ul></ol><p><strong>保存和恢复寄存器</strong><p>为了确保函数调用的正确性，通常需要在函数入口处保存这些寄存器的值，并在函数返回前恢复这些值。这通常通过使用堆栈来实现(利用<code>sp</code>栈寄存器). 通常内存上的值首先加到寄存器上然后再进行计算.<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>.data</span><br><span class=line>n: .word 8</span><br><span class=line>lw t0, 0(sp) ; t0 = [sp]</span><br><span class=line>la t1, n</span><br><span class=line>lw t1, 0(t1) ; t1 = [t1]</span><br><span class=line>addi t1,t1,2</span><br><span class=line>sw t0, 0(t1) ; [t1] = t0</span><br></pre></table></figure><p>使用RISCV写一段factorial代码,注意要么写为recursion要么写更简单的iteration<figure class="highlight stylus"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=title>factorial</span><span class=params>(n)</span></span> = n!</span><br></pre></table></figure><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line>factorial:</span><br><span class=line>  addi sp,sp,-4</span><br><span class=line>  sw s0,0(sp) # sp[0] = s0</span><br><span class=line>  addi s0,x0,1 # sum = 1</span><br><span class=line>  addi t0,x0,1 # i = 1</span><br><span class=line>loop:</span><br><span class=line>  blt a0,t0,exit # if n < i, goto exit</span><br><span class=line>  mul s0,s0,t0# sum = sum * i</span><br><span class=line>  addi t0,t0,1 # i++</span><br><span class=line>  jal x0,loop</span><br><span class=line>exit:</span><br><span class=line>  add a0,x0,s0 # a0 = sum</span><br><span class=line>  lw s0,0(sp) # s0 = sp[0]</span><br><span class=line>  addi sp,sp,4</span><br><span class=line>  jr ra</span><br></pre></table></figure><blockquote><p>所有覆盖按约定保留的寄存器的函数都必须有一个序言(prologue)和一个尾声(epilogue)，序言将这些寄存器值保存到函数开始时的堆栈中;epilogue将为函数的调用者恢复这些值。 由于调用约定违反而导致的bug很难发现,不要直接修改这些寄存器<p>也就是对于保存寄存器的处理,包括s开头的寄存器和ra寄存器(受jal影响)</blockquote><p>后面有一个专门的测试,在每个函数前后写上将s寄存器值保存到内存的代码,此外如果一个函数栈中调用了另一个函数,如果那个函数修改了t寄存器,那么父函数栈也需要保存相应的寄存器. 对于ra寄存器同理,函数<code>jrl</code>调用另一个函数,修改了ra寄存器值,也需要在调用另一个函数之前保存ra,否则这个函数无法通过<code>jr</code>跳转回去了(当然可以使用j label调转到某个位置).<p>此外还使用RISC-V实现了链表分配和map操作.<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line>create_default_list:</span><br><span class=line>    addi sp, sp, -12</span><br><span class=line>    sw  ra, 0(sp)</span><br><span class=line>    sw  s0, 4(sp)</span><br><span class=line>    sw  s1, 8(sp)</span><br><span class=line>    li  s0, 0       # pointer to the last node we handled</span><br><span class=line>    li  s1, 0       # number of nodes handled</span><br><span class=line>loop:   #do...</span><br><span class=line>    li  a0, 8</span><br><span class=line>    jal ra, malloc      # get memory for the next node</span><br><span class=line>    sw  s1, 0(a0)   # node->value = i</span><br><span class=line>    sw  s0, 4(a0)   # node->next = last</span><br><span class=line>    add s0, a0, x0  # last = node</span><br><span class=line>    addi    s1, s1, 1   # i++</span><br><span class=line>    addi t0, x0, 10</span><br><span class=line>    bne s1, t0, loop    # ... while i!= 10</span><br><span class=line>    lw  ra, 0(sp)</span><br><span class=line>    lw  s0, 4(sp)</span><br><span class=line>    lw  s1, 8(sp)</span><br><span class=line>    addi sp, sp, 12</span><br><span class=line>    jr ra</span><br><span class=line>malloc:</span><br><span class=line>    addi    a1, a0, 0</span><br><span class=line>    addi    a0, x0 9</span><br><span class=line>    ecall</span><br><span class=line>    jr  r</span><br></pre></table></figure><p>上面malloc中调用了<code>ecall</code>系统调用.<p>实现高阶函数<code>map</code>操作<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br></pre><td class=code><pre><span class=line>map:</span><br><span class=line>    # Prologue: Make space on the stack and back-up registers</span><br><span class=line>    ### YOUR CODE HERE ###</span><br><span class=line>    addi sp,sp,-12</span><br><span class=line>    sw ra, 0(sp)</span><br><span class=line>    sw s0, 4(sp)</span><br><span class=line>    sw s1, 8(sp)</span><br><span class=line></span><br><span class=line>    beq a0, x0, done    # If we were given a null pointer (address 0), we're done.</span><br><span class=line></span><br><span class=line>    add s0, a0, x0  # Save address of this node in s0</span><br><span class=line>    add s1, a1, x0  # Save address of function in s1</span><br><span class=line></span><br><span class=line>    # Remember that each node is 8 bytes long: 4 for the value followed by 4 for the pointer to next.</span><br><span class=line>    # What does this tell you about how you access the value and how you access the pointer to next?</span><br><span class=line></span><br><span class=line>    # load the value of the current node into a0</span><br><span class=line>    # THINK: why a0? prepare to call map</span><br><span class=line>    ### YOUR CODE HERE ###</span><br><span class=line>    lw a0,0(s0) # a0 = [s0]</span><br><span class=line></span><br><span class=line>    # Call the function in question on that value. DO NOT use a label (be prepared to answer why).</span><br><span class=line>    # What function? Recall the parameters of "map"</span><br><span class=line>    ### YOUR CODE HERE ###</span><br><span class=line>    # jal is used to jump to label</span><br><span class=line>    jalr ra, s1 ,0 # call square</span><br><span class=line>    # Where can you assume the returned value is?</span><br><span class=line>    ### YOUR CODE HERE ###</span><br><span class=line>    sw a0, 0(s0) # [s0] = a0</span><br><span class=line></span><br><span class=line>    # Load the address of the next node into a0</span><br><span class=line>    # The Address of the next node is an attribute of the current node.</span><br><span class=line>    # Think about how structs are organized in memory.</span><br><span class=line>    ### YOUR CODE HERE ###</span><br><span class=line>    lw a0, 4(s0) # a0 = [s0+4]</span><br><span class=line></span><br><span class=line>    # Put the address of the function back into a1 to prepare for the recursion</span><br><span class=line>    # THINK: why a1? What about a0?</span><br><span class=line>    ### YOUR CODE HERE ###</span><br><span class=line>    mv a1, s1 # not really necessary, cause a1 is not changed in square functino</span><br><span class=line></span><br><span class=line>    # recurse</span><br><span class=line>    ### YOUR CODE HERE ###</span><br><span class=line>    jal ra, map</span><br><span class=line></span><br><span class=line>done:</span><br><span class=line>    # Epilogue: Restore register values and free space from the stack</span><br><span class=line>    ### YOUR CODE HERE ###</span><br><span class=line>    lw ra, 0(sp)</span><br><span class=line>    lw s0, 4(sp)</span><br><span class=line>    lw s1, 8(sp)</span><br><span class=line>    addi sp,sp,12</span><br><span class=line>    jr ra # Return to caller</span><br><span class=line></span><br><span class=line>square:</span><br><span class=line>    mul a0 ,a0, a0</span><br><span class=line>    jr ra</span><br></pre></table></figure><h3 id=04><a class=headerlink href=#04 title=04></a>04</h3><p>修改一个汇编代码中的问题,我卡了很久还是看了其他人的解答.<p>在main中获取数组第一个值地址和大小,在mainLoop中不断遍历,修改数组值<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br></pre><td class=code><pre><span class=line>map:</span><br><span class=line>    addi sp, sp, -12</span><br><span class=line>    sw ra, 0(sp)</span><br><span class=line>    sw s1, 4(sp)</span><br><span class=line>    sw s0, 8(sp)</span><br><span class=line></span><br><span class=line>    beq a0, x0, done    # if we were given a null pointer, we're done.</span><br><span class=line></span><br><span class=line>    add s0, a0, x0      # save address of this node in s0</span><br><span class=line>    add s1, a1, x0      # save address of function in s1</span><br><span class=line>    add t0, x0, x0      # t0 is a counter</span><br><span class=line></span><br><span class=line></span><br><span class=line>    lw t1, 0(s0)   # load the address of the array of current node into t1</span><br><span class=line>    lw t2, 4(s0)        # load the size of the node's array into t2</span><br><span class=line>    addi t1, t1, -4</span><br><span class=line>    # remember that each node is 12 bytes long:</span><br><span class=line>    # - 4 for the array pointer</span><br><span class=line>    # - 4 for the size of the array</span><br><span class=line>    # - 4 more for the pointer to the next node</span><br><span class=line></span><br><span class=line>    # also keep in mind that we should not make ANY assumption on which registers</span><br><span class=line>    # are modified by the callees, even when we know the content inside the functions </span><br><span class=line>    # we call. this is to enforce the abstraction barrier of calling convention.</span><br><span class=line>mapLoop:</span><br><span class=line>    # add t1, s0, x0      # load the address of the array of current node into t1</span><br><span class=line>    addi t1, t1, 4      # offset the array address by the count</span><br><span class=line>    lw a0, 0(t1)        # load the value at that address into a0</span><br><span class=line>    addi sp,sp,-12</span><br><span class=line>    sw t0, 0(sp)</span><br><span class=line>    sw t1, 4(sp)</span><br><span class=line>    sw t2, 8(sp)</span><br><span class=line>    jalr ra,s1,0             # call the function on that value.</span><br><span class=line>    lw t0, 0(sp)</span><br><span class=line>    lw t1, 4(sp)</span><br><span class=line>    lw t2, 8(sp)</span><br><span class=line>    addi sp,sp,12</span><br><span class=line></span><br><span class=line>    sw a0, 0(t1)        # store the returned value back into the array</span><br><span class=line>    addi t0, t0, 1      # increment the count</span><br><span class=line>    bne t0, t2, mapLoop # repeat if we haven't reached the array size yet</span><br><span class=line></span><br><span class=line>    lw a0, 8(s0)  # load the address of the next node into a0</span><br><span class=line>    mv a1,s1</span><br><span class=line></span><br><span class=line>    jal  map            # recurse</span><br><span class=line>done:</span><br><span class=line>    lw s0, 8(sp)</span><br><span class=line>    lw s1, 4(sp)</span><br><span class=line>    lw ra, 0(sp)</span><br><span class=line>    addi sp, sp, 12</span><br><span class=line>    jr ra</span><br></pre></table></figure><p>然后写一个映射<figure class="highlight stylus"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=function><span class=title>f</span><span class=params>(-<span class=number>3</span>)</span></span> = <span class=number>6</span></span><br><span class=line><span class=function><span class=title>f</span><span class=params>(-<span class=number>2</span>)</span></span> = <span class=number>61</span></span><br><span class=line><span class=function><span class=title>f</span><span class=params>(-<span class=number>1</span>)</span></span> = <span class=number>17</span></span><br><span class=line><span class=function><span class=title>f</span><span class=params>(<span class=number>0</span>)</span></span> = -<span class=number>38</span></span><br><span class=line><span class=function><span class=title>f</span><span class=params>(<span class=number>1</span>)</span></span> = <span class=number>19</span></span><br><span class=line><span class=function><span class=title>f</span><span class=params>(<span class=number>2</span>)</span></span> = <span class=number>42</span></span><br><span class=line><span class=function><span class=title>f</span><span class=params>(<span class=number>3</span>)</span></span> = <span class=number>5</span></span><br></pre></table></figure><p>其中a0寄存器是输入值,a1是输出列表<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line>f:</span><br><span class=line>    addi a0,a0,3</span><br><span class=line>    # li t0, 4</span><br><span class=line>    # mul a0,a0,t0</span><br><span class=line>    # add s0,a1,a0 # s0 is the address</span><br><span class=line>    slli a0,a0,2</span><br><span class=line>    add a0,a1,a0</span><br><span class=line>    lw a0, 0(a0)</span><br><span class=line>    </span><br><span class=line>    jr ra   </span><br></pre></table></figure><h3 id=05><a class=headerlink href=#05 title=05></a>05</h3><p>使用logisim工具构建模拟电路,使用AND,OR,NOT基本件构建NAND,NOR,XOR以及Mux. 此外还有个寄存器<p><img alt=image-20241002193745279 data-src=https://s2.loli.net/2024/10/02/2QKgjTAZU48rXcP.png><p>FSM代表有限状态机。FSM跟踪给定的输入，根据这些输入在状态之间移动，并在每次输入时输出一些东西。<p>我们使用寄存器来存储当前所在FSM的状态，并使用组合逻辑将FSM的输入和当前寄存器状态映射到FSM的输出和下一个寄存器状态。说实话,这个FSM的作用我没太看懂,貌似是连续两次一样的输入,输出就固定了. 需要连现在状态到下一次状态的电路线,我按照truth table直接推的.<p>此外还需要画出rotr电路,我一开始画成下面这样,使用Mux-16针对每个0-15值选择对应偏移…<p><img alt=image-20241002224915855 data-src=https://s2.loli.net/2024/10/02/VFjKlRYLwc826qb.png><p>其实可以根据每一位使用mux-2,简单得多<p><img alt=image-20241002231322258 data-src=https://s2.loli.net/2024/10/02/MG3ecRyFif1njkb.png><h3 id=06><a class=headerlink href=#06 title=06></a>06</h3><p>关于电路流水线时间的问题,通过编排优化流水线<p><img alt=image-20241002231814951 data-src=https://s2.loli.net/2024/10/02/q8GXlWucIeimaCz.png><p>这个电路所做的就是接收两个输入，将它们相乘，然后将结果与当前状态值相加。对于这个电路，设<strong>加法器块的传播延迟为45ns，乘法块的传播延迟为60ns。寄存器的CLK-to-Q延迟为10ns，设置时间为10ns，保持时间为5ns</strong>。计算该电路可以工作的最大时钟速率。假设两个输入都来自从外部源接收数据的时钟寄存器。<p>为了确保电路能够正确工作，时钟周期必须满足以下条件：<ol><li><strong>数据路径延迟</strong> + <strong>CLK-to-Q 延迟</strong> + <strong>建立时间</strong> ≤ 时钟周期<li><strong>保持时间</strong> < 时钟周期</ol><p>首先，计算第一个条件： 时钟周期≥数据路径延迟+CLK-to-Q 延迟+建立时间时钟周期≥数据路径延迟+CLK-to-Q 延迟+建立时间 时钟周期≥105 ns+10 ns+10 ns时钟周期≥105ns+10ns+10ns 时钟周期≥125 ns时钟周期≥125ns<p>接下来，检查保持时间的要求： 时钟周期>5 ns时钟周期>5ns<p>显然，125ns 已经大于 5ns，所以保持时间的要求自然满足。<p><img alt=image-20241002232639288 data-src=https://s2.loli.net/2024/10/02/HAY1F6ZsJbhjix7.png><p>如果一个计算依赖于前一个计算的输出，那么很难对它们进行管道处理，我们通常需要插入一个(或几个)管道“bubbles”，以确保第一个计算的输出准备好成为第二个计算的输入。提醒一下，bubbles是在管道中故意延迟指令的过程。理解为什么这种“bubbles”对于这种特殊的电路是不必要的是很重要的。<p>下面这种pipeline方案在乘法和加法之间增加了一个register保存中间值,输出会增加一个前导0<p><img alt=image-20241002234052193 data-src=https://s2.loli.net/2024/10/02/DZFX7x5wgIiQHCK.png><p>在non_pipeline版本中,一个tick会同时更新输出值和寄存器的值<p>假设我们在乘法器和加法器之间插入一个寄存器，将电路分成两个阶段：<ol><li><strong>第一阶段</strong>：乘法器<li><strong>第二阶段</strong>：加法器</ol><p>每个阶段的延迟如下：<ul><li>第一阶段（乘法器）延迟：60ns<li>第二阶段（加法器）延迟：45ns</ul><p>寄存器的时序要求<ul><li><strong>CLK-to-Q 延迟</strong>：10ns<li><strong>建立时间</strong>：10ns<li><strong>保持时间</strong>：5ns</ul><p><strong>计算每个阶段的最大时钟周期</strong><p>为了确保每个阶段的时序要求都得到满足，我们需要计算每个阶段的最大时钟周期。<p><strong>第一阶段</strong><ul><li><strong>数据路径延迟</strong>：60ns<li><strong>CLK-to-Q 延迟</strong>：10ns<li><strong>建立时间</strong>：10ns</ul><p>第一阶段的时钟周期要求： 时钟周期≥60 ns+10 ns+10 ns时钟周期≥60ns+10ns+10ns 时钟周期≥80 ns时钟周期≥80ns<p><strong>第二阶段</strong><ul><li><strong>数据路径延迟</strong>：45ns<li><strong>CLK-to-Q 延迟</strong>：10ns<li><strong>建立时间</strong>：10ns</ul><p>第二阶段的时钟周期要求： 时钟周期≥45 ns+10 ns+10 ns时钟周期≥45ns+10ns+10ns 时钟周期≥65 ns时钟周期≥65ns<p>为了确保整个流水线电路能够正确工作，时钟周期必须满足所有阶段中最严格的要求。因此，最终的时钟周期应取这两个阶段的最大值：<p>时钟周期=max⁡(80 ns,65 ns)=80 ns时钟周期=max(80ns,65ns)=80ns<p>由于乘法延时比加法长,这两个阶段相对独立.<p>在流水线设计中，“气泡”（bubbles）通常指的是空闲的时钟周期，用于处理流水线中的依赖关系或避免冲突。在某些情况下，插入气泡是为了确保数据的正确性和避免数据冒险（data hazards）。然而，在这个电路中，插入一个寄存器将乘法和加法操作分成两个独立的阶段，这样可以避免大多数常见的数据冒险，因此不需要插入气泡。<p>为什么这个电路不需要气泡？<ol><li><strong>独立的流水线阶段</strong>：<ul><li>通过在乘法器和加法器之间插入一个寄存器，将整个操作分成了两个独立的阶段。<li>每个阶段都有自己的时钟周期，数据在每个阶段的末尾被寄存器捕获并传递到下一个阶段。</ul><li><strong>数据流的清晰分离</strong>：<ul><li>在第一阶段，乘法器完成乘法操作，并将结果存储在寄存器中。<li>在第二阶段，加法器从寄存器中读取乘法结果，并将其与当前状态值相加。<li>这种分离确保了每个阶段的数据都是在前一个阶段完成后的稳定状态下进行处理的，避免了数据冒险。</ul><li><strong>时序要求的满足</strong>：<ul><li>每个阶段的时钟周期都足够长，以满足寄存器的时序要求（CLK-to-Q 延迟、建立时间和保持时间）。<li>例如，第一阶段的时钟周期为 80ns，第二阶段的时钟周期为 65ns，这两个值都足以确保数据在每个阶段的末尾被正确捕获和传递</ul></ol><h3 id=07><a class=headerlink href=#07 title=07></a>07</h3><p>主要介绍cache,<p>write-back意味着在写入命中时，数据只被写入缓存，当这个写入发生时，被写入块的脏位变为1。写入缓存的速度很快，因此回写缓存中的写入延迟通常非常小。但是，当从回写缓存中取出块时，如果脏位为1，则必须使用该块的内容更新内存，因为它包含尚未反映在内存中的更改。这使得回写缓存更难以在硬件中实现。<p>write-through意味着在写命中时，数据同时写入缓存和主存。写入缓存很快，但写入主存很慢;这使得透写缓存中的写延迟比回写缓存中的写延迟慢。然而，透写缓存意味着更简单的硬件，因为我们可以假设在透写缓存中，内存总是拥有最新的数据。<p>Write-around意味着在任何情况下，数据只被写入主存;如果缓存中有要写入的块，则块的有效位变为无效位。从本质上讲，在写绕过缓存中没有写命中这样的事情;写“命中”和写“未命中”的作用是一样的<p><strong>miss policies</strong><p>write -allocate的意思是，在写失败时，将丢失的块拉到缓存中。对于回写，写分配缓存，这意味着内存永远不会直接写入;相反，总是对缓存进行写操作，并且在删除时更新内存。<p><strong>过程</strong>：<ol><li><strong>写操作</strong>：处理器尝试写入某个内存地址。<li><strong>缓存查找</strong>：缓存控制器检查该地址是否在缓存中。<li><strong>未命中</strong>：如果该地址不在缓存中，发生未命中。<li><strong>加载缓存行</strong>：从主存中读取该地址所在的整个缓存行，并将其加载到缓存中。<li><strong>写入缓存</strong>：将写操作的数据写入缓存中的相应位置。<li><strong>写入主存</strong>：根据缓存的写策略（写回或写穿透），决定是否立即将数据写入主存</ol><p>no write-allocate意味着在写失败时，不会将错过的块拉到缓存中。只更新内存<p><strong>过程</strong>：<ol><li><strong>写操作</strong>：处理器尝试写入某个内存地址。<li><strong>缓存查找</strong>：缓存控制器检查该地址是否在缓存中。<li><strong>未命中</strong>：如果该地址不在缓存中，发生未命中。<li><strong>加载缓存行</strong>：从主存中读取该地址所在的整个缓存行，并将其加载到缓存中。<li><strong>写入缓存</strong>：将写操作的数据写入缓存中的相应位置。<li><strong>写入主存</strong>：根据缓存的写策略（写回或写穿透），决定是否立即将数据写入主存</ol><p><strong>更新策略</strong><p>LRU—最近最少使用当我们决定移除缓存块以腾出空间时，我们选择在所有块中使用时间最远的块<p>随机-当我们决定移除一个缓存块来腾出空间时，我们随机选择缓存中的一个块来移除。<p>MRU—最近使用的—当我们决定移除缓存块以腾出空间时，我们选择所有块中最近使用的块<p>针对下面代码,假设缓存是write through,write-allocate,也就是命中时同时写入缓存和内存,没有命中写入缓存与内存<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>int</span> <span class=built_in>array</span>[];  <span class=comment>//Assume sizeof(int) == 4</span></span><br><span class=line><span class=keyword>for</span> (k = <span class=number>0</span>; k < repcount; k++) {		<span class=comment>// repeat repcount times</span></span><br><span class=line>  <span class=comment>/* Step through the selected array segment with the given step size. */</span></span><br><span class=line>  <span class=keyword>for</span> (index = <span class=number>0</span>; index < arraysize; index += stepsize) {</span><br><span class=line>    <span class=keyword>if</span>(option==<span class=number>0</span>)</span><br><span class=line>      <span class=built_in>array</span>[index] = <span class=number>0</span>;			<span class=comment>// Option 0: One cache access - write</span></span><br><span class=line>    <span class=keyword>else</span></span><br><span class=line>      <span class=built_in>array</span>[index] = <span class=built_in>array</span>[index] + <span class=number>1</span>;	<span class=comment>// Option 1: Two cache accesses - read AND write</span></span><br><span class=line>  }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>缓存行的组织</strong><p>缓存行的组织方式通常有以下几种：<ol><li><strong>直接映射（Direct-Mapped）</strong>：<ul><li>每个主存块只能映射到缓存中的一个特定位置。<li>简单但容易发生冲突未命中。</ul><li><strong>组相联（Set-Associative）</strong>：<ul><li>主存块可以映射到缓存中的多个位置（一组）。<li>平衡了直接映射和全相联的优缺点。</ul><li><strong>全相联（Fully Associative）</strong>：<ul><li>主存块可以映射到缓存中的任意位置。<li>复杂但灵活性高</ul></ol><h4 id=Scene-1><a title="Scene 1" class=headerlink href=#Scene-1></a>Scene 1</h4><ul><li><strong>Array Size (<code>a0</code>)</strong>: 128 (bytes)<li><strong>Step Size (<code>a1</code>)</strong>: 8<li><strong>Rep Count (<code>a2</code>)</strong>: 4<li><strong>Option (<code>a3</code>)</strong>: 0</ul><p><strong>Cache Parameters</strong>: (set these in the Cache tab)<ul><li><strong>Cache Levels</strong>: 1<li><strong>Block Size</strong>: 8<li><strong>Number of Blocks</strong>: 4<li><strong>Enable?</strong>: Should be green<li><strong>Placement Policy</strong>: Direct Mapped<li><strong>Associativity</strong>: 1 (Venus won’t let you change this, why?)<li><strong>Block Replacement Policy</strong>: LRU</ul><p>128/8/4=4,所以一次遍历会写入4次,遍历4次就会写入16次. 发现每次都没有命中,这是为什么呢？ 我们想想,每次没命中就会把对应4字节内容放入缓存和内存(write through,write-allocate),遍历一遍之后block中<p><img alt=image-20241003134801342 data-src=https://s2.loli.net/2024/10/03/nkSE5IHOro7KWYV.png><p>cache命中的应用就是矩阵(线性代数)运算<p>要正确计算矩阵乘法，循环顺序并不重要。但是<strong>选择访问矩阵元素的顺序会对性能产生很大的影响。当内存访问利用空间和时间局部性，利用已经包含在缓存中的块时，缓存性能更好</strong>(缓存命中更多，缓存丢失更少)。优化程序的内存访问模式对于从内存层次结构中获得良好的性能至关重要<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>void</span> <span class=title>multMat1</span><span class=params>( <span class=keyword>int</span> n, <span class=keyword>float</span> *A, <span class=keyword>float</span> *B, <span class=keyword>float</span> *C )</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> i,j,k;</span><br><span class=line>    <span class=comment>/* This is ijk loop order. */</span></span><br><span class=line>    <span class=keyword>for</span>( i = <span class=number>0</span>; i < n; i++ )</span><br><span class=line>        <span class=keyword>for</span>( j = <span class=number>0</span>; j < n; j++ )</span><br><span class=line>            <span class=keyword>for</span>( k = <span class=number>0</span>; k < n; k++ )</span><br><span class=line>                C[i+j*n] += A[i+k*n]*B[k+j*n];</span><br><span class=line>}</span><br></pre></table></figure><h4 id=Cache-Blocksize><a title="Cache Blocksize" class=headerlink href=#Cache-Blocksize></a>Cache Blocksize</h4><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>void</span> <span class=title>transpose_blocking</span><span class=params>(<span class=keyword>int</span> n, <span class=keyword>int</span> blocksize, <span class=keyword>int</span> *dst, <span class=keyword>int</span> *src)</span> </span>{</span><br><span class=line>  <span class=comment>// YOUR CODE HERE</span></span><br><span class=line>  <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < n; i += blocksize) {</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>0</span>; j < n; j += blocksize) {</span><br><span class=line>      <span class=keyword>for</span> (<span class=keyword>int</span> x = <span class=number>0</span>; x < blocksize; x++) {</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> y = <span class=number>0</span>; y < blocksize; y++) {</span><br><span class=line>          <span class=keyword>if</span> (i + x < n && j + y < n) {</span><br><span class=line>            dst[j + y + (i + x) * n] = src[i + x + (j + y) * n];</span><br><span class=line>          }</span><br><span class=line>        }</span><br><span class=line>      }</span><br><span class=line>    }</span><br><span class=line>  }</span><br><span class=line>}</span><br></pre></table></figure><p>设置blocksize,一次填写一个方形块，其中每个方形块的尺寸为blocksize × blocksize。<p>后面几个lab就是关于页内存,SIMD,OpenMP并行编程以及Spark等等.<h2 id=参考资料><a class=headerlink href=#参考资料 title=参考资料></a>参考资料</h2><ol><li><a href=https://www.learncs.site/docs/intro rel=noopener target=_blank>前言 | CS自学社区 (learncs.site)</a><li><a href=https://www.learncs.site/assets/files/gdb5-refcard-89fdebb2475f348ded03071dd13271df.pdf rel=noopener target=_blank>gdb5-refcard-89fdebb2475f348ded03071dd13271df.pdf (learncs.site)</a><li><a href=https://www.learncs.site/assets/files/riscvcard-75f9fb3a791fab6eee17d3cf216f77f0.pdf rel=noopener target=_blank>HTU2.indd (learncs.site)</a></ol><link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script></div><div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div class=popular-posts-header>相关文章</div><ul class=popular-posts><li class=popular-posts-item><div class=popular-posts-title><a href=\2022\05\06\write-a-compiler-by-yourself\ rel=bookmark>write_a_compiler_by_yourself</a></div><li class=popular-posts-item><div class=popular-posts-title><a href=\2021\10\03\socket学习\ rel=bookmark>socket学习</a></div><li class=popular-posts-item><div class=popular-posts-title><a href=\2021\06\12\数据结构noj-3\ rel=bookmark>数据结构noj_3</a></div><li class=popular-posts-item><div class=popular-posts-title><a href=\2021\05\17\数据结构noj_2\ rel=bookmark>数据结构noj_2</a></div><li class=popular-posts-item><div class=popular-posts-title><a href=\2021\05\10\哈夫曼编-译码\ rel=bookmark>哈夫曼编/译码</a></div></ul><div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a href=https://www.sekyoro.top/2024/10/01/%E6%89%93%E5%AE%9E%E5%9F%BA%E7%A1%80-cs61c%E5%AD%A6%E4%B9%A0/ title=打实基础:cs61c学习>https://www.sekyoro.top/2024/10/01/打实基础-cs61c学习/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div><footer class=post-footer><div class=post-tags><a href=/tags/c/ rel=tag><i class="fa fa-tag"></i> c</a></div><div class=post-nav><div class=post-nav-item><a title="Just For Fun: 学习c++之后可以尝试的框架/工具" href=/2024/09/30/Just-For-Fun-%E5%AD%A6%E4%B9%A0c-%E4%B9%8B%E5%90%8E%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E7%9A%84%E6%A1%86%E6%9E%B6-%E5%B7%A5%E5%85%B7/ rel=prev> <i class="fa fa-chevron-left"></i> Just For Fun: 学习c++之后可以尝试的框架/工具 </a></div><div class=post-nav-item><a href=/2024/10/02/%E7%AA%97%E5%8F%A3%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E6%8E%A5%E5%8F%A3/ rel=next title=窗口系统与图形绘制接口> 窗口系统与图形绘制接口 <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div><!-- 评论区 --><div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#Labs><span class=nav-number>1.</span> <span class=nav-text>Labs</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#00><span class=nav-number>1.1.</span> <span class=nav-text>00</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#01><span class=nav-number>1.2.</span> <span class=nav-text>01</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#02><span class=nav-number>1.3.</span> <span class=nav-text>02</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#03><span class=nav-number>1.4.</span> <span class=nav-text>03</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#RISC-V-%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A><span class=nav-number>1.4.1.</span> <span class=nav-text>RISC-V 调用约定</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#04><span class=nav-number>1.5.</span> <span class=nav-text>04</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#05><span class=nav-number>1.6.</span> <span class=nav-text>05</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#06><span class=nav-number>1.7.</span> <span class=nav-text>06</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#07><span class=nav-number>1.8.</span> <span class=nav-text>07</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#Scene-1><span class=nav-number>1.8.1.</span> <span class=nav-text>Scene 1</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Cache-Blocksize><span class=nav-number>1.8.2.</span> <span class=nav-text>Cache Blocksize</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99><span class=nav-number>2.</span> <span class=nav-text>参考资料</span></a></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>236</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>16</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>211</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a><li class=links-of-blogroll-item><a href=https://www.lllomh.com/ rel=noopener target=_blank title=https://www.lllomh.com/>芈渡</a><li class=links-of-blogroll-item><a href=https://protool-ten.vercel.app/ rel=noopener target=_blank title=https://protool-ten.vercel.app/>protools</a></ul></div><div class="motion-element announcement"><div class=title></div><p class=content><p class=date></div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>文章词云</h3><div class="widget tagcloud" id=myCanvasContainer><canvas height=250 id=resCanvas style=width:100% width=250><ul class=tag-list itemprop=keywords><li class=tag-list-item><a class=tag-list-link href=/tags/c/ rel=tag>c</a><span class=tag-list-count>10</span></ul></canvas></div></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2025</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>2.4m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>36:30</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer></div><script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script><script src=/lib/anime.min.js></script><script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script><script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/pisces.js></script><script src=/js/next-boot.js></script><script src=/js/bookmark.js></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	'.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script><script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script><script src=/js/algolia-search.js></script><script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script><div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div><script charset=utf-8 defer src=/js/tagcanvas.js></script><script charset=utf-8 defer src=/js/tagcloud.js></script><script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script><script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script><script src=/js/src/activate-power-mode.min.js></script><script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script>
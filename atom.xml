<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sekyoro的博客小屋</title>
  
  
  <link href="https://www.sekyoro.top/atom.xml" rel="self"/>
  
  <link href="https://www.sekyoro.top/"/>
  <updated>2023-07-09T04:24:37.782Z</updated>
  <id>https://www.sekyoro.top/</id>
  
  <author>
    <name>Sekyoro</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>青龙面板部署项目</title>
    <link href="https://www.sekyoro.top/2023/07/09/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"/>
    <id>https://www.sekyoro.top/2023/07/09/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/</id>
    <published>2023-07-09T03:21:18.000Z</published>
    <updated>2023-07-09T04:24:37.782Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>青龙面板主要用于在上面放一些自动化脚本,可以跑一些类似签到的程序.之前我部署过一些,结果服务器出现了一些问题,现在使用docker重装一下并建立一个新的docker image.<br><span id="more"></span></p><p>首先官方仓库<a href="https://github.com/whyour/qinglong">whyour/qinglong: 支持 Python3、JavaScript、Shell、Typescript 的定时任务管理平台（Timed task management platform supporting Python3, JavaScript, Shell, Typescript） (github.com)</a>,推荐使用docker的方式,卸载安装都很方便.</p><p>启动一个容器后,在本地打开设置的端口,这里不推荐使用5700,因为会有机器人扫描端口暴力破解,我之前就遇到过.此外要在防火墙上打开对应的端口.</p><p><img data-src="https://s2.loli.net/2023/07/09/DWxV5MUmoeqikjN.png" alt="image-20230709112516871"></p><p>然后在本地打开对应端口的网页,选择推送方式,我一般九用PushPlus的一对一推送,官方文档<a href="https://www.pushplus.plus/push1.html">一对一消息|pushplus(推送加)-微信消息推送平台</a></p><p>然后设置账号和密码.这样搭建就完成了,这里推荐几个脚本,一般来说越新的越好.</p><h3 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h3><p>有许多库可以使用,我之前就用的faker.详情可以看看文尾参考链接</p><h3 id="阿里云盘签到"><a href="#阿里云盘签到" class="headerlink" title="阿里云盘签到"></a>阿里云盘签到</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https:<span class="regexp">//gi</span>thub.com<span class="regexp">/mrabit/</span>aliyundriveDailyCheck.git <span class="string">&quot;autoSignin&quot;</span> <span class="string">&quot;&quot;</span> <span class="string">&quot;qlApi&quot;</span></span><br></pre></td></tr></table></figure><p>阿里云盘的自动签到</p><h3 id="美团-饿了吗"><a href="#美团-饿了吗" class="headerlink" title="美团 饿了吗"></a>美团 饿了吗</h3><ul><li>美团</li><li>定时规则：10 8,11,18,21 <em> </em> *</li><li>脚本地址：<a href="https://raw.githubusercontent.com/leafTheFish/DeathNote/main/meituanV3.js">https://raw.githubusercontent.com/leafTheFish/DeathNote/main/meituanV3.js</a></li><li></li><li>饿了么</li><li>定时规则：10 8,11,18,21 <em> </em> *</li><li>脚本地址：<a href="https://raw.githubusercontent.com/leafTheFish/DeathNote/main/elmV3.js">https://raw.githubusercontent.com/leafTheFish/DeathNote/main/elmV3.js</a></li></ul><h3 id="B站"><a href="#B站" class="headerlink" title="B站"></a>B站</h3><p>我fork了一下源项目,把输出限制在5000字以配合PushPlus的免费推送额度</p><p><a href="https://github.com/drowning-in-codes/BiliBiliToolPro/blob/main/qinglong/README.md">BiliBiliToolPro/qinglong/README.md at main · drowning-in-codes/BiliBiliToolPro · GitHub</a></p><p>注意配置相关cookie用于登录</p><p><img data-src="https://s2.loli.net/2023/07/09/czmZdETvkt41i3b.png" alt="image-20230709121439385" style="zoom:67%;" /></p><h2 id="打包镜像"><a href="#打包镜像" class="headerlink" title="打包镜像"></a>打包镜像</h2><p>由于之前装了一堆脚本结果服务器出现了一点问题,这里打算打包镜像,镜像里就带着这些脚本以及一些cookie</p><p>使用<code>docker commit</code></p><p><img data-src="https://s2.loli.net/2023/07/09/iknuaYByJEV7X8z.png" alt="image-20230709122034155"></p><p>查询刚才的新镜像</p><p><img data-src="https://s2.loli.net/2023/07/09/vYIqbO6c2BPuo9Z.png" alt="image-20230709122209545"></p><p>可以使用<code>docker tag [IMAGE ID] [NEW NAME]</code>重命名,同时删除之前的镜像</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li>[2023最新青龙面板京东脚本库（7月2日，持续更新中） - 便利空间 (conveniencespace.com)]</li><li>[<a href="https://www.cnblogs.com/anyview/p/17030881.html">青龙面板自动领京东京豆，做农场浇水、萌宠、种豆、签到等任务 - 视觉书虫 - 博客园 (cnblogs.com)</a>(<a href="https://conveniencespace.com/index.php/2022/05/03/2022最新青龙面板京东脚本库（持续更新中）/">https://conveniencespace.com/index.php/2022/05/03/2022最新青龙面板京东脚本库（持续更新中）/</a>)</li><li><a href="https://www.dujin.org/20920.html">使用青龙面板挂载「阿里云盘账号」自动签到领会员福利-缙哥哥 (dujin.org)</a></li><li><a href="https://blog.renzicu.com/2022/qinglong-meituanelm/index.html">码农大叔博客 - 技术交流 | 「薅羊毛」青龙面板 – 美团&amp;饿了么 (renzicu.com)</a></li><li><a href="https://www.runoob.com/w3cnote/docker-use-container-create-image.html">Docker 使用容器来创建镜像 | 菜鸟教程 (runoob.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;青龙面板主要用于在上面放一些自动化脚本,可以跑一些类似签到的程序.之前我部署过一些,结果服务器出现了一些问题,现在使用docker重装一下并建立一个新的docker image.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Astro+Vercel部署博客</title>
    <link href="https://www.sekyoro.top/2023/07/07/Astro-Vercel%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/"/>
    <id>https://www.sekyoro.top/2023/07/07/Astro-Vercel%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-07-07T07:21:56.000Z</published>
    <updated>2023-07-08T09:27:46.837Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>类似于hexo,这里使用Astro部署博客.创建一个Github项目部署在Vercel,主要目的是记录一些琐碎的学习记录,顺便学习一下很热的Astro.</p><span id="more"></span><h2 id="Astro介绍"><a href="#Astro介绍" class="headerlink" title="Astro介绍"></a>Astro介绍</h2><p>Astro 是<strong>集多功能于一体的 Web 框架</strong>，用于构建<strong>快速、以内容为中心</strong>的网站。</p><h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><p><a href="https://docs.astro.build/zh-cn/getting-started/#主要特性">标题部分 主要特性</a></p><ul><li><strong>组件群岛:</strong> 用于构建更快网站的新 web 架构。</li><li><strong>服务器优先的 API 设计:</strong> 从用户设备上去除高成本的 Hydration。</li><li><strong>默认零 JS:</strong> 没有 JavaScript 运行时开销来减慢你的速度。</li><li><strong>边缘就绪:</strong> 在任何地方部署，甚至像 Deno 或 Cloudflare 这样的全球边缘运行时。</li><li><strong>可定制:</strong> Tailwind, MDX 和 100 多个其他集成可供选择。</li><li><strong>不依赖特定 UI:</strong> 支持 React, Preact, Svelte, Vue, Solid, Lit 等等</li></ul><p>可以使用<a href="[CodeSandbox: Code, Review and Deploy in Record Time](https://codesandbox.io/">codesandbox</a>)与<a href="[StackBlitz | Instant Dev Environments | Click. Code. Done.](https://stackblitz.com/">stackblitz</a>)在线写一些代码.</p><p>可以在这个网站<a href="https://astro.new/latest/">Getting Started | astro.new</a>玩玩一些常用模板.</p><p>也有其他用户的例子<a href="https://astro.build/themes/">Themes | Astro</a>，关于主题的.</p><p>另外可以使用astro方便添加其他库,比如添加tailwind.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx astro add tailwind</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2023/07/08/h6JqXOmDHubWRzy.png" alt="image-20230708152345258"></p><p>这里增加了tailwind以及react</p><h3 id="Astro的配置"><a href="#Astro的配置" class="headerlink" title="Astro的配置"></a>Astro的配置</h3><blockquote><p>在 <code>astro.config.mjs</code> 文件中自定义 Astro 的运行方式。它在 Astro 项目中十分常见，所有官方的示例模板和主题都默认附带。</p></blockquote><p>这里我使用了Blog模板,用于记录博客的.</p><p><img data-src="C:/Users/Tim/AppData/Roaming/Typora/typora-user-images/image-20230708172345905.png" alt="image-20230708172345905"></p><blockquote><ul><li>Edit this page in <code>src/pages/index.astro</code></li><li>Edit the site header items in <code>src/components/Header.astro</code></li><li>Add your name to the footer in <code>src/components/Footer.astro</code></li><li>Check out the included blog posts in <code>src/pages/blog/</code></li><li>Customize the blog post page layout in <code>src/layouts/BlogPost.astro</code></li></ul></blockquote><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><blockquote><p>Astro 为你的项目提供了一个有想法的文件夹布局。每个 Astro 项目的根目录下都应该包括以下目录和文件：</p><ul><li><code>src/*</code> - 你的项目源代码（组件、页面、样式等）。</li><li><code>public/*</code> - 你的非代码、未处理的资源（字体、图标等）。</li><li><code>package.json</code> - 项目列表。</li><li><code>astro.config.mjs</code> - Astro 配置文件（可选）。</li><li><code>tsconfig.json</code> - TypeScript 配置文件（可选）。</li></ul></blockquote><h4 id="src-components"><a href="#src-components" class="headerlink" title="src/components"></a><code>src/components</code></h4><p><a href="https://docs.astro.build/zh-cn/core-concepts/project-structure/#srccomponents">标题部分 src/components</a></p><p><strong>组件</strong>是你在 HTML 页面中可重复使用的代码单元。它可以是 <a href="https://docs.astro.build/zh-cn/core-concepts/astro-components/">Astro 组件</a> 或是像 React 或 Vue 这样的<a href="https://docs.astro.build/zh-cn/core-concepts/framework-components/">前端组件</a>。通常将你项目中所有组件都分组放在这个文件夹中。</p><p>这在 Astro 项目中是个习惯，但不过你可以自由地根据喜好进行管理。</p><h4 id="src-layouts"><a href="#src-layouts" class="headerlink" title="src/layouts"></a><code>src/layouts</code></h4><p><a href="https://docs.astro.build/zh-cn/core-concepts/project-structure/#srclayouts">标题部分 src/layouts</a></p><p><a href="https://docs.astro.build/zh-cn/core-concepts/layouts/">布局</a>是特殊的组件，它将一些内容包裹在一个更大的页面布局中。通常用在 <a href="https://docs.astro.build/zh-cn/core-concepts/astro-pages/">Astro 页面</a>和 <a href="https://docs.astro.build/zh-cn/guides/markdown-content/">Markdown 页面</a>中以定义页面的布局。</p><p>和 <code>src/components</code> 一样，这个目录也只是约定俗成。</p><h4 id="src-pages"><a href="#src-pages" class="headerlink" title="src/pages"></a><code>src/pages</code></h4><p><a href="https://docs.astro.build/zh-cn/core-concepts/project-structure/#srcpages">标题部分 src/pages</a></p><p><a href="https://docs.astro.build/zh-cn/core-concepts/astro-pages/">页面</a>是一种用于创建新的页面的特殊组件。一个页面可以是一个 Astro 组件，也可以是一个 Markdown 文件，它代表你网站的一些内容页面。</p><h4 id="src-styles"><a href="#src-styles" class="headerlink" title="src/styles"></a><code>src/styles</code></h4><p><a href="https://docs.astro.build/zh-cn/core-concepts/project-structure/#srcstyles">标题部分 src/styles</a></p><p>在 <code>src/styles</code> 目录下存储你的 CSS 或 Sass 文件仍只是个习惯。只要你的样式在 <code>src/</code> 目录下的某个地方，并且正确导入，Astro 就能处理并压缩它们。</p><h4 id="public"><a href="#public" class="headerlink" title="public/"></a><code>public/</code></h4><p><a href="https://docs.astro.build/zh-cn/core-concepts/project-structure/#public">标题部分 public/</a></p><p><code>public/</code> 目录用于文件和资源，它不会在 Astro 构建过程中处理。这些文件将不加修改地被直接复制到构建文件夹。</p><p>这种行为使得 <code>public/</code> 成为存放图片和字体等普通资源或 <code>robots.txt</code> 和 <code>manifest.webmanifest</code> 等特殊文件的理想选择。</p><h3 id="撰写组件"><a href="#撰写组件" class="headerlink" title="撰写组件"></a>撰写组件</h3><blockquote><p>Astro 组件非常灵活的。通常情况下，Astro 组件会包含一些<strong>可在页面中复用的 UI</strong>，如 header 或简介卡。在其他时候，Astro 组件可能包含一个较小的 HTML 片段，像是常见的使 SEO 更好的 <code>&lt;meta&gt;</code> 标签集合。Astro 组件甚至可以包含整个页面布局。</p><p>Astro 组件中最重要的一点是，它们在构建过程中会被<strong>渲染成 HTML</strong>。即使你在组件内运行 JavaScript 代码，它也会抢先一步运行从呈现给用户的最终页面中剥离出来。其最终使得网站变得更快，且默认不用任何 JavaScript。</p></blockquote><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://docs.astro.build/zh-cn/getting-started/">入门指南 🚀 Astro 文档</a></li><li><a href="https://2022.stateofjs.com/en-US/">State of JavaScript 2022 (stateofjs.com)</a></li><li><a href="https://astro.new/latest/">Getting Started | astro.new</a></li><li><a href="https://www.youtube.com/watch?v=NniT0vKyn-E&amp;ab_channel=developedbyed">(1) Astro Crash Course in 60 Minutes - YouTube</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;类似于hexo,这里使用Astro部署博客.创建一个Github项目部署在Vercel,主要目的是记录一些琐碎的学习记录,顺便学习一下很热的Astro.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Astro" scheme="https://www.sekyoro.top/tags/Astro/"/>
    
    <category term="Vercel" scheme="https://www.sekyoro.top/tags/Vercel/"/>
    
    <category term="Github" scheme="https://www.sekyoro.top/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>AI写作工作流</title>
    <link href="https://www.sekyoro.top/2023/06/12/AI%E5%86%99%E4%BD%9C%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>https://www.sekyoro.top/2023/06/12/AI%E5%86%99%E4%BD%9C%E5%B7%A5%E4%BD%9C%E6%B5%81/</id>
    <published>2023-06-12T11:17:40.000Z</published>
    <updated>2023-06-12T13:33:45.141Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用ChatGPT可以帮助写作,但其本身是个对话AI,有专门帮助写作的AI.这里做一个介绍同时尝试整合到日常工作流中.<br><span id="more"></span></p><p>之前想在一些自媒体号上发布一些好用的ChatGPT以及微软的Bing替代品,没想过还通过不了审核,甚至有些平台ChatGPT都不好提.于是打算在这里写写,也可以关注我的微信公众号或者个人网站。</p><p>这里推荐的AI写作工具有几个要求:</p><ol><li>有免费计划或者额度</li><li>最好提供API便于开发</li><li>专注于写作,不需要一句一句去询问.如果能生成一些图片辅助写作就更好了.</li><li>多语言支持</li></ol><p>我将体验下面的每个应用并给出个人见解。</p><h3 id="Chatsonic-writesonic"><a href="#Chatsonic-writesonic" class="headerlink" title="Chatsonic(writesonic)"></a>Chatsonic(writesonic)</h3><p><a href="https://writesonic.com/?via=devinder14">Writesonic - Best AI Writer, Copywriting &amp; Paraphrasing Tool</a></p><p>可以说是比较推荐的工具了,有免费方案,功能很多,还有浏览器扩展以及app.</p><p><img data-src="https://i.imgur.com/NC0RjRO.png" alt="image-20230612201548133"></p><p>如果你没有精力去搞其他工具,那光使用这个就行了,可以使用浏览器扩展或者手机App.</p><p>具体来说有以下优点</p><p>1.来源于事实和实时信息</p><p>如果您正在寻找一种有效的方式来生成具有最新新闻、事实和数字的内容，Chatsonic是最好的ChatGPT替代品。为了提供实时更新，Chatsonic的人工智能聊天机器人与谷歌搜索集成。</p><p>通过使用自然语言处理（NLP）和机器学习，Chatsonic对有关当前新闻和趋势的问题提供准确的答案，并提供详细的总结和见解。</p><p>2.理解语音命令</p><p>由于NLP—ChatSonic可以理解语音命令。</p><p>你只需要发出一个语音命令，它就会生成你所需要的东西。此外，它还可以响应像Siri或谷歌助手的语音命令，最终可以帮助您节省更多的时间，使整体体验更加愉快。</p><p>3.充当你的个人助理</p><p>把Chatsonic想象成你的虚拟助理，他在你的指尖上给你提供你需要的信息。</p><p>无论您是需要数学方面的帮助，还是需要准备工作面试，或是需要有关屋檐下任何东西的信息，Chatsonic都能为您的内容创作带来革命性的变化。</p><p>在我们都以提高生产力为目标的时候，Chatsonic帮助用户更快地写作，并使这个过程变得愉快。</p><p>4.将想法转化为独特的数字艺术</p><p>目前，所有像Chat GPT这样的网站都有一个共同的局限性：它们不能生成支持内容的令人惊叹的AI艺术。</p><p>这就是Chatsonic作为一个差异化因素出现的地方。您可以快速轻松地创建令人惊叹的数字AI艺术，因为ChatsSonic已经整合了稳定扩散和DALL-E，只需点击一下就可以创建自定义AI图像。</p><p>5.Chatsonic的API集成到现有的应用程序中</p><p>通过将这个ChatGPT的替代品整合到您现有的应用程序中，释放Chatsonic的全部潜力。这样，您就可以在不切换标签的情况下获得最新信息。</p><p>Chatsonic的API可以与您的网站和移动应用程序整合，建立强大的客户服务和沟通能力。</p><p>想了解如何在自己的系统中使用ChatGPT API，请阅读30多个使用案例 - <a href="https://writesonic.com/blog/chatgpt-api-use-cases/">ChatGPT API use cases: 35 ways to implement ChatSonic API (writesonic.com)</a>。</p><p>这里的API跟ChatGPT类似,有空我也打算写一个套壳对话机器人。</p><h3 id="YouChat"><a href="#YouChat" class="headerlink" title="YouChat"></a>YouChat</h3><p><a href="https://you.com/">The AI Search Engine You Control | AI Chat &amp; Apps</a></p><p>YouChat是一个很好的ChatGPT替代品，用于研究，同时给人一种日常体验。该工具是由You[点]com，一个搜索引擎推出的。它的工作原理与其他一般的聊天工具基本相同。该工具使用自然语言处理和人工智能，像人一样自然地进行交谈。</p><p>YouChat可以写代码和电子邮件，翻译，总结文本，并回答一般的询问。YouChat在回答基本级别的查询方面非常出色，但由于它仍在学习中，可能会错过一些特定的小众内容。该工具提供的所有信息并不总是正确的。</p><p>此外也有YouWrite以及YouImage功能,也是有免费的。</p><h3 id="copy-ai"><a href="#copy-ai" class="headerlink" title="copy.ai"></a>copy.ai</h3><p><a href="https://app.copy.ai/projects">Copy.ai</a> 免费的支持中文,网站介绍说用于写博客以及写邮件.</p><p><img data-src="https://i.imgur.com/7Xufnib.png" alt="image-20230612205040139"></p><p>不得不说在网上一搜有太多相关内容了,但实际使用之后才知道哪些好用哪些真的不便于使用。</p><p>比如有浏览器扩展的肯定是非常好的优点,不像其他的还需要打开相关网站.所以我这里是强烈推荐Chatsonic的。</p><h3 id="Rytr"><a href="#Rytr" class="headerlink" title="Rytr"></a>Rytr</h3><p><a href="https://app.rytr.me/create">Rytr · Best AI Writer, Content Generator &amp; Writing Assistant</a></p><p>Rytr是一个人工智能写作助手，可以帮助你创造高质量的内容，只需几秒钟的时间，而成本却很低!</p><p>免费版本每个月只能生成5000个字符</p><p><img data-src="https://i.imgur.com/zIKQzAS.png" alt="image-20230612213317657" style="zoom: 33%;" /></p><p>下面详细介绍一下Chatsonic.</p><p>以下是浏览器插件</p><p><img data-src="https://i.imgur.com/c4C1znZ.png" alt="image-20230612210508225" style="zoom: 50%;" /></p><p>如果用相同的问题询问基于GPT3.5的ChatGPT会得到非常糟糕的回答,但这个的回答就好很多.虽然也有一些问题.</p><p><img data-src="https://i.imgur.com/XwAjLUN.png" alt="image-20230612210640326" style="zoom:50%;" /></p><p>免费额度大概25000字,有以下具体功能</p><p><img data-src="https://i.imgur.com/oob3R76.png" alt=" "></p><p>比如我使用其中的Website Copy功能写一个网站的登录页.填写以下信息,我随便填的</p><p><img data-src="https://i.imgur.com/bS6K9Ju.png" alt="image-20230612212038829" style="zoom:50%;" /></p><p>得到结果</p><p><img data-src="https://i.imgur.com/EbQmKoZ.png" alt=" " style="zoom:50%;" /></p><p>效果还是很不错的.</p><p>回到主题写作功能,你可以首先给出主题搜索相关文章或者自己给它文章链接或者文章的文件,然后生成文章并自己修改.</p><p><img data-src="https://i.imgur.com/amfyrWe.png" alt="image-20230612212217201" style="zoom:33%;" /></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.wbolt.com/best-chatgpt-alternatives.html#h-6-colossal-chat">25个最佳ChatGPT替代品 - 闪电博 (wbolt.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/625827740">Writesonic： 2023年最好用的的AI 写作工具 ｜使用 GPT 4 - 知乎 (zhihu.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用ChatGPT可以帮助写作,但其本身是个对话AI,有专门帮助写作的AI.这里做一个介绍同时尝试整合到日常工作流中.&lt;br&gt;</summary>
    
    
    
    
    <category term="AI" scheme="https://www.sekyoro.top/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>node的包管理工具介绍</title>
    <link href="https://www.sekyoro.top/2023/06/10/node%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.sekyoro.top/2023/06/10/node%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</id>
    <published>2023-06-10T07:13:46.000Z</published>
    <updated>2023-06-10T13:39:45.035Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>不同的语言都有相应的不同包或者环境管理工具,本文介绍一下node的<br><span id="more"></span></p><p>在前端开发中,使用node作为运行时环境时,常使用npm与yarn等作为包管理工具.</p><h2 id="npm与yarn存在的问题"><a href="#npm与yarn存在的问题" class="headerlink" title="npm与yarn存在的问题"></a>npm与yarn存在的问题</h2><h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><p>对于npm,其核心是有一个package.json和package-lock.json文件用于记录和追踪包版本和依赖。</p><p>之前版本的npm的node_modules目录结构是</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">node_modules </span><br><span class="line">└─ 依赖A </span><br><span class="line">   ├─ index.<span class="keyword">js </span></span><br><span class="line">   ├─ package.<span class="keyword">json </span></span><br><span class="line">   └─ node_modules </span><br><span class="line">       └─ 依赖<span class="keyword">B </span></span><br><span class="line">       ├─ index.<span class="keyword">js </span></span><br><span class="line">       └─ package.<span class="keyword">json</span></span><br><span class="line"><span class="keyword"></span> └─ 依赖C </span><br><span class="line">   ├─ index.<span class="keyword">js </span></span><br><span class="line">   ├─ package.<span class="keyword">json </span></span><br><span class="line">   └─ node_modules </span><br><span class="line">       └─ 依赖<span class="keyword">B </span></span><br><span class="line">       ├─ index.<span class="keyword">js </span></span><br><span class="line">       └─ package.<span class="keyword">json</span></span><br></pre></td></tr></table></figure><p>但很明显由于这种会重复安装依赖,还无法共享依赖,现在的版本是这样</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">node_modules </span><br><span class="line">└─ 依赖A  </span><br><span class="line">    ├─ index.<span class="keyword">js </span></span><br><span class="line">    ├─ package.<span class="keyword">json </span></span><br><span class="line">    └─ node_modules </span><br><span class="line">└─ 依赖C   </span><br><span class="line">    ├─ index.<span class="keyword">js </span></span><br><span class="line">    ├─ package.<span class="keyword">json </span></span><br><span class="line">    └─ node_modules </span><br><span class="line">└─ 依赖<span class="keyword">B </span></span><br><span class="line">    ├─ index.<span class="keyword">js </span></span><br><span class="line">    ├─ package.<span class="keyword">json </span></span><br><span class="line">    └─ node_modules </span><br></pre></td></tr></table></figure><blockquote><p><code>node_modules</code>下所有的依赖都会平铺到同一层级。由于require寻找包的机制，如果A和C都依赖了B，那么A和C在自己的node_modules中未找到依赖B的时候会向上寻找，并最终在与他们同级的node_modules中找到依赖包B。 这样<strong>就不会出现重复下载的情况。而且依赖层级嵌套也不会太深。因为没有重复的下载，所有的A和C都会寻找并依赖于同一个B包。自然也就解决了实例无法共享数据的问题</strong></p></blockquote><p>这种扁平化结构虽然是解决了之前的嵌套问题，但同时也带来了另外一些问题：</p><ul><li>依赖结构的不确定性</li><li>扁平化算法的复杂度增加</li><li>项目中仍然可以非法访问没有声明过的依赖包(幽灵依赖)</li></ul><p>yarn的输出格式提示以及下载速度比npm更快.</p><h3 id="PNPM"><a href="#PNPM" class="headerlink" title="PNPM"></a>PNPM</h3><p>  主要是采用硬链接和软链接的方式，提高了安装速度、节约了磁盘空间、避免了“依赖分身（doppelgangers）”和“幻影依赖（Phantom dependencies）”的问题。而且 yarn 支持的：安全、离线模式、更快的速度，pnpm 都支持，而且速度还要更快。</p><p>现在一般用的还是npm或者yarn.</p><p>最后再介绍一些打包工具.</p><p>常用的打包工具有Parcel,Rollup与Webpack,现在也常常使用比较火的Vite,其功能也不仅限于打包.</p><p><strong>对于应用使用 webpack或者Vite，对于类库使用 Rollup</strong></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://github.com/pnpm/pnpm">pnpm/pnpm: Fast, disk space efficient package manager (github.com)</a></li><li><a href="https://nodejs.org/en">Node.js (nodejs.org)</a></li><li><a href="https://www.ruanyifeng.com/blog/2020/08/how-nodejs-use-es6-module.html">Node.js 如何处理 ES6 模块 - 阮一峰的网络日志 (ruanyifeng.com)</a></li><li><a href="https://www.yarnpkg.cn/">Home | Yarn - JavaScript 软件包管理器 | Yarn中文文档 - Yarn中文网 (yarnpkg.cn)</a></li><li><a href="https://www.yarnpkg.cn/">Home | Yarn - JavaScript 软件包管理器 | Yarn中文文档 - Yarn中文网 (yarnpkg.cn)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;不同的语言都有相应的不同包或者环境管理工具,本文介绍一下node的&lt;br&gt;</summary>
    
    
    
    
    <category term="node" scheme="https://www.sekyoro.top/tags/node/"/>
    
    <category term="npm" scheme="https://www.sekyoro.top/tags/npm/"/>
    
    <category term="yarn" scheme="https://www.sekyoro.top/tags/yarn/"/>
    
  </entry>
  
  <entry>
    <title>深入Clash配置文件</title>
    <link href="https://www.sekyoro.top/2023/06/03/%E6%B7%B1%E5%85%A5Clash%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>https://www.sekyoro.top/2023/06/03/%E6%B7%B1%E5%85%A5Clash%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</id>
    <published>2023-06-03T13:16:28.000Z</published>
    <updated>2023-06-03T14:35:24.990Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近用代理都是用的Clash,自己也搭了一个代理服务器,顺便看看Clash的配置文件.<br><span id="more"></span></p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>有一些vmess,ssr,ss转clash配置文件的网站,比如下面的:</p><p><a href="https://sub-web.wcc.best/">Subscription Converter (wcc.best)</a>,<a href="https://a.ppconverter.eu.org/">Proxy Provider Converter (ppconverter.eu.org)</a></p><p><a href="https://acl4ssr-sub.github.io/">ACL4SSR 在线订阅转换 (acl4ssr-sub.github.io)</a></p><p><a href="https://sub.v1.mk/">在线订阅转换工具 (v1.mk)</a></p><p>不过有一些略显冗余而且有自己的网站名,所以打算看看配置文件格式自己改改</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>可以看看一般的配置文件是啥样的,如果你有自己的clash配置文件就可以看看,为了避免代理被使用,我这里就简单说说.</p><p><img data-src="https://s2.loli.net/2023/06/03/HwIUPr4Kq3kjvWx.png" alt="image-20230603214331664"></p><p>port用于配置HTTP(S)代理,此外也有socks-port用于匹配之基于socks的代理</p><p>可以使用mixed-port指定HTTP(S)和SOCKS4(A)/SOCKS5在同一端口,</p><p>allow-lan: true表示局域网内可使用,这个一般适合放在路由器上的服务器.</p><p>mode指定clash路由工作模式,有三种模式包括rule,global,direct</p><blockquote><p>rule: rule-based packet routing</p><p>global: all packets will be forwarded to a single endpoint</p><p>direct: directly forward the packets to the Internet</p></blockquote><p>external-controller指定clash的restfulapi调用监听地址,如果你想自己写请求可以设置这个参数.</p><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>剩下最重要的三个参数proxies,proxy grops以及Proxy Providers,其实还有rules.</p><p>对于proxies就是用于配置自己的代理的,包括以下几种协议</p><p><img data-src="https://s2.loli.net/2023/06/03/mHEhSLt9gqKAnRO.png" alt="image-20230603220002530"></p><p>常用v2ray的vmess以及ssr.</p><p>对于vmess,配置格式如下.至于如何获得vmess链接,可以参考我之前的文章自己搭建,当然付钱买其他人的也行.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">proxies:</span></span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">proxy_name</span>, <span class="attr">server:</span> <span class="string">proxy_ip</span>, <span class="attr">port:</span> <span class="string">proxy_port</span>, <span class="attr">type:</span> <span class="string">vmess</span>, <span class="attr">uuid:</span> <span class="string">proxy_uuid</span>, <span class="attr">alterId:</span> <span class="number">0</span>, <span class="attr">cipher:</span> <span class="string">auto</span>, <span class="attr">tls:</span> <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure><p>这里相当于定义了可用的代理,或者如下格式设置</p><p><img data-src="https://s2.loli.net/2023/06/03/lZYbvEq3WmygtIr.png" alt="image-20230603221051028"></p><p>其中,name可以用于后面proxy-group的引用,type就是协议类型,其他的与具体配置有关</p><p>proxy-group设置了clash的显示,相当于一个分组</p><p><img data-src="https://s2.loli.net/2023/06/03/9h85ulEtzCJSIjf.png" alt="image-20230603220831027" style="zoom:50%;" /></p><p>最上面的DIRECT和REJECT是默认的</p><ul><li>Direct：不走代理</li><li>Reject：禁止访问</li></ul><p>此外可以嵌套使用,也就是proxy-group中的proxies也可以是proxy-group中的项目,而type设置为select是用于选择proxy.</p><p><img data-src="https://s2.loli.net/2023/06/03/neiomlIY6NMH2CE.png" alt="image-20230603222406981" style="zoom:50%;" /></p><p>然后对于一些网站我们想直连,对于另一些使用不同的代理,这样就可以使用rules.</p><blockquote><p>一个代理规则主要由三部分组成：</p><ol><li>应用对象，包括完整域名(DOMAIN)、域名后缀(DOMAIN-SUFFIX)、域名关键字(DOMAIN-KEYWORD)、IP地址/段(IP-CIDR)以及GEOIP；</li><li>作用的IP或者域名；</li><li>采取的规则，包括直连(DIRECT)、屏蔽(REJECT)，走某个代理组(就是刚才定义的proxy-groups)</li></ol></blockquote><p><img data-src="https://s2.loli.net/2023/06/03/XMteCPELH5D3O94.png" alt="image-20230603222609199" style="zoom:50%;" /></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://fndroid.github.io/clash-win-docs/contents/ui/profiles.html">配置 Profiles · Clash for Windows (fndroid.github.io)</a></li><li><a href="https://vpsgongyi.com/p/2396/">深入理解Clash配置文件 - VPS攻略 (vpsgongyi.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近用代理都是用的Clash,自己也搭了一个代理服务器,顺便看看Clash的配置文件.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>技术教程:如何自己搭建一个VPN</title>
    <link href="https://www.sekyoro.top/2023/06/03/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B-%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAVPN/"/>
    <id>https://www.sekyoro.top/2023/06/03/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B-%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAVPN/</id>
    <published>2023-06-03T06:52:16.000Z</published>
    <updated>2023-06-03T12:35:26.942Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>仅供技术学习与交流<br><span id="more"></span></p><h2 id="VPN简单介绍"><a href="#VPN简单介绍" class="headerlink" title="VPN简单介绍"></a>VPN简单介绍</h2><p>首先需要明确的是,VPN本是一种技术,英文是Virtual Private Network,顾名思义是虚拟化的私人网络.简单来说就是基于代理IP然后自己在上面加一些功能.像是自己的手机或者PC其实都有连接VPN的功能.此外也有一些连接VPN的客户端软件.</p><p><img data-src="https://s2.loli.net/2023/06/03/W7lEcMw8eZK9IDo.png" alt="image-20230603150053505" style="zoom:50%;" /></p><h3 id="VPN好处"><a href="#VPN好处" class="headerlink" title="VPN好处"></a>VPN好处</h3><blockquote><ul><li><strong>加密 IP 地址：</strong>VPN 的主要工作就是对 ISP 和其他第三方隐藏您的 IP 地址。这样当您在线发送和接收信息时，就不用担心会有被除了您和 VPN 提供商以外的任何人看到的风险。</li><li><strong>加密协议：</strong>VPN 还应该防止您留下痕迹，例如，互联网历史记录、搜索历史记录和 cookie。加密 cookie 尤其重要，因为能阻止第三方访问保密信息，如个人数据、财务信息和网站上的其他内容。</li><li><strong>自杀开关：</strong>如果您的 VPN 连接突然中断，您的安全连接也会中断。好的 VPN 能检测到这种突然停机并终止预先选择的程序，从而降低数据被泄露的可能性。</li><li><strong>双因素身份验证：</strong>通过使用各种身份验证方法，强大的 VPN 能够检查试图登录的每个人。例如：您可能会被提醒输入密码，然后会将代码发送到您的手机。这使得未经邀请的第三方难以访问您的安全连接。</li></ul></blockquote><p>本篇文章主要目的是动手自己搭建一个访问外网的VPN,为此需要一个搭建在大陆地区以外的的服务器,因此需要一个性价比高的国外云服务器商.</p><p>这里就主要使用<a href="https://www.vultr.com/register/">Vultr</a>云服务商,事实上国内的也行,不过为了安全考虑还是算了.此外Vultr是支持支付宝支付的,不需要再去办一张VISA银行卡了,这就很满足需求了.</p><p>主要方法是使用性价比高的服务商的服务器再搭建VPN服务端软件进行配置.</p><p>一些VPS服务商推荐<a href="https://vpsxueyuan.com/2022-best-vps/">2023年最值得购买的VPS推荐</a></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="注册Vultr"><a href="#注册Vultr" class="headerlink" title="注册Vultr"></a>注册Vultr</h3><p>可以点击我的邀请进行注册<a href="https://www.vultr.com/?ref=9473485">注册地址</a>,此外也有<a href="https://www.vultr.com/?ref=9473486-8H">优惠链接</a></p><p>其他可能已经失效的活动<a href="https://www.vultrcn.com/11.html">Vultr优惠码整理</a>,包括充多少送多少(最多100美金),另外还有送美金余额的,总之还是不错的.</p><p><img data-src="https://s2.loli.net/2023/06/03/8tl2yLZskjWGTcY.png" alt="image-20230603160407745" style="zoom:50%;" /></p><h3 id="充值"><a href="#充值" class="headerlink" title="充值"></a>充值</h3><p>这里使用支付宝支付,此外可以使用一些兑换码获取一些福利,下面细说.</p><p><img data-src="https://s2.loli.net/2023/06/03/tD7BMopWwsmnvI6.png" alt="image-20230603160605588" style="zoom:50%;" /></p><h3 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h3><p><img data-src="https://s2.loli.net/2023/06/03/Uj9iGZ4Wo6emthV.png" alt="image-20230603151410859" style="zoom:50%;" /></p><p>选择Regular Performance,</p><p><img data-src="https://s2.loli.net/2023/06/03/7ckwCSKsh9PLvTo.png" alt="image-20230603155931403"></p><p>最低只要一个月2.5刀,不过貌似这个只支持IPV6,所以只能再加一刀支持IPV4</p><p><img data-src="https://s2.loli.net/2023/06/03/7jpMzXtLNAgZIhU.png" alt="image-20230603155808005"></p><p>最后加上0.7刀备份,所以一个月就是4.2刀.还是比较便宜的。目前大致情况总结如下</p><div class="table-container"><table><thead><tr><th style="text-align:center">CPU</th><th style="text-align:center">内存</th><th style="text-align:center">硬盘</th><th style="text-align:center">带宽</th><th style="text-align:center">IP</th><th style="text-align:center">价格</th></tr></thead><tbody><tr><td style="text-align:center">1 核</td><td style="text-align:center">512MB</td><td style="text-align:center">10GB</td><td style="text-align:center">0.5TB</td><td style="text-align:center">IPv6</td><td style="text-align:center"><a href="https://guowaivps.org/go/vultr">$2.5/月</a></td></tr><tr><td style="text-align:center">1 核</td><td style="text-align:center">512MB</td><td style="text-align:center">10GB</td><td style="text-align:center">0.5TB</td><td style="text-align:center">IPv4</td><td style="text-align:center"><a href="https://guowaivps.org/go/vultr">$3.5/月</a></td></tr><tr><td style="text-align:center">1 核</td><td style="text-align:center">1GB</td><td style="text-align:center">25GB</td><td style="text-align:center">1TB</td><td style="text-align:center">IPv4</td><td style="text-align:center"><a href="https://guowaivps.org/go/vultr">$5/月</a></td></tr><tr><td style="text-align:center">1 核</td><td style="text-align:center">2GB</td><td style="text-align:center">55GB</td><td style="text-align:center">2TB</td><td style="text-align:center">IPv4</td><td style="text-align:center"><a href="https://guowaivps.org/go/vultr">$10/月</a></td></tr><tr><td style="text-align:center">2 核</td><td style="text-align:center">4GB</td><td style="text-align:center">80GB</td><td style="text-align:center">3TB</td><td style="text-align:center">IPv4</td><td style="text-align:center"><a href="https://guowaivps.org/go/vultr">$20/月</a></td></tr><tr><td style="text-align:center">4 核</td><td style="text-align:center">8GB</td><td style="text-align:center">160GB</td><td style="text-align:center">4TB</td><td style="text-align:center">IPv4</td><td style="text-align:center"><a href="https://guowaivps.org/go/vultr">$40/月</a></td></tr><tr><td style="text-align:center">6 核</td><td style="text-align:center">16GB</td><td style="text-align:center">320GB</td><td style="text-align:center">5TB</td><td style="text-align:center">IPv4</td><td style="text-align:center"><a href="https://guowaivps.org/go/vultr">$80/月</a></td></tr><tr><td style="text-align:center">8 核</td><td style="text-align:center">32GB</td><td style="text-align:center">640GB</td><td style="text-align:center">6TB</td><td style="text-align:center">IPv4</td><td style="text-align:center"><a href="https://guowaivps.org/go/vultr">$160/月</a></td></tr><tr><td style="text-align:center">16 核</td><td style="text-align:center">64GB</td><td style="text-align:center">1280GB</td><td style="text-align:center">10TB</td><td style="text-align:center">IPv4</td><td style="text-align:center"><a href="https://guowaivps.org/go/vultr">$320/月</a></td></tr><tr><td style="text-align:center">24 核</td><td style="text-align:center">96GB</td><td style="text-align:center">1600GB</td><td style="text-align:center">15TB</td><td style="text-align:center">IPv4</td><td style="text-align:center"><a href="https://guowaivps.org/go/vultr">$640/月</a></td></tr></tbody></table></div><p>最后购买的服务器如下</p><p><img data-src="https://s2.loli.net/2023/06/03/xnDOYvcGfg7TRb1.png" alt="image-20230603160314905"></p><p>点击实例,进入后查看ip,用户名和密码,这样方便使用终端连接</p><p><img data-src="https://s2.loli.net/2023/06/03/T62l48bHnrwBJjM.png" alt="image-20230603161001092"></p><p>此外测试一下能不能连接,本地ping一下,ping不通可以删掉,删掉后不计费.</p><p><img data-src="https://s2.loli.net/2023/06/03/l28InbCFUPd7yrS.png" alt="image-20230603161143254" style="zoom:50%;" /></p><h3 id="安装服务端VPN"><a href="#安装服务端VPN" class="headerlink" title="安装服务端VPN"></a>安装服务端VPN</h3><p>主要有shadowsocks和V2ray,终端可以使用Xshell或者PuTTY.</p><h4 id="V2Ray"><a href="#V2Ray" class="headerlink" title="V2Ray"></a>V2Ray</h4><p>这里使用V2ray,如果你想使用其他的可以看看参考链接.利用的仓库是<a href="https://github.com/xiaoming2028/FreePAC/wiki/美国VPS-Hostwinds一键脚本搭建V2Ray最新中文教程">一键脚本搭建V2Ray最新中文教程</a></p><blockquote><h4 id="V2Ray的优势"><a href="#V2Ray的优势" class="headerlink" title="V2Ray的优势"></a><strong>V2Ray的优势</strong></h4><blockquote><ul><li><strong>更完善的协议:</strong> V2Ray 使用了新的自行研发的 VMess 协议，改正了 Shadowsocks 一些已有的缺点，更难被墙检测到（不保证可靠性）</li><li><strong>更强大的性能:</strong> 网络性能更好，具体数据可以看 V2Ray 官方博客</li><li><strong>更丰富的功能:</strong></li></ul></blockquote></blockquote><p>使用命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -s -L https://git.io/v2ray.sh)</span><br></pre></td></tr></table></figure><p>如果出现INTERNAL ERROR 500,可以再试试.如果出现其他错误,自己再改改.</p><p>安装好后出现如下图</p><p><img data-src="https://s2.loli.net/2023/06/03/AfylcpMsmGJRgV9.png" alt="image-20230603164722550" style="zoom:50%;" /></p><p>命令V2ray进行进一步配置,修改协议,端口等</p><p><img data-src="https://s2.loli.net/2023/06/03/CEuhbjH3zeXWNYd.png" alt="image-20230603164801527" style="zoom:50%;" /></p><p>使用v2ray ip查看自己的ip</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=5200/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>防火墙开启端口,这是很有必要的.</p><p>最后可以使用这个网站<a href="https://ping.sx/check-port">Check Port | Ping.Sx</a>检测一下,如果是绿色的reachable就可以了.</p><p><img data-src="https://s2.loli.net/2023/06/03/9diQ3kxVCUaZG5j.png" alt="image-20230603170821614"></p><p>其他命令添加配置：</p><ul><li><code>v2ray add</code> -&gt; 添加配置</li><li><code>v2ray add ss</code> -&gt; 添加一个 Shadowsocks 配置</li><li><code>v2ray add tcp</code> -&gt; 添加一个 VMess-TCP 配置</li><li><code>v2ray add kcpd</code> -&gt; 添加一个 VMess-mKCP-dynamic-port 动态端口配置</li></ul><p><img data-src="https://s2.loli.net/2023/06/03/r5E2pmuKCgSx7RF.png" alt="image-20230603170717004"></p><p>优化v2ray</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v2ray bbr</span><br></pre></td></tr></table></figure><h4 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h4><p>搭建Shadowsocks教程如下,基本方法差不多</p><p><a href="https://github.com/xiaoming2028/FreePAC/wiki/VPS一键脚本搭建SSR教程，Youtube看4k视频无压力">VPS一键脚本搭建SSR教程</a></p><p><a href="https://github.com/clown-coding/vpn">clown-coding/vpn: 快速搭建一个自己的VPN翻墙科学上网 (github.com)</a></p><p><a href="https://github.com/sucong426/VPN">快速搭建个人VPN</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget –no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x shadowsocks.sh</span><br><span class="line">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure><p>然后根据情况自己配置即可</p><p><img data-src="https://s2.loli.net/2023/06/03/4AVn5yZ3Q6EU8fj.png" alt="image-20230603180917790" style="zoom: 80%;" /></p><p>安装完成后就有相关信息.</p><p>还有另一个脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span><br><span class="line">chmod +x shadowsocks-all.sh</span><br><span class="line">./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure><p><del>配置更多,但我使用这个有时下载不了</del>后面发现由于我是用Centos 8.x版本的操作系统,EPEL软件包有点问题.参考这篇文章解决<a href="https://zhuanlan.zhihu.com/p/90442949">如何在 CentOS 8 和 RHEL 8 服务器上启用 EPEL 仓库 - 知乎 (zhihu.com)</a> ,最后还是不行的话建议换OS,用Debian</p><p><strong>最后记得重启一下</strong></p><p>可以使用<a href="https://bianyuan.xyz/">边缘@订阅转换API (bianyuan.xyz)</a>转换为clash订阅地址,因为我本身用clash客户端比较多</p><p><img data-src="https://s2.loli.net/2023/06/03/85rJdCYwav49Myg.png" alt="image-20230603173315958"></p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端主要有V2ray,ShadowSocks以及现在的Clash,导入服务端对应的链接即可.</p><p><a href="https://www.howru.cc/articles/414.html">Shadowsocks Windows客户端快速使用指南 - 小小的宇宙 (howru.cc)</a></p><p><img data-src="https://s2.loli.net/2023/06/03/WLHpD6Bc5SYVi4P.png" alt="image-20230603172709508" style="zoom:50%;" /></p><p>这里不做过多介绍,可以看看参考资料.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.kaspersky.com.cn/resource-center/definitions/what-is-a-vpn">什么是 VPN，它是怎样运作的？ (kaspersky.com.cn)</a></li><li><a href="https://github.com/yukaiji/buildVpn">yukaiji/buildVpn: 图文教程搭建一个vpn翻墙 (github.com)</a></li><li><a href="https://github.com/sucong426/freevpn">sucong426/freevpn: 新手搭建VPN科学上网教程/自由/v2ray/翻墙梯子/快速最新/免费机场 (github.com)</a></li><li><a href="https://github.com/sucong426/VPN">sucong426/VPN: 快速搭建个人VPN/科学上网/翻墙/教程/ssr/ss/bbr/梯子搭建/自建机场/自由上网/代理服务/VPN/2023最新教程 (github.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/607513892">2023年Vultr服务器是否还值得用 - 知乎 (zhihu.com)</a></li><li><a href="https://github.com/xiaoming2028/FreePAC/wiki">Home · xiaoming2028/FreePAC Wiki (github.com)</a></li><li><a href="https://teddysun.com/486.html">Shadowsocks 一键安装脚本（四合一） | 秋水逸冰 (teddysun.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;仅供技术学习与交流&lt;br&gt;</summary>
    
    
    
    
    <category term="VPN" scheme="https://www.sekyoro.top/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>Wox插件编写</title>
    <link href="https://www.sekyoro.top/2023/05/20/Wox%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/"/>
    <id>https://www.sekyoro.top/2023/05/20/Wox%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/</id>
    <published>2023-05-20T02:21:31.000Z</published>
    <updated>2023-06-03T06:52:19.078Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近正在使用Wox，这个软件还挺高效的，而且还能自己编写一些插件，这里打算自己写点插件用用.<br><span id="more"></span></p><p><a href="http://www.wox.one/">Wox</a>官网</p><p><a href="http://www.wox.one/plugin">Plugin (wox.one)</a>插件,此外官方也提供了编写文档，<a href="http://doc.wox.one/zh/plugin/create_plugin.html">编写插件 · GitBook (wox.one)</a>提供Python和C#两种优秀的语言编写方案。我这里就使用Python写了.</p><p>首先需要做的是创建新的虚拟环境作隔离，一般使用python自带的<code>venv</code>或者<code>virtualenv</code>,当然也有比较新的<code>pipenv</code>和被认为比较重的<code>Anaconda</code>，后两者也是包管理器，功能比较多。</p><p>以下是创建虚拟环境的代码示例：</p><p>使用 virtualenv：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 virtualenv</span></span><br><span class="line">pip install virtualenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建名为 myenv 的虚拟环境</span></span><br><span class="line">virtualenv myenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活虚拟环境（Windows 平台）</span></span><br><span class="line">myenv\Scripts\activate.bat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活虚拟环境（Linux 和 Mac 平台）</span></span><br><span class="line"><span class="built_in">source</span> myenv/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出虚拟环境</span></span><br><span class="line">deactivate</span><br></pre></td></tr></table></figure><p>使用 venv：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建名为 myenv 的虚拟环境</span></span><br><span class="line">python3 -m venv myenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活虚拟环境</span></span><br><span class="line"><span class="built_in">source</span> myenv/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出虚拟环境</span></span><br><span class="line">deactivate</span><br></pre></td></tr></table></figure><p>这一步还是很重要的，环境不能乱。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>可以看看官方案例以及其他插件的目录结构</p><p><img data-src="https://s2.loli.net/2023/05/20/79rv3TcFb4fYPqn.png" alt="image-20230520114456394"></p><p>在创建Wox的时候，用户必须在插件的根目录方式一个名为<code>plugin.json</code>的文件。该文件中包含了该插件的一些基本信息。</p><p><code>plugin.json</code>的格式如下： <strong>请在粘贴下面代码的时候移除其中的注释</strong></p><p>重点是触发词<code>ActionKeyword</code>以及<code>IcoPath</code>插件图标,<code>ID</code>需要一个32位不与其他插件重复的随机数，自己生成即可。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;ID&quot;</span>:<span class="string">&quot;D2D2C23B084D411DB66FE0C79D6C2A6H&quot;</span>,   <span class="comment">//插件ID，32位的UUID</span></span><br><span class="line">  <span class="attr">&quot;ActionKeyword&quot;</span>:<span class="string">&quot;wpm&quot;</span>,                     <span class="comment">//插件默认的触发关键字</span></span><br><span class="line">  <span class="attr">&quot;Name&quot;</span>:<span class="string">&quot;WPM&quot;</span>,                              <span class="comment">//插件名字</span></span><br><span class="line">  <span class="attr">&quot;Description&quot;</span>:<span class="string">&quot;Wox Package Management&quot;</span>,    <span class="comment">//插件介绍</span></span><br><span class="line">  <span class="attr">&quot;Author&quot;</span>:<span class="string">&quot;qianlifeng&quot;</span>,                     <span class="comment">//作者</span></span><br><span class="line">  <span class="attr">&quot;Version&quot;</span>:<span class="string">&quot;1.0.0&quot;</span>,                         <span class="comment">//插件版本，必须是x.x.x的格式</span></span><br><span class="line">  <span class="attr">&quot;Language&quot;</span>:<span class="string">&quot;csharp&quot;</span>,                       <span class="comment">//插件语言，目前支持csharp,python</span></span><br><span class="line">  <span class="attr">&quot;Website&quot;</span>:<span class="string">&quot;http://www.getwox.com&quot;</span>,         <span class="comment">//插件网站或者个人网站</span></span><br><span class="line">  <span class="attr">&quot;IcoPath&quot;</span>: <span class="string">&quot;Images\\pic.png&quot;</span>,              <span class="comment">//插件图标，路径是相对插件根目录的路径</span></span><br><span class="line">  <span class="attr">&quot;ExecuteFileName&quot;</span>:<span class="string">&quot;PluginManagement.dll&quot;</span>   <span class="comment">//执行文件入口，如果是C#插件则填写DLL路径，如果是pyhton则填写python文件路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是主文件以及插件图标文件</p><h2 id="Python开发"><a href="#Python开发" class="headerlink" title="Python开发"></a>Python开发</h2><blockquote><p>Wox自带了一个打包的Python及其标准库，所以使用Python插件的用户不必自己再安装Python环境。同时，Wox还打包了requests和beautifulsoup4两个库， 方便用户进行网络访问与解析。</p></blockquote><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>使用Python开发需要有一个类继承Wox,注意这个东西并不需要pip下载，是Wox自带的运行时，包括requests和BeautifulSoup4，而其他的第三方包需要自己下载.下载Wox时有一个full-installer包含python解释器，自己可以设置Python解释器文件夹路径为环境变量，一般下载Python时选择加入环境变量即可。</p><p>继承Wox类后关键要继承的方法是<code>query</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> webbrowser</span><br><span class="line"><span class="keyword">from</span> wox <span class="keyword">import</span> Wox,WoxAPI</span><br><span class="line"></span><br><span class="line"><span class="comment">#用户写的Python类必须继承Wox类 https://github.com/qianlifeng/Wox/blob/master/PythonHome/wox.py</span></span><br><span class="line"><span class="comment">#这里的Wox基类做了一些工作，简化了与Wox通信的步骤。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span>(<span class="params">Wox</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request</span>(<span class="params">self,url</span>):</span></span><br><span class="line">    <span class="comment">#如果用户配置了代理，那么可以在这里设置。这里的self.proxy来自Wox封装好的对象</span></span><br><span class="line">    <span class="keyword">if</span> self.proxy <span class="keyword">and</span> self.proxy.get(<span class="string">&quot;enabled&quot;</span>) <span class="keyword">and</span> self.proxy.get(<span class="string">&quot;server&quot;</span>):</span><br><span class="line">      proxies = &#123;</span><br><span class="line">        <span class="string">&quot;http&quot;</span>:<span class="string">&quot;http://&#123;&#125;:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(self.proxy.get(<span class="string">&quot;server&quot;</span>),self.proxy.get(<span class="string">&quot;port&quot;</span>)),</span><br><span class="line">        <span class="string">&quot;https&quot;</span>:<span class="string">&quot;http://&#123;&#125;:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(self.proxy.get(<span class="string">&quot;server&quot;</span>),self.proxy.get(<span class="string">&quot;port&quot;</span>))&#125;</span><br><span class="line">      <span class="keyword">return</span> requests.get(url,proxies = proxies)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> requests.get(url)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#必须有一个query方法，用户执行查询的时候会自动调用query方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span>(<span class="params">self,key</span>):</span></span><br><span class="line">    r = self.request(<span class="string">&#x27;https://news.ycombinator.com/&#x27;</span>)</span><br><span class="line">    bs = BeautifulSoup(r.text)</span><br><span class="line">    results = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> bs.select(<span class="string">&quot;.comhead&quot;</span>):</span><br><span class="line">      title = i.previous_sibling.text</span><br><span class="line">      url = i.previous_sibling[<span class="string">&quot;href&quot;</span>]</span><br><span class="line">      results.append(&#123;</span><br><span class="line">        <span class="string">&quot;Title&quot;</span>: title ,</span><br><span class="line">        <span class="string">&quot;SubTitle&quot;</span>:title,</span><br><span class="line">        <span class="string">&quot;IcoPath&quot;</span>:<span class="string">&quot;Images/app.ico&quot;</span>,</span><br><span class="line">        <span class="string">&quot;JsonRPCAction&quot;</span>:&#123;</span><br><span class="line">          <span class="comment">#这里除了自已定义的方法，还可以调用Wox的API。调用格式如下：Wox.xxxx方法名</span></span><br><span class="line">          <span class="comment">#方法名字可以从这里查阅https://github.com/qianlifeng/Wox/blob/master/Wox.Plugin/IPublicAPI.cs 直接同名方法即可</span></span><br><span class="line">          <span class="string">&quot;method&quot;</span>: <span class="string">&quot;openUrl&quot;</span>,</span><br><span class="line">          <span class="comment">#参数必须以数组的形式传过去</span></span><br><span class="line">          <span class="string">&quot;parameters&quot;</span>:[url],</span><br><span class="line">          <span class="comment">#是否隐藏窗口</span></span><br><span class="line">          <span class="string">&quot;dontHideAfterAction&quot;</span>:<span class="literal">True</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">openUrl</span>(<span class="params">self,url</span>):</span></span><br><span class="line">    webbrowser.<span class="built_in">open</span>(url)</span><br><span class="line">    WoxAPI.change_query(url)</span><br><span class="line"></span><br><span class="line"><span class="comment">#以下代码是必须的</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">Main()</span><br></pre></td></tr></table></figure><p>上面这个例子就很典型，每次在Wox中输入就会调用query方法,其需要返回一个列表，列表中每一项内容如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">&quot;Title&quot;</span>: title ,</span><br><span class="line">        <span class="attr">&quot;SubTitle&quot;</span>:title,</span><br><span class="line">        <span class="attr">&quot;IcoPath&quot;</span>:<span class="string">&quot;Images/app.ico&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;JsonRPCAction&quot;</span>:&#123;</span><br><span class="line">          <span class="attr">&quot;method&quot;</span>: <span class="string">&quot;openUrl&quot;</span>,  </span><br><span class="line">          <span class="attr">&quot;parameters&quot;</span>:[url],</span><br><span class="line">          <span class="attr">&quot;dontHideAfterAction&quot;</span>:True</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2023/05/21/rqlJXwZEeTzhdIK.png" alt="image-20230521171823745"></p><p>其中,拿一个翻译插件来说，Title就是要点,SubTitle就是翻译结果,icoPath是左边图标的路径，我测试了必须使用本地文件，而JsonRPCAction就是按Enter键或鼠标左击后的响应，method就是触发的方法，可以自己写，也可以用wox.py<a href="https://github.com/Wox-launcher/Wox/blob/master/JsonRPC/wox.py">Wox/wox.py at master · Wox-launcher/Wox · GitHub</a>中的WoxAPI方法,parameters就是参数，要求传入一个列表.<code>dontHideAfterAction</code>表示点击之后Wox会不会隐藏.</p><p>此外还有个有意思的方法就是<code>context_menu</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">context_menu</span>(<span class="params">self, data</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    optional context menu entries for a result</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><p>就是鼠标右击或者Shift+Enter后的响应，<strong>需要注意的是</strong>,重载的必须是<code>context_menu(self, data)</code>,不能确少data参数，这个data可以在query方法中返回的结果里设置<code>ContextData</code>如下</p><p><img data-src="https://s2.loli.net/2023/05/22/Tu4YXj6OHxD9ngG.png" alt="image-20230522112012105" style="zoom:67%;" /></p><p>比如我在Context menu里添加一项<code>去我的博客看看</code>,下面两项是默认的.</p><p><img data-src="https://s2.loli.net/2023/05/22/vLZGqJ58NnWkBoi.png" alt="image-20230522113028138" style="zoom: 67%;" /></p><p>所以<code>query</code>和<code>context_menu</code>返回的结果就是展示的结果项目。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>像对于这种插件的开发个人认为是比较累的，debug比较麻烦,不能在终端直接显示，不像一般的客户端或者Web开发，所以日志还是很重要的，主要使用Python自带的logging模块.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 日志记录</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        filename = os.path.join(os.path.dirname(__file__), <span class="string">&#x27;log.txt&#x27;</span>)</span><br><span class="line">        logging.basicConfig(level=logging.DEBUG, filename=filename, filemode=<span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">                            <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#x27;</span>)</span><br><span class="line">        self.logger = logging.getLogger()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">self, msg</span>):</span></span><br><span class="line">        self.logger.debug(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self, msg</span>):</span></span><br><span class="line">        self.logger.info(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span>(<span class="params">self, msg</span>):</span></span><br><span class="line">        self.logger.error(msg)</span><br></pre></td></tr></table></figure><p>使用时初始化Logger,再掉用实例方法输出信息到文件.</p><h4 id="显示项目"><a href="#显示项目" class="headerlink" title="显示项目"></a>显示项目</h4><p>Wox插件机制叫做<a href="https://www.jsonrpc.org/specification">JSON-RPC 2.0 Specification (jsonrpc.org)</a>,利用这种方法将要展示的信息发给Wox并显示出来.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query</span>(<span class="params">self, key</span>):</span></span><br><span class="line">    self.results = []</span><br><span class="line">    logger = Logger()</span><br><span class="line">    logger.info(<span class="string">&quot;-------------info--------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">    args = key.split()</span><br><span class="line">    length = <span class="built_in">len</span>(args)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">        self.results.append(</span><br><span class="line">            self.add_item(<span class="string">&quot;有道智云翻译(正在开发中)&quot;</span>, <span class="string">&quot;需要配置key&quot;</span>, <span class="string">&#x27;Images/zhiyun.png&#x27;</span>, <span class="string">&quot;configyoudao&quot;</span>, <span class="string">&quot;zy&quot;</span>))</span><br><span class="line">        self.results.append(</span><br><span class="line">            self.add_item(<span class="string">&quot;使用有道翻译免费版本&quot;</span>, <span class="string">&quot;暂只支持中英互译&quot;</span>, <span class="string">&#x27;Images/youdao.png&#x27;</span>, <span class="string">&quot;freetrans&quot;</span>, <span class="string">&quot;yd&quot;</span>))</span><br><span class="line">        self.results.append(self.add_item(<span class="string">&quot;使用百度翻译&quot;</span>, <span class="string">&quot;需要配置key&quot;</span>, <span class="string">&#x27;Images/bd.png&#x27;</span>, <span class="string">&quot;configbaidu&quot;</span>, <span class="string">&quot;bd&quot;</span>))</span><br><span class="line">        self.results.append(self.add_item(<span class="string">&quot;重载插件&quot;</span>, <span class="string">&quot;重新加载插件&quot;</span>, <span class="string">&#x27;Images/pic.jpg&#x27;</span>, <span class="string">&quot;reload&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> self.results</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> self.results</span><br></pre></td></tr></table></figure><p>这是我写的部分代码，可以看到返回了一个列表，展示出来就是下面样子的</p><p><img data-src="https://s2.loli.net/2023/05/21/K5TBRAWYpmGbeaf.png" alt="image-20230521172551777"></p><p>可以通过显示项目的方法debug.</p><h3 id="响应方法"><a href="#响应方法" class="headerlink" title="响应方法"></a>响应方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">openUrl</span>(<span class="params">self, url</span>):</span></span><br><span class="line">    webbrowser.<span class="built_in">open</span>(url)</span><br><span class="line">    WoxAPI.change_query(url, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>在返回的项目中，<code>JsonRPCAction</code>的method就填方法名,可以写在一个类中，可以使用WoxAPI改变query也就是搜索的字符串，此外还有其他方法，<strong>注意</strong>，我测试的发现show_msg已经无法正常使用了</p><p><img data-src="https://s2.loli.net/2023/05/21/kwTv5QKbJtL716S.png" alt="image-20230521173212739" style="zoom:50%;" /></p><p><code>JsonRPCAction</code>的parameters传入的列表就对应method中的参数，比如传[1,2],而method中就可以使用method(a,b)来接收,当然也可以使用method(*para)用一个元组接收.</p><p><img data-src="https://s2.loli.net/2023/05/21/7FJRkB6H21wNcsL.png" alt="image-20230521174809680"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Python编写插件相关资料比较少,C#要多一点</li><li>可以参考这个文件的代码,还是不错的<a href="https://github.com/Wox-launcher/Wox/tree/master/Plugins/HelloWorldPython">Wox/Plugins/HelloWorldPython at master · Wox-launcher/Wox · GitHub</a></li><li>可以看看我的翻译插件,支持免费中英互译,也支持百度的有一定免费额度的API翻译，支持多种语言<br><img data-src="https://s2.loli.net/2023/05/21/zH9peMTlJg13GYU.png" alt="image-20230521173938835"><br><img data-src="https://s2.loli.net/2023/05/21/7CioWXbFr4nSx3d.png" alt="image-20230521174103179"></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/81568689#:~:text=virtualenv ：Python 虚拟环境管理工具。 venv ：Python 标准库内置的虚拟环境管理工具，Python 3.3 加入，Python,开始作为管理虚拟环境的推荐工具，用法类似 virtualenv。 如果你使用 Python 3，推荐使用 venv 来替代 virtualenv。">要不我们还是用回 virtualenv/venv 和 pip 吧 </a></li><li><a href="https://github.com/Wox-launcher/Wox/blob/master/JsonRPC/wox.py">Wox/wox.py at master · Wox-launcher/Wox · GitHub</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近正在使用Wox，这个软件还挺高效的，而且还能自己编写一些插件，这里打算自己写点插件用用.&lt;br&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://www.sekyoro.top/tags/python/"/>
    
    <category term="插件" scheme="https://www.sekyoro.top/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>python的特别方法与装饰器</title>
    <link href="https://www.sekyoro.top/2023/05/07/python%E7%9A%84%E7%89%B9%E5%88%AB%E6%96%B9%E6%B3%95%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>https://www.sekyoro.top/2023/05/07/python%E7%9A%84%E7%89%B9%E5%88%AB%E6%96%B9%E6%B3%95%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/</id>
    <published>2023-05-07T03:31:24.000Z</published>
    <updated>2023-05-07T07:15:13.795Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这里将介绍python的所谓魔法方法以及装饰器<br><span id="more"></span></p><h3 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h3><p>一般在类中以双下划线包围的方法就是魔术方法，或者叫特殊方法。</p><p>简单来说，Python的魔术方法是为了利用Python的标准方法以及不用去记住标准操作的名称，实现更统一的接口。</p><p><img data-src="https://s2.loli.net/2023/05/07/2QCAj8iUIsNtrzO.png" alt="image-20230507133421451"></p><p>例如下面的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Card = collections.namedtuple(<span class="string">&#x27;Card&#x27;</span>, [<span class="string">&#x27;rank&#x27;</span>, <span class="string">&#x27;suit&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span>:</span></span><br><span class="line">    ranks = [<span class="built_in">str</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>)] + <span class="built_in">list</span>(<span class="string">&#x27;JQKA&#x27;</span>)</span><br><span class="line">    suits = <span class="string">&#x27;spades diamonds clubs hearts&#x27;</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                                        <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._cards[item]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(deck))</span><br><span class="line">    <span class="built_in">print</span>(deck[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><code>__len__</code>这个特别方法使得调用len(beer<em>card)实际调用`<em>_len</em></em>`</p><p> <strong>getitem</strong> 方法把 [] 操作交给了 self._cards 列表，所以我们的 deck 类自动支持切 片（slicing）操作。</p><p>输出如下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">52</span><br><span class="line">Card(<span class="attribute">rank</span>=<span class="string">&#x27;2&#x27;</span>, <span class="attribute">suit</span>=<span class="string">&#x27;spades&#x27;</span>)</span><br></pre></td></tr></table></figure><p>另外，仅仅实现了 <strong>getitem</strong> 方法，对象就变成可迭代的了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> deck:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2023/05/07/nBPSwYrg68y47Ff.png" alt="image-20230507134341143"></p><p>同时<code>__contains__</code>可以实现<code>in</code>方法</p><p>除了上面通过特殊方法实现迭代，len(),切片等方法外，还可以实现类似重载运算符的效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x=<span class="number">0</span>, y=<span class="number">0</span></span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Vector(%r, %r)&#x27;</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(<span class="built_in">abs</span>(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        x = self.x + other.x</span><br><span class="line">        y = self.y + other.y</span><br><span class="line">        <span class="keyword">return</span> Vector(x, y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span>(<span class="params">self, scalar</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.x * scalar, self.y * scalar)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v1 = Vector(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">v2 = Vector(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">v3 = v1+v2</span><br><span class="line"><span class="built_in">print</span>(v3)</span><br></pre></td></tr></table></figure><p>输出Vector(7, 9)</p><p>还有<code>__repr__</code>和<code>__str__</code></p><p><strong>repr</strong> 和 <strong>str</strong> 的区别在于，后者是在 str() 函数被使用，或是在用 print 函数打印一个对象的时候才被调用的，并且它返回的字符串对终端用户更友好。</p><p> 如果你只想实现这两个特殊方法中的一个，<strong>repr</strong> 是更好的选择，因为如果一个对象没有 <strong>str</strong> 函数，而 Python 又需要调用它的时候，解释器会用 <strong>repr</strong> 作为替代。</p><blockquote><ul><li><code>&#123;!r&#125;</code>就是使用format语法时候的<code>%r</code>。因此，我们只需要关注<code>%r</code>就好。</li><li><code>%r</code>表示的用<code>repr()</code>处理；类似于的<code>%s</code>表示用<code>str()</code>处理一样</li></ul></blockquote><p>其他特别方法</p><p><img data-src="https://s2.loli.net/2023/05/07/GpmoahVdxD1TNwL.png" alt="image-20230507134927018"></p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><blockquote><p>装饰器的作用就是为已经存在的函数或对象添加额外的功能。<br>装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure><p>装饰器涉及到闭包的概念,什么是闭包，一句话说就是，在函数中再嵌套一个函数，并且引用外部函数的变量，这就是一个闭包了</p><p>上述无参装饰器可以用于输出日志。</p><p>如果要在wrapper中访问参数,如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;params&quot;</span>, args, kwargs)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;this is a test function&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果要在装饰器中使用参数,还要在外面包围一层。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span>(<span class="params">level</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">outwrapper</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[&#123;0&#125;]: enter &#123;1&#125;()&quot;</span>.<span class="built_in">format</span>(level, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> outwrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(<span class="params">level=<span class="string">&quot;INFO&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br></pre></td></tr></table></figure><p>除了使用函数装饰器也可以是使用类装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logging</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func</span>):</span></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(self.func.__name__))</span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br></pre></td></tr></table></figure><p>装饰器中使用参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logging</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, level</span>):</span></span><br><span class="line">        self.level = level</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[&#123;0&#125;]: enter &#123;1&#125;()&quot;</span>.<span class="built_in">format</span>(self.level, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(<span class="params">level=<span class="string">&quot;TEST&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><blockquote><p>当我们创建一个类，以定义对象时，我们可能会希望一些属性对于外界是只读的，或者希望创建属性只能按特定的方式访问或修改。这时就可以使用 Python 中的属性（Property）。</p><p>在 Python 中，属性是包装在函数中的代码段，它们能够拦截对对象属性的访问和修改。Python 内置了@property 装饰器，可以用来修饰一个方法，使之成为属性调用。同时，Python 还提供了 @property 修饰器的对应方法的 setter 方法，用于设置属性。</p></blockquote><p>简单来说，属性优化了之前使用公共方法来访问私有属性得方法同时有更精细的粒度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myObj</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.__name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;init&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    obj = myObj(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(obj.name)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>如果使用<code>obj.name = &quot;world&quot;</code>更改属性则会报错.</p><p>添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@name.setter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self, newname</span>):</span></span><br><span class="line">     self.__name = newname</span><br></pre></td></tr></table></figure><p>可以通过name属性更改<code>self.__name</code></p><p>此外还有deleter</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@name.deleter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">     self.__name = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>使用del删除属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> obj.name</span><br><span class="line"><span class="built_in">print</span>(obj.name)</span><br></pre></td></tr></table></figure><p>输出就是<code>None</code></p><p>属性也可以通过property() 函数创建.</p><p>基本使用格式如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">属性名=property(<span class="attribute">fget</span>=None, <span class="attribute">fset</span>=None, <span class="attribute">fdel</span>=None, <span class="attribute">doc</span>=None)</span><br></pre></td></tr></table></figure><p>其中，fget 参数用于指定获取该属性值的类方法，fset 参数用于指定设置该属性值的方法，fdel 参数用于指定删除该属性值的方法，最后的 doc 是一个文档字符串，用于说明此函数的作用。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/329962624">Python常用魔术方法 - 知乎 (zhihu.com)</a></li><li>《流畅的Python》</li><li><a href="https://blog.csdn.net/luoz_java/article/details/90339876">Python基础（十四）—装饰器 wrapper_luoz_python的博客-CSDN博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/87353829">python 装饰器详解 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/366156798">Python @property属性详解 - 知乎 (zhihu.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;这里将介绍python的所谓魔法方法以及装饰器&lt;br&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://www.sekyoro.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python中的logging模块</title>
    <link href="https://www.sekyoro.top/2023/05/02/python%E4%B8%AD%E7%9A%84logging%E6%A8%A1%E5%9D%97/"/>
    <id>https://www.sekyoro.top/2023/05/02/python%E4%B8%AD%E7%9A%84logging%E6%A8%A1%E5%9D%97/</id>
    <published>2023-05-02T13:55:55.000Z</published>
    <updated>2023-05-03T15:09:24.034Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>开发一个程序或者软件使用日志记录是非常有用的,对于开发者DEBUG,维护以及有经验的程序使用者都可以根据日志判断软件出了什么问题以及能做什么.这里主要介绍使用Python的原生模块logging写日志.<br><span id="more"></span></p><h2 id="日志概念"><a href="#日志概念" class="headerlink" title="日志概念"></a>日志概念</h2><blockquote><p>日志是一种可以追踪某些软件运行时所发生事件的方法。软件开发人员可以向他们的代码中调用日志记录相关的方法来表明发生了某些事情。一个事件可以用一个可包含可选变量数据的消息来描述。</p><p>此外，事件也有重要性的概念，这个重要性也可以被称为严重性级别（level）。</p></blockquote><p>在部署项目时，不可能直接将所有的信息都输出到控制台中，我们可以将这些信息记录到日志文件中，这样不仅方便我们查看程序运行时的情况，也可以在项目出现故障时根据程序运行时产生的日志快速定位问题出现的位置。</p><p>日志等级,在python的logging模块中有以下几个等级以及等级的值</p><blockquote><p>CRITICAL = 50<br>FATAL = CRITICAL<br>ERROR = 40<br>WARNING = 30<br>WARN = WARNING<br>INFO = 20<br>DEBUG = 10<br>NOTSET = 0</p></blockquote><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line">logger = logging.getLogger(__name__)</span><br></pre></td></tr></table></figure><p>使用<code>basicConfig</code>进行基本配置,</p><p><img data-src="https://img.proanimer.com/imgs/02/05image-20230502221157465.png" alt="image-20230502221157465"></p><p>可以设置<code>filename</code>作为日志信息的输入文件.</p><p>可以创造多个 Logger 对象，但是真正输出日志的是root Logger 对象。每个 Logger 对象都可以设置一个名字，如果设置<code>logger = logging.getLogger(__name__)</code>，<strong>name</strong> 是 Python 中的一个特殊内置变量，他代表当前模块的名称（默认为 <strong>main</strong>）。则 Logger 对象的 name 为建议使用使用以点号作为分隔符的命名空间等级制度。</p><h3 id="Logging组件"><a href="#Logging组件" class="headerlink" title="Logging组件"></a>Logging组件</h3><div class="table-container"><table><thead><tr><th>组件名称</th><th>类名</th><th>描述</th></tr></thead><tbody><tr><td>日志器</td><td>Logger</td><td>提供程序一直使用的接口</td></tr><tr><td>处理器</td><td>Handler</td><td>将日志记录发送到合适的目的输出</td></tr><tr><td>过滤器</td><td>Filer</td><td>决定输出哪条日志记录</td></tr><tr><td>格式器</td><td>Formatter</td><td>决定日志记录的最终输出格式</td></tr></tbody></table></div><p>如果直接想要简单使用,可以直接使用<code>logging</code>对象,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.DEBUG,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&quot;%(asctime)s %(name)s %(levelname)s %(message)s&quot;</span>,</span><br><span class="line">                    datefmt = <span class="string">&#x27;%Y-%m-%d  %H:%M:%S %a&#x27;</span>   </span><br><span class="line">                    )</span><br><span class="line">logging.debug(<span class="string">&quot;msg1&quot;</span>)</span><br><span class="line">logging.info(<span class="string">&quot;msg2&quot;</span>)</span><br><span class="line">logging.warning(<span class="string">&quot;msg3&quot;</span>)</span><br><span class="line">logging.error(<span class="string">&quot;msg4&quot;</span>)</span><br><span class="line">logging.critical(<span class="string">&quot;msg5&quot;</span>)</span><br></pre></td></tr></table></figure><p>对于<code>format</code>的值</p><div class="table-container"><table><thead><tr><th>字段/属性名称</th><th>使用格式</th><th>描述</th></tr></thead><tbody><tr><td>asctime</td><td>%(asctime)s</td><td>将日志的时间构造成可读的形式，默认情况下是‘2016-02-08 12:00:00,123’精确到毫秒</td></tr><tr><td>name</td><td>%(name)s</td><td>所使用的日志器名称，默认是’root’，因为默认使用的是 rootLogger</td></tr><tr><td>filename</td><td>%(filename)s</td><td>调用日志输出函数的模块的文件名； pathname的文件名部分，包含文件后缀</td></tr><tr><td>funcName</td><td>%(funcName)s</td><td>由哪个function发出的log， 调用日志输出函数的函数名</td></tr><tr><td>levelname</td><td>%(levelname)s</td><td>日志的最终等级（被filter修改后的）</td></tr><tr><td>message</td><td>%(message)s</td><td>日志信息， 日志记录的文本内容</td></tr><tr><td>lineno</td><td>%(lineno)d</td><td>当前日志的行号， 调用日志输出函数的语句所在的代码行</td></tr><tr><td>levelno</td><td>%(levelno)s</td><td>该日志记录的数字形式的日志级别（10, 20, 30, 40, 50）</td></tr><tr><td>pathname</td><td>%(pathname)s</td><td>完整路径 ，调用日志输出函数的模块的完整路径名，可能没有</td></tr><tr><td>process</td><td>%(process)s</td><td>当前进程， 进程ID。可能没有</td></tr><tr><td>processName</td><td>%(processName)s</td><td>进程名称，Python 3.1新增</td></tr><tr><td>thread</td><td>%(thread)s</td><td>当前线程， 线程ID。可能没有</td></tr><tr><td>threadName</td><td>%(thread)s</td><td>线程名称</td></tr><tr><td>module</td><td>%(module)s</td><td>调用日志输出函数的模块名， filename的名称部分，不包含后缀即不包含文件后缀的文件名</td></tr><tr><td>created</td><td>%(created)f</td><td>当前时间，用UNIX标准的表示时间的浮点数表示； 日志事件发生的时间—时间戳，就是当时调用time.time()函数返回的值</td></tr><tr><td>relativeCreated</td><td>%(relativeCreated)d</td><td>输出日志信息时的，自Logger创建以 来的毫秒数； 日志事件发生的时间相对于logging模块加载时间的相对毫秒数</td></tr><tr><td>msecs</td><td>%(msecs)d</td><td>日志事件发生事件的毫秒部分。logging.basicConfig()中用了参数datefmt，将会去掉asctime中产生的毫秒部分，可以用这个加上</td></tr></tbody></table></div><p>对于<code>datefmt</code>字段,对应的是<code>format</code>字段的<code>%(asctime)s</code>,用于修改时间显示格式.</p><p><code>level</code>字段用于显示的<strong>最低等级</strong></p><p>总结来说,简单实用就是配置logging.basicConfig()（用默认日志格式（Formatter）为日志系统建立一个默认的流处理器（StreamHandler），设置基础配置（如日志级别等）并加到root logger（根Logger）中）这几个logging模块级别的函数。</p><h3 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h3><p>进阶使用跟上述的模块四大组件有关,</p><ul><li>日志器（logger）需要通过处理器（handler）将日志信息输出到目标位置，如：文件、sys.stdout、网络等；</li><li>不同的处理器（handler）可以将日志输出到不同的位置；</li><li>日志器（logger）可以设置多个处理器（handler）将同一条日志记录输出到不同的位置；</li><li>每个处理器（handler）都可以设置自己的过滤器（filter）实现日志过滤，从而只保留感兴趣的日志；</li><li>每个处理器（handler）都可以设置自己的格式器（formatter）实现同一条日志以不同的格式输出到不同的地方。</li></ul><h4 id="Logger类"><a href="#Logger类" class="headerlink" title="Logger类"></a>Logger类</h4><blockquote><p>Logger对象有3个任务要做：</p><ul><li>1）向应用程序代码暴露几个方法，使应用程序可以在运行时记录日志消息；</li><li>2）基于日志严重等级（默认的过滤设施）或filter对象来决定要对哪些日志进行后续处理；</li><li>3）将日志消息传送给所有感兴趣的日志handlers。</li></ul><p>Logger对象最常用的方法分为两类：配置方法 和 消息发送方法</p></blockquote><p>一般通过<code>logging.getLogger(__name__)</code>得到logger对象,然后通过<code>logger.setLevel</code>设置logger过滤的等级.</p><p>通过addHandler和addFilter添加处理器和过滤器.</p><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Logger.setLevel()</td><td>设置日志器将会处理的日志消息的最低严重级别</td></tr><tr><td>Logger.addHandler() 和 Logger.removeHandler()</td><td>为该logger对象添加 和 移除一个handler对象</td></tr><tr><td>Logger.addFilter() 和 Logger.removeFilter()</td><td>为该logger对象添加 和 移除一个filter对象</td></tr></tbody></table></div><p>使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;DEBUG&quot;</span>)</span><br><span class="line">logger.info(<span class="string">&quot;INFO&quot;</span>)</span><br><span class="line">logger.warning(<span class="string">&quot;WARNING&quot;</span>)</span><br><span class="line">logger.error(<span class="string">&quot;ERROR&quot;</span>)</span><br><span class="line">logger.critical(<span class="string">&quot;CRITICAL&quot;</span>)</span><br><span class="line">logger.log(<span class="number">15</span>,<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>常用的就是info,debug,warning,error几种日志等级,也可以通过logger.log设置自己的日志等级和消息.</p><h4 id="Handler类"><a href="#Handler类" class="headerlink" title="Handler类"></a>Handler类</h4><p>Handler对象的作用是（基于日志消息的level）将消息分发到handler指定的位置（文件、网络、邮件等）。Logger对象可以通过addHandler()方法为自己添加0个或者更多个handler对象。比如，一个应用程序可能想要实现以下几个日志需求：</p><ul><li>1）把所有日志都发送到一个日志文件中；</li><li>2）把所有严重级别大于等于error的日志发送到stdout（标准输出）；</li><li>3）把所有严重级别为critical的日志发送到一个email邮件地址。这种场景就需要3个不同的handlers，每个handler复杂发送一个特定严重级别的日志到一个特定的位置。</li></ul><p>Handler一般使用StreamHandler和FileHandler用于输入到Stream和磁盘文件.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">handler = logging.StreamHandler()</span><br><span class="line">logger.addHandler(handler)</span><br></pre></td></tr></table></figure><p>handler也可以设置level,过滤通过了logger的日志,此外handler也可以设置Filter用于更细致的过滤以及设置Formatter用于输出格式.</p><div class="table-container"><table><thead><tr><th>Handler</th><th>描述</th></tr></thead><tbody><tr><td>logging.StreamHandler</td><td>将日志消息发送到输出到Stream，如std.out, std.err或任何file-like对象。</td></tr><tr><td>logging.FileHandler</td><td>将日志消息发送到磁盘文件，默认情况下文件大小会无限增长</td></tr><tr><td>logging.handlers.RotatingFileHandler</td><td>将日志消息发送到磁盘文件，并支持日志文件按大小切割</td></tr><tr><td>logging.hanlders.TimedRotatingFileHandler</td><td>将日志消息发送到磁盘文件，并支持日志文件按时间切割</td></tr><tr><td>logging.handlers.HTTPHandler</td><td>将日志消息以GET或POST的方式发送给一个HTTP服务器</td></tr><tr><td>logging.handlers.SMTPHandler</td><td>将日志消息发送给一个指定的email地址</td></tr><tr><td>logging.NullHandler</td><td>该Handler实例会忽略error messages，通常被想使用logging的library开发者使用来避免’No handlers could be found for logger XXX’信息的出现。</td></tr></tbody></table></div><h4 id="Formatter类"><a href="#Formatter类" class="headerlink" title="Formatter类"></a>Formatter类</h4><p>常用的两个参数是</p><ul><li>fmt：指定消息格式化字符串，如果不指定该参数则默认使用message的原始值</li><li>datefmt：指定日期格式字符串，如果不指定该参数则默认使用”%Y-%m-%d %H:%M:%S”</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">formatter = logging.Formatter(<span class="string">&#x27;Hello %(message)s&#x27;</span>)</span><br><span class="line">handler.setFormatter(formatter)</span><br></pre></td></tr></table></figure><p><img data-src="https://img.proanimer.com/imgs/03/05image-20230503222936462.png" alt="image-20230503222936462"></p><h4 id="Filter类"><a href="#Filter类" class="headerlink" title="Filter类"></a>Filter类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoParsingFilter</span>(<span class="params">logging.Filter</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">filter</span>(<span class="params">self, record</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(record.getMessage())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> record.getMessage().startswith(<span class="string">&#x27;parsing&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter_grammar_messages</span>(<span class="params">record</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(record.funcName,<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> record.funcName == <span class="string">&#x27;load_grammar&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>可以使用类或者函数作为Filter</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logger.addFilter(NoParsingFilter())</span><br><span class="line">logger.addFilter(filter_grammar_messages)</span><br></pre></td></tr></table></figure><p>同时也可以在类中的初始化函数设置类的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filter</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Filter instances are used to perform arbitrary filtering of LogRecords.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Loggers and Handlers can optionally use Filter instances to filter</span></span><br><span class="line"><span class="string">    records as desired. The base filter class only allows events which are</span></span><br><span class="line"><span class="string">    below a certain point in the logger hierarchy. For example, a filter</span></span><br><span class="line"><span class="string">    initialized with &quot;A.B&quot; will allow events logged by loggers &quot;A.B&quot;,</span></span><br><span class="line"><span class="string">    &quot;A.B.C&quot;, &quot;A.B.C.D&quot;, &quot;A.B.D&quot; etc. but not &quot;A.BB&quot;, &quot;B.A.B&quot; etc. If</span></span><br><span class="line"><span class="string">    initialized with the empty string, all events are passed.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize a filter.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Initialize with the name of the logger which, together with its</span></span><br><span class="line"><span class="string">        children, will have its events allowed through the filter. If no</span></span><br><span class="line"><span class="string">        name is specified, allow every event.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.nlen = <span class="built_in">len</span>(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">filter</span>(<span class="params">self, record</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Determine if the specified record is to be logged.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Is the specified record to be logged? Returns 0 for no, nonzero for</span></span><br><span class="line"><span class="string">        yes. If deemed appropriate, the record may be modified in-place.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.nlen == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> self.name == record.name:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> record.name.find(self.name, <span class="number">0</span>, self.nlen) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> (record.name[self.nlen] == <span class="string">&quot;.&quot;</span>)</span><br></pre></td></tr></table></figure><p>注意Filter也有默认行为,过滤行为设计到初始化的Filer,这里就不细说了.</p><blockquote><h3 id="日志流处理简要流程"><a href="#日志流处理简要流程" class="headerlink" title="日志流处理简要流程"></a>日志流处理简要流程</h3><p>1、创建一个logger</p><p>2、设置下logger的日志的等级</p><p>3、创建合适的Handler(FileHandler要有路径)</p><p>4、设置下每个Handler的日志等级</p><p>5、创建下日志的格式</p><p>6、向Handler中添加上面创建的格式</p><p>7、将上面创建的Handler添加到logger中</p><p>8、打印输出logger.debug\logger.info\logger.warning\logger.error\logger.critical</p></blockquote><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li>重复写日志问题</li></ol><blockquote><p>用Python的logging模块记录日志时，可能会遇到重复记录日志的问题，第一条记录写一次，第二条记录写两次，第三条记录写三次</p></blockquote><p>原因:：第二次调用log的时候，根据getLogger(name)里的name获取同一个logger，而这个logger里已经有了第一次你添加的handler，第二次调用又添加了一个handler，所以，这个logger里有了两个同样的handler，以此类推，调用几次就会有几个handler。</p><p> 解决办法:1. 最后移除handler 2.做判断,若logger已有handler,则不再添加handler</p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">#解决方案1，添加removeHandler语句，每次用完之后移除Handler</span></span><br><span class="line">logger.removeHandler(fh)</span><br><span class="line">logger.removeHandler(ch)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> logger.handlers:</span><br><span class="line">        <span class="comment">#创建handler</span></span><br><span class="line">    fh = logging.FileHandler(<span class="string">&quot;test.log&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    ch = logging.StreamHandler()</span><br><span class="line">​</span><br><span class="line">        <span class="comment">#设置输出日志格式</span></span><br><span class="line">     formatter = logging.Formatter(</span><br><span class="line">            fmt=<span class="string">&quot;%(asctime)s %(name)s %(filename)s %(message)s&quot;</span>,</span><br><span class="line">            datefmt=<span class="string">&quot;%Y/%m/%d %X&quot;</span></span><br><span class="line">            )</span><br></pre></td></tr></table></figure><h3 id="logging配置文件"><a href="#logging配置文件" class="headerlink" title="logging配置文件"></a>logging配置文件</h3><p>可以使用<code>logging.conf.fileconf</code>进行配置logging</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging.config</span><br><span class="line">logging.config.fileConfig(<span class="string">&#x27;logging.conf&#x27;</span>)</span><br></pre></td></tr></table></figure><p>下面是一个<code>logging.conf</code>文件demo</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">文件配置</span><br><span class="line">配置文件logging.conf如下:</span><br><span class="line">[loggers]</span><br><span class="line"><span class="attribute">keys</span>=root,example01</span><br><span class="line"></span><br><span class="line">[logger_root]</span><br><span class="line"><span class="attribute">level</span>=DEBUG</span><br><span class="line"><span class="attribute">handlers</span>=hand01,hand02</span><br><span class="line"></span><br><span class="line">[logger_example01]</span><br><span class="line"><span class="attribute">handlers</span>=hand01,hand02</span><br><span class="line"><span class="attribute">qualname</span>=example01</span><br><span class="line"><span class="attribute">propagate</span>=0</span><br><span class="line"></span><br><span class="line">[handlers]</span><br><span class="line"><span class="attribute">keys</span>=hand01,hand02</span><br><span class="line"></span><br><span class="line">[handler_hand01]</span><br><span class="line"><span class="attribute">class</span>=StreamHandler</span><br><span class="line"><span class="attribute">level</span>=INFO</span><br><span class="line"><span class="attribute">formatter</span>=form02</span><br><span class="line">args=(sys.stderr,)</span><br><span class="line"></span><br><span class="line">[handler_hand02]</span><br><span class="line"><span class="attribute">class</span>=FileHandler</span><br><span class="line"><span class="attribute">level</span>=DEBUG</span><br><span class="line"><span class="attribute">formatter</span>=form01</span><br><span class="line">args=(<span class="string">&#x27;log.log&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">[formatters]</span><br><span class="line"><span class="attribute">keys</span>=form01,form02</span><br><span class="line"></span><br><span class="line">[formatter_form01]</span><br><span class="line"><span class="attribute">format</span>=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s```</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/445411809">最棒总结！Python日志库 logging 使用指南来了 - 知乎 (zhihu.com)</a></li><li><a href="https://www.cnblogs.com/yuanyongqiang/p/11913812.html#_label0">Python3 日志(内置logging模块) - 天马行宇 - 博客园 (cnblogs.com)</a></li><li><a href="https://www.jianshu.com/p/feb86c06c4f4">python logging模块使用教程 - 简书 (jianshu.com)</a></li><li><a href="https://www.cnblogs.com/yyds/p/6901864.html">Python之日志处理（logging模块） - 云游道士 - 博客园 (cnblogs.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;开发一个程序或者软件使用日志记录是非常有用的,对于开发者DEBUG,维护以及有经验的程序使用者都可以根据日志判断软件出了什么问题以及能做什么.这里主要介绍使用Python的原生模块logging写日志.&lt;br&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://www.sekyoro.top/tags/python/"/>
    
    <category term="logging" scheme="https://www.sekyoro.top/tags/logging/"/>
    
    <category term="日志" scheme="https://www.sekyoro.top/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>如何使用word组织一篇学术垃圾</title>
    <link href="https://www.sekyoro.top/2023/04/07/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8word%E7%BB%84%E7%BB%87%E4%B8%80%E7%AF%87%E5%AD%A6%E6%9C%AF%E5%9E%83%E5%9C%BE/"/>
    <id>https://www.sekyoro.top/2023/04/07/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8word%E7%BB%84%E7%BB%87%E4%B8%80%E7%AF%87%E5%AD%A6%E6%9C%AF%E5%9E%83%E5%9C%BE/</id>
    <published>2023-04-07T03:57:06.000Z</published>
    <updated>2023-06-09T15:17:09.331Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>简单来说就是word样式设置</p><span id="more"></span><h3 id="纸张大小设置"><a href="#纸张大小设置" class="headerlink" title="纸张大小设置"></a>纸张大小设置</h3><p><img data-src="https://s2.loli.net/2023/06/09/cRopkws7T1n2dxA.png" alt="image-20230609151901283"></p><h3 id="设置标题样式"><a href="#设置标题样式" class="headerlink" title="设置标题样式"></a>设置标题样式</h3><p><img data-src="https://s2.loli.net/2023/04/08/ebjiD7yvBS63HCW.png" alt="image-20230408221018455" style="zoom:50%;" /></p><p><img data-src="https://s2.loli.net/2023/04/08/PfaiO9EkbVGl7Up.png" alt="image-20230408221508064" style="zoom:50%;" /></p><p><img data-src="https://s2.loli.net/2023/04/08/OYpf3ti2mgGLKbR.png" alt="image-20230408221523407" style="zoom:50%;" /></p><h3 id="题注和引用"><a href="#题注和引用" class="headerlink" title="题注和引用"></a>题注和引用</h3><p><img data-src="https://s2.loli.net/2023/06/09/HSZhj4mEUreQBbD.png" alt="image-20230609170058267"></p><h3 id="页眉页码设置"><a href="#页眉页码设置" class="headerlink" title="页眉页码设置"></a>页眉页码设置</h3><p>需要使用分节符,在wps中可以设置显示分节符,在文件的选项中设置.</p><p><img data-src="https://s2.loli.net/2023/06/09/9wxroRGhuYIN1zE.png" alt="image-20230609160619429"></p><p>然后在封面，目录后插入分节符，在中英摘要之间插入分页符,在摘要与目录之间插入分页符</p><p><img data-src="https://s2.loli.net/2023/06/09/8Kn3TqpXOCoc4zP.png" alt="image-20230609161039060"></p><p>注意,这里摘要,目录使用I,II编号,正文使用阿拉伯数字.</p><p><img data-src="https://s2.loli.net/2023/06/09/hlifCENFVroXu4t.png" alt="image-20230609161112284"></p><p>此外有些论文要求奇偶页页眉不同,取消链接到前一节,勾选奇偶页不同,然后修改域,选择链接和引用,选择标题1.</p><p>同时有论文要求每章节需要分页</p><h3 id="使用公式"><a href="#使用公式" class="headerlink" title="使用公式"></a>使用公式</h3><p>可以使用自带公式编辑,就是鼠标点点点.</p><p>也可以使用在线的编辑器编辑公式复制进去.</p><p>或者安装MathType<a href="https://zhuanlan.zhihu.com/p/531033840#:~:text=说明：WPS里面“宏”的功能是锁定的，无法使用MathType的全部功能，需要上网下载一个“WPS的vba模块”程序。 WPS VBA 宏插件是一款WPS官方推出的WPS VBA模块插件工具，安装后可以开启WPS的宏功能，该WPS VBA,宏插件支持WPS2016和WPS2019版本，兼容Win7和Win10系统。 1.下载wps.vba.exe 链接： pan.baidu.com%2Fs%2F1DD-1j- 提取码：will 2.关闭WPS 3.运行wps.vba.exe，傻瓜式安装（一直下一步）">WPS加载MathType模块 - 知乎 (zhihu.com)</a></p><h3 id="制作三线表"><a href="#制作三线表" class="headerlink" title="制作三线表"></a>制作三线表</h3><p>表格的应用</p><p><img data-src="https://s2.loli.net/2023/04/11/FshAErVzwxaZIOQ.png" alt="image-20230411155154936" style="zoom:67%;" /></p><p><img data-src="https://s2.loli.net/2023/04/11/3PKRuZlpk8wAQvN.png" alt="image-20230411155204407"></p><h3 id="插入参考文献"><a href="#插入参考文献" class="headerlink" title="插入参考文献"></a>插入参考文献</h3><p>推荐使用EndNote或Zotero,详细教程可以看看</p><p><a href="https://www.sekyoro.top/2023/04/02/EndNote基本使用/">EndNote基本使用 | Sekyoro的博客小屋</a></p><p><a href="https://www.sekyoro.top/2022/10/01/Obsidian学习/">Obsidian学习与Zotero联动 | Sekyoro的博客小屋</a></p><h3 id="生成目录"><a href="#生成目录" class="headerlink" title="生成目录"></a>生成目录</h3><p>使用各种标题样式,然后使用引用中的目录.</p><p><img data-src="https://s2.loli.net/2023/06/09/clXritTnsYvjBS1.png" alt="image-20230609163349541"></p><p>注意自动生成的目录格式一般都需要修改.</p><h3 id="导出pdf"><a href="#导出pdf" class="headerlink" title="导出pdf"></a>导出pdf</h3><p>如果需要pdf可以使用在线网站或者wps本身提供的转pdf功能</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单来说就是word样式设置&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>mne处理脑电数据基本使用</title>
    <link href="https://www.sekyoro.top/2023/04/04/mne%E5%A4%84%E7%90%86%E8%84%91%E7%94%B5%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.sekyoro.top/2023/04/04/mne%E5%A4%84%E7%90%86%E8%84%91%E7%94%B5%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2023-04-04T06:40:57.000Z</published>
    <updated>2023-07-03T14:18:20.915Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近的东西,不定期更新<br><span id="more"></span></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>一般处理脑电数据的工具有matlab的EEGlab和python的相关包工具,当然事实上有很多类似的工具.本人现在只接触了这些.</p><p>EEGLAB的使用这里不详细说了,比较方便的是其有方便的GUI,当然后面我也发现python也有相关的带GUI的EEG数据处理包.</p><p>这里主要介绍MNE同时也会搭配一些机器学习算法等.<a href="[Documentation overview — MNE 1.3.1 documentation](https://mne.tools/stable/overview/index.html">MNE官网</a>)</p><p><a href="[Glossary — MNE 1.3.1 documentation](https://mne.tools/stable/glossary.html">一些概念介绍</a>)</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>主要包括设置电极位置,重参考,降采样,滤波,使用ICA方法去除伪迹等.</p><p>可以使用Matlab或直接使用mne进行处理</p><h3 id="划分数据集"><a href="#划分数据集" class="headerlink" title="划分数据集"></a>划分数据集</h3><p>将数据集划分话训练集和测试集,主要使用sklearn工具包</p><p>可以直接使用<code>train_test_split</code>分割训练集,就是简单的按比例分割,可以先打乱</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个数据集X和相应的标签y,X中样本数目为100</span></span><br><span class="line">X, y = np.arange(<span class="number">200</span>).reshape((<span class="number">100</span>, <span class="number">2</span>)), <span class="built_in">range</span>(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#用train_test_split函数划分出训练集和测试集，测试集占比0.33</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split( X, y, test_size=<span class="number">0.33</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印出原始样本集、训练集和测试集的数目</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The length of original data X is:&quot;</span>, X.shape[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The length of train Data is:&quot;</span>, X_train.shape[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The length of test Data is:&quot;</span>, X_test.shape[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>但是一般用交叉验证划分比较多,比如<code>KFold</code>和<code>ShuffleSplit</code>.</p><p>这类包一般在<code>sklearn.model_selection</code>中,使用KFold等处理一个对象的运动想象任务的数据集划分,使用GroupKFold等处理对象间数据集划分. 也就是说可以使用GoupKFold,LeaveOneGoupOut处理跨对象的数据.</p><p>同时搭配<code>GridSearchCV</code>用于调整超参数,获得较好的模型.</p><h3 id="多域分析"><a href="#多域分析" class="headerlink" title="多域分析"></a>多域分析</h3><p>脑电信号可以涉及到多个域的特征提取</p><p><a href="https://blog.csdn.net/ZhangJingHuaJYO/article/details/123464658#:~:text=脑电信号常见的特征有： 时域中： 平均值、标准差、一阶差分、归一化一阶差分、能量、功率、高阶过零分析。 不稳定指数等,时频域： 功率谱密度、高阶谱、微分熵等 空间域： DASM、RASM、不对称系数、DCAU、多维度有向信息等">脑电EEG常用的特征</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pywt <span class="keyword">import</span> wavedec, waverec</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> mne.decoding <span class="keyword">import</span> CSP</span><br><span class="line"><span class="keyword">from</span> sklearn.discriminant_analysis <span class="keyword">import</span> LinearDiscriminantAnalysis <span class="keyword">as</span> LDA</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> make_pipeline</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> mne.decoding <span class="keyword">import</span> CSP</span><br><span class="line"><span class="keyword">from</span> sklearn.discriminant_analysis <span class="keyword">import</span> LinearDiscriminantAnalysis <span class="keyword">as</span> LDA</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> make_pipeline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> moabb</span><br><span class="line"><span class="keyword">from</span> moabb.evaluations <span class="keyword">import</span> WithinSessionEvaluation</span><br><span class="line"><span class="keyword">from</span> moabb.paradigms <span class="keyword">import</span> LeftRightImagery</span><br><span class="line"><span class="keyword">from</span> moabb.datasets <span class="keyword">import</span> BNCI2014004</span><br><span class="line"><span class="keyword">from</span> moabb.paradigms <span class="keyword">import</span> LeftRightImagery</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pywt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mne.channels <span class="keyword">import</span> make_standard_montage</span><br><span class="line"><span class="keyword">from</span> mne.datasets <span class="keyword">import</span> eegbci</span><br><span class="line"><span class="keyword">from</span> mne.preprocessing <span class="keyword">import</span> ICA</span><br><span class="line"><span class="keyword">from</span> mne_features.feature_extraction <span class="keyword">import</span> FeatureExtractor, extract_features</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> welch</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA, FastICA</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold, StratifiedKFold, ShuffleSplit, LeaveOneGroupOut</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> make_pipeline, Pipeline</span><br><span class="line"><span class="keyword">import</span> moabb</span><br><span class="line"><span class="keyword">from</span> moabb.datasets <span class="keyword">import</span> PhysionetMI</span><br><span class="line"><span class="keyword">from</span> moabb.evaluations <span class="keyword">import</span> WithinSessionEvaluation, CrossSubjectEvaluation</span><br><span class="line"><span class="keyword">from</span> moabb.paradigms <span class="keyword">import</span> LeftRightImagery, MotorImagery</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">from</span> mne.decoding <span class="keyword">import</span> CSP, UnsupervisedSpatialFilter, SlidingEstimator, cross_val_multiscore</span><br><span class="line"><span class="keyword">from</span> sklearn.discriminant_analysis <span class="keyword">import</span> LinearDiscriminantAnalysis <span class="keyword">as</span> LDA, LinearDiscriminantAnalysis</span><br><span class="line"><span class="keyword">from</span> mne.io <span class="keyword">import</span> read_raw_edf</span><br><span class="line"><span class="keyword">import</span> mne</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> mne <span class="keyword">import</span> events_from_annotations, concatenate_raws, pick_types, Epochs</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder, StandardScaler</span><br><span class="line"><span class="keyword">from</span> mne_features.univariate <span class="keyword">import</span> compute_energy_freq_bands, compute_pow_freq_bands, compute_mean</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> differential_entropy</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> spectrum <span class="keyword">import</span> burg, arburg</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest, f_classif, chi2, mutual_info_classif</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> make_pipeline, Pipeline</span><br><span class="line"><span class="keyword">from</span> mne.decoding <span class="keyword">import</span> UnsupervisedSpatialFilter, CSP</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> mne_features.univariate <span class="keyword">import</span> compute_spect_entropy</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> moabb.paradigms <span class="keyword">import</span> FilterBankLeftRightImagery</span><br><span class="line"><span class="keyword">from</span> moabb.pipelines.utils <span class="keyword">import</span> FilterBank</span><br><span class="line"><span class="keyword">import</span> moabb</span><br><span class="line"><span class="keyword">from</span> moabb.evaluations <span class="keyword">import</span> WithinSessionEvaluation</span><br><span class="line"><span class="keyword">from</span> moabb.paradigms <span class="keyword">import</span> LeftRightImagery</span><br><span class="line"><span class="keyword">from</span> moabb.datasets <span class="keyword">import</span> BNCI2014004</span><br><span class="line"><span class="keyword">from</span> moabb.paradigms <span class="keyword">import</span> LeftRightImagery</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pywt</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> FunctionTransformer</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mne.channels <span class="keyword">import</span> make_standard_montage</span><br><span class="line"><span class="keyword">from</span> mne.datasets <span class="keyword">import</span> eegbci</span><br><span class="line"><span class="keyword">from</span> mne.preprocessing <span class="keyword">import</span> ICA</span><br><span class="line"><span class="keyword">from</span> mne_features.feature_extraction <span class="keyword">import</span> FeatureExtractor, extract_features, FeatureFunctionTransformer</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> welch</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA, FastICA</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold, StratifiedKFold, ShuffleSplit, LeaveOneGroupOut</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> make_pipeline, Pipeline</span><br><span class="line"><span class="keyword">import</span> moabb</span><br><span class="line"><span class="keyword">from</span> moabb.datasets <span class="keyword">import</span> PhysionetMI</span><br><span class="line"><span class="keyword">from</span> moabb.evaluations <span class="keyword">import</span> WithinSessionEvaluation, CrossSubjectEvaluation</span><br><span class="line"><span class="keyword">from</span> moabb.paradigms <span class="keyword">import</span> LeftRightImagery, MotorImagery</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">from</span> mne.decoding <span class="keyword">import</span> CSP, UnsupervisedSpatialFilter, SlidingEstimator, cross_val_multiscore</span><br><span class="line"><span class="keyword">from</span> sklearn.discriminant_analysis <span class="keyword">import</span> LinearDiscriminantAnalysis <span class="keyword">as</span> LDA, LinearDiscriminantAnalysis</span><br><span class="line"><span class="keyword">from</span> mne.io <span class="keyword">import</span> read_raw_edf</span><br><span class="line"><span class="keyword">import</span> mne</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> mne <span class="keyword">import</span> events_from_annotations, concatenate_raws, pick_types, Epochs</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder, StandardScaler</span><br><span class="line"><span class="keyword">from</span> mne_features.univariate <span class="keyword">import</span> compute_energy_freq_bands, compute_pow_freq_bands, compute_mean</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> differential_entropy</span><br><span class="line"><span class="keyword">from</span> spectrum <span class="keyword">import</span> burg, arburg</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest, f_classif, chi2, mutual_info_classif</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> make_pipeline, Pipeline</span><br><span class="line"><span class="keyword">from</span> mne.decoding <span class="keyword">import</span> UnsupervisedSpatialFilter, CSP</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> mne_features.univariate <span class="keyword">import</span> compute_spect_entropy</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> FunctionTransformer</span><br><span class="line"><span class="keyword">from</span> mne_features.feature_extraction <span class="keyword">import</span> FeatureExtractor, extract_features</span><br><span class="line"><span class="keyword">from</span> moabb.paradigms <span class="keyword">import</span> FilterBankLeftRightImagery</span><br><span class="line"><span class="keyword">from</span> moabb.pipelines.utils <span class="keyword">import</span> FilterBank</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">from</span> mne <span class="keyword">import</span> time_frequency</span><br><span class="line"></span><br><span class="line"><span class="comment"># def csp_params(data):</span></span><br><span class="line"><span class="comment">#     csp_ins = CSP(n_components=8)</span></span><br><span class="line"><span class="comment">#     X_new = csp_ins.fit_transform(data,label)</span></span><br><span class="line"><span class="comment">#     return X_new</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">bci competition IV 2b 分类结果</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_sub_result</span>(<span class="params">acc_lda_scores, acc_knn_scores, acc_svm_scores</span>):</span></span><br><span class="line">    barWidth = <span class="number">0.3</span></span><br><span class="line"></span><br><span class="line">    acc_lda_scores.append(np.mean(acc_lda_scores))</span><br><span class="line">    acc_knn_scores.append(np.mean(acc_knn_scores))</span><br><span class="line">    acc_svm_scores.append(np.mean(acc_svm_scores))</span><br><span class="line"></span><br><span class="line">    r1 = np.arange(<span class="built_in">len</span>(acc_lda_scores))</span><br><span class="line">    r2 = [x + barWidth <span class="keyword">for</span> x <span class="keyword">in</span> r1]</span><br><span class="line">    r3 = [x + barWidth <span class="keyword">for</span> x <span class="keyword">in</span> r2]</span><br><span class="line">    plt.bar(r1, acc_lda_scores, width=barWidth, edgecolor=<span class="string">&#x27;white&#x27;</span>, label=<span class="string">&#x27;LDA&#x27;</span>)</span><br><span class="line">    plt.bar(r2, acc_knn_scores, width=barWidth, edgecolor=<span class="string">&#x27;white&#x27;</span>, label=<span class="string">&#x27;KNN&#x27;</span>)</span><br><span class="line">    plt.bar(r3, acc_svm_scores, width=barWidth, edgecolor=<span class="string">&#x27;white&#x27;</span>, label=<span class="string">&#x27;SVM&#x27;</span>)</span><br><span class="line">    plt.xticks([r + barWidth <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(acc_lda_scores))],</span><br><span class="line">               [<span class="string">&#x27;sub&#x27;</span> + <span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(acc_lda_scores) + <span class="number">1</span>)] + [<span class="string">&#x27;平均&#x27;</span>])</span><br><span class="line">    <span class="comment"># y轴</span></span><br><span class="line">    plt.ylabel(<span class="string">&quot;准确率&quot;</span>)</span><br><span class="line">    <span class="comment"># 创建图例</span></span><br><span class="line"></span><br><span class="line">    plt.title(<span class="string">&quot;频域分类结果对比&quot;</span>)</span><br><span class="line">    <span class="comment"># 展示图片</span></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ar_coeff</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    return AR coefficients</span></span><br><span class="line"><span class="string">    :param data:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    model_order = <span class="number">8</span></span><br><span class="line">    features = [arburg(data[i], order=model_order)[<span class="number">0</span>].real <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(data.shape[<span class="number">0</span>])]</span><br><span class="line">    <span class="comment"># np.zeros((data.shape[0], model_order))</span></span><br><span class="line">    <span class="comment"># for i in range(data.shape[0]):</span></span><br><span class="line">    <span class="comment"># AR, rho, ref = arburg(data[i], model_order)</span></span><br><span class="line">    <span class="comment"># features[i] = AR.real</span></span><br><span class="line">    features = np.mean(features, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> features</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">differ_en</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="comment"># compute differential entropy</span></span><br><span class="line">    freqs, psd = welch(data, <span class="number">160</span>, nperseg=<span class="number">320</span>, )</span><br><span class="line">    idx_alpha = np.logical_and(freqs &gt;= <span class="number">1</span>, freqs &lt;= <span class="number">45</span>)</span><br><span class="line">    alpha_psd = psd[:, idx_alpha]</span><br><span class="line">    variance = np.var(alpha_psd, ddof=<span class="number">1</span>, axis=-<span class="number">1</span>)  <span class="comment"># 计算指定数据(数组元素)的方差 ,ddof=1 除以（n-1）,ddof=0代表除以n，默认值为0</span></span><br><span class="line">    result = np.log(<span class="number">2</span> * math.pi * math.e * variance) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dwt_coeff</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    dwt coefficients</span></span><br><span class="line"><span class="string">    :param data:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cA4, cD4, cD3, _, _ = pywt.wavedec(data, <span class="string">&#x27;db4&#x27;</span>, level=<span class="number">4</span>)</span><br><span class="line">    cA4_mean = np.mean(cA4, axis=<span class="number">1</span>)</span><br><span class="line">    cA_var = np.var(cA4, axis=-<span class="number">1</span>)</span><br><span class="line">    cD4_mean = np.mean(cD4, axis=<span class="number">1</span>)</span><br><span class="line">    cD4_var = np.var(cD4, axis=-<span class="number">1</span>)</span><br><span class="line">    cD3_mean = np.mean(cD3, axis=<span class="number">1</span>)</span><br><span class="line">    cD3_var = np.var(cD3, axis=-<span class="number">1</span>)</span><br><span class="line">    feature = np.concatenate((cA4_mean, cA_var, cD4_mean, cD4_var, cD3_mean, cD3_var), axis=-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> feature</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wavepack_coeff_energy</span>(<span class="params">data</span>):</span></span><br><span class="line">    n = <span class="number">3</span></span><br><span class="line">    wp = pywt.WaveletPacket(data, wavelet=<span class="string">&#x27;db4&#x27;</span>, maxlevel=n)</span><br><span class="line">    re = []  <span class="comment"># 第n层所有节点的分解系数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [node.path <span class="keyword">for</span> node <span class="keyword">in</span> wp.get_level(n, <span class="string">&#x27;freq&#x27;</span>)]:</span><br><span class="line">        re.append(wp[i].data)</span><br><span class="line">    <span class="comment"># 第n层能量特征</span></span><br><span class="line">    energy = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> re:</span><br><span class="line">        energy.append(<span class="built_in">pow</span>(np.linalg.norm(i, axis=-<span class="number">1</span>), <span class="number">2</span>))</span><br><span class="line">    D1 = energy[<span class="number">0</span>] / np.<span class="built_in">sum</span>(energy)</span><br><span class="line">    D2 = energy[<span class="number">1</span>] / np.<span class="built_in">sum</span>(energy)</span><br><span class="line">    D3 = energy[<span class="number">2</span>] / np.<span class="built_in">sum</span>(energy)</span><br><span class="line">    D1_mean = np.mean(wp[<span class="string">&#x27;aaa&#x27;</span>].data, axis=-<span class="number">1</span>)</span><br><span class="line">    D2_mean = np.mean(wp[<span class="string">&#x27;aad&#x27;</span>].data, axis=-<span class="number">1</span>)</span><br><span class="line">    D3_mean = np.mean(wp[<span class="string">&#x27;add&#x27;</span>].data, axis=-<span class="number">1</span>)</span><br><span class="line">    D1_var = np.var(wp[<span class="string">&#x27;aaa&#x27;</span>].data, axis=-<span class="number">1</span>)</span><br><span class="line">    D2_var = np.var(wp[<span class="string">&#x27;aad&#x27;</span>].data, axis=-<span class="number">1</span>)</span><br><span class="line">    D3_var = np.var(wp[<span class="string">&#x27;add&#x27;</span>].data, axis=-<span class="number">1</span>)</span><br><span class="line">    features = np.concatenate((D1, D2, D3, D1_mean, D2_mean, D3_mean, D1_var, D2_var, D3_var), axis=-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> features</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dwt_coeff</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    dwt coefficients</span></span><br><span class="line"><span class="string">    :param data:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cA4, cD4, cD3, _, _ = pywt.wavedec(data, <span class="string">&#x27;db4&#x27;</span>, level=<span class="number">4</span>)</span><br><span class="line">    cA4_mean = np.mean(cA4, axis=-<span class="number">1</span>)</span><br><span class="line">    cA_var = np.var(cA4, axis=-<span class="number">1</span>)</span><br><span class="line">    cD4_mean = np.mean(cD4, axis=-<span class="number">1</span>)</span><br><span class="line">    cD4_var = np.var(cD4, axis=-<span class="number">1</span>)</span><br><span class="line">    cD3_mean = np.mean(cD3, axis=-<span class="number">1</span>)</span><br><span class="line">    cD3_var = np.var(cD3, axis=-<span class="number">1</span>)</span><br><span class="line">    feature = np.concatenate((cA4_mean, cA_var, cD4_mean, cD4_var, cD3_mean, cD3_var), axis=-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> feature</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delta</span>(<span class="params">data</span>):</span></span><br><span class="line">    b, a = signal.butter(<span class="number">8</span>, [<span class="number">4</span> / <span class="number">160</span> * <span class="number">2</span>, <span class="number">8</span> / <span class="number">160</span> * <span class="number">2</span>], btype=<span class="string">&#x27;bandpass&#x27;</span>)</span><br><span class="line">    filteredData = signal.filtfilt(b, a, data)</span><br><span class="line">    <span class="keyword">return</span> filteredData</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_bci</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="comment"># session_condition = (data[&quot;session&quot;]==&quot;session_2&quot;)|(data[&quot;session&quot;]==&quot;session_3&quot;)|(data[&quot;session&quot;]==&quot;session_4&quot;)</span></span><br><span class="line">    scores = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">109</span>):</span><br><span class="line">        conditon = (data[<span class="string">&quot;subject&quot;</span>] == <span class="built_in">str</span>(i))</span><br><span class="line">        <span class="built_in">print</span>(data[conditon][<span class="string">&quot;score&quot;</span>])</span><br><span class="line">        score = np.<span class="built_in">max</span>(data[conditon][<span class="string">&quot;score&quot;</span>])</span><br><span class="line">        <span class="keyword">if</span> score &gt;= <span class="number">0.74</span>:</span><br><span class="line">            scores.append(score)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(scores) == <span class="number">20</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> scores</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reconstruct_dwt</span>(<span class="params">data</span>):</span></span><br><span class="line">    coeffs = wavedec(data, <span class="string">&#x27;db4&#x27;</span>, level=<span class="number">4</span>)</span><br><span class="line">    newdata = waverec(coeffs, <span class="string">&#x27;db4&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> newdata</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">psd_welch</span>(<span class="params">data</span>):</span></span><br><span class="line">    psd, fres = time_frequency.psd_array_welch(data, sfreq=<span class="number">160</span>, fmin=<span class="number">0.1</span>, fmax=<span class="number">60</span>, n_fft=<span class="number">160</span>, n_overlap=<span class="number">80</span>)</span><br><span class="line">    <span class="built_in">print</span>(psd.shape)</span><br><span class="line">    <span class="keyword">return</span> psd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wavelet_packet</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(x.shape)</span><br><span class="line">    mother_wavelet = <span class="string">&#x27;db4&#x27;</span></span><br><span class="line">    wp = pywt.WaveletPacket(data=x, wavelet=mother_wavelet, mode=<span class="string">&#x27;symmetric&#x27;</span>, maxlevel=<span class="number">4</span>)</span><br><span class="line">    node_name_list = [node.path <span class="keyword">for</span> node <span class="keyword">in</span> wp.get_level(<span class="number">4</span>, <span class="string">&#x27;natural&#x27;</span>)]</span><br><span class="line">    rec_results = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> node_name_list:</span><br><span class="line">        new_wp = pywt.WaveletPacket(data=x, wavelet=mother_wavelet, mode=<span class="string">&#x27;symmetric&#x27;</span>)</span><br><span class="line">        new_wp[i] = wp[i].data</span><br><span class="line">        x_i = new_wp.reconstruct(update=<span class="literal">True</span>)</span><br><span class="line">        rec_results.append(x_i)</span><br><span class="line">    output = np.array(rec_results)</span><br><span class="line">    output = np.reshape(output, (x.shape[<span class="number">0</span>], -<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(output.shape)</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reshapeIN</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;expand&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(data.shape)</span><br><span class="line">    <span class="comment">## 首先将inf值都替换为nan</span></span><br><span class="line">    data[np.isinf(data) | np.isnan(data)] = <span class="number">0.01</span></span><br><span class="line">    <span class="comment"># newdata = np.reshape(data,(-1,3,data.shape[-1]))</span></span><br><span class="line">    <span class="comment"># newdata = np.reshape(data, (-1, 21, data.shape[-1]))</span></span><br><span class="line">    newdata = np.reshape(data, (-<span class="number">1</span>, <span class="number">14</span>, data.shape[-<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">return</span> newdata</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reshapeDE</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;shrink&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(data.shape)</span><br><span class="line">    <span class="comment">## 首先将inf值都替换为nan</span></span><br><span class="line">    data[np.isinf(data) | np.isnan(data)] = <span class="number">0.01</span></span><br><span class="line">    <span class="comment"># newdata = np.reshape(data,(-1,3,data.shape[-1]))</span></span><br><span class="line">    <span class="comment"># newdata = np.reshape(data, (-1, 21, data.shape[-1]))</span></span><br><span class="line">    newdata = np.reshape(data, (data.shape[<span class="number">0</span>], -<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> newdata</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(data.shape)</span><br><span class="line">    b, a = signal.butter(<span class="number">8</span>, [<span class="number">0.1</span> / <span class="number">160</span> * <span class="number">2</span>, <span class="number">4</span> / <span class="number">160</span> * <span class="number">2</span>], btype=<span class="string">&#x27;bandpass&#x27;</span>)</span><br><span class="line">    delta_dataset = signal.filtfilt(b, a, data)</span><br><span class="line">    b, a = signal.butter(<span class="number">8</span>, [<span class="number">4</span> / <span class="number">160</span> * <span class="number">2</span>, <span class="number">7</span> / <span class="number">160</span> * <span class="number">2</span>], btype=<span class="string">&#x27;bandpass&#x27;</span>)</span><br><span class="line">    theta_dataset = signal.filtfilt(b, a, data)</span><br><span class="line">    b, a = signal.butter(<span class="number">8</span>, [<span class="number">7</span> / <span class="number">160</span> * <span class="number">2</span>, <span class="number">18</span> / <span class="number">160</span> * <span class="number">2</span>], btype=<span class="string">&#x27;bandpass&#x27;</span>)</span><br><span class="line">    u_dataset = signal.filtfilt(b, a, data)</span><br><span class="line">    b, a = signal.butter(<span class="number">8</span>, [<span class="number">16</span> / <span class="number">160</span> * <span class="number">2</span>, <span class="number">24</span> / <span class="number">160</span> * <span class="number">2</span>], btype=<span class="string">&#x27;bandpass&#x27;</span>)</span><br><span class="line">    beta_Data = signal.filtfilt(b, a, data)</span><br><span class="line">    b, a = signal.butter(<span class="number">8</span>, [<span class="number">30</span> / <span class="number">160</span> * <span class="number">2</span>, <span class="number">50</span> / <span class="number">160</span> * <span class="number">2</span>], btype=<span class="string">&#x27;bandpass&#x27;</span>)</span><br><span class="line">    gamma_Data = signal.filtfilt(b, a, data)</span><br><span class="line">    newData = np.concatenate((data, u_dataset, beta_Data), axis=-<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(newData.shape)</span><br><span class="line">    <span class="keyword">return</span> newData</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_channel</span>(<span class="params">data</span>):</span></span><br><span class="line">    selected_channel = (<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>,)</span><br><span class="line">    <span class="comment"># selected_channel = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)</span></span><br><span class="line">    selected_channel = (<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">20</span>, <span class="number">26</span>, <span class="number">33</span>, <span class="number">49</span>, <span class="number">51</span>, <span class="number">57</span>, <span class="number">63</span>)</span><br><span class="line">    newdata = data[:, selected_channel, :]</span><br><span class="line">    <span class="keyword">return</span> newdata</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 设置中文显示字体</span></span><br><span class="line">    matplotlib.rc(<span class="string">&quot;font&quot;</span>, family=<span class="string">&#x27;Microsoft YaHei&#x27;</span>)</span><br><span class="line">    matplotlib.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">    <span class="comment"># feature extraction</span></span><br><span class="line">    timedomain_features = &#123;<span class="string">&#x27;variance&#x27;</span>, <span class="string">&#x27;hjorth_mobility&#x27;</span>, <span class="string">&#x27;hjorth_complexity&#x27;</span>, <span class="string">&#x27;skewness&#x27;</span>, <span class="string">&#x27;kurtosis&#x27;</span>,</span><br><span class="line">                           <span class="string">&#x27;zero_crossings&#x27;</span>, <span class="string">&#x27;higuchi_fd&#x27;</span>, <span class="string">&#x27;rms&#x27;</span>, <span class="string">&#x27;ptp_amp&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">    freqdomain_features = &#123;(<span class="string">&#x27;DE&#x27;</span>, differ_en), <span class="string">&#x27;pow_freq_bands&#x27;</span>, <span class="string">&#x27;energy_freq_bands&#x27;</span>&#125;</span><br><span class="line">    freqdomain_params = &#123;</span><br><span class="line">        <span class="string">&#x27;pow_freq_bands__freq_bands&#x27;</span>: np.array([<span class="number">0.5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">45</span>]),</span><br><span class="line">        <span class="string">&#x27;pow_freq_bands__ratios&#x27;</span>: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;energy_freq_bands__freq_bands&#x27;</span>: np.array([<span class="number">0.5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">30</span>, <span class="number">45</span>]),</span><br><span class="line">    &#125;</span><br><span class="line">    timefredomain_features = &#123;(<span class="string">&#x27;dwt_coeff&#x27;</span>, dwt_coeff)&#125;</span><br><span class="line">    timefredomain_features = &#123;(<span class="string">&#x27;dwt_coeff&#x27;</span>, reconstruct_dwt)&#125;</span><br><span class="line">    delta_signal = &#123;(<span class="string">&#x27;delta&#x27;</span>, delta)&#125;</span><br><span class="line">    dataset = PhysionetMI(imagined=<span class="literal">True</span>, executed=<span class="literal">False</span>)</span><br><span class="line">    sub_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">109</span>)]</span><br><span class="line">    dataset.subject_list = sub_list</span><br><span class="line">    paradigm = LeftRightImagery()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;metric&quot;</span>, paradigm.scoring)</span><br><span class="line">    acc_lda_scores = []</span><br><span class="line">    acc_knn_scores = []</span><br><span class="line">    acc_svm_scores = []</span><br><span class="line">    evaluation = WithinSessionEvaluation(</span><br><span class="line">        paradigm=paradigm,</span><br><span class="line">        datasets=[dataset],</span><br><span class="line">        overwrite=<span class="literal">True</span>,</span><br><span class="line">        hdf5_path=<span class="literal">None</span>,</span><br><span class="line">    )</span><br><span class="line">    expand = FunctionTransformer(reshapeIN)</span><br><span class="line">    shrink = FunctionTransformer(reshapeDE)</span><br><span class="line">    downsample = FunctionTransformer(dp)</span><br><span class="line">    channel_selection = FunctionTransformer(select_channel)</span><br><span class="line">    myfeature = &#123;(<span class="string">&#x27;psd&#x27;</span>, psd_welch)&#125;</span><br><span class="line">    fe = FeatureExtractor(<span class="number">160</span>, selected_funcs=myfeature)</span><br><span class="line">    pipeline = make_pipeline(channel_selection, downsample, CSP(n_components=<span class="number">8</span>),</span><br><span class="line">                             LDA())</span><br><span class="line">    results_t = evaluation.process(&#123;<span class="string">&quot;timedomain+lda&quot;</span>: pipeline&#125;)</span><br><span class="line">    <span class="built_in">print</span>(results_t)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># fe = FeatureExtractor(160, selected_funcs=freqdomain_features, params=freqdomain_params)</span></span><br><span class="line">    pipeline = make_pipeline(channel_selection, downsample, CSP(n_components=<span class="number">8</span>),</span><br><span class="line">                             KNeighborsClassifier())</span><br><span class="line">    results_k = evaluation.process(&#123;<span class="string">&quot;freqdomain+lda&quot;</span>: pipeline&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># fe = FeatureExtractor(160, selected_funcs=timefredomain_features)</span></span><br><span class="line">    pipeline = make_pipeline(channel_selection, downsample, CSP(n_components=<span class="number">8</span>),</span><br><span class="line">                             SVC())</span><br><span class="line">    results_s = evaluation.process(&#123;<span class="string">&quot;timefreq+lda&quot;</span>: pipeline&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h3><p>经过调研，准确率与Kappa系数常被用做BCI分类效果的评价指标.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># delta_signal = &#123;(&#x27;delta&#x27;, delta)&#125;</span></span><br><span class="line"><span class="comment"># fe = FeatureExtractor(250, selected_funcs=delta_signal)</span></span><br><span class="line"><span class="comment"># pipeline = make_pipeline(CSP(n_components=8), SVC())</span></span><br><span class="line"><span class="comment"># results_csp = evaluation.process(&#123;&quot;CSP+lda&quot;: pipeline&#125;)</span></span><br><span class="line"></span><br><span class="line">l1 = process_bci(results_t)</span><br><span class="line">l2 = process_bci(results_k)</span><br><span class="line">l3 = process_bci(results_s)</span><br><span class="line"><span class="comment"># l4 = process_bci(results_csp)</span></span><br><span class="line">l1 = np.array(l1)</span><br><span class="line">l2 = np.array(l2)</span><br><span class="line">l3 = np.array(l3)</span><br><span class="line"><span class="comment"># l4 = np.array(l4)</span></span><br><span class="line"></span><br><span class="line">l1 = np.append(l1, np.mean(l1))</span><br><span class="line">l2 = np.append(l2, np.mean(l3))</span><br><span class="line">l3 = np.append(l3, np.mean(l3))</span><br><span class="line"><span class="comment"># l4 = np.append(l4, np.mean(l4))</span></span><br><span class="line">barWidth = <span class="number">0.3</span></span><br><span class="line">r1 = np.arange(<span class="built_in">len</span>(l1))</span><br><span class="line">r2 = [x + barWidth <span class="keyword">for</span> x <span class="keyword">in</span> r1]</span><br><span class="line">r3 = [x + barWidth <span class="keyword">for</span> x <span class="keyword">in</span> r2]</span><br><span class="line"><span class="comment"># r4 = [x + barWidth for x in r3]</span></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.bar(r1, l1, width=barWidth, edgecolor=<span class="string">&#x27;white&#x27;</span>, label=<span class="string">&#x27;LDA&#x27;</span>)</span><br><span class="line">plt.bar(r2, l2, width=barWidth, edgecolor=<span class="string">&#x27;white&#x27;</span>, label=<span class="string">&#x27;KNN&#x27;</span>)</span><br><span class="line">plt.bar(r3, l3, width=barWidth, edgecolor=<span class="string">&#x27;white&#x27;</span>, label=<span class="string">&#x27;SVC&#x27;</span>)</span><br><span class="line"><span class="comment"># plt.bar(r4, l4, width=barWidth, edgecolor=&#x27;white&#x27;, label=&#x27;CSP&#x27;)</span></span><br><span class="line">plt.xticks([r + barWidth <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(l1))], [<span class="string">&#x27;s&#x27;</span> + <span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(l1))] + [<span class="string">&#x27;平均&#x27;</span>])</span><br><span class="line"><span class="comment"># y轴</span></span><br><span class="line">plt.ylabel(<span class="string">&quot;准确率&quot;</span>)</span><br><span class="line"><span class="comment"># 创建图例</span></span><br><span class="line">plt.legend(loc=<span class="string">&quot;upper center&quot;</span>)</span><br><span class="line"><span class="comment"># 标题</span></span><br><span class="line">plt.title(<span class="string">&quot;TCSSF特征提取对比&quot;</span>)</span><br><span class="line"><span class="comment"># 展示图片</span></span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">print</span>(l1)</span><br><span class="line"><span class="built_in">print</span>(l2)</span><br><span class="line"><span class="built_in">print</span>(l3)</span><br><span class="line"><span class="comment"># print(l4)</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://mne.tools/stable/overview/index.html">Documentation overview — MNE 1.3.1 documentation</a></p></li><li><p><a href="https://github.com/ZitongLu1996/Python-EEG-Handbook">ZitongLu1996/Python-EEG-Handbook: Python脑电数据处理中文手册 - A Chinese handbook for EEG data analysis based on Python (github.com)</a></p><h3 id="有用的Python库"><a href="#有用的Python库" class="headerlink" title="有用的Python库"></a>有用的Python库</h3><ol><li>mne</li><li>mne-features<a href="https://mne.tools/mne-features/auto_examples/plot_mne_sample_features.html#sphx-glr-auto-examples-plot-mne-sample-features-py">Extract features from MEG time series for classification — mne_features 0.2 documentation</a></li><li>eeglib<a href="https://github.com/Xiul109/eeglib">Xiul109/eeglib: A library with tools for EEG analysis (github.com)</a></li><li>pyeeg<a href="https://github.com/forrestbao/pyeeg/tree/master/pyeeg">pyeeg/pyeeg at master · forrestbao/pyeeg (github.com)</a></li><li>scikit-learn</li></ol></li></ol><h3 id="Github相关项目"><a href="#Github相关项目" class="headerlink" title="Github相关项目"></a>Github相关项目</h3><ol><li><a href="https://github.com/JoyRabha/Feature-Extraction-EEG/blob/master/Feature Extraction.ipynb">Feature-Extraction-EEG/Feature Extraction.ipynb at master · JoyRabha/Feature-Extraction-EEG (github.com)</a>特征提取的库</li><li><a href="https://github.com/dasdarin/eeg-features">https://github.com/dasdarin/eeg-features</a></li><li><a href="https://github.com/mcguegi/eeg_analysis_thesis/tree/master/feature_extraction">eeg_analysis_thesis/feature_extraction at master · mcguegi/eeg_analysis_thesis (github.com)</a></li><li><a href="https://github.com/yangsh827/Seizure_FE/blob/master/FE.py">Seizure_FE/FE.py at master · yangsh827/Seizure_FE (github.com)</a></li><li><a href="https://github.com/omerfbhatti/BCI-Project">omerfbhatti/BCI-Project: Brain Computer Interface Project as part of “Programming for DSAI” course at AIT (github.com)</a></li><li><a href="https://github.com/sari-saba-sadiya/EEGExtract/blob/main/EEGExtract.py">EEGExtract/EEGExtract.py at main · sari-saba-sadiya/EEGExtract (github.com)</a></li><li><a href="https://github.com/vancleys/EEGFeatures">vancleys/EEGFeatures: EEG Features to be extract from raw data. (github.com)</a></li><li><a href="https://github.com/prashanth-prakash/EEG-ANALYSIS-FOR-MOTOR-IMAGERY-APPLICATION/blob/master/Notebooks/CSP_features_Classification.ipynb">EEG-ANALYSIS-FOR-MOTOR-IMAGERY-APPLICATION/CSP_features_Classification.ipynb at master · prashanth-prakash/EEG-ANALYSIS-FOR-MOTOR-IMAGERY-APPLICATION (github.com)</a></li><li><a href="https://github.com/MEDHA-TIWARI/Feature-extraction-technique-for-EEG-signals">MEDHA-TIWARI/Feature-extraction-technique-for-EEG-signals: feature extraction from eeg datasets (github.com)</a></li><li><a href="https://github.com/wmichalska/EEG-emotions">wmichalska/EEG-emotions: Application prepares data to learning process. Including preprocessing, cleaning, reformating, feature extraction using PyEEG library and learning using Sklearn tool. (github.com)</a></li><li><a href="https://github.com/jesus-333/FBCSP-Python">jesus-333/FBCSP-Python: Python implemementation of the FBCSP algorithm (github.com)</a></li><li><a href="https://github.com/mauricio-ms/motor-imagery/blob/master/README.md">motor-imagery/README.md at master · mauricio-ms/motor-imagery · GitHub</a></li><li><a href="https://github.com/stupiddogger/FBCSP/blob/master/FBCSP.py">FBCSP/FBCSP.py at master · stupiddogger/FBCSP · GitHub</a> FBCSP</li><li><a href="https://github.com/TNTLFreiburg/fbcsp/tree/master">TNTLFreiburg/fbcsp (github.com)</a> FB</li><li><a href="https://github.com/NeuroTechX/moabb/tree/develop">NeuroTechX/moabb: Mother of All BCI Benchmarks (github.com)</a></li></ol><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><ol><li>BCI Competition IV-1: <a href="http://www.bbci.de/competition/iv/#dataset1">http://www.bbci.de/competition/iv/#dataset1</a></li></ol><ol><li>BCI Competition IV-2a: <a href="http://www.bbci.de/competition/iv/#dataset2a">http://www.bbci.de/competition/iv/#dataset2a</a></li></ol><ol><li>BCI Competition IV-2b: <a href="http://www.bbci.de/competition/iv/#dataset2b">http://www.bbci.de/competition/iv/#dataset2b</a></li><li>Motor Movement/Imagery Dataset: <a href="https://www.physionet.org/physiobank/database/eegmmidb/">https://www.physionet.org/physiobank/database/eegmmidb/</a></li></ol><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近的东西,不定期更新&lt;br&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://www.sekyoro.top/tags/python/"/>
    
    <category term="MNE" scheme="https://www.sekyoro.top/tags/MNE/"/>
    
    <category term="EEG" scheme="https://www.sekyoro.top/tags/EEG/"/>
    
  </entry>
  
  <entry>
    <title>EndNote基本使用</title>
    <link href="https://www.sekyoro.top/2023/04/02/EndNote%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.sekyoro.top/2023/04/02/EndNote%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2023-04-02T11:45:33.000Z</published>
    <updated>2023-04-02T13:27:30.413Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>之前讲过使用Zotero管理并阅读文献,现在写论文的使用为了方便管理插入文献,这里使用EndNote管理.<br><span id="more"></span></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>Endnote是一款被广泛使用的文献管理软件，其是<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/SCI/18829">SCI</a>（Thomson Scientific 公司）的官方软件，支持国际期刊的参考文献格式有3776 种【也可以自定义期刊引用格式】。</p><p>软件非常方便科研狗进行文献整理，写笔记，做备注，分类，导出期刊格式，进行数据迁移【这个特别方便，可以随时将其他电脑上的文献导入到自己的电脑中】</p></blockquote><p>EndNote版本特别多,我目前用的是EndNote20,不过其他版本也类似.</p><p><a href="https://link.zhihu.com/?target=https%3A//its.tsinghua.edu.cn/column/bgrj/2">下载地址</a></p><p>注意下载的时候有一个添加的word选项勾上即可.</p><p>下面简单地介绍其使用</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="创建Library"><a href="#创建Library" class="headerlink" title="创建Library"></a>创建Library</h3><p><img data-src="http://cdn.sekyoro.top/imgs/02/0420230402200455.png" alt="image-20230402200448244" style="zoom:50%;" /></p><p>一个Library用于存放文献以及笔记.可以对文献进行分组.</p><p><img data-src="https://pic2.zhimg.com/80/v2-959f0acb60032ef5c334118a1f5b9a2d_720w.webp" alt="img" style="zoom:67%;" /></p><p>这里我以Pub Med的一篇文章导入为例</p><p><img data-src="http://cdn.sekyoro.top/imgs/02/0420230402200702.png" alt="image-20230402200702560" style="zoom: 50%;" /></p><p>下载好文件即可选择导入</p><p><img data-src="http://cdn.sekyoro.top/imgs/02/0420230402200741.png" alt="image-20230402200740915" style="zoom:50%;" /></p><p>由于这里是Pub Med格式,导入时还需要选择Filter</p><p><img data-src="http://cdn.sekyoro.top/imgs/02/0420230402201909.png" alt="image-20230402201908947" style="zoom:50%;" /></p><p>这里推荐尝试使用EndNote打开这个文件,也会导入到Library中,更加简单.</p><p>当然还可以直接通过自己填写信息添加文献,不过我推荐就使用上面的方式即可.</p><p><img data-src="http://cdn.sekyoro.top/imgs/02/0420230402202743.png" alt="image-20230402202743736" style="zoom:50%;" /></p><h3 id="文献目录"><a href="#文献目录" class="headerlink" title="文献目录"></a>文献目录</h3><p>导入文献后常常需要对文献进行分类.</p><p>创建好一个Library后默认会有一个Group Set,这个是删除不掉的.我一般在这个set里创建group</p><p>然后将文献添加到group中.</p><p><img data-src="http://cdn.sekyoro.top/imgs/02/0420230402203123.png" alt="image-20230402203122928" style="zoom:50%;" /></p><h3 id="添加笔记"><a href="#添加笔记" class="headerlink" title="添加笔记"></a>添加笔记</h3><p>右键点击文献,选择Edit Reference,点击Summary,选择Attach file链接笔记文件即可.</p><p><img data-src="http://cdn.sekyoro.top/imgs/02/0420230402204815.png" alt="image-20230402204815649" style="zoom:50%;" /></p><p>同时添加pdf也是类似.</p><h3 id="设置参考文献格式"><a href="#设置参考文献格式" class="headerlink" title="设置参考文献格式"></a>设置参考文献格式</h3><p><img data-src="http://cdn.sekyoro.top/imgs/02/0420230402204250.png" alt="image-20230402204250594" style="zoom:50%;" /></p><p>插入论文的文献格式设置,可以去<a href="https://www.endnote.com/">https://www.EndNote.com/</a> 下载想要的格式</p><h3 id="本地迁移"><a href="#本地迁移" class="headerlink" title="本地迁移"></a>本地迁移</h3><p>使用压缩功能把当前文献库报错,如果需要迁移到另一个电脑,选择上方菜单栏中的【File】-【Compress Library.enlx】</p><p><img data-src="http://cdn.sekyoro.top/imgs/02/0420230402205005.png" alt="image-20230402205005519" style="zoom:50%;" /></p><p>如果双击打开这个压缩文件，会自动生成一个文件「测试.enl」和一个文件夹「测试.Data」，这样又会自动还原为正常的数据库文件。</p><h3 id="与Word一起使用"><a href="#与Word一起使用" class="headerlink" title="与Word一起使用"></a>与Word一起使用</h3><p>在下载时记得勾选与Word联动,如果忘了可以查看下载目录</p><p><img data-src="http://cdn.sekyoro.top/imgs/02/0420230402205432.png" alt="image-20230402205432273"></p><p>点击这个config endnote.exe进行设置.</p><p>配置后Word中就有相关选项</p><p><img data-src="http://cdn.sekyoro.top/imgs/02/0420230402210145.png" alt="image-20230402210145730"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/110516363">还不会EndNote？超详细教程来了！ - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/65652207">[EndNote]导入PubMed数据库文献方法 - 知乎 (zhihu.com)</a></li><li><a href="https://www.cnblogs.com/vmware-com/p/12244995.html#:~:text=1，首先在电脑上打开word2019，点击左上角的“文件”菜单。 2，然后在打开的文件菜单中点击“选项”的快捷链接。,3，接下来在打开的Word选项窗口中点击左侧边栏的“加载项”的菜单项。 4，在右侧的窗口中点击com加载项后面的“转到”按钮。 5，接下来就会弹出COM加载项的窗口，在窗口中找到并勾选Endnote的选项。">如何将EndNote 和 Word (office)连接起来 - VMWARE_COM - 博客园 (cnblogs.com)</a></li><li><a href="https://www.jianshu.com/p/ffb7ee272457">Endnote20文献管理软件使用教程 - 简书 (jianshu.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前讲过使用Zotero管理并阅读文献,现在写论文的使用为了方便管理插入文献,这里使用EndNote管理.&lt;br&gt;</summary>
    
    
    
    
    <category term="paper" scheme="https://www.sekyoro.top/tags/paper/"/>
    
    <category term="thesis" scheme="https://www.sekyoro.top/tags/thesis/"/>
    
  </entry>
  
  <entry>
    <title>服务器结合OSS存储用于自动录播</title>
    <link href="https://www.sekyoro.top/2023/04/01/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%93%E5%90%88OSS%E5%AD%98%E5%82%A8%E7%94%A8%E4%BA%8E%E8%87%AA%E5%8A%A8%E5%BD%95%E6%92%AD/"/>
    <id>https://www.sekyoro.top/2023/04/01/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%93%E5%90%88OSS%E5%AD%98%E5%82%A8%E7%94%A8%E4%BA%8E%E8%87%AA%E5%8A%A8%E5%BD%95%E6%92%AD/</id>
    <published>2023-04-01T05:19:46.000Z</published>
    <updated>2023-04-16T09:24:04.851Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>搭建一个自动录播平台,录播的内容存储到云盘中.使用B站录播姬+OSS对象存储+服务器<br><span id="more"></span><br>之前买过一台廉价的服务器,只有40G的云盘存储,再想增加存储加个40G的云盘</p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401132610.png" alt="image-20230401132603630"></p><p>看见价格还是算了,所以考虑使用OSS对象存储.</p><p>1、对象存储一般可以单独使用，无需跟云主机进行组合搭配，而云硬盘则必须跟云主机同时使用，无法单独使用。</p><p>2、对象存储是可以共享的，而云硬盘一般无法共享，即便可以共享，操作起来也是非常复杂。</p><p>3、两者最大的差别在于一个是本地局域网内的存储方式，而另一个是使用云端服务器。简单来说一个是局域网，一个是公网；一个是存储设备，一个就是一个云端硬盘。</p><p>所以选择OSS存储.</p><h2 id="购买OSS对象存储"><a href="#购买OSS对象存储" class="headerlink" title="购买OSS对象存储"></a>购买OSS对象存储</h2><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401132832.png" alt="image-20230401132831841" style="zoom:50%;" /></p><p>创建bucket,这个地域选择与OSS对象存储一样的区域.</p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401134520.png" alt="image-20230401134520599" style="zoom:50%;" /></p><p>接下来尝试将OSS的bucket作为服务器的文件系统,也就是bucket在服务器上访问.</p><blockquote><p>OSS以目录的方式挂载到ECS实例，可通过以下两种方法进行实现：</p><ul><li>通过配置云存储网关来实现，详情请参见<a href="https://help.aliyun.com/document_detail/134092.htm?spm=a2c4g.11186623.0.0.740f1e4f2KpgFK">通过云存储网关挂载OSS</a>。</li><li>如没有云存储网关，您也可通过ossfs命令行的方式，将存储空间下的某个文件目录挂载到本地文件系统。详情请参见以下方案：<ul><li><a href="https://help.aliyun.com/document_detail/153893.htm?spm=a2c4g.11186623.0.0.740f1e4f2KpgFK">使用ossfs挂载指定文件目录</a></li><li><a href="https://help.aliyun.com/document_detail/39524.htm">ossfs如何通过非root用户挂载Bucket到ECS实例</a></li></ul></li></ul></blockquote><p>第一种方法的前提条件,要求ECS的地域与OSS同地域,<del>这里不满足所以采用第二种方法</del>后面发现如果想让服务器跟OSS存储联动,最好还是选择同地域的,因为我发现我服务器在国内,OSS放在新加坡,内网是ping不通的.下面两种方法都介绍一下,推荐使用云存储网关.</p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401135037.png" alt="image-20230401135037647"></p><h2 id="挂载对象存储到服务器"><a href="#挂载对象存储到服务器" class="headerlink" title="挂载对象存储到服务器"></a>挂载对象存储到服务器</h2><p><strong>使用ossfs挂载</strong></p><h3 id="安装ossfs"><a href="#安装ossfs" class="headerlink" title="安装ossfs"></a>安装ossfs</h3><p>首先在阿里云上查看你的操作系统,这里以Centos8.0为标准</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget http://gosspublic.alicdn.com/ossfs/ossfs_1.80.7_centos8.0_x86_64.rpm</span><br></pre></td></tr></table></figure><p>安装后下载</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install ossfs_1.80.7_centos8.0_x86_64.rpm</span><br></pre></td></tr></table></figure><h3 id="配置账号信息"><a href="#配置账号信息" class="headerlink" title="配置账号信息"></a>配置账号信息</h3><blockquote><p>通过ossfs访问OSS存储空间时，需要配置账号信息，也就是AccessKey ID和AccessKey Secret。这些账号信息需要按照特定的格式写到账号配置文件中。当挂载ossfs时，会从这个账号配置文件上获取账号信息，格式为<code>$bucket_name:$access_key_id:$access_key_secret</code>。</p></blockquote><p>access key可以使用<strong>RAM用户</strong>或者阿里云账号.我之前创建了<strong>阿里云账号的AccessKey</strong>,由于阿里提醒说有安全问题让我用RAM用户,这里就再创建一个用户使用AccessKey.</p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401141144.png" alt="image-20230401141143831" style="zoom:50%;" /></p><p>如果使用RAM角色访问,需要先创建角色</p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401150541.png" alt="image-20230401150541565" style="zoom:50%;" /></p><p><strong>创建角色</strong></p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401150651.png" alt="image-20230401150651605" style="zoom:50%;" /></p><p><strong>然后为角色添加权限</strong></p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401150816.png" alt="image-20230401150815904" style="zoom:50%;" /></p><p><strong>为实例添加角色</strong></p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401150907.png" alt="image-20230401150907529" style="zoom:50%;" /></p><blockquote><p>通过ossfs访问OSS存储空间时，需要配置账号信息，也就是AccessKey ID和AccessKey Secret。这些账号信息需要按照特定的格式写到账号配置文件中。当挂载ossfs时，会从这个账号配置文件上获取账号信息，格式为<code>$bucket_name:$access_key_id:$access_key_secret</code></p></blockquote><p>完成上述要求后需要配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ossfs bucket1 /tmp/ossfs -ourl=http://oss-cn-hangzhou.aliyuncs.com -oram_role=http://100.100.100.200/latest/meta-data/ram/security-credentials/EcsRamRoleOssTest</span><br></pre></td></tr></table></figure><p>命令类似.也就是将账号信息配置到一个目录中,默认账号配置文件的默认路径为/etc/passwd-ossfs.账号配置文件的默认路径为/etc/passwd-ossfs</p><p>如果使用阿里云账户的AccessKey</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> bucket-test-1:AAAIbZcdVCmQ****:AAA8x0y9hxQ31coh7A5e2MZEUz**** &gt; /etc/passwd-ossfs</span><br></pre></td></tr></table></figure><p>配置好后进行挂载,bucket的内网测试是能ping通的.</p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401152415.png" alt="image-20230401152412179"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ossfs bili-record /home/files/bili-record -ourl=http://oss-ap-southeast-1-internal.aliyuncs.com</span><br></pre></td></tr></table></figure><p>这里是内网访问</p><p><strong>卸载</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fusermount -u /tmp/ossfs</span><br></pre></td></tr></table></figure><h3 id="通过云存储网关挂载"><a href="#通过云存储网关挂载" class="headerlink" title="通过云存储网关挂载"></a>通过云存储网关挂载</h3><p><a href="https://help.aliyun.com/document_detail/134092.htm?spm=a2c4g.11186623.0.0.740f36b5JO1KZv">通过云存储网关挂载OSS (aliyun.com)</a></p><p>还需要付费</p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401152902.png" alt="image-20230401152901650" style="zoom:50%;" /></p><h3 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h3><ol><li><p>在centos系统中,在/etc/init.d/目录下建立文件ossfs,内容为挂载指令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ossfs bili-record /home/files/bili-record -ourl=http://oss-ap-southeast-1-internal.aliyuncs.com</span><br></pre></td></tr></table></figure></li></ol><p>2.赋予可执行权限</p>   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x /etc/init.d/ossfs</span><br></pre></td></tr></table></figure><p>3.把ossfs启动脚本作为其他服务，开机自动启动：</p>   <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig ossfs <span class="keyword">on</span></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在网站上上传文件,然后查看服务器</p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401155033.png" alt="image-20230401155032846" style="zoom:50%;" /></p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401155048.png" alt="image-20230401155048241" style="zoom:67%;" /></p><h2 id="增加域名管理"><a href="#增加域名管理" class="headerlink" title="增加域名管理"></a>增加域名管理</h2><blockquote><p>文件（Object）上传至存储空间（Bucket）后，OSS会自动生成文件URL，您可以直接通过文件URL（即Bucket外网访问域名）访问该文件。若您希望通过自定义域名（自有域名）访问这些文件，需要将自定义域名绑定至文件所在的Bucket。</p><p>域名信息更新需 1 分钟左右的时间，CD</p></blockquote><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401155607.png" alt="image-20230401155607206" style="zoom:50%;" /></p><p>在域名服务商配置即可,这里不详细说了.</p><h2 id="使用B站录播姬"><a href="#使用B站录播姬" class="headerlink" title="使用B站录播姬"></a>使用B站录播姬</h2><p><a href="https://rec.danmuji.org/">B站录播姬 (danmuji.org)</a>官网</p><p>我这里使用docker版本,首先拉取镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull bililive/recorder:latest</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制粘贴运行之前记得修改  &quot;宿主机路径&quot;</span></span><br><span class="line">docker run -d -v 宿主机路径:/rec -p 2356:2356 bililive/recorder</span><br></pre></td></tr></table></figure><ol><li><code>/rec</code> ：作为 <code>&quot;工作目录&quot;</code> ，用于存储录播配置和录播 <code>.flv</code> 视频文件。</li><li><code>/ssl</code> ：作为 Nginx 证书存储目录。</li><li><code>/file</code> ：官方文档中指出：</li></ol><p>由于安全问题,这里增加HTTP Basic登录功能</p><p><strong>配置文件</strong></p><p><a href="https://rec.danmuji.org/user/settings/">设置项 - B站录播姬 (danmuji.org)</a></p><p>由于配置文件json还挺麻烦,由于有web ui,可以开放端口直接配置搭配文档编写.</p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401172201.png" alt="image-20230401172201099" style="zoom:67%;" /></p><p>比如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;version&quot;</span>:<span class="number">3</span>,<span class="attr">&quot;global&quot;</span>:&#123;&#125;,<span class="attr">&quot;rooms&quot;</span>:[&#123;<span class="attr">&quot;RoomId&quot;</span>:&#123;<span class="attr">&quot;HasValue&quot;</span>:<span class="literal">true</span>,<span class="attr">&quot;Value&quot;</span>:<span class="string">&quot;房间号&quot;</span>&#125;,<span class="attr">&quot;AutoRecord&quot;</span>:&#123;<span class="attr">&quot;HasValue&quot;</span>:<span class="literal">true</span>,<span class="attr">&quot;Value&quot;</span>:<span class="literal">true</span>&#125;&#125;]&#125;</span><br></pre></td></tr></table></figure><h4 id="更新录播姬"><a href="#更新录播姬" class="headerlink" title="更新录播姬"></a>更新录播姬</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取最新版本的镜像</span></span><br><span class="line"><span class="comment"># 参考本页面上面的拉取镜像部分</span></span><br><span class="line">docker pull bililive/recorder:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止运行并删除</span></span><br><span class="line">docker stop &lt;旧容器ID&gt;</span><br><span class="line">docker rm &lt;旧容器ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新新建容器运行</span></span><br><span class="line"><span class="comment"># 参考本页面上面的运行录播姬部分</span></span><br><span class="line">docker run -d -v 宿主机路径:/rec -p 2356:2356 bililive/recorder:latest</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://rec.danmuji.org/user/install/docker/">Docker 镜像 - 安装使用 - B站录播姬 (danmuji.org)</a></li><li><a href="https://www.bilibili.com/read/cv15242801">基于云服务器以及OSS存储打造属于自己的自动录播姬 - 哔哩哔哩 (bilibili.com)</a></li><li><a href="https://help.aliyun.com/document_detail/405812.html">OSS如何以目录的方式挂载到ECS实例 (aliyun.com)</a></li><li><a href="https://www.bilibili.com/read/cv15242801">阿里云OSS通过服务器ESC内网流量访问文件</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;搭建一个自动录播平台,录播的内容存储到云盘中.使用B站录播姬+OSS对象存储+服务器&lt;br&gt;</summary>
    
    
    
    
    <category term="OSS存储" scheme="https://www.sekyoro.top/tags/OSS%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>实战写浏览器插件</title>
    <link href="https://www.sekyoro.top/2023/03/23/%E5%AE%9E%E6%88%98%E5%86%99%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    <id>https://www.sekyoro.top/2023/03/23/%E5%AE%9E%E6%88%98%E5%86%99%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/</id>
    <published>2023-03-23T13:40:04.000Z</published>
    <updated>2023-03-26T07:13:44.237Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>写一些浏览器脚本或者插件方便平时的自动化操作.<br>油猴脚本编写不难,但考虑到浏览器插件可能涉及功能多同时并不是所有人会去安装一个类似油猴的插件,所以这里选择开发插件</p><span id="more"></span><p>现在Edge浏览器和Chrome浏览器都差不太多,需要修改一些API即可进行移植,这里选择Chrome浏览器,因为谷歌官方教程写得更详细一些.</p><p>如果要从谷歌浏览器插件迁移到Edge,也只需要修改一些不支持的API即可</p><p>Microsoft Edge 不支持以下扩展 API：</p><ul><li><code>chrome.gcm</code>.</li><li><code>chrome.identity.getAccounts</code>.</li><li><code>chrome.identity.getAuthToken</code> - 作为替代项，可以使用 <code>launchWebAuthFlow</code> 提取 OAuth2 令牌来对用户进行身份验证。</li><li><code>chrome.instanceID</code>.</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://learn.microsoft.com/zh-cn/microsoft-edge/extensions-chromium/getting-started/part1-simple-extension?tabs=v3">创建扩展教程，第 1 部分 - Microsoft Edge Development | Microsoft Learn</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;写一些浏览器脚本或者插件方便平时的自动化操作.&lt;br&gt;油猴脚本编写不难,但考虑到浏览器插件可能涉及功能多同时并不是所有人会去安装一个类似油猴的插件,所以这里选择开发插件&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://www.sekyoro.top/tags/JavaScript/"/>
    
    <category term="油猴脚本" scheme="https://www.sekyoro.top/tags/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>vscode+latex本地搭建tex写论文</title>
    <link href="https://www.sekyoro.top/2023/03/22/vscode-latex%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAtex%E5%86%99%E8%AE%BA%E6%96%87/"/>
    <id>https://www.sekyoro.top/2023/03/22/vscode-latex%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAtex%E5%86%99%E8%AE%BA%E6%96%87/</id>
    <published>2023-03-22T08:14:39.000Z</published>
    <updated>2023-03-22T09:13:30.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>如果是为了方便简洁,实际使用<a href="https://www.overleaf.com/">Overleaf</a>完全够了,之前也写过使用Obsidian写文章的教程. 这次主要介绍使用在本地vscode加上插件写论文.<br><span id="more"></span></p><h2 id="需要工具"><a href="#需要工具" class="headerlink" title="需要工具"></a>需要工具</h2><ol><li><strong>vscode</strong> 官网即可</li><li><strong>texlive</strong> 通过镜像站即可,比如<a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/">Index of /CTAN/systems/texlive/Images/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></li></ol><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322162307.png" alt="image-20230322162300639" style="zoom:67%;" /></p><p>选中箭头指向的其中一个即可,然后一步一步来即可.可以参考相关教程<a href="https://zhuanlan.zhihu.com/p/493412905">TeX Live 2022 安装指南【安装 LaTeX】</a>. 安装TexLive目的就是为了有个解析引擎,类似与c++程序下载g++一样</p><ol><li><a href="https://www.sumatrapdfreader.org/free-pdf-reader">Sumatra PDF (sumatrapdfreader.org)</a>  用于查看pdf,当然用其他的也可以.这是一个开源免费的pdf阅读器,用于查看tex编译后得到的pdf,并且设置反向搜索(即双击pdf的某个位置可以跳转到tex代码相应的位置)</li></ol><h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><p><strong>下载texlive之后</strong>,进行测试是否安装成功. 在命令行输入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tex</span><br></pre></td></tr></table></figure><p>显示</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322163046.png" alt="image-20230322163046678"></p><p>表示安装成功.</p><p><strong>在vscode中</strong>下载插件Latex Workshop,用于有效地编译预览tex文件.</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322162850.png" alt="image-20230322162849810" style="zoom:50%;" /></p><p>当然你也可以同时下载其他用于自动补全tex的插件.然后进行配置.</p><p>如果你还不了解tex相关的一类东西,可以在文章末尾<strong>参考资料</strong>中查看Tex家族.</p><h4 id="简单实用"><a href="#简单实用" class="headerlink" title="简单实用"></a>简单实用</h4><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322163519.png" alt="image-20230322163519674"></p><p>下载了插件后,你会注意到左部有这个插件标识,点击即可. 发现上面有相关命令.有编译,查看pdf,导向等等. 我们常用的就是构建,值得注意的是我们构建就是利用工具设置工具链进行一套编译流程.</p><p>现在你就可以写tex然后点击 <code>pdflatex-&gt;bibtex-&gt;pdflatex*2</code>即可得到pdf</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322163846.png" alt="image-20230322163846157"></p><p>但是你会发现使用中文会报错,所以接下来我们会进行相关配置.</p><blockquote><ul><li>TeX：1978年由Donald Erwin Knuth（高德纳）开发。是后来大部分TeX相关的基础。其生成dvi文件，然后经由其他程序转换为pdf文件。</li><li>pdfTeX：Tex语言的又一个实现，将TeX代码直接编译成PDF文件。</li><li>XeTeX：TeX 语言的新的实现，支持 Unicode 编码和直接访问操作系统字体。</li><li>LuaTeX：TeX 语言的一个完整的有扩展的实现。LuaTeX支持Unicode、系统字体和内嵌语言扩展，能直接输出PDF格式文件，也可以仍然输出 DVI 格式。</li></ul></blockquote><p>我们需要增加xelatex工具.首先在设置中搜索<code>tools</code></p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322164243.png" alt="image-20230322164243143" style="zoom:50%;" /></p><p>点击setting.json配置，增加xelatex,代码如下.即数组中的第一项.</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322164343.png" alt="image-20230322164343493" style="zoom:67%;" /></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;-synctex=1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-interaction=nonstopmode&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-file-line-error&quot;</span>,</span><br><span class="line">        <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上相当于增加了一个tool.</p><p>现在需要增加一个recipe,相当于一套流程,这个流程需要用到xelatex.</p><p>设置中搜索recipe</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322164525.png" alt="image-20230322164525817"></p><p>点击setting.json,增加红框的代码</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322164546.png" alt="image-20230322164546431" style="zoom:50%;" /></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tools&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">    ],</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xelatex ➞ bibtex ➞ xelatex × 2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tools&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;bibtex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在你可以看见增加的recipe了,如红箭头所示. 现在支持tex中有中文了.</p><p>注意需要使用ctex包</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125;</span><br></pre></td></tr></table></figure><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322164634.png" alt="image-20230322164634064"></p><h3 id="实现正反向搜索"><a href="#实现正反向搜索" class="headerlink" title="实现正反向搜索"></a>实现正反向搜索</h3><p>这里使用sumatra作为external的pdf阅读器并实现双向搜索.</p><p>设置中搜索viewer.</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322165018.png" alt="image-20230322165018028" style="zoom: 67%;" /></p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322165037.png" alt="image-20230322165036922" style="zoom:67%;" /></p><p>设置external同时设置sumatra安装路径.</p><h4 id="正向搜索"><a href="#正向搜索" class="headerlink" title="正向搜索"></a>正向搜索</h4><p>在设置中搜索 viewer,看到下图参数设置.</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322165147.png" alt="image-20230322165147100" style="zoom:67%;" /></p><p>注意,这里可以先尝试随便添加项,然后在setting.json中查找这个配置.</p><p>将这个参数修改如下,注意其中的逆向搜索路径(这里是<code>&quot;D:/Microsoft VS Code/Code.exe\&quot; \&quot;D:/Microsoft VS Code/resources/app/out/cli.js\&quot; -r -g \&quot;%f:%l\&quot;</code>)表示vscode相关下载位置,注意使用自己安装vscode的相关位置.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;latex-workshop.view.pdf.external.viewer.args&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;-forward-search&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%TEX%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%LINE%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-reuse-instance&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-inverse-search&quot;</span>,</span><br><span class="line">    <span class="string">&quot;\&quot;D:/Microsoft VS Code/Code.exe\&quot; \&quot;D:/Microsoft VS Code/resources/app/out/cli.js\&quot; -r -g \&quot;%f:%l\&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%PDF%&quot;</span>,</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><p>然后就配置成功了(事实上并没有完全成功,具体可以看下面的<a href="#attention">注意</a>).</p><p>正向搜索方法:平时选择其中之一即可</p><ol><li><p><img data-src="http://cdn.sekyoro.top/imgs/22/03image-20230322165523694.png" alt="image-20230322165523694"></p></li><li><p>按下<code>Ctrl+Alt+J</code>，直接跳转至PDF对应的地方。</p></li><li><p>点击<strong>View LaTeX PDF -&gt; View in external viewer</strong>。</p></li></ol><h4 id="逆向搜索"><a href="#逆向搜索" class="headerlink" title="逆向搜索"></a>逆向搜索</h4><p>设置中搜索Synctex,配置参数和命令. 跟上面的其实类似. </p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322165700.png" alt="image-20230322165659967" style="zoom:80%;" /></p><p><code>latex-workshop.view.pdf.external.synctex.args</code>参数配置如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;-forward-search&quot;</span>,</span><br><span class="line">   <span class="string">&quot;%TEX%&quot;</span>,</span><br><span class="line">   <span class="string">&quot;%LINE%&quot;</span>,</span><br><span class="line">   <span class="string">&quot;-reuse-instance&quot;</span>,</span><br><span class="line">   <span class="string">&quot;-inverse-search&quot;</span>,</span><br><span class="line">   <span class="string">&quot;\&quot;D:/Microsoft VS Code/Code.exe\&quot; \&quot;D:/Microsoft VS Code/resources/app/out/cli.js\&quot; -r -g \&quot;%f:%l\&quot;&quot;</span>,</span><br><span class="line">   <span class="string">&quot;%PDF%&quot;</span>,</span><br></pre></td></tr></table></figure><p>上面的路径也是根据你下载vscode的路径配置.</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><a id="attention">注意</a></h3><p>事实上要实现在sumatra中反向搜索,你还需要进行其他配置. 打开sumatra,点击左上角选择<strong>高级选项</strong>.</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322170018.png" alt="image-20230322170018604" style="zoom:67%;" /></p><p>搜索<code>InverseSearchCmdLine</code> 可以发现这里的值应该已经被设置了.后面发现,按照上述设置在vscode中打开sumatra后会将这里的参数设置会vscode中配置的,但是现在需要更改一下.</p><p>在vscode配置中,逆向搜索增加<code>--ms-enable-electron-run-as-node</code>参数.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;latex-workshop.view.pdf.external.viewer.args&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;-forward-search&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%TEX%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%LINE%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-reuse-instance&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-inverse-search&quot;</span>,</span><br><span class="line">    <span class="string">&quot;\&quot;D:/Microsoft VS Code/Code.exe\&quot; \&quot;D:/Microsoft VS Code/resources/app/out/cli.js\&quot; --ms-enable-electron-run-as-node -r -g \&quot;%f:%l\&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%PDF%&quot;</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;latex-workshop.view.pdf.external.synctex.command&quot;</span>: <span class="string">&quot;D:\\SumatraPDF\\SumatraPDF.exe&quot;</span>,</span><br><span class="line">  <span class="string">&quot;latex-workshop.view.pdf.external.synctex.args&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;-forward-search&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%TEX%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%LINE%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-reuse-instance&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-inverse-search&quot;</span>,</span><br><span class="line">    <span class="string">&quot;\&quot;D:/Microsoft VS Code/Code.exe\&quot; \&quot;D:/Microsoft VS Code/resources/app/out/cli.js\&quot; --ms-enable-electron-run-as-node -r -g \&quot;%f:%l\&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%PDF%&quot;</span>,</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><p>这样双击sumatra中的pdf即可跳转到vscode中的tex相应位置了.</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/273343930">在vscode中使用latex高效书写论文教程 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/144729565">学术论文写作利器—— VS Code + LaTeX - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/71432461">VS Code下配置LaTeX编译环境 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/434142338">VScode+Latex+SumatraPDF反向搜索失败解决办法（Version 1.63） - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/248669482">TeX 家族（TeX, XeTeX, LuaTeX,XeLaTeX …看完这篇就懂了） - 知乎 (zhihu.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果是为了方便简洁,实际使用&lt;a href=&quot;https://www.overleaf.com/&quot;&gt;Overleaf&lt;/a&gt;完全够了,之前也写过使用Obsidian写文章的教程. 这次主要介绍使用在本地vscode加上插件写论文.&lt;br&gt;</summary>
    
    
    
    <category term="latex" scheme="https://www.sekyoro.top/categories/latex/"/>
    
    
    <category term="latex" scheme="https://www.sekyoro.top/tags/latex/"/>
    
    <category term="vscode" scheme="https://www.sekyoro.top/tags/vscode/"/>
    
    <category term="sumatra" scheme="https://www.sekyoro.top/tags/sumatra/"/>
    
  </entry>
  
  <entry>
    <title>STL学习</title>
    <link href="https://www.sekyoro.top/2023/03/05/STL%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2023/03/05/STL%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-03-05T15:56:00.000Z</published>
    <updated>2023-03-05T15:57:32.116Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>刷算法时有必要使用一些stl.<br><span id="more"></span></p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h3><h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><p>初始化 通过如下创建 array 容器的方式，可以将所有的元素初始化为 0 或者和默认元素类型等效的值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="keyword">double</span>, 10&gt; values &#123;&#125;;</span><br></pre></td></tr></table></figure><p>array 容器是 <a href="http://c.biancheng.net/cplus/">C++</a> 11 标准中新增的序列容器，简单地理解，它就是在 C++ 普通数组的基础上，添加了一些成员函数和全局函数。在使用上，它比普通数组更安全，且效率并没有因此变差。</p><div class="table-container"><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的随机访问迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的随机访问迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素之前一个位置的随机访问迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>size()</td><td>返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。</td></tr><tr><td>max_size()</td><td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。</td></tr><tr><td>empty()</td><td>判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快。</td></tr><tr><td>at(n)</td><td>返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。</td></tr><tr><td>front()</td><td>返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。</td></tr><tr><td>back()</td><td>返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。</td></tr><tr><td>data()</td><td>返回一个指向容器首个元素的<a href="http://c.biancheng.net/c/80/">指针</a>。利用该指针，可实现复制容器中所有元素等类似功能。</td></tr><tr><td>fill(val)</td><td>将 val 这个值赋值给容器中的每个元素。</td></tr><tr><td>array1.swap(array2)</td><td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</td></tr></tbody></table></div><p>对于array相比一般的c数组,可以直接利用front,back获取前后引用,size函数获取个数,以及一般的容器迭代器等</p><p>同时还有at函数更加安全的获取array中的元素,但由于不能更改长度,实践中用的并不多</p><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><div class="table-container"><table><thead><tr><th>begin()</th><th>返回指向容器中第一个元素的迭代器。</th></tr></thead><tbody><tr><td>end()</td><td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>size()</td><td>返回实际元素个数。</td></tr><tr><td>max_size()</td><td>返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td></tr><tr><td>resize()</td><td>改变实际元素的个数。</td></tr><tr><td>capacity()</td><td>返回当前容量。</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td></tr><tr><td>reserve()</td><td>增加容器的容量。</td></tr><tr><td>shrink _to_fit()</td><td>将内存减少到等于当前元素实际所使用的大小。</td></tr><tr><td>operator[ ]</td><td>重载了 [ ] 运算符，可以向访问数组中元素那样，通过下标即可访问甚至修改 vector 容器中的元素。</td></tr><tr><td>at()</td><td>使用经过边界检查的索引访问元素。</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td></tr><tr><td>back()</td><td>返回最后一个元素的引用。</td></tr><tr><td>data()</td><td>返回指向容器中第一个元素的指针。</td></tr><tr><td>assign()</td><td>用新元素替换原有内容。</td></tr><tr><td>push_back()</td><td>在序列的尾部添加一个元素。</td></tr><tr><td>pop_back()</td><td>移出序列尾部的元素。</td></tr><tr><td>insert()</td><td>在指定的位置插入一个或多个元素。</td></tr><tr><td>erase()</td><td>移出一个元素或一段元素。</td></tr><tr><td>clear()</td><td>移出所有的元素，容器大小变为 0。</td></tr><tr><td>swap()</td><td>交换两个容器的所有元素。</td></tr><tr><td>emplace()</td><td>在指定的位置直接生成一个元素。</td></tr><tr><td>emplace_back()</td><td>在序列尾部生成一个元素。</td></tr></tbody></table></div><p>可以更改大小,在内存上是连续分布的.所以可以随机访问,跟一般的数组和array类似.  可以使用reserve函数调整大小,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values.<span class="built_in">reserve</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>这样就设置了容器的内存分配，即至少可以容纳 20 个元素。注意，如果 vector 的容量在执行此语句之前，已经大于或等于 20 个元素，那么这条语句什么也不做；另外，调用 reserve() 不会影响已存储的元素，也不会生成任何元素，即 values 容器内此时仍然没有任何元素.</p><p>同时使用emplace,emplace_back,erase等来增加或删除元素.</p><blockquote><p>emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p></blockquote><p>插入元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; demo&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">//第一种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">3</span>);<span class="comment">//&#123;1,3,2&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>);<span class="comment">//&#123;1,3,2,5,5&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种格式用法</span></span><br><span class="line">    std::array&lt;<span class="keyword">int</span>,3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>());<span class="comment">//&#123;1,3,2,5,5,7,8,9&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;);<span class="comment">//&#123;1,3,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; demo[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除元素</p><div class="table-container"><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>pop_back()</td><td>删除 vector 容器中最后一个元素，该容器的大小（size）会减 1，但容量（capacity）不会发生改变。</td></tr><tr><td>erase(pos)</td><td>删除 vector 容器中 pos 迭代器指定位置处的元素，并返回指向被删除元素下一个位置元素的迭代器。该容器的大小（size）会减 1，但容量（capacity）不会发生改变。</td></tr><tr><td>swap(beg)、pop_back()</td><td>先调用 swap() 函数交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back() 删除该目标元素。</td></tr><tr><td>erase(beg,end)</td><td>删除 vector 容器中位于迭代器 [beg,end)指定区域内的所有元素，并返回指向被删除区域下一个位置元素的迭代器。该容器的大小（size）会减小，但容量（capacity）不会发生改变。</td></tr><tr><td>remove()</td><td>删除容器中所有和指定元素值相等的元素，并返回指向最后一个元素下一个位置的迭代器。值得一提的是，调用该函数不会改变容器的大小和容量。</td></tr><tr><td>clear()</td><td>删除 vector 容器中所有的元素，使其变成空的 vector 容器。该函数会改变 vector 的大小（变为 0），但不是改变其容量。</td></tr></tbody></table></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">//删除 2、3</span></span><br><span class="line">    <span class="keyword">auto</span> iter = demo.<span class="built_in">erase</span>(demo.<span class="built_in">begin</span>()+<span class="number">1</span>, demo.<span class="built_in">end</span>() - <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size is :&quot;</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity is :&quot;</span> &lt;&lt; demo.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; demo[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用emplace,emplace_back,pop_back,erase对vector进行增删数据,使用at访问数据</p><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>deque 容器和 vecotr 容器有很多相似之处，比如：</p><ul><li>deque 容器也擅长在序列尾部添加或删除元素（时间复杂度为<code>O(1)</code>），而不擅长在序列中间添加或删除元素。</li><li>deque 容器也可以根据需要修改自身的容量和大小</li></ul><p>和 vector 不同的是，deque 还擅长在序列头部添加或删除元素，所耗费的时间复杂度也为常数阶<code>O(1)</code>。并且更重要的一点是，deque 容器中存储元素并不能保证所有元素都存储到连续的内存空间中。</p><blockquote><p>当需要向序列两端频繁的添加或删除元素时，应首选 deque 容器。</p></blockquote><p>和 vector 相比，额外增加了实现在容器头部添加和删除元素的成员函数比如emplace_front,pop_font，同时删除了 capacity()、reserve() 和 data() 成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化一个空deque容量</span></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt;d;</span><br><span class="line">    <span class="comment">//向d容器中的尾部依次添加 1，2,3</span></span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">2</span>); <span class="comment">//&#123;1,2&#125;</span></span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">3</span>); <span class="comment">//&#123;1,2,3&#125;</span></span><br><span class="line">    <span class="comment">//向d容器的头部添加 0 </span></span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">0</span>); <span class="comment">//&#123;0,1,2,3&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用 size() 成员函数输出该容器存储的字符个数。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素个数为：%d\n&quot;</span>, d.<span class="built_in">size</span>());</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//使用迭代器遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = d.<span class="built_in">begin</span>(); i &lt; d.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p><a href="http://c.biancheng.net/stl/">STL</a> list 容器，又称双向链表容器，即该容器的底层是以双向链表的形式实现的。这意味着，list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。</p><p>list 容器具有一些其它容器（array、vector 和 deque）所不具备的优势，即它可以在序列已知的任何位置快速插入或删除元素（时间复杂度为<code>O(1)</code>）。并且在 list 容器中移动元素，也比其它容器的效率高。</p><p>和之前的序列容器相比，list 容器迭代器最大的不同在于，其配备的迭代器类型为双向迭代器，而不再是随机访问迭代器。</p><div class="table-container"><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的双向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器中最后一个元素所在位置的下一个位置的双向迭代器。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的反向双向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的反向双向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td></tr><tr><td>size()</td><td>返回当前容器实际包含的元素个数。</td></tr><tr><td>max_size()</td><td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td></tr><tr><td>back()</td><td>返回最后一个元素的引用。</td></tr><tr><td>assign()</td><td>用新元素替换容器中原有内容。</td></tr><tr><td>emplace_front()</td><td>在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。</td></tr><tr><td>push_front()</td><td>在容器头部插入一个元素。</td></tr><tr><td>pop_front()</td><td>删除容器头部的一个元素。</td></tr><tr><td>emplace_back()</td><td>在容器尾部直接生成一个元素。该函数和 push_back() 的功能相同，但效率更高。</td></tr><tr><td>push_back()</td><td>在容器尾部插入一个元素。</td></tr><tr><td>pop_back()</td><td>删除容器尾部的一个元素。</td></tr><tr><td>emplace()</td><td>在容器中的指定位置插入元素。该函数和 insert() 功能相同，但效率更高。</td></tr><tr><td>insert()</td><td>在容器中的指定位置插入元素。</td></tr><tr><td>erase()</td><td>删除容器中一个或某区域内的元素。</td></tr><tr><td>swap()</td><td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。</td></tr><tr><td>resize()</td><td>调整容器的大小。</td></tr><tr><td>clear()</td><td>删除容器存储的所有元素。</td></tr><tr><td>splice()</td><td>将一个 list 容器中的元素插入到另一个容器的指定位置。</td></tr><tr><td>remove(val)</td><td>删除容器中所有等于 val 的元素。</td></tr><tr><td>remove_if()</td><td>删除容器中满足条件的元素。</td></tr><tr><td>unique()</td><td>删除容器中相邻的重复元素，只保留一个。</td></tr><tr><td>merge()</td><td>合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的。</td></tr><tr><td>sort()</td><td>通过更改容器中元素的位置，将它们进行排序。</td></tr><tr><td>reverse()</td><td>反转容器中元素的顺序。</td></tr></tbody></table></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空的 list 容器</span></span><br><span class="line">    std::list&lt;<span class="keyword">double</span>&gt; values;</span><br><span class="line">    <span class="comment">//向容器中添加元素</span></span><br><span class="line">    values.<span class="built_in">push_back</span>(<span class="number">3.1</span>);</span><br><span class="line">    values.<span class="built_in">push_back</span>(<span class="number">2.2</span>);</span><br><span class="line">    values.<span class="built_in">push_back</span>(<span class="number">2.9</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;values size：&quot;</span> &lt;&lt; values.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//对容器中的元素进行排序</span></span><br><span class="line">    values.<span class="built_in">sort</span>();</span><br><span class="line">    <span class="comment">//使用迭代器输出list容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (std::list&lt;<span class="keyword">double</span>&gt;::iterator it = values.<span class="built_in">begin</span>(); it != values.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::list&lt;<span class="keyword">int</span>&gt; values&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="comment">//第一种格式用法</span></span><br><span class="line">    values.<span class="built_in">insert</span>(values.<span class="built_in">begin</span>() , <span class="number">3</span>);<span class="comment">//&#123;3,1,2&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种格式用法</span></span><br><span class="line">    values.<span class="built_in">insert</span>(values.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>);<span class="comment">//&#123;3,1,2,5,5&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种格式用法</span></span><br><span class="line">    std::array&lt;<span class="keyword">int</span>, 3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    values.<span class="built_in">insert</span>(values.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>());<span class="comment">//&#123;3,1,2,5,5,7,8,9&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四种格式用法</span></span><br><span class="line">    values.<span class="built_in">insert</span>(values.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;);<span class="comment">//&#123;3,1,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = values.<span class="built_in">begin</span>(); p != values.<span class="built_in">end</span>(); ++p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h3><p>关联式容器在存储元素值的同时，会为各元素额外再配备一个值（又称为“键”，其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联式容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。</p><blockquote><p>弃用序列式容器，转而选用关联式容器存储元素，往往就是看中了关联式容器可以快速查找、读取或者删除所存储的元素，同时该类型容器插入元素的效率也比序列式容器高。</p></blockquote><p>也就是说，使用关联式容器存储的元素，都是一个一个的“键值对”（ <key,value> ），这是和序列式容器最大的不同。除此之外，序列式容器中存储的元素默认都是未经过排序的，而使用关联式容器存储的元素，默认会根据各元素的键值的大小做升序排序</p><div class="table-container"><table><thead><tr><th>关联式容器名称</th><th>特点</th></tr></thead><tbody><tr><td>map</td><td>定义在 <map> 头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根据各元素键的大小，默认进行升序排序（调用 std::less<T>）。</td></tr><tr><td>set</td><td>定义在 <set> 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个元素的键（其实也就是元素值）的大小进行升序排序（调用 std::less<T>）。</td></tr><tr><td>multimap</td><td>定义在 <map> 头文件中，和 map 容器唯一的不同在于，multimap 容器中存储元素的键可以重复。</td></tr><tr><td>multiset</td><td>定义在 <set> 头文件中，和 set 容器唯一的不同在于，multiset 容器中存储元素的值可以重复（一旦值重复，则意味着键也是重复的）。</td></tr></tbody></table></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span> <span class="comment">//使用 map 容器，必须引入该头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空的 map 关联式容器，该容器中存储的键值对，其中键为 string 字符串，值也为 string 字符串类型</span></span><br><span class="line">    map&lt;string, string&gt; mymap;</span><br><span class="line">    <span class="comment">//向 mymap 容器中添加数据</span></span><br><span class="line">    mymap[<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>] = <span class="string">&quot;C语言教程&quot;</span>;</span><br><span class="line">    mymap[<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>] = <span class="string">&quot;Python教程&quot;</span>;</span><br><span class="line">    mymap[<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>] = <span class="string">&quot;Java教程&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用 map 容器的迭代器，遍历 mymap 容器，并输出其中存储的各个键值对</span></span><br><span class="line">    <span class="keyword">for</span> (map&lt;string, string&gt;::iterator it = mymap.<span class="built_in">begin</span>(); it != mymap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="comment">//输出各个元素中的键和值</span></span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到“键值对”并不是普通类型数据，<a href="http://c.biancheng.net/cplus/">C++</a> <a href="http://c.biancheng.net/stl/">STL</a> 标准库提供了 pair 类模板，其专门用来将 2 个普通元素 first 和 second（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素<code>&lt;first, second&gt;</code>。通过其构成的元素格式不难看出，使用 pair 类模板来创建“键值对”形式的元素</p><p>pair 类模板定义在<code>&lt;utility&gt;</code>头文件中，所以在使用该类模板之前，需引入此头文件。另外值得一提的是，在 C++ 11 标准之前，pair 类模板中提供了以下 3 种构造函数：</p><h1 id="1-默认构造函数，即创建空的-pair-对象pair"><a href="#1-默认构造函数，即创建空的-pair-对象pair" class="headerlink" title="1) 默认构造函数，即创建空的 pair 对象pair();"></a>1) 默认构造函数，即创建空的 pair 对象pair();</h1><h1 id="2-直接使用-2-个元素初始化成-pair-对象pair-const-first-type-amp-a-const-second-type-amp-b"><a href="#2-直接使用-2-个元素初始化成-pair-对象pair-const-first-type-amp-a-const-second-type-amp-b" class="headerlink" title="2) 直接使用 2 个元素初始化成 pair 对象pair (const first_type&amp; a, const second_type&amp; b);"></a>2) 直接使用 2 个元素初始化成 pair 对象pair (const first_type&amp; a, const second_type&amp; b);</h1><h1 id="3-拷贝（复制）构造函数，即借助另一个-pair-对象，创建新的-pair-对象template-pair-const-pair-amp-pr"><a href="#3-拷贝（复制）构造函数，即借助另一个-pair-对象，创建新的-pair-对象template-pair-const-pair-amp-pr" class="headerlink" title="3) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象template pair (const pair&amp; pr);"></a>3) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象template<class U, class V> pair (const pair<U,V>&amp; pr);</h1><p>在 C++ 11 标准中，在引入<a href="http://c.biancheng.net/view/439.html">右值引用</a>的基础上，pair 类模板中又增添了如下 2 个构造函数：</p><h1 id="4-移动构造函数template-pair-pair-amp-amp-pr-5-使用右值引用参数，创建-pair-对象template-pair-U-amp-amp-a-V-amp-amp-b"><a href="#4-移动构造函数template-pair-pair-amp-amp-pr-5-使用右值引用参数，创建-pair-对象template-pair-U-amp-amp-a-V-amp-amp-b" class="headerlink" title="4) 移动构造函数template pair (pair&amp;&amp; pr);#5) 使用右值引用参数，创建 pair 对象template pair (U&amp;&amp; a, V&amp;&amp; b);"></a>4) 移动构造函数template<class U, class V> pair (pair<U,V>&amp;&amp; pr);#5) 使用右值引用参数，创建 pair 对象template<class U, class V> pair (U&amp;&amp; a, V&amp;&amp; b);</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span>      <span class="comment">// pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用构造函数 1，也就是默认构造函数</span></span><br><span class="line">    pair &lt;string, <span class="keyword">double</span>&gt; pair1;</span><br><span class="line">    <span class="comment">// 调用第 2 种构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair2</span>(<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);  </span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair3</span>(pair2);</span><br><span class="line">    <span class="comment">//调用移动构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair4</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;C++教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/cplus/&quot;</span>));</span><br><span class="line">    <span class="comment">// 调用第 5 种构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair5</span>(<span class="built_in">string</span>(<span class="string">&quot;Python教程&quot;</span>), <span class="built_in">string</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>));  </span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair1: &quot;</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair1.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair2: &quot;</span>&lt;&lt; pair2.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair2.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair3: &quot;</span> &lt;&lt; pair3.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair3.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair4: &quot;</span> &lt;&lt; pair4.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair4.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair5: &quot;</span> &lt;&lt; pair5.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair5.second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,<span class="keyword">int</span>&gt;myMap;</span><br><span class="line">   map&lt;string,<span class="keyword">int</span>&gt;mymap&#123;&#123;<span class="string">&quot;C语言&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;C++教程&quot;</span>,<span class="number">20</span>&#125;&#125;;</span><br><span class="line">   map&lt;string,string&gt;m&#123;<span class="built_in">make_pair</span>(<span class="string">&quot;hi&quot;</span>,<span class="string">&quot;hello&quot;</span>)&#125;;</span><br><span class="line">   map&lt;string,string&gt;copiedmap&#123;m&#125;;</span><br><span class="line"></span><br><span class="line">   map&lt;string,<span class="keyword">int</span>,greater&lt;string&gt; &gt;hismap;</span><br></pre></td></tr></table></figure><p>常用的成员函数是find,count</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>      <span class="comment">// map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建空 map 容器，默认根据个键值对中键的值，对键值对做降序排序</span></span><br><span class="line">    std::map&lt;std::string, std::string, std::greater&lt;std::string&gt;&gt;myMap;</span><br><span class="line">    <span class="comment">//调用 emplace() 方法，直接向 myMap 容器中指定位置构造新键值对</span></span><br><span class="line">    myMap.<span class="built_in">emplace</span>(<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">    myMap.<span class="built_in">emplace</span>(<span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    myMap.<span class="built_in">emplace</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    <span class="comment">//输出当前 myMap 容器存储键值对的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myMap size==&quot;</span> &lt;&lt; myMap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//判断当前 myMap 容器是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!myMap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">//借助 myMap 容器迭代器，将该容器的键值对逐个输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = myMap.<span class="built_in">begin</span>(); i != myMap.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">            cout &lt;&lt; i-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i-&gt;second &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string&gt; myset&#123;<span class="string">&quot;shit&quot;</span>&#125;;</span><br><span class="line">    set&lt;string&gt; set2&#123;</span><br><span class="line">        <span class="string">&quot;hi&quot;</span>,</span><br><span class="line">        <span class="string">&quot;hello&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">set&lt;string&gt; <span class="title">s1</span><span class="params">(set2)</span></span>;</span><br><span class="line">    s.<span class="built_in">emplace</span>(<span class="string">&quot;hi&quot;</span>);</span><br></pre></td></tr></table></figure><p>删除元素 erase</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 set 容器</span></span><br><span class="line">    std::set&lt;<span class="keyword">int</span>&gt;myset&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//1) 调用第一种格式的 erase() 方法</span></span><br><span class="line">    <span class="keyword">int</span> num = myset.<span class="built_in">erase</span>(<span class="number">2</span>); <span class="comment">//删除元素 2，myset=&#123;1,3,4,5&#125;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2) 调用第二种格式的 erase() 方法</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt;::iterator iter = myset.<span class="built_in">erase</span>(myset.<span class="built_in">begin</span>()); <span class="comment">//删除元素 1，myset=&#123;3,4,5&#125;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter-&gt;&quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3) 调用第三种格式的 erase() 方法</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt;::iterator iter2 = myset.<span class="built_in">erase</span>(myset.<span class="built_in">begin</span>(), --myset.<span class="built_in">end</span>());<span class="comment">//删除元素 3,4，myset=&#123;5&#125;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter2-&gt;&quot;</span> &lt;&lt; *iter2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset;</span><br><span class="line">    <span class="comment">//空set容器不存储任何元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//向myset容器中插入新元素</span></span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//利用双向迭代器，遍历myset</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myset.<span class="built_in">begin</span>(); iter != myset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th>介绍</th></tr></thead><tbody><tr><td style="text-align:left">upper_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td style="text-align:left">equal_range(val)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。</td></tr><tr><td style="text-align:left">lower_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr></tbody></table></div><p>注意count,find等新的成员函数</p><p>此外关联式容器还有multimap和multiset,这里不介绍了.</p><h4 id="无序关联式容器"><a href="#无序关联式容器" class="headerlink" title="无序关联式容器"></a>无序关联式容器</h4><p>和关联式容器一样，无序容器也使用键值对（pair 类型）的方式存储数据。不过，它们有本质上的不同：</p><ul><li>关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构；</li><li>无序容器的底层实现采用的是哈希表的存储结构。</li></ul><div class="table-container"><table><thead><tr><th>无序容器</th><th>功能</th></tr></thead><tbody><tr><td>unordered_map</td><td>存储键值对 <key, value> 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。</td></tr><tr><td>unordered_multimap</td><td>和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。</td></tr><tr><td>unordered_set</td><td>不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。</td></tr><tr><td>unordered_multiset</td></tr></tbody></table></div><p>总的来说，实际场景中如果涉及大量遍历容器的操作，建议首选关联式容器；反之，如果更多的操作是通过键获取对应的值，则应首选无序容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化一个 unordered_map 容器，其存储的 &lt;string,string&gt; 类型的键值对</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; my_uMap&#123;</span><br><span class="line">        &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Python教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//查找指定键对应的值，效率比关联式容器高</span></span><br><span class="line">    string str = my_uMap.<span class="built_in">at</span>(<span class="string">&quot;C语言教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用迭代器遍历哈希容器，效率不如关联式容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = my_uMap.<span class="built_in">begin</span>(); iter != my_uMap.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//pair 类型键值对分为 2 部分</span></span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器是cpp STL库的概念,要访问顺序容器和关联容器中的元素，需要通过“迭代器（iterator）”进行。迭代器是一个变量，相当于容器</p><p>和操纵容器的算法之间的中介。迭代器可以指向容器中的某个元素，通过迭代器就可以读写它指向的元素。从这一点上看，迭代器和<a href="http://c.biancheng.net/c/80/">指针</a>类似.</p><p>通过迭代器可以读取它指向的元素，<code>*迭代器名</code>就表示迭代器指向的元素。通过非常量迭代器还能修改其指向的元素。</p><p>迭代器都可以进行<code>++</code>操作。反向迭代器和正向迭代器的区别在于：</p><ul><li>对正向迭代器进行<code>++</code>操作时，迭代器会指向容器中的后一个元素；</li><li>而对反向迭代器进行<code>++</code>操作时，迭代器会指向容器中的前一个元素</li></ul><h3 id="迭代器的分类"><a href="#迭代器的分类" class="headerlink" title="迭代器的分类"></a>迭代器的分类</h3><p>常用的迭代器按功能强弱分为输入、输出、正向、双向、随机访问五种，这里只介绍常用的三种。</p><p>1) 正向迭代器。假设 p 是一个正向迭代器，则 p 支持以下操作：++p，p++，*p。此外，两个正向迭代器可以互相赋值，还可以用<code>==</code>和<code>!=</code>运算符进行比较。</p><p>2) 双向迭代器。双向迭代器具有正向迭代器的全部功能。除此之外，若 p 是一个双向迭代器，则<code>--p</code>和<code>p--</code>都是有定义的。<code>--p</code>使得 p 朝和<code>++p</code>相反的方向移动。</p><p>3) 随机访问迭代器。随机访问迭代器具有双向迭代器的全部功能。若 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p><ul><li>p+=i：使得 p 往后移动 i 个元素。</li><li>p-=i：使得 p 往前移动 i 个元素。</li><li>p+i：返回 p 后面第 i 个元素的迭代器。</li><li>p-i：返回 p 前面第 i 个元素的迭代器。</li><li>p[i]：返回 p 后面第 i 个元素的引用</li></ul><div class="table-container"><table><thead><tr><th>容器</th><th>迭代器功能</th></tr></thead><tbody><tr><td>vector</td><td>随机访问</td></tr><tr><td>deque</td><td>随机访问</td></tr><tr><td>list</td><td>双向</td></tr><tr><td>set / multiset</td><td>双向</td></tr><tr><td>map / multimap</td><td>双向</td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr><tr><td>priority_queue</td><td>不支持迭代器</td></tr></tbody></table></div><h2 id="迭代器的辅助函数"><a href="#迭代器的辅助函数" class="headerlink" title="迭代器的辅助函数"></a>迭代器的辅助函数</h2><p>STL 中有用于操作迭代器的三个函数模板，它们是：</p><ul><li>advance(p, n)：使迭代器 p 向前或向后移动 n 个元素。</li><li>dis<a href="http://c.biancheng.net/ref/tan.html">tan</a>ce(p, q)：计算两个迭代器之间的距离，即迭代器 p 经过多少次 + + 操作后和迭代器 q 相等。如果调用时 p 已经指向 q 的后面，则这个函数会陷入死循环。</li><li>iter_swap(p, q)：用于交换两个迭代器 p、q 指向的值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span> <span class="comment">//要使用操作迭代器的函数模板，需要包含此文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    list &lt;<span class="keyword">int</span>&gt; <span class="built_in">lst</span>(a, a+<span class="number">5</span>);</span><br><span class="line">    list &lt;<span class="keyword">int</span>&gt;::iterator p = lst.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">advance</span>(p, <span class="number">2</span>);  <span class="comment">//p向后移动两个元素，指向3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1)&quot;</span> &lt;&lt; *p &lt;&lt; endl;  <span class="comment">//输出 1)3</span></span><br><span class="line">    <span class="built_in">advance</span>(p, <span class="number">-1</span>);  <span class="comment">//p向前移动一个元素，指向2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2)&quot;</span> &lt;&lt; *p &lt;&lt; endl;  <span class="comment">//输出 2)2</span></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt;::iterator q = lst.<span class="built_in">end</span>();</span><br><span class="line">    q--;  <span class="comment">//q 指向 5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3)&quot;</span> &lt;&lt; <span class="built_in">distance</span>(p, q) &lt;&lt; endl;  <span class="comment">//输出 3)3</span></span><br><span class="line">    <span class="built_in">iter_swap</span>(p, q); <span class="comment">//交换 2 和 5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;4)&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = lst.<span class="built_in">begin</span>(); p != lst.<span class="built_in">end</span>(); ++p)</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;刷算法时有必要使用一些stl.&lt;br&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://www.sekyoro.top/tags/cpp/"/>
    
    <category term="stl" scheme="https://www.sekyoro.top/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>浏览器CORS和CSP介绍</title>
    <link href="https://www.sekyoro.top/2023/03/04/%E6%B5%8F%E8%A7%88%E5%99%A8CORS%E5%92%8CCSP%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.sekyoro.top/2023/03/04/%E6%B5%8F%E8%A7%88%E5%99%A8CORS%E5%92%8CCSP%E4%BB%8B%E7%BB%8D/</id>
    <published>2023-03-04T07:08:59.000Z</published>
    <updated>2023-03-04T08:53:05.173Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>了解浏览器的一些安全策略同时了解跨域问题.<br><span id="more"></span></p><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>全称是跨源资源共享(Cross-Origin Resource Sharing).是一个系统，它由一系列传输的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP_header">HTTP 标头</a>组成，这些 HTTP 标头决定浏览器是否阻止前端 JavaScript 代码获取跨源请求的响应.</p><p>这又涉及到了浏览器的同源策略.</p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p><strong>同源策略</strong>是一个重要的安全策略，它用于限制一个<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin">源</a>的文档或者它加载的脚本如何能与另一个源的资源进行交互。</p><blockquote><p>它能帮助阻隔恶意文档，减少可能被攻击的媒介。例如，它可以防止互联网上的恶意网站在浏览器中运行 JS 脚本，从第三方网络邮件服务（用户已登录）或公司内网（因没有公共 IP 地址而受到保护，不会被攻击者直接访问）读取数据，并将这些数据转发给攻击者。</p></blockquote><h4 id="源的定义"><a href="#源的定义" class="headerlink" title="源的定义"></a>源的定义</h4><p>如果两个 URL 的<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol">协议</a>、<a href="https://developer.mozilla.org/en-US/docs/Glossary/Port">端口 (en-US)</a>（如果有指定的话）和<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Host">主机</a>都相同的话，则这两个 URL 是<em>同源</em>的。这个方案也被称为“协议/主机/端口元组”，或者直接是“元组”。（“元组”是指一组项目构成的整体，具有双重/三重/四重/五重等通用形式。）</p><p>协议比如http,https.  主机是域名或者ip地址.</p><div class="table-container"><table><thead><tr><th style="text-align:left">URL</th><th style="text-align:left">结果</th><th style="text-align:left">原因</th></tr></thead><tbody><tr><td style="text-align:left"><code>http://store.company.com/dir2/other.html</code></td><td style="text-align:left">同源</td><td style="text-align:left">只有路径不同</td></tr><tr><td style="text-align:left"><code>http://store.company.com/dir/inner/another.html</code></td><td style="text-align:left">同源</td><td style="text-align:left">只有路径不同</td></tr><tr><td style="text-align:left"><code>https://store.company.com/secure.html</code></td><td style="text-align:left">失败</td><td style="text-align:left">协议不同</td></tr><tr><td style="text-align:left"><code>http://store.company.com:81/dir/etc.html</code></td><td style="text-align:left">失败</td><td style="text-align:left">端口不同（<code>http://</code> 默认端口是 80）</td></tr><tr><td style="text-align:left"><code>http://news.company.com/dir/other.html</code></td><td style="text-align:left">失败</td><td style="text-align:left">主机不同</td></tr></tbody></table></div><p>除了一般的HTTP还有<strong>文件源</strong>.</p><p>现代浏览器通常将使用 <code>file:///</code> 模式加载的文件的来源视为<em>不透明的来源</em>。这意味着，假如一个文件包括来自同一文件夹的其它文件，它们不会被认为来自同一来源，并可能引发 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CORS">CORS</a> 错误</p><p><strong>源的继承</strong></p><p>在页面中通过 <code>about:blank</code> 或 <code>javascript:</code> URL 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URL 没有包含源服务器的相关信息。</p><p>例如，<code>about:blank</code> 通常作为父脚本写入内容的新的空白弹出窗口的 URL（例如，通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open"><code>Window.open()</code></a>）。如果此弹出窗口也包含 JavaScript，则该脚本将从创建它的脚本那里继承对应的源。</p><h4 id="跨源网络访问"><a href="#跨源网络访问" class="headerlink" title="跨源网络访问"></a>跨源网络访问</h4><p>同源策略会影响不同源之间的交互.</p><blockquote><p>例如在使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img"><code>img</code></a> 标签时则会受到同源策略的约束。这些交互通常分为三类：</p><ul><li>跨源<strong>写操作</strong>（Cross-origin writes）一般是被允许的。例如链接、重定向以及表单提交。特定少数的 HTTP 请求需要添加<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#预检请求">预检请求</a>。</li><li>跨源<strong>资源嵌入</strong>（Cross-origin embedding）一般是被允许的.</li><li>跨源<strong>读操作</strong>（Cross-origin reads）一般是不被允许的，但常可以通过内嵌资源来巧妙的进行读取访问。例如，你可以读取嵌入图片的高度和宽度，调用内嵌脚本的方法，或<a href="https://bugzil.la/629094">得知内嵌资源的可用性</a>。</li></ul></blockquote><p>以下是<strong>可能嵌入跨源的资源</strong>的一些示例：</p><ul><li>使用 <code>&lt;script src=&quot;…&quot;&gt;&lt;/script&gt;</code> 标签嵌入的 JavaScript 脚本。语法错误信息只能被同源脚本中捕捉到。</li><li>使用 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;…&quot;&gt;</code> 标签嵌入的 CSS。由于 CSS 的松散的语法规则，CSS 的跨源需要一个设置正确的 <code>Content-Type</code> 标头。如果样式表是跨源的，且 MIME 类型不正确，资源不以有效的 CSS 结构开始，浏览器会阻止它的加载。</li><li>通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img"><code>img</code></a> 展示的图片。</li><li>通过<code>video</code>和<code>audio</code>播放的多媒体资源。</li><li>通过 <code>object</code>和<code>embed</code> 嵌入的插件。</li><li>通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face"><code>@font-face</code></a> 引入的字体。一些浏览器允许跨源字体（cross-origin fonts），另一些需要同源字体（same-origin fonts）。</li><li>通过iframe载入的资源。站点可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Frame-Options"><code>X-Frame-Options</code></a> 标头来阻止这种形式的跨源交互。</li></ul><p>这份<a href="https://fetch.spec.whatwg.org/#http-cors-protocol">跨源共享标准</a>允许在下列场景中使用跨站点 HTTP 请求：</p><ul><li>前文提到的由 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">Fetch API</a> 发起的跨源 HTTP 请求。</li><li>Web 字体（CSS 中通过 <code>@font-face</code> 使用跨源字体资源），<a href="https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements">因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用</a>。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL">WebGL 贴图</a>。</li><li>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage"><code>drawImage()</code></a> 将图片或视频画面绘制到 canvas。</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Shapes/Shapes_From_Images">来自图像的 CSS 图形 (en-US)</a>。</li></ul><p>可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">CORS</a> 来允许跨源访问。CORS 是 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP">HTTP</a> 的一部分，它允许服务端来指定哪些主机可以从这个服务端加载资源。</p><h3 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h3><p>cors是一种基于HTTP头的机制,解决浏览器同源策略,允许服务器标示除了它自己以外的其它<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin">源</a>（域、协议或端口），使得浏览器允许这些源访问加载自己的资源.</p><p><strong>CORS 标头</strong></p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin"><code>Access-Control-Allow-Origin</code></a></p><p>指示响应的资源是否可以被给定的来源共享。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials"><code>Access-Control-Allow-Credentials</code></a></p><p>指示当请求的凭证标记为 true 时，是否可以公开对该请求响应。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Headers"><code>Access-Control-Allow-Headers</code></a></p><p>用在对预检请求的响应中，指示实际的请求中可以使用哪些 HTTP 标头。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Methods"><code>Access-Control-Allow-Methods</code></a></p><p>指定对预检请求的响应中，哪些 HTTP 方法允许访问请求的资源。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Expose-Headers"><code>Access-Control-Expose-Headers</code></a></p><p>通过列出标头的名称，指示哪些标头可以作为响应的一部分公开。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Max-Age"><code>Access-Control-Max-Age</code></a></p><p>指示预检请求的结果能被缓存多久。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers"><code>Access-Control-Request-Headers</code></a></p><p>用于发起一个预检请求，告知服务器正式请求会使用哪些 HTTP 标头。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Method"><code>Access-Control-Request-Method</code></a></p><p>用于发起一个预检请求，告知服务器正式请求会使用哪一种 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods">HTTP 请求方法</a>。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin"><code>Origin</code></a></p><p>指示获取资源的请求是从什么源发起的。</p></li></ul><p>跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求,通过浏览器发起一个到服务器托管的跨源资源的“预检”请求。在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头.</p><h4 id="实际访问控制场景"><a href="#实际访问控制场景" class="headerlink" title="实际访问控制场景"></a>实际访问控制场景</h4><ol><li><p>简单请求不会触发CORS预检请求.</p><p>若满足所有下述条件,</p><ul><li>使用下列方法之一：<ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD"><code>HEAD</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST"><code>POST</code></a></li></ul></li></ul></li></ol><p>​    允许人为设置下面的字段</p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept"><code>Accept</code></a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language"><code>Accept-Language</code></a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language"><code>Content-Language</code></a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a>（需要注意额外的限制）</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Range"><code>Range</code></a>（只允许<a href="https://fetch.spec.whatwg.org/#simple-range-header-value">简单的范围标头值</a> 如 <code>bytes=256-</code> 或 <code>bytes=127-255</code>）</p></li><li><p><code>Content-Type</code></p></li></ul><p>  标头所指定的</p><p>  媒体类型</p><p>  的值仅限于下列三者之一：</p><ul><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul><p>具体请查阅MDN<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#什么情况下需要_cors？">跨源资源共享（CORS） - HTTP | MDN (mozilla.org)</a></p><p>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin"><code>Origin</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin"><code>Access-Control-Allow-Origin</code></a> 就能完成最简单的访问控制。如果 <code>https://bar.other</code> 的资源持有者想限制他的资源<em>只能</em>通过 <code>https://foo.example</code> 来访问</p><ol><li>预检请求</li></ol><p>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin"><code>Origin</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin"><code>Access-Control-Allow-Origin</code></a> 就能完成最简单的访问控制。如果 <code>https://bar.other</code> 的资源持有者想限制他的资源<em>只能</em>通过 <code>https://foo.example</code> 来访问</p><ol><li><p>附带身份凭证的请求</p><p>一般而言，对于跨源 <code>XMLHttpRequest</code> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">Fetch</a> 请求，浏览器<strong>不会</strong>发送身份凭证信息。如果要发送凭证信息，需要设置 <code>XMLHttpRequest</code> 对象的某个特殊标志位，或在构造 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Request"><code>Request</code></a> 对象时设置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> invocation = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"> invocation.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>如果服务器端的响应中未携带 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials"><code>Access-Control-Allow-Credentials</code></a><code>: true</code>，浏览器将<strong>不会</strong>把响应内容返回给请求的发送者</p></li></ol><h2 id="内容安全策略-CSP"><a href="#内容安全策略-CSP" class="headerlink" title="内容安全策略(CSP)"></a>内容安全策略(CSP)</h2><p><strong>内容安全策略</strong>（<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CSP">CSP</a>）是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括<strong>跨站脚本</strong>（<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting">XSS</a>）和<strong>数据注入攻击</strong>等。无论是数据盗取、网站内容污染还是恶意软件分发，这些攻击都是主要的手段。  </p><p>为使 CSP 可用，你需要配置你的网络服务器返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy"><code>Content-Security-Policy</code></a> HTTP 标头（有时你会看到 <code>X-Content-Security-Policy</code> 标头，但那是旧版本，并且你无须再如此指定它）。</p><p>除此之外，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta">``</a> 元素也可以被用来配置该策略，例如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; img-src https://*; child-src &#x27;none&#x27;;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP#示例_1">示例 1</a></h3><p>一个网站管理者想要所有内容均来自站点的同一个源（不包括其子域名）。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-<span class="keyword">Security</span>-<span class="keyword">Policy</span>: <span class="keyword">default</span>-src <span class="string">&#x27;self&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP#示例_2">示例 2</a></h3><p>一个网站管理者允许内容来自信任的域名及其子域名（域名不必须与 CSP 设置所在的域名相同）。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-<span class="keyword">Security</span>-<span class="keyword">Policy</span>: <span class="keyword">default</span>-src <span class="string">&#x27;self&#x27;</span> *.<span class="keyword">trusted</span>.com</span><br></pre></td></tr></table></figure><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP#示例_3">示例 3</a></h3><p>一个网站管理者允许网页应用的用户在他们自己的内容中包含来自任何源的图片，但是限制音频或视频需从信任的资源提供者，所有脚本必须从特定主机服务器获取可信的代码。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content</span>-Security-Policy: default-src <span class="string">&#x27;self&#x27;</span>; <span class="selector-tag">img</span>-<span class="attribute">src</span> *; media-<span class="attribute">src</span> media1<span class="selector-class">.com</span> media2<span class="selector-class">.com</span>; script-<span class="attribute">src</span> userscripts<span class="selector-class">.example</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure><p>在这里，各种内容默认仅允许从文档所在的源获取，但存在如下例外：</p><ul><li>图片可以从任何地方加载 (注意“*”通配符)。</li><li>多媒体文件仅允许从 media1.com 和 media2.com 加载（不允许从这些站点的子域名）。</li><li>可运行脚本仅允许来自于 userscripts.example.com。</li></ul><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP#示例_4">示例 4</a></h3><p>一个线上银行网站的管理者想要确保网站的所有内容都要通过 SSL 方式获取，以避免攻击者窃听用户发出的请求。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src <span class="attribute">https</span>:<span class="comment">//onlinebanking.jumbobank.com</span></span><br></pre></td></tr></table></figure><p>该服务器仅允许通过 HTTPS 方式并仅从 onlinebanking.jumbobank.com 域名来访问文档。</p><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP#示例_5">示例 5</a></h3><p>一个在线邮箱的管理者想要允许在邮件里包含 HTML，同样图片允许从任何地方加载，但不允许 JavaScript 或者其它潜在的危险内容（从任意位置加载）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content</span>-Security-Policy: default-src <span class="string">&#x27;self&#x27;</span> *.mailsite.com; <span class="selector-tag">img</span>-<span class="attribute">src</span> *</span><br></pre></td></tr></table></figure><p>注意这个示例并未指定 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src"><code>script-src</code> (en-US)</a>；在此 CSP 示例中，站点通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src"><code>default-src</code></a> 指令的对其进行配置，这也同样意味着脚本文件仅允许从原始服务器获取。</p><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">跨源资源共享（CORS） - HTTP | MDN (mozilla.org)</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP#对策略进行测试">内容安全策略（CSP） - HTTP | MDN (mozilla.org)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;了解浏览器的一些安全策略同时了解跨域问题.&lt;br&gt;</summary>
    
    
    
    
    <category term="cors" scheme="https://www.sekyoro.top/tags/cors/"/>
    
    <category term="csp" scheme="https://www.sekyoro.top/tags/csp/"/>
    
    <category term="浏览器" scheme="https://www.sekyoro.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>学习purecss构建自己的css框架</title>
    <link href="https://www.sekyoro.top/2023/02/18/%E5%AD%A6%E4%B9%A0purecss%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84css%E6%A1%86%E6%9E%B6/"/>
    <id>https://www.sekyoro.top/2023/02/18/%E5%AD%A6%E4%B9%A0purecss%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84css%E6%A1%86%E6%9E%B6/</id>
    <published>2023-02-18T04:35:33.000Z</published>
    <updated>2023-02-18T04:58:31.377Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>更加简易的Bootstrap框架,定制度更高.比Tailwind轻量.<br><span id="more"></span></p><p>中文官方文档<a href="https://purecss.cn/start.html">开始使用 - Pure | Pure中文站 | Purecss学习网</a></p><p>官网有最新版<a href="https://purecss.io/start/">Get Started - Pure (purecss.io)</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;更加简易的Bootstrap框架,定制度更高.比Tailwind轻量.&lt;br&gt;</summary>
    
    
    
    
    <category term="css" scheme="https://www.sekyoro.top/tags/css/"/>
    
    <category term="pure.css" scheme="https://www.sekyoro.top/tags/pure-css/"/>
    
  </entry>
  
  <entry>
    <title>DLHLP学习</title>
    <link href="https://www.sekyoro.top/2023/02/17/DLHLP%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2023/02/17/DLHLP%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-02-17T02:37:57.000Z</published>
    <updated>2023-02-17T03:03:53.064Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>李宏毅的语言处理. Deep Learning for Human Language Processing.<br><span id="more"></span></p><p>课程链接<a href="https://www.youtube.com/watch?v=nER51ZyJaCQ&amp;list=PLJV_el3uVTsO07RpBYFsXg-bN5Lu0nhdG&amp;ab_channel=Hung-yiLee">DLHLP 2020] Deep Learning for Human Language Processing (Course Overview) - YouTube</a></p><p><img data-src="http://cdn.sekyoro.top/imgs/17/0220230217105241.png" alt="image-20230217105215776" style="zoom:67%;" /></p><h3 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h3><p>传统语音处理</p><p><img data-src="http://cdn.sekyoro.top/imgs/17/0220230217105753.png" alt="image-20230217105753162"></p><p>ASR(automatic speech recognition)</p><h3 id="语音合成"><a href="#语音合成" class="headerlink" title="语音合成"></a>语音合成</h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;李宏毅的语言处理. Deep Learning for Human Language Processing.&lt;br&gt;</summary>
    
    
    
    
    <category term="Deep Learning" scheme="https://www.sekyoro.top/tags/Deep-Learning/"/>
    
    <category term="Speech" scheme="https://www.sekyoro.top/tags/Speech/"/>
    
  </entry>
  
  <entry>
    <title>docker学习</title>
    <link href="https://www.sekyoro.top/2023/02/13/docker%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2023/02/13/docker%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-02-13T09:41:44.000Z</published>
    <updated>2023-02-13T15:27:29.952Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Docker可以方便部署以及利用镜像快速学习一些项目,解决环境冲突等.重点关注Dockerfile和docker-compose文件的编写.<br><span id="more"></span></p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Docker 是一个开源的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html">Go 语言</a> 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><blockquote><p>Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p></blockquote><ul><li>Web 应用的自动化打包和发布。</li><li>自动化测试和持续集成、发布。</li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li><li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li></ul><h3 id="镜像-image"><a href="#镜像-image" class="headerlink" title="镜像(image)"></a>镜像(image)</h3><p>镜像类似于一个打包好的软件或可执行程序,可以通过运行这个镜像得到容器(类似于一个进程).</p><p>镜像可以<strong>自己打包</strong>或从<strong>Docker Hub</strong><a href="https://hub.docker.com/">Docker Hub Container Image Library | App Containerization</a>获取,如果本地没有打包的默认从后者拉取.</p><p>自己打包需要Dockerfile定制这个”可执行程序”,有了Dockerfile后可以使用<code>docker build .</code>构建镜像.</p><p><code>.</code>符号表示在这个目录下的Dockerfile文件.</p><p>一个镜像可以在多个容器运行,可以将镜像分享给别人.</p><p>使用<code>docker run</code>运行镜像,如果本地没有会自动<code>docker pull</code>拉取.</p><p>使用<code>docker push</code>可以将自己的镜像推送到Docker Hub.</p><p>这里我们创建一个小项目.</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213175949.png" alt="image-20230213175925727" style="zoom:50%;" /></p><p>创建一个服务监听端口.</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213175946.png" alt="image-20230213175946483"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span></span><br><span class="line">        &#123;</span><br><span class="line">res.send(<span class="string">&#x27;&lt;p&gt;你好&lt;/p&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">app.listen(port,<span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="string">&quot;端口是3000&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写好后就可以直接创建Dockerfile建立镜像了.</p><p>首先Dockerfile文件创建在项目根目录中.</p><p>需要先拉取镜像,可以在<a href="https://hub.docker.com/">Docker Hub Container Image Library | App Containerization</a>中查找.</p><p>首先我们用到了node,所以需要拉取相应的node镜像(一般node镜像肯定带了OS等底层的镜像)</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213180313.png" alt="image-20230213180312673" style="zoom: 50%;" /></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">19</span>-alpine3.<span class="number">16</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /myworkdir</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm i</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;node&quot;</span>,<span class="string">&quot;app.js&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>docker会一行一行扫描代码.</p><p>FROM表示拉取node:19-alpine3.16,node:19-alpine3.16是镜像名,19-alpine3.16表示版本,node 19版本,alpine是一个操作系统常用于Docker构建.  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myimage:v1  .</span><br></pre></td></tr></table></figure><p>如果不使用tag,则没有名字</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/02image-20230213190037683.png" alt="image-20230213190037683"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag &lt;IMAGE ID&gt; &lt;REPO:TAG&gt;</span><br></pre></td></tr></table></figure><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213190203.png" alt="image-20230213190203625"></p><p>没有tag默认latest</p><p>使用<code>docker push</code>推送镜像</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213190322.png" alt="image-20230213190322542" style="zoom:50%;" /></p><p>使用<code>docker rmi</code>删除本地镜像</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213190427.png" alt="image-20230213190427515"></p><p>使用<code>docker pull</code>拉取Docker Hub中的镜像.</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213190537.png" alt="image-20230213190537437"></p><h3 id="容器-container"><a href="#容器-container" class="headerlink" title="容器(container)"></a>容器(container)</h3><p>使用<code>docker run &lt;镜像名&gt;</code>运行镜像从而得到</p><p><code>-d</code>参数后台运行</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213191520.png" alt="image-20230213191519991" style="zoom:67%;" /></p><p>使用<code>docker images</code>查询镜像信息.</p><p>使用<code>docker ps</code>查询容器信息.</p><p>这里并不能直接通过3000端口访问网页,因为并没有实际暴露.</p><p>Dockerfile文件中EXPOSE命令只是标识提醒作用.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3000:3000 --name mydocker proanimer/nodejs:<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><code>-p</code>参数表示端口映射 本地3000映射后者容器的3000.</p><p><code>--name</code>参数表示给容器命名,否则有默认命名.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3000:3000 --name mydockerpro proanimer/nodejs:<span class="built_in">test</span>           </span><br></pre></td></tr></table></figure><p>使用<code>docker stop &lt;容器id&gt;</code>停止运行.</p><p>使用<code>docker rm &lt;容器id&gt;</code>删除窗口.</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213192549.png" alt="image-20230213192549208"></p><p>修改文件后容器并不会跟着改变,因为修改的文件时本地镜像中的文件,容器是之前的镜像运行后的结果.我们需要与运行的容器直接交互.</p><p>使用<code>docker exec -it &lt;镜像名或id&gt; /bin/sh</code> </p><p><code>/bin/sh</code>是容器中os的shell.</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213201031.png" alt="image-20230213195526472"></p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213201022.png" alt="image-20230213200936929"></p><p>注意 如果在Windows上需要加上winpty,同时设定shell路径时是<code>//bin/sh</code>即需要多加上一个<code>/</code></p><p>注意进入容器后很多工具比如vim可能都没有,所以需要用到路径映射.</p><p>设置volume,-v 把本地指定文件夹和容器指定文件夹绑定</p><p>这里使用</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213210813.png" alt="image-20230213210813343">注意如果是git bash for windows.使用下面命令,</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  -v F://docker_exp1://myworkdir -p 3000:3000 --name mypro proanimer/nodejs:<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213220937.png" alt="image-20230213220937554"></p><p>发现挂载路径有/hostmnt,这是git bash比较特别的,表示宿主机.</p><p>如果是在windows的powershell.</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213220123.png" alt="image-20230213220122719"></p><p>检查挂载路径,<img data-src="http://cdn.sekyoro.top/imgs/13/0220230213221258.png" alt="image-20230213221258083" style="zoom:80%;" /></p><p>两者这里不同,但本质上是一样的.</p><p>注意,这里路径映射时是依照宿主机的,即如果宿主机/dir上有A,B文件,容器路径中/dir中有C文件,将这两个路径映射,则实际用时是A,B文件.</p><p>同时使用<code>-v 目录</code>对这个容器中的目录不进行同步.本地只读后增加:ro</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213225237.png" alt="image-20230213225237389" style="zoom:67%;" /></p><p><strong>ro模式</strong></p><p>（1）文件：容器内不能修改，会提示read-only</p><p>（2）文件夹：容器内不能修改、新增、删除文件夹中的文件，会提示read-only</p><p><code>docker rm -fv</code>同时把volume删除.</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>通过写Dockerfile定制镜像文件,使用<code>docker build</code>创建镜像.</p><h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p><strong>FROM</strong>：定制的镜像都是基于FROM的镜像</p><h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p><strong>RUN</strong>：用于执行后面跟着的命令行命令。有以下两种格式：</p><p>shell 格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;命令行命令&gt;</span><br><span class="line"><span class="comment"># &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span></span><br></pre></td></tr></table></figure><p>exec 格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN [<span class="string">&quot;可执行文件&quot;</span>, <span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>]</span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line"><span class="comment"># RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN **yum** -y **install** **wget**</span><br><span class="line">RUN **wget** -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span><br><span class="line">RUN **tar** -xvf redis.tar.gz</span><br></pre></td></tr></table></figure><p>以上执行会创建 3 层镜像。可简化为以下格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum -y install wget \</span><br><span class="line">  &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span><br><span class="line">  &amp;&amp; tar -xvf redis.tar.gz</span><br></pre></td></tr></table></figure><p>如上，以 <strong>&amp;&amp;</strong> 符号连接命令，这样执行后，只会创建 1 层镜像。</p><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p><ul><li><strong>CMD 在docker run</strong> 时运行。</li><li><strong>RUN 是在 docker build</strong>即构建时运行.</li></ul><p><strong>作用</strong>：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD &lt;shell 命令&gt; </span><br><span class="line">CMD [<span class="string">&quot;&lt;可执行文件或命令&gt;&quot;</span>,<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...] </span><br><span class="line">CMD [<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...]  <span class="comment"># 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span></span><br></pre></td></tr></table></figure><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p><p>但是, 如果运行 docker run 时使用了 —entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序。</p><p><strong>优点</strong>：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [<span class="string">&quot;&lt;executeable&gt;&quot;</span>,<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...]</span><br></pre></td></tr></table></figure><h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。</p><p>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> &lt;工作目录路径&gt;</span></span><br></pre></td></tr></table></figure><h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p><p>作用：</p><ul><li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li><li>避免容器不断变大。</li></ul><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">&quot;&lt;路径1&gt;&quot;</span>, <span class="string">&quot;&lt;路径2&gt;&quot;</span>...]</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> &lt;路径&gt;</span></span><br></pre></td></tr></table></figure><p>在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。</p><h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p>仅仅只是声明端口. <strong>注意</strong>并没有实际作用</p><p>作用：</p><ul><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li><li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li></ul><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;端口<span class="number">1</span>&gt; [&lt;端口<span class="number">2</span>&gt;...]</span><br></pre></td></tr></table></figure><h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="keyword">ENV</span> &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br></pre></td></tr></table></figure><p>以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span></span><br><span class="line"><span class="bash">  &amp;&amp; curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span></span></span><br></pre></td></tr></table></figure><h4 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h4><p>构建参数，与 ENV 作用一致。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</p><p>构建命令 docker build 中可以用 —build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> &lt;参数名&gt;[=&lt;默认值&gt;]</span><br></pre></td></tr></table></figure><h4 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h4><p>用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在<strong>本次构建镜像的过程中不会执行</strong>（假设镜像为 test-build）。当有新的 Dockerfile <strong>使用了之前构建的镜像 FROM test-build ，这时执行新镜像的 Dockerfile 构建时候，会执行</strong> test-build 的 Dockerfile 里的 ONBUILD 指定的命令。</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ONBUILD</span> &lt;其它指令&gt;</span><br></pre></td></tr></table></figure><h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p>LABEL 指令用来给镜像添加一些元数据（metadata），以键值对的形式，语法格式如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt; =&lt;value&gt; ...</span></span><br></pre></td></tr></table></figure><p>比如我们可以添加镜像的作者：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL org.opencontainers.image.authors=<span class="string">&quot;runoob&quot;</span></span><br></pre></td></tr></table></figure><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h3><p>启动多个容器处理应用.</p><p>yaml文件格式.</p><p><strong>基本语法</strong></p><ul><li><strong>大小写敏感</strong></li><li><strong>使用缩进表示层级关系</strong></li><li>缩进不允许使用tab，<strong>只允许空格</strong></li><li>缩进的空格数不重要，<strong>只要相同层级的元素左对齐即可</strong></li><li>‘#’表示注释</li></ul><p>创建docker-compose.yml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yaml 配置实例</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">.:/code</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">logvolume01:/var/log</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">logvolume01:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>services下都是镜像,build表示通过Dockerfile构建.</p><p>ports和volumes用于映射端口和数据卷.</p><p>使用命令<code>docker-compose up -d --build</code>-d表示后台,—build表示如果镜像修改就会重建.</p><h4 id="version"><a href="#version" class="headerlink" title="version"></a>version</h4><p>指定本 yml 依从的 compose 哪个版本制定的。</p><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>指定为构建镜像上下文路径：</p><h4 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h4><p>将主机的数据卷或着文件挂载到容器里。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:latest</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/localhost/postgres.sock:/var/run/postgres/postgres.sock&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/localhost/data:/var/lib/postgresql/data&quot;</span></span><br></pre></td></tr></table></figure><h4 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h4><p>暴露端口，但不映射到宿主机，只允许能被连接的服务访问。仅可以指定内部端口为参数，如下所示：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">expose:</span></span><br><span class="line">    - <span class="string">&quot;3000&quot;</span></span><br><span class="line">    - <span class="string">&quot;8000&quot;</span></span><br></pre></td></tr></table></figure><h4 id="links"><a href="#links" class="headerlink" title="links"></a>links</h4><p>链接到其它服务中的容器。使用服务名称（同时作为别名），或者服务名称:服务别名（如 SERVICE:ALIAS），例如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">links:</span><br><span class="line"><span class="bullet">    -</span> db</span><br><span class="line"><span class="bullet">    -</span> db:database</span><br><span class="line"><span class="bullet">    -</span> redis</span><br></pre></td></tr></table></figure><p>使用<code>docker-compose down -v</code>删除镜像同时删除volume</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.cnblogs.com/minseo/p/11548177.html">Docker入门之docker-compose - minseo - 博客园 (cnblogs.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;Docker可以方便部署以及利用镜像快速学习一些项目,解决环境冲突等.重点关注Dockerfile和docker-compose文件的编写.&lt;br&gt;</summary>
    
    
    
    
    <category term="tutorial" scheme="https://www.sekyoro.top/tags/tutorial/"/>
    
    <category term="docker" scheme="https://www.sekyoro.top/tags/docker/"/>
    
  </entry>
  
</feed>

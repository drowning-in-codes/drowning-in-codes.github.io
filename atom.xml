<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sekyoro的博客小屋</title>
  
  
  <link href="https://www.sekyoro.top/atom.xml" rel="self"/>
  
  <link href="https://www.sekyoro.top/"/>
  <updated>2025-08-11T03:34:17.348Z</updated>
  <id>https://www.sekyoro.top/</id>
  
  <author>
    <name>Sekyoro</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>springcloud微服务入门</title>
    <link href="https://www.sekyoro.top/2025/08/10/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/"/>
    <id>https://www.sekyoro.top/2025/08/10/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/</id>
    <published>2025-08-10T04:39:18.000Z</published>
    <updated>2025-08-11T03:34:17.348Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>单体架构将业务所有功能集中在一个项目开发,通过打成一个包部署. 架构简单,部署成本低.但是功能之间耦合度高,而<strong>分布式架构根据业务功能对系统进行拆分,每个业务模块作为独立项目开发,有利于降低服务耦合以及服务拓展</strong>.<br><span id="more"></span></p><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><p>事务可以看作一次大的活动,可以有不同的小活动组成,这些活动要么全部成功,要么全部失败.  </p><p>而在计算机系统中更多通过数据库来控制事务,利用数据库本身事务特性来实现,数据库通常和应用在同一个服务器,因此这种叫做本地事务. 事务本身特性ACID,原子性,一致性,隔离性与持久性.</p><h2 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h2><p>CAP理论是分布式系统中最基础也是最重要的理论之一。它指出，一个分布式系统<strong>不可能同时满足</strong>以下三个条件：</p><ul><li><strong>一致性（Consistency）</strong>：所有节点在同一时间看到的数据都是一致的。</li><li><strong>可用性（Availability）</strong>：系统在面对部分节点失效时，仍能对外提供服务。</li><li><strong>分区容错性（Partition Tolerance）</strong>：系统在网络分区（节点之间无法通信）发生时，仍能正常运行。</li></ul><p><strong>关键点</strong>：在分布式系统中，<strong>分区容错性是必须满足的</strong>。因为网络不可靠，随时可能发生分区。因此，在实践中，你只能在 <strong>C 和 A 之间进行取舍</strong>：</p><ul><li><strong>CP 系统</strong>：<strong>优先保证一致性，牺牲可用性。在网络分区时，为了保证数据一致，系统会停止服务</strong>。例如，ZooKeeper、etcd。</li><li><strong>AP 系统</strong>：优先保证可用性，牺牲一致性<strong>。在网络分区时，系统依然对外提供服务，但可能返回不一致的数据</strong>。例如，Cassandra、DynamoDB。</li></ul><p>BASE 理论是 CAP 理论中 AP 系统的延伸，是针对大型互联网应用提出的。它是一种在牺牲强一致性的情况下，追求高可用性的思想。</p><ul><li><strong>基本可用（Basically Available）</strong>：系统可以有部分功能降级，允许在网络分区时牺牲部分非核心功能，但核心功能要保持可用。</li><li><strong>软状态（Soft State）</strong>：允许系统中的数据存在中间状态，这个中间状态不影响系统正常工作。</li><li><strong>最终一致性（Eventually Consistent）</strong>：系统中的数据可能在一段时间内是不一致的，但最终会达到一致状态。</li></ul><p><strong>关键点</strong>：BASE 理论是许多分布式系统的设计基础，特别是在对性能和可用性要求极高的场景中。例如，电商的购物车、社交媒体的好友列表，都可以在短时间内允许数据不一致，最终同步。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式锁是用于分布式环境下并发控制的一种机制，用于控制某个资源在同一时刻只能被一个应用所使用。</p><p>Redis 本身可以被多个客户端共享访问，正好就是一个共享存储系统，可以用来保存分布式锁，而且 Redis 的读写性能高，可以应对高并发的锁操作场景。Redis 的 SET 命令有个 NX 参数可以实现「key不存在才插入」，所以可以用它来实现分布式锁：</p><ul><li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li><li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li></ul><p>基于 Redis 节点实现分布式锁时，对于加锁操作，我们需要满足三个条件。</p><ul><li>加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的方式完成，所以，我们使用 SET 命令带上 NX 选项来实现加锁；</li><li>锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以，我们在 SET 命令执行时加上 EX/PX 选项，设置其过期时间；</li><li>锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作，所以，我们使用 SET 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端；</li></ul><p>满足这三个条件的分布式命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock_key unique_value NX PX 10000</span><br></pre></td></tr></table></figure><ul><li>lock_key 就是 key 键；</li><li>unique_value 是客户端生成的唯一的标识，区分来自不同客户端的锁操作；</li><li>NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；</li><li>PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。</li></ul><p>而解锁的过程就是将 lock_key 键删除（del lock_key），但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以，解锁的时候，我们要先判断锁的 unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除。</p><p>可以看到，解锁是有两个操作，这时就需要 Lua 脚本来保证解锁的原子性，因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这样一来，就通过使用 SET 命令和 Lua 脚本在 Redis 单节点上完成了分布式锁的加锁和解锁。</p><p>还可以<strong>基于zookeeper来实现分布式</strong>。</p><p>zookeeper是一个<strong>为分布式应用提供一致性服务的软件，它内部是一个分层的文件系统目录树结构，规定统一个目录下只能有一个唯一文件名。</strong></p><p>数据模型：</p><ul><li>永久节点：<strong>节点创建后，不会因为会话失效而消失</strong></li><li>临时节点：<strong>与永久节点相反，如果客户端连接失效，则立即删除节点</strong></li><li>顺序节点：与上述两个节点特性类似，如果指定创建这类节点时，zk会自动在节点名后加一个数字后缀，并且是有序的。</li></ul><p>监视器（watcher）：</p><ul><li><strong>当创建一个节点时，可以注册一个该节点的监视器，当节点状态发生改变时，watch被触发时，ZooKeeper将会向客户端发送且仅发送一条通知</strong>，因为watch只能被触发一次。</li></ul><p>利用Zookeeper的临时顺序节点和监听机制两大特性，可以帮助我们实现分布式锁。</p><p><img data-src="https://cdn.xiaolincoding.com//picgo/1728721036831-d9c8124c-b9ac-4490-92c6-2e52e5636c55.png" alt="img"></p><ul><li>首先得有一个持久节点<code>/locks</code>, 路径服务于某个使用场景，如果有多个使用场景建议路径不同。</li><li>请求进来时首先在<code>/locks</code>创建临时有序节点，所有会看到在<code>/locks</code>下面有seq-000000000, seq-00000001 等等节点。</li><li>然后判断当前创建得节点是不是<code>/locks</code>路径下面最小的节点，如果是，获取锁，不是，阻塞线程，同时设置监听器，监听前一个节点。</li><li>获取到锁以后，开始处理业务逻辑，最后delete当前节点，表示释放锁。</li><li>后一个节点就会收到通知，唤起线程，重复上面的判断。</li></ul><p>zookerper 实现的分布式锁是强一致性的，<strong>因为它底层的 ZAB协议(原子广播协议), 天然满足 CP，</strong>但是这也意味着性能的下降, 所以不站在具体数据下看 Redis 和 Zookeeper, 代表着性能和一致性的取舍。</p><p>如果项目没有强依赖 ZK, 使用 Redis 就好了, 因为现在 Redis 用途很广, 大部分项目中都引用了 Redis，没必要对此再引入一个新的组件, 如果业务场景对于 Redis 异步方式的同步数据造成锁丢失无法忍受, 在业务层处理就好了</p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>分布式系统会把一个应用系统拆分为独立部署的多个服务,因此需要服务之间远程协作才能完成事务操作,这种分布式系统环境下由不同服务之间通过网络远程协作完成事务称之为分布式事务.</p><p>分布式事务最大问题是各个子事务的一致性问题,通过CAP定理和BASE理论</p><p>AP模式:各个子事务分别执行和提交,允许出现结果不一致,然后<strong>采用弥补措施</strong>恢复数据,实现<strong>最终一致性</strong></p><p>CP模式: <strong>各个子事务执行后互相等待,同时提交,同时回滚,达成强一致性</strong>.但事务等待过程中会出现弱可用状态.</p><p>解决分布式事务,各个子系统之间必须能感知到彼此的事务状态,才能保证状态一致. 因此需要一个事务协调者来协调每个事务的参与者(子系统事务,分支事务). 有关联的各个分支事务在一起称为全局事务</p><p><img data-src="https://s2.loli.net/2025/08/10/zQ5VyrXtv1Gmd2B.png" alt="image-20250810202942753"></p><h2 id="分布式限流算法"><a href="#分布式限流算法" class="headerlink" title="分布式限流算法"></a>分布式限流算法</h2><ul><li><strong>滑动窗口限流算法</strong>是对固定窗口限流算法的改进，有效解决了窗口切换时可能会产生两倍于阈值流量请求的问题。</li><li><strong>漏桶限流算法</strong>能够对流量起到整流的作用，让随机不稳定的流量以固定的速率流出，但是不能解决<strong>流量突发</strong>的问题。</li><li><strong>令牌桶算法</strong>作为漏斗算法的一种改进，除了能够起到平滑流量的作用，还允许一定程度的流量突发。</li></ul><blockquote><p>固定窗口限流算法</p></blockquote><p>固定窗口限流算法就是对一段固定时间窗口内的请求进行计数，如果请求数超过了阈值，则舍弃该请求；如果没有达到设定的阈值，则接受该请求，且计数加1。当时间窗口结束时，重置计数器为0。</p><p><img data-src="https://cdn.xiaolincoding.com//picgo/1714660128964-c3acea75-3a80-427b-aafa-8d75d2672532.png" alt="img"></p><p>固定窗口限流优点是实现简单，但是会有“流量吐刺”的问题，假设窗口大小为1s，限流大小为100，然后恰好在某个窗口的第999ms来了100个请求，窗口前期没有请求，所以这100个请求都会通过。再恰好，下一个窗口的第1ms有来了100个请求，也全部通过了，那也就是在2ms之内通过了200个请求，而我们设定的阈值是100，通过的请求达到了阈值的两倍，这样可能会给系统造成巨大的负载压力。</p><p><img data-src="https://cdn.xiaolincoding.com//picgo/1714660725465-d851112c-47c6-4fa1-a383-8433555fbefb.png" alt="img"></p><blockquote><p>滑动窗口限流算法</p></blockquote><p>改进固定窗口缺陷的方法是采用滑动窗口限流算法，滑动窗口就是将限流窗口内部切分成一些更小的时间片，然后在时间轴上滑动，每次滑动，滑过一个小时间片，就形成一个新的限流窗口，即滑动窗口。然后在这个滑动窗口内执行固定窗口算法即可。</p><p>滑动窗口可以避免固定窗口出现的放过两倍请求的问题，因为一个短时间内出现的所有请求必然在一个滑动窗口内，所以一定会被滑动窗口限流。</p><p><img data-src="https://cdn.xiaolincoding.com//picgo/1714660846185-84b51249-3360-43d1-ab85-682094db87fc.png" alt="img"></p><blockquote><p>漏桶限流算法</p></blockquote><p>漏桶限流算法是模拟水流过一个有漏洞的桶进而限流的思路，如图。</p><p><img data-src="https://cdn.xiaolincoding.com//picgo/1714660900451-b154db6e-dfdf-4580-88db-2ae25bf03b69.png" alt="img"></p><p>水龙头的水先流入漏桶，再通过漏桶底部的孔流出。如果流入的水量太大，底部的孔来不及流出，就会导致水桶太满溢出去。</p><p>从系统的角度来看，我们不知道什么时候会有请求来，也不知道请求会以多大的速率来，这就给系统的安全性埋下了隐患。但是如果加了一层漏斗算法限流之后，就能够保证请求以恒定的速率流出。在系统看来，请求永远是以平滑的传输速率过来，从而起到了保护系统的作用。</p><p>使用漏桶限流算法，缺点有两个：</p><ul><li>即使系统资源很空闲，多个请求同时到达时，漏桶也是慢慢地一个接一个地去处理请求，这其实并不符合人们的期望，因为这样就是在浪费计算资源。</li><li>不能解决流量突发的问题，假设漏斗速率是2个/秒，然后突然来了10个请求，受限于漏斗的容量，只有5个请求被接受，另外5个被拒绝。你可能会说，漏斗速率是2个/秒，然后瞬间接受了5个请求，这不就解决了流量突发的问题吗？不，这5个请求只是被接受了，但是没有马上被处理，处理的速度仍然是我们设定的2个/秒，所以没有解决流量突发的问题</li></ul><blockquote><p>令牌桶限流算法</p></blockquote><p>令牌桶是另一种桶限流算法，模拟一个特定大小的桶，然后向桶中以特定的速度放入令牌（token），请求到达后，必须从桶中取出一个令牌才能继续处理。如果桶中已经没有令牌了，那么当前请求就被限流。如果桶中的令牌放满了，令牌桶也会溢出。</p><p>放令牌的动作是持续不断进行的，如果桶中令牌数达到上限，则丢弃令牌，因此桶中可能一直持有大量的可用令牌。此时请求进来可以直接拿到令牌执行。比如设置 qps 为 100，那么限流器初始化完成 1 秒后，桶中就已经有 100 个令牌了，如果此前还没有请求过来，这时突然来了 100 个请求，该限流器可以抵挡瞬时的 100 个请求。由此可见，只有桶中没有令牌时，请求才会进行等待，最终表现的效果即为以一定的速率执行。令牌桶的示意图如下：</p><p><img data-src="https://cdn.xiaolincoding.com//picgo/1714661434275-d83c23d2-26c7-4415-af6a-5a71d9ea0e40.png" alt="img"></p><p>令牌桶限流算法综合效果比较好，能在最大程度利用系统资源处理请求的基础上，实现限流的目标，建议通常场景中优先使用该算法。</p><h2 id="分布式一致性算法"><a href="#分布式一致性算法" class="headerlink" title="分布式一致性算法"></a>分布式一致性算法</h2><p>Raft与Paxos</p><p>Raft 和 Paxos 是两种经典的分布式一致性算法，旨在实现<strong>多节点状态机的高可靠一致性</strong>。两者核心目标相同（保证分布式系统数据一致性），但设计理念和实现方式有区别。</p><blockquote><p>raft 协议的原理</p></blockquote><p>Raft算法由leader节点来处理一致性问题。leader节点接收来自客户端的请求日志数据，然后同步到集群中其它节点进行复制，当日志已经同步到超过半数以上节点的时候，leader节点再通知集群中其它节点哪些日志已经被复制成功，可以提交到raft状态机中执行。</p><p>通过以上方式，Raft算法将要解决的一致性问题分为了以下几个子问题。</p><ul><li>leader选举：集群中必须存在一个leader节点。</li><li>日志复制：leader节点接收来自客户端的请求然后将这些请求序列化成日志数据再同步到集群中其它节点。</li><li>安全性：如果某个节点已经将一条提交过的数据输入raft状态机执行了，那么其它节点不可能再将相同索引 的另一条日志数据输入到raft状态机中执行。</li></ul><p>Raft算法需要有两个比较重要的机制</p><ul><li><strong>角色转换与选举机制</strong>：Raft 将系统中的节点分为三种角色：领导者（Leader）、跟随者（Follower）和候选人（Candidate）。系统启动时，所有节点都是跟随者。跟随者会定期从领导者处接收心跳信息以确认领导者的存活。如果跟随者在一段时间内（选举超时时间）没有收到领导者的心跳，它会转变为候选人，发起新一轮的选举。候选人向其他节点发送请求投票消息。其他节点根据收到的请求投票消息，决定是否为该候选人投票。当候选人获得超过半数节点的投票时，它就成为新的领导者。领导者会周期性地向所有跟随者发送心跳消息，以维持自己的领导地位。每个领导者的领导周期称为一个任期（Term），任期号是单调递增的。</li></ul><p><img data-src="https://cdn.xiaolincoding.com//picgo/1741335422453-5a93e24e-d9a4-49c9-9ae8-170e7db0e387.png" alt="img"></p><ul><li><strong>日志复制机制</strong>：客户端的请求会被领导者作为日志条目添加到自己的日志中。领导者将新的日志条目复制到其他跟随者节点。它会通过附加日志消息将日志条目发送给跟随者，跟随者收到消息后会将日志条目追加到自己的日志中，并向领导者发送确认消息。当领导者得知某个日志条目已经被大多数节点复制时，它会将该日志条目标记为已提交，并将其应用到状态机中。然后，领导者会通知其他节点该日志条目已提交，跟随者也会将已提交的日志条目应用到自己的状态机中。</li></ul><p><img data-src="https://cdn.xiaolincoding.com//picgo/1741335463759-7880ff38-4280-47c9-ac37-a0acbaedc6c3.png" alt="img"></p><blockquote><p>paxos协议的原理</p></blockquote><p>Paxos算法的核心思想是将一致性问题分解为多个阶段，每个阶段都有一个专门的协议来处理。Paxos算法的主要组成部分包括提议者（Proposer）、接受者（Acceptor）和投票者（Voter）。</p><ul><li>提议者：提议者是负责提出一致性问题的节点，它会向接受者发送提议，并等待接受者的回复。</li><li>接受者：接受者是负责处理提议的节点，它会接收提议者发送的提议，并对提议进行判断。如果接受者认为提议是有效的，它会向投票者发送请求，并等待投票者的回复。</li><li>投票者：投票者是负责决定提议是否有效的节点，它会接收接受者发送的请求，并对请求进行判断。如果投票者认为请求是有效的，它会向接受者发送投票，表示支持或反对提议。</li></ul><p><img data-src="https://cdn.xiaolincoding.com//picgo/1741336124270-c0328978-0eed-4409-bc42-dfaddf10a373.png" alt="img"></p><p>Paxos算法的流程如下（以Basic Paxos 算法为例子）：</p><ul><li>准备阶段：提议者选择一个提案编号，并向所有接受者发送准备请求。提案编号是一个全局唯一的、单调递增的数字。接受者收到准备请求后，如果提案编号大于它之前接受过的任何提案编号，它会承诺不再接受编号小于该提案编号的提案，并返回它之前接受过的最大编号的提案信息（如果有）。</li><li>接受阶段：如果提议者收到了超过半数接受者的响应，它会根据这些响应确定要提议的值。如果接受者返回了之前接受过的提案信息，提议者会选择编号最大的提案中的值作为要提议的值；如果没有，提议者可以选择自己的值。提议者向所有接受者发送接受请求，包含提案编号和要提议的值。</li><li>学习阶段：当提议者收到超过半数接受者对某个提案的接受响应时，该提案被认为达成共识。学习者通过接受者的通知得知达成共识的值。</li></ul><p>对比总结</p><ul><li><strong>Raft</strong> 更易于理解和实现，它将共识过程分解为选举和日志复制两个相对独立的子问题，并且对选举超时时间等参数进行了明确的定义和限制，降低了算法的复杂度。</li><li><strong>Paxos</strong> 是一种更通用、更基础的共识算法，它的理论性更强，在学术界有广泛的研究和应用。但 Paxos 的实现相对复杂，理解和调试难度较大。</li></ul><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>单体架构特点:简单方便,利于部署,高度耦合,扩展性差</p><p>分布式架构:松耦合,扩展性好,但架构复杂</p><p>微服务是一种良好架构设计的分布式架构方案,微服务架构特征:</p><ul><li>单一职责: 微服务拆分粒度更小,每个服务对应唯一的业务能力,做到单一职责,避免重复业务开发.</li><li>面向服务:对外暴露业务接口</li><li>自治:部署独立、数据独立、技术独立</li><li>隔离性强:服务调用做好隔离、容错、降级,避免出现级联问题</li></ul><h3 id="微服务结构"><a href="#微服务结构" class="headerlink" title="微服务结构"></a>微服务结构</h3><p><img data-src="https://cdn.xiaolincoding.com//picgo/1715933382453-968d55a3-059b-423d-9f67-0ebf732fc400.png" alt="img" style="zoom: 67%;" /></p><p>需要<strong>注册中心</strong>注册并管理服务<strong>,配置中心</strong>对服务进行集中配置,服务之间的远程调用,<strong>API服务网关</strong>进行处理请求与路由,<strong>负载均衡</strong>用于将网络流量有效地分配到多个服务实例上，以优化资源利用、最大化吞吐量并避免任何单一实例过载,以及<strong>服务监控与保护</strong>,对系统进行链路保护，避免服务雪崩的问题</p><p>具体微服务框架包括Dubbo,<strong>SpringCloud</strong>,SpringCloudAlibaba.</p><p><img data-src="https://s2.loli.net/2025/08/10/voKC1ztFXBRIeh5.png" alt="image-20250810133810872"></p><p>Spring Boot是用于构建单个Spring应用的框架，而Spring Cloud则是用于构建分布式系统中的微服务架构的工具，Spring Cloud提供了服务注册与发现、负载均衡、断路器、网关等功能。</p><p><strong>服务拆分</strong></p><ul><li>单一职责,不同微服务,不要重复开发相同业务</li><li>微服务数据独立,不要访问其他微服务的数据库</li><li>微服务将自己的业务暴露为接口供其他微服务调用</li></ul><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>常用的注册中心组件包括Eureka以及Nacos.</p><p>在Eureka中,微服务角色分为eureka server和sureka client,后者分为服务提供者和服务消费者.</p><p><strong>消费者如何找到服务提供者</strong>,<strong>如何从多个服务进行选择</strong>,<strong>如何知道该服务提供者是否仍可用</strong></p><p>服务提供者启动时会像服务中心注册自身信息,服务中心会保存这些信息,消费者根据服务名称向服务中心拉取提供者信息.服务消费者利用负载均衡算法从服务列表中挑选一个. </p><p>服务提供者每过一段时间向Eureka Server发送心跳请求报告健康状态,然后Eureka更新记录服务列表的信息,心跳不正常会被剔除,消费者就能拉取到最新的信息.</p><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h4><p>引入相关stater,创建eureka-server,进行配置服务端口和对应地址信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--eureka服务端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span> <span class="comment"># 服务端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eurekaserver</span> <span class="comment"># eureka的服务名称</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span>  <span class="comment"># eureka的地址信息</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><p>加上注解<code>@EnableEurekaServer</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@EnableEurekaServer</span><br><span class="line">@SpringBootApplication</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaApplication</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.<span class="built_in">run</span>(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端也类似,将相关微服务引入然后配置服务端ip与端口地址</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--eureka客户端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="服务发现与负载均衡"><a href="#服务发现与负载均衡" class="headerlink" title="服务发现与负载均衡"></a>服务发现与负载均衡</h4><p>将其他服务硬编码的请求ip地址改为对应的服务名,同时在restTemplate的bean上加@loadBalanced注解. </p><p>请求会被拦截器拦截,然后解析其中的服务名拉取服务列表,得到提供相同服务的若干节点,然后做负载均衡.</p><p><img data-src="https://s2.loli.net/2025/08/10/NHRvX86mQrnxDpK.png" alt="image-20250810152040203"></p><p><strong>Ribbon默认的负载均衡策略</strong></p><p><img data-src="https://s2.loli.net/2025/08/10/59dSqPhXMoQ8cvD.png" alt="image-20250810152318854"></p><p>修改负载均衡策略方法:1. 创建bean 2.配置文件中配置</p><p>此外Eureka默认懒加载,在第一服务调用时才会去加载拉取服务中心相关服务信息.可以开启饥饿加载,启动服务中心就进行加载ribbon客户端方便负载均衡.</p><p><img data-src="https://s2.loli.net/2025/08/10/t7QDqlGs6oMVf9d.png" alt="image-20250810153028389"></p><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><p>相比Eureka功能更多.除了服务注册和发现,也支持集中式配置,服务降级等.</p><p>Nacos中客户端的服务消费者在<strong>订阅相关服务并接受推送以及定时拉取相关服务</strong>列表后会存入缓存,</p><p>工作流程如下：</p><ol><li><strong>服务注册</strong>：服务提供者启动时，会向 Nacos 服务端注册自己的实例信息（IP、端口、服务名等）。</li><li><strong>服务订阅</strong>：服务消费者启动时，<strong>会向 Nacos 服务端订阅它所需要调用的服务</strong>。</li><li><strong>推送更新</strong>：当服务提供者的实例列表发生变化（如新实例上线或旧实例下线），Nacos 服务端会实时将最新的实例列表推送给所有订阅了该服务的消费者。(Nacos相比eureka差别)</li><li><strong>客户端缓存</strong>：消费者客户端会维护一个本地缓存，存储最新的服务实例列表。(定时pull)</li><li><strong>远程调用</strong>：当消费者需要调用服务时，它会从本地缓存中获取服务实例列表，然后通过负载均衡策略（如轮询、随机等）选择一个健康的实例进行调用。这个过程通常由 <strong>OpenFeign</strong> 或 <strong>RestTemplate</strong> 这样的声明式客户端自动完成。</li></ol><p>与Eureka差别是,nacos将服务提供者分为<strong>临时实例和非临时实例</strong>.  临时实例采用心跳检测,服务提供者每过一段时间发送心跳给注册中心,当超时将临时实例从服务列表中剔除. 非临时实例在心跳超时后,会去主动检测,如果未响应,等待该非临时节点. </p><p>Nacos可以配置节点的集群属性,跟地域位置相关,因为相同地域同一集群的服务器之间通信速度更快.</p><p>一个服务对应多个集群,一个集群包含多个节点,可以根据服务器地域属性配置集群</p><p><img data-src="https://s2.loli.net/2025/08/10/xCJktiVqD9IcgwK.png" alt="image-20250810154729061"></p><p>nacos默认有限选择与服务消费者相同地域属性的服务提供方,在本地集群的多个节点中随机选择.</p><p><img data-src="https://s2.loli.net/2025/08/10/SYjCDIFQaGe9knP.png" alt="image-20250810155533106"></p><p><img data-src="https://s2.loli.net/2025/08/10/Gf9Dq8rRAU76p5g.png" alt="image-20250810162319041"></p><h4 id="环境隔离"><a href="#环境隔离" class="headerlink" title="环境隔离"></a>环境隔离</h4><p>Nacos支持环境隔离</p><p><img data-src="https://s2.loli.net/2025/08/10/9X4fNq7vQOpzsDl.png" alt="image-20250810160607335"></p><h4 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h4><ul><li>配置更改热更新</li></ul><p>在nacos中可以添加配置,设置配置名称(与需要的服务名称相同)与需要热更新的内容.</p><p>引入nacos-config的依赖,此外为了让服务启动时知道nacos地址方便读取nacos中热更新配置,需要在<code>bootstrap.yaml</code>(其优先级更高)中配置服务名称以及nacos地址等信息.</p><p><img data-src="https://s2.loli.net/2025/08/10/cinjxrXePTu4ymS.png" alt="image-20250810164123884"></p><p>使用时类似使用<code>application.yaml</code>文件中的变量,使用<code>@Value</code>获取对应值.</p><p><img data-src="https://s2.loli.net/2025/08/10/4jGMJozcUObNIyV.png" alt="image-20250810164415915"></p><p>为了实现配置文件变更,微服务无需重启就可以感知,还需要在@Value注解所在类加上<code>@RefreshScope</code>注解,实现在nacos中更改配置进行更新. 还可以使用<code>@ConfigurationProperties</code><strong>.</strong></p><p><strong>多环境配置共享</strong></p><p>在配置nacos文件名称时,没有后缀的配置,例如<code>userservice.yml</code>一定会被加载.如果有对应的环境,比如<code>dev</code>,就会优先读取<code>userservice-dev.yml</code>.</p><p><img data-src="https://s2.loli.net/2025/08/10/v4KsJwcHV3GxQIO.png" alt="image-20250810165809462"></p><h3 id="负载均衡有哪些算法？"><a href="#负载均衡有哪些算法？" class="headerlink" title="负载均衡有哪些算法？"></a>负载均衡有哪些算法？</h3><ul><li>简单轮询：将请求按顺序分发给后端服务器上，不关心服务器当前的状态，比如后端服务器的性能、当前的负载。</li><li>加权轮询：根据服务器自身的性能给服务器设置不同的权重，将请求按顺序和权重分发给后端服务器，可以让性能高的机器处理更多的请求</li><li>简单随机：将请求随机分发给后端服务器上，请求越多，各个服务器接收到的请求越平均</li><li>加权随机：根据服务器自身的性能给服务器设置不同的权重，将请求按各个服务器的权重随机分发给后端服务器</li><li>一致性哈希：根据请求的客户端 ip、或请求参数通过哈希算法得到一个数值，利用该数值取模映射出对应的后端服务器，这样能保证同一个客户端或相同参数的请求每次都使用同一台服务器</li><li>最小活跃数：统计每台服务器上当前正在处理的请求数，也就是请求活跃数，将请求分发给活跃数最少的后台服务器</li></ul><h3 id="如何实现一直均衡给一个用户？"><a href="#如何实现一直均衡给一个用户？" class="headerlink" title="如何实现一直均衡给一个用户？"></a>如何实现一直均衡给一个用户？</h3><p>可以通过「一致性哈希算法」来实现，根据请求的客户端 ip、或请求参数通过哈希算法得到一个数值，利用该数值取模映射出对应的后端服务器，这样能保证同一个客户端或相同参数的请求每次都使用同一台服务器</p><h3 id="服务调用Feign"><a href="#服务调用Feign" class="headerlink" title="服务调用Feign"></a>服务调用Feign</h3><p><strong>Feign</strong> 是由 Netflix 开发并开源的一个声明式 HTTP 客户端。它的核心思想是让你通过定义一个接口，并使用注解来描述 HTTP 请求，而 Feign 会在运行时自动生成一个代理实现类来执行这些请求。</p><p><strong>OpenFeign</strong> 是在 Netflix Feign 停止维护后，由开源社区和 Spring Cloud 团队接手并继续维护和发展的项目。它是在 Feign 的基础上进行了<strong>封装和增强</strong>，使其能够更好地融入到 Spring Cloud 和 Spring Boot 的生态系统中。</p><p><strong>核心特点：</strong></p><ul><li><strong>Spring 生态集成</strong>：OpenFeign 最显著的特点是深度集成了 Spring 框架。它支持 Spring MVC 的注解（如 <code>@RequestMapping</code>, <code>@GetMapping</code> 等），这让开发者可以使用与编写 REST Controller 完全相同的注解来定义客户端接口，大大降低了学习成本。</li><li><strong>独立于 Netflix OSS</strong>：OpenFeign 不再强制依赖于 Netflix OSS 的组件。在 Spring Cloud 的新版本中，它与 Spring Cloud LoadBalancer（替代 Ribbon）和 Spring Cloud CircuitBreaker（替代 Hystrix）等组件无缝集成，提供了更灵活和现代化的解决方案。</li><li><strong>更活跃的社区</strong>：作为 Spring Cloud 官方维护的项目，OpenFeign 拥有更活跃的社区支持、更频繁的更新和更好的文档。</li></ul><h3 id="网关Gateway"><a href="#网关Gateway" class="headerlink" title="网关Gateway"></a>网关Gateway</h3><p>网关的主要职责是作为微服务架构的<strong>入口点</strong>，它将复杂的内部微服务结构对客户端隐藏起来。</p><ul><li>身份认证与权限校验</li><li>服务路由、负载均衡</li><li>请求限流</li></ul><p>常用的组件有Zuul以及SpringCloud Gateway.</p><p>引入相关以来后,进行路由配置,需要声明nacos地址,网关服务端口和名称. 然后配置路由规则,到某个服务. 配置uri与对应的路由断言<code>predicates</code>. 外部请求到达网关后,根据uri与对应规则是否匹配.比如<code>/user/**</code>. 网关路由配置内容包括:路由id,路由目的地uri,以及路由断言匹配请求地址,路由过滤器.</p><p><img data-src="https://s2.loli.net/2025/08/10/NAzKq1UZCvfTFBs.png" alt="image-20250810173600658"></p><h4 id="路由过滤器配置"><a href="#路由过滤器配置" class="headerlink" title="路由过滤器配置"></a>路由过滤器配置</h4><p>GatewayFilter对进入网关的请求和微服务响应做处理. 有添加请求头,请求参数以及响应头的过滤器.</p><p><img data-src="https://s2.loli.net/2025/08/10/K2ILHxDQukbj1Mg.png" alt="image-20250810174117515"></p><p>在配置文件中添加</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">routes:</span></span><br><span class="line"><span class="string">-xxx</span></span><br><span class="line">    <span class="string">-filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=key,val</span> <span class="comment"># 只对某个路由起作用</span></span><br><span class="line"><span class="attr">default-filters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">xx</span> <span class="comment">#全局过滤器</span></span><br></pre></td></tr></table></figure><h4 id="全局过滤器GlobalFilter"><a href="#全局过滤器GlobalFilter" class="headerlink" title="全局过滤器GlobalFilter"></a>全局过滤器GlobalFilter</h4><p>全局过滤器的逻辑需要自己代码实现,处理逻辑更灵活</p><p><img data-src="https://s2.loli.net/2025/08/10/QN5KFwRfBvVZcpJ.png" alt="image-20250810174728714"></p><p>globalfilter声明式注明顺序,而gatewayfilter的默认执行顺序是声明时的顺序,从0开始</p><p><img data-src="https://s2.loli.net/2025/08/10/bc8Kkw3iOYqrHS2.png" alt="image-20250810175224223"></p><h3 id="CORS跨域处理"><a href="#CORS跨域处理" class="headerlink" title="CORS跨域处理"></a>CORS跨域处理</h3><p>跨域问题:<strong>浏览器</strong>禁止请求的发起者与服务端发生跨域<strong>ajax请求</strong>,请求被浏览器拦截的问题.</p><p>跨域: 域名不同,端口不同,协议不同.</p><p>在网关中进行配置</p><p><img data-src="https://s2.loli.net/2025/08/10/clsJUIbdZzFCX3f.png" alt="image-20250810180804958"></p><h3 id="链路监控与保护-Sentinel"><a href="#链路监控与保护-Sentinel" class="headerlink" title="链路监控与保护 Sentinel"></a>链路监控与保护 Sentinel</h3><p>在微服务架构中，<strong>雪崩问题（Circuit Breaker）</strong> 是一个非常严重且常见的问题。它描述了一种故障蔓延的现象：一个微服务的失败导致了整个系统的级联失败，就像雪崩一样迅速且难以控制。</p><p><strong>雪崩问题的形成原因</strong></p><p>雪崩问题通常发生在服务间的依赖调用中。它的形成主要有以下几个原因：</p><ol><li><strong>服务调用阻塞</strong> 当服务 A 调用服务 B 时，<strong>如果服务 B 因某种原因（如网络延迟、服务器过载）响应缓慢，那么服务 A 的请求线程就会长时间处于等待状态。如果有大量请求同时涌入，服务 A 的所有线程资源（如线程池）都可能被耗尽，导致服务 A 无法处理任何新请求</strong>，最终自身也陷入瘫痪。</li><li><strong>线程池耗尽</strong> 在许多微服务框架中，服务调用通常使用独立的线程池来管理。如果某个依赖的服务出现问题，所有相关的调用线程都会被阻塞。这会导致整个线程池被耗尽，进而影响到所有依赖该服务的上游服务。</li><li><strong>服务高负载</strong> 当某个微服务因流量突增而达到处理瓶颈时，它的响应时间会变长。这会导致上游服务的请求线程被阻塞，进而影响更多的服务，形成连锁反应。</li></ol><h4 id="解决雪崩问题的常见方式"><a href="#解决雪崩问题的常见方式" class="headerlink" title="解决雪崩问题的常见方式"></a>解决雪崩问题的常见方式</h4><ol><li>超时处理,请求超过一定时间没有相应就返回错误信息</li><li>舱壁模式(线程隔离),限定每个业务使用的线程数,避免耗尽整个tomcat整个资源.其核心思想是<strong>为每个依赖服务分配独立的线程池</strong>。这样，即使一个服务出现故障导致其线程池被耗尽，也不会影响到调用其他服务的线程池，从而避免了故障的扩散。</li><li>熔断降级,由断路器统计业务执行的一场比例,超出阈值拦截该业务一切请求.当熔断器被打开或服务调用失败时，降级机制会提供一个备选方案。例如，调用服务 A 失败时，我们可以不返回一个错误，而是返回一个缓存中的数据、一个默认值或者一个友好的提示信息。这保证了用户体验，并减少了故障对整体业务的影响。</li><li>流量控制,限制业务访问的QPS,避免服务因流量突增而故障.</li></ol><p><img data-src="https://s2.loli.net/2025/08/10/C3GAh9LzBwYSxOX.png" alt="image-20250810192830886"></p><h4 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h4><p>Sentinel 以<strong>流量</strong>为切入点，提供了以下几个维度的保护：</p><ul><li><strong>流量控制（限流）</strong>：当请求流量超过设定的阈值时，Sentinel 会对多余的请求进行限制。它可以基于 QPS（每秒查询数）、并发线程数等维度来控制流量，并提供多种控制效果，如直接拒绝、排队等待等。</li><li><strong>熔断降级（Circuit Breaking）</strong>：当依赖的下游服务出现故障或响应延迟过高时，为了防止故障扩散，Sentinel 会自动熔断对该服务的调用。在一段时间内，所有对该服务的请求都会直接失败，直到服务恢复正常，熔断器才会进入半开状态进行探测。</li><li><strong>系统自适应保护</strong>：Sentinel 不仅关注单一资源的流量，还能从整个系统的角度进行保护。当系统负载（如 CPU 使用率、Load 等）过高时，Sentinel 会自动拒绝部分请求，以确保系统不会因过载而崩溃。</li><li><strong>热点参数限流</strong>：针对特定的热点数据（如某个商品 ID、某个用户 ID），Sentinel 可以对其进行单独的限流，防止因单个热点数据引发的突发流量压垮系统。</li></ul><p><img data-src="https://s2.loli.net/2025/08/10/fK2CXIRe58SPQjt.png" alt="image-20250810192939284"></p><p>Sentinel提供了五种核心规则来保护你的应用：</p><ul><li><strong>流量控制 (Flow Control)</strong>：<ul><li><strong>作用</strong>：控制一个资源的访问流量，防止突发流量压垮服务。</li><li><strong>关键</strong>：基于QPS（每秒请求数）或并发线程数进行限流。</li><li><strong>限流效果</strong>：<ul><li><strong>快速失败 (Fail-fast)</strong>：默认模式，超过阈值立即拒绝。</li><li><strong>排队等待 (Wait)</strong>：超过阈值的请求会进入队列，按固定速率处理，平滑流量。</li><li><strong>慢启动 (Warm-up)</strong>：流量阈值在一定时间内逐渐增加，给系统一个预热时间，防止冷系统被瞬间打垮。</li></ul></li></ul></li><li><strong>熔断降级 (Circuit Breaking)</strong>：<ul><li><strong>作用</strong>：当依赖的下游服务出现故障时，主动断开对该服务的调用，防止故障扩散。</li><li><strong>关键</strong>：<ul><li><strong>慢调用比率 (Slow Request Ratio)</strong>：当服务的平均响应时间（RT）超过阈值且失败比率达到一定值时，触发熔断。</li><li><strong>异常比率 (Error Ratio)</strong>：当服务的异常比率达到阈值时，触发熔断。</li><li><strong>异常数 (Error Count)</strong>：当服务的异常数在指定时间窗口内超过阈值时，触发熔断。</li></ul></li><li><strong>状态</strong>：<strong>闭合 (Closed)</strong> -&gt; <strong>打开 (Open)</strong> -&gt; <strong>半开 (Half-Open)</strong>。</li></ul></li><li><strong>系统自适应保护 (System Adaptive Protection)</strong>：<ul><li><strong>作用</strong>：从整个系统的角度进行保护，防止系统因过载而崩溃。</li><li><strong>关键</strong>：基于系统的整体负载（如CPU使用率、系统平均Load等）来动态调整限流阈值，当系统指标超过设定阈值时，拒绝新的请求。</li></ul></li><li><strong>热点参数限流 (Hotspot Parameter Flow Control)</strong>：<ul><li><strong>作用</strong>：针对资源中的热点参数进行限流，如某个商品ID、某个用户ID。</li><li><strong>关键</strong>：可以对单个热点参数设置独立的限流规则，避免因单个热点数据引发的流量高峰影响整个系统。</li></ul></li><li><strong>授权规则 (Authority Rules)</strong>：<ul><li><strong>作用</strong>：根据请求的来源（如IP、服务名）进行访问控制，可以设置黑名单或白名单。</li></ul></li></ul><ol><li>工作原理与架构</li></ol><ul><li><strong>滑动窗口（Sliding Window）</strong>：Sentinel的核心流量统计算法。它<strong>将时间窗口划分为多个小的时间片，实时统计和聚合请求数据</strong>，从而实现对QPS和并发线程数的精准控制。</li><li><strong>责任链模式（Slot Chain）</strong>：Sentinel的内部架构是基于责任链模式设计的。所有请求在进入和离开资源时，都会经过一系列的<code>Slot</code>（插槽），每个<code>Slot</code>负责不同的功能，如<code>统计（StatisticSlot）</code>、<code>流量控制（FlowSlot）</code>、<code>熔断降级（DegradeSlot）</code>等。</li><li><strong>控制台 (Dashboard)</strong>：Sentinel提供了一个轻量级的Web控制台，用于实时监控、动态配置和管理规则。它使得Sentinel的规则管理变得非常方便，无需重启应用即可生效。</li></ul><h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><p>Seata 是一款由阿里巴巴开源的<strong>分布式事务解决方案</strong>。它的核心目标是在微服务架构下，为开发者提供一种高性能、简单易用的方式来解决<strong>分布式事务</strong>带来的数据一致性问题。</p><p>简单来说，当一个业务操作涉及多个微服务和多个数据库时，如何保证这些操作要么全部成功，要么全部失败，这就是分布式事务要解决的问题。Seata 提供了多种事务模式来处理不同的业务场景。</p><h3 id="Seata-的三大核心组件"><a href="#Seata-的三大核心组件" class="headerlink" title="Seata 的三大核心组件"></a>Seata 的三大核心组件</h3><p>Seata 的架构由三个主要组件构成，它们共同协作来管理和协调分布式事务：</p><ol><li><strong>Transaction Coordinator (TC)</strong>：<strong>事务协调者</strong>。这是一个独立的、中心化的服务，负责维护和协调全局事务的状态。它接收事务的注册、提交或回滚请求，并向所有参与事务的微服务发送指令。</li><li><strong>Transaction Manager (TM)</strong>：<strong>事务管理器</strong>。定义全局事务的范围,内嵌在业务应用中，负责向 TC 开启、提交或回滚一个<strong>全局事务</strong>。它定义了一个分布式事务的边界。</li><li><strong>Resource Manager (RM)</strong>：<strong>资源管理器</strong>。管理分支事务处理的资源,也内嵌在业务应用中，负责管理<strong>分支事务</strong>。它与 TC 沟通，注册和报告分支事务的状态，并根据 TC 的指令来提交或回滚本地事务。</li></ol><p>这三个组件形成了一个完整的分布式事务管理框架。</p><p><img data-src="https://s2.loli.net/2025/08/10/OKEenToSQI31jBH.png" alt="image-20250810203459835"></p><h3 id="Seata-的关键事务模式"><a href="#Seata-的关键事务模式" class="headerlink" title="Seata 的关键事务模式"></a>Seata 的关键事务模式</h3><p>Seata 提供了多种事务模式，每种模式都适用于不同的业务场景，它们的核心区别在于如何实现<strong>两阶段提交</strong>。</p><h4 id="1-AT-模式-Automatic-Transaction"><a href="#1-AT-模式-Automatic-Transaction" class="headerlink" title="1. AT 模式 (Automatic Transaction)"></a>1. AT 模式 (Automatic Transaction)</h4><p>这是 Seata <strong>最推荐</strong>和<strong>最常用</strong>的模式，因为它对业务代码的侵入性最小。</p><ul><li><strong>工作原理</strong>：AT 模式基于支持本地 ACID 事务的关系型数据库。<ul><li><strong>一阶段</strong>：业务 SQL 操作和 Seata 的<strong>回滚日志</strong>在同一个本地事务中提交。在本地事务提交前，Seata 会拦截 SQL，并记录数据变更前后的镜像（before image, after image）。</li><li><strong>二阶段</strong>：<ul><li><strong>提交</strong>：TC 收到所有分支事务成功的消息后，直接通知 RM 提交。RM 异步批量清理回滚日志，这个过程非常快。</li><li><strong>回滚</strong>：如果某个分支事务失败，TC 会通知所有 RM 进行回滚。RM 会根据一阶段记录的回滚日志，自动生成补偿 SQL 来恢复数据。</li></ul></li></ul></li><li><strong>特点</strong>：对开发者来说几乎是透明的，就像使用本地事务一样简单。它通过全局锁来保证事务间的写隔离。</li></ul><h4 id="2-TCC-模式-Try-Confirm-Cancel"><a href="#2-TCC-模式-Try-Confirm-Cancel" class="headerlink" title="2. TCC 模式 (Try-Confirm-Cancel)"></a>2. TCC 模式 (Try-Confirm-Cancel)</h4><p>TCC 模式是一种经典的分布式事务模型，它对业务代码有侵入性，需要开发者自己实现三个阶段：</p><ul><li><strong>Try</strong>：尝试执行。它会检查并预留业务资源，但并不真正执行业务操作。例如，预扣库存。</li><li><strong>Confirm</strong>：确认执行。如果所有分支事务的 <code>Try</code> 阶段都成功，TC 会通知所有 RM 执行 <code>Confirm</code> 逻辑，真正提交业务操作。</li><li><strong>Cancel</strong>：取消执行。如果任何一个分支事务的 <code>Try</code> 阶段失败，TC 会通知所有 RM 执行 <code>Cancel</code> 逻辑，回滚已预留的资源。</li><li><strong>特点</strong>：要求开发者对业务逻辑有清晰的理解，并手动实现 Try、Confirm 和 Cancel 三个方法。它的优点是性能高，可以实现更细粒度的资源控制。</li></ul><h4 id="3-Saga-模式"><a href="#3-Saga-模式" class="headerlink" title="3. Saga 模式"></a>3. Saga 模式</h4><p>Saga 模式是 Seata 提供的长事务解决方案，它不依赖于两阶段提交，而是通过一系列<strong>本地事务</strong>来保证最终一致性。</p><ul><li><strong>工作原理</strong>：<ul><li>一个分布式事务被分解为一系列本地事务。</li><li>每个本地事务都有一个对应的<strong>补偿（Compensation）</strong>操作。</li><li>如果某个本地事务失败，它会触发前面所有已成功的本地事务执行它们的补偿操作来回滚。</li></ul></li><li><strong>特点</strong>：特别适合事务执行时间长、业务流程复杂的场景。Seata 提供了编排工具来简化 Saga 模式的实现。</li></ul><h4 id="4-XA-模式"><a href="#4-XA-模式" class="headerlink" title="4. XA 模式"></a>4. XA 模式</h4><p>XA 模式是基于 XA 协议实现的，它是一个由数据库厂商支持的、严格的两阶段提交协议。</p><ul><li><strong>特点</strong>：XA 模式能够严格保证 ACID 特性，对业务代码零侵入，但性能相对较差，因为它在整个事务过程中会锁定数据库资源。</li></ul><p>此外还有<strong>配置中心</strong>(SpringCloudConfig)集中管理各节点配置文件的问题,<strong>集中式日志管理</strong>(ELK技术栈)收集各节点日志并统一管理的问题.这里不深入.</p><ul><li><strong>配置中心</strong>：配置中心主要解决了「<strong>如何集中管理各节点配置文件的问题</strong>」，在微服务架构下，所有的微服务节点都包含自己的各种配置文件，如jdbc配置、自定义配置、环境配置、运行参数配置等。要知道有的微服务可能可能有几十个节点，如果将这些配置文件分散存储在节点上，发生配置更改就需要逐个节点调整，将给运维人员带来巨大的压力。配置中心便由此而生，通过部署配置中心服务器，将各节点配置文件从服务中剥离，集中转存到配置中心。一般配置中心都有UI界面，方便实现大规模集群配置调整。</li><li><strong>集中式日志管理</strong>：集中式日志主要是解决了「<strong>如何收集各节点日志并统一管理的问题</strong>」。微服务架构默认将应用日志分别保存在部署节点上，当需要对日志数据和操作数据进行数据分析和数据统计时，必须收集所有节点的日志数据。那么怎么高效收集所有节点的日志数据呢？业内常见的方案有ELK、EFK。通过搭建独立的日志收集系统，定时抓取各节点增量日志形成有效的统计报表，为统计和分析提供数据支撑。</li></ul><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ol><li><a href="https://www.bilibili.com/video/BV1LQ4y127n4">https://www.bilibili.com/video/BV1LQ4y127n4</a></li><li><a href="https://www.bilibili.com/video/BV1kH4y1S7wz">https://www.bilibili.com/video/BV1kH4y1S7wz</a> 介绍分布式事务</li><li><a href="https://www.bilibili.com/video/BV1UJc2ezEFU">https://www.bilibili.com/video/BV1UJc2ezEFU</a></li><li><a href="https://www.bilibili.com/video/BV1Q4411y7ip">https://www.bilibili.com/video/BV1Q4411y7ip</a></li><li><a href="https://xiaolincoding.com/interview/spring.html">https://xiaolincoding.com/interview/spring.html</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;单体架构将业务所有功能集中在一个项目开发,通过打成一个包部署. 架构简单,部署成本低.但是功能之间耦合度高,而&lt;strong&gt;分布式架构根据业务功能对系统进行拆分,每个业务模块作为独立项目开发,有利于降低服务耦合以及服务拓展&lt;/strong&gt;.&lt;br&gt;</summary>
    
    
    
    
    <category term="springcloud" scheme="https://www.sekyoro.top/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>c++刷leetcode注意事项</title>
    <link href="https://www.sekyoro.top/2025/07/31/c-%E5%88%B7leetcode%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://www.sekyoro.top/2025/07/31/c-%E5%88%B7leetcode%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2025-07-31T02:45:47.000Z</published>
    <updated>2025-08-12T13:16:41.882Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近在刷leetcode题目,积累了一些提醒以及用c++STL刷题经验,这里记录一下<br><span id="more"></span></p><h1 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h1><h2 id="数组与字符串"><a href="#数组与字符串" class="headerlink" title="数组与字符串"></a>数组与字符串</h2><blockquote><p>在使用vector和string的方法以及stl包含的方法时,比如find,insert,erase,substr方法的参数类型与返回值类型. 有的支持迭代器,有的重载了索引类型等</p></blockquote><h2 id="双指针与数组-链表"><a href="#双指针与数组-链表" class="headerlink" title="双指针与数组/链表"></a>双指针与数组/链表</h2><blockquote><p>在对链表进行操作时，一种常用的技巧是添加一个哑节点（dummy node），它的 next 指针指向链表的头节点。这样一来，我们就不需要对头节点进行特殊的判断了。</p></blockquote><h3 id="删除链表倒数第n个节点"><a href="#删除链表倒数第n个节点" class="headerlink" title="删除链表倒数第n个节点"></a>删除链表倒数第n个节点</h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 延迟n步的节点</span></span><br><span class="line">       <span class="comment">// 双指针和哑节点</span></span><br><span class="line">       <span class="comment">// 哑节点</span></span><br><span class="line">       ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode* first = head;</span><br><span class="line">        ListNode* second = dummy;</span><br><span class="line">        <span class="comment">// 不首先遍历获得节点总数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i) &#123;</span><br><span class="line">        <span class="comment">// 指向第n个节点</span></span><br><span class="line">            first = first-&gt;next; <span class="comment">// first和second之间有n-1个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(first) &#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 快慢指针</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slowPtr = head,*fastPtr = head;</span><br><span class="line">        <span class="keyword">while</span>(fastPtr &amp;&amp; fastPtr-&gt;next!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slowPtr = slowPtr-&gt;next;</span><br><span class="line">            fastPtr = fastPtr-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slowPtr == fastPtr) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 快慢指针</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slowPtr = head,*fastPtr = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fastPtr!=slowPtr) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fastPtr== <span class="literal">nullptr</span> || fastPtr-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slowPtr = slowPtr-&gt;next;</span><br><span class="line">            fastPtr = fastPtr-&gt;next-&gt;next;</span><br><span class="line">           </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h3><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p><strong>只有当链表 headA 和 headB 都不为空时，两个链表才可能相交</strong>。因此首先判断链表 headA 和 headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null。</p><p>当链表 headA 和 headB 都不为空时，创建两个指针 pA 和 pB，初始时分别指向两个链表的头节点 headA 和 headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：</p><p>每步操作需要同时更新指针 pA 和 pB。</p><p>如果指针 pA 不为空，则将指针 pA 移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点。</p><p>如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。</p><p>当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者 null。</p><h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h3><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h3><h3 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h3><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// i行移动到n-1-i列</span></span><br><span class="line">        <span class="comment">//  j列移动到j行</span></span><br><span class="line">        <span class="comment">// matrix_new[col][n−row−1]=matrix[row][col]</span></span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n/<span class="number">2</span>;++i) &#123;</span><br><span class="line">            <span class="comment">// 针对每一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;(<span class="number">1</span>+n)/<span class="number">2</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                <span class="comment">// matrix_[i][j] = matrix[n-j-1][i]</span></span><br><span class="line">                matrix[i][j] = matrix[n-j<span class="number">-1</span>][i];</span><br><span class="line">                matrix[n-j<span class="number">-1</span>][i] = matrix[n-i<span class="number">-1</span>][n-j<span class="number">-1</span>];</span><br><span class="line">                matrix[n-i<span class="number">-1</span>][n-j<span class="number">-1</span>] = matrix[j][n-i<span class="number">-1</span>];</span><br><span class="line">                matrix[j][n-i<span class="number">-1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a>搜索二维矩阵</h3><p>编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列。</li><li>每列的元素从上到下升序排列。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; m &amp;&amp; y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[x][y] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (matrix[x][y] &gt; target) &#123;</span><br><span class="line">                --y;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ++x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="无重复字符最长字串"><a href="#无重复字符最长字串" class="headerlink" title="无重复字符最长字串"></a>无重复字符最长字串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">       unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; char_map;</span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> max_len&#123;&#125;;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> right = <span class="number">0</span>;right&lt;s.<span class="built_in">size</span>();right++) &#123;</span><br><span class="line">        <span class="keyword">char</span> current_char  = s.<span class="built_in">at</span>(right);</span><br><span class="line">           <span class="keyword">if</span>(char_map.<span class="built_in">count</span>(current_char)&amp;&amp; char_map[current_char] &gt;= left) &#123;</span><br><span class="line">            <span class="comment">// 遇到了重复字符,获取它上一次出现的索引并进行更新</span></span><br><span class="line">            left = char_map[current_char]+<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="comment">// 更新当前字符的最新索引</span></span><br><span class="line">            char_map[current_char] = right; <span class="comment">// 更新最新的索引</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len,right-left+<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">return</span> max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="固定大小窗口"><a href="#固定大小窗口" class="headerlink" title="固定大小窗口"></a>固定大小窗口</h3><h3 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h3><p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的 排列。如果是，返回 true ；否则，返回 false 。</p><p>换句话说，s1 的排列之一是 s2 的 子串 。</p><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><hr><p>二分查找（Binary Search），也叫折半查找，是一种在<strong>有序数组</strong>中查找特定元素的算法。它的核心思想是每次都通过比较中间元素，将搜索范围缩小一半，从而达到极高的查找效率。其时间复杂度为 O(logN)，这使得它在处理大规模有序数据时表现卓越。</p><p>二分查找的精髓在于其迭代地缩小搜索范围。无论具体问题如何，万变不离其宗的是以下几个要素：</p><ol><li><strong>明确搜索空间：</strong> 定义一个闭区间 <code>[left, right]</code>，表示当前可能包含目标解的范围。初始时，<code>left</code> 通常是数组的起始索引，<code>right</code> 是数组的结束索引。</li><li><strong>计算中间点：</strong> <code>mid = left + (right - left) / 2</code>。这种写法可以有效避免 <code>(left + right)</code> 可能导致的整数溢出，特别是在 <code>left</code> 和 <code>right</code> 都很大时。</li><li><strong>比较与决策：</strong> 将 <code>nums[mid]</code> 与目标值或某个条件进行比较。根据比较结果，有三种基本情况：<ul><li><strong>找到了目标值（或满足条件）：</strong> 直接返回 <code>mid</code> 或进行其他处理。</li><li><strong><code>nums[mid]</code> 太小了：</strong> 说明目标值（或满足条件的解）在 <code>mid</code> 的右侧，更新 <code>left = mid + 1</code>。</li><li><strong><code>nums[mid]</code> 太大了：</strong> 说明目标值（或满足条件的解）在 <code>mid</code> 的左侧，更新 <code>right = mid - 1</code> 或 <code>right = mid</code> (取决于具体问题)。</li></ul></li><li><strong>循环终止条件：</strong> 循环通常持续到 <code>left &lt;= right</code> 或 <code>left &lt; right</code>。循环结束后，<code>left</code> 和 <code>right</code> 的关系（例如 <code>left == right</code> 或 <code>left == right + 1</code>）将指示最终的搜索结果。</li></ol><p>在实际应用中，二分查找的循环终止条件和边界更新方式会根据“寻找什么”而略有不同。最常见的两种模式是：</p><ol><li><strong>查找特定值（或存在性）：</strong> 循环条件 <code>while (left &lt;= right)</code>，当 <code>left &gt; right</code> 时，表示整个搜索区间为空，未找到目标。<ul><li>如果 <code>nums[mid] == target</code>，返回 <code>mid</code>。</li><li>如果 <code>nums[mid] &lt; target</code>，<code>left = mid + 1</code>。</li><li>如果 <code>nums[mid] &gt; target</code>，<code>right = mid - 1</code>。</li><li><strong>特点：</strong> <code>left</code> 和 <code>right</code> 最终会越过彼此。</li></ul></li><li><strong>查找边界（第一个/最后一个满足条件的元素）：</strong> 循环条件 <code>while (left &lt; right)</code>，当 <code>left == right</code> 时，循环结束，<code>left</code>（或 <code>right</code>）就是所求的索引。<ul><li>如果 <code>nums[mid]</code> 满足条件：可能 <code>mid</code> 就是答案，也可能答案在 <code>mid</code> 的左侧。所以 <code>right = mid</code>。</li><li>如果 <code>nums[mid]</code> 不满足条件：答案肯定在 <code>mid</code> 的右侧。所以 <code>left = mid + 1</code>。</li><li><strong>特点：</strong> <code>left</code> 和 <code>right</code> 最终会收敛到同一个点。<strong>这种模式在寻找“第一个满足XX条件”或“最后一个满足XX条件”的问题中非常常见。</strong></li></ul></li></ol><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p><strong>单调栈（Monotonic Stack）是一种特殊的栈数据结构，它在保持栈内元素严格单调递增</strong>或<strong>严格单调递减</strong>的同时，遍历处理输入序列。这种数据结构非常适合解决与“下一个更大/更小元素”相关的序列问题，因为它可以高效地找到每个元素左边或右边第一个比它大或小的元素，而无需进行嵌套循环。</p><p>核心知识：工作原理</p><p>单调栈的核心思想是<strong>“当一个元素入栈时，将所有不满足单调性的元素都弹出”</strong>。</p><p>以<strong>单调递增栈</strong>（栈底到栈顶递增）为例：</p><ol><li><strong>遍历输入序列</strong>。</li><li><strong>当前元素 <code>x</code> 入栈</strong>：在 <code>x</code> 入栈之前，不断弹出栈顶元素 <code>y</code>，直到栈为空或 <code>y &lt; x</code>。</li><li><strong>为什么这样做？</strong><ul><li>对于每一个被弹出的元素 <code>y</code>，<code>x</code> 就是它右边第一个比它大的元素。</li><li>通过这种方式，我们可以在一次遍历中，为每个元素找到它右边的第一个更大元素，时间复杂度仅为 O(n)。</li></ul></li></ol><h3 id="LeetCode-经典题目"><a href="#LeetCode-经典题目" class="headerlink" title="LeetCode 经典题目"></a>LeetCode 经典题目</h3><p>单调栈在 LeetCode 上有许多经典应用，这些题目通常能让你深入理解其工作原理。</p><ol><li>每日温度</li></ol><p><strong>问题描述</strong>：给定一个整数数组 <code>temperatures</code>，表示每天的温度。返回一个数组，其中 <code>answer[i]</code> 是指在第 <code>i</code> 天之后，至少需要等待多少天才能等到更暖和的温度。如果该天之后不存在更暖和的温度，则 <code>answer[i]</code> 为 0。</p><p><strong>解题思路</strong>：</p><ul><li>我们维护一个<strong>单调递减栈</strong>，栈中存储的是元素的<strong>索引</strong>。栈底到栈顶的索引对应的温度是递减的。</li><li>遍历温度数组：<ul><li>如果当前温度 <code>temperatures[i]</code> 大于栈顶索引 <code>j</code> 对应的温度 <code>temperatures[j]</code>，说明我们找到了 <code>j</code> 右边第一个比它大的元素。</li><li>弹出栈顶索引 <code>j</code>，计算等待天数 <code>i - j</code>，并将其存入结果数组 <code>answer[j]</code>。</li><li>重复此过程，直到栈顶元素不比当前温度小。</li><li>最后，将当前索引 <code>i</code> 压入栈中。</li></ul></li><li>栈中剩下的索引，意味着它们右边没有比它们更大的元素，对应的 <code>answer</code> 值为 0。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LeetCode 739. 每日温度</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[s.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> prev_index = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                result[prev_index] = i - prev_index;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>柱状图中最大的矩形</li></ol><p><strong>问题描述</strong>：给定 <code>n</code> 个非负整数，表示一个柱状图，每个柱子的宽度为 1。找出这个柱状图中能形成的最大矩形面积。</p><p><strong>解题思路</strong>：</p><ul><li>要求最大矩形面积，可以转换为：对于每个柱子，找到以它为高的最大矩形。这个矩形的宽度由它左右两侧第一个比它低的柱子决定。</li><li>我们可以用两次单调栈遍历：<ol><li><strong>从左到右遍历</strong>，使用<strong>单调递增栈</strong>，找到每个柱子<strong>左边第一个比它低的柱子索引</strong>。</li><li><strong>从右到左遍历</strong>，使用<strong>单调递增栈</strong>，找到每个柱子<strong>右边第一个比它低的柱子索引</strong>。</li></ol></li><li>有了左右两边的索引，就可以计算以每个柱子为高的矩形面积，并找出最大值。</li></ul><p><strong>优化思路</strong>：</p><ul><li>可以只用<strong>一次</strong>单调栈遍历来解决。</li><li>依然使用<strong>单调递增栈</strong>存储索引。当 <code>heights[i]</code> 小于栈顶 <code>heights[top]</code> 时，<code>heights[top]</code> 就是一个潜在的高度。</li><li>此时，<code>heights[top]</code> 的右边界是 <code>i</code>，左边界是新的栈顶（如果栈不为空）或 -1。计算面积并更新最大值。</li></ul><ol><li>接雨水</li></ol><p><strong>问题描述</strong>：给定 <code>n</code> 个非负整数，表示一个柱状图，计算下雨后能接多少雨水。</p><p><strong>解题思路</strong>：</p><ul><li>可以用<strong>双指针</strong>或<strong>单调栈</strong>来解决。</li><li>使用<strong>单调递减栈</strong>存储索引。</li><li>遍历柱子数组：<ul><li>当 <code>heights[i]</code> 高于栈顶 <code>heights[top]</code> 时，说明 <code>heights[top]</code> 可能会形成一个凹槽。</li><li>弹出 <code>top</code>，它就是凹槽的底部。</li><li>新的栈顶 <code>s.top()</code> 是凹槽的左壁，<code>i</code> 是凹槽的右壁。</li><li>计算凹槽的高度 <code>min(heights[i], heights[s.top()]) - heights[top]</code>，宽度 <code>i - s.top() - 1</code>，并累加雨水。</li></ul></li></ul><h2 id="优先队列-堆"><a href="#优先队列-堆" class="headerlink" title="优先队列/堆"></a>优先队列/堆</h2><p><strong>优先队列</strong>是一种抽象数据类型（ADT），它的核心特征是：</p><ul><li>队列中的每个元素都有一个<strong>优先级</strong>。</li><li>队列总是按照优先级最高的元素进行出队（删除）操作。</li><li>元素的入队（插入）顺序不影响出队顺序，只与优先级有关。</li></ul><p>你可以想象一个医院的急诊室：医生总是优先处理病情最严重的病人，而不是先到诊的病人。这就是一个优先队列的典型例子。</p><p>优先队列通常分为两种类型：</p><ul><li><strong>最大优先队列：</strong> 优先级最高的元素是最大的元素。</li><li><strong>最小优先队列：</strong> 优先级最高的元素是最小的元素。</li></ul><h3 id="什么是堆？"><a href="#什么是堆？" class="headerlink" title="什么是堆？"></a>什么是堆？</h3><p><strong>堆</strong>是一种具体的数据结构，它通常是一个<strong>完全二叉树</strong>，并且满足特定的堆属性：</p><ul><li><strong>最大堆（Max Heap）：</strong> 任何一个父节点的值都<strong>大于或等于</strong>其子节点的值。因此，最大的元素总是在堆的根部。</li><li><strong>最小堆（Min Heap）：</strong> 任何一个父节点的值都<strong>小于或等于</strong>其子节点的值。因此，最小的元素总是在堆的根部。</li></ul><p>因为堆能够高效地找到最大或最小的元素，所以它成为了实现<strong>优先队列</strong>最常见、最有效的方式。在大多数编程语言中，当你使用“优先队列”时，底层往往就是一个堆。</p><p>堆可以通过完全二叉树实现堆排序.通过将数组构建成一个堆，然后不断地移除堆顶元素来完成排序。</p><p>堆排序主要分为两个步骤：</p><ol><li><strong>建堆（Heapify）：</strong> 将一个无序数组构建成一个堆。我们通常会构建一个<strong>最大堆（Max Heap）</strong>，这样数组中最大的元素就会被放在数组的第一个位置（即堆顶）。</li><li><strong>排序：</strong> 持续地从堆中移除最大的元素，并将其放到数组的正确位置上。</li></ol><p>堆排序的关键在于一个名为 <code>heapify</code> 的操作。这个函数的作用是，确保以一个节点为根的子树满足堆的性质。以最大堆为例，<code>heapify(arr, n, i)</code> 函数会比较节点 <code>i</code>、它的左子节点和右子节点，找到这三个节点中最大的元素，并将其放在节点 <code>i</code> 的位置。如果发生了交换，就会对被交换的子树递归地调用 <code>heapify</code>，直到整个子树都满足最大堆的性质。</p><p><code>heapify</code> 函数是堆排序的基础。它需要三个参数：数组 <code>arr</code>、堆的大小 <code>n</code>、以及要调整的子树的根节点索引 <code>i</code>。</p><p><code>heapSort</code> 函数会调用 <code>heapify</code> 来完成建堆和排序两个步骤。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆调整函数：将以 i 为根节点的子树调整为最大堆</span></span><br><span class="line"><span class="comment">// n 是堆的当前大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> largest = i;       <span class="comment">// 假设根节点是最大的</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;  <span class="comment">// 左子节点的索引</span></span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>; <span class="comment">// 右子节点的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较左子节点和根节点，更新 largest</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较右子节点和目前最大的节点，更新 largest</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最大的不是根节点，则进行交换</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[i], arr[largest]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归地对被交换的子树进行堆调整</span></span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 步骤1：建堆</span></span><br><span class="line"><span class="comment">// 从最后一个非叶子节点开始（索引为 n/2 - 1），</span></span><br><span class="line"><span class="comment">// 依次向上对每个子树进行堆调整，直到整个数组成为一个最大堆。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：排序</span></span><br><span class="line"><span class="comment">// 循环 n-1 次，每次从堆中移除一个最大元素并放到数组末尾</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 将当前堆顶（最大值）与堆的最后一个元素交换</span></span><br><span class="line">    <span class="comment">// 此时，最大的元素已经位于数组的正确位置</span></span><br><span class="line">    std::<span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新调整堆，忽略已经排序好的最后一个元素（i）</span></span><br><span class="line">    <span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划（Dynamic Programming，简称 DP）是一种通过将复杂问题分解成更小的<strong>重叠子问题</strong>来求解的算法思想。它的核心在于<strong>避免重复计算</strong>，通过存储子问题的解来提高效率。</p><p>掌握动态规划的关键，在于理解它解决的两大核心问题：</p><ol><li><strong>最优子结构（Optimal Substructure）：</strong> 一个问题的最优解可以通过其子问题的最优解来构造。</li><li><strong>重叠子问题（Overlapping Subproblems）：</strong> 在求解问题的过程中，需要多次计算同一个子问题。</li></ol><h3 id="动态规划的解题步骤"><a href="#动态规划的解题步骤" class="headerlink" title="动态规划的解题步骤"></a>动态规划的解题步骤</h3><p>解决一个动态规划问题，通常可以遵循以下四个步骤，这就像一个解题模板：</p><ol><li><strong>确定 DP 状态（State）：</strong><ul><li>状态是动态规划的核心。你需要定义一个数组或表格 <code>dp</code>，其中 <code>dp[i]</code> 或 <code>dp[i][j]</code> 代表了解决某个子问题的<strong>解</strong>。</li><li>状态的定义必须能够<strong>唯一</strong>且<strong>完整</strong>地描述一个子问题。</li><li><strong>例如：</strong> 在“爬楼梯”问题中，<code>dp[i]</code> 可以定义为“爬到第 <code>i</code> 级台阶的方法总数”。</li></ul></li><li><strong>确定状态转移方程（State Transition Equation）：</strong><ul><li>状态转移方程是连接子问题与原问题的桥梁。它描述了如何从一个或多个子问题的解，计算出当前问题的解。</li><li><strong>例如：</strong> 在“爬楼梯”问题中，要爬到第 <code>i</code> 级台阶，可以从第 <code>i-1</code> 级爬一步，或者从第 <code>i-2</code> 级爬两步。所以状态转移方程是 <code>dp[i] = dp[i-1] + dp[i-2]</code>。</li></ul></li><li><strong>确定 DP 数组的初始值和边界条件：</strong><ul><li>动态规划的计算通常有一个起点。你需要为 DP 数组的最初几个元素（通常是 <code>dp[0]</code> 或 <code>dp[0][0]</code>）赋值。</li><li>这些初始值是递归的终止条件，它们必须是已知的、能够推导出后续所有状态的值。</li><li><strong>例如：</strong> 在“爬楼梯”问题中，爬到第 0 级台阶只有 1 种方法（不动），<code>dp[0] = 1</code>。爬到第 1 级台阶也只有 1 种方法（爬一步），<code>dp[1] = 1</code>。</li></ul></li><li><strong>确定遍历顺序：</strong><ul><li>动态规划的计算是有依赖关系的。你需要按照一定的顺序（通常是<strong>从小到大</strong>或<strong>从左到右</strong>）遍历 DP 数组，确保在计算 <code>dp[i]</code> 时，所有它依赖的子问题的解（如 <code>dp[i-1]</code>、<code>dp[i-2]</code>）都已经计算完成。</li><li><strong>例如：</strong> 在“爬楼梯”问题中，我们需要从 <code>i = 2</code> 开始遍历，一直到 <code>n</code>，因为 <code>dp[i]</code> 依赖于 <code>dp[i-1]</code> 和 <code>dp[i-2]</code>。</li></ul></li></ol><h3 id="动态规划的解题套路"><a href="#动态规划的解题套路" class="headerlink" title="动态规划的解题套路"></a>动态规划的解题套路</h3><p>掌握了上述四个步骤后，我们可以通过一个简单的套路来解决大部分动态规划问题：</p><ol><li><strong>读题，识别动态规划问题：</strong> 如果问题可以分解为重叠子问题，并且需要求最优解（最大、最小、最多、最少），那么它很可能是动态规划。</li><li><strong>定义 DP 数组：</strong> 勇敢地写下 <code>dp[i]</code> 或 <code>dp[i][j]</code>，并用一句话描述它的含义。</li><li><strong>找递推关系（状态转移方程）：</strong> 思考如何从 <code>dp[...小一些的索引...]</code> 得到 <code>dp[i]</code>，这是最难的一步，通常需要举几个小例子来推导。</li><li><strong>初始化 DP 数组：</strong> 确定 <code>dp[0]</code>、<code>dp[0][0]</code> 等基本情况。</li><li><strong>编写循环：</strong> 按照正确的依赖顺序，编写 <code>for</code> 循环来填充 DP 数组。</li><li><strong>返回结果：</strong> 根据 DP 数组的定义，返回最终需要的答案。</li></ol><h3 id="最长递增字串"><a href="#最长递增字串" class="headerlink" title="最长递增字串"></a>最长递增字串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[n] 表示以索引i结尾的数组的最长递增长度</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sz = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(sz,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> max_len&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;sz;++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums.<span class="built_in">at</span>(i)&gt;nums.<span class="built_in">at</span>(j)) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最长公共字串"><a href="#最长公共字串" class="headerlink" title="最长公共字串"></a>最长公共字串</h3><h3 id="最长回文字串"><a href="#最长回文字串" class="headerlink" title="最长回文字串"></a>最长回文字串</h3><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p>一种方法是将原本字符串与逆序后的字符串求最长公共字串长度.</p><p>另外可以直接使用动态规划.</p><p>可以使用一个二维 DP 数组来解决这个问题。定义 <code>dp[i][j]</code> 为字符串 <code>s</code> 在索引 <code>i</code> 到 <code>j</code> 之间的子串中，最长回文子序列的长度</p><p><strong>状态转移方程</strong></p><p>要计算 <code>dp[i][j]</code>，我们需要考虑子串 <code>s[i...j]</code> 的两端字符 <code>s[i]</code> 和 <code>s[j]</code>：</p><ul><li><strong>如果 <code>s[i] == s[j]</code></strong> 这意味着这两个字符可以作为回文子序列的一部分。此时，最长回文子序列的长度是在 <code>s[i+1...j-1]</code> 子串的最长回文子序列的基础上，加上这两个匹配的字符。 <code>dp[i][j] = dp[i+1][j-1] + 2</code></li><li><strong>如果 <code>s[i] != s[j]</code></strong> 这两个字符不匹配，我们不能同时将它们都作为回文子序列的一部分。因此，我们需要在以下两种情况中取最大值：<ol><li><code>s[i...j-1]</code> 子串中的最长回文子序列的长度 (<code>dp[i][j-1]</code>)。</li><li><code>s[i+1...j]</code> 子串中的最长回文子序列的长度 (<code>dp[i+1][j]</code>)。 <code>dp[i][j] = max(dp[i][j-1], dp[i+1][j])</code></li></ol></li></ul><p><strong>边界条件</strong></p><p>需要初始化 DP 数组。当子串的长度为 1 时，它本身就是一个回文子序列，所以：</p><ul><li><code>dp[i][i] = 1</code></li></ul><p><strong>遍历顺序</strong></p><p>观察状态转移方程，<code>dp[i][j]</code> 依赖于 <code>dp[i+1][j-1]</code>、<code>dp[i][j-1]</code> 和 <code>dp[i+1][j]</code>。这意味着在计算 <code>dp[i][j]</code> 时，我们需要先知道其<strong>左下角</strong>、<strong>左边</strong>和<strong>下边</strong>的值。</p><p>为了满足这个依赖关系，我们应该从<strong>小到大</strong>遍历子串的长度，然后从<strong>后往前</strong>遍历起始索引。</p><ul><li>外层循环：子串长度 <code>len</code> 从 1 到 <code>n</code>。</li><li>内层循环：起始索引 <code>i</code> 从 <code>n-1</code> 到 0。</li><li>结束索引 <code>j</code> 总是 <code>i + len - 1</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(sz,vector&lt;<span class="keyword">int</span>&gt;(sz));</span><br><span class="line">        <span class="comment">// 状态转移方程 i,j表示起始位置和截止位置 这个范围的最长回文字串长度</span></span><br><span class="line">        <span class="comment">// dp[i][j] = 1 ,i == j</span></span><br><span class="line">        <span class="comment">// dp[i][j] = 0 ,i &gt; j</span></span><br><span class="line">        <span class="comment">// dp[i][j] = if s[i] == s[j] dp[i+1][j-1] + 2</span></span><br><span class="line">        <span class="comment">// s[i] != s[j]   dp[i][j]  = max(dp[i+1][j],dp[i][j-1])</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;sz;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">at</span>(i) == s.<span class="built_in">at</span>(j)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][sz<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>用栈实现 DFS 的核心思想是：</p><ol><li>将根节点压入栈中。</li><li>进入一个循环，只要栈不为空，就执行以下操作：<ul><li>弹出栈顶节点，并访问它。</li><li>将该节点的<strong>右子节点</strong>压入栈中（如果存在）。</li><li>将该节点的<strong>左子节点</strong>压入栈中（如果存在）。</li></ul></li></ol><p>为什么先压入右子节点，再压入左子节点？因为栈是<strong>后进先出（LIFO）</strong>的。这样做可以确保左子节点总是先于右子节点被弹出和访问，从而模拟了递归的深度优先探索顺序。</p><h3 id="三种遍历方式的实现"><a href="#三种遍历方式的实现" class="headerlink" title="三种遍历方式的实现"></a>三种遍历方式的实现</h3><p>使用栈实现 DFS 可以轻松模拟前序、中序和后序遍历。</p><ol><li>前序遍历（Pre-order Traversal）</li></ol><p>前序遍历的顺序是：<strong>根 -&gt; 左 -&gt; 右</strong>。使用栈实现时，只需按照核心思想的步骤即可。</p><ul><li><strong>步骤：</strong><ol><li>将根节点入栈。</li><li>循环直到栈为空：<ul><li>弹出节点 <code>node</code>，访问它。</li><li>将 <code>node</code> 的右子节点入栈（如果存在）。</li><li>将 <code>node</code> 的左子节点入栈（如果存在）。</li></ul></li></ol></li></ul><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::stack&lt;TreeNode*&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>中序遍历（In-order Traversal）</li></ol><p>中序遍历的顺序是：<strong>左 -&gt; 根 -&gt; 右</strong>。这个实现稍复杂，因为我们需要在访问根节点之前，先遍历完它的所有左子节点。</p><ul><li><strong>步骤：</strong><ol><li>初始化一个 <code>current</code> 指针指向根节点。</li><li>循环直到 <code>current</code> 为空且栈为空：<ul><li>将所有左子节点依次入栈，直到 <code>current</code> 为空。</li><li>弹出栈顶节点 <code>node</code>，访问它。</li><li>让 <code>current</code> 指向 <code>node</code> 的右子节点，继续循环。</li></ul></li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    std::stack&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* current = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(current);</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        current = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        result.<span class="built_in">push_back</span>(current-&gt;val);</span><br><span class="line">        current = current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>后序遍历（Post-order Traversal）</li></ol><p>后序遍历的顺序是：<strong>左 -&gt; 右 -&gt; 根</strong>。这是三种遍历中最复杂的。一种常见的技巧是：</p><ul><li>先用类似前序遍历的方式，以<strong>根 -&gt; 右 -&gt; 左</strong>的顺序遍历。</li><li>将遍历结果存入一个临时数组。</li><li>最后将临时数组<strong>反转</strong>，即可得到后序遍历的结果。</li><li><strong>步骤：</strong><ol><li>将根节点入栈。</li><li>循环直到栈为空：<ul><li>弹出节点 <code>node</code>，将它的值存入临时数组。</li><li>将 <code>node</code> 的左子节点入栈（如果存在）。</li><li>将 <code>node</code> 的右子节点入栈（如果存在）。</li></ul></li><li>反转临时数组。</li></ol></li></ul><p>C++</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::stack&lt;TreeNode*&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><blockquote><p>图做深搜广搜的时候注意在哪里判断选择结束条件,实在做选择的时候还是在从堆栈中取出数据的时候</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> counts&#123;&#125;;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(sz--) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="comment">//  if(t 满足终止条件) &#123;</span></span><br><span class="line">      <span class="comment">//      </span></span><br><span class="line">      <span class="comment">//  &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(choice : choices) &#123;</span><br><span class="line">            <span class="comment">//判断选择是否满足终止条件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    counts++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p><strong>Dijkstra 算法</strong>用于在一个<strong>带权图中</strong>找到从一个<strong>起始节点</strong>到<strong>所有其他节点</strong>的<strong>最短路径</strong>。</p><p>Dijkstra 算法维护一个节点集合，这个集合中的节点已经确定了最短路径。它从起始节点开始，不断选择<strong>距离起始节点最近</strong>的未访问节点，并用这个节点来更新其所有邻接节点的距离。这个过程重复进行，直到所有节点都被访问。</p><p><strong>算法步骤</strong></p><ol><li><strong>初始化</strong>：创建一个距离数组 <code>dist</code>，将起始节点的距离设为 0，其他所有节点的距离设为无穷大。</li><li><strong>优先队列</strong>：使用一个<strong>最小优先队列</strong>来存储 <code>&lt;距离, 节点&gt;</code> 对，初始时将 <code>&lt;0, 起始节点&gt;</code> 放入队列。</li><li><strong>循环</strong>：只要优先队列不为空，就执行以下操作：<ul><li>从队列中弹出距离最小的节点 <code>u</code>。</li><li>如果 <code>u</code> 已经被访问过，则跳过。</li><li>标记 <code>u</code> 为已访问。</li><li>遍历 <code>u</code> 的所有邻接节点 <code>v</code>：<ul><li>计算通过 <code>u</code> 到 <code>v</code> 的新距离：<code>new_dist = dist[u] + weight(u, v)</code>。</li><li>如果 <code>new_dist &lt; dist[v]</code>，则更新 <code>dist[v] = new_dist</code>，并将 <code>&lt;new_dist, v&gt;</code> 放入优先队列。</li></ul></li></ul></li><li><strong>结果</strong>：当循环结束时，<code>dist</code> 数组中存储的就是起始节点到所有其他节点的最短距离。</li></ol><p><strong>适用场景</strong></p><ul><li><strong>寻找最短路径</strong>，例如，导航系统计算两个地点之间的最短距离。</li><li>要求所有<strong>边权都为非负数</strong>。<strong>如果图中存在负权边，Dijkstra 算法会失效</strong>，此时需要使用 <strong>Bellman-Ford</strong> 或 <strong>SPFA</strong> 算法。</li></ul><p>最小生成树（Minimum Spanning Tree, MST）是图论中的一个核心概念，它指的是一个<strong>加权连通图</strong>的特殊子图。</p><h3 id="最小生成树的概念"><a href="#最小生成树的概念" class="headerlink" title="最小生成树的概念"></a>最小生成树的概念</h3><ul><li><strong>图</strong>：一个由<strong>节点（顶点）</strong>和<strong>边</strong>组成的集合。</li><li><strong>加权图</strong>：图中的每条边都有一个<strong>权重</strong>（或成本、距离）。</li><li><strong>连通图</strong>：图中任意两个节点之间都存在一条路径。</li><li><strong>生成树</strong>：是原图的一个<strong>子图</strong>，它连接了原图中的<strong>所有节点</strong>，但没有任何<strong>环</strong>，且包含了<strong>最少</strong>的边。一个包含 <code>n</code> 个节点的图，其生成树总是包含 <code>n-1</code> 条边。</li></ul><p>而<strong>最小生成树</strong>，就是在所有可能的生成树中，<strong>所有边的权重之和最小</strong>的那一棵。</p><p>解决最小生成树问题的经典算法有两个：</p><ul><li><strong>Prim 算法</strong>：从一个起始节点开始，逐步向外扩展，每次都选择连接已构建树和未加入树的权重最小的边。</li><li><strong>Kruskal 算法</strong>：将所有边按权重从小到大排序，然后依次选择边，只要这条边不会形成环，就将其加入到生成树中。</li></ul><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><p><strong>Prim 算法</strong>用于找到一个<strong>加权连通图</strong>的<strong>最小生成树（Minimum Spanning Tree, MST）</strong>。最小生成树是图的一个子图，它连接了所有节点，且所有边的权重之和最小。</p><p>Prim 算法从一个任意的起始节点开始，逐步添加边，以构建一棵树。在每一步中，它都选择连接<strong>当前已构建树</strong>与<strong>未加入树的节点</strong>的<strong>权重最小的边</strong>。这个过程重复进行，直到所有节点都被加入到树中。</p><p><strong>算法步骤</strong></p><ol><li><strong>初始化</strong>：创建一个距离数组 <code>dist</code>，将起始节点的距离设为 0，其他节点的距离设为无穷大。这个距离表示节点与当前已构建树之间的最小边权。</li><li><strong>优先队列</strong>：使用一个<strong>最小优先队列</strong>来存储 <code>&lt;边权, 节点&gt;</code> 对，初始时将 <code>&lt;0, 起始节点&gt;</code> 放入队列。</li><li><strong>循环</strong>：只要优先队列不为空，就执行以下操作：<ul><li>从队列中弹出边权最小的节点 <code>u</code>。</li><li>如果 <code>u</code> 已经被访问过，则跳过。</li><li>标记 <code>u</code> 为已访问，并将边权 <code>weight</code> 加入到 MST 的总权重中。</li><li>遍历 <code>u</code> 的所有邻接节点 <code>v</code>：<ul><li>如果 <code>v</code> 未被访问，并且边 <code>(u, v)</code> 的权重小于 <code>v</code> 当前的距离：<ul><li>更新 <code>v</code> 的距离：<code>dist[v] = weight(u, v)</code>。</li><li>将 <code>&lt;weight(u, v), v&gt;</code> 放入优先队列。</li></ul></li></ul></li></ul></li><li><strong>结果</strong>：当循环结束时，所有节点的 <code>dist</code> 值的总和（或者通过其他方式记录的边的权重之和）就是最小生成树的总权重。</li></ol><p>适用场景</p><ul><li><strong>构建最小生成树</strong>，例如，设计一个网络连接所有城市，但要使总光缆长度最小。</li><li>Prim 算法可以处理<strong>负权边</strong>，因为它只关心边本身的权重，而不是累积的路径权重。</li></ul><p><strong>区别总结</strong></p><div class="table-container"><table><thead><tr><th>特性</th><th>Dijkstra 算法</th><th>Prim 算法</th></tr></thead><tbody><tr><td><strong>解决问题</strong></td><td>单源最短路径（SSSP）</td><td>最小生成树（MST）</td></tr><tr><td><strong>目标</strong></td><td>找到从源节点到所有其他节点的最短路径</td><td>找到连接所有节点的最小总权重的子图</td></tr><tr><td><strong>核心选择</strong></td><td>选择<strong>距离源节点最近</strong>的未访问节点</td><td>选择<strong>距离当前树最近</strong>的未访问节点</td></tr><tr><td><strong>边权</strong></td><td>要求<strong>非负</strong></td><td>可处理<strong>负权边</strong></td></tr><tr><td><strong>路径</strong></td><td>关心<strong>累积路径</strong>的权重</td><td>只关心<strong>单条边</strong>的权重</td></tr></tbody></table></div><p>它的主要作用是<strong>计算一个有向图或无向图中任意两个节点之间的最短路径</strong>。这个算法可以处理<strong>带负权值</strong>的边，但不能处理<strong>负权环</strong>（如果图中存在负权环，算法会失效）。</p><h3 id="Floyd-算法的核心思想"><a href="#Floyd-算法的核心思想" class="headerlink" title="Floyd 算法的核心思想"></a>Floyd 算法的核心思想</h3><p>Floyd 算法的核心思想是<strong>动态规划</strong>。它通过逐步增加中间节点的数量来更新最短路径。</p><p>假设图中有 n 个节点，算法的执行过程是这样的：</p><ol><li><strong>初始化</strong>：创建一个 ntimesn 的距离矩阵 <code>dist</code>。<code>dist[i][j]</code> 初始化为节点 i 到节点 j 的直接距离。如果两个节点之间没有直接连接，距离设为无穷大。</li><li><strong>迭代</strong>：算法会进行 n 次迭代，每次迭代都以一个节点 k 作为“中间节点”。<ul><li>在第 k 次迭代中，算法会遍历所有的节点对 (i,j)。</li><li>它会检查，如果从 i 经过 k 到达 j 的路径比已知的最短路径更短，就更新 <code>dist[i][j]</code>。</li><li>更新公式为：<code>dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])</code>。</li></ul></li></ol><p>通过这 n 次迭代，算法考虑了所有可能的中间节点，最终得到的 <code>dist</code> 矩阵就包含了任意两个节点之间的最短路径。</p><h2 id="深搜广搜"><a href="#深搜广搜" class="headerlink" title="深搜广搜"></a>深搜广搜</h2><h3 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h3><h4 id="省份数量"><a href="#省份数量" class="headerlink" title="省份数量"></a>省份数量</h4><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。 </p><p> 省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。 </p><p> 给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。 </p><p> 返回矩阵中 省份 的数量。</p><p>要解决这个问题，我们可以将城市和它们之间的连接关系看作是一个图（Graph）。其中，每个城市都是图中的一个节点，如果两个城市相连，那么它们之间就有一条边。题目中定义的“省份”其实就是图中的<strong>连通分量（Connected Component）</strong>。</p><p>因此，问题的核心就变成了：<strong>给定一个图，找出其中的连通分量数量</strong>。</p><p>我们可以使用两种常见的图遍历算法来解决这个问题：<strong>深度优先搜索（DFS）或广度优先搜索（BFS）</strong>。</p><p>方法一：深度优先搜索（DFS）</p><p>DFS 的基本思想是从一个未访问过的城市开始，沿着它的连接路径一直走下去，直到所有与之相连的城市都被访问。当这条路径走完后，我们就找到了一个完整的省份。然后，我们从下一个未访问过的城市重新开始，重复这个过程，直到所有城市都被访问。</p><p><strong>算法步骤</strong>：</p><ol><li>初始化一个计数器 <code>count = 0</code>，用于记录省份的数量。</li><li>创建一个布尔数组 <code>visited</code>，大小为 <code>n</code>，用于标记城市是否已被访问。</li><li>遍历所有城市，从 <code>i = 0</code> 到 <code>n - 1</code>。</li><li>对于每个城市 <code>i</code>：<ul><li>如果 <code>visited[i]</code> 为 <code>false</code>，说明我们遇到了一个新省份。</li><li>将 <code>count</code> 加 1。</li><li>调用 DFS 函数，从城市 <code>i</code> 开始遍历，并标记所有与其相连的城市为已访问。</li></ul></li><li>DFS 函数的实现：<ul><li>接收当前城市 <code>i</code> 作为参数。</li><li>将 <code>visited[i]</code> 设置为 <code>true</code>。</li><li>遍历所有城市 <code>j</code>，从 <code>0</code> 到 <code>n - 1</code>。</li><li>如果城市 <code>i</code> 与城市 <code>j</code> 相连（<code>isConnected[i][j] == 1</code>），且城市 <code>j</code> 未被访问（<code>!visited[j]</code>），则递归调用 DFS 函数，从城市 <code>j</code> 继续遍历。</li></ul></li></ol><p><strong>代码实现</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = isConnected.length;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="comment">// 找到一个新的省份</span></span><br><span class="line">                count++;</span><br><span class="line">                <span class="comment">// 从当前城市开始，深度遍历所有相连的城市</span></span><br><span class="line">                dfs(isConnected, visited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] isConnected, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 标记当前城市为已访问</span></span><br><span class="line">        visited[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 遍历所有城市</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; isConnected.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果城市i和城市j相连，且城市j未被访问过</span></span><br><span class="line">            <span class="keyword">if</span> (isConnected[i][j] == <span class="number">1</span> &amp;&amp; !visited[j]) &#123;</span><br><span class="line">                <span class="comment">// 递归地继续遍历</span></span><br><span class="line">                dfs(isConnected, visited, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：广度优先搜索（BFS）</p><p>BFS 的思想与 DFS 类似，只是遍历的方式不同。它不是沿着一条路径一直走，而是从一个城市开始，先访问所有与它直接相连的城市，然后是与这些城市直接相连的城市，以此类推。我们可以使用队列（Queue）来实现 BFS。</p><p><strong>算法步骤</strong>：</p><ol><li>初始化 <code>count = 0</code> 和布尔数组 <code>visited</code>。</li><li>遍历所有城市 <code>i</code>：</li><li>如果 <code>visited[i]</code> 为 <code>false</code>，则 <code>count++</code>。</li><li>创建一个队列，并将城市 <code>i</code> 加入队列。</li><li>将 <code>visited[i]</code> 设置为 <code>true</code>。</li><li>当队列不为空时：<ul><li>取出队列头部元素 <code>currentCity</code>。</li><li>遍历所有城市 <code>j</code>：</li><li>如果 <code>currentCity</code> 与城市 <code>j</code> 相连，且城市 <code>j</code> 未被访问，则将 <code>j</code> 加入队列，并将 <code>visited[j]</code> 设置为 <code>true</code>。</li></ul></li></ol><h3 id="重新规划路线"><a href="#重新规划路线" class="headerlink" title="重新规划路线"></a>重新规划路线</h3><h3 id="除法求值"><a href="#除法求值" class="headerlink" title="除法求值"></a>除法求值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> unordered_map&lt;string,unordered_map&lt;string,<span class="keyword">double</span>&gt;&gt;&amp; graph,string x,string z,set&lt;string&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph.<span class="built_in">find</span>(x) == graph.<span class="built_in">end</span>() || visited.<span class="built_in">count</span>(x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1.0</span>; <span class="comment">// 没有找到</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果找到了终点，返回 1.0 (表示从自己到自己的权重)</span></span><br><span class="line">            <span class="keyword">if</span> (x == z) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.<span class="built_in">insert</span>(x);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> node:graph.<span class="built_in">at</span>(x)) &#123;</span><br><span class="line">                <span class="keyword">double</span> result = <span class="built_in">dfs</span>(graph,node.first,z,visited);</span><br><span class="line">                <span class="keyword">if</span>(result != <span class="number">-1.0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> result*node.second; <span class="comment">// 找到对应值</span></span><br><span class="line">                &#125;                 </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">calcEquation</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;<span class="keyword">double</span>&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 构建已有的图</span></span><br><span class="line">        unordered_map&lt;string,unordered_map&lt;string,<span class="keyword">double</span>&gt;&gt; graph;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;equations.<span class="built_in">size</span>();++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> equation = equations.<span class="built_in">at</span>(i);</span><br><span class="line">            string x = equation[<span class="number">0</span>];</span><br><span class="line">            string y = equation[<span class="number">1</span>];</span><br><span class="line">            graph[x][y] = values[i];</span><br><span class="line">            graph[y][x] = <span class="number">1.0</span>/values[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.dfs</span></span><br><span class="line">        vector&lt;<span class="keyword">double</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> query:queries) &#123;</span><br><span class="line">            string x = query[<span class="number">0</span>];</span><br><span class="line">            string y = query[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(graph.<span class="built_in">find</span>(x) == graph.<span class="built_in">end</span>() || graph.<span class="built_in">find</span>(y) == graph.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">// 不存在该变量</span></span><br><span class="line">                result.<span class="built_in">emplace_back</span>(<span class="number">-1.0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x == y) &#123;</span><br><span class="line">                <span class="comment">// 值相等</span></span><br><span class="line">                result.<span class="built_in">emplace_back</span>(<span class="number">1.0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 通过dfs查找值 </span></span><br><span class="line">                set&lt;string&gt; visited;</span><br><span class="line">                result.<span class="built_in">emplace_back</span>(<span class="built_in">dfs</span>(graph,x,y,visited));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>回溯（Backtracking）是一种<strong>通过探索所有可能的候选解来找出所有解或最优解</strong>的算法策略。它通常用于解决组合问题、排列问题、子集问题等。</p><p>回溯算法的本质是<strong>深度优先搜索 (DFS)</strong> 的一种特殊应用。它像是在一个解空间树中进行遍历，每走一步就尝试一个选择，如果发现当前选择不能达到目标或偏离了最佳路径，就会<strong>“回溯”</strong>（撤销当前选择），退回到上一步，然后尝试另一个选择。</p><p>这个过程可以概括为：<strong>选择 → 探索 → 撤销。</strong></p><p>掌握这三要素是编写回溯代码的关键：</p><p><strong>路径 (Path):</strong> 记录已经做出的选择。这通常是一个 <code>List</code> 或 <code>Vector</code>，存储当前已选择的元素。</p><p><strong>选择列表 (Choices):</strong> 当前可以做出的选择。这是从问题中抽象出来的，通常是某个集合或数组中剩余的元素。</p><p><strong>结束条件 (Base Case / Termination Condition):</strong> 什么时候停止递归？通常是路径满足了特定条件（比如长度达到要求，找到了一个解）或者选择列表为空。</p><p>状态修改</p><p><strong>参数传递：</strong> 通常，<code>path</code> 应该作为引用（或指针）传递，因为它在递归过程中需要被修改和回溯。其他参数根据是否需要在递归调用中改变而定。</p><p><strong>状态的“做选择”和“撤销选择”：</strong> 确保每做一步选择后，都将其添加到 <code>path</code> 中；在递归调用结束后，<strong>务必撤销这个选择</strong>，恢复到递归前的状态，以便尝试其他分支。这是回溯算法的核心。</p><p>剪枝是回溯算法的灵魂，能极大提高效率。</p><ul><li><p><strong>定义：</strong> 在搜索过程中，一旦发现当前路径不可能得到有效解或最优解时，就立即停止对该路径的后续搜索。</p></li><li><p><strong>常见剪枝点：</strong></p><ul><li><strong>边界条件检查：</strong> 例如，如果路径长度已经超过了目标长度。</li><li><strong>不合法条件：</strong> 例如，组合问题中，如果当前选择导致和已经超过了目标值。</li><li><strong>排序：</strong> 对输入数据进行排序，可以帮助你在遍历选择时，当发现某个分支不可能生成有效解时，跳过后续相似的选择。例如，在有重复元素的组合问题中，排序后可以跳过重复的元素。</li></ul><p>当输入数组中包含<strong>重复元素</strong>，但要求结果中<strong>不允许有重复的组合/排列</strong>时，去重是一个常见的难点。</p><ul><li><strong>排序 + <code>if (i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue;</code></strong>：这是最经典的去重技巧。<ul><li>首先，对输入数组进行排序。</li><li>在 <code>for</code> 循环遍历 <code>Choices</code> 时，检查当前元素是否与前一个元素相同。如果相同，并且前一个元素已经被跳过（而不是本次递归中被选择后移除的），则跳过当前元素，以避免生成重复的路径。</li><li>这个判断通常应用于<strong>同一层递归</strong>中的去重，防止在同一位置做出相同的选择。</li></ul></li></ul><p><strong>遍历方式的选择</strong></p><p><strong>是否允许重复选择元素：</strong></p><ul><li><p><strong>允许（例如组合问题，<code>[1,1,2]</code> 选两个，可以是 <code>[1,1]</code>）：</strong> 递归时，下一个选择的起始索引可以从当前选择的索引开始 (<code>i</code> 或 <code>startIndex</code>)。</p></li><li><p><strong>不允许（例如排列问题，每个元素只能用一次）：</strong> 递归时，需要通过 <code>visited</code> 数组或移除元素的方式，确保元素不被重复选择。</p></li></ul></li></ul><p>​        <strong>是否要求组合/排列：</strong></p><ul><li><strong>组合 (Combinations)：</strong> 结果不考虑元素顺序（<code>[1,2]</code> 和 <code>[2,1]</code> 视为同一种）。通常通过在递归时传递一个 <code>startIndex</code> 参数来确保选择的元素索引是递增的，避免生成重复的组合。</li><li><strong>排列 (Permutations)：</strong> 结果考虑元素顺序（<code>[1,2]</code> 和 <code>[2,1]</code> 视为不同种）。通常需要一个 <code>visited</code> 数组或类似机制来标记已使用的元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 示例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(参数, ... Path, Choices)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 结束条件：满足某个条件时，将Path加入结果集，并返回</span></span><br><span class="line">    <span class="keyword">if</span> (满足结束条件) &#123;</span><br><span class="line">        result.<span class="built_in">add</span>(<span class="keyword">new</span> ArrayList&lt;&gt;(Path)); <span class="comment">// 注意：这里通常需要拷贝Path，因为Path后续还会被修改</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 遍历所有选择</span></span><br><span class="line">    <span class="keyword">for</span> (选择 in Choices) &#123;</span><br><span class="line">        <span class="comment">// 做选择：将当前选择加入Path</span></span><br><span class="line">        Path.<span class="built_in">add</span>(选择);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 剪枝（可选）：如果当前选择明显不符合条件，提前终止分支</span></span><br><span class="line">        <span class="comment">// if (...) continue; 或 return;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归：进入下一个决策层</span></span><br><span class="line">        <span class="built_in">backtrack</span>(参数, ... Path, newChoices); <span class="comment">// newChoices通常是基于当前选择更新后的</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 撤销选择：从Path中移除当前选择，回到上一个状态</span></span><br><span class="line">        Path.<span class="built_in">remove</span>(Path.<span class="built_in">size</span>() - <span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见回溯问题类型</p><ul><li><strong>子集问题：</strong> 找出所有可能的子集（<code>Subsets</code>）。</li><li><strong>组合问题：</strong> 找出所有和为目标值的组合，或固定长度的组合（<code>Combinations Sum</code>, <code>Combinations</code>）。</li><li><strong>排列问题：</strong> 找出所有可能的排列（<code>Permutations</code>）。</li><li><strong>迷宫问题/路径查找：</strong> 在网格或图中寻找路径（<code>Word Search</code>, <code>N-Queens</code>）。</li><li><strong>数独求解：</strong> 填字游戏。</li></ul><h2 id="搜索与排序"><a href="#搜索与排序" class="headerlink" title="搜索与排序"></a>搜索与排序</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>核心思想：分治,快速排序主要分为三个步骤：</p><ol><li><strong>选择基准（Pick a Pivot）：</strong> 从数组中选择一个元素作为基准。基准的选择有很多策略（第一个、最后一个、中间的、随机的），不同的选择会影响算法的性能。</li><li><strong>分区（Partition）：</strong> 重新排列数组，将所有小于基准的元素移到基准的左边，所有大于基准的元素移到基准的右边。等于基准的元素可以放在任意一边。分区结束后，基准元素就处于其最终的有序位置。</li><li><strong>递归（Recursion）：</strong> 递归地对基准左边的子数组和基准右边的子数组进行快速排序。</li></ol><p>分区操作是快速排序的核心。目标是将数组 <code>arr[low...high]</code> 以 <code>pivot</code> 为基准进行分区。</p><p><strong>Lomuto 分区方案：</strong></p><ol><li>选择 <code>arr[high]</code> 作为基准（或其他位置，然后交换到 <code>high</code>）。</li><li>维护一个索引 <code>i</code>，指向“小于基准”区域的最后一个元素。</li><li>遍历 <code>j</code> 从 <code>low</code> 到 <code>high-1</code>：<ul><li>如果 <code>arr[j] &lt;= pivot</code>，则将 <code>arr[j]</code> 交换到 <code>arr[i+1]</code> 的位置，并增加 <code>i</code>。</li></ul></li><li>最后，将基准元素（<code>arr[high]</code>）交换到 <code>arr[i+1]</code> 的位置。</li><li>返回 <code>i+1</code>，即基准最终的索引。</li></ol><ul><li><strong>优点：</strong> 简单易懂。</li><li><strong>缺点：</strong> 对有大量重复元素的数组性能较差</li></ul><p><strong>Hoare 分区方案：</strong></p><ol><li>选择 <code>arr[low]</code> 作为基准（或其他位置）。</li><li>维护两个指针 <code>i</code>（从 <code>low-1</code> 开始向右移动）和 <code>j</code>（从 <code>high+1</code> 开始向左移动）。</li><li><code>while (true)</code> 循环：<ul><li><code>do i++</code> 直到 <code>arr[i] &gt;= pivot</code>。</li><li><code>do j--</code> 直到 <code>arr[j] &lt;= pivot</code>。</li><li>如果 <code>i &lt; j</code>，交换 <code>arr[i]</code> 和 <code>arr[j]</code>。</li><li>否则，跳出循环。</li></ul></li><li>返回 <code>j</code>（或 <code>i</code>，取决于实现）。</li></ol><ul><li><strong>优点：</strong> 对有大量重复元素的数组性能更好，通常比 Lomuto 更高效。</li><li><strong>缺点：</strong> 边界条件和指针移动相对复杂，容易出错。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">( vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pivotIndex = <span class="built_in">partition</span>(nums,l,r);</span><br><span class="line">    <span class="comment">// quickSort(nums,l,pivotIndex-1);</span></span><br><span class="line">    <span class="built_in">quickSort</span>(nums,l,pivotIndex<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(nums,pivotIndex+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> l , <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivotIndex = l;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums.<span class="built_in">at</span>(pivotIndex);</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) &#123;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// hore分区 </span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r &amp;&amp; nums.<span class="built_in">at</span>(l)&lt;=pivot) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r &amp;&amp; nums.<span class="built_in">at</span>(r)&gt;=pivot) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums.<span class="built_in">at</span>(l),nums.<span class="built_in">at</span>(r));</span><br><span class="line">    &#125;</span><br><span class="line">    l = nums.<span class="built_in">at</span>(l)&gt;pivot?l<span class="number">-1</span>:l;    </span><br><span class="line">    <span class="built_in">swap</span>(nums.<span class="built_in">at</span>(pivotIndex),nums.<span class="built_in">at</span>(l));</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并排序（Merge Sort）是一种高效的、基于<strong>分治（Divide and Conquer）</strong>思想的排序算法。它的核心思想是将一个大问题分解成若干个小问题，直到小问题足够简单可以直接解决，然后将这些小问题的解合并起来，从而解决原先的大问题。</p><p>归并排序主要分为两个核心步骤：</p><ol><li><strong>分解（Divide）：</strong> 不断地将待排序的数组从中间一分为二，直到每个子数组只包含一个元素（一个元素自然是有序的）。</li><li><strong>合并（Conquer）：</strong> 将相邻的两个有序子数组合并成一个更大的有序数组。这个合并过程会重复进行，直到所有子数组都被合并成一个完整的有序数组。</li></ol><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3><p><strong>前缀树（Trie）</strong>，又称“字典树”，是一种用于高效存储和查找字符串集合的树形数据结构。它的核心思想是利用字符串的<strong>公共前缀</strong>来减少查询时间。</p><p><strong>前缀树的核心知识</strong></p><ol><li>结构</li></ol><p>一个前缀树由一系列节点组成，每个节点通常包含以下信息：</p><ul><li><strong>子节点数组（或哈希表）</strong>：用于存储指向子节点的指针。数组的大小取决于字符集，例如，如果只包含小写字母 ‘a’ 到 ‘z’，数组大小就是 26。</li><li><strong>结束标记（布尔值）</strong>：标记当前节点是否代表一个完整的单词的结尾。</li></ul><ol><li>工作原理</li></ol><p>前缀树的查找和插入操作都非常直观：</p><ul><li><strong>插入</strong>：从根节点开始，遍历字符串的每个字符。如果当前字符对应的子节点不存在，就创建一个新节点；然后移动到那个子节点，继续下一个字符。当所有字符都遍历完后，将最后一个节点的结束标记设为 <code>true</code>。</li><li><strong>查找</strong>：从根节点开始，遍历字符串的每个字符。如果某个字符对应的子节点不存在，说明字符串不在树中。如果遍历完整个字符串，并且最后一个节点的结束标记为 <code>true</code>，则说明找到了该单词。</li></ul><ol><li>性能优势</li></ol><ul><li><strong>时间复杂度</strong>：<ul><li><strong>插入和查找</strong>的时间复杂度都非常高效，通常是 O(L)，其中 L 是字符串的长度。与哈希表相比，它的性能不依赖于哈希函数的质量，而且没有哈希冲突的问题。</li></ul></li><li><strong>空间复杂度</strong>：<ul><li>空间消耗取决于存储的字符串数量和它们的公共前缀。在许多情况下，多个字符串共享前缀可以节省空间，但如果字符串都很长且没有公共前缀，空间消耗可能会大于哈希表。</li></ul></li></ul><h3 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h3><p>如何实现前缀树(包括插入,查找，前缀查找)并利用前缀树进行单词查找.</p><h3 id="LeetCode-题目实践"><a href="#LeetCode-题目实践" class="headerlink" title="LeetCode 题目实践"></a>LeetCode 题目实践</h3><p>掌握了前缀树的原理后，我们可以用它来解决一些 LeetCode 上的经典问题。</p><p><strong>1. 实现前缀树 (Trie)</strong></p><p>这是最基础的题目，要求你实现 <code>Trie</code> 类，包含 <code>insert</code>、<code>search</code> 和 <code>startsWith</code> 三个方法。通过这道题可以巩固对前缀树结构的理解。</p><ul><li><strong><code>insert(word)</code></strong>：将单词 <code>word</code> 插入前缀树。</li><li><strong><code>search(word)</code></strong>：判断 <code>word</code> 是否在前缀树中。</li><li><strong><code>startsWith(prefix)</code></strong>：判断是否有以 <code>prefix</code> 为前缀的单词</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vector&lt;TrieNode*&gt; chars&#123;<span class="number">26</span>,<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        <span class="keyword">bool</span> isEndOfWord&#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TrieNode* trieRoot;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>():<span class="built_in">trieRoot</span>(<span class="keyword">new</span> TrieNode) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> node = trieRoot;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:word) &#123;</span><br><span class="line">             <span class="keyword">auto</span> n = node-&gt;chars[ch-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">             <span class="keyword">if</span>(n == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                n = <span class="keyword">new</span> TrieNode;</span><br><span class="line">                node-&gt;chars[ch-<span class="string">&#x27;a&#x27;</span>] = n;</span><br><span class="line">             &#125;</span><br><span class="line">             node = n;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEndOfWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> node = trieRoot;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:word) &#123;</span><br><span class="line">            <span class="keyword">auto</span> n = node-&gt;chars[ch-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;isEndOfWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prefix.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> node = trieRoot;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> ch:prefix) &#123;</span><br><span class="line">            <span class="keyword">auto</span> n = node-&gt;chars[ch-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = n;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ol><li>单词搜索 II</li></ol><p>这道题需要你在一个网格中找出所有符合条件的单词。如果对每个单词都进行独立的搜索，效率会很低。使用前缀树可以大大优化。</p><ul><li><strong>思路</strong>：<ol><li>将所有待查找的单词构建成一棵前缀树。</li><li>遍历网格中的每个单元格，从该单元格开始进行<strong>深度优先搜索（DFS）</strong>。</li><li>DFS 的过程中，每访问一个新单元格，就检查它对应的字符是否存在于前缀树中。</li><li>如果当前路径构成的字符串是前缀树中的一个单词，就将其加入结果集。</li><li>利用前缀树，一旦某个字符在当前路径中不匹配任何前缀，就可以<strong>剪枝</strong>，避免不必要的搜索。</li></ol></li></ul><ol><li>键值映射</li></ol><p>这道题要求你实现一个字典，支持插入键值对和计算具有某个前缀的所有键对应值的总和。</p><ul><li><strong>思路</strong>：<ol><li>构建一个前缀树，每个节点除了子节点指针外，还要存储一个<strong>累加值</strong>。</li><li><code>insert(key, val)</code>：在插入时，从根节点开始遍历 <code>key</code> 的每个字符。每经过一个节点，都将该节点的累加值更新为 <code>val</code>。</li><li><code>sum(prefix)</code>：遍历 <code>prefix</code> 对应的路径，返回最后一个节点的累加值。</li></ol></li></ul><p>前缀树在处理与字符串前缀相关的查找、插入、计数等问题时，是一种非常高效且优雅的解决方案。</p><h2 id="区间集合"><a href="#区间集合" class="headerlink" title="区间集合"></a>区间集合</h2><h1 id="c-刷题"><a href="#c-刷题" class="headerlink" title="c++刷题"></a>c++刷题</h1><p>c++的STL相比于java集合的使用没有那么简单,迭代器以及一些容器类的使用更加晦涩.</p><p>这里介绍一些常用类,常用方法以及注意事项,还有一些没那么常见的类也要看一看注意一下.</p><p>使用c++STL需要注意的点是容器本身的方法和std下提供的算法的不同,比如参数是size_type还是iter_pos,以及返回值是迭代器还是size_type.</p><p>std::find以及string.find,map.find等差别.erase返回值的差别</p><h2 id="vector的常用操作"><a href="#vector的常用操作" class="headerlink" title="vector的常用操作"></a>vector的常用操作</h2><p>很常用容器,支持随机访问以及尾部增删</p><p>注意它没有find方法,因为可以使用遍历方便查找,或者使用std::find.</p><p><code>std::vector</code> 是 C++ STL 中最常用的容器之一，因为它兼具动态数组的灵活性和 C 风格数组的性能优势。但在 LeetCode 刷题或实际开发中，如果不注意一些细节，它也可能带来性能问题或难以排查的 bug。</p><h2 id="std-vector-常用方法注意事项"><a href="#std-vector-常用方法注意事项" class="headerlink" title="std::vector 常用方法注意事项"></a><code>std::vector</code> 常用方法注意事项</h2><h3 id="1-索引访问：-vs-at"><a href="#1-索引访问：-vs-at" class="headerlink" title="1. 索引访问：[] vs. .at()"></a>1. 索引访问：<code>[]</code> vs. <code>.at()</code></h3><ul><li><strong><code>vec[index]</code> (下标运算符)</strong>：<ul><li><strong>优点</strong>：速度最快，因为它<strong>不执行边界检查</strong>。</li><li><strong>缺点</strong>：如果 <code>index</code> 超出 <code>[0, vec.size() - 1]</code> 范围，会导致<strong>未定义行为 (Undefined Behavior)</strong>。这可能表现为程序崩溃、数据损坏或看似随机的错误。</li><li><strong>注意事项</strong>：<strong>仅在你100%确定索引有效时使用</strong>。在 LeetCode 这种注重性能的场景，如果你的逻辑能保证索引有效，它很常见。</li></ul></li><li><strong><code>vec.at(index)</code> (成员函数)</strong>：<ul><li><strong>优点</strong>：执行<strong>边界检查</strong>。如果 <code>index</code> 超出范围，会抛出 <code>std::out_of_range</code> 异常，这使得调试更容易。</li><li><strong>缺点</strong>：由于额外的检查，其性能略低于 <code>[]</code>。</li><li><strong>注意事项</strong>：在你不确定索引是否总是有效时，或者在需要严格错误处理的生产代码中，更推荐使用 <code>.at()</code>。</li></ul></li></ul><h3 id="2-push-back-的性能与-reserve"><a href="#2-push-back-的性能与-reserve" class="headerlink" title="2. push_back() 的性能与 reserve()"></a>2. <code>push_back()</code> 的性能与 <code>reserve()</code></h3><ul><li><strong><code>vec.push_back(value)</code></strong>：<ul><li><strong>优点</strong>：方便地在末尾添加元素。</li><li><strong>注意事项</strong>：当 <code>vector</code> 的当前容量不足以容纳新元素时，它会进行<strong>重新分配 (reallocation)</strong>。<ul><li>重新分配会涉及：<ol><li>分配一块<strong>更大的新内存</strong>（通常是当前容量的 1.5 倍或 2 倍）。</li><li>将<strong>所有现有元素复制（或移动）到新内存</strong>。</li><li><strong>释放旧内存</strong>。</li></ol></li><li>这是一个相对<strong>昂贵的操作</strong>，特别是当 <code>vector</code> 很大时。频繁的重新分配会严重影响性能。</li></ul></li></ul></li><li><strong><code>vec.reserve(new_cap)</code></strong>：<ul><li><strong>功能</strong>：<strong>预留</strong> <code>new_cap</code> 大小的内存空间，但<strong>不改变 <code>vector</code> 的实际大小 (<code>size()</code>)</strong>。</li><li><strong>优点</strong>：如果你知道 <code>vector</code> 大致会增长到多大，或者需要添加大量元素，预先调用 <code>reserve()</code> 可以<strong>避免多次重新分配</strong>，显著提升性能。</li><li><strong>注意事项</strong>：<code>reserve()</code> 只能增加容量，不能减少。</li></ul></li></ul><h3 id="3-迭代器失效-Iterator-Invalidation"><a href="#3-迭代器失效-Iterator-Invalidation" class="headerlink" title="3. 迭代器失效 (Iterator Invalidation)"></a>3. 迭代器失效 (Iterator Invalidation)</h3><ul><li><p><strong>当 <code>vector</code> 发生重新分配时</strong>：所有指向其内部元素的<strong>迭代器、指针和引用都会失效</strong>。这意味着它们可能指向错误的内存地址，或者指向已经被释放的内存。</p></li><li><p><strong>常见的引起重新分配的操作</strong>：</p><ul><li><code>push_back()</code> (当容量不足时)</li><li><code>insert()</code></li><li><code>resize()</code></li><li><code>erase()</code> (虽然 <code>erase</code> 返回下一个有效迭代器，但它也会使被删除元素及之后的所有迭代器失效)</li></ul></li><li><p><strong>注意事项</strong>：</p><ul><li>在循环中进行 <code>erase()</code> 操作时，如果使用传统的 <code>for</code> 循环，必须小心处理返回的迭代器：<code>it = vec.erase(it);</code></li><li>在进行可能引起重新分配的操作后，<strong>务必重新获取迭代器</strong>。</li></ul><p><code>erase</code> 的重载版本都会使<strong>从被删除元素（或范围）开始到 <code>vector</code> 末尾的所有迭代器、指针和引用失效</strong>。因此，在使用 <code>erase</code> 后，你通常需要重新获取迭代器。 erase主要是删除指定迭代器或者迭代器范围,参数没有size_type指定索引的类型.</p><h4 id="std-remove-和-erase-remove-惯用法"><a href="#std-remove-和-erase-remove-惯用法" class="headerlink" title="std::remove 和 erase-remove 惯用法"></a><code>std::remove</code> 和 <code>erase-remove</code> 惯用法</h4><p>在需要<strong>删除满足特定条件的所有元素</strong>时，通常不直接在循环中使用 <code>erase</code>，而是使用 <strong><code>std::remove</code> (或 <code>std::remove_if</code>) 结合 <code>vector::erase</code></strong> 的惯用法。这种方法通常更高效，因为它只进行一次数据移动。</p><ul><li><strong><code>std::remove</code> (或 <code>std::remove_if</code>)</strong>：这是一个算法（在 <code>&lt;algorithm&gt;</code> 中），它将所有要“删除”的元素移动到范围的末尾，并返回一个指向新逻辑末尾的迭代器。<strong>它不实际删除元素，也不改变容器的大小。</strong></li><li><strong><code>vector::erase</code></strong>：然后使用 <code>vector::erase</code> 来删除从 <code>std::remove</code> 返回的迭代器到 <code>vector.end()</code> 之间的元素，从而真正改变 <code>vector</code> 的大小并释放内存。</li></ul></li></ul><h3 id="4-pop-back-与-front-back-的使用"><a href="#4-pop-back-与-front-back-的使用" class="headerlink" title="4.pop_back() 与 front()/back() 的使用"></a>4.<code>pop_back()</code> 与 <code>front()</code>/<code>back()</code> 的使用</h3><ul><li><p><strong><code>vec.pop_back()</code> 和 <code>vec.front()</code> / <code>vec.back()</code></strong>：</p><ul><li><strong>注意事项</strong>：在使用这些方法前，<strong>必须确保 <code>vector</code> 非空</strong>（即 <code>!vec.empty()</code>）。如果 <code>vector</code> 为空时调用它们，会导致<strong>未定义行为</strong>。</li></ul><p><strong><code>vec.front()</code></strong></p><ul><li><strong>功能：</strong> 返回 <code>vector</code> 中第一个元素的引用。</li><li><strong>返回值：</strong> 对第一个元素的<strong>引用</strong> (<code>T&amp;</code>)。</li><li><strong>注意事项：</strong> <code>vector</code> <strong>不能为空</strong>。调用空 <code>vector</code> 的 <code>front()</code> 会导致未定义行为。</li><li><strong>例子：</strong> <code>int first = myVector.front();</code></li></ul><p><strong><code>vec.back()</code></strong></p><ul><li><strong>功能：</strong> 返回 <code>vector</code> 中最后一个元素的引用。</li><li><strong>返回值：</strong> 对最后一个元素的<strong>引用</strong> (<code>T&amp;</code>)。</li><li><strong>注意事项：</strong> <code>vector</code> <strong>不能为空</strong>。调用空 <code>vector</code> 的 <code>back()</code> 会导致未定义行为。</li><li><strong>例子：</strong> <code>int last = myVector.back();</code></li></ul><p><strong><code>vec.data()</code> (C++11)</strong></p><ul><li><strong>功能：</strong> 返回指向 <code>vector</code> 内部存储数据的<strong>首个元素的指针</strong>。这允许你将 <code>vector</code> 的数据作为 C 风格数组传递给 C 语言 API。</li><li><strong>返回值：</strong> <code>T*</code> (非 <code>const</code> 版本) 或 <code>const T*</code> ( <code>const</code> 版本)。</li><li><strong>注意事项：</strong> 返回的指针在 <code>vector</code> 重新分配内存后会<strong>失效</strong>。</li><li><strong>例子：</strong> <code>int* rawArray = myVector.data();</code></li></ul></li></ul><h3 id="5-clear-vs-shrink-to-fit"><a href="#5-clear-vs-shrink-to-fit" class="headerlink" title="5. clear() vs. shrink_to_fit()"></a>5. <code>clear()</code> vs. <code>shrink_to_fit()</code></h3><ul><li><p><strong><code>vec.clear()</code></strong>:</p><ul><li><strong>功能</strong>：删除 <code>vector</code> 中的所有元素，使其 <code>size()</code> 变为 0。</li><li><strong>注意事项</strong>：它<strong>不一定会释放</strong> <code>vector</code> 内部已分配的内存，<code>capacity()</code> 可能保持不变。</li></ul></li><li><p><strong><code>vec.shrink_to_fit()</code> (C++11)</strong>:</p><ul><li><p><strong>功能</strong>：请求 <code>vector</code> 将其容量调整到刚好足以容纳当前元素（即 <code>capacity()</code> 变为 <code>size()</code>）。这是一个提示，不保证一定会减少容量。</p></li><li><p><strong>注意事项</strong>：如果 <code>vector</code> 之前有过大量元素，然后清空或删除了大部分，但你希望立即释放多余内存以节省资源，可以使用它。但频繁调用也可能导致不必要的开销。</p></li></ul></li></ul><h3 id="6-插入与删除元素"><a href="#6-插入与删除元素" class="headerlink" title="6.插入与删除元素"></a>6.插入与删除元素</h3><p><strong><code>vec.insert(const_iterator position, const T&amp; value)</code> / <code>vec.insert(const_iterator position, T&amp;&amp; value)</code></strong></p><ul><li><strong>功能：</strong> 在 <code>position</code> 迭代器指向的位置<strong>之前</strong>插入一个 <code>value</code>。</li><li><strong>返回值：</strong> 指向新插入元素的<strong>迭代器</strong>。</li><li><strong>注意事项：</strong> 插入操作会使 <code>position</code> 及其之后所有迭代器失效。如果容量不足，会触发重新分配。时间复杂度为 O(N)，因为需要移动 <code>position</code> 之后的所有元素。</li><li><strong>例子：</strong> <code>auto it = myVector.insert(myVector.begin() + 1, 99);</code></li></ul><p><strong><code>ec.insert(const_iterator position, size_type count, const T&amp; value)</code></strong></p><ul><li><strong>功能：</strong> 在 <code>position</code> 迭代器指向的位置<strong>之前</strong>插入 <code>count</code> 个 <code>value</code>。</li><li><strong>返回值：</strong> 指向第一个新插入元素的<strong>迭代器</strong>。</li><li><strong>注意事项：</strong> 同单元素 <code>insert</code>。</li></ul><p><strong><code>vec.insert(const_iterator position, InputIt first, InputIt last)</code></strong></p><ul><li><strong>功能：</strong> 在 <code>position</code> 迭代器指向的位置<strong>之前</strong>插入 <code>[first, last)</code> 范围内的元素。</li><li><strong>返回值：</strong> 指向第一个新插入元素的<strong>迭代器</strong>。</li><li><strong>注意事项：</strong> 同单元素 <code>insert</code>。</li></ul><p><strong><code>vec.emplace(const_iterator position, Args&amp;&amp;... args)</code> (C++11)</strong></p><ul><li><strong>功能：</strong> 在 <code>position</code> 迭代器指向的位置就地构造一个元素。</li><li><strong>返回值：</strong> 指向新构造元素的<strong>迭代器</strong>。</li><li><strong>注意事项：</strong> 同 <code>insert</code>。</li></ul><p><strong><code>vec.erase(const_iterator position)</code></strong></p><ul><li><strong>功能：</strong> 删除 <code>position</code> 迭代器指向的单个元素。</li><li><strong>返回值：</strong> 指向被删除元素之后<strong>第一个有效元素</strong>的<strong>迭代器</strong>。如果删除的是最后一个元素，则返回 <code>vec.end()</code>。</li><li><strong>注意事项：</strong> 删除操作会使 <code>position</code> 及其之后的所有迭代器失效。时间复杂度为 O(N)。</li><li><strong>例子：</strong> <code>auto it_next = myVector.erase(myVector.begin() + 1);</code></li></ul><p><strong><code>vec.erase(const_iterator first, const_iterator last)</code></strong></p><ul><li><strong>功能：</strong> 删除 <code>[first, last)</code> 范围内的元素。</li><li><strong>返回值：</strong> 指向被删除范围之后<strong>第一个有效元素</strong>的<strong>迭代器</strong>。如果删除的范围包含 <code>vector</code> 的所有元素直到末尾，则返回 <code>vec.end()</code>。</li><li><strong>注意事项：</strong> 删除操作会使 <code>first</code> 及其之后的所有迭代器失效。时间复杂度为 O(N)。</li><li><strong>例子：</strong> <code>auto it_next = myVector.erase(myVector.begin() + 1, myVector.begin() + 3);</code></li></ul><p><strong><code>vec.swap(std::vector&amp; other)</code></strong></p><ul><li><strong>功能：</strong> 高效地交换两个 <code>vector</code> 的内容。这是一种常数时间操作，因为它只交换了内部的指针和大小信息。</li><li><strong>返回值：</strong> <code>void</code>。</li><li><strong>注意事项：</strong> 交换后，迭代器和引用仍然指向它们原来的元素，只是这些元素现在属于另一个 <code>vector</code> 对象了。</li></ul><h3 id="7-构造函数与-resize-的区别"><a href="#7-构造函数与-resize-的区别" class="headerlink" title="7.构造函数与 resize() 的区别"></a>7.构造函数与 <code>resize()</code> 的区别</h3><ul><li><strong>构造函数 <code>std::vector&lt;T&gt; vec(count);</code></strong>：创建 <code>count</code> 个元素，并对它们进行<strong>默认初始化</strong>。</li><li><strong><code>vec.resize(count);</code></strong>：如果 <code>count</code> 大于当前 <code>size()</code>，会添加新的元素并进行<strong>默认初始化</strong>。</li><li><strong><code>vec.clear();</code></strong> 之后再 <code>vec.resize(count);</code>：会清空现有元素，然后创建 <code>count</code> 个新元素并默认初始化。</li></ul><h2 id="string的常用操作"><a href="#string的常用操作" class="headerlink" title="string的常用操作"></a>string的常用操作</h2><p>主要是insert,erase的返回值,vector的insert,erase操作只能是迭代器并返回操作成功指向的迭代器(insert返回指向的插入成功的迭代器,erase返回指向删除后的下一个迭代器)</p><p>而string的insert和erase的重载方法中有参数是索引,返回值是指向字符串自身的引用,也就是说可以链式调用.</p><p><strong><code>std::string&amp; insert(size_type index, const std::string&amp; str);</code> 等重载</strong></p><ul><li><strong>返回值：</strong> 字符串自身的引用（<code>*this</code>）。</li><li><strong>注意事项：</strong> 在指定位置 <code>index</code> 插入内容。<code>index</code> 不能超过 <code>size()</code>，否则抛出 <code>std::out_of_range</code>。插入操作可能涉及大量字符移动，性能开销较大。</li></ul><p><strong><code>std::string&amp; erase(size_type index = 0, size_type count = npos);</code> 等重载</strong></p><ul><li><strong>返回值：</strong> 字符串自身的引用（<code>*this</code>）。</li><li><strong>注意事项：</strong> 从 <code>index</code> 位置开始删除 <code>count</code> 个字符。<code>index</code> 不能超过 <code>size()</code>，否则抛出 <code>std::out_of_range</code>。删除操作可能涉及大量字符移动。</li></ul><p>并且注意,erase的第一个参数是offset,第二个参数是删除个数,默认一直删到末尾.</p><p>类似的参数还有substr,第一个参数是offset,第二个参数是limit.</p><p><strong><code>std::string substr(size_type pos = 0, size_type len = npos) const;</code></strong></p><ul><li><strong>返回值：</strong> 从 <code>pos</code> 位置开始，长度为 <code>len</code> 的<strong>新字符串</strong>。</li><li><strong>注意事项：</strong> 返回一个<strong>副本</strong>，而不是引用。<code>pos</code> 不能超过 <code>size()</code>，否则抛出 <code>std::out_of_range</code>。<code>len</code> 超过实际可用长度时会被截断。</li></ul><p>此外erase,insert也有对应参数为迭代器的重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator position)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(const_iterator pos, CharT c)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(const_iterator pos, size_type count, CharT c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class InputIt&gt;</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(const_iterator pos, InputIt first, InputIt last)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>迭代器失效：</strong> 大多数 <code>insert</code> 操作都可能导致字符串重新分配内存，这会使所有之前获得的指向该字符串内部的迭代器和指针<strong>失效</strong>。这意味着你不能在 <code>insert</code> 操作之后依赖旧的迭代器继续操作。如果你需要继续迭代，应该使用 <code>insert</code> 的返回值（新的迭代器）。</p><p><strong>性能开销：</strong> 在字符串的中间或开头进行插入操作，通常需要移动大量现有字符，这会带来较大的性能开销。如果性能是关键考虑因素，并且需要频繁在中间插入，你可能需要重新评估数据结构或算法。</p><p>字符串查找可以使用find,返回值是索引</p><p><strong>作用：</strong> 在字符串中查找子串或字符。</p><ul><li><strong><code>size_type find(const std::string&amp; str, size_type pos = 0) const;</code> / <code>find(CharT c, size_type pos = 0) const;</code> 等重载</strong><ul><li><strong>返回值：</strong> 如果找到，返回第一次出现的起始位置索引；如果未找到，返回 <code>std::string::npos</code>。</li><li><strong>注意事项：</strong> <code>pos</code> 指定从哪个位置开始查找。<code>npos</code> 是 <code>size_type</code> 的一个特殊静态成员常量，通常是 <code>size_type</code> 的最大值，表示“找不到”。</li></ul></li><li><strong><code>size_type rfind(const std::string&amp; str, size_type pos = npos) const;</code> 等重载</strong><ul><li><strong>返回值：</strong> 如果找到，返回最后一次出现的起始位置索引；如果未找到，返回 <code>std::string::npos</code>。</li><li><strong>注意事项：</strong> <code>rfind</code> 从字符串末尾开始向前查找（但返回的索引是从字符串开头算的）。</li></ul></li><li><strong><code>size_type find_first_of(const std::string&amp; str, size_type pos = 0) const;</code> 等重载</strong><ul><li><strong>返回值：</strong> 查找 <code>str</code> 中<strong>任意一个字符</strong>在当前字符串中第一次出现的索引。</li><li><strong>注意事项：</strong> 如果 <code>str</code> 是 <code>&quot;aeiou&quot;</code>，它会查找 <code>a</code> 或 <code>e</code> 或 <code>i</code> 或 <code>o</code> 或 <code>u</code> 中任意一个字符的第一次出现。</li></ul></li><li><strong><code>size_type find_last_of(const std::string&amp; str, size_type pos = npos) const;</code> 等重载</strong><ul><li><strong>返回值：</strong> 查找 <code>str</code> 中<strong>任意一个字符</strong>在当前字符串中最后一次出现的索引。</li></ul></li><li><strong><code>size_type find_first_not_of(const std::string&amp; str, size_type pos = 0) const;</code> 等重载</strong><ul><li><strong>返回值：</strong> 查找<strong>不在</strong> <code>str</code> 中的字符在当前字符串中第一次出现的索引。</li></ul></li><li><strong><code>size_type find_last_not_of(const std::string&amp; str, size_type pos = npos) const;</code> 等重载</strong><ul><li><strong>返回值：</strong> 查找<strong>不在</strong> <code>str</code> 中的字符在当前字符串中最后一次出现的索引。</li></ul></li></ul><p>还有个replace方法可能容易忽略,能替换字符串</p><p><strong><code>std::string&amp; replace(size_type pos, size_type len, const std::string&amp; str);</code> 等重载</strong></p><ul><li><strong>返回值：</strong> 字符串自身的引用（<code>*this</code>）。</li><li><strong>注意事项：</strong> 将 <code>pos</code> 位置开始、长度为 <code>len</code> 的子串替换为 <code>str</code>。</li></ul><p>一般注意事项：</p><ul><li><strong>内存管理：</strong> <code>std::string</code> 会自动管理内存，你无需手动 <code>new</code> 或 <code>delete</code>。当字符串内容变化且当前容量不足时，它会自动重新分配内存（通常会以指数级增长，如 1.5 倍或 2 倍）。</li><li><strong>异常安全：</strong> <code>std::string</code> 的大多数操作都提供异常安全保证。</li><li><strong>性能考量：</strong> <strong>频繁的字符串拼接、插入、删除操作</strong>（尤其是字符串头部或中部）可能导致多次内存重新分配和数据拷贝，影响性能。在这种情况下，考虑使用 <code>reserve()</code> 预分配内存，或者考虑使用其他数据结构（如 <code>std::vector&lt;char&gt;</code> 或字符数组）在底层操作，再转换为 <code>std::string</code>。</li><li><strong><code>std::string::npos</code>：</strong> 这是一个静态成员常量，表示“未找到”或“到字符串末尾”。</li><li><strong>空字符串：</strong> 大多数操作都能正确处理空字符串，但访问 <code>front()</code>、<code>back()</code>、<code>operator[]</code> 或 <code>erase()</code> 等可能需要非空字符串的操作时，要特别注意空字符串的情况，避免未定义行为。</li></ul><h2 id="list与deque的常用操作"><a href="#list与deque的常用操作" class="headerlink" title="list与deque的常用操作"></a>list与deque的常用操作</h2><p>list是双向链表,在链表两端增删数据效率O(1),但查询需要遍历,而deque支持随机访问.</p><p><code>std::list</code> 是一个<strong>双向链表</strong>实现，这意味着它的元素在内存中<strong>不一定是连续存储的</strong>。每个元素都包含指向前一个和后一个元素的指针。</p><p><strong>快速插入/删除：</strong> 在列表的任何位置进行插入和删除操作都是<strong>常数时间复杂度 O(1)</strong>，因为只需要修改少量指针。</p><p><strong>不支持随机访问：</strong> 无法通过索引 <code>[]</code> 或 <code>at()</code> 直接访问元素，访问元素需要<strong>线性时间 O(n)</strong> 遍历。</p><p><strong>迭代器稳定性：</strong> 插入和删除操作不会使其他迭代器失效（除了被删除的元素对应的迭代器）。</p><p><strong>内存开销：</strong> 每个元素除了存储数据本身，还需要额外的内存来存储前后指针，因此比 <code>std::vector</code> 和 <code>std::deque</code> 有更高的内存开销。</p><p><strong><code>iterator erase(const_iterator pos);</code></strong></p><ul><li><strong>返回值：</strong> 指向被删除元素<strong>之后</strong>的元素的迭代器。</li><li><strong>注意事项：</strong> 删除 <code>pos</code> 处元素。O(1) 复杂度。<code>pos</code> 必须有效且不能是 <code>end()</code>。</li></ul><p><strong><code>iterator erase(const_iterator first, const_iterator last);</code></strong></p><ul><li><strong>返回值：</strong> 指向被删除范围<strong>之后</strong>的元素的迭代器。</li><li><strong>注意事项：</strong> 删除范围 <code>[first, last)</code> 的元素</li></ul><p><code>std::list</code> 作为双向链表，其核心优势在于<strong>高效的非尾部插入和删除</strong>以及<strong>迭代器稳定性</strong>。因此，它拥有一系列专门针对链表特性的方法：</p><ol><li><code>splice()</code> 系列方法<ul><li><strong>作用：</strong> 这是 <code>std::list</code> 最独特且功能强大的方法之一。它能以 <strong>O(1) 的复杂度</strong>（不包括查找插入位置和移动元素的迭代器）将一个 <code>list</code> 的元素<strong>移动</strong>到另一个 <code>list</code> 中，或者移动一个 <code>list</code> 中的部分元素。元素不是复制，而是直接修改它们的链表指针，效率极高。</li><li><strong>重载示例：</strong><ul><li><code>void splice(const_iterator pos, std::list&amp; other);</code>：将 <code>other</code> 整个列表的所有元素移动到当前列表的 <code>pos</code> 之前。<code>other</code> 列表会变空。</li><li><code>void splice(const_iterator pos, std::list&amp; other, const_iterator it);</code>：将 <code>other</code> 列表中 <code>it</code> 指向的单个元素移动到当前列表的 <code>pos</code> 之前。</li><li><code>void splice(const_iterator pos, std::list&amp; other, const_iterator first, const_iterator last);</code>：将 <code>other</code> 列表中 <code>[first, last)</code> 范围内的元素移动到当前列表的 <code>pos</code> 之前。</li></ul></li><li><strong><code>vector</code> 对比：</strong> <code>std::vector</code> 没有 <code>splice</code> 方法，因为其底层是连续内存，任何元素的“移动”实际上都是复制和删除，需要 O(n) 复杂度。</li></ul></li><li><code>remove()</code> 和 <code>remove_if()</code><ul><li><strong>作用：</strong> 删除列表中所有等于特定值（<code>remove</code>）或满足特定条件（<code>remove_if</code>）的元素。</li><li><strong>重载示例：</strong><ul><li><code>void remove(const T&amp; value);</code></li><li><code>template&lt;class Predicate&gt; void remove_if(Predicate pred);</code></li></ul></li><li><strong><code>vector</code> 对比：</strong> <code>std::vector</code> 通常通过“移除-擦除 (erase-remove idiom)”来实现类似功能：<code>vec.erase(std::remove(vec.begin(), vec.end(), value), vec.end());</code>。这在 <code>std::vector</code> 中是 O(n) 操作，并且会移动元素，而 <code>std::list</code> 的 <code>remove</code> 操作是真正的 O(n) 遍历和 O(1) 删除每个元素。</li></ul></li><li><code>unique()</code><ul><li><strong>作用：</strong> 删除列表中<strong>连续的重复元素</strong>。</li><li><strong>重载示例：</strong><ul><li><code>void unique();</code></li><li><code>template&lt;class BinaryPredicate&gt; void unique(BinaryPredicate binary_pred);</code></li></ul></li><li><strong><code>vector</code> 对比：</strong> <code>std::vector</code> 使用 <code>std::unique</code> 算法（同样需要配合 <code>erase</code>），它也只删除连续重复的元素。但 <code>list</code> 的 <code>unique</code> 是成员函数，是针对链表优化的。</li></ul></li><li><code>merge()</code><ul><li><strong>作用：</strong> 将另一个<strong>已排序的列表</strong>的元素合并到当前列表，使当前列表保持排序。另一个列表会被清空。</li><li><strong>重载示例：</strong><ul><li><code>void merge(std::list&amp; other);</code></li><li><code>template&lt;class Compare&gt; void merge(std::list&amp; other, Compare comp);</code></li></ul></li><li><strong><code>vector</code> 对比：</strong> <code>std::vector</code> 通常使用 <code>std::merge</code> 算法，它会创建一个新容器来存放合并结果，而不是直接在原地合并并清空源容器。<code>list</code> 的 <code>merge</code> 操作是基于链表指针的 O(n) 高效合并。</li></ul></li><li><code>sort()</code><ul><li><strong>作用：</strong> 对列表进行排序。</li><li><strong>重载示例：</strong><ul><li><code>void sort();</code></li><li><code>template&lt;class Compare&gt; void sort(Compare comp);</code></li></ul></li><li><strong><code>vector</code> 对比：</strong> <code>std::vector</code> 使用全局函数 <code>std::sort</code>，它要求随机访问迭代器。由于 <code>std::list</code> 不支持随机访问，它不能使用 <code>std::sort</code>，因此它提供了自己的成员 <code>sort()</code> 方法，通常是基于归并排序（merge sort）的变种，以适应链表结构。</li></ul></li><li><code>reverse()</code><ul><li><strong>作用：</strong> 反转列表中元素的顺序。</li><li><strong>重载示例：</strong><ul><li><code>void reverse();</code></li></ul></li><li><strong><code>vector</code> 对比：</strong> <code>std::vector</code> 可以使用 <code>std::reverse</code> 算法。<code>list</code> 的 <code>reverse</code> 是成员函数，针对链表结构优化。</li></ul></li></ol><p><code>std::deque</code> (double-ended queue) 是一个<strong>双端队列</strong>容器，它支持在两端（头部和尾部）快速插入和删除元素。它在内部通常实现为<strong>分段的动态数组</strong>，这意味着其元素在内存中不一定是连续的，但可以通过一个“映射”结构来快速访问。</p><p><code>std::deque</code> 的设计目标是支持两端的高效插入/删除，同时保留随机访问的能力。虽然它的特殊方法不如 <code>std::list</code> 那么多，但其头部操作是其显著优势</p><p><strong>头部/尾部快速插入/删除：</strong> <code>push_front()</code>, <code>pop_front()</code>, <code>push_back()</code>, <code>pop_back()</code> 都是<strong>常数时间复杂度 O(1)</strong>。</p><p><strong>随机访问：</strong> 支持通过索引 <code>[]</code> 和 <code>at()</code> 进行随机访问，平均是<strong>常数时间复杂度 O(1)</strong> (因为它通过映射表快速找到对应内存段)。</p><p><strong>中部插入/删除：</strong> 在中部插入和删除元素是<strong>线性时间复杂度 O(n)</strong>，因为可能需要移动元素。</p><p><strong>迭代器稳定性：</strong></p><ul><li>在头部或尾部插入/删除不会使现有迭代器失效（除了指向被删除元素的迭代器）。</li><li>在<strong>中部</strong>插入或删除会使<strong>所有迭代器</strong>失效。</li></ul><p><strong>内存使用：</strong> 比 <code>std::vector</code> 更灵活，因为它不要求连续内存，但可能比 <code>std::vector</code> 有略高的间接访问开销。</p><p><strong><code>iterator insert(const_iterator pos, const T&amp; value);</code> / <code>insert(const_iterator pos, T&amp;&amp; value);</code> 等重载</strong></p><ul><li><strong>返回值：</strong> 指向新插入元素的迭代器。</li><li><strong>注意事项：</strong> 在 <code>pos</code> 迭代器指向的位置<strong>之前</strong>插入元素。中部插入是 O(n) 复杂度。<code>pos</code> 可以是 <code>end()</code>。<strong>所有迭代器可能失效</strong>。</li></ul><p><strong><code>iterator insert(const_iterator pos, size_type count, const T&amp; value);</code></strong></p><ul><li><strong>返回值：</strong> 指向新插入序列第一个元素的迭代器。</li></ul><p><strong><code>template&lt;class InputIt&gt; iterator insert(const_iterator pos, InputIt first, InputIt last);</code></strong></p><ul><li><strong>返回值：</strong> 指向新插入序列第一个元素的迭代器。</li></ul><p><strong><code>iterator erase(const_iterator pos);</code></strong></p><ul><li><strong>返回值：</strong> 指向被删除元素<strong>之后</strong>的元素的迭代器。</li><li><strong>注意事项：</strong> 删除 <code>pos</code> 处元素。中部删除是 O(n) 复杂度。<code>pos</code> 必须有效且不能是 <code>end()</code>。<strong>所有迭代器可能失效</strong>。</li></ul><p><strong><code>iterator erase(const_iterator first, const_iterator last);</code></strong></p><ul><li><strong>返回值：</strong> 指向被删除范围<strong>之后</strong>的元素的迭代器。</li><li><strong>注意事项：</strong> 删除范围 <code>[first, last)</code> 的元素。</li></ul><p><strong><code>void clear();</code></strong></p><ul><li><strong>返回值：</strong> <code>void</code>。</li><li><strong>注意事项：</strong> 删除所有元素，双端队列变为空。</li></ul><p><strong><code>void resize(size_type count);</code> / <code>void resize(size_type count, const T&amp; value);</code></strong></p><ul><li><strong>返回值：</strong> <code>void</code>。</li><li><strong>注意事项：</strong> 改变双端队列大小。</li></ul><p><strong><code>void swap(std::deque&amp; other);</code></strong></p><ul><li><strong>返回值：</strong> <code>void</code>。</li><li><strong>注意事项：</strong> 交换两个双端队列的内容，O(1) 复杂度</li></ul><p><code>push_front()</code></p><ul><li><strong>作用：</strong> 在双端队列的<strong>头部</strong>添加一个元素。</li><li><strong>重载示例：</strong><ul><li><code>void push_front(const T&amp; value);</code></li><li><code>void push_front(T&amp;&amp; value);</code></li></ul></li><li><strong><code>vector</code> 对比：</strong> <code>std::vector</code> 没有 <code>push_front()</code> 方法。在 <code>vector</code> 的头部插入元素需要将所有现有元素后移，复杂度为 O(n)，效率极低。<code>deque</code> 的 <code>push_front()</code> 是<strong>常数时间复杂度 O(1) (均摊)</strong>。</li></ul><p><code>pop_front()</code></p><ul><li><strong>作用：</strong> 删除双端队列的<strong>头部</strong>元素。</li><li><strong>重载示例：</strong><ul><li><code>void pop_front();</code></li></ul></li><li><strong><code>vector</code> 对比：</strong> <code>std::vector</code> 没有 <code>pop_front()</code> 方法。在 <code>vector</code> 的头部删除元素同样需要将所有后续元素前移，复杂度为 O(n)。<code>deque</code> 的 <code>pop_front()</code> 是<strong>常数时间复杂度 O(1) (均摊)</strong>。</li></ul><p><code>std::vector</code> 专注于<strong>连续内存</strong>和<strong>快速随机访问</strong>，以及<strong>尾部操作</strong>。它的优势在于缓存局部性好，适合作为动态数组。</p><p><code>std::list</code> 则专注于<strong>高效的任意位置插入和删除</strong>，其 <code>splice()</code>、<code>remove()</code>、<code>merge()</code> 和成员 <code>sort()</code> 等方法都是其链表特性的体现，是 <code>vector</code> 所不具备的。</p><p><code>std::deque</code> 则是介于两者之间，它提供了 <code>vector</code> 的大部分功能（包括随机访问），同时具备 <code>list</code> 在<strong>两端操作</strong>上的 O(1) 优势，即 <code>push_front()</code> 和 <code>pop_front()</code> 是其独有且高效的操作。</p><h2 id="stack与queue"><a href="#stack与queue" class="headerlink" title="stack与queue"></a>stack与queue</h2><hr><p><code>std::stack</code> 和 <code>std::queue</code> 是 C++ 标准库（STL）中两种非常重要的<strong>容器适配器（Container Adapters）</strong>。它们不是独立的底层数据结构，而是将现有的序列容器（如 <code>std::deque</code>、<code>std::list</code> 或 <code>std::vector</code>）封装起来，提供特定的访问接口，从而模拟栈（LIFO，后进先出）和队列（FIFO，先进先出）的行为。</p><p><strong>构造函数 (Constructors)</strong></p><ul><li><strong><code>std::stack&lt;T&gt; s;</code></strong><ul><li><strong>功能：</strong> 创建一个空的栈。默认底层容器是 <code>std::deque&lt;T&gt;</code>。</li><li><strong>返回值：</strong> 无。</li><li><strong>例子：</strong> <code>std::stack&lt;int&gt; myStack;</code></li></ul></li><li><strong><code>std::stack&lt;T, Container&gt; s(container_obj);</code></strong><ul><li><strong>功能：</strong> 使用指定的底层容器类型 <code>Container</code> 创建栈，并用一个现有容器对象初始化。</li><li><strong>返回值：</strong> 无。</li><li><strong>例子：</strong> <code>std::list&lt;int&gt; myList = &#123;1, 2, 3&#125;; std::stack&lt;int, std::list&lt;int&gt;&gt; myStackFromList(myList);</code></li></ul></li></ul><p><strong><code>s.push(const T&amp; value)</code></strong></p><ul><li><strong>功能：</strong> 在栈顶插入一个元素。</li><li><strong>返回值：</strong> 无。</li><li><strong>例子：</strong> <code>myStack.push(10);</code></li></ul><p><strong><code>s.pop()</code></strong></p><ul><li><strong>功能：</strong> 移除栈顶元素。</li><li><strong>返回值：</strong> 无。</li><li><strong>注意事项：</strong> <strong>不返回被移除的元素。</strong> 在调用前必须确保栈不为空，否则会导致未定义行为。</li><li><strong>例子：</strong> <code>myStack.pop();</code></li></ul><p><strong><code>s.top()</code></strong></p><ul><li><strong>功能：</strong> 返回栈顶元素的引用。</li><li><strong>返回值：</strong> <code>T&amp;</code> (对栈顶元素的引用)。</li><li><strong>注意事项：</strong> <strong>不移除元素。</strong> 在调用前必须确保栈不为空，否则会导致未定义行为。</li><li><strong>例子：</strong> <code>int topElement = myStack.top();</code></li></ul><p><strong><code>std::queue&lt;T&gt; q;</code></strong></p><ul><li><strong>功能：</strong> 创建一个空的队列。默认底层容器是 <code>std::deque&lt;T&gt;</code>。</li><li><strong>返回值：</strong> 无。</li><li><strong>例子：</strong> <code>std::queue&lt;std::string&gt; myQueue;</code></li></ul><p><strong><code>std::queue&lt;T, Container&gt; q(container_obj);</code></strong></p><ul><li><strong>功能：</strong> 使用指定的底层容器类型 <code>Container</code> 创建队列，并用一个现有容器对象初始化。</li><li><strong>返回值：</strong> 无。</li><li><strong>例子：</strong> <code>std::vector&lt;std::string&gt; myVec = &#123;&quot;A&quot;, &quot;B&quot;&#125;; std::queue&lt;std::string, std::vector&lt;std::string&gt;&gt; myQueueFromVec(myVec);</code> （注意：<code>vector</code> 不支持 <code>pop_front</code>，所以不能作为 <code>queue</code> 的底层容器。这里写错，正确的应该是 <code>std::list</code> 或 <code>std::deque</code>）</li><li><strong>更正例子：</strong> <code>std::deque&lt;std::string&gt; myDeque = &#123;&quot;A&quot;, &quot;B&quot;&#125;; std::queue&lt;std::string, std::deque&lt;std::string&gt;&gt; myQueueFromDeque(myDeque);</code></li></ul><p><strong><code>q.push(const T&amp; value)</code></strong></p><ul><li><strong>功能：</strong> 在队尾插入一个元素。</li><li><strong>返回值：</strong> 无。</li><li><strong>例子：</strong> <code>myQueue.push(&quot;Task 1&quot;);</code></li></ul><p><strong><code>q.pop()</code></strong></p><ul><li><strong>功能：</strong> 移除队头元素。</li><li><strong>返回值：</strong> 无。</li><li><strong>注意事项：</strong> <strong>不返回被移除的元素。</strong> 在调用前必须确保队列不为空，否则会导致未定义行为。</li><li><strong>例子：</strong> <code>myQueue.pop();</code></li></ul><p><strong><code>q.front()</code></strong></p><ul><li><strong>功能：</strong> 返回队头元素的引用。</li><li><strong>返回值：</strong> <code>T&amp;</code> (对队头元素的引用)。</li><li><strong>注意事项：</strong> <strong>不移除元素。</strong> 在调用前必须确保队列不为空，否则会导致未定义行为。</li><li><strong>例子：</strong> <code>std::string currentTask = myQueue.front();</code></li></ul><p><strong><code>q.back()</code></strong></p><ul><li><strong>功能：</strong> 返回队尾元素的引用。</li><li><strong>返回值：</strong> <code>T&amp;</code> (对队尾元素的引用)。</li><li><strong>注意事项：</strong> <strong>不移除元素。</strong> 在调用前必须确保队列不为空，否则会导致未定义行为。</li><li><strong>例子：</strong> <code>std::string lastAddedTask = myQueue.back();</code></li></ul><p>注意队列有q.back获得队尾元素,而栈只能访问一端,也就是栈顶.</p><h2 id="map-unordered-map"><a href="#map-unordered-map" class="headerlink" title="map/unordered_map"></a>map/unordered_map</h2><p><code>std::map</code> 是 C++ 标准库中的一个<strong>有序关联容器</strong>，它存储键值对 (key-value pairs)。它的主要特点是：</p><ul><li><strong>键是唯一的</strong>：<code>std::map</code> 中不允许有重复的键。</li><li><strong>元素是排序的</strong>：<code>std::map</code> 中的所有元素都会根据它们的键自动进行<strong>升序排序</strong>。默认情况下，它使用键类型的 <code>operator&lt;</code> 进行排序。</li><li><strong>底层实现是平衡二叉搜索树</strong>：通常是<strong>红黑树</strong>。这确保了大部分操作的对数时间复杂度。</li></ul><p><strong><code>std::map&lt;Key, Value&gt; m;</code></strong></p><ul><li><strong>功能：</strong> 创建一个空的 <code>map</code>。</li><li><strong>返回值：</strong> 无。</li><li><strong>示例：</strong> <code>std::map&lt;std::string, int&gt; wordCounts;</code></li></ul><p><strong><code>std::map&lt;Key, Value&gt; m = &#123;&#123;k1, v1&#125;, &#123;k2, v2&#125;&#125;;</code></strong></p><ul><li><strong>功能：</strong> 使用初始化列表创建 <code>map</code>。</li><li><strong>返回值：</strong> 无。</li><li><strong>示例：</strong> <code>std::map&lt;int, char&gt; grades = &#123;&#123;1, 'A'&#125;, &#123;2, 'B'&#125;&#125;;</code></li></ul><p><strong><code>std::map&lt;Key, Value&gt; m(first, last);</code></strong></p><ul><li><strong>功能：</strong> 从另一个范围 <code>[first, last)</code> 初始化 <code>map</code>，<strong>范围内的元素必须是键值对类型</strong>（如 <code>std::pair&lt;Key, Value&gt;</code>）。</li><li><strong>返回值：</strong> 无。</li></ul><p><strong><code>m.insert(&#123;key, value&#125;)</code> / <code>m.insert(std::make_pair(key, value))</code></strong></p><ul><li><strong>功能：</strong> 插入一个键值对。如果 <code>key</code> 已存在，则插入失败，<code>map</code> 不会被修改。</li><li><strong>返回值：</strong> <code>std::pair&lt;iterator, bool&gt;</code>。<ul><li><code>iterator</code> 指向新插入的元素或已存在的具有相同键的元素。</li><li><code>bool</code> 为 <code>true</code> 表示成功插入新元素，<code>false</code> 表示元素已存在。</li></ul></li></ul><p><strong><code>m.emplace(Args&amp;&amp;... args)</code> (C++11)</strong></p><ul><li><strong>功能：</strong> 在 <code>map</code> 中就地构造一个键值对。通常比 <code>insert</code> 接受 <code>std::pair</code> 更高效。</li><li><strong>返回值：</strong> 同 <code>insert</code>。</li></ul><p><strong><code>m.erase(const Key&amp; key)</code></strong></p><ul><li><strong>功能：</strong> 删除 <code>map</code> 中匹配 <code>key</code> 的键值对。</li><li><strong>返回值：</strong> <code>size_type</code>，表示被删除元素的数量（对于 <code>map</code> 而言，总是 <strong>0 或 1</strong>，因为键是唯一的）。</li></ul><p><strong><code>m.erase(iterator pos)</code></strong></p><ul><li><strong>功能：</strong> 删除 <code>pos</code> 迭代器指向的单个元素。</li><li><strong>返回值：</strong> 指向被删除元素之后<strong>第一个有效元素</strong>的<strong>迭代器</strong>。如果删除的是最后一个元素，则返回 <code>m.end()</code>。</li></ul><p><strong><code>m.erase(iterator first, iterator last)</code></strong></p><ul><li><strong>功能：</strong> 删除 <code>[first, last)</code> 范围内的元素。</li><li><strong>返回值：</strong> 指向被删除范围之后<strong>第一个有效元素</strong>的<strong>迭代器</strong>。</li></ul><p><strong><code>m.count(const Key&amp; key)</code></strong></p><ul><li><strong>功能：</strong> 返回 <code>map</code> 中匹配 <code>key</code> 的元素数量。</li><li><strong>返回值：</strong> <code>size_type</code> (对于 <code>map</code> 而言，总是 <strong>0 或 1</strong>)。</li></ul><p><strong><code>m.find(const Key&amp; key)</code></strong></p><ul><li><strong>功能：</strong> 查找 <code>map</code> 中匹配 <code>key</code> 的元素。</li><li><strong>返回值：</strong> 如果找到，返回指向该元素的<strong>迭代器</strong>；否则，返回 <code>m.end()</code> 迭代器。</li></ul><p><strong><code>m.lower_bound(const Key&amp; key)</code></strong></p><ul><li><strong>功能：</strong> 返回指向<strong>第一个键不小于 <code>key</code> 的元素</strong>的迭代器。</li><li><strong>返回值：</strong> <code>iterator</code>。</li></ul><p><strong><code>m.upper_bound(const Key&amp; key)</code></strong></p><ul><li><strong>功能：</strong> 返回指向<strong>第一个键大于 <code>key</code> 的元素</strong>的迭代器。</li><li><strong>返回值：</strong> <code>iterator</code></li></ul><p><code>std::unordered_map</code> 是一种<strong>无序的关联容器</strong>，它通过<strong>哈希表（Hash Table）</strong>实现。它也存储键值对，但元素没有特定的排序，而是根据键的哈希值来组织。</p><p><strong><code>um.insert(&#123;key, value&#125;)</code> / <code>um.insert(std::make_pair(key, value))</code></strong></p><ul><li><strong>功能：</strong> 插入一个键值对。如果 <code>key</code> 已存在，则插入失败。</li><li><strong>返回值：</strong> <code>std::pair&lt;iterator, bool&gt;</code>。同 <code>std::map</code>。</li></ul><p><strong><code>um.emplace(Args&amp;&amp;... args)</code> (C++11)</strong></p><ul><li><strong>功能：</strong> 就地构造一个键值对。</li><li><strong>返回值：</strong> 同 <code>insert</code>。</li></ul><p><strong><code>um.erase(const Key&amp; key)</code></strong></p><ul><li><strong>功能：</strong> 删除 <code>unordered_map</code> 中匹配 <code>key</code> 的键值对。</li><li><strong>返回值：</strong> <code>size_type</code>，表示被删除元素的数量（对于 <code>unordered_map</code> 而言，总是 <strong>0 或 1</strong>，因为键是唯一的）。</li></ul><p><strong><code>um.erase(iterator pos)</code></strong></p><ul><li><strong>功能：</strong> 删除 <code>pos</code> 迭代器指向的单个元素。</li><li><strong>返回值：</strong> 指向被删除元素之后<strong>下一个可能有效（但无序）的元素</strong>的<strong>迭代器</strong>。</li></ul><p><strong><code>um.erase(iterator first, iterator last)</code></strong></p><ul><li><strong>功能：</strong> 删除 <code>[first, last)</code> 范围内的元素。</li><li><strong>返回值：</strong> 指向被删除范围之后<strong>下一个可能有效（但无序）的元素</strong>的<strong>迭代器</strong>。</li></ul><p><strong><code>um.count(const Key&amp; key)</code></strong></p><ul><li><strong>功能：</strong> 返回 <code>unordered_map</code> 中匹配 <code>key</code> 的元素数量。</li><li><strong>返回值：</strong> <code>size_type</code> (总是 <strong>0 或 1</strong>)。</li></ul><p><strong><code>um.find(const Key&amp; key)</code></strong></p><ul><li><strong>功能：</strong> 查找 <code>unordered_map</code> 中匹配 <code>key</code> 的元素。</li><li><strong>返回值：</strong> 如果找到，返回指向该元素的<strong>迭代器</strong>；否则，返回 <code>um.end()</code> 迭代器。</li></ul><h2 id="set-unordered-set"><a href="#set-unordered-set" class="headerlink" title="set/unordered_set"></a>set/unordered_set</h2><p><code>std::set</code> 是一种<strong>有序的关联容器</strong>，它存储<strong>唯一</strong>的元素，并且所有元素都根据其值的<strong>严格弱序（strict weak ordering）\</strong>进行排序。其底层通常实现为*<em>红黑树（Red-Black Tree）*</em>。</p><p><strong><code>std::set&lt;T&gt; s;</code></strong></p><ul><li><strong>功能：</strong> 创建一个空的 <code>set</code>。</li><li><strong>返回值：</strong> 无。</li><li><strong>示例：</strong> <code>std::set&lt;int&gt; mySet;</code></li></ul><p><strong><code>std::set&lt;T&gt; s = &#123;e1, e2, ...&#125;;</code></strong></p><ul><li><strong>功能：</strong> 使用初始化列表创建 <code>set</code>。</li><li><strong>返回值：</strong> 无。</li><li><strong>示例：</strong> <code>std::set&lt;std::string&gt; uniqueWords = &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;apple&quot;&#125;;</code> (实际只存储 “apple”, “banana”)</li></ul><p><strong><code>std::set&lt;T&gt; s(first, last);</code></strong></p><ul><li><strong>功能：</strong> 从另一个范围 <code>[first, last)</code> 初始化 <code>set</code>。</li><li><strong>返回值：</strong> 无。</li></ul><p><strong><code>s.insert(const T&amp; value)</code> / <code>s.insert(T&amp;&amp; value)</code></strong></p><ul><li><strong>功能：</strong> 插入一个元素。如果 <code>value</code> 已存在，则插入失败，<code>set</code> 不会被修改。</li><li><strong>返回值：</strong> <code>std::pair&lt;iterator, bool&gt;</code>。<ul><li><code>iterator</code> 指向新插入的元素或已存在的相同元素。</li><li><code>bool</code> 为 <code>true</code> 表示成功插入新元素，<code>false</code> 表示元素已存在。</li></ul></li></ul><p><strong><code>s.emplace(Args&amp;&amp;... args)</code> (C++11)</strong></p><ul><li><strong>功能：</strong> 在 <code>set</code> 中就地构造一个元素。</li><li><strong>返回值：</strong> 同 <code>insert</code>。</li></ul><p><strong><code>s.erase(const T&amp; value)</code></strong></p><ul><li><strong>功能：</strong> 删除 <code>set</code> 中匹配 <code>value</code> 的元素。</li><li><strong>返回值：</strong> <code>size_type</code>，表示被删除元素的数量（对于 <code>set</code> 而言，总是 <strong>0 或 1</strong>，因为元素是唯一的）。</li></ul><p><strong><code>s.erase(iterator pos)</code></strong></p><ul><li><strong>功能：</strong> 删除 <code>pos</code> 迭代器指向的单个元素。</li><li><strong>返回值：</strong> 指向被删除元素之后<strong>第一个有效元素</strong>的<strong>迭代器</strong>。如果删除的是最后一个元素，则返回 <code>s.end()</code>。</li></ul><p><strong><code>s.erase(iterator first, iterator last)</code></strong></p><ul><li><strong>功能：</strong> 删除 <code>[first, last)</code> 范围内的元素。</li><li><strong>返回值：</strong> 指向被删除范围之后<strong>第一个有效元素</strong>的<strong>迭代器</strong>。</li></ul><p><strong><code>s.count(const T&amp; value)</code></strong></p><ul><li><strong>功能：</strong> 返回 <code>set</code> 中匹配 <code>value</code> 的元素数量。</li><li><strong>返回值：</strong> <code>size_type</code> (对于 <code>set</code> 而言，总是 <strong>0 或 1</strong>)。</li></ul><p><strong><code>s.find(const T&amp; value)</code></strong></p><ul><li><strong>功能：</strong> 查找 <code>set</code> 中匹配 <code>value</code> 的元素。</li><li><strong>返回值：</strong> 如果找到，返回指向该元素的<strong>迭代器</strong>；否则，返回 <code>s.end()</code> 迭代器。</li></ul><p><strong><code>s.lower_bound(const T&amp; value)</code></strong></p><ul><li><strong>功能：</strong> 返回指向<strong>第一个不小于 <code>value</code> 的元素</strong>的迭代器。</li><li><strong>返回值：</strong> <code>iterator</code>。</li></ul><p><strong><code>s.upper_bound(const T&amp; value)</code></strong></p><ul><li><strong>功能：</strong> 返回指向<strong>第一个大于 <code>value</code> 的元素</strong>的迭代器。</li><li><strong>返回值：</strong> <code>iterator</code>。</li></ul><p><code>std::set</code> 的元素类型 (<code>T</code>) 必须是<strong>可比较的</strong>。这意味着它必须能够通过 <code>operator&lt;</code> 进行排序，或者你需要提供一个自定义的比较函数。</p><p><code>std::unordered_set</code> 是一种<strong>无序的关联容器</strong>，它存储<strong>唯一</strong>的元素。其底层通过<strong>哈希表（Hash Table）</strong>实现。</p><p><strong><code>us.insert(const T&amp; value)</code> / <code>us.insert(T&amp;&amp; value)</code></strong></p><ul><li><strong>功能：</strong> 插入一个元素。如果 <code>value</code> 已存在，则插入失败。</li><li><strong>返回值：</strong> <code>std::pair&lt;iterator, bool&gt;</code>。同 <code>std::set</code>。</li></ul><p><strong><code>us.emplace(Args&amp;&amp;... args)</code> (C++11)</strong></p><ul><li><strong>功能：</strong> 就地构造一个元素。</li><li><strong>返回值：</strong> 同 <code>insert</code>。</li></ul><p><strong><code>us.erase(const T&amp; value)</code></strong></p><ul><li><strong>功能：</strong> 删除 <code>unordered_set</code> 中匹配 <code>value</code> 的元素。</li><li><strong>返回值：</strong> <code>size_type</code>，表示被删除元素的数量（对于 <code>unordered_set</code> 而言，总是 <strong>0 或 1</strong>）。</li></ul><p><strong><code>us.erase(iterator pos)</code></strong></p><ul><li><strong>功能：</strong> 删除 <code>pos</code> 迭代器指向的单个元素。</li><li><strong>返回值：</strong> 指向被删除元素之后<strong>下一个可能有效（但无序）的元素</strong>的<strong>迭代器</strong>。</li></ul><p><strong><code>us.erase(iterator first, iterator last)</code></strong></p><ul><li><strong>功能：</strong> 删除 <code>[first, last)</code> 范围内的元素。</li><li><strong>返回值：</strong> 指向被删除范围之后<strong>下一个可能有效（但无序）的元素</strong>的<strong>迭代器</strong>。</li></ul><p><strong><code>us.count(const T&amp; value)</code></strong></p><ul><li><strong>功能：</strong> 返回 <code>unordered_set</code> 中匹配 <code>value</code> 的元素数量。</li><li><strong>返回值：</strong> <code>size_type</code> (总是 <strong>0 或 1</strong>)。</li></ul><p><strong><code>us.find(const T&amp; value)</code></strong></p><ul><li><strong>功能：</strong> 查找 <code>unordered_set</code> 中匹配 <code>value</code> 的元素。</li><li><strong>返回值：</strong> 如果找到，返回指向该元素的<strong>迭代器</strong>；否则，返回 <code>us.end()</code> 迭代器。</li></ul><h3 id="erase与find的参数与对应返回值"><a href="#erase与find的参数与对应返回值" class="headerlink" title="erase与find的参数与对应返回值"></a>erase与find的参数与对应返回值</h3><p>在map/set以及unordered_map/unordered_set中,erase成员方法参数如果是size_type,返回值是删除个数,如果是迭代器或者迭代器范围,返回值指向下一个元素迭代器. 而find通过值返回迭代器.</p><p>而在string中,erase参数是offset与len,返回指向新字符串的引用,find参数是字符或字符串返回size_type索引.</p><p>而在vector,list中,erase参数是迭代器或者迭代器范围,返回删除成功后指向的下一个元素迭代器,而没有find成员方法.</p><h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p><code>std::priority_queue</code> 是 C++ 标准库 (STL) 中的一个<strong>容器适配器 (Container Adapter)</strong>，它提供了一个类似队列的接口，但其<strong>内部元素总是按照特定优先级排序</strong>。默认情况下，它是一个<strong>最大堆（Max-Heap）</strong>，意味着队头元素总是当前所有元素中最大的</p><p><strong><code>std::priority_queue&lt;T&gt; pq;</code></strong></p><ul><li><strong>功能：</strong> 创建一个空的优先级队列。默认底层容器是 <code>std::vector&lt;T&gt;</code>，默认比较器是 <code>std::less&lt;T&gt;</code> (用于实现最大堆)。</li><li><strong>返回值：</strong> 无。</li><li><strong>示例：</strong> <code>std::priority_queue&lt;int&gt; max_heap;</code></li></ul><p><strong><code>std::priority_queue&lt;T, Container, Compare&gt; pq(comp);</code></strong></p><ul><li><p><strong>功能：</strong> 使用指定的底层容器类型 <code>Container</code> 和自定义比较器 <code>Compare</code> 创建优先级队列。<code>comp</code> 是比较器的实例。</p></li><li><p><strong>返回值：</strong> 无。</p></li><li><p><strong>示例 (最小堆 - Min-Heap)：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::priority_queue&lt;<span class="keyword">int</span>, std::vector&lt;<span class="keyword">int</span>&gt;, std::greater&lt;<span class="keyword">int</span>&gt;&gt; min_heap;</span><br></pre></td></tr></table></figure><p>这里，<code>std::greater&lt;int&gt;</code> 使得“大”的元素优先级“低”（因为 <code>a &gt; b</code> 为 <code>true</code>，<code>a</code> 就排在 <code>b</code> 后面），从而实现最小堆。</p></li></ul><p><strong><code>pq.push(const T&amp; value)</code></strong></p><ul><li><strong>功能：</strong> 插入一个元素到优先级队列中。它会根据优先级自动将其放置到正确的位置，并维护堆的属性。</li><li><strong>返回值：</strong> 无。</li><li><strong>例子：</strong> <code>max_heap.push(10);</code></li></ul><p><strong><code>pq.pop()</code></strong></p><ul><li><strong>功能：</strong> 移除优先级最高的元素（即堆顶元素）。</li><li><strong>返回值：</strong> 无。</li><li><strong>注意事项：</strong> <strong>不返回被移除的元素。</strong> 在调用前必须确保队列不为空，否则会导致未定义行为。</li><li><strong>例子：</strong> <code>max_heap.pop();</code></li></ul><p><strong><code>pq.top()</code></strong></p><ul><li><strong>功能：</strong> 返回优先级最高的元素（即堆顶元素）的<strong>常量引用</strong>。</li><li><strong>返回值：</strong> <code>const T&amp;</code> (对堆顶元素的常量引用)。</li><li><strong>注意事项：</strong> <strong>不移除元素。</strong> 在调用前必须确保队列不为空，否则会导致未定义行为。</li><li><strong>例子：</strong> <code>int highest_priority_element = max_heap.top();</code></li></ul><p><strong><code>pq.empty()</code></strong></p><ul><li><strong>功能：</strong> 检查优先级队列是否为空。</li><li><strong>返回值：</strong> <code>bool</code> (<code>true</code> 表示空，<code>false</code> 表示非空)。</li><li><strong>例子：</strong> <code>if (max_heap.empty()) &#123; /* 队列为空 */ &#125;</code></li></ul><p><strong><code>pq.size()</code></strong></p><ul><li><strong>功能：</strong> 返回优先级队列中元素的数量。</li><li><strong>返回值：</strong> <code>size_type</code> (无符号整数类型)。</li><li><strong>例子：</strong> <code>std::cout &lt;&lt; max_heap.size();</code></li></ul><p><code>vector</code> 可以作为 <code>map</code> 的键但不能直接作为 <code>unordered_map</code> 的键</p><p>set同理.</p><p><code>std::map</code> 是一个<strong>有序关联容器</strong>，它的底层通常实现为<strong>红黑树</strong>（一种自平衡二叉搜索树）。<code>std::map</code> 存储元素时，需要能够对键进行<strong>排序</strong>。这意味着 <code>std::map</code> 的键类型必须是<strong>可比较的 (Comparable)</strong>，具体来说，它需要支持<strong>小于运算符 <code>operator&lt;</code></strong>。</p><p>而 <code>std::vector</code> 恰好<strong>默认提供了 <code>operator&lt;</code></strong> 的重载。</p><p>std::vector<code>的</code>operator&lt;` 是如何工作的？</p><p><code>std::vector</code> 的 <code>operator&lt;</code> 执行的是<strong>字典序 (lexicographical comparison)</strong> 比较。这意味着它会逐个元素地比较两个 <code>vector</code>：</p><ol><li>从第一个元素开始比较。</li><li>如果两个 <code>vector</code> 在某个位置上的元素不相等，那么拥有较小元素的那个 <code>vector</code> 被认为是“更小”的。</li><li>如果一个 <code>vector</code> 是另一个 <code>vector</code> 的前缀（即较短的那个 <code>vector</code> 的所有元素都与较长的 <code>vector</code> 的对应前缀元素相同），那么较短的那个 <code>vector</code> 被认为是“更小”的。</li></ol><p>关键在于它们底层的实现机制不同：</p><ul><li><p><strong><code>std::map</code> (基于红黑树)</strong>：</p><ul><li>需要键是<strong>可比较的</strong>（通过 <code>operator&lt;</code>）。</li><li><code>std::vector</code> 默认提供了字典序的 <code>operator&lt;</code>，所以它满足这个要求。</li><li>操作的平均时间复杂度是 O(logN)。</li></ul></li><li><p><strong><code>std::unordered_map</code> (基于哈希表)</strong>：</p><ul><li><p>需要键是<strong>可哈希的</strong>（通过 <code>std::hash</code> 特化）和<strong>可相等比较的</strong>（通过 <code>operator==</code>）。</p></li><li><p><code>std::vector</code> 默认<strong>没有提供 <code>std::hash</code> 特化</strong>，所以它不满足这个要求，除非你自定义哈希函数。</p></li><li><p>操作的平均时间复杂度是 O(1)。</p><p><code>std::unordered_set</code> 是一种<strong>无序集合容器</strong>，它存储唯一元素的集合。它的底层也是基于<strong>哈希表</strong>实现的。因此，它对所存储的元素类型有同样的要求：</p><ol><li><strong>可哈希 (Hashable)</strong>：必须存在 <code>std::hash&lt;T&gt;</code> 的特化，能够为元素类型 <code>T</code> 计算哈希值。</li><li><strong>可相等比较 (EqualityComparable)</strong>：元素类型 <code>T</code> 必须支持 <code>operator==</code>，用于在哈希冲突时判断元素是否真正相等。</li></ol></li></ul></li></ul><p>如果vector,string等作为map的key,然后对这个key进行了操作会怎样.</p><p>如果 <code>std::map</code> 的 <strong>key</strong> 是 <code>std::vector</code>，然后你对这个 <strong>作为 key 的 <code>std::vector</code> 对象本身</strong> 进行了修改（比如 <code>push_back</code> 元素或 <code>clear</code>），那会发生<strong>非常严重的问题</strong>，通常会导致<strong>未定义行为</strong></p><p><code>std::map</code> 依靠键的<strong>顺序</strong>来组织其内部的红黑树结构。当你插入一个 <code>std::vector</code> 作为键时，<code>map</code> 会使用 <code>std::vector</code> 的 <code>operator&lt;</code> 来确定这个键在树中的位置。</p><p>如果你修改了这个 <code>vector</code> 键（例如 <code>push_back</code>），它的内容就变了，这意味着它的<strong>字典序比较结果也可能改变</strong>。</p><p>此时，红黑树的内部结构就会变得<strong>不一致 (corrupted)</strong>。树的节点仍然按照旧的键值进行组织，但实际的键值已经改变，导致查找、插入、删除等操作都会出错，因为它们会根据错误的顺序进行导航。最终结果就是未定义行为，程序可能崩溃，也可能产生错误的结果。</p><h2 id="其他一些类"><a href="#其他一些类" class="headerlink" title="其他一些类"></a>其他一些类</h2><p>multimap/unordered_multimap</p><p>multiset/unordered_multiset</p><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p><code>std::tuple</code> 是一个固定大小的异构（heterogeneous）容器，可以存储<strong>不同类型</strong>的固定数量的对象。你可以把它想象成一个“增强版”的 <code>std::pair</code>，因为 <code>pair</code> 只能存储两个不同类型的元素，而 <code>tuple</code> 可以存储任意数量的不同类型元素。</p><p>核心特点</p><ul><li><strong>异构性</strong>: 存储的元素类型可以不同。</li><li><strong>固定大小</strong>: <code>tuple</code> 的大小在编译时就确定了，不能动态改变。</li><li><strong>零开销抽象</strong>: 通常，<code>tuple</code> 的性能可以媲美直接使用多个独立变量，编译器可以进行很好的优化。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::tuple&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, std::string&gt; <span class="title">t1</span><span class="params">(<span class="number">10</span>, <span class="number">3.14</span>, <span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// 或使用 C++11 后的列表初始化（需要显式指定类型）</span></span><br><span class="line">std::tuple&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, std::string&gt; t2 = &#123;<span class="number">20</span>, <span class="number">2.71</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> t3 = std::<span class="built_in">make_tuple</span>(<span class="number">30</span>, <span class="number">1.618</span>, <span class="string">&quot;C++&quot;</span>); <span class="comment">// t3 类型为 std::tuple&lt;int, double, const char*&gt;</span></span><br><span class="line"><span class="keyword">int</span> i = std::get&lt;<span class="number">0</span>&gt;(t1);         <span class="comment">// 获取第一个元素 (10)</span></span><br><span class="line"><span class="keyword">double</span> d = std::get&lt;<span class="number">1</span>&gt;(t1);      <span class="comment">// 获取第二个元素 (3.14)</span></span><br><span class="line">std::string s = std::get&lt;<span class="number">2</span>&gt;(t1); <span class="comment">// 获取第三个元素 (&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> size = std::tuple_size&lt;<span class="keyword">decltype</span>(t1)&gt;::value; <span class="comment">// size = 3</span></span><br><span class="line"><span class="keyword">auto</span> person = std::<span class="built_in">make_tuple</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>, <span class="string">&quot;New York&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> [name, age, city] = person; <span class="comment">// 相当于声明了 name, age, city 三个变量并赋值</span></span><br><span class="line">std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; city &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p><code>std::array</code> 是一个固定大小的<strong>同构</strong>序列容器，它封装了 C 风格的静态数组。它提供了像 <code>std::vector</code> 一样的 STL 容器接口（如迭代器、<code>size()</code>、<code>at()</code> 等），但它的<strong>大小在编译时就确定</strong>，且不能改变。它的数据是直接存储在栈上（如果大小允许且不是全局/静态），而不是堆上，避免了动态内存分配的开销。</p><p>核心特点</p><ul><li><strong>固定大小</strong>: 大小在编译时已知且不可变。</li><li><strong>同构性</strong>: 存储的元素类型必须相同。</li><li><strong>栈分配</strong>: 数据通常直接存储在栈上（除非太大或声明为全局/静态），性能优势明显。</li><li><strong>C 风格数组的替代</strong>: 提供了 C 风格数组的性能，同时拥有 STL 容器的安全性（如边界检查 <code>at()</code>) 和易用性。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::array&lt;<span class="keyword">int</span>, 5&gt; arr1; <span class="comment">// 声明一个包含 5 个 int 的 array，元素默认初始化 (int 为 0)</span></span><br><span class="line">std::array&lt;<span class="keyword">double</span>, 3&gt; arr2 = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>&#125;; <span class="comment">// 使用初始化列表</span></span><br></pre></td></tr></table></figure><h2 id="std下STL方法"><a href="#std下STL方法" class="headerlink" title="std下STL方法"></a>std下STL方法</h2><h1 id="遇到的错误"><a href="#遇到的错误" class="headerlink" title="遇到的错误"></a>遇到的错误</h1><ol><li>runtime error: addition of unsigned offset to 0x7fb499600340 overflowed to 0x7fb49960033f (basic_string.h)</li></ol><p>这是一个非常典型的 <strong>Undefined Behavior (UB)</strong> 警告/错误，通常由 Clang/LLVM 编译器（或其衍生的 sanitizers，如 AddressSanitizer/ASan）在运行时检测到。</p><p>为什么会发生这种错误？</p><ol><li><p><strong>无效的索引或指针算术：</strong></p><ul><li>你可能在使用一个指针或迭代器，并对其添加了一个负数或一个非常大的无符号数，导致指针指向了它不应该指向的内存区域，甚至“绕回”到内存地址空间的低端。</li><li>一个常见的场景是，你有一个指向数组末尾的指针，然后尝试对其进行 <code>ptr + offset</code> 操作，而 <code>offset</code> 是一个非常大的无符号数，或者实际上应该是一个负数但被误用为无符号数。</li></ul><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* p = some_array + size; <span class="comment">// p 指向数组末尾之后一个位置</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> offset = some_large_unsigned_value;</span><br><span class="line"><span class="keyword">char</span>* invalid_p = p + offset; <span class="comment">// 此时如果 offset 足够大，可能会导致地址回绕</span></span><br></pre></td></tr></table></figure><p>或者更直接的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* p = some_array;</span><br><span class="line"><span class="keyword">size_t</span> invalid_idx = <span class="number">-1</span>; <span class="comment">// 这是一个非常大的无符号数</span></span><br><span class="line"><span class="keyword">char</span> element = p[invalid_idx]; <span class="comment">// 等同于 p + invalid_idx，可能溢出</span></span><br></pre></td></tr></table></figure></li><li><p><strong>减法错误导致无符号数溢出：</strong></p><ul><li>如果你有一个无符号整型变量 <code>u_var</code>，并且执行 <code>u_var - another_unsigned_var</code>，如果 <code>u_var &lt; another_unsigned_var</code>，结果将是一个非常大的正数（无符号数下溢）。</li><li>然后你用这个非常大的结果作为内存偏移量。</li></ul><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">size_t</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 假设某种逻辑错误导致 index 变成了 0，然后你尝试 index - 1</span></span><br><span class="line"><span class="keyword">size_t</span> prev_index = index - <span class="number">1</span>; <span class="comment">// prev_index 会变成 size_t 的最大值</span></span><br><span class="line"><span class="keyword">int</span> val = v[prev_index]; <span class="comment">// 访问越界，很可能导致地址回绕</span></span><br></pre></td></tr></table></figure></li><li><p><strong>内存越界访问：</strong></p><ul><li>虽然错误信息明确是“addition of unsigned offset … overflowed”，但最根本的原因常常是试图访问一个不在合法范围内的内存地址。</li><li>尤其是在使用 <code>size_t</code> 或 <code>unsigned int</code> 作为索引或偏移量时，如果计算结果错误地变成了非常大的正数，就可能导致这种所谓的“溢出”。</li></ul></li><li><p>Line 1122: Char 9: runtime error: reference binding to null pointer of type ‘int’ (stl_vector.h)</p></li></ol><p>遇到的这个 <code>runtime error: reference binding to null pointer of type &#39;int&#39; (stl_vector.h)</code> 错误，是一个非常经典的 C++ <strong>未定义行为 (Undefined Behavior, UB)</strong> 错误，而且它通常是由 <strong>AddressSanitizer (ASan)</strong> 或其他内存安全工具在运行时检测到的。错误信息清晰地指出：你正在尝试将一个引用绑定到一个空指针上，而这是 C++ 标准不允许的。</p><p>虽然错误信息指向 <code>stl_vector.h</code>，但这通常意味着<strong>你的代码</strong>在尝试访问 <code>std::vector</code> 的某个元素时，使用了无效的索引，导致 <code>std::vector</code> 内部的指针（指向其元素存储的内存）被非法地用于引用绑定。</p><h3 id="错误的根本原因"><a href="#错误的根本原因" class="headerlink" title="错误的根本原因"></a>错误的根本原因</h3><p>这个错误最常见的根本原因就是：<strong>你试图通过 <code>[]</code> 运算符或 <code>at()</code> 方法访问一个 <code>std::vector</code> 中不存在的元素。</strong></p><p>具体来说，当 <code>std::vector</code> 为空或者你提供的索引超出了其有效范围时，会发生以下情况：</p><ol><li><strong><code>std::vector</code> 为空：</strong><ul><li>当 <code>std::vector</code> 的 <code>size()</code> 为 0 时，它可能不分配任何内存，或者其内部的 <code>data()</code> 指针就是 <code>nullptr</code>。</li><li>此时，如果你尝试 <code>myVector[0]</code>，编译器并不知道 <code>myVector</code> 是空的，它会直接计算 <code>data() + 0</code>，如果 <code>data()</code> 是 <code>nullptr</code>，结果仍然是 <code>nullptr</code>。</li><li>然后，对 <code>*nullptr</code> 进行解引用并尝试将其绑定到引用时，就会触发这个错误。</li></ul></li><li><strong>索引越界 (Out-of-bounds access)：</strong><ul><li>你尝试访问的索引 <code>i</code> 大于或等于 <code>myVector.size()</code>。</li><li><code>myVector[i]</code> 的操作在内部通常被转换为 <code>*(myVector.data() + i)</code>。如果 <code>i</code> 足够大，超出了已分配内存的范围，甚至可能导致指针算术溢出（回到内存地址空间低端，接近 <code>nullptr</code>）或者直接尝试访问未映射的内存区域。</li><li>如果恰好 <code>myVector.data() + i</code> 的结果接近或就是 <code>nullptr</code>，就会触发这个特定的错误</li></ul></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在刷leetcode题目,积累了一些提醒以及用c++STL刷题经验,这里记录一下&lt;br&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="https://www.sekyoro.top/tags/leetcode/"/>
    
    <category term="c++" scheme="https://www.sekyoro.top/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>并发、Java与Spring重点概念</title>
    <link href="https://www.sekyoro.top/2025/07/29/%E5%B9%B6%E5%8F%91%E3%80%81Java%E4%B8%8ESpring%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/"/>
    <id>https://www.sekyoro.top/2025/07/29/%E5%B9%B6%E5%8F%91%E3%80%81Java%E4%B8%8ESpring%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/</id>
    <published>2025-07-29T12:07:29.000Z</published>
    <updated>2025-08-06T09:00:28.377Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>分为三类Java基础知识,集合,JVM,多线程并发相关以及Spring,SpringBoot,SpringCloud分布式了解.<br><span id="more"></span></p><h1 id="操作系统与计算机网络关键知识"><a href="#操作系统与计算机网络关键知识" class="headerlink" title="操作系统与计算机网络关键知识"></a>操作系统与计算机网络关键知识</h1><h2 id="进程线程"><a href="#进程线程" class="headerlink" title="进程线程"></a>进程线程</h2><p>死锁</p><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>TCP/IP协议被组织成四个概念层，其中有三层对应于ISO参考模型中的相应层。ICP/IP协议族并不包含物理层和数据链路层，因此它不能独立完成整个计算机网络系统的功能，必须与许多其他的协议协同工作。TCP/IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层和网络接口层</strong>。</p><ul><li>应用层 支持 HTTP、SMTP 等最终用户进程</li><li>传输层 处理主机到主机的通信（TCP、UDP）</li><li>网络层 寻址和路由数据包（IP 协议）</li><li>链路层 通过网络的物理电线、电缆或无线信道移动比特</li></ul><p><img data-src="https://cdn.xiaolincoding.com//picgo/1718240465754-594d5aab-cb68-408a-b228-70fd33b094f4.png" alt="img" style="zoom:67%;" /></p><p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p><p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p><p><strong>控制位：</strong></p><ul><li><em>ACK</em>：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。</li><li><em>RST</em>：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。</li><li><em>SYN</em>：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li><li><em>FIN</em>：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。</li></ul><p>TCP协议主要通过以下几点来保证传输可靠性：连接管理、序列号、确认应答、超时重传、流量控制、拥塞控制。</p><ul><li><strong>连接管理</strong>：即三次握手和四次挥手。连接管理机制能够建立起可靠的连接，这是保证传输可靠性的前提。</li><li><strong>序列号</strong>：TCP将每个字节的数据都进行了编号，这就是序列号。序列号的具体作用如下：能够保证可靠性，既能防止数据丢失，又能避免数据重复。能够保证有序性，按照序列号顺序进行数据包还原。能够提高效率，基于序列号可实现多次发送，一次确认。</li><li><strong>确认应答</strong>：接收方接收数据之后，会回传ACK报文，报文中带有此次确认的序列号，用于告知发送方此次接收数据的情况。在指定时间后，若发送端仍未收到确认应答，就会启动超时重传。</li><li><strong>超时重传</strong>：超时重传主要有两种场景：数据包丢失：在指定时间后，若发送端仍未收到确认应答，就会启动超时重传，向接收端重新发送数据包。确认包丢失：当接收端收到重复数据(通过序列号进行识别)时将其丢弃，并重新回传ACK报文。</li><li><strong>流量控制</strong>：接收端处理数据的速度是有限的，如果发送方发送数据的速度过快，就会导致接收端的缓冲区溢出，进而导致丢包。为了避免上述情况的发生，TCP支持根据接收端的处理能力，来决定发送端的发送速度。这就是流量控制。流量控制是通过在TCP报文段首部维护一个滑动窗口来实现的。</li><li><strong>拥塞控制</strong>：拥塞控制就是当网络拥堵严重时，发送端减少数据发送。拥塞控制是通过发送端维护一个拥塞窗口来实现的。可以得出，发送端的发送速度，受限于滑动窗口和拥塞窗口中的最小值。拥塞控制方法分为：慢开始，拥塞避免、快重传和快恢复</li></ul><h3 id="TPC为什么需要三次握手建立连接"><a href="#TPC为什么需要三次握手建立连接" class="headerlink" title="TPC为什么需要三次握手建立连接"></a>TPC为什么需要三次握手建立连接</h3><p>三次握手的原因：</p><ul><li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li><li>三次握手才可以同步双方的初始序列号</li><li>三次握手才可以避免资源浪费</li></ul><p>三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱。</strong></p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><ul><li>连接：TCP 是面向连接的传输层协议，传输数据前先要建立连接；UDP 是不需要连接，即刻传输数据。</li><li>服务对象：TCP 是一对一的两点服务，即一条连接只有两个端点。UDP 支持一对一、一对多、多对多的交互通信</li><li>可靠性：TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议</li><li>拥塞控制、流量控制：TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li><li>首部开销：TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li><li>传输方式：TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序</li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP报文部分"><a href="#HTTP报文部分" class="headerlink" title="HTTP报文部分"></a>HTTP报文部分</h3><p>HTTP、HTTPS、CDN、DNS、FTP 都是应用层协议</p><p>分请求报文和响应报文来说明。</p><p><img data-src="https://cdn.xiaolincoding.com//picgo/1721710466863-78bf586d-a25c-4fe4-bf27-5dd576b998c8.png" alt="img"></p><p><strong>请求报文：</strong></p><ul><li>请求行：包含请求方法、请求目标（URL或URI）和HTTP协议版本。</li><li>请求头部：包含关于请求的附加信息，如Host、User-Agent、Content-Type等。</li><li>空行：请求头部和请求体之间用空行分隔。</li><li>请求体：可选，包含请求的数据，通常用于POST请求等需要传输数据的情况。</li></ul><p><strong>响应报文：</strong></p><ul><li>状态行：包含HTTP协议版本、状态码和状态信息。</li><li>响应头部：包含关于响应的附加信息，如Content-Type、Content-Length等。</li><li>空行：响应头部和响应体之间用空行分隔。</li><li>响应体：包含响应的数据，通常是服务器返回的HTML、JSON等内容。</li></ul><h3 id="HTTP不同版本"><a href="#HTTP不同版本" class="headerlink" title="HTTP不同版本"></a>HTTP不同版本</h3><p><strong>HTTP/1.1</strong></p><p>HTTP/1.1 是一个<strong>基于文本的协议</strong>，是 Web 长期以来的主流标准。它的核心特点是简单易懂，但也存在一些严重的性能问题。</p><ul><li><strong>队头阻塞（Head-of-Line Blocking）</strong>：在 HTTP/1.1 中，<strong>一个连接在同一时间只能处理一个请求。如果上一个请求的响应没有返回，后续的请求就会被阻塞</strong>。即使使用了 <strong>Pipelining</strong>（管道化，允许多个请求连续发送，无需等待响应），如果第一个响应丢失，后面的所有响应也会被延迟，从而导致严重的性能问题。</li><li><strong>不必要的开销</strong>：每个请求和响应都带有重复的头部信息，增加了数据传输的开销。</li><li><strong>连接效率低</strong>：尽管支持<strong>长连接</strong>（Persistent Connection），允许在一个 TCP 连接上发送多个请求，但由于队头阻塞问题，效率仍然不高。</li></ul><p><strong>HTTP/2</strong></p><p>HTTP/2 是为了解决 HTTP/1.1 的性能问题而诞生的，它在语义上兼容 HTTP/1.1，但底层做了彻底的革新。</p><ul><li><strong>二进制分帧（Binary Framing）</strong>：HTTP/2 将所有<strong>请求和响应都拆分为二进制帧，并在一个 TCP 连接上进行传输</strong>。这使得协议的解析更高效、更健壮。</li><li><strong>多路复用（Multiplexing）</strong>：这是 HTTP/2 最大的优势。它允许在<strong>一个 TCP 连接</strong>上同时发送多个请求和接收多个响应，解决了 HTTP/1.1 的队头阻塞问题。<strong>因为数据被拆分成了独立的帧，即使某个数据流很慢，也不会影响到其他数据流</strong>。</li><li><strong>头部压缩（Header Compression）</strong>：HTTP/2 使用 <strong>HPACK</strong> 算法对头部进行压缩。它维护了一个静态和动态的头部表，并使用霍夫曼编码，避免了重复发送相同的头部信息，大大减少了数据传输量。</li><li><strong>服务器推送（Server Push）</strong>：允许服务器在客户端请求之前，主动推送它认为客户端可能需要的资源（如 CSS、JavaScript 文件），从而减少客户端的等待时间。</li></ul><p><strong>HTTP/3</strong></p><p>HTTP/3 的出现是为了解决 HTTP/2 仍然存在的底层问题——<strong>TCP 的队头阻塞</strong>。</p><ul><li><strong>基于 QUIC 协议</strong>：HTTP/3 没有使用 TCP，而是选择了基于 <strong>UDP</strong> 的 <strong>QUIC</strong> 协议。</li><li><strong>解决 TCP 队头阻塞</strong>：在 TCP 中，<strong>如果一个数据包丢失，整个连接的所有数据流都会被阻塞，直到丢失的数据包被重传。而 QUIC 协议基于 UDP，它在应用层实现了类似 TCP 的可靠传输和拥塞控制。这意味着即使某个数据流的数据包丢失，也只会阻塞该数据流本身</strong>，<strong>而不会影响到同一连接上的其他数据流</strong>，从而彻底解决了底层协议的队头阻塞问题。</li><li><strong>更快的连接建立</strong>：QUIC 协议将 TCP 的三次握手和 TLS 的加密握手合并在一起。在大多数情况下，它只需要一次往返（1-RTT）就能建立安全连接，甚至在连接缓存后可以实现 0-RTT，大大减少了连接延迟。</li><li><strong>更好的网络切换能力</strong>：QUIC 协议通过连接 ID 来识别连接，而不是 IP 地址和端口号。这使得在网络切换时（例如从 Wi-Fi 切换到移动数据），连接可以无缝迁移，而无需重新建立。</li></ul><div class="table-container"><table><thead><tr><th>特性</th><th><strong>HTTP/1.1</strong></th><th><strong>HTTP/2</strong></th><th><strong>HTTP/3</strong></th></tr></thead><tbody><tr><td><strong>底层协议</strong></td><td>TCP</td><td>TCP</td><td><strong>UDP (QUIC)</strong></td></tr><tr><td><strong>传输形式</strong></td><td>文本</td><td>二进制帧</td><td>二进制帧</td></tr><tr><td><strong>多路复用</strong></td><td>不支持（有管道化但效果不佳）</td><td><strong>支持</strong>（在一个 TCP 连接上）</td><td><strong>支持</strong>（在 QUIC 连接上，从根本上解决队头阻塞）</td></tr><tr><td><strong>头部压缩</strong></td><td>不支持</td><td><strong>支持 (HPACK)</strong></td><td><strong>支持</strong>（QUIC 自带）</td></tr><tr><td><strong>服务器推送</strong></td><td>不支持</td><td><strong>支持</strong></td><td><strong>支持</strong></td></tr><tr><td><strong>队头阻塞</strong></td><td>应用层阻塞</td><td><strong>TCP 层阻塞</strong></td><td><strong>无队头阻塞</strong></td></tr><tr><td><strong>连接建立</strong></td><td>TCP 三次握手</td><td>TCP 三次握手 + TLS 握手</td><td><strong>QUIC 握手（1-RTT 或 0-RTT）</strong></td></tr></tbody></table></div><h3 id="常用状态码"><a href="#常用状态码" class="headerlink" title="常用状态码"></a>常用状态码</h3><p>HTTP 状态码分为 5 大类</p><ul><li>1xx 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</li><li>2xx 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</li><li>3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</li><li>4xx 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</li><li>5xx 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</li></ul><p>其中常见的具体状态码有：</p><ul><li>200：请求成功；</li><li>301：永久重定向；302：临时重定向；</li><li>404：无法找到此页面；405：请求的方法类型不支持；</li><li>500：服务器内部出错</li></ul><p>3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li><li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li></ul><p>301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p><ul><li>502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</li><li>504 Gateway Time-out：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器收到响应。</li></ul><p>举一个例子，假设 nginx 是代理服务器，收到客户端的请求后，将请求转发到后端服务器（tomcat 等）。</p><ul><li>当nginx收到了无效的响应时，就返回502。</li><li>当nginx超过自己配置的超时时间，还没有收到请求时，就返回504错误。</li></ul><h3 id="HTTP请求类型"><a href="#HTTP请求类型" class="headerlink" title="HTTP请求类型"></a>HTTP请求类型</h3><ul><li>GET：用于请求获取指定资源，通常用于获取数据。</li><li>POST：用于向服务器提交数据，通常用于提交表单数据或进行资源的创建。</li><li>PUT：用于向服务器更新指定资源，通常用于更新已存在的资源。</li><li>DELETE：用于请求服务器删除指定资源。</li><li><p>HEAD：类似于GET请求，但只返回资源的头部信息，用于获取资源的元数据而不获取实际内容</p><p>RFC 规范定义的语义来看：</p></li><li><p><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</p></li><li><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</li></ul><h3 id="HTTP对请求和响应拆包"><a href="#HTTP对请求和响应拆包" class="headerlink" title="HTTP对请求和响应拆包"></a>HTTP对请求和响应拆包</h3><p>在HTTP/1.1中，请求的拆包是通过”Content-Length”头字段来进行的。该字段指示了请求正文的长度，服务器可以根据该长度来正确接收和解析请求。</p><p>具体来说，当客户端发送一个HTTP请求时，会在请求头中添加”Content-Length”字段，该字段的值表示请求正文的字节数。</p><p>服务器在接收到请求后，会根据”Content-Length”字段的值来确定请求的长度，并从请求中读取相应数量的字节，直到读取完整个请求内容。</p><p>这种基于”Content-Length”字段的拆包机制可以确保服务器正确接收到完整的请求，避免了请求的丢失或截断问题</p><h3 id="HTTP的断点重传"><a href="#HTTP的断点重传" class="headerlink" title="HTTP的断点重传"></a>HTTP的断点重传</h3><p>断点续传是HTTP/1.1协议支持的特性。实现断点续传的功能，需要客户端记录下当前的下载进度，并在需要续传的时候通知服务端本次需要下载的内容片段。</p><p>一个最简单的断点续传流程如下：</p><ol><li>客户端开始下载一个1024K的文件，服务端发送Accept-Ranges: bytes来告诉客户端，其支持带Range的请求</li><li>假如客户端下载了其中512K时候网络突然断开了，过了一会网络可以了，客户端再下载时候，需要在HTTP头中申明本次需要续传的片段：Range:bytes=512000-这个头通知服务端从文件的512K位置开始传输文件，直到文件内容结束</li><li>服务端收到断点续传请求，从文件的512K位置开始传输，并且在HTTP头中增加：Content-Range:bytes 512000-/1024000,Content-Length: 512000。并且此时服务端返回的HTTP状态码应该是206 Partial Content。如果客户端传递过来的Range超过资源的大小,则响应416 Requested Range Not Satisfiable</li></ol><p>通过上面流程可以看出：断点续传中4个HTTP头不可少的，<strong>分别是Range头、Content-Range头、Accept-Ranges头、Content-Length头</strong>。其中第一个Range头是客户端发过来的，后面3个头需要服务端发送给客户端。下面是它们的说明：</p><ul><li><strong>Accept-Ranges: bytes：</strong>这个值声明了可被接受的每一个范围请求, 大多数情况下是字节数 bytes</li><li><strong>Range: bytes=开始位置-结束位置：</strong>Range是浏览器告知服务器所需分部分内容范围的消息头。</li></ul><h3 id="HTTP为什么不安全"><a href="#HTTP为什么不安全" class="headerlink" title="HTTP为什么不安全"></a>HTTP为什么不安全</h3><p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p><ul><li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li><li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li><li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li></ul><p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议，可以很好的解决了上述的风险：</p><ul><li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li><li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li><li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li></ul><p>HTTPS相比于HTTP更加安全,区别主要有以下四点：</p><ul><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li><li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul><h3 id="HTTPS握手过程"><a href="#HTTPS握手过程" class="headerlink" title="HTTPS握手过程"></a>HTTPS握手过程</h3><p>传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书文件其实就是服务端的公钥，会在 TLS 握手阶段传递给客户端，而服务端的私钥则一直留在服务端，一定要确保私钥不能被窃取。</p><p>在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。</p><p>主要通过加密和身份校验机制来防范中间人攻击的:</p><ul><li>加密：https 握手期间会通过非对称加密的方式来协商出对称加密密钥。</li><li>身份校验：服务器会向证书颁发机构申请数字证书，证书中包含了服务器的公钥和其他相关信息。当客户端与服务器建立连接时，服务器会将证书发送给客户端。客户端会验证证书的合法性，包括检查证书的有效期、颁发机构的信任等。如果验证通过，客户端会使用证书中的公钥来加密通信数据，并将加密后的数据发送给服务器，然后由服务端用私钥解密。</li></ul><p>中间人攻击的关键在于攻击者冒充服务器与客户端建立连接，并同时与服务器建立连接。</p><p>但由于攻击者无法获得服务器的私钥，因此无法正确解密客户端发送的加密数据。同时，客户端会在建立连接时验证服务器的证书，如果证书验证失败或存在问题，客户端会发出警告或中止连接</p><h3 id="HTTP进行TCP连接后什么情况下会断开"><a href="#HTTP进行TCP连接后什么情况下会断开" class="headerlink" title="HTTP进行TCP连接后什么情况下会断开"></a>HTTP进行TCP连接后什么情况下会断开</h3><ul><li>当服务端或者客户端执行 close 系统调用的时候，会发送FIN报文，就会进行四次挥手的过程</li><li>当发送方发送了数据之后，接收方超过一段时间没有响应ACK报文，发送方重传数据达到最大次数的时候，就会断开TCP连接</li><li>当HTTP长时间没有进行请求和响应的时候，超过一定的时间，就会释放连接</li></ul><p>HTTP是应用层协议，定义了客户端和服务器之间交换的数据格式和规则；Socket是通信的一端，提供了网络通信的接口；TCP是传输层协议，负责在网络中建立可靠的数据传输连接。它们在网络通信中扮演不同的角色和层次。</p><ul><li>HTTP是一种用于传输超文本数据的应用层协议，用于在客户端和服务器之间传输和显示Web页面。</li><li>Socket是计算机网络中的一种抽象，用于描述通信链路的一端，提供了底层的通信接口，可实现不同计算机之间的数据交换。</li><li>TCP是一种面向连接的、可靠的传输层协议，负责在通信的两端之间建立可靠的数据传输连接。</li></ul><h3 id="DNS以及域名解析过程"><a href="#DNS以及域名解析过程" class="headerlink" title="DNS以及域名解析过程"></a>DNS以及域名解析过程</h3><p>DNS的全称是Domain Name System（域名系统），它是互联网中用于将域名转换为对应IP地址的分布式数据库系统。DNS扮演着重要的角色，使得人们可以通过易记的域名访问互联网资源，而无需记住复杂的IP地址。域名的层级关系类似一个树状结构：</p><ul><li>根 DNS 服务器（.）</li><li>顶级域 DNS 服务器（.com）</li><li>权威 DNS 服务器（server.com）</li></ul><p>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。</p><p>这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。</p><p>因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器</p><ol><li>客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。</li><li>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 www.server.com 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</li><li>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</li><li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com 的 IP 地址吗？”</li><li>顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</li><li>本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li><li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li></ol><h3 id="无状态HTTP含义"><a href="#无状态HTTP含义" class="headerlink" title="无状态HTTP含义"></a>无状态HTTP含义</h3><p>HTTP是无状态的，这意味着每个请求都是独立的，服务器不会在多个请求之间保留关于客户端状态的信息。在每个HTTP请求中，服务器不会记住之前的请求或会话状态，因此每个请求都是相互独立的。</p><p>虽然HTTP本身是无状态的，但可以通过一些机制来实现状态保持，其中最常见的方式是使用Cookie和Session来跟踪用户状态。通过在客户端存储会话信息或状态信息，服务器可以识别和跟踪特定用户的状态，以提供一定程度的状态保持功能</p><h4 id="cookie与session"><a href="#cookie与session" class="headerlink" title="cookie与session"></a>cookie与session</h4><h4 id="jwt令牌"><a href="#jwt令牌" class="headerlink" title="jwt令牌"></a>jwt令牌</h4><p>JWT令牌由三个部分组成：头部（Header）、载荷（Payload）和签名（Signature）。其中，头部和载荷均为JSON格式，使用Base64编码进行序列化，而签名部分是对头部、载荷和密钥进行签名后的结果。</p><ul><li>无状态性：JWT是无状态的令牌，不需要在服务器端存储会话信息。相反，JWT令牌中包含了所有必要的信息，如用户身份、权限等。这使得JWT在分布式系统中更加适用，可以方便地进行扩展和跨域访问。</li><li>安全性：JWT使用密钥对令牌进行签名，确保令牌的完整性和真实性。只有持有正确密钥的服务器才能对令牌进行验证和解析。这种方式比传统的基于会话和Cookie的验证更加安全，有效防止了CSRF（跨站请求伪造）等攻击。</li><li>跨域支持：JWT令牌可以在不同域之间传递，适用于跨域访问的场景。通过在请求的头部或参数中携带JWT令牌，可以实现无需Cookie的跨域身份验证</li></ul><p>在传统的基于会话和Cookie的身份验证方式中，会话信息通常存储在服务器的内存或数据库中。但在集群部署中，不同服务器之间没有共享的会话信息，这会导致用户在不同服务器之间切换时需要重新登录，或者需要引入额外的共享机制（如Redis），增加了复杂性和性能开销。</p><p>而JWT令牌通过在令牌中包含所有必要的身份验证和会话信息，使得服务器无需存储会话信息，从而解决了集群部署中的身份验证和会话管理问题。当用户进行登录认证后，服务器将生成一个JWT令牌并返回给客户端。客户端在后续的请求中携带该令牌，服务器可以通过对令牌进行验证和解析来获取用户身份和权限信息，而无需访问共享的会话存储。</p><p>由于JWT令牌是自包含的，服务器可以独立地对令牌进行验证，而不需要依赖其他服务器或共享存储。这使得集群中的每个服务器都可以独立处理请求，提高了系统的可伸缩性和容错性。</p><p>JWT 一旦派发出去，在失效之前都是有效的，没办法即使撤销JWT。</p><p>要解决这个问题的话，得在业务层增加判断逻辑，比如增加<strong>黑名单机制。</strong>使用内存数据库比如 Redis 维护一个黑名单，如果想让某个 JWT 失效的话就直接将这个 JWT 加入到 <strong>黑名单</strong> 即可。然后，每次使用 JWT 进行请求的话都会先判断这个 JWT 是否存在于黑名单中。</p><ul><li>及时失效令牌：当检测到JWT令牌泄露或存在风险时，可以立即将令牌标记为失效状态。服务器在接收到带有失效标记的令牌时，会拒绝对其进行任何操作，从而保护用户的身份和数据安全。</li><li>刷新令牌：JWT令牌通常具有一定的有效期，过期后需要重新获取新的令牌。当检测到令牌泄露时，可以主动刷新令牌，即重新生成一个新的令牌，并将旧令牌标记为失效状态。这样，即使泄露的令牌被恶意使用，也会很快失效，减少了被攻击者滥用的风险。</li><li>使用黑名单：服务器可以维护一个令牌的黑名单，将泄露的令牌添加到黑名单中。在接收到令牌时，先检查令牌是否在黑名单中，如果在则拒绝操作。这种方法需要服务器维护黑名单的状态，对性能有一定的影响，但可以有效地保护泄露的令牌不被滥用。</li></ul><h4 id="localStorage和SessionStorage"><a href="#localStorage和SessionStorage" class="headerlink" title="localStorage和SessionStorage"></a>localStorage和SessionStorage</h4><ul><li>存储容量: Cookie 的存储容量通常较小,每个 Cookie 的大小限制在几 KB 左右。而 LocalStorage 的存储容量通常较大,一般限制在几 MB 左右。因此,如果需要存储大量数据，LocalStorage 通常更适合;</li><li>数据发送: Cookie 在每次 HTTP 请求中都会自动发送到服务器,这使得 Cookie 适合用于在客户端和服务器之间传递数据。而 localStorage 的数据不会自动发送到服务器,它仅在浏览器端存储数据,因此 LocalStorage 适合用于在同一域名下的不同页面之间共享数据;</li><li>生命周期：Cookie 可以设置一个过期时间,使得数据在指定时间后自动过期。而 LocalStorage 的数据将永久存储在浏览器中,除非通过 JavaScript 代码手动删除;</li><li>安全性：Cookie 的安全性较低,因为 Cookie 在每次 HTTP 请求中都会自动发送到服务器,存在被窃取或篡改的风险。而 LocalStorage 的数据仅在浏览器端存储,不会自动发送到服务器,相对而言更安全一些</li></ul><h3 id="HTTP长连接与WebSocket关系-与RPC关系"><a href="#HTTP长连接与WebSocket关系-与RPC关系" class="headerlink" title="HTTP长连接与WebSocket关系 与RPC关系"></a>HTTP长连接与WebSocket关系 与RPC关系</h3><ul><li><strong>全双工和半双工</strong>：TCP 协议本身是<strong>全双工</strong>的，但我们最常用的 HTTP/1.1，虽然是基于 TCP 的协议，但它是<strong>半双工</strong>的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 WebSocket 协议。</li><li><strong>应用场景区别</strong>：在 HTTP/1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用<strong>定时轮询或者长轮询</strong>的方式实现<strong>服务器推送</strong>(comet)的效果。对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。</li></ul><ul><li>RPC 本质上不算是协议，而是一种调用方式，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，不一定非得基于 TCP 协议。</li><li>从发展历史来说，HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。</li><li>RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP/1.1 性能要更好，所以大部分公司内部都还在使用 RPC。</li><li>HTTP/2.0在 HTTP/1.1的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。</li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>它的核心思想是确保一个类在整个应用程序中<strong>只有一个实例</strong>，并提供一个全局访问点来获取这个唯一的实例。单例模式主要用于以下场景：</p><ul><li><strong>资源共享</strong>：当某个对象的创建开销很大，或者该对象需要被频繁访问时，例如数据库连接池、线程池、配置对象等。通过单例模式，可以避免重复创建，节省资源。</li><li><strong>全局唯一</strong>：当某个类只需要一个实例，且该实例需要被全局共享时，例如日志记录器、缓存、窗口管理器等</li></ul><p>在实际开发中，单例模式有多种实现方式，每种方式都有其优缺点。</p><p><strong>饿汉式（Eager Initialization）</strong></p><p>在类加载时就创建好实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在类加载时就创建好实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EagerSingleton INSTANCE = <span class="keyword">new</span> EagerSingleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EagerSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有静态方法返回实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>：线程安全，实现简单。</li><li><strong>缺点</strong>：无论是否使用，都会在类加载时创建实例，可能造成资源浪费。</li></ul><p><strong>懒汉式（Lazy Initialization）</strong></p><p>在第一次调用时才创建实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在第一次调用时创建实例</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>：按需创建，节省资源。</li><li><strong>缺点</strong>：在多线程环境下，不加锁会导致线程不安全。为了解决这个问题，需要使用 <code>synchronized</code> 关键字，但它会带来性能开销。</li></ul><p><strong>双重检查锁（Double-Checked Locking, DCL）</strong></p><p>这是懒汉式的优化版本，旨在兼顾性能和线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DCLSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 volatile 关键字保证可见性和有序性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DCLSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DCLSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DCLSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次检查，避免不必要的同步</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DCLSingleton.class) &#123;</span><br><span class="line">                <span class="comment">// 第二次检查，确保只有一个线程创建实例</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> DCLSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>：线程安全，并且只有在第一次创建实例时才需要同步，性能较高。</li><li><strong>缺点</strong>：实现相对复杂，需要使用 <code>volatile</code> 关键字来防止指令重排，确保正确性。</li></ul><p><strong>静态内部类（Static Inner Class）</strong></p><p>这是目前公认的<strong>最佳实现方式</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InnerClassSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InnerClassSingleton INSTANCE = <span class="keyword">new</span> InnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InnerClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有第一次调用时，才会加载 SingletonHolder 类，从而创建实例</span></span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>：<strong>线程安全，延迟加载，性能高</strong>。JVM 保证了类的加载是线程安全的，并且只有在 <code>getInstance()</code> 方法被调用时，才会加载内部类，从而实现懒加载。</li><li><strong>缺点</strong>：无明显缺点，是推荐的单例实现方式。</li></ul><h2 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h2><p>当我们需要创建一个产品对象时，</p><p>首先，我们会定义一个抽象的产品接口或者抽象类，明确规定产品的公共行为和属性。这样，无论后续添加多少具体产品，客户端都可以通过同一接口来操作它们。</p><p>其次，我们实现具体的产品类，这些类分别实现了抽象产品接口，包含各自独特的业务逻辑和功能。</p><p>接着，我们定义一个工厂接口或者抽象工厂类，声明一个创建产品对象的方法。该方法的职责是隐藏具体产品对象的实例化过程，客户端只需要调用这个方法即可获得产品实例。</p><p>然后，我们实现具体的工厂类，它们根据传入的参数或内部逻辑，决定创建哪一种具体的产品对象。这样，具体产品的创建细节完全被封装在工厂内部，客户端无需关心对象的创建过程。</p><p>最后，当客户端需要一个产品时，它只需调用工厂提供的创建方法，获得对应的产品对象，并直接使用。这种方式不仅降低了客户端与具体产品实现之间的耦合，也方便了系统的扩展和维护</p><p>工厂模式主要解决了以下几个问题：</p><ul><li><strong>解耦</strong>：将对象的创建与使用分离。你的业务逻辑代码不需要关心如何创建对象，只需要向工厂请求即可。</li><li><strong>可扩展性</strong>：当需要增加新的产品时，只需增加一个具体工厂和产品类，而不需要修改原有的代码。这符合“开闭原则”（对扩展开放，对修改关闭）。</li><li><strong>统一管理</strong>：工厂可以统一管理对象的创建，例如在创建对象时进行一些初始化操作，或者根据不同的参数创建不同的对象。</li></ul><p>工厂模式主要有三种常见的实现方式，复杂度逐级递增。</p><p><strong>简单工厂模式（Simple Factory Pattern）</strong></p><p>也被称为静态工厂模式，它不属于 GoF（Gang of Four）的 23 种设计模式之一，但非常常用。</p><ul><li><strong>定义</strong>：一个工厂类负责创建所有产品类的实例。</li><li><strong>结构</strong>：一个工厂类，一个抽象产品类，多个具体产品类。</li><li><strong>缺点</strong>：工厂类承担了所有产品的创建逻辑，职责过重。当增加新产品时，需要修改工厂类的代码，违反了开闭原则。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用产品A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">createProduct</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;A&quot;</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;B&quot;</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Product product = SimpleFactory.createProduct(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">product.use();</span><br></pre></td></tr></table></figure><p><strong>工厂方法模式（Factory Method Pattern）</strong></p><ul><li><strong>定义</strong>：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法模式将对象的创建延迟到子类。</li><li><strong>结构</strong>：一个抽象工厂，多个具体工厂，一个抽象产品，多个具体产品。</li><li><strong>优点</strong>：符合开闭原则。当增加新产品时，只需增加一个对应的具体工厂，不需要修改任何已有的工厂代码。</li><li><strong>缺点</strong>：每增加一个产品，就需要增加一个具体工厂，类的数量会增加。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用产品A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">Product <span class="title">createProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactoryA</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Factory factory = <span class="keyword">new</span> ConcreteFactoryA();</span><br><span class="line">Product product = factory.createProduct();</span><br><span class="line">product.use();</span><br></pre></td></tr></table></figure><p><strong>抽象工厂模式（Abstract Factory Pattern）</strong></p><ul><li><strong>定义</strong>：提供一个接口，用于创建一系列相关或相互依赖的对象，而无需指定它们具体的类。</li><li><strong>结构</strong>：一个抽象工厂，多个具体工厂，多个抽象产品，多个具体产品。</li><li><strong>优点</strong>：可以创建一组相关联的对象，方便管理。</li><li><strong>缺点</strong>：当需要增加新的产品系列时，需要修改抽象工厂接口和所有具体工厂，扩展起来比较复杂。</li></ul><p><strong>示例：</strong> 假设我们有<strong>产品A</strong>和<strong>产品B</strong>两个系列，每个系列都有不同的实现。</p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品A</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">useA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractProductB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">useB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">AbstractProductA <span class="title">createProductA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">AbstractProductB <span class="title">createProductB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">AbstractFactory factory = <span class="keyword">new</span> ConcreteFactory1();</span><br><span class="line">AbstractProductA productA = factory.createProductA();</span><br><span class="line">productA.useA();</span><br></pre></td></tr></table></figure><h2 id="生产者消费者设计模式"><a href="#生产者消费者设计模式" class="headerlink" title="生产者消费者设计模式"></a>生产者消费者设计模式</h2><p>这个模式包含三个核心角色：</p><ol><li><strong>生产者（Producer）</strong>：负责生成数据并将其放入共享的<strong>缓冲区</strong>中。</li><li><strong>消费者（Consumer）</strong>：负责从缓冲区中取出数据进行处理。</li><li><strong>缓冲区（Buffer）</strong>：一个共享的、线程安全的数据结构，用于连接生产者和消费者。它通常有容量限制。</li></ol><p>生产者和消费者之间通过缓冲区进行通信，它们彼此独立，互不影响，从而实现了<strong>解耦</strong>。</p><p>(1)基于 synchronized 和 wait/notify 的实现</p><p>这是最基础的实现方式，使用 Java 内置的同步机制来控制线程间的协作。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">5</span>; <span class="comment">// 缓冲区最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; buffer = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> throws InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果缓冲区满了，生产者等待</span></span><br><span class="line">                <span class="keyword">while</span> (buffer.<span class="built_in">size</span>() == MAX_SIZE) &#123;</span><br><span class="line">                    <span class="built_in">wait</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 生产数据并放入缓冲区</span></span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">&quot;Produced: &quot;</span> + value);</span><br><span class="line">                buffer.<span class="built_in">add</span>(value++);</span><br><span class="line">                <span class="comment">// 唤醒消费者</span></span><br><span class="line">                <span class="built_in">notifyAll</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.<span class="built_in">sleep</span>(<span class="number">1000</span>); <span class="comment">// 模拟生产耗时</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> throws InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果缓冲区为空，消费者等待</span></span><br><span class="line">                <span class="keyword">while</span> (buffer.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                    <span class="built_in">wait</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 消费数据</span></span><br><span class="line">                <span class="keyword">int</span> value = buffer.<span class="built_in">poll</span>();</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">&quot;Consumed: &quot;</span> + value);</span><br><span class="line">                <span class="comment">// 唤醒生产者</span></span><br><span class="line">                <span class="built_in">notifyAll</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.<span class="built_in">sleep</span>(<span class="number">1500</span>); <span class="comment">// 模拟消费耗时</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer pc = <span class="keyword">new</span> <span class="built_in">ProducerConsumer</span>();</span><br><span class="line"></span><br><span class="line">        Thread producerThread = <span class="keyword">new</span> <span class="built_in">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pc.<span class="built_in">produce</span>();</span><br><span class="line">            &#125; <span class="built_in"><span class="keyword">catch</span></span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.<span class="built_in">currentThread</span>().<span class="built_in">interrupt</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread consumerThread = <span class="keyword">new</span> <span class="built_in">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pc.<span class="built_in">consume</span>();</span><br><span class="line">            &#125; <span class="built_in"><span class="keyword">catch</span></span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.<span class="built_in">currentThread</span>().<span class="built_in">interrupt</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producerThread.<span class="built_in">start</span>();</span><br><span class="line">        consumerThread.<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：简单直观，适合初学者理解线程间协作的基本原理。</p><p>缺点：synchronized 和 wait/notify 的粒度较粗，性能可能较低。</p><p>(2)基于 BlockingQueue 的实现</p><p>Java 提供了线程安全的阻塞队列（如 LinkedBlockingQueue），可以简化生产者-消费者的实现。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerWithBlockingQueue</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; buffer = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(MAX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> throws InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            buffer.<span class="built_in">put</span>(value); <span class="comment">// 如果缓冲区满，自动阻塞</span></span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot;Produced: &quot;</span> + value);</span><br><span class="line">            value++;</span><br><span class="line">            Thread.<span class="built_in">sleep</span>(<span class="number">1000</span>); <span class="comment">// 模拟生产耗时</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> throws InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = buffer.<span class="built_in">take</span>(); <span class="comment">// 如果缓冲区空，自动阻塞</span></span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot;Consumed: &quot;</span> + value);</span><br><span class="line">            Thread.<span class="built_in">sleep</span>(<span class="number">1500</span>); <span class="comment">// 模拟消费耗时</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumerWithBlockingQueue pc = <span class="keyword">new</span> <span class="built_in">ProducerConsumerWithBlockingQueue</span>();</span><br><span class="line"></span><br><span class="line">        Thread producerThread = <span class="keyword">new</span> <span class="built_in">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pc.<span class="built_in">produce</span>();</span><br><span class="line">            &#125; <span class="built_in"><span class="keyword">catch</span></span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.<span class="built_in">currentThread</span>().<span class="built_in">interrupt</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread consumerThread = <span class="keyword">new</span> <span class="built_in">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pc.<span class="built_in">consume</span>();</span><br><span class="line">            &#125; <span class="built_in"><span class="keyword">catch</span></span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.<span class="built_in">currentThread</span>().<span class="built_in">interrupt</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producerThread.<span class="built_in">start</span>();</span><br><span class="line">        consumerThread.<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：BlockingQueue 内部实现了同步机制，代码更简洁。</p><p>优点：减少了手动管理锁和条件变量的复杂性，性能更高</p><h1 id="JAVA基础与集合"><a href="#JAVA基础与集合" class="headerlink" title="JAVA基础与集合"></a>JAVA基础与集合</h1><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>第一，封装（Encapsulation）。</p><p>封装是指将数据（属性）和行为（方法）捆绑在一起，并对外隐藏对象的内部实现细节。通过访问修饰符（如 private、protected 和 public），我们可以控制哪些部分是对外可见的，哪些是内部私有的。这种机制提高了代码的安全性和可维护性。例如，在 Java 中，我们通常会将类的属性设置为 private，并通过 getter 和 setter 方法提供受控的访问方式。</p><p>第二，继承（Inheritance）。</p><p>继承允许一个类（子类）基于另一个类（父类）来构建，从而复用父类的属性和方法。通过继承，子类不仅可以拥有父类的功能，还可以扩展或重写父类的行为。Java 中使用 extends 关键字实现继承。例如，我们可以通过定义一个通用的 Animal 类，然后让 Dog 和 Cat 类继承它，这样就避免了重复编写相同的代码。继承体现了“is-a”的关系，比如“狗是一个动物”。</p><p>第三，多态（Polymorphism）。</p><p>多态是指同一个方法调用可以根据对象的实际类型表现出不同的行为。多态分为两种形式：编译时多态（方法重载）和运行时多态（方法重写）。运行时多态是通过动态绑定实现的，即程序在运行时决定调用哪个方法。例如，如果父类 Animal 有一个 makeSound() 方法，子类 Dog 和 Cat 可以分别重写这个方法，当调用 animal.makeSound() 时，具体执行的是 Dog 或 Cat 的实现。多态使得代码更加灵活和可扩展。</p><h2 id="接口、普通类和抽象类区别和共同点"><a href="#接口、普通类和抽象类区别和共同点" class="headerlink" title="接口、普通类和抽象类区别和共同点"></a>接口、普通类和抽象类区别和共同点</h2><p>第一个是定义上的区别。</p><p>普通类是一个完整的、具体的类，可以直接实例化为对象。它包含属性和方法，并且可以有构造方法。</p><p>抽象类是一个不能直接实例化的类，通常用来作为其他类的基类。它可以包含抽象方法（没有实现的方法）和具体方法（有实现的方法）。</p><p>接口是一种完全抽象的结构，用于定义行为规范。它只包含抽象方法（Java 8 之后可以包含默认方法和静态方法）。</p><p>第二个是方法实现上的区别。</p><p>普通类的所有方法都可以有具体实现（即方法体）。</p><p>抽象类可以包含具体方法和抽象方法。</p><p>接口默认只包含抽象方法（Java 8 后可以包含默认方法和静态方法）。</p><p>第三是继承关系上的区别。</p><p>普通类支持单继承（一个类只能继承一个父类）。</p><p>抽象类也支持单继承（一个类只能继承一个抽象类）。</p><p>接口支持多实现（一个类可以实现多个接口）。</p><p>第四是成员变量上的区别。</p><p>普通类和抽象类都可以有各种类型的成员变量（实例变量、静态变量等）。</p><p>接口只能有常量（public static final）。</p><p>接下来讲一下共同点，一共有3点。</p><p>首先，它们都是面向对象编程的基础结构，都可以用来组织代码，实现封装、继承和多态等特性。</p><p>其次，它们都可以包含方法，尽管接口中的方法默认是抽象的。</p><p>最后，它们都可以被继承或实现，普通类可以通过继承扩展功能，抽象类和接口则需要子类继承或实现后才能使</p><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>深拷贝和浅拷贝的核心区别在于是否递归地复制对象内部的引用类型数据，接下来，我会从定义、实现方式以及使用场景三个方面详细讲解它们的区别。</p><p>首先是定义上的区别，</p><p>浅拷贝是指创建一个新对象，但新对象中的引用类型字段仍然指向原对象中引用类型的内存地址。换句话说，浅拷贝只复制了对象本身，而没有复制对象内部的引用类型数据。修改新对象中的引用类型数据会影响原对象。</p><p>深拷贝是指创建一个新对象，并且递归地复制对象内部的所有引用类型数据。换句话说，深拷贝不仅复制了对象本身，还复制了对象内部的所有引用类型数据。修改新对象中的引用类型数据不会影响原对象。</p><p>其次是实现方式上的区别，</p><p><strong>浅拷贝可以使用 Object 类的 clone() 方法，也可以使用实现 Cloneable 接口并重写 clone() 的方法</strong>。</p><p>深拷贝可以<strong>手动对引用类型字段进行递归拷贝</strong>，也可以<strong>使用序列化（Serialization）的方式将对象序列化为字节流</strong>，再反序列化为新对象。</p><p>最后是使用场景上的区别，</p><p>浅拷贝适用于当对象内部的引用类型数据不需要独立复制的情况。</p><p>深拷贝适用于当对象内部的引用类型数据需要完全独立的情况。</p><h2 id="int和Integer的区别"><a href="#int和Integer的区别" class="headerlink" title="int和Integer的区别"></a>int和Integer的区别</h2><p>第一个是定义上的区别，</p><p>int 是 Java 的基本数据类型，直接存储数值，占用固定的 4 字节内存空间，范围是从 -2,147,483,648 到 2,147,483,647。</p><p>而 Integer 是 int 的包装类，它是一个对象，通过引用指向存储的数值，因此除了存储数值本身外，还需要额外的内存开销。</p><p>第二个是使用方式上的区别，</p><p>int 是一种原始类型，可以直接声明和赋值。</p><p>而 Integer 必须实例化后才能使用，它提供了更多的功能，比如支持泛型、序列化、缓存以及一些实用方法。</p><p>第三个是使用场景上的区别，</p><p>当需要高效处理整数时，优先使用 int。</p><p>当需要将整数作为对象使用时，选择 Integer</p><h2 id="什么是自动拆箱和装箱"><a href="#什么是自动拆箱和装箱" class="headerlink" title="什么是自动拆箱和装箱"></a>什么是自动拆箱和装箱</h2><p>自动拆箱和装箱是为了提高代码的简洁性，它简化了基本数据类型与对应的包装类之间的转换。接下来我会详细解释什么是自动装箱和自动拆箱，以及它们的注意事项。</p><p>首先说一下自动装箱，</p><p>自动装箱是指将基本数据类型（如 int、double、boolean 等）自动转换为对应的包装类对象（如 Integer、Double、Boolean 等）。这个过程由编译器自动完成，无需手动调用包装类的构造方法或静态方法。</p><p>当存储一个基本数据类型到需要用到对象的场景中(例如集合)，Java 编译器会检测到基本数据类型需要被转换为包装类对象，编译器会自动调用包装类的 valueOf() 方法来创建对应的包装类对象，生成的对象会被存储到目标位置。</p><p>接下来说一下自动拆箱，</p><p>自动拆箱是指将包装类对象（如 Integer、Double、Boolean 等）自动转换为对应的基本数据类型（如 int、double、boolean 等）。同样，这个过程也是由编译器自动完成的。</p><p>当你从一个需要对象的场景中取出值并赋给基本数据类型时，Java 编译器会检测到目标变量是一个基本数据类型。编译器会自动调用包装类的 xxxValue() 方法，比如 intValue()、doubleValue() 等，来获取基本数据类型的值。返回的基本数据类型值会被赋给目标变量。</p><p>最后说一下注意事项，一共有3点需要注意</p><p>第一个是性能问题，频繁的自动装箱和拆箱可能会导致额外的性能开销，因为每次都需要创建或转换对象。</p><p>第二个是空指针异常，如果对一个 null 的包装类对象进行自动拆箱操作，会抛出 NullPointerException。</p><p>第三个是缓存机制，某些包装类（如 Integer、Boolean 等）会对常用值进行缓存。</p><h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><p>第一是发生位置的不同，重载发生在同一个类中，而重写发生在父子类之间 。</p><p>第二是方法签名的不同，重载要求方法名相同，但参数列表必须不同。重写要求方法名和参数列表完全相同。</p><p>第三是返回值类型的不同，重载的返回值类型可以不同，而重写的返回值类型必须相同或是父类返回值类型的子类型。</p><p>第四是访问修饰符的不同，重载对访问修饰符没有限制，而重写的访问修饰符不能比父类更严格。</p><p>第五是异常声明的不同，重载对异常声明没有限制，而重写时，子类方法抛出的异常不能比父类方法抛出的异常范围更大。</p><p>第六是绑定关系的不同，重载是静态绑定 ，编译时确定调用哪个方法，而重写是动态绑定 ，运行时根据对象的实际类型决定调用哪个方法</p><h2 id="和queals的区别"><a href="#和queals的区别" class="headerlink" title="==和queals的区别"></a>==和queals的区别</h2><p>== 和 equals 是 Java 中用于比较的两种方式，</p><p>第一个是比较内容上，== 比较的是内存地址（引用类型）或实际值（基本数据类型），而equals 比较的是逻辑上的相等性，具体取决于类是否重写了 equals 方法。</p><p>第二个是适用范围上，== 可用于基本数据类型和引用数据类型，而 equals 只能用于引用数据类型。</p><p>第三个是默认行为上，== 始终比较的是内存地址或实际值，而equals 在未重写时与 == 行为一致，但在某些类中（如 String、Integer 等）被重写以实现内容比较。</p><p>第四个是可扩展性上，== 是操作符，无法被修改或扩展，而equals 是方法，可以在自定义类中重写以实现特定的比较逻辑。</p><p>第五个是性能上，== 性能更高，因为它直接比较内存地址或值，而equals 性能可能较低，尤其是在复杂对象中需要逐个比较属性值</p><h2 id="泛型以及作用"><a href="#泛型以及作用" class="headerlink" title="泛型以及作用"></a>泛型以及作用</h2><p>第一点是提高代码的复用性，它允许我们编写与类型无关的通用代码。</p><p>第二点是增强类型安全性<strong>，</strong>在没有泛型的情况下，集合类（如 ArrayList）默认存储的是 Object 类型，取出元素时需要手动进行类型转换，容易引发 ClassCastException。而泛型在编译时就会进行类型检查，避免了运行时的类型错误。</p><p>第三点是简化代码<strong>，</strong>使用泛型后，我们无需显式地进行类型转换，减少了冗余代码，提高了代码的可读性和维护性。</p><p>第四点是支持复杂的类型约束<strong>，</strong>泛型可以通过通配符（如 ? extends T 和 ? super T）实现更复杂的类型限制，满足特定场景下的需求。</p><h2 id="什么是反射以及应用"><a href="#什么是反射以及应用" class="headerlink" title="什么是反射以及应用"></a>什么是反射以及应用</h2><p>反射（Reflection）是 Java 中一种强大的机制，它<strong>允许程序在运行时动态地获取类的信息并操作类的属性、方法和构造器</strong>。</p><p>首先说一下什么是反射<strong>，</strong></p><p>反射是一种在运行时动态获取类信息的能力。通过反射，我们可以在程序运行时加载类、获取类的结构（如字段、方法、构造器等），甚至可以调用类的方法或修改字段的值。</p><p>其次，反射主要应用在这5个场景，</p><p>第一个是框架开发，很多 Java 框架都有使用反射，比如如 Spring、Hibernate 等。</p><p>第二个是动态代理，动态代理是反射的一个重要应用，常用于 AOP（面向切面编程）。通过反射，我们可以在运行时动态生成代理类，拦截方法调用并添加额外逻辑。</p><p>第三个是注解处理，注解本身不会对程序产生任何影响，但通过反射，我们可以在运行时读取注解信息并执行相应的逻辑。</p><p>第四个是插件化开发，在某些场景下，我们需要动态加载外部的类或模块。反射可以帮助我们在运行时加载这些类并调用其方法，从而实现插件化开发。</p><p>第五个是测试工具，单元测试框架（如 JUnit）利用反射来发现和运行测试方法，而无需手动指定每个测试用例。</p><h2 id="StringBuild以及特征"><a href="#StringBuild以及特征" class="headerlink" title="StringBuild以及特征"></a>StringBuild以及特征</h2><p>StingBuilder 是一个可变的字符序列，与 String 不同，StringBuffer 的内容是可以被修改的。它的核心特点是线程安全和高效的字符串操作。</p><p>StringBuffer 的4个特点<strong>，</strong></p><p>第一个是它具有可变性，可以<strong>在原有对象上直接修改字符串内容，而无需创建新的对象</strong>。</p><p>第二个它是<strong>线程安全的，StringBuffer 的所有方法都通过 synchronized 关键字修饰，因此它是线程安全的</strong>。 在多线程环境下，多个线程可以同时操作同一个 StringBuffer 对象，而不会引发数据竞争或不一致问题。</p><p>第三个是性能相对较好，StringBuffer 内部使用一个可扩容的字符数组来存储数据，当容量不足时会自动扩展。相比于 String 的不可变性（每次修改都会生成新对象），StringBuffer 在频繁修改字符串时性能更高。而相比于非线程安全的 StringBuilder ，性能略低。</p><p>第四个是包含丰富的 API，比如：append()：追加内容到字符串末尾。 insert()：在指定位置插入内容。delete()：删除指定范围的内容。 reverse()：反转字符串内容。 toString()：将 StringBuffer 转换为 String。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="保证数据一致性方案"><a href="#保证数据一致性方案" class="headerlink" title="保证数据一致性方案"></a>保证数据一致性方案</h2><p>要保证多线程的程序是安全，不要出现数据竞争造成的数据混乱的问题。</p><p>Java的线程安全在三个方面体现：</p><ul><li><strong>原子性</strong>：提供互斥访问，同一时刻只能有一个线程对数据进行操作，在Java中使用了atomic包（这个包提供了一些支持原子操作的类，这些类可以在多线程环境下保证操作的原子性）和synchronized关键字来确保原子性；</li><li><strong>可见性</strong>：一个线程对主内存的修改可以及时地被其他线程看到，在Java中使用了synchronized和volatile这两个关键字确保可见性；</li><li><strong>有序性</strong>：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，在Java中使用了happens-before原则来确保有序性。</li></ul><ul><li><strong>事务管理</strong>：使用数据库事务来确保一组数据库操作要么全部成功提交，要么全部失败回滚。通过ACID（原子性、一致性、隔离性、持久性）属性，数据库事务可以保证数据的一致性。</li><li><strong>锁机制</strong>：使用锁来实现对共享资源的互斥访问。在 Java 中，可以使用 synchronized 关键字、ReentrantLock 或其他锁机制来控制并发访问，从而避免并发操作导致数据不一致。</li><li><strong>版本控制</strong>：通过乐观锁的方式，在更新数据时记录数据的版本信息，从而避免同时对同一数据进行修改，进而保证数据的一致性。</li></ul><h2 id="如何保证多线程安全"><a href="#如何保证多线程安全" class="headerlink" title="如何保证多线程安全"></a>如何保证多线程安全</h2><ul><li><p><strong>synchronized关键字</strong>:可以使用<code>synchronized</code>关键字来同步代码块或方法，确保同一时刻只有一个线程可以访问这些代码。对象锁是通过<code>synchronized</code>关键字锁定对象的监视器（monitor）来实现的。</p></li><li><p><strong>volatile关键字</strong>:<code>volatile</code>关键字用于变量，确保所有线程看到的是该变量的最新值，而不是可能存储在本地寄存器中的副本。</p></li><li><strong>Lock接口和ReentrantLock类</strong>:<code>java.util.concurrent.locks.Lock</code>接口提供了比<code>synchronized</code>更强大的锁定机制，<code>ReentrantLock</code>是一个实现该接口的例子，提供了更灵活的锁管理和更高的性能。</li><li><strong>原子类</strong>：Java并发库（<code>java.util.concurrent.atomic</code>）提供了原子类，如<code>AtomicInteger</code>、<code>AtomicLong</code>等，这些类提供了原子操作，可以用于更新基本类型的变量而无需额外的同步。</li></ul><h2 id="Java中常用锁"><a href="#Java中常用锁" class="headerlink" title="Java中常用锁"></a>Java中常用锁</h2><p>Java中的锁是用于管理多线程并发访问共享资源的关键机制。锁可以确保在任意给定时间内只有一个线程可以访问特定的资源，从而避免数据竞争和不一致性。Java提供了多种锁机制，可以分为以下几类：</p><ul><li><strong>内置锁（synchronized）</strong>：Java中的<code>synchronized</code>关键字是内置锁机制的基础，可以用于方法或代码块。当一个线程进入<code>synchronized</code>代码块或方法时，它会获取关联对象的锁；当线程离开该代码块或方法时，锁会被释放。如果其他线程尝试获取同一个对象的锁，它们将被阻塞，直到锁被释放。其中，syncronized加锁时有无锁、偏向锁、轻量级锁和重量级锁几个级别。偏向锁用于当一个线程进入同步块时，如果没有任何其他线程竞争，就会使用偏向锁，以减少锁的开销。轻量级锁使用线程栈上的数据结构，避免了操作系统级别的锁。重量级锁则涉及操作系统级的互斥锁。</li><li><strong>ReentrantLock</strong>：<code>java.util.concurrent.locks.ReentrantLock</code>是一个显式的锁类，提供了比<code>synchronized</code>更高级的功能，如可中断的锁等待、定时锁等待、公平锁选项等。<code>ReentrantLock</code>使用<code>lock()</code>和<code>unlock()</code>方法来获取和释放锁。其中，公平锁按照线程请求锁的顺序来分配锁，保证了锁分配的公平性，但可能增加锁的等待时间。非公平锁不保证锁分配的顺序，可以减少锁的竞争，提高性能，但可能造成某些线程的饥饿。</li><li><strong>读写锁（ReadWriteLock）</strong>：<code>java.util.concurrent.locks.ReadWriteLock</code>接口定义了一种锁，允许多个读取者同时访问共享资源，但只允许一个写入者。读写锁通常用于读取远多于写入的情况，以提高并发性。</li><li><strong>乐观锁和悲观锁</strong>：悲观锁（Pessimistic Locking）通常指在访问数据前就锁定资源，假设最坏的情况，即数据很可能被其他线程修改。<code>synchronized</code>和<code>ReentrantLock</code>都是悲观锁的例子。乐观锁（Optimistic Locking）通常不锁定资源，而是在更新数据时检查数据是否已被其他线程修改。乐观锁常使用版本号或时间戳来实现。</li><li><strong>自旋锁</strong>：自旋锁是一种锁机制，线程在等待锁时会持续循环检查锁是否可用，而不是放弃CPU并阻塞。通常可以使用CAS来实现。这在锁等待时间很短的情况下可以提高性能，但过度自旋会浪费CPU资源。</li></ul><h2 id="Java中并发工具"><a href="#Java中并发工具" class="headerlink" title="Java中并发工具"></a>Java中并发工具</h2><p>Java 中一些常用的并发工具，它们位于 <code>java.util.concurrent</code> 包中，常见的有：</p><ul><li><strong>CountDownLatch</strong>：CountDownLatch 是一个同步辅助类，它允许一个或多个线程等待其他线程完成操作。它使用一个计数器进行初始化，调用 <code>countDown()</code> 方法会使计数器减一，当计数器的值减为 0 时，等待的线程会被唤醒。可以把它想象成一个倒计时器，当倒计时结束（计数器为 0）时，等待的事件就会发生。示例代码：</li><li><strong>CyclicBarrier</strong>：CyclicBarrier 允许一组线程互相等待，直到到达一个公共的屏障点。当所有线程都到达这个屏障点后，它们可以继续执行后续操作，并且这个屏障可以被重置循环使用。与 <code>CountDownLatch</code> 不同，<code>CyclicBarrier</code> 侧重于线程间的相互等待，而不是等待某些操作完成。</li><li><strong>Semaphore</strong>：Semaphore 是一个计数信号量，用于控制同时访问某个共享资源的线程数量。通过 <code>acquire()</code> 方法获取许可，使用 <code>release()</code> 方法释放许可。如果没有许可可用，线程将被阻塞，直到有许可被释放。可以用来限制对某些资源（如数据库连接池、文件操作等）的并发访问量</li><li><strong>Future 和 Callable</strong>：Callable 是一个类似于 <code>Runnable</code> 的接口，但它可以返回结果，并且可以抛出异常。Future 用于表示一个异步计算的结果，可以通过它来获取 <code>Callable</code> 任务的执行结果或取消任务。</li><li><strong>ConcurrentHashMap</strong>：ConcurrentHashMap 是一个线程安全的哈希表，它允许多个线程同时进行读操作，在一定程度上支持并发的修改操作，避免了 <code>HashMap</code> 在多线程环境下需要使用 <code>synchronized</code> 或 <code>Collections.synchronizedMap()</code> 进行同步的性能问题。</li></ul><h2 id="Synchronized与ReentrantLock"><a href="#Synchronized与ReentrantLock" class="headerlink" title="Synchronized与ReentrantLock"></a>Synchronized与ReentrantLock</h2><p>synchronized 和 ReentrantLock 都是 Java 中提供的可重入锁：</p><ul><li><strong>用法不同</strong>：synchronized 可用来修饰普通方法、静态方法和代码块，而 ReentrantLock 只能用在代码块上。</li><li><strong>获取锁和释放锁方式不同</strong>：synchronized 会自动加锁和释放锁，当进入 synchronized 修饰的代码块之后会自动加锁，当离开 synchronized 的代码段之后会自动释放锁。而 ReentrantLock 需要手动加锁和释放锁</li><li><strong>锁类型不同</strong>：synchronized 属于非公平锁，而 ReentrantLock 既可以是公平锁也可以是非公平锁。</li><li><strong>响应中断不同</strong>：ReentrantLock 可以响应中断，解决死锁的问题，而 synchronized 不能响应中断。</li><li><strong>底层实现不同</strong>：synchronized 是 JVM 层面通过监视器实现的，而 ReentrantLock 是基于 AQS 实现的。</li></ul><p>synchronized 核心优化方案主要包含以下 4 个：</p><ul><li><strong>锁膨胀</strong>：synchronized 从无锁升级到偏向锁，再到轻量级锁，最后到重量级锁的过程，它叫做锁膨胀也叫做锁升级。JDK 1.6 之前，synchronized 是重量级锁，也就是说 synchronized 在释放和获取锁时都会从用户态转换成内核态，而转换的效率是比较低的。但有了锁膨胀机制之后，synchronized 的状态就多了无锁、偏向锁以及轻量级锁了，这时候在进行并发操作时，大部分的场景都不需要用户态到内核态的转换了，这样就大幅的提升了 synchronized 的性能。</li><li><strong>锁消除</strong>：指的是在某些情况下，JVM 虚拟机如果检测不到某段代码被共享和竞争的可能性，就会将这段代码所属的同步锁消除掉，从而到底提高程序性能的目的。</li><li><strong>锁粗化</strong>：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。</li><li><strong>自适应自旋锁</strong>：指通过自身循环，尝试获取锁的一种方式，优点在于它避免一些线程的挂起和恢复操作，因为挂起线程和恢复线程都需要从用户态转入内核态，这个过程是比较慢的，所以通过自旋的方式可以一定程度上避免线程挂起和恢复所造成的性能开销</li></ul><h2 id="AQS是什么"><a href="#AQS是什么" class="headerlink" title="AQS是什么"></a>AQS是什么</h2><p>AQS全称为AbstractQueuedSynchronizer，是Java中的一个抽象类。 AQS是一个用于构建锁、同步器、协作工具类的工具类（框架）。</p><p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p><p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。</p><p>AQS 是一个用于构建锁和同步器的框架，许多同步器如 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code> 等都是基于 AQS 构建的。AQS 使用一个 <code>volatile</code> 的整数变量 <code>state</code> 来表示同步状态，通过内置的 <code>FIFO</code> 队列来管理等待线程。它提供了一些基本的操作，如 <code>acquire</code>（获取资源）和 <code>release</code>（释放资源），这些操作会修改 <code>state</code> 的值，并根据 <code>state</code> 的值来判断线程是否可以获取或释放资源。AQS 的 <code>acquire</code> 操作通常会先尝试获取资源，如果失败，线程将被添加到等待队列中，并阻塞等待。<code>release</code> 操作会释放资源，并唤醒等待队列中的线程。</p><p>AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p><p>ThreadLocal</p><p><strong><code>ThreadLocal</code>：</strong> 为每个线程提供独立的变量副本。<strong>子线程默认不会继承父线程的 <code>ThreadLocal</code> 变量。</strong> 当子线程启动时，它自己的 <code>ThreadLocalMap</code> 是空的，不会包含父线程设置的任何 <code>ThreadLocal</code> 值。</p><p><strong><code>InheritableThreadLocal</code>：</strong> 当父线程创建子线程时，<strong>子线程会默认获取父线程所有 <code>InheritableThreadLocal</code> 变量的副本。</strong> 这些副本在子线程创建时被初始化，之后父子线程对各自副本的修改互不影响。</p><p><code>InheritableThreadLocal</code> 在<strong>线程池</strong>场景下存在局限性。如果线程池中的线程是<strong>复用</strong>的，而不是每次都新建的，那么子线程在被复用执行任务时，不会再次执行父线程的数据复制逻辑，从而无法继承新的 <code>InheritableThreadLocal</code> 值。为了解决这个问题，需要手动在任务提交或执行前后进行数据的传递和清理.</p><p>类似于 <code>ThreadLocal</code>，<code>InheritableThreadLocal</code> 也可能导致内存泄漏。即使子线程继承了父线程的值，当这些值不再需要时，也应该调用 <code>remove()</code> 方法进行清理，尤其是在线程池环境中。 </p><p>Synchronized</p><p>RetreenLock</p><p>ConcurrentHashMap</p><p><strong><code>CopyOnWriteArrayList</code>：</strong></p><ul><li><strong>特点：</strong> 线程安全的 <code>ArrayList</code> 实现。在<strong>写操作（添加、删除、修改）时，会复制一份底层数组</strong>，在新数组上进行修改，完成后再替换旧数组的引用。<strong>读操作无需加锁</strong>。</li><li><strong>适用场景：</strong> <strong>读操作远多于写操作</strong>的场景。写操作的开销较大，因为需要复制整个数组。</li><li><strong>注意事项：</strong> 迭代器是“弱一致性”的，即迭代器看到的是创建时集合的快照，不反映后续的写操作。</li></ul><p><strong><code>CopyOnWriteArraySet</code>：</strong></p><ul><li><strong>特点：</strong> 线程安全的 <code>HashSet</code> 实现，其内部就是基于 <code>CopyOnWriteArrayList</code> 实现的。</li><li><strong>适用场景：</strong> 同 <code>CopyOnWriteArrayList</code>，适用于读多写少的场景。</li></ul><p><code>Collections</code> 工具类包装的同步集合</p><p>这些集合通过在每个公共方法上添加 <code>synchronized</code> 关键字来实现同步。</p><ul><li><strong><code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code>：</strong> 线程安全的 <code>List</code>。</li><li><strong><code>Collections.synchronizedMap(new HashMap&lt;&gt;())</code>：</strong> 线程安全的 <code>Map</code>。</li><li><strong><code>Collections.synchronizedSet(new HashSet&lt;&gt;())</code>：</strong> 线程安全的 <code>Set</code>。</li><li><strong>特点：</strong> 简单易用，但<strong>同步粒度较粗</strong>，每次访问集合都需要获取对象锁。这意味着即使是读操作也会被阻塞。在高并发场景下，性能往往较差，容易成为性能瓶颈。</li><li><strong>适用场景：</strong> 并发程度较低的场景，或者对性能要求不高、需要快速实现线程安全的场景</li></ul><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>JVM 运行时内存共分为虚拟机栈、堆、元空间、程序计数器、本地方法栈五个部分。还有一部分内存叫直接内存，属于操作系统的本地内存，也是可以直接操作的。</p><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>按照线程是否共享,可以分为</p><p><strong>堆,元空间</strong></p><p>Java 堆是 JVM 所管理的内存中最大的一块，也是被<strong>所有线程共享</strong>的内存区域。其唯一的目的就是存放<strong>对象实例</strong>，几乎所有的对象实例以及数组都在这里分配内存。</p><p><strong>特性：</strong></p><ul><li><strong>线程共享：</strong> 所有线程共享这一块内存。</li><li><strong>垃圾收集器主要工作区域：</strong> 堆是 Java 垃圾收集器（Garbage Collector，GC）管理的主要区域，因此也被称为“GC 堆”（Garbage Collected Heap）。</li><li><strong>分代思想：</strong> 为了更好地进行垃圾回收，现代 JVM 的堆通常被细分为<strong>新生代（Young Generation）和老年代（Old Generation）</strong>。新生代又分为 Eden 空间、From Survivor 空间和 To Survivor 空间。</li><li><strong>内存分配：</strong> 大多数新创建的对象首先在新生代的 Eden 区分配</li></ul><p><strong>可能抛出异常：</strong></p><ul><li><code>OutOfMemoryError</code>：当堆中没有足够的内存完成实例分配，并且堆也无法再扩展时</li></ul><p>方法区（Method Area）</p><ul><li><p><strong>作用：</strong> 方法区（在 Java 8 之前是<strong>永久代</strong>，Java 8 及之后是<strong>元空间</strong>）是所有线程共享的内存区域，用于存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</p></li><li><p><strong>特性：</strong></p><ul><li><strong>线程共享。</strong></li><li><strong>垃圾回收：</strong> 方法区（元空间）也会进行垃圾回收，但条件比较苛刻，主要是对<strong>常量池的回收</strong>和对<strong>类型的卸载</strong>。</li><li><strong>元空间与永久代：</strong><ul><li><strong>永久代 (PermGen, Java 8 之前)：</strong> 属于堆的一部分，因此受到 GC 管理，大小固定或有限。容易发生 <code>OutOfMemoryError</code>。</li><li><strong>元空间 (Metaspace, Java 8 及之后)：</strong> 不在 JVM 内存中，而是使用<strong>本地内存（Native Memory）</strong>，理论上只受限于系统可用内存，因此默认情况下 OOM 风险降低。</li></ul></li></ul></li><li><p><strong>运行时常量池（Runtime Constant Pool）：</strong></p><ul><li>它是方法区的一部分（在 Java 8 元空间中，常量池位于元空间内部）。</li><li><p>用于存放编译期生成的各种字面量和符号引用，这些内容在类加载后进入运行时常量池。</p></li><li><p><strong>StringTable (字符串常量池)</strong>：虽然名字里有“常量池”，但它在 JVM 8 之前和之后的位置有所变化。</p></li><li><p>当你在 Java 代码中直接使用字符串字面量时（例如 <code>String s = &quot;hello&quot;;</code>），JVM 会首先检查字符串常量池中是否已经存在一个内容为 <code>&quot;hello&quot;</code> 的字符串对象。</p><ul><li>如果存在，<code>s</code> 就会直接引用池中已有的对象。</li><li><p>如果不存在，JVM 就会在堆中创建一个新的 <code>String</code> 对象，并将其引用放入字符串常量池，然后 <code>s</code> 再引用这个新的对象。 这种机制保证了<strong>常量池中每个唯一的字符串字面量只存在一份对应的 <code>String</code> 对象实例</strong></p></li><li><p>Java 7 及之前：位于<strong>永久代</strong>。</p></li><li>Java 8 及之后：被挪到了<strong>堆</strong>中。</li></ul></li></ul></li></ul><p><strong>可能抛出异常：</strong></p><ul><li><code>OutOfMemoryError</code>：当方法区（元空间）无法满足内存分配需求时。</li></ul><p><strong>虚拟机栈,本地方法栈以及程序计数器</strong></p><ol><li>程序计数器（Program Counter Register）</li></ol><ul><li><strong>作用：</strong> 程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。</li><li><strong>特性：</strong><ul><li><strong>线程私有：</strong> 每条 JVM 线程都有自己独立的程序计数器。</li><li><strong>唯一不抛出 <code>OutOfMemoryError</code> 的区域：</strong> 这是 JVM 规范中唯一一个没有规定任何 <code>OutOfMemoryError</code> 情况的区域。</li><li><strong>执行引擎的指示器：</strong> 如果线程正在执行的是一个 Java 方法，这个计数器就记录着正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。</li></ul></li></ul><ol><li>Java 虚拟机栈（Java Virtual Machine Stacks）</li></ol><ul><li><strong>作用：</strong> Java 虚拟机栈是线程私有的，它的生命周期与线程相同。每个方法在执行的同时都会创建一个<strong>栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口</strong>等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。\</li></ul><p>虚拟机栈中<strong>“动态链接”区域的实际内容</strong>是一个<strong>指向运行时常量池的引用</strong>。它的作用是：</p><ul><li><strong>桥梁：</strong> 作为当前执行方法与该方法所属类的运行时常量池之间的桥梁。</li><li><p><strong>入口：</strong> 为方法提供一个入口，使其在运行时能够根据需要（例如，调用其他方法、访问字段）去运行时常量池中查找并解析相应的<strong>符号引用</strong>。</p></li><li><p><strong>特性：</strong></p><ul><li><strong>线程私有：</strong> 每个线程都有独立的 Java 虚拟机栈。</li><li><strong>局部变量表：</strong> 存储方法参数和方法内部定义的局部变量（基本数据类型和对象引用）。</li><li><strong>操作数栈：</strong> 存储方法执行过程中需要操作的数据。</li><li><strong>栈帧：</strong> 随着方法调用而创建，随着方法结束而销毁。</li></ul></li><li><strong>可能抛出异常：</strong><ul><li><code>StackOverflowError</code>：如果线程请求的栈深度大于虚拟机所允许的深度（例如，无限递归）。</li><li><code>OutOfMemoryError</code>：如果 JVM 栈可以动态扩展，并且在扩展时无法申请到足够的内存。</li></ul></li></ul><ol><li>本地方法栈（Native Method Stacks）</li></ol><ul><li><strong>作用：</strong> 本地方法栈与 Java 虚拟机栈的作用类似，只不过它服务于 <strong>Native 方法</strong>（即用 C/C++ 等语言编写的本地方法）。</li><li><strong>特性：</strong><ul><li><strong>线程私有：</strong> 与 Java 虚拟机栈一样，也是线程私有的。</li></ul></li><li><strong>可能抛出异常：</strong><ul><li><code>StackOverflowError</code> 和 <code>OutOfMemoryError</code>：与 Java 虚拟机栈类似。</li></ul></li></ul><h3 id="虚拟机栈中存储的内容"><a href="#虚拟机栈中存储的内容" class="headerlink" title="虚拟机栈中存储的内容"></a>虚拟机栈中存储的内容</h3><p>在JVM内存模型中，栈（Stack）主要用于管理线程的局部变量和方法调用的上下文，而堆（Heap）则是用于存储所有类的实例和数组。</p><p>当我们在栈中讨论“存储”时，实际上指的是存储基本类型的数据（如int, double等）和对象的引用，而不是对象本身。</p><p>这里的关键点是，栈中存储的<strong>不是</strong>对象，而是<strong>对象的引用</strong>。也就是说，当你在方法中声明一个对象，比如<code>MyObject obj = new MyObject();</code>，这里的<code>obj</code>实际上是一个存储在栈上的引用，指向堆中实际的对象实例。这个引用是一个固定大小的数据（例如在64位系统上是8字节），它指向堆中分配给对象的内存区域。</p><h3 id="堆分为哪几个部分"><a href="#堆分为哪几个部分" class="headerlink" title="堆分为哪几个部分"></a>堆分为哪几个部分</h3><p>JVM 堆主要分为以下两个大的部分：</p><ol><li><strong>新生代 (Young Generation / Young Space)</strong></li><li><p><strong>老年代 (Old Generation / Tenured Generation / Old Space)</strong></p></li><li><p>新生代 (Young Generation)</p></li></ol><ul><li><strong>特点：</strong> 绝大多数新创建的对象都首先在新生代中分配内存。新生代中的对象生命周期通常比较短。</li><li><strong>组成：</strong> 新生代又进一步划分为三个子区域：<ul><li><strong>Eden 空间 (Eden Space)：</strong> 这是对象最初被创建和放置的区域。当 <code>new</code> 一个对象时，如果 Eden 空间足够，对象就会在这里分配。</li><li><strong>Survivor 空间 (Survivor Space)：</strong> 通常有两个，分别为 <strong>From Survivor Space</strong> 和 <strong>To Survivor Space</strong>。这两个空间在同一时间只有一个是活跃的（用作对象存活区），另一个是空的（用作下一次复制的清理区）。它们用于存放那些在 Eden 区经过一次垃圾回收后仍然存活的对象。</li></ul></li><li><strong>垃圾回收（Minor GC）：</strong> 新生代进行的垃圾回收被称为 <strong>Minor GC（或 Young GC）</strong>。<ul><li>当 Eden 空间不足以分配新对象时，会触发 Minor GC。</li><li><strong>Minor GC 会将 Eden 区和 From Survivor 区中仍然存活的对象复制到 To Survivor 区。</strong></li><li><strong>然后清空 Eden 区和 From Survivor 区</strong>。</li><li><strong>To Survivor 区和 From Survivor 区的角色会互换，以便下一次 Minor GC 使用。</strong></li><li>对象在 Survivor 区中每熬过一次 Minor GC，其年龄（age）就会增加一岁。当对象的年龄达到一定阈值（默认为 15，可以通过 <code>-XX:MaxTenuringThreshold</code> 参数调整）时，它就会被晋升（晋级）到老年代。</li></ul></li></ul><ol><li>老年代 (Old Generation / Tenured Generation)</li></ol><ul><li><strong>特点：</strong> 用于存放那些在新生代中<strong>多次垃圾回收后仍然存活的对象</strong>，或者是一些<strong>生命周期较长、占用内存较大的对象</strong>。老年代中的对象通常比较稳定，存活时间长。</li><li><strong>垃圾回收（Major GC / Full GC）：</strong> 老年代进行的垃圾回收被称为 <strong>Major GC（或 Full GC）</strong>。<ul><li>当老年代空间不足时，会触发 Major GC。</li><li>Major GC 的回收效率通常比 Minor GC 低很多，耗时也更长，因为它需要扫描整个老年代，并且可能会触发新生代的 Minor GC。因此，应该尽量避免频繁的 Major GC。</li></ul></li></ul><p>大对象通常会直接分配到老年代。</p><p>新生代主要用于存放生命周期较短的对象，并且其内存空间相对较小。如果将大对象分配到新生代，可能会很快导致新生代空间不足，从而频繁触发 Minor GC。而每次 Minor GC 都需要进行对象的复制和移动操作，这会带来一定的性能开销。将大对象直接分配到老年代，可以减少新生代的内存压力，降低 Minor GC 的频率。</p><p><strong>大对象通常需要连续的内存空间，如果在新生代中频繁分配和回收大对象，容易产生内存碎片，导致后续分配大对象时可能因为内存不连续而失败</strong>。老年代的空间相对较大，更适合存储大对象，有助于减少内存碎片的产生</p><p>当程序中通过对象或类直接调用某个方法时，主要包括以下几个步骤：</p><ul><li><strong>解析方法调用</strong>：JVM会根据方法的符号引用找到实际的方法地址（如果之前没有解析过的话）。</li><li><strong>栈帧创建</strong>：在调用一个方法前，JVM会在当前线程的Java虚拟机栈中为该方法分配一个新的栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li><li><strong>执行方法</strong>：执行方法内的字节码指令，涉及的操作可能包括局部变量的读写、操作数栈的操作、跳转控制、对象创建、方法调用等。</li><li><strong>返回处理</strong>：方法执行完毕后，可能会返回一个结果给调用者，并清理当前栈帧，恢复调用者的执行环境。</li></ul><p>方法区于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</p><ul><li>类信息：包括类的结构信息、类的访问修饰符、父类与接口等信息。</li><li>常量池：存储类和接口中的常量，包括字面值常量、符号引用，以及运行时常量池。</li><li>静态变量：存储类的静态变量，这些变量在类初始化的时候被赋值。</li><li>方法字节码：存储类的方法字节码，即编译后的代码。</li><li>符号引用：存储类和方法的符号引用，是一种直接引用不同于直接引用的引用类型。</li><li>运行时常量池：存储着在类文件中的常量池数据，在类加载后在方法区生成该运行时常量池。</li><li>常量池缓存：用于提升类加载的效率，将常用的常量缓存起来方便使用。</li></ul><p>String 保存在字符串常量池中，不同于其他对象，它的值是不可变的，且可以被多个引用共享.</p><p> String s = new String（“abc”）执行过程中分别对应哪些内存区域？</p><p>首先，我们看到这个代码中有一个new关键字，我们知道<strong>new</strong>指令是创建一个类的实例对象并完成加载初始化的，因此这个字符串对象是在<strong>运行期</strong>才能确定的，创建的字符串对象是在<strong>堆内存上</strong>。</p><p>其次，在String的构造方法中传递了一个字符串abc，由于这里的abc是被final修饰的属性，所以它是一个字符串常量。在首次构建这个对象时，JVM拿字面量”abc”去字符串常量池试图获取其对应String对象的引用。于是在堆中创建了一个”abc”的String对象，并将其引用保存到字符串常量池中，然后返回；</p><p>所以，<strong>如果abc这个字符串常量不存在，则创建两个对象，分别是abc这个字符串常量，以及new String这个实例对象。如果abc这字符串常量存在，则只会创建一个对象</strong>。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用类型主要分为强软弱虚四种：</p><ul><li>强引用指的就是代码中普遍存在的赋值方式，比如A a = new A()这种。强引用关联的对象，永远不会被GC回收。</li><li>软引用可以用SoftReference来描述，指的是那些有用但是不是必须要的对象。系统在发生内存溢出前会对这类引用的对象进行回收。</li><li>弱引用可以用WeakReference来描述，他的强度比软引用更低一点，弱引用的对象下一次GC的时候一定会被回收，而不管内存是否足够。</li><li>虚引用也被称作幻影引用，是最弱的引用关系，可以用PhantomReference来描述，他必须和ReferenceQueue一起使用，同样的当发生GC的时候，虚引用也会被回收。可以用虚引用来管理堆外内存。</li></ul><p>在Java中，弱引用是通过<code>Java.lang.ref.WeakReference</code>类实现的。弱引用的一个主要用途是创建非强制性的对象引用，这些引用可以在内存压力大时被垃圾回收器清理，从而避免内存泄露。</p><p>弱引用的使用场景：</p><ul><li><strong>缓存系统</strong>：弱引用常用于实现缓存，特别是当希望缓存项能够在内存压力下自动释放时。<strong>如果缓存的大小不受控制，可能会导致内存溢出。使用弱引用来维护缓存，可以让JVM在需要更多内存时自动清理</strong>这些缓存对象。</li><li><strong>对象池</strong>：在对象池中，弱引用可以用来管理那些暂时不使用的对象。当对象不再被强引用时，它们可以被垃圾回收，释放内存。</li><li><strong>避免内存泄露</strong>：当一个对象不应该被长期引用时，使用弱引用可以防止该对象被意外地保留，从而避免潜在的内存泄露。</li></ul><p><strong>内存泄露</strong>：内存泄漏是指程序在运行过程中<strong>不再使用的对象仍然被引用，而无法被垃圾收集器回收，从而导致可用内存逐渐减少</strong>。虽然在Java中，垃圾回收机制会自动回收不再使用的对象，但如果有对象仍被不再使用的引用持有，垃圾收集器无法回收这些内存，最终可能导致程序的内存使用不断增加。</p><p>内存泄露常见原因：</p><ul><li><strong>静态集合</strong>：使用静态数据结构（如<code>HashMap</code>或<code>ArrayList</code>）存储对象，且未清理。</li><li><strong>事件监听</strong>：未取消对事件源的监听，导致对象持续被引用。</li><li><strong>线程</strong>：未停止的线程可能持有对象引用，无法被回收。</li></ul><p>内存溢出：内存溢出是指Java虚拟机（JVM）在申请内存时，无法找到足够的内存，最终引发<code>OutOfMemoryError</code>。这通常发生在堆内存不足以存放新创建的对象时。</p><p>内存溢出常见原因：</p><ul><li><strong>大量对象创建</strong>：程序中不断创建大量对象，超出JVM堆的限制。</li><li><strong>持久引用</strong>：大型数据结构（如缓存、集合等）长时间持有对象引用，导致内存累积。</li><li><strong>递归调用</strong>：深度递归导致栈溢出。</li></ul><h3 id="内存泄漏案例"><a href="#内存泄漏案例" class="headerlink" title="内存泄漏案例"></a>内存泄漏案例</h3><p>1、静态属性导致内存泄露</p><p>静态强引用变量作用域是全局的.</p><p>留意static的变量，如果集合或大量的对象定义为static的，它们会停留在整个应用程序的生命周期当中。而它们所占用的内存空间，本可以用于其他地方。</p><p>那么如何优化呢？第一，进来减少静态变量；第二，如果使用单例，尽量采用懒加载。</p><p>2.ThreadLocal提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定，从而实现线程安全的特性。</p><p>ThreadLocal的实现中，每个Thread维护一个ThreadLocalMap映射表，key是ThreadLocal实例本身，value是真正需要存储的Object。</p><p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统GC时，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value。</p><p>如果当前线程迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。</p><p>如何解决此问题？</p><ul><li>第一，使用ThreadLocal提供的remove方法，可对当前线程中的value值进行移除；</li><li>第二，不要使用ThreadLocal.set(null) 的方式清除value，它实际上并没有清除值，而是查找与当前线程关联的Map并将键值对分别设置为当前线程和null。</li><li>第三，最好将ThreadLocal视为需要在finally块中关闭的资源，以确保即使在发生异常的情况下也始终关闭该资源。</li></ul><h2 id="类初始化与类加载"><a href="#类初始化与类加载" class="headerlink" title="类初始化与类加载"></a>类初始化与类加载</h2><p><img data-src="https://cdn.xiaolincoding.com//picgo/1713516384566-e820b967-73ce-49a4-a6e6-36af9a38ebc4.webp" alt="img"></p><h3 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h3><p>一个 <code>new</code> 操作背后包含了 JVM 复杂的内部协作：</p><ol><li><strong>类加载检查：</strong> 确保类已准备就绪。</li><li><strong>分配内存：</strong> 在堆上为对象实例开辟空间，考虑并发问题。</li><li><strong>初始化零值：</strong> 为所有成员变量赋默认值。</li><li><strong>设置对象头：</strong> 填充对象的元数据信息。</li><li><strong>执行构造函数：</strong> 按照代码逻辑完成对象的初始化。</li><li><strong>返回引用：</strong> 将新对象的内存地址交给程序使用。</li></ol><p>在Java中创建对象的过程包括以下几个步骤：</p><ol><li><p><strong>类加载检查</strong>：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在<strong>常量池</strong>中定位到一个类的<strong>符号引用</strong>，并且检查这个符号引用代表的类是否已被<strong>加载过、解析和初始化</strong>过。如果没有，那必须先执行相应的<strong>类加载过程</strong>。 执行类的 <code>&lt;clinit&gt;()</code> 方法（类构造器方法），这是首次对类进行主动使用时触发的。该方法会执行<strong>静态代码块中的内容</strong>，并为静态变量赋<strong>明确指定的值</strong>。</p><p>如果类没有被加载、链接和初始化，JVM 会先执行这些必要的类加载过程。</p></li><li><p><strong>分配内存</strong>：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的<strong>内存大小</strong>在<strong>类加载</strong>完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。</p></li><li><p><strong>初始化零值</strong>：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p></li><li><p><strong>进行必要设置，比如对象头</strong>：初始化零值完成之后，虚拟机要对对象进行<strong>必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在<strong>对象头</strong>中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p></li><li>‘’<strong>执行 init 方法</strong>：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始——构造函数，即class文件中的方法还没有执行，所有的字段都还为零，<strong>对象需要的其他资源和状态信息</strong>还没有按照预定的意图构造好。所以一般来说，执行 new 指令之后会接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全被构造出来。</li></ol><p>对象的生命周期包括创建、使用和销毁三个阶段：</p><ul><li><p>创建：对象通过关键字new在堆内存中被实例化，构造函数被调用，对象的内存空间被分配。</p></li><li><p>使用：对象被引用并执行相应的操作，可以通过引用访问对象的属性和方法，在程序运行过程中被不断使用。</p></li><li><p>销毁：当对象不再被引用时，通过垃圾回收机制自动回收对象所占用的内存空间。垃圾回收器会在适当的时候检测并回收不再被引用的对象，释放对象占用的内存空间，完成对象的销毁过程。</p></li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li><strong>启动类加载器（Bootstrap Class Loader）</strong>：这是最顶层的类加载器，负责加载Java的核心库（如位于jre/lib/rt.jar中的类），它是用C++编写的，是JVM的一部分。启动类加载器无法被Java程序直接引用。 这是最顶层的类加载器，由 C++ 实现，是 JVM 自身的一部分，因此在 Java 代码中无法直接获取到它的引用。它负责加载 <code>JAVA_HOME/jre/lib</code> 目录下（或被 <code>-Xbootclasspath</code> 参数所指定的路径中）所有 Java 核心 API 的 <code>.jar</code> 文件，例如 <code>rt.jar</code> (运行时类库)、<code>charsets.jar</code> 等。基于安全考虑，它只能加载指定路径下的核心库。</li><li><strong>扩展类加载器（Extension Class Loader）</strong>：它是Java语言实现的，继承自ClassLoader类，负责加载Java扩展目录（jre/lib/ext或由系统变量Java.ext.dirs指定的目录）下的jar包和类库。扩展类加载器由启动类加载器加载，并且父加载器就是启动类加载器。可以加载开发者在 <code>ext</code> 目录下放置的自定义 <code>.jar</code> 包。</li><li><strong>系统类加载器（System Class Loader）/ 应用程序类加载器（Application Class Loader）</strong>：这也是Java语言实现的，负责加载用户类路径（ClassPath）上的指定类库，是我们平时编写Java程序时默认使用的类加载器。系统类加载器的父加载器是扩展类加载器。它可以通过ClassLoader.getSystemClassLoader()方法获取到。是用户自定义类加载器的默认父加载器，也是我们平时最常用的一个类加载器</li><li><strong>自定义类加载器（Custom Class Loader）</strong>：开发者可以根据需求定制类的加载方式，比如从网络加载class文件、数据库、甚至是加密的文件中加载类等。自定义类加载器可以用来扩展Java应用程序的灵活性和安全性，是Java动态性的一个重要体现。</li></ul><p>这些类加载器之间的关系形成了双亲委派模型，其核心思想是<strong>当一个类加载器收到类加载的请求时，首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中</strong>。</p><p>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p><h3 id="双亲委派模型作用"><a href="#双亲委派模型作用" class="headerlink" title="双亲委派模型作用"></a>双亲委派模型作用</h3><p>双亲委派模型工作原理：</p><ol><li>当一个类加载器收到类加载请求时，它并不会立即尝试加载这个类。</li><li>它首先会把这个请求委派给它的<strong>父加载器</strong>去执行。</li><li>只有当父加载器反馈它无法完成这个加载请求时（即在它的搜索范围内没有找到该类），子加载器才会尝试自己去加载。</li></ol><p>双亲委派模型的优点：</p><ul><li><strong>避免重复加载：</strong> 确保一个类在 JVM 中只会被加载一次，因为总是由顶层的父加载器优先加载。</li><li><p><strong>安全性：</strong> 防止核心 API 类被恶意替换。例如，如果有人尝试编写一个名为 <code>java.lang.Object</code> 的类并替换核心库，由于启动类加载器会优先加载真正的 <code>rt.jar</code> 中的 <code>Object</code> 类，恶意类就不会被加载。</p></li><li><p><strong>保证类的唯一性</strong>：通过委托机制，<strong>确保了所有加载请求都会传递到启动类加载器，避免了不同类加载器重复加载相同类的情况</strong>，保证了Java核心类库的统一性，也防止了用户自定义类覆盖核心类库的可能。</p></li><li><strong>保证安全性</strong>：由于Java核心库被启动类加载器加载，而启动类加载器只加载信任的类路径中的类，这样可以防止不可信的类假冒核心类，增强了系统的安全性。例如，恶意代码无法自定义一个Java.lang.System类并加载到JVM中，因为这个请求会被委托给启动类加载器，而启动类加载器只会加载标准的Java库中的类。</li><li><strong>支持隔离和层次划分</strong>：双亲委派模型支持不同层次的类加载器服务于不同的类加载需求，如应用程序类加载器加载用户代码，扩展类加载器加载扩展框架，启动类加载器加载核心库。这种层次化的划分有助于实现沙箱安全机制，保证了各个层级类加载器的职责清晰，也便于维护和扩展。</li><li><strong>简化了加载流程</strong>：通过委派，大部分类能够被正确的类加载器加载，减少了每个加载器需要处理的类的数量，简化了类的加载过程，提高了加载效率。</li></ul><p><strong>双亲委派模型的工作流程</strong>，主要分为四步，</p><p>第一步是检查缓存，当前类加载器会先检查是否已经加载过目标类，如果已加载，则直接返回对应的 Class 对象。</p><p>第二步是委派父加载器，如果没有加载过，当前类加载器会将加载请求委派给父加载器处理。</p><p>第三步是递归向上，父加载器继续将请求委派给它的父加载器，直到到达 Bootstrap ClassLoader。</p><p>第四步是尝试加载，如果父加载器无法加载目标类，则子加载器会尝试自己加载。</p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括以下 7 个阶段：</p><ul><li><strong>加载</strong>：通过类的全限定名（包名 + 类名），获取到该类的.class文件的二进制字节流，将二进制字节流所代表的静态存储结构，转化为方法区运行时的数据结构，在内存中生成一个代表该类的Java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li><li><strong>链接</strong>：验证、准备、解析 3 个阶段统称为连接。<ul><li><strong>验证</strong>：确保class文件中的字节流包含的信息，符合当前虚拟机的要求，保证这个被加载的class类的正确性，不会危害到虚拟机的安全。验证阶段大致会完成以下四个阶段的检验动作：文件格式校验、元数据验证、字节码验证、符号引用验证</li><li><strong>准备</strong>：为类中的静态字段分配内存，并设置默认的初始值，比如int类型初始值是0。被final修饰的static字段不会设置，因为final在编译的时候就分配了</li><li><strong>解析</strong>：解析阶段是虚拟机<strong>将常量池的「符号引用」直接替换为「直接引用」的过程</strong>。符号引用是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用的时候可以无歧义地定位到目标即可。直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，直接引用是和虚拟机实现的内存布局相关的。如果有了直接引用， 那引用的目标必定已经存在在内存中了。</li></ul></li><li><strong>初始化</strong>：初始化是整个类加载过程的最后一个阶段，初始化阶段简单来说就是执行类的初始化代码（括静态变量赋值和静态代码块的执行），要注意的是这里的初始化方法并不是开发者写的，而是编译器自动生成的。初始化的顺序遵循“父类优先”的原则，即先初始化父类，再初始化子类。</li><li><strong>使用</strong>：使用类或者创建对象</li><li><strong>卸载</strong>：如果有下面的情况，类就会被卸载：1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。2. 加载该类的ClassLoader已经被回收。 3. 类对应的Java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>垃圾回收（Garbage Collection, GC）是自动管理内存的一种机制，它负责自动释放不再被程序引用的对象所占用的内存，这种机制减少了内存泄漏和内存管理错误的可能性。</p><p>垃圾回收（Garbage Collection, GC）是自动管理内存的一种机制，它负责自动释放不再被程序引用的对象所占用的内存，这种机制减少了内存泄漏和内存管理错误的可能性。垃圾回收可以通过多种方式触发，具体如下：</p><ul><li><strong>内存不足时</strong>：当JVM检测到堆内存不足，无法为新的对象分配内存时，会自动触发垃圾回收。</li><li><strong>手动请求</strong>：虽然垃圾回收是自动的，开发者可以通过调用 <code>System.gc()</code> 或 <code>Runtime.getRuntime().gc()</code> 建议 JVM 进行垃圾回收。不过这只是一个建议，并不能保证立即执行。</li><li><strong>JVM参数</strong>：启动 Java 应用时可以通过 JVM 参数来调整垃圾回收的行为，比如：<code>-Xmx</code>（最大堆大小）、<code>-Xms</code>（初始堆大小）等。</li><li><strong>对象数量或内存使用达到阈值</strong>：垃圾收集器内部实现了一些策略，以监控对象的创建和内存使用，达到某个阈值时触发垃圾回收</li></ul><h3 id="判断垃圾的方式"><a href="#判断垃圾的方式" class="headerlink" title="判断垃圾的方式"></a>判断垃圾的方式</h3><p>引用计数与可达性分析.</p><p><strong>引用计数法</strong>（Reference Counting）</p><ul><li><strong>原理</strong>：为每个对象分配一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1。当计数器为0时，表示对象不再被任何变量引用，可以被回收。</li><li><strong>缺点</strong>：<strong>不能解决循环引用的问题</strong>，即两个对象相互引用，但不再被其他任何对象引用，这时引用计数器不会为0，导致对象无法被回收。</li></ul><p><strong>可达性分析</strong></p><p>Java虚拟机主要采用此算法来判断对象是否为垃圾。</p><ul><li><strong>原理</strong>：从一组称为GC Roots（垃圾收集根）的对象出发，向下追溯它们引用的对象，以及这些对象引用的其他对象，以此类推。如果一个对象到GC Roots没有任何引用链相连（即从GC Roots到这个对象不可达），那么这个对象就被认为是不可达的，可以被回收。GC Roots对象包括：<strong>虚拟机栈（栈帧中的本地变量表）中引用的对象</strong>、<strong>方法区中类静态属性引用的对象</strong>、本地方法栈中JNI（Java Native Interface）引用的对象、<strong>活跃线程的引用</strong>等</li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ul><li><strong>标记-清除算法</strong>：标记-清除算法分为“标记”和“清除”两个阶段，首先通过可达性分析，标记出所有需要回收的对象，然后统一回收所有被标记的对象。标记-清除算法有两个缺陷，一个是效率问题，标记和清除的过程效率都不高，另外一个就是，清除结束后会造成大量的碎片空间。有可能会造成在申请大块内存的时候因为没有足够的连续空间导致再次 GC。</li><li><strong>复制算法</strong>：为了解决碎片空间的问题，出现了“复制算法”。复制算法的原理是，将内存分成两块，每次申请内存时都使用其中的一块，当内存不够时，将这一块内存中所有存活的复制到另一块上。然后将然后再把已使用的内存整个清理掉。复制算法解决了空间碎片的问题。但是也带来了新的问题。因为每次在申请内存时，都只能使用一半的内存空间。内存利用率严重不足。</li><li><strong>标记-整理算法</strong>：复制算法在 GC 之后存活对象较少的情况下效率比较高，但如果存活对象比较多时，会执行较多的复制操作，效率就会下降。而老年代的对象在 GC 之后的存活率就比较高，所以就有人提出了“标记-整理算法”。标记-整理算法的“标记”过程与“标记-清除算法”的标记过程一致，但标记之后不会直接清理。而是将所有存活对象都移动到内存的一端。移动结束后直接清理掉剩余部分。</li><li><strong>分代回收算法</strong>：分代收集是将内存划分成了新生代和老年代。分配的依据是对象的生存周期，或者说经历过的 GC 次数。对象创建时，一般在新生代申请内存，当经历一次 GC 之后如果对还存活，那么对象的年龄 +1。当年龄超过一定值(默认是 15，可以通过参数 -XX:MaxTenuringThreshold 来设定)后，如果对象还存活，那么该对象会进入老年代。</li></ul><p>对于新生代，大多数对象朝生夕灭，采用复制算法进行垃圾回收。新生代进一步划分为 Eden 区和两个 Survivor 区（From 和 To）；对于老年代，存活时间较长的对象存储在此，采用标记-清除或标记-整理算法进行垃圾回收。</p><h3 id="垃圾回收器有哪些"><a href="#垃圾回收器有哪些" class="headerlink" title="垃圾回收器有哪些"></a>垃圾回收器有哪些</h3><ul><li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li><li>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代</li></ul><p>第一个是 <strong>CMS 收集器</strong>，CMS（Concurrent Mark Sweep）是以最小化停顿时间为目标的垃圾收集器，适用于需要高响应的应用场景（如 Web 应用）。其基于“标记-清除算法”，回收流程包括以下阶段：</p><p>首先停止所有用户线程，启用一个GC线程进行初始标记（Stop The World）<strong>，</strong>标记 GC Roots 能直接引用的对象，停顿时间短。</p><p>其次由用户线程和 GC 线程并发执行，进行并发标记<strong>，</strong>用户线程和 GC 线程并发执行，完成从 GC Roots 开始的对象引用分析。</p><p>然后，启动多个GC 线程进行重新标记（Stop The World），修正并发标记期间用户线程对对象引用的变动，停顿时间稍长但可控。</p><p>最后，启动多个用户线程和一个GC 线程，进行并发清除<strong>，</strong>清理不可达对象，清理完成后把GC线程进行重置。</p><p>CMS 的优点是以响应时间优先，停顿时间短，但也有两个缺点，一个是由于CMS采用“标记-清除”，会导致内存碎片积累，另一个是由于在并发清理过程中仍有用户线程运行，可能生成新的垃圾对象，需在下次 GC 处理。</p><p>第二个是 <strong>G1 收集器</strong>，G1（Garbage-First）收集器以控制 GC 停顿时间为目标，兼具高吞吐量和低延迟性能，适用于大内存、多核环境。其基于“标记-整理”和“标记-复制算法”，回收流程包括以下阶段：</p><p>首先，停止所有用户线程，启用一个GC线程进行初始标记（Stop The World）<strong>，</strong>标记从 GC Roots 可达的对象，时间短。</p><p>其次，让用户线程和一个GC 线程并发工作，用GC 线程进行并发标记<strong>，</strong>分析整个堆中对象的存活情况。</p><p>然后，停止所有用户线程，让多个GC 线程进行最终标记（Stop The World），修正并发标记阶段产生的引用变动，识别即将被回收的对象。</p><p>最后，让多个GC 线程进行筛选回收<strong>，</strong>根据收集时间预算，优先回收回收价值最高的 Region。回收完成后把GC线程进行重置。这是 G1 的核心优化，基于堆分区，将回收工作集中于垃圾最多的区域，避免全堆扫描。</p><p>G1 具有三个优点，</p><p>其一，将堆内存划分为多个 Region，可分别执行标记、回收，提升效率。</p><p>第二，采用“标记-整理”和“标记-复制”，实现内存紧凑化。</p><p>第三，方便控制停顿时间，通过后台维护的优先队列，动态选择高价值 Region，极大减少了全堆停顿的频率。</p><p>但G1缺点是：调优复杂，对硬件资源要求较高。</p><h1 id="Spring与SpringBoot"><a href="#Spring与SpringBoot" class="headerlink" title="Spring与SpringBoot"></a>Spring与SpringBoot</h1><blockquote><p>重要考点:Bean的声明周期与扩展方法  IoC和AOP理解</p><p>动态代理 动态代理与静态代理区别  AOP执行流程</p><p>Spring事务,传播行为以及什么时候会失效</p></blockquote><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>Spring框架核心特性包括：</p><ul><li><strong>IoC容器</strong>：Spring通过控制反转实现了对象的创建和对象间的依赖关系管理。开发者只需要定义好Bean及其依赖关系，Spring容器负责创建和组装这些对象。</li><li><strong>AOP</strong>：面向切面编程，允许开发者定义横切关注点，例如事务管理、安全控制等，独立于业务逻辑的代码。通过AOP，可以将这些关注点模块化，提高代码的可维护性和可重用性。</li><li><strong>事务管理</strong>：Spring提供了一致的事务管理接口，支持声明式和编程式事务。开发者可以轻松地进行事务管理，而无需关心具体的事务API。</li><li><strong>MVC框架</strong>：Spring MVC是一个基于Servlet API构建的Web框架，采用了模型-视图-控制器（MVC）架构。它支持灵活的URL到页面控制器的映射，以及多种视图技术</li></ul><div class="table-container"><table><thead><tr><th><strong>核心思想</strong></th><th><strong>解决的问题</strong></th><th><strong>实现手段</strong></th><th><strong>典型应用场景</strong></th></tr></thead><tbody><tr><td><strong>IOC</strong></td><td>对象创建与依赖管理的高耦合</td><td>容器管理Bean生命周期</td><td>动态替换数据库实现、服务组装</td></tr><tr><td><strong>DI</strong></td><td>依赖关系的硬编码问题</td><td>Setter/构造器/注解注入</td><td>注入数据源、服务层依赖DAO层</td></tr><tr><td><strong>AOP</strong></td><td>横切逻辑分散在业务代码中</td><td>动态代理与切面配置</td><td>日志、事务、权限校验统一处理</td></tr></tbody></table></div><ul><li><strong>IoC</strong>：即控制反转的意思，它是一种创建和获取对象的技术思想，依赖注入(DI)是实现这种技术的一种方式。传统开发过程中，我们需要通过new关键字来创建对象。使用IoC思想开发方式的话，我们不通过new关键字创建对象，而是通过IoC容器来帮我们实例化对象。 通过IoC的方式，可以大大降低对象之间的耦合度。</li><li><strong>AOP</strong>：是面向切面编程，能够将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，以减少系统的重复代码，降低模块间的耦合度。Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 Cglib 生成一个被代理对象的子类来作为代理。</li></ul><h2 id="Spring中的AOP"><a href="#Spring中的AOP" class="headerlink" title="Spring中的AOP"></a>Spring中的AOP</h2><p>在面向切面编程的思想里面，把功能分为两种</p><ul><li><strong>核心业务</strong>：登陆、注册、增、删、改、查、都叫核心业务</li><li><strong>周边功能</strong>：日志、事务管理这些次要的为周边业务</li></ul><p>在面向切面编程中，核心业务功能和周边功能是分别独立进行开发，两者不是耦合的，然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOP。</p><p>AOP能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p><p>在 AOP 中有以下几个概念：</p><ul><li><strong>AspectJ</strong>：切面，只是一个概念，没有具体的接口或类与之对应，是 Join point，Advice 和 Pointcut 的一个统称。</li><li><strong>Join point</strong>：连接点，指程序执行过程中的一个点，例如方法调用、异常处理等。在 Spring AOP 中，仅支持方法级别的连接点。</li><li><strong>Advice</strong>：通知，即我们定义的一个切面中的横切逻辑，有“around”，“before”和“after”三种类型。在很多的 AOP 实现框架中，Advice 通常作为一个拦截器，也可以包含许多个拦截器作为一条链路围绕着 Join point 进行处理。</li><li><strong>Pointcut</strong>：切点，用于匹配连接点，一个 AspectJ 中包含哪些 Join point 需要由 Pointcut 进行筛选。</li><li><strong>Introduction</strong>：引介，让一个切面可以声明被通知的对象实现任何他们没有真正实现的额外的接口。例如可以让一个代理对象代理两个目标类。</li><li><strong>Weaving</strong>：织入，在有了连接点、切点、通知以及切面，如何将它们应用到程序中呢？没错，就是织入，在切点的引导下，将通知逻辑插入到目标方法上，使得我们的通知逻辑在方法调用时得以执行。</li><li><strong>AOP proxy</strong>：AOP 代理，指在 AOP 实现框架中实现切面协议的对象。在 Spring AOP 中有两种代理，分别是 JDK 动态代理和 CGLIB 动态代理。</li><li><strong>Target object</strong>：目标对象，就是被代理的对象。</li></ul><h2 id="Spring的中IoC"><a href="#Spring的中IoC" class="headerlink" title="Spring的中IoC"></a>Spring的中IoC</h2><p>Spring IoC（Inversion of Control，控制反转）是 Spring 框架的核心机制之一，负责管理对象的创建、依赖关系和生命周期，从而实现组件解耦，提升代码的可维护性和扩展性。</p><p>首先，<strong>IoC 的核心思想</strong> 是将对象的管理权从应用程序代码中转移到 Spring 容器。传统方式下，类 A 依赖于类 B，A 需要自己创建 B 的实例，而在 IoC 模式下，Spring 负责实例化和注入 B，A 只需要声明依赖即可。</p><p>其次，<strong>Spring IoC 主要通过依赖注入（DI）来实现</strong>。Spring 通过 XML 配置、Java 注解（@Autowired、@Resource）或 Java 代码（@Bean）定义 Bean 及其依赖关系，容器会在运行时自动解析并注入相应的对象。</p><p>接着，<strong>Spring IoC 的工作流程</strong> 可以分为三个阶段：</p><p>第一个阶段是IOC 容器初始化，</p><p>Spring 解析 XML 配置或注解，获取所有 Bean 的定义信息，生成 BeanDefinition。</p><p>BeanDefinition 存储了 Bean 的基本信息（类名、作用域、依赖等），并注册到 IOC 容器的 BeanDefinitionMap 中。</p><p>这个阶段完成了 IoC 容器的初始化，但还未实例化 Bean。</p><p>第二个阶段是Bean 实例化及依赖注入</p><p>Spring 通过反射实例化那些 未设置 lazy-init 且是单例模式 的 Bean。</p><p>依赖注入（DI）发生在这个阶段，Spring 根据 BeanDefinition 解析 Bean 之间的依赖关系，并通过构造方法、setter 方法或字段注入（@Autowired）完成对象的注入。</p><p>第三个阶段是Bean 的使用</p><p>业务代码可以通过 @Autowired 或 BeanFactory.getBean() 获取 Bean。</p><p>对于 设置了 lazy-init 的 Bean 或非单例 Bean，它们的实例化不会在 IoC 容器初始化时完成，而是在 第一次调用 getBean() 时 进行创建和初始化，且 Spring 不会长期管理它们。</p><p>最后，<strong>Spring IoC 主要解决三个问题</strong>，</p><p>第一个是降低耦合，组件之间通过接口和依赖注入解耦，增强了代码的灵活性。</p><p>第二个是简化对象管理，开发者无需手动创建对象，Spring 统一管理 Bean 生命周期。</p><p>第三个是提升维护性，当需要修改依赖关系时，只需调整配置，而无需修改业务代码。</p><h2 id="IOC和AOP实现机制"><a href="#IOC和AOP实现机制" class="headerlink" title="IOC和AOP实现机制"></a>IOC和AOP实现机制</h2><h3 id="IOC实现机制"><a href="#IOC实现机制" class="headerlink" title="IOC实现机制"></a>IOC实现机制</h3><ul><li><strong>反射</strong>：Spring IOC容器利用Java的反射机制动态地加载类、创建对象实例及调用对象方法，反射允许在运行时检查类、方法、属性等信息，从而实现灵活的对象实例化和管理。</li><li><strong>依赖注入</strong>：IOC的核心概念是依赖注入，即容器负责管理应用程序组件之间的依赖关系。Spring通过构造函数注入、属性注入或方法注入，将组件之间的依赖关系描述在配置文件中或使用注解。</li><li><strong>设计模式 - 工厂模式</strong>：Spring IOC容器通常采用工厂模式来管理对象的创建和生命周期。容器作为工厂负责实例化Bean并管理它们的生命周期，将Bean的实例化过程交给容器来管理。</li><li><strong>容器实现</strong>：Spring IOC容器是实现IOC的核心，通常使用BeanFactory或ApplicationContext来管理Bean。BeanFactory是IOC容器的基本形式，提供基本的IOC功能；ApplicationContext是BeanFactory的扩展，并提供更多企业级功能。</li></ul><p><strong>所谓控制</strong>就是对象的创建、初始化、销毁。</p><ul><li>创建对象：原来是 new 一个，现在是由 Spring 容器创建。</li><li>初始化对象：原来是对象自己通过构造器或者 setter 方法给依赖的对象赋值，现在是由 Spring 容器自动注入。</li><li>销毁对象：原来是直接给对象赋值 null 或做一些销毁操作，现在是 Spring 容器管理生命周期负责销毁对象。</li></ul><p><strong>控制反转与依赖注入</strong></p><ul><li>控制反转：“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。</li><li>依赖注入：依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。<strong>不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用</strong>。</li></ul><p>依赖注入则是将<strong>对象的创建和依赖关系的管理交给 Spring 容器来完成，类只需要声明自己所依赖的对象，容器会在运行时将这些依赖对象注入到类中</strong>，从而降低了类与类之间的耦合度，提高了代码的可维护性和可测试性。常见的依赖注入的实现方式，比如构造器注入、Setter方法注入，还有字段注入</p><p><strong>Spring IOC实现需要考虑的问题</strong></p><ul><li>Bean的生命周期管理：需要设计Bean的创建、初始化、销毁等生命周期管理机制，可以考虑使用工厂模式和单例模式来实现。</li><li>依赖注入：需要实现依赖注入的功能，包括属性注入、构造函数注入、方法注入等，可以考虑使用反射机制和XML配置文件来实现。</li><li>Bean的作用域：需要支持多种Bean作用域，比如单例、原型、会话、请求等，可以考虑使用Map来存储不同作用域的Bean实例。</li><li>AOP功能的支持：需要支持AOP功能，可以考虑使用动态代理机制和切面编程来实现。</li><li>异常处理：需要考虑异常处理机制，包括Bean创建异常、依赖注入异常等，可以考虑使用try-catch机制来处理异常。</li><li>配置文件加载：需要支持从不同的配置文件中加载Bean的相关信息，可以考虑使用XML、注解或者Java配置类来实现</li></ul><h3 id="AOP实现机制"><a href="#AOP实现机制" class="headerlink" title="AOP实现机制"></a>AOP实现机制</h3><p>Spring AOP的实现依赖于<strong>动态代理技术</strong>。动态代理是在运行时动态生成代理对象，而不是在编译时。它允许开发者在运行时指定要代理的接口和行为，从而实现在不修改源码的情况下增强方法的功能。</p><p>Spring AOP支持两种动态代理：</p><ul><li><strong>基于JDK的动态代理</strong>：使用java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口实现。这种方式需要代理的类实现一个或多个接口。</li><li><strong>基于CGLIB的动态代理</strong>：当被代理的类没有实现接口时，Spring会使用CGLIB库生成一个被代理类的子类作为代理。CGLIB（Code Generation Library）是一个第三方代码生成库，通过继承方式实现代理。</li></ul><p>Java的动态代理是一种在运行时动态创建代理对象的机制，主要用于在不修改原始类的情况下对方法调用进行拦截和增强。</p><p>Java动态代理主要分为两种类型：</p><ul><li><strong>基于接口的代理</strong>（JDK动态代理）： 这种类型的代理要求目标对象必须实现至少一个接口。Java动态代理会创建一个实现了相同接口的代理类，然后在运行时动态生成该类的实例。这种代理的实现核心是<code>java.lang.reflect.Proxy</code>类和<code>java.lang.reflect.InvocationHandler</code>接口。每一个动态代理类都必须实现<code>InvocationHandler</code>接口，并且每个代理类的实例都关联到一个<code>handler</code>。当通过代理对象调用一个方法时，这个方法的调用会被转发为由<code>InvocationHandler</code>接口的<code>invoke()</code>方法来进行调用。</li><li><strong>基于类的代理</strong>（CGLIB动态代理）： CGLIB（Code Generation Library）是一个强大的高性能的代码生成库，它可以在运行时动态生成一个目标类的子类。CGLIB代理不需要目标类实现接口，而是通过继承的方式创建代理类。因此，如果目标对象没有实现任何接口，可以使用CGLIB来创建动态代理。</li></ul><p>代理是一种常用的设计模式，目的是：为其他对象提供一个代理以控制对某个对象的访问，将两个类的关系解耦。代理类和委托类都要实现相同的接口，因为代理真正调用的是委托类的方法。</p><p>区别：</p><ul><li>静态代理：由程序员创建或者是由特定工具创建，在代码编译时就确定了被代理的类是一个静态代理。静态代理通常只代理一个类；</li><li>动态代理：在代码运行期间，运用反射机制动态创建生成。动态代理代理的是一个接口下的多个实现类。</li></ul><h3 id="如何解决循环依赖问题"><a href="#如何解决循环依赖问题" class="headerlink" title="如何解决循环依赖问题"></a>如何解决循环依赖问题</h3><p>循环依赖指的是两个类中的属性相互依赖对方：例如 A 类中有 B 属性，B 类中有 A属性，从而形成了一个依赖闭环</p><p>循环依赖问题在Spring中主要有三种情况：</p><ul><li>第一种：通过构造方法进行依赖注入时产生的循环依赖问题。</li><li>第二种：通过setter方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题。</li><li>第三种：通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题。</li></ul><p>只有第三种方式的循环依赖问题被 Spring 解决了，其他两种方式在遇到循环依赖问题时，Spring都会产生异常。</p><p>假设 Spring 尝试创建 Bean A：</p><ol><li>Spring 实例化 <code>BeanA</code> (调用构造器，此时 <code>BeanA</code> 的依赖 <code>beanB</code> 尚未设置)。</li><li>Spring 将<strong>一个 Bean A 的早期引用（一个 ObjectFactory）放入三级缓存</strong>。这个引用在将来可以暴露一个尚未完全初始化的 <code>BeanA</code> 实例。</li><li>Spring 尝试填充 <code>BeanA</code> 的属性，发现它需要 <code>BeanB</code>。</li><li>Spring 开始创建 <code>BeanB</code>。</li><li>Spring 实例化 <code>BeanB</code>。</li><li>Spring 将一个 <code>BeanB</code> 的早期引用放入三级缓存。</li><li>Spring 尝试填充 <code>BeanB</code> 的属性，发现它需要 <code>BeanA</code>。</li><li>Spring 检查一级缓存（没有 <code>BeanA</code>），检查二级缓存（没有 <code>BeanA</code>）。</li><li>Spring 检查三级缓存，发现有 <code>BeanA</code> 的早期引用工厂。它通过这个工厂获取到<strong>一个尚未完全初始化（但已实例化）的 <code>BeanA</code> 实例</strong>。</li><li>Spring 将这个早期 <code>BeanA</code> 实例注入到 <code>BeanB</code> 中。此时 <code>BeanB</code> 可以继续完成初始化。</li><li><code>BeanB</code> 初始化完成后，被放入一级缓存。</li><li>Spring 回到 <code>BeanA</code> 的初始化过程，将完全初始化的 <code>BeanB</code> 实例注入到 <code>BeanA</code> 中。</li><li><code>BeanA</code> 初始化完成后，被放入一级缓存。</li></ol><p>通过三级缓存，Spring 能够在 Bean 被完全初始化之前，就将其<strong>“半成品”的引用</strong>暴露给其他 Bean，从而打破了循环。</p><p><strong>注意事项：</strong></p><ul><li>这种解决方案<strong>只适用于单例 (Singleton)</strong> 作用域的 Bean。</li><li>它<strong>不适用于原型 (Prototype)</strong> 作用域的 Bean，因为原型 Bean 每次获取都是新实例，无法缓存“半成品”状态。</li><li>它<strong>不适用于构造器注入</strong>，因为构造器是在 Bean 实例创建时就要求所有依赖必须到位，而此时没有“半成品”可供缓存</li></ul><h2 id="动态代理与静态代理"><a href="#动态代理与静态代理" class="headerlink" title="动态代理与静态代理"></a>动态代理与静态代理</h2><p>动态代理是一种在<strong>运行时动态生成代理对象，并在代理对象中增强目标对象方法的技术</strong>。它被广泛用于 AOP（面向切面编程）、权限控制、日志记录等场景，使得程序更加灵活、可维护。动态代理可以通过 <strong>JDK 原生的 Proxy 机制或 CGLIB 方式</strong>实现。</p><p>Java动态代理主要分为两种类型：</p><ul><li><p><strong>基于接口的代理</strong>（JDK动态代理）： 这种类型的代理要求目标对象必须实现至少一个接口。Java动态代理会创建一个实现了相同接口的代理类，然后在运行时动态生成该类的实例。这种代理的实现核心是<code>java.lang.reflect.Proxy</code>类和<code>java.lang.reflect.InvocationHandler</code>接口。每一个动态代理类都必须实现<code>InvocationHandler</code>接口，并且每个代理类的实例都关联到一个<code>handler</code>。当通过代理对象调用一个方法时，这个方法的调用会被转发为由<code>InvocationHandler</code>接口的<code>invoke()</code>方法来进行调用。</p></li><li><p><strong>基于类的代理</strong>（CGLIB动态代理）： CGLIB（Code Generation Library）是一个强大的高性能的代码生成库，它可以在运行时动态生成一个目标类的子类。CGLIB代理不需要目标类实现接口，而是通过继承的方式创建代理类。因此，如果目标对象没有实现任何接口，可以使用CGLIB来创建动态代理.</p><p><strong>CGLIB</strong> 通过子类继承目标类，适用于没有实现接口的类，当使用 CGLIB 动态代理时，主要分为四步，</p><p>第一步是通过 Enhancer 创建代理对象。</p><p>第二步是设置父类，CGL IB 代理基于子类继承，因此代理对象是目标类的子类。</p><p>第三步是定义并实现 MethodInterceptor 接口，在 intercept 方法中增强目标方法。</p><p>第四步是调用代理方法，当调用代理对象的方法时，intercept 方法会被触发，执行增强逻辑，并最终调用目标方法. </p><p>可以通过配置强制 Spring 始终使用 CGLIB 代理，即使目标 Bean 实现了接口。这通常通过设置@EnableAspectJAutoProxy(proxyTargetClass = true)</p></li></ul><p><strong>动态代理和静态代理的区别</strong></p><p>代理是一种常用的设计模式，目的是：为其他对象提供一个代理以控制对某个对象的访问，将两个类的关系解耦。代理类和委托类都要实现相同的接口，因为代理真正调用的是委托类的方法。</p><p>区别：</p><ul><li>静态代理：由程序员创建或者是由特定工具创建，在代码编译时就确定了被代理的类是一个静态代理。静态代理通常只代理一个类；</li><li>动态代理：在代码运行期间，运用反射机制动态创建生成。动态代理代理的是一个接口下的多个实现类。</li></ul><h2 id="Spring的事务"><a href="#Spring的事务" class="headerlink" title="Spring的事务"></a>Spring的事务</h2><p><strong>事务的ACID特性：</strong></p><ul><li><strong>原子性 (Atomicity)：</strong> 事务是一个不可分割的工作单元，要么全部提交，要么全部回滚。</li><li><strong>一致性 (Consistency)：</strong> 事务完成后，数据必须处于一致状态，满足所有预设规则。</li><li><strong>隔离性 (Isolation)：</strong> 并发事务的执行互不干扰，一个事务的中间状态对其他事务不可见。</li><li><strong>持久性 (Durability)：</strong> 事务提交后，对数据的修改是永久性的，即使系统故障也不会丢失。</li></ul><h3 id="Spring事务实现"><a href="#Spring事务实现" class="headerlink" title="Spring事务实现"></a>Spring事务实现</h3><p>Spring 定义了 <code>PlatformTransactionManager</code> 接口，它是 Spring 事务策略的核心。不同的数据访问技术有不同的实现类：</p><ul><li><strong><code>DataSourceTransactionManager</code>：</strong> 用于纯 JDBC 或 MyBatis。</li><li><strong><code>JpaTransactionManager</code>：</strong> 用于 JPA。</li><li><strong><code>HibernateTransactionManager</code>：</strong> 用于 Hibernate (已过时，通常用 <code>JpaTransactionManager</code> 配合 Hibernate)。</li><li><p><strong><code>JtaTransactionManager</code>：</strong> 用于分布式事务，通过 JTA (Java Transaction API) 实现。</p></li><li><p>这个管理器负责与底层事务资源（如数据库连接）进行交互，执行事务的提交、回滚等操作。</p></li></ul><p><strong>事务同步管理器 (TransactionSynchronizationManager)：</strong></p><ul><li>这是一个内部类，Spring 用它来管理线程本地（ThreadLocal）的事务上下文，确保同一个线程中的所有操作都在同一个事务中执行</li></ul><p>Spring 事务本身不实现事务。它是一个高级的、声明式的事务管理框架，它通过其事务管理器 (<code>PlatformTransactionManager</code> 的不同实现) 来委托和协调底层数据访问技术（如 JDBC、JPA）和数据库（DBMS）来执行真正的事务操作。</p><p>Spring 的 <code>PlatformTransactionManager</code> 实现类就是连接 Spring 事务抽象和底层数据库事务的<strong>桥梁</strong>。例如,DataSourceTransactionManager<strong>： 当你的应用使用纯 JDBC 或 MyBatis 时，你会配置 <code>DataSourceTransactionManager</code>。这个管理器会通过 Java 的 </strong>JDBC API 来与数据库进行事务操作。</p><h3 id="事务传播行为与隔离级别"><a href="#事务传播行为与隔离级别" class="headerlink" title="事务传播行为与隔离级别"></a>事务传播行为与隔离级别</h3><p><code>@Transactional</code> 注解提供了丰富的属性来控制事务行为：</p><ol><li><strong><code>propagation</code> (事务传播行为)：</strong> 定义<strong>事务方法如何加入到现有事务中</strong>。<ul><li><strong><code>REQUIRED</code> (默认)：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新事务。</li><li><strong><code>SUPPORTS</code>：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行。</li><li><strong><code>MANDATORY</code>：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li><li><strong><code>REQUIRES_NEW</code>：</strong> 总是创建一个新事务，并挂起当前存在的事务（如果存在）。</li><li><strong><code>NOT_SUPPORTED</code>：</strong> 以非事务方式执行操作，并挂起当前存在的事务（如果存在）。</li><li><strong><code>NEVER</code>：</strong> 以非事务方式执行操作；如果当前存在事务，则抛出异常。</li><li><strong><code>NESTED</code>：</strong> 如果当前存在事务，则在嵌套事务中执行。如果当前没有事务，则行为与 <code>REQUIRED</code> 类似。嵌套事务（例如 JDBC savepoints）可以在外部事务回滚时回滚到保存点，但不能独立提交。</li></ul></li><li><strong><code>isolation</code> (事务隔离级别)：</strong> 定义多个事务并发执行时，一个事务对另一个事务的影响程度。<ul><li><strong><code>DEFAULT</code> (默认)：</strong> 使用底层数据库的默认隔离级别。</li><li><strong><code>READ_UNCOMMITTED</code> (读未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据。可能导致脏读、不可重复读和幻读。</li><li><strong><code>READ_COMMITTED</code> (读已提交)：</strong> 只能读取已提交的数据。避免脏读，但可能出现不可重复读和幻读。</li><li><strong><code>REPEATABLE_READ</code> (可重复读)：</strong> 保证在同一个事务中多次读取同一数据时，结果总是一致的。避免脏读和不可重复读，但可能出现幻读。</li><li><strong><code>SERIALIZABLE</code> (串行化)：</strong> 最高的隔离级别，完全隔离所有并发事务。避免脏读、不可重复读和幻读，但并发性能最低。</li></ul></li><li><strong><code>readOnly</code> (只读事务)：</strong><ul><li><code>true</code>：表示该事务只进行读取操作，不修改数据。优化数据库性能（数据库可能会进行一些优化，如不加锁）。</li><li><code>false</code> (默认)：读写事务。</li></ul></li><li><strong><code>timeout</code> (事务超时)：</strong><ul><li>定义事务在强制回滚之前可以运行的最大秒数。</li><li>默认值为 -1，表示不超时。</li></ul></li><li><strong><code>rollbackFor</code> / <code>rollbackForClassName</code>：</strong><ul><li>指定哪些异常类型会导致事务回滚。</li><li>默认情况下，只有运行时异常 (<code>RuntimeException</code>) 及其子类会导致事务回滚，检查型异常 (<code>Checked Exception</code>) 不会。</li></ul></li><li><strong><code>noRollbackFor</code> / <code>noRollbackForClassName</code>：</strong><ul><li>指定哪些异常类型不会导致事务回滚。</li></ul></li></ol><h3 id="事务失效场景"><a href="#事务失效场景" class="headerlink" title="事务失效场景"></a>事务失效场景</h3><p>Spring Boot通过Spring框架的事务管理模块来支持事务操作。事务管理在Spring Boot中通常是通过 @Transactional 注解来实现的。事务可能会失效的一些常见情况包括:</p><ol><li><strong>未捕获异常</strong>: 如果一个事务方法中发生了未捕获的异常，并且异常未被处理或传播到事务边界之外，那么事务会失效，所有的数据库操作会回滚。</li><li><strong>非受检异常</strong>: 默认情况下，Spring对非受检异常（RuntimeException或其子类）进行回滚处理，这意味着当事务方法中抛出这些异常时，事务会回滚。</li><li><strong>事务传播属性设置不当</strong>: 如果在多个事务之间存在事务嵌套，且事务传播属性配置不正确，可能导致事务失效。特别是在方法内部调用有 @Transactional 注解的方法时要特别注意。</li><li><strong>多数据源的事务管理</strong>: 如果在使用多数据源时，事务管理没有正确配置或者存在多个 @Transactional 注解时，可能会导致事务失效。</li><li><strong>跨方法调用事务问题</strong>: 如果一个事务方法内部调用另一个方法，而这个被调用的方法没有 @Transactional 注解，这种情况下外层事务可能会失效。</li><li><strong>事务在非公开方法中失效</strong>: 如果 @Transactional 注解标注在私有方法上或者非 public 方法上，事务也会失效。</li></ol><p>具体来说:</p><p>即使使用了 <code>@Transactional</code> 注解，事务也可能因为一些常见的原因而失效：</p><ol><li><strong><code>@Transactional</code> 注解在非 public 方法上：</strong><ul><li>Spring AOP 默认是基于 JDK 动态代理或 CGLIB 代理来实现的，它只对 <code>public</code> 方法有效。如果你在 <code>private</code> 或 <code>protected</code> 方法上加 <code>@Transactional</code>，事务将不会生效。</li></ul></li><li><strong>同一个类中方法互调 (Self-invocation)：</strong><ul><li>如果一个 <code>@Transactional</code> 方法被同一个 Bean 内部的另一个方法调用，而该调用没有经过 Spring 代理，事务也不会生效。</li><li><strong>解决方案：</strong><ul><li>将调用逻辑拆分到另一个服务 Bean 中。</li><li>通过 Spring AOP 的 <code>AopContext.currentProxy()</code> 获取当前代理对象进行调用（需要暴露代理）。</li><li>注入自身 Bean（如上例中的 <code>self</code>）。</li></ul></li></ul></li><li><strong>异常被捕获但未抛出或未标记回滚：</strong><ul><li>如果事务方法内部抛出了一个异常，但你将其 <code>try-catch</code> 捕获了，并且没有重新抛出（或者抛出的不是 <code>RuntimeException</code> 且未配置 <code>rollbackFor</code>），Spring 就不会知道需要回滚事务。</li><li><strong>解决方案：</strong> 确保事务方法抛出 <code>RuntimeException</code> 或配置 <code>rollbackFor</code>。</li></ul></li><li><strong>数据库不支持事务：</strong><ul><li>例如，MySQL 的 MyISAM 存储引擎不支持事务，即使配置了事务，也不会生效。必须使用 InnoDB 等支持事务的存储引擎。</li></ul></li><li><strong>没有配置事务管理器：</strong><ul><li>Spring 需要 <code>PlatformTransactionManager</code> Bean 才能启用事务功能。</li><li><strong>解决方案：</strong> 确保你的配置类中有类似 <code>DataSourceTransactionManager</code> 的 Bean。</li></ul></li><li><strong><code>@Transactional</code> 注解所在的类没有被 Spring 管理：</strong><ul><li><code>@Transactional</code> 只能作用于 Spring 容器管理的 Bean。</li><li><strong>解决方案：</strong> 确保类上带有 <code>@Component</code>, <code>@Service</code>, <code>@Repository</code> 等 Spring 注解。</li></ul></li></ol><h3 id="事务方法的自调用与解决方法"><a href="#事务方法的自调用与解决方法" class="headerlink" title="事务方法的自调用与解决方法"></a>事务方法的自调用与解决方法</h3><p>Spring的事务，使用this调用是否生效？</p><p>不能生效。</p><p>因为Spring事务是通过代理对象来控制的，只有通过代理对象的方法调用才会应用事务管理的相关规则。当使用<code>this</code>直接调用时，是绕过了Spring的代理机制，因此不会应用事务设置。</p><p>解决方法:</p><ol><li>将调用逻辑拆分到另一个服务 Bean 中。</li><li>通过 Spring AOP 的 <code>AopContext.currentProxy()</code> 获取当前代理对象进行调用（需要暴露代理@EnableAspectJAutoProxy(exposeProxy = true)）。</li><li>注入自身 Bean（如上例中的 <code>self</code>）。</li></ol><h2 id="SpringMVC的handlermapping和handleradapter"><a href="#SpringMVC的handlermapping和handleradapter" class="headerlink" title="SpringMVC的handlermapping和handleradapter"></a>SpringMVC的handlermapping和handleradapter</h2><p>Spring MVC的工作流程如下：</p><ol><li>用户发送请求至前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求调用处理器映射器HandlerMapping。</li><li>处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。</li><li>DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作</li><li>执行处理器Handler(Controller，也叫页面控制器)。</li><li>Handler执行完成返回ModelAndView</li><li>HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li><li>ViewReslover解析后返回具体View</li><li>DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）。</li><li>DispatcherServlet响应用户。</li></ol><p>HandlerMapping：</p><ul><li><strong>作用</strong>：HandlerMapping负责将请求映射到处理器（Controller）。</li><li><strong>功能</strong>：根据请求的URL、请求参数等信息，找到处理请求的 Controller。</li><li><strong>类型</strong>：Spring提供了多种HandlerMapping实现，如BeanNameUrlHandlerMapping、RequestMappingHandlerMapping等。</li><li><strong>工作流程</strong>：根据请求信息确定要请求的处理器(Controller)。HandlerMapping可以根据URL、请求参数等规则确定对应的处理器。</li></ul><p>HandlerAdapter：</p><ul><li><strong>作用</strong>：HandlerAdapter负责调用处理器(Controller)来处理请求。</li><li><strong>功能</strong>：处理器(Controller)可能有不同的接口类型（Controller接口、HttpRequestHandler接口等），HandlerAdapter根据处理器的类型来选择合适的方法来调用处理器。</li><li><strong>类型</strong>：Spring提供了多个HandlerAdapter实现，用于适配不同类型的处理器。</li><li><strong>工作流程</strong>：根据处理器的接口类型，选择相应的HandlerAdapter来调用处理器。</li></ul><p>工作流程：</p><ol><li>当客户端发送请求时，HandlerMapping根据请求信息找到对应的处理器(Controller)。</li><li>HandlerAdapter根据处理器的类型选择合适的方法来调用处理器。</li><li>处理器执行相应的业务逻辑，生成ModelAndView。</li><li>HandlerAdapter将处理器的执行结果包装成ModelAndView。</li><li>视图解析器根据ModelAndView找到对应的视图进行渲染。</li><li>将渲染后的视图返回给客户端。</li></ol><h1 id="Bean的生命周期与作用域"><a href="#Bean的生命周期与作用域" class="headerlink" title="Bean的生命周期与作用域"></a>Bean的生命周期与作用域</h1><p>一个 Bean 的完整生命周期大致可以分为以下几个主要阶段：</p><ol><li><strong>实例化 (Instantiation)</strong></li></ol><p>Spring IoC 容器根据 Bean 定义（如 XML 配置、Java Config 或组件扫描）找到对应的 Bean 类，并使用其<strong>构造函数</strong>创建 Bean 的一个实例。此时，实例仅仅是一个“裸对象”，其内部的依赖属性尚未被填充。</p><ol><li><p><strong>属性填充 (Populating Properties)</strong></p><p>在 Bean 实例被创建之后，Spring 容器会根据 Bean 定义中声明的依赖关系，对 Bean 的属性进行填充。这包括通过 Setter 方法注入依赖（Setter 注入）或通过反射直接设置字段（属性注入）。</p></li><li><p><strong>初始化 (Initialization)</strong></p></li></ol><p>在所有属性都被填充后，Bean 可能需要执行一些初始化逻辑（如打开文件、建立数据库连接、加载配置等）。Spring 提供了多种方式来定义初始化方法。</p><ol><li><strong>使用中 (In Use)</strong></li></ol><p>Bean 已经被完全初始化并准备就绪，可以从容器中获取并用于业务逻辑。这是 Bean 生命周期中最长的阶段。</p><ol><li><strong>销毁 (Destruction)</strong></li></ol><p>当容器关闭时（例如，Web 应用停止，或者 <code>ApplicationContext</code> 手动关闭），单例 Bean 会被销毁，以释放资源。</p><h2 id="生命期介入的扩展方法"><a href="#生命期介入的扩展方法" class="headerlink" title="生命期介入的扩展方法"></a>生命期介入的扩展方法</h2><p>经常在初始化阶段通过注解、实现接口或者xml实现某些逻辑.</p><p>例如在初始化阶段</p><p><strong>你可以介入的扩展点（按执行顺序）：</strong></p><ul><li><strong><code>BeanNameAware</code> 接口：</strong><ul><li><code>setBeanName(String name)</code>：如果 Bean 实现了此接口，Spring 会将 Bean 的 ID 或名称传递给它。</li></ul></li><li><strong><code>BeanFactoryAware</code> 接口：</strong><ul><li><code>setBeanFactory(BeanFactory beanFactory)</code>：如果 Bean 实现了此接口，Spring 会将创建它的 <code>BeanFactory</code> 实例传递给它。</li></ul></li><li><strong><code>ApplicationContextAware</code> 接口 (如果是 ApplicationContext 容器)：</strong><ul><li><code>setApplicationContext(ApplicationContext applicationContext)</code>：如果 Bean 实现了此接口，Spring 会将创建它的 <code>ApplicationContext</code> 实例传递给它。</li></ul></li><li><strong><code>BeanPostProcessor</code> (前置处理)：</strong><ul><li><code>postProcessBeforeInitialization(Object bean, String beanName)</code>：在任何初始化回调（如 <code>@PostConstruct</code> 或 <code>InitializingBean.afterPropertiesSet</code>）<strong>之前</strong>调用。</li></ul></li><li><strong><code>@PostConstruct</code> 注解：</strong><ul><li>被 <code>@PostConstruct</code> 标记的方法会在依赖注入完成后、所有初始化回调方法之前自动调用。这是最常用的初始化方式。</li></ul></li><li><strong><code>InitializingBean</code> 接口：</strong><ul><li><code>afterPropertiesSet()</code>：如果 Bean 实现了此接口，在所有属性设置完成之后，此方法会被调用。</li></ul></li><li><strong>自定义 <code>init-method</code>：</strong><ul><li>在 Bean 定义中指定一个初始化方法名（如 <code>@Bean(initMethod = &quot;myInitMethod&quot;)</code> 或 XML 中的 <code>init-method=&quot;myInitMethod&quot;</code>）。</li></ul></li><li><strong><code>BeanPostProcessor</code> (后置处理)：</strong><ul><li><code>postProcessAfterInitialization(Object bean, String beanName)</code>：在所有初始化回调（如 <code>@PostConstruct</code>、<code>afterPropertiesSet</code>、<code>init-method</code>）<strong>之后</strong>调用。<strong>AOP 代理通常是在这个阶段创建的。</strong>这意味着如果你在这个方法中获取 Bean 的引用，你将得到的是代理对象。</li></ul></li></ul><p>而在销毁阶段,</p><p><strong><code>@PreDestroy</code> 注解：</strong></p><ul><li>被 <code>@PreDestroy</code> 标记的方法会在 Bean 销毁之前自动调用。常用于资源清理（如关闭数据库连接、文件句柄等）。</li></ul><p><strong><code>DisposableBean</code> 接口：</strong></p><ul><li><code>destroy()</code>：如果 Bean 实现了此接口，在容器关闭时，此方法会被调用。</li></ul><p><strong>自定义 <code>destroy-method</code>：</strong></p><ul><li>在 Bean 定义中指定一个销毁方法名（如 <code>@Bean(destroyMethod = &quot;myDestroyMethod&quot;)</code> 或 XML 中的 <code>destroy-method=&quot;myDestroyMethod&quot;</code>）。</li></ul><p>Spring框架中的Bean作用域（Scope）定义了Bean的生命周期和可见性。不同的作用域影响着Spring容器如何管理这些Bean的实例，包括它们如何被创建、如何被销毁以及它们是否可以被多个用户共享。</p><p>Spring支持几种不同的作用域，以满足不同的应用场景需求。以下是一些主要的Bean作用域：</p><ul><li><strong>Singleton（单例）</strong>：在整个应用程序中只存在一个 Bean 实例。默认作用域，Spring 容器中只会创建一个 Bean 实例，并在容器的整个生命周期中共享该实例。</li><li><strong>Prototype（原型）</strong>：每次请求时都会创建一个新的 Bean 实例。次从容器中获取该 Bean 时都会创建一个新实例，适用于状态非常瞬时的 Bean。</li><li><strong>Request（请求）</strong>：每个 HTTP 请求都会创建一个新的 Bean 实例。仅在 Spring Web 应用程序中有效，每个 HTTP 请求都会创建一个新的 Bean 实例，适用于 Web 应用中需求局部性的 Bean。</li><li><strong>Session（会话）</strong>：Session 范围内只会创建一个 Bean 实例。该 Bean 实例在用户会话范围内共享，仅在 Spring Web 应用程序中有效，适用于与用户会话相关的 Bean。</li><li><strong>Application</strong>：当前 ServletContext 中只存在一个 Bean 实例。仅在 Spring Web 应用程序中有效，该 Bean 实例在整个 ServletContext 范围内共享，适用于应用程序范围内共享的 Bean。</li><li><strong>WebSocket（Web套接字）</strong>：在 WebSocket 范围内只存在一个 Bean 实例。仅在支持 WebSocket 的应用程序中有效，该 Bean 实例在 WebSocket 会话范围内共享，适用于 WebSocket 会话范围内共享的 Bean。</li><li><strong>Custom scopes（自定义作用域）</strong>：Spring 允许开发者定义自定义的作用域，通过实现 Scope 接口来创建新的 Bean 作用域。</li></ul><h3 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h3><p><strong>Spring 中的 Bean 默认都是单例的。就是说，每个Bean的实例只会被创建一次，并且会被存储在Spring容器的缓存中，以便在后续的请求中重复使用</strong>。这种单例模式可以提高应用程序的性能和内存效率。</p><p>但是，Spring也支持将Bean设置为多例模式，即每次请求都会创建一个新的Bean实例。要将Bean设置为多例模式，可以在Bean定义中通过设置scope属性为”prototype”来实现。</p><p>需要注意的是，虽然Spring的默认行为是将Bean设置为单例模式，但在一些情况下，使用多例模式是更为合适的，例如在创建状态不可变的Bean或有状态Bean时。此外，需要注意的是，如果Bean单例是有状态的，那么在使用时需要考虑线程安全性问题</p><p>作用域为单例和非单例的bean的声明周期</p><p>Spring Bean 的生命周期完全由 IoC 容器控制。Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 <code>prototype</code> 的 Bean，Spring 在创建好交给使用者之后，则不会再管理后续的生命周期。</p><p>具体区别如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>阶段</strong></th><th style="text-align:left"><strong>单例（Singleton）</strong></th><th style="text-align:left"><strong>非单例（如Prototype）</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>创建时机</strong></td><td style="text-align:left">容器启动时创建（或首次请求时，取决于配置）。</td><td style="text-align:left">每次请求时创建新实例。</td></tr><tr><td style="text-align:left"><strong>初始化流程</strong></td><td style="text-align:left">完整执行生命周期流程（属性注入、Aware接口、初始化方法等）。</td><td style="text-align:left">每次创建新实例时都会完整执行生命周期流程（仅到初始化完成）。</td></tr><tr><td style="text-align:left"><strong>销毁时机</strong></td><td style="text-align:left">容器关闭时销毁，触发<code>DisposableBean</code>或<code>destroy-method</code>。</td><td style="text-align:left"><strong>容器不管理销毁</strong>，需由调用者自行释放资源（Spring不跟踪实例）。</td></tr><tr><td style="text-align:left"><strong>内存占用</strong></td><td style="text-align:left">单实例常驻内存，高效但需注意线程安全。</td><td style="text-align:left">每次请求生成新实例，内存开销较大，需手动管理资源释放。</td></tr><tr><td style="text-align:left"><strong>适用场景</strong></td><td style="text-align:left">无状态服务（如Service、DAO层）。</td><td style="text-align:left">有状态对象（如用户会话、临时计算对象）。</td></tr></tbody></table></div><h2 id="Bean是线程安全的吗"><a href="#Bean是线程安全的吗" class="headerlink" title="Bean是线程安全的吗"></a>Bean是线程安全的吗</h2><p>Spring 框架中的 Bean 是否具备线程安全性，主要取决于它的作用域以及是否包含可变状态。</p><p>Bean 线程安全性的影响因素</p><p>Spring 默认的 Bean 作用域是 singleton，即在 IoC 容器中只会创建一个实例，并被多个线程共享。如果这个 Bean 维护了可变的成员变量，就可能在并发访问时引发数据不一致的问题，从而导致线程安全风险。</p><p>而 prototype 作用域 下，每次获取 Bean 都会创建新的实例，因此不会发生资源竞争，自然也就没有线程安全问题。</p><p>单例 Bean 是否一定不安全？</p><p>不一定！</p><p>无状态 Bean 是线程安全的：例如常见的 Service 或 Dao 层 Bean，它们通常不存储可变数据，仅执行业务逻辑，因此不会受到并发影响。</p><p>有状态 Bean 可能会引发线程安全问题：如果 Bean 存储了可变成员变量，比如用户会话信息、计数器等，可能会因多个线程同时访问导致数据不一致。</p><p>解决有状态 Bean 的线程安全问题</p><p>如果一个单例 Bean 需要维护状态，可通过以下方式确保线程安全：</p><p>设计为无状态 Bean：尽量避免定义可变成员变量，或在方法内部使用局部变量。</p><p>使用 ThreadLocal：让每个线程拥有独立的变量副本，防止数据共享导致冲突。</p><p>同步控制：在访问共享资源时，使用 synchronized 或 ReentrantLock 进行加锁，确保线程互斥访问。</p><p>Spring Bean 默认<strong>不是线程安全的</strong>，因为它们是单例的，所有线程共享同一个实例。要确保 Bean 的线程安全，你需要：</p><ul><li><strong>优先设计无状态的 Bean。</strong></li><li><strong>在 Bean 内部使用局部变量。</strong></li><li><strong>使用线程安全的集合。</strong></li><li><strong>应用适当的同步机制。</strong></li><li><strong>考虑使用 <code>ThreadLocal</code>。</strong></li><li><strong>或者，更改 Bean 的作用域为 <code>prototype</code>（但要理解其语义）。</strong></li></ul><h2 id="Spring的其他扩展方法"><a href="#Spring的其他扩展方法" class="headerlink" title="Spring的其他扩展方法"></a>Spring的其他扩展方法</h2><p>Spring框架提供了许多扩展点，使得开发者可以根据需求定制和扩展Spring的功能。以下是一些常用的扩展点：</p><ol><li>BeanFactoryPostProcessor：允许在Spring容器实例化bean之前修改bean的定义。常用于修改bean属性或改变bean的作用域。</li><li>BeanPostProcessor：可以在bean实例化、配置以及初始化之后对其进行额外处理。常用于代理bean、修改bean属性等。</li><li>PropertySource：用于定义不同的属性源，如文件、数据库等，以便在Spring应用中使用。</li><li>ImportSelector和ImportBeanDefinitionRegistrar：用于根据条件动态注册bean定义，实现配置类的模块化。</li><li>Spring MVC中的<strong>HandlerInterceptor</strong>：<strong>用于拦截处理请求，可以在请求处理前、处理中和处理后执行特定逻辑</strong>。</li><li>Spring MVC中的<strong>ControllerAdvice</strong>：用于<strong>全局处理控制器的异常、数据绑定和数据校验</strong>。</li><li>Spring Boot的自动配置：通过创建自定义的自动配置类，可以实现对框架和第三方库的自动配置。</li><li>自定义注解：创建自定义注解，用于实现特定功能或约定，如权限控制、日志记录等。</li></ol><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><ul><li>Spring Boot 提供了自动化配置，大大简化了项目的配置过程。<strong>通过约定优于配置的原则，很多常用的配置可以自动完成</strong>，开发者可以专注于业务逻辑的实现。</li><li>Spring Boot 提供了<strong>快速的项目启动器，通过引入不同的 Starter</strong>，可以快速集成常用的框架和库（如数据库、消息队列、Web 开发等），极大地提高了开发效率。</li><li>Spring Boot 默认<strong>集成了多种内嵌服务器</strong>（如Tomcat、Jetty、Undertow），无需额外配置，即可将应用打包成可执行的 JAR 文件，方便部署和运行</li></ul><h3 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h3><p>自动装配就是 Spring Boot 根据你项目中引入的 <strong>Maven/Gradle 依赖（JAR 包）</strong>，自动判断你可能需要哪些 Bean，并替你<strong>自动创建和配置这些 Bean</strong>，把它们注册到 Spring IoC 容器中</p><p>SpringBoot 的自动装配原理是基于Spring Framework的条件化配置和@EnableAutoConfiguration注解实现的。<strong>这种机制允许开发者在项目中引入相关的依赖，SpringBoot 将根据这些依赖自动配置应用程序的上下文和功能</strong>。</p><p>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的META-INF/spring.factories文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</p><p>通俗来讲，自动装配就是<strong>通过注解或一些简单的配置就可以在SpringBoot的帮助下开启和配置各种功能</strong>，比如数据库访问、Web开发。</p><p><strong>自动装配的工作流程总结</strong></p><ol><li><strong>启动应用：</strong> 你的 Spring Boot 应用从 <code>main</code> 方法开始，运行 <code>SpringApplication.run()</code>。</li><li><strong>找到 <code>@SpringBootApplication</code>：</strong> <code>SpringApplication</code> 会扫描主启动类上的 <code>@SpringBootApplication</code> 注解。</li><li><strong>开启组件扫描：</strong> <code>@ComponentScan</code> 会扫描主启动类所在的包及其子包，发现并注册自定义的 Bean。</li><li><strong>开启自动装配：</strong> <code>@EnableAutoConfiguration</code> 激活自动装配机制。<ul><li>它通过 <code>AutoConfigurationImportSelector</code> 去扫描所有 classpath 下的 JAR 包。</li><li>查找每个 JAR 包中的 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件。</li><li>读取这些文件中列出的所有自动配置类。</li></ul></li><li><strong>按条件加载配置：</strong> 对每一个找到的自动配置类，Spring Boot 会根据其上的 <code>@Conditional</code> 注解家族进行<strong>条件判断</strong>。<ul><li>如果条件满足（例如，classpath 中有某个类，或者容器中没有某个 Bean），那么这个自动配置类就会被激活。</li><li>激活的自动配置类中的 <code>@Bean</code> 方法会被执行，从而创建和配置相关的 Bean，并注册到 Spring IoC 容器中。</li></ul></li><li><strong>完成启动：</strong> 至此，所有的自动配置和自定义 Bean 都已就绪，应用程序可以开始接收请求和执行业务逻辑。</li></ol><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><p>Spring Boot 中一些常用的注解包括：</p><ul><li><strong>@SpringBootApplication</strong>：用于标注主应用程序类，标识一个Spring Boot应用程序的入口点，同时启用自动配置和组件扫描。</li><li><strong>@Controller</strong>：标识控制器类，处理HTTP请求。</li><li><strong>@RestController</strong>：结合@Controller和@ResponseBody，返回RESTful风格的数据。</li><li><strong>@Service</strong>：标识服务类，通常用于标记业务逻辑层。</li><li><strong>@Repository</strong>：标识数据访问组件，通常用于标记数据访问层。</li><li><strong>@Component</strong>：通用的Spring组件注解，表示一个受Spring管理的组件。</li><li><strong>@Autowired</strong>：用于自动装配Spring Bean。</li><li><strong>@Value</strong>：用于注入配置属性值。</li><li><strong>@RequestMapping</strong>：用于映射HTTP请求路径到Controller的处理方法。</li><li><strong>@GetMapping</strong>、@PostMapping、@PutMapping、@DeleteMapping：简化@RequestMapping的GET、POST、PUT和DELETE请求。</li></ul><p>另外，一个与配置相关的重要注解是：</p><ul><li><strong>@Configuration</strong>：用于指定一个类为配置类，其中定义的bean会被Spring容器管理。通常与@Bean配合使用，@Bean用于声明一个Bean实例，由Spring容器进行管理</li></ul><h1 id="微服务与SpringCloud"><a href="#微服务与SpringCloud" class="headerlink" title="微服务与SpringCloud"></a>微服务与SpringCloud</h1><p><strong>分布式系统</strong>是一个广泛的概念，它指的是将一个大型软件系统拆分成<strong>多个独立的组件</strong>，这些组件部署在<strong>不同的计算机（节点）上</strong>，并通过<strong>网络</strong>进行通信和协作，共同完成一个目标。</p><p><strong>核心特征：</strong></p><ul><li><strong>多节点：</strong> 系统由多台独立的计算机组成。</li><li><strong>网络通信：</strong> 节点之间通过网络（如 TCP/IP）进行消息传递。</li><li><strong>协作完成任务：</strong> 各个节点协同工作，共同提供一个整体服务或功能。</li><li><strong>透明性（理想目标）：</strong> 用户和客户端在理想情况下感觉不到系统是由多个独立部分组成的。</li></ul><p><strong>微服务</strong>是一种<strong>架构风格（Architectural Style）</strong>，它是分布式系统的一种具体实现方式。微服务将一个单一的应用程序拆分成<strong>一组小型、独立、松耦合的服务</strong>。每个服务都运行在自己的进程中，并围绕着特定的业务功能进行构建，通过轻量级机制（通常是 HTTP API）进行通信。</p><p><strong>核心特征：</strong></p><ul><li><strong>服务独立性：</strong> 每个微服务都是一个独立的、可部署的单元。</li><li><strong>围绕业务能力构建：</strong> 服务边界清晰，专注于解决一个具体的业务问题。</li><li><strong>松耦合：</strong> 服务之间依赖性低，一个服务的变更通常不会直接影响其他服务。</li><li><strong>独立部署：</strong> 各个服务可以独立开发、独立部署、独立扩展。</li><li><strong>技术异构性：</strong> 不同微服务可以使用不同的编程语言、数据库和技术栈。</li><li><strong>去中心化治理：</strong> 服务团队拥有自治权，可以自主选择技术栈和开发流程。</li></ul><p>Spring Boot是用于<strong>构建单个Spring应用的框架</strong>，而Spring Cloud则是用于<strong>构建分布式系统中的微服务架构的工具</strong>，<strong>Spring Cloud提供了服务注册与发现、负载均衡、断路器、网关等功能</strong>。</p><p>两者可以结合使用，通过Spring Boot构建微服务应用，然后用Spring Cloud来实现微服务架构中的各种功能。</p><h3 id="微服务组件"><a href="#微服务组件" class="headerlink" title="微服务组件"></a>微服务组件</h3><p><img data-src="https://cdn.xiaolincoding.com//picgo/1715933382453-968d55a3-059b-423d-9f67-0ebf732fc400.png" alt="img" style="zoom: 67%;" /></p><p><strong>注册中心</strong>, 微服务框架核心组件,作用是对新节点进行注册以及状态维护,解决了”<strong>如何发现新节点以及检查各节点的运行状态的问题</strong>“.  <strong>微服务节点在启动时将自己服务的ip,端口等信息在服务中心登记</strong>,注册中心会定时检查该节点的运行状态. 注册中心通常会采用<strong>心跳机制最大程度保证已登记过的服务节点都是可用的</strong>。</p><p><strong>负载均衡</strong>,负载均衡<strong>解决了如何发现服务及负载均衡如何实现的问题」</strong>，通常微服务在互相调用时，并不是直接通过IP、端口进行访问调用。<strong>而是先通过服务名在注册中心查询该服务拥有哪些节点，注册中心将该服务可用节点列表返回给服务调用者，这个过程叫服务发现</strong>，因服务高可用的要求，<strong>服务调用者会接收到多个节点，必须要从中进行选择。因此服务调用者一端必须内置负载均衡器，通过负载均衡策略选择合适的节点</strong>发起实质性的通信请求。</p><p><strong>服务通信</strong>,服务通信组件解决了<strong>服务间如何进行消息通信的问题</strong>，服务间通信采用轻量级协议，通常是HTTP RESTful风格。但因为RESTful风格过于灵活，必须加以约束，通常应用时对其封装。例如在SpringCloud中就提供了Feign和RestTemplate两种技术屏蔽底层的实现细节，所有开发者都是基于封装后统一的SDK进行开发，有利于团队间的相互合作。</p><p><strong>配置中心</strong>：配置中心主要解决了<strong>如何集中管理各节点配置文件的问题</strong>，在微服务架构下，所有的微服务节点都包含自己的各种配置文件，如jdbc配置、自定义配置、环境配置、运行参数配置等。要知道有的微服务可能可能有几十个节点，如果将这些配置文件分散存储在节点上，发生配置更改就需要逐个节点调整，将给运维人员带来巨大的压力。配置中心便由此而生，通过部署配置中心服务器，将各节点配置文件从服务中剥离，集中转存到配置中心。一般配置中心都有UI界面，方便实现大规模集群配置调整。</p><p><strong>集中式日志管理</strong>：集中式日志主要是解决了<strong>如何收集各节点日志并统一管理的问题</strong>。微服务架构默认将应用日志分别保存在部署节点上，当需要对日志数据和操作数据进行数据分析和数据统计时，必须收集所有节点的日志数据。那么怎么高效收集所有节点的日志数据呢？业内常见的方案有ELK、EFK。通过搭建独立的日志收集系统，定时抓取各节点增量日志形成有效的统计报表，为统计和分析提供数据支撑。</p><p><strong>分布式链路追踪</strong>：分布式链路追踪解决了<strong>如何直观的了解各节点间的调用链路的问题</strong>。系统中一个复杂的业务流程，可能会出现连续调用多个微服务，我们需要了解完整的业务逻辑涉及的每个微服务的运行状态，通过可视化链路图展现，可以帮助开发人员快速分析系统瓶颈及出错的服务。</p><p><strong>服务保护</strong>：服务保护主要是解决了<strong>如何对系统进行链路保护，避免服务雪崩的问题</strong>。在业务运行时，微服务间互相调用支撑，如果某个微服务出现高延迟导致线程池满载，或是业务处理失败。这里就需要引入服务保护组件来实现高延迟服务的快速降级，避免系统崩溃。</p><p><img data-src="https://cdn.xiaolincoding.com//picgo/1715933831252-4dbe4ae0-8072-4512-b54b-39ea5e8b3153.png" alt="img" style="zoom:67%;" /></p><ul><li>SpringCloud Alibaba中使用<strong>Alibaba Nacos</strong>组件实现<strong>注册中心</strong>，Nacos提供了一组简单易用的特性集，可快速实现动态服务发现、服务配置、服务元数据及流量管理。</li><li>SpringCloud Alibaba 使用<strong>Nacos服务端均衡</strong>实现负载均衡，与Ribbon在调用端负载不同，Nacos是在服务发现的同时利用负载均衡返回服务节点数据。</li><li>SpringCloud Alibaba 使用<strong>Netflix Feign</strong>和<strong>Alibaba Dubbo</strong>组件来实现服务通行，前者与SpringCloud采用了相同的方案，后者则是对自家的<strong>RPC 框架Dubbo</strong>也给予支持，为服务间通信提供另一种选择。</li><li>SpringCloud Alibaba 在<strong>API服务网关</strong>组件中，使用与SpringCloud相同的组件，即：<strong>SpringCloud Gateway</strong>。</li><li>SpringCloud Alibaba在配置中心组件中使用<strong>Nacos内置配置中心</strong>，Nacos内置的配置中心，可将配置信息<strong>存储保存在指定数据库</strong>中</li><li>SpringCloud Alibaba在原有的<strong>ELK方案</strong>外，还可以使用阿里云日志服务（LOG）实现日志集中式管理。</li><li>SpringCloud Alibaba在<strong>分布式链路组件</strong>中采用与SpringCloud相同的方案，即：<strong>Sleuth/Zipkin Server</strong>。</li><li>SpringCloud Alibaba使用<strong>Alibaba Sentinel</strong>实现系统保护，Sentinel不仅功能更强大，实现系统保护比Hystrix更优雅，而且还拥有更好的UI界面。</li></ul><h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><ul><li>简单轮询：将请求按顺序分发给后端服务器上，不关心服务器当前的状态，比如后端服务器的性能、当前的负载。</li><li>加权轮询：根据服务器自身的性能给服务器设置不同的权重，将请求按顺序和权重分发给后端服务器，可以让性能高的机器处理更多的请求</li><li>简单随机：将请求随机分发给后端服务器上，请求越多，各个服务器接收到的请求越平均</li><li>加权随机：根据服务器自身的性能给服务器设置不同的权重，将请求按各个服务器的权重随机分发给后端服务器</li><li>一致性哈希：根据请求的客户端 ip、或请求参数通过哈希算法得到一个数值，利用该数值取模映射出对应的后端服务器，这样能保证同一个客户端或相同参数的请求每次都使用同一台服务器</li><li>最小活跃数：统计每台服务器上当前正在处理的请求数，也就是请求活跃数，将请求分发给活跃数最少的后台服务器</li></ul><p>可以<strong>通过「一致性哈希算法」来实现一直均衡给一个用户，根据请求的客户端 ip、或请求参数通过哈希算法得到一个数值，利用该数值取模映射出对应的后端服务器</strong>，这样能保证同一个客户端或相同参数的请求每次都使用同一台服务器。</p><h3 id="服务熔断与服务降级"><a href="#服务熔断与服务降级" class="headerlink" title="服务熔断与服务降级"></a>服务熔断与服务降级</h3><p>服务熔断是应对微服务雪崩效应的一种<strong>链路保护机制，类似股市、保险丝</strong>。</p><p>比如说，微服务之间的数据交互是通过远程调用来完成的。服务A调用服务，服务B调用服务c，某一时间链路上对服务C的调用响应时间过长或者服务C不可用，随着时间的增长，对服务C的调用也越来越多，然后服务C崩溃了，但是链路调用还在，对服务B的调用也在持续增多，然后服务B崩溃，随之A也崩溃，导致雪崩效应。</p><p>服务熔断是应对雪崩效应的一种微服务链路保护机制。例如在高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。同样，在微服务架构中，熔断机制也是起着类似的作用<strong>。当调用链路的某个微服务不可用或者响应时间太长时，会进行服务熔断，不再有该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。</strong></p><p>所以，服务熔断的作用类似于我们家用的保险丝，当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用。</p><p>在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制</p><p>服务降级一般是指在服务器压力剧增的时候，根据实际业务使用情况以及流量，对一些服务和页面有策略的不处理或者用一种简单的方式进行处理，从而<strong>释放服务器资源的资源以保证核心业务的正常高效运行。</strong></p><p>服务器的资源是有限的，而请求是无限的。在用户使用即并发高峰期，会影响整体服务的性能，严重的话会导致宕机，以至于某些重要服务不可用。故高峰期为了保证核心功能服务的可用性，就需要对某些服务降级处理。可以理解为舍小保大</p><p>服务降级是从整个系统的负荷情况出发和考虑的，<strong>对某些负荷会比较高的情况，为了预防某些功能（业务场景）出现负荷过载或者响应慢的情况，在其内部暂时舍弃对一些非核心的接口和数据的请求</strong>，而直接返回一个提前准备好的fallback（退路）错误处理信息。这样，虽然提供的是一个有损的服务，但却保证了整个系统的稳定性和可用性。</p><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h3><p>CAP 原则又称 CAP 定理, 指的是在一个分布式系统中, Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）, <strong>三者不可得兼</strong></p><ul><li><p><strong>一致性(C) :</strong> 在分布式系统中的所有数据备份, 在同一时刻是否同样的值(等同于所有节点访问同一份最新的数据副本)</p><p><strong>所有客户端在任何时候看到的数据都是一致的</strong>。这意味着所有对数据的读操作都应该返回最新写入的数据，或者返回一个错误。在分布式环境中，这通常通过同步数据来实现。</p></li><li><p><strong>可用性(A):</strong> 在集群中一部分节点故障后, 集群整体是否还能响应客户端的读写请求(对数据更新具备高可用性).</p><p><strong>系统中的所有非故障节点都能在有限的时间内响应任何请求</strong>。这意味着系统总是能处理请求并返回一个（可能是旧的）结果，即使某些节点出现故障。</p></li><li><p><strong>分区容错性(P):</strong> 以实际效果而言, 分区相当于对通信的时限要求. 系统如果不能在时限内达成数据一致性, 就意味着发生了分区的情况, 必须就当前操作在 C 和 A 之间做出选择. </p><p>即使网络中出现任意数量的消息丢失或延迟，导致系统被分割成多个不相交的子系统（即“网络分区”），系统仍然能够继续运行。</p></li></ul><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式锁是用于分布式环境下并发控制的一种机制，用于控制某个资源在同一时刻只能被一个应用所使用</p><p>可以通过redis实现分布式锁,<code>set key  value nx ex threadId</code></p><p>Redis 本身可以被多个客户端共享访问，正好就是一个共享存储系统，可以用来实现分布式锁，而且 Redis 的读写性能高，可以应对高并发的锁操作场景。Redis 的 SET 命令有个 NX 参数可以实现「key不存在才插入」，所以可以用它来实现分布式锁：</p><ul><li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li><li><p>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</p></li><li><p>加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的方式完成，所以，我们使用 SET 命令带上 NX 选项来实现加锁；而Redis单挑指令的执行本身保证了原子性</p></li><li><strong>锁变量需要设置过期时间，以免客户端拿到锁后发生异常</strong>，导致锁一直无法释放，所以，我们在 SET 命令执行时加上 EX/PX 选项，设置其过期时间；</li><li><strong>锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作</strong>，所以，我们使用 SET 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端</li></ul><p><strong>Zookeeper实现分布式锁</strong></p><p>zookeeper是一个为分布式应用提供一致性服务的软件，它<strong>内部是一个分层的文件系统目录树结构</strong>，规定<strong>同一个目录下只能有一个唯一文件名</strong>。</p><p>它提供了一个<strong>分布式协调服务</strong>。可以把它想象成一个高可用的、高性能的、分布式的文件系统（或者说是一个<strong>树形结构的数据存储</strong>），但它专门为<strong>存储和管理分布式应用程序的配置信息、命名服务、提供分布式同步以及组服务</strong>而设计。</p><p>ZooKeeper 的设计目标是解决分布式系统中的各种协调问题，使得开发者无需从头开始构建复杂的分布式原语。它提供了一组简单的 API，让分布式应用能够在其上构建更高级的功能</p><p>ZooKeeper 实现分布式锁通常采用的是<strong>排他锁（Exclusive Lock或共享锁（Shared Lock）</strong>，其核心思想是利用 ZooKeeper 的<strong>临时顺序节点（Ephemeral Sequential ZNodes）</strong>和<strong>监视器</strong>特性。</p><p>数据模型：</p><ul><li>永久节点：节点创建后，不会因为会话失效而消失</li><li>临时节点：与永久节点相反，如果客户端连接失效，则立即删除节点</li><li>顺序节点：与上述两个节点特性类似，如果指定创建这类节点时，zk会自动在节点名后加一个数字后缀，并且是有序的。</li></ul><p>基本原理（排他锁）：</p><ol><li><strong>定义锁路径：</strong> 首先在 ZooKeeper 中定义一个持久的根节点，作为所有锁的父节点，例如 <code>/locks</code>。</li><li><strong>创建临时顺序节点：</strong> 当客户端 A 想要获取锁时，它会在 <code>/locks</code> 目录下创建一个临时的、顺序的子节点。例如，如果它是第一个创建的，可能得到 <code>/locks/lock-0000000001</code>。</li><li><strong>判断是否获得锁：</strong> 客户端 A 创建节点后，会获取 <code>/locks</code> 目录下所有子节点的列表，并检查自己创建的节点是否是所有子节点中序号最小的那个。<ul><li><strong>如果是：</strong> 客户端 A 成功获得了锁。</li><li><strong>如果不是：</strong> 客户端 A 并没有获得锁。它会找到比自己节点序号小一级的那个节点（也就是紧邻在它前面的那个节点），并在这个<strong>前一个节点上设置一个 Watch 监听器</strong>。</li></ul></li><li><strong>等待通知（Watch 机制）：</strong><ul><li>如果客户端 A 没有获得锁，它会进入等待状态。当它监听的前一个节点被删除时（这意味着持有该锁的客户端释放了锁或崩溃了），ZooKeeper 会通过 Watch 机制通知客户端 A。</li><li>客户端 A 收到通知后，会再次执行步骤 3：获取子节点列表，检查自己是否是最小的。如果是，则获得锁；否则，继续监听它前面新的节点。</li></ul></li><li><strong>释放锁：</strong> 当客户端 A 完成对共享资源的操作后，它会删除自己创建的那个临时节点（例如 <code>/locks/lock-0000000001</code>）。由于是临时节点，如果客户端 A 崩溃或会话断开，这个节点也会被自动删除，从而释放锁。</li></ol><p><strong>为什么使用临时顺序节点？</strong></p><ul><li><strong>排他性：</strong> 保证了在任何时刻，只有一个客户端持有的临时顺序节点是最小的，从而实现排他性。</li><li><strong>公平性（避免饥饿）：</strong> 由于是顺序节点，每个请求锁的客户端都会获得一个唯一的、递增的序号。客户端只需要关注紧邻它前面的那个节点，当那个节点被删除时，它就知道轮到自己了。这保证了所有请求锁的客户端都能按照请求的先后顺序获得锁，避免了饥饿现象。</li><li><strong>死锁避免：</strong> 临时节点的特性是防止死锁的关键。如果持有锁的客户端崩溃了，它的会话会过期，ZooKeeper 会自动删除它创建的临时节点，从而释放锁，避免了因客户端崩溃导致的死锁问题。</li><li><strong>高性能 Watch：</strong> 客户端只需要监听它前面一个节点的删除事件，而不是监听整个父节点的子节点列表变化。这样可以减少 Watch 的触发次数，提高性能。</li></ul><p><strong>共享锁的实现（读写锁）：</strong></p><p>共享锁的实现与排他锁类似，只是在判断是否获得锁的逻辑上有所不同：</p><ol><li><strong>创建临时顺序节点：</strong> 读锁和写锁请求都会在 <code>/locks</code> 目录下创建临时的顺序节点，例如 <code>/locks/read-000000000X</code> 或 <code>/locks/write-000000000Y</code>。</li><li><strong>判断是否获得锁：</strong><ul><li><strong>获取写锁（Write Lock）：</strong> 必须确保自己创建的节点是所有子节点中序号最小的。如果不是，则监听前面所有比自己序号小的节点（读锁或写锁）。</li><li><strong>获取读锁（Read Lock）：</strong> 必须确保在所有比自己节点序号小的节点中，<strong>没有写锁节点</strong>。如果存在写锁节点，则监听最靠近自己的写锁节点。如果没有写锁节点，但存在读锁节点，则可以获得读锁（因为读锁之间不互斥）。</li></ul></li></ol><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>在单体应用时代，一个业务操作通常只涉及一个数据库，通过本地事务（ACID 特性）就能轻松保证数据的<strong>原子性、一致性、隔离性和持久性</strong>。然而，随着系统向<strong>分布式架构</strong>（特别是<strong>微服务架构</strong>）演进，一个完整的业务操作可能需要调用多个独立的服务，而每个服务又可能操作不同的数据库。这时，传统的本地事务就无能为力了，因为它们无法跨越服务的边界。</p><p><strong>分布式事务</strong>应运而生，它的核心目标是：<strong>确保分布式系统中，多个独立服务或数据库的原子性操作能够像一个单一操作一样，要么全部成功，要么全部失败。</strong></p><div class="table-container"><table><thead><tr><th><strong>方案</strong></th><th><strong>一致性</strong></th><th><strong>性能</strong></th><th><strong>复杂度</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td>2PC</td><td>强一致性</td><td>低</td><td>中</td><td>传统数据库、XA协议</td></tr><tr><td>3PC</td><td>强一致性</td><td>中低</td><td>高</td><td>需减少阻塞的强一致场景</td></tr><tr><td>TCC</td><td>最终一致性</td><td>高</td><td>高</td><td>高并发业务（支付、库存）</td></tr><tr><td>Saga</td><td>最终一致性</td><td>中</td><td>高</td><td>长事务、跨服务流程</td></tr><tr><td>消息队列</td><td>最终一致性</td><td>高</td><td>中</td><td>事件驱动架构</td></tr><tr><td>本地消息表</td><td>最终一致性</td><td>中</td><td>低</td><td>异步通知（订单-积分</td></tr></tbody></table></div><ul><li>两阶段提交协议（2PC）：为准备阶段和提交阶段。准备阶段，协调者向参与者发送准备请求，参与者执行事务操作并反馈结果。<strong>若所有参与者准备就绪，协调者在提交阶段发送提交请求，参与者执行提交</strong>；否则发送回滚请求。实现简单，能保证事务强一致性。存在单点故障，协调者故障会影响事务流程；性能低，多次消息交互增加延迟；资源锁导致资源长时间占用，降低并发性能。适用于对数据一致性要求高、并发度低的场景，如金融系统转账业务。</li></ul><p><strong>原理：</strong> 2PC 是最经典的分布式事务协议，它将事务的提交过程分为两个阶段：<strong>准备阶段 (Prepare Phase)</strong> 和 <strong>提交阶段 (Commit Phase)</strong>。它有一个<strong>事务协调者 (Transaction Coordinator)</strong> 和多个<strong>事务参与者 (Transaction Participant)</strong>。</p><p><strong>流程：</strong></p><ol><li><strong>准备阶段 (Vote Request)：</strong> 协调者通知所有参与者准备提交事务。每个参与者执行事务操作，并锁定所需资源，但不真正提交。如果一切顺利，参与者返回“同意”；如果遇到问题，返回“拒绝”。</li><li><strong>提交阶段 (Execution Phase)：</strong> 协调者根据所有参与者的响应做出决定。<ul><li>如果所有参与者都同意，协调者发出“提交”指令，所有参与者执行真正的提交操作并释放资源。</li><li>如果有任何一个参与者拒绝或超时，协调者发出“回滚”指令，所有参与者回滚之前的操作并释放资源。</li></ul></li></ol><p><strong>优点：</strong> 强一致性，保证事务的原子性</p><ul><li>三阶段提交协议（3PC）：在 2PC 基础上，将准备阶段拆分为询问阶段和准备阶段，形成询问、准备和提交三个阶段。<strong>询问阶段协调者询问参与者能否执行事务，后续阶段与 2PC 类似。降低参与者阻塞时间，提高并发性能，引入超时机制一定程度解决单点故障问题</strong>。无法完全避免数据不一致，极端网络情况下可能出现部分提交部分回滚。用于对并发性能有要求、对数据一致性要求相对较低的场景。</li></ul><p>3PC 是在 2PC 基础上进行的改进，引入了“预提交（Pre-Commit）”阶段和超时机制，旨在解决 2PC 的同步阻塞和单点故障问题。</p><p>TCC：将业务操作拆分为 Try、Confirm、Cancel 三个阶段。<strong>Try 阶段预留业务资源，Confirm 阶段确认资源完成业务操作，Cancel 阶段在失败时释放资源回滚操作</strong>。可根据业务场景定制开发，性能较高，减少资源占用时间。开发成本高，需实现三个方法，要处理异常和补偿逻辑，实现复杂度大。适用于对性能要求高、业务逻辑复杂的场景，如电商系统订单处理、库存管理</p><p>TCC 是一种业务层面的分布式事务解决方案。它将一个完整的业务逻辑拆分为三个独立的操作：</p><ul><li><strong>Try：</strong> 尝试执行，对业务资源做<strong>预留</strong>（锁定）。确保资源在事务提交前可用。</li><li><strong>Confirm：</strong> 确认执行，真正<strong>提交</strong>业务操作。</li><li><strong>Cancel：</strong> 撤销执行，当任何一个 Try 操作失败时，执行<strong>补偿</strong>操作，释放预留资源或回滚已执行的部分。</li></ul><p><strong>Try 阶段：</strong> 协调者依次调用所有参与服务的 Try 接口。如果所有 Try 都成功，进入 Confirm 阶段。</p><p><strong>Confirm 阶段：</strong> 协调者调用所有参与服务的 Confirm 接口，完成实际业务提交。</p><p><strong>Cancel 阶段：</strong> 如果在 Try 阶段有任何一个服务返回失败，协调者会调用所有已 Try 成功的服务的 Cancel 接口进行补偿。</p><ul><li><p>Saga：将长事务拆分为多个短事务，每个短事务有对应的补偿事务。某个短事务失败，按相反顺序执行补偿事务回滚系统状态。性能较高，短事务可并行执行减少时间，对业务侵入性小，只需实现补偿事务。只能保证最终一致性，部分补偿事务失败可能导致系统状态不一致。适用于业务流程长、对数据一致性要求为最终一致性的场景，如旅游系统订单、航班、酒店预订。</p><p>Saga 是一种更宽松的最终一致性模式，它将一个长事务分解为一系列<strong>短事务（本地事务）</strong>。每个短事务都有一个<strong>对应的补偿操作</strong>。当任何一个短事务失败时，会触发之前已成功完成的短事务的补偿操作，从而实现回滚。</p></li></ul><p><strong>流程：</strong></p><ul><li><strong>协调器（Choreography 或 Orchestration）：</strong> Saga 可以通过事件驱动（无中心协调器）或中心协调器来管理。</li><li><strong>正向操作序列：</strong> 业务操作按顺序调用各个服务，每个服务完成自己的本地事务。</li><li><p><strong>补偿操作序列：</strong> 如果某个服务在执行时失败，Saga 会从该失败点开始，逆序调用之前已成功完成的服务的补偿操作，以撤销之前的操作。</p></li><li><p>可靠消息最终一致性方案：基于消息队列，业务系统执行本地事务时将业务操作封装成消息发至消息队列，下游系统消费消息并执行操作，失败则消息队列重试。实现简单，对业务代码修改小，系统耦合度低，能保证数据最终一致性。消息队列可靠性和性能影响大，可能出现消息丢失或延迟，需处理消息幂等性。适用于对数据一致性要求为最终一致性、系统耦合度低的场景，如电商订单支付、库存扣减。</p></li></ul><p>利用<strong>消息队列</strong>作为中间件，确保业务操作的可靠传递。</p><p><strong>流程（以事务消息为例）：</strong></p><ol><li><strong>本地事务与消息发送：</strong> 服务 A 在其本地事务中执行业务操作，同时向消息队列发送一条“事务消息”（处于“待确认”状态）。两者要么同时成功（由消息队列提供的事务消息机制保证），要么同时失败。</li><li><strong>消息投递：</strong> 消息队列将消息投递给服务 B。</li><li><strong>服务 B 处理：</strong> 服务 B 接收到消息，执行自己的本地事务，并向消息队列发送一个确认消息。</li><li><strong>最终一致：</strong> 如果服务 B 处理失败，消息队列会根据配置进行重试。如果最终无法处理，可以通过人工干预或补偿机制来解决。</li></ol><ul><li>本地消息表：业务与消息存储在同一个数据库，利用本地事务保证一致性，后台任务轮询消息表，通过MQ通知下游服务，下游服务消费成功后确认消息，失败则重试。简单可靠，无外部依赖。消息可能重复消费，需幂等设计。适用场景是异步最终一致性（如订单创建后通知积分服务）。</li></ul><h4 id="分布式场景的限流算法"><a href="#分布式场景的限流算法" class="headerlink" title="分布式场景的限流算法"></a>分布式场景的限流算法</h4><ul><li><strong>滑动窗口限流算法</strong>是对固定窗口限流算法的改进，有效解决了窗口切换时可能会产生两倍于阈值流量请求的问题。</li><li>漏桶限流算法能够对流量起到整流的作用，让随机不稳定的流量以固定的速率流出，但是不能解决<strong>流量突发</strong>的问题。</li><li><strong>令牌桶算法</strong>作为漏斗算法的一种改进，除了能够起到平滑流量的作用，还允许一定程度的流量突发。</li></ul><p>固定窗口限流算法就是对一段固定时间窗口内的请求进行计数，如果请求数超过了阈值，则舍弃该请求；如果没有达到设定的阈值，则接受该请求，且计数加1。当时间窗口结束时，重置计数器为0。</p><p>固定窗口限流优点是实现简单，但是会有“流量吐刺”的问题，假设窗口大小为1s，限流大小为100，然后恰好在某个窗口的第999ms来了100个请求，窗口前期没有请求，所以这100个请求都会通过。再恰好，下一个窗口的第1ms有来了100个请求，也全部通过了，那也就是在2ms之内通过了200个请求，而我们设定的阈值是100，通过的请求达到了阈值的两倍，这样可能会给系统造成巨大的负载压力。</p><p>改进固定窗口缺陷的方法是采用滑动窗口限流算法，<strong>滑动窗口就是将限流窗口内部切分成一些更小的时间片，然后在时间轴上滑动，每次滑动，滑过一个小时间片，就形成一个新的限流窗口，即滑动窗口。然后在这个滑动窗口内执行固定窗口算法即可。</strong></p><p>滑动窗口可以避免固定窗口出现的放过两倍请求的问题，因为一个短时间内出现的所有请求必然在一个滑动窗口内，所以一定会被滑动窗口限流。</p><p>令牌桶是另一种桶限流算法，模拟一个特定大小的桶，然后向桶中以特定的速度放入令牌（token），请求到达后，必须从桶中取出一个令牌才能继续处理。如果桶中已经没有令牌了，那么当前请求就被限流。如果桶中的令牌放满了，令牌桶也会溢出。</p><p>放令牌的动作是持续不断进行的，如果桶中令牌数达到上限，则丢弃令牌，因此桶中可能一直持有大量的可用令牌。此时请求进来可以直接拿到令牌执行。比如设置 qps 为 100，那么限流器初始化完成 1 秒后，桶中就已经有 100 个令牌了，如果此前还没有请求过来，这时突然来了 100 个请求，该限流器可以抵挡瞬时的 100 个请求。由此可见，只有桶中没有令牌时，请求才会进行等待，最终表现的效果即为以一定的速率执行</p><h3 id="分布式一致性算法"><a href="#分布式一致性算法" class="headerlink" title="分布式一致性算法"></a>分布式一致性算法</h3><p>Raft 和 Paxos 是两种经典的分布式一致性算法，旨在实现<strong>多节点状态机的高可靠一致性</strong>。两者核心目标相同（保证分布式系统数据一致性），但设计理念和实现方式有区别。</p><h4 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h4><p>Raft算法由leader节点来处理一致性问题。leader节点接收来自客户端的请求日志数据，然后同步到集群中其它节点进行复制，当日志已经同步到超过半数以上节点的时候，leader节点再通知集群中其它节点哪些日志已经被复制成功，可以提交到raft状态机中执行。</p><p>通过以上方式，Raft算法将要解决的一致性问题分为了以下几个子问题。</p><ul><li>leader选举：集群中必须存在一个leader节点。</li><li>日志复制：leader节点接收来自客户端的请求然后将这些请求序列化成日志数据再同步到集群中其它节点。</li><li>安全性：如果某个节点已经将一条提交过的数据输入raft状态机执行了，那么其它节点不可能再将相同索引 的另一条日志数据输入到raft状态机中执行。</li></ul><h4 id="Paxos协议"><a href="#Paxos协议" class="headerlink" title="Paxos协议"></a>Paxos协议</h4><p>Paxos算法的核心思想是将一致性问题分解为多个阶段，每个阶段都有一个专门的协议来处理。Paxos算法的主要组成部分包括提议者（Proposer）、接受者（Acceptor）和投票者（Voter）。</p><ul><li>提议者：提议者是负责提出一致性问题的节点，它会向接受者发送提议，并等待接受者的回复。</li><li>接受者：接受者是负责处理提议的节点，它会接收提议者发送的提议，并对提议进行判断。如果接受者认为提议是有效的，它会向投票者发送请求，并等待投票者的回复。</li><li>投票者：投票者是负责决定提议是否有效的节点，它会接收接受者发送的请求，并对请求进行判断。如果投票者认为请求是有效的，它会向接受者发送投票，表示支持或反对提议。</li></ul><p>Paxos算法的流程如下（以Basic Paxos 算法为例子）：</p><ul><li>准备阶段：提议者选择一个提案编号，并向所有接受者发送准备请求。提案编号是一个全局唯一的、单调递增的数字。接受者收到准备请求后，如果提案编号大于它之前接受过的任何提案编号，它会承诺不再接受编号小于该提案编号的提案，并返回它之前接受过的最大编号的提案信息（如果有）。</li><li>接受阶段：如果提议者收到了超过半数接受者的响应，它会根据这些响应确定要提议的值。如果接受者返回了之前接受过的提案信息，提议者会选择编号最大的提案中的值作为要提议的值；如果没有，提议者可以选择自己的值。提议者向所有接受者发送接受请求，包含提案编号和要提议的值。</li><li><p>学习阶段：当提议者收到超过半数接受者对某个提案的接受响应时，该提案被认为达成共识。学习者通过接受者的通知得知达成共识的值。</p></li><li><p><strong>Raft</strong> 更易于理解和实现，它将共识过程分解为选举和日志复制两个相对独立的子问题，并且对选举超时时间等参数进行了明确的定义和限制，降低了算法的复杂度。</p></li><li><strong>Paxos</strong> 是一种更通用、更基础的共识算法，它的理论性更强，在学术界有广泛的研究和应用。但 Paxos 的实现相对复杂，理解和调试难度较大。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://xiaolincoding.com/interview">https://xiaolincoding.com/interview</a></li><li><a href="https://www.pdai.tech/">https://www.pdai.tech/</a></li><li><a href="https://javaguide.cn/home.html">JavaGuide（Java学习&amp;面试指南） | JavaGuide</a></li><li><a href="https://javabetter.cn/">主页 | 二哥的Java进阶之路</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;分为三类Java基础知识,集合,JVM,多线程并发相关以及Spring,SpringBoot,SpringCloud分布式了解.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>rabbit-mq初探</title>
    <link href="https://www.sekyoro.top/2025/07/21/rabbit-mq%E5%88%9D%E6%8E%A2/"/>
    <id>https://www.sekyoro.top/2025/07/21/rabbit-mq%E5%88%9D%E6%8E%A2/</id>
    <published>2025-07-21T12:36:01.000Z</published>
    <updated>2025-08-09T05:22:32.480Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>消息队列功能很强大,它能使业务降低耦合,异步调用无需等待,下游服务故障不影响上游业务,缓存消息起到流量削峰填谷的作用. 这里介绍其中的RabbitMQ,此外在说一下Elastic Search和MongoDB.<br><span id="more"></span></p><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p><img data-src="https://s2.loli.net/2025/07/23/aSBLvYT564eHXyq.png" alt="image-20250723102231391"></p><p>消息队列:<strong>分布式应用必定涉及到各个系统之间的通信问题</strong>，这个时候消息队列也应运而生了。可以说分布式的产生是消息队列的基础</p><p>为什么使用消息队列?异步、解耦、削峰</p><p>引入消息队列带来的问题: 消息顺序消息  重复消费消息  分布式事务问题等</p><p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想象成：当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ 就好比由邮局、邮箱和邮递员组成的一个系统。从计算机术语层面来说，RabbitMQ 模型更像是一种交换机模型。</p><p><strong>可靠性</strong>: RabbitMQ 使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。</p><p><strong>灵活的路由</strong> : 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。</p><p><strong>扩展性</strong>: 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。</p><p><strong>高可用性</strong> : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。</p><p><strong>多种协议</strong>: RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP， MQTT 等多种消息 中间件协议。</p><p><strong>多语言客户端</strong> :RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。</p><p><strong>管理界面</strong> : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。</p><p><strong>插件机制</strong> : RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装Erlang和Rabbit-mq,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl.bat status</span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq-management</span><br></pre></td></tr></table></figure><p>然后访问15672端口可视化管理.</p><h2 id="队列类型"><a href="#队列类型" class="headerlink" title="队列类型"></a>队列类型</h2><p>RabbitMQ 提供了三种主要的队列类型，它们在数据存储、性能、特性和使用场景上有所不同：</p><h3 id="经典队列"><a href="#经典队列" class="headerlink" title="经典队列"></a>经典队列</h3><ul><li><strong>默认和最常见：</strong> 这是 RabbitMQ 最早支持的队列类型，也是如果你不显式指定队列类型时创建的默认类型。</li><li><strong>灵活的持久性：</strong> 可以配置为<strong>持久化 (durable)</strong> 或<strong>非持久化 (transient)</strong>。<ul><li><strong>持久化队列：</strong> 队列的元数据（队列名称、配置等）和消息都会被写入磁盘。即使 RabbitMQ 服务重启，队列及其消息也不会丢失。</li><li><strong>非持久化队列：</strong> 队列的元数据和消息只存在于内存中。RabbitMQ 服务重启后，队列及其消息会丢失。</li></ul></li><li><strong>支持镜像 (Mirrored Queues)：</strong> 经典队列可以通过配置<strong>镜像模式</strong>来提高可用性。这意味着队列的主副本存在于一个节点，同时在其他节点上也有同步的副本。当主节点故障时，一个镜像副本可以被提升为新的主副本。<ul><li><strong>优点：</strong> 提高了高可用性。</li><li><strong>缺点：</strong> 镜像队列在写入时需要进行同步复制，这会增加网络开销和延迟，影响吞吐量。消费者从主副本消费，如果主副本故障，需要选举新的主副本。</li></ul></li><li><strong>性能：</strong> 在单节点或非镜像模式下性能较高，但在高可用（镜像）模式下，由于同步复制开销，吞吐量可能会下降。</li><li><strong>内部实现：</strong> 消息通常存储在内存中，并根据需要（如持久化消息或内存不足时）溢出到磁盘。</li></ul><p><strong>使用场景：</strong></p><ul><li>大多数通用消息传递场景。</li><li>对消息持久性和可靠性有要求，但对吞吐量要求不是极致的场景（特别是在镜像模式下）。</li><li>需要简单高可用的应用。</li></ul><h3 id="仲裁队列-Quorum-Queue"><a href="#仲裁队列-Quorum-Queue" class="headerlink" title="仲裁队列(Quorum Queue)"></a>仲裁队列(Quorum Queue)</h3><p><strong>特点：</strong></p><ul><li><strong>Raft 共识算法：</strong> 仲裁队列是 RabbitMQ 3.8 版本引入的新队列类型，它基于 <strong>Raft 一致性算法</strong>实现。Raft 算法确保了分布式系统中的强一致性，比经典队列的镜像机制更健壮。</li><li><strong>自动高可用：</strong> 仲裁队列天生就是分布式的，不需要像经典队列那样手动配置镜像。它会自动在集群中的大多数节点上复制消息。</li><li><strong>多数派机制 (Quorum)：</strong> 任何操作（如消息的发布、消费确认）都需要集群中<strong>大多数节点</strong>的确认才能被视为成功。例如，一个有 3 个节点的仲裁队列，需要 2 个节点的确认。这保证了即使有节点故障，只要多数派存活，数据就不会丢失，并且服务可以继续。</li><li><strong>更好的数据安全性：</strong> Raft 算法确保了消息的强一致性，理论上比经典队列的镜像模式更能避免脑裂 (split-brain) 等问题，提供更高的数据安全性。</li><li><strong>写入性能：</strong> 由于需要多数派确认，写入性能通常会比非镜像的经典队列低，但比镜像的经典队列在某些情况下可能更好，因为它优化了复制过程。</li><li><strong>消费者行为：</strong> 消费者可以从任何副本消费消息，并且消费确认也会通过 Raft 算法进行同步，确保消费的顺序和一致性。</li><li><strong>只支持持久化：</strong> 仲裁队列的消息总是持久化的。</li></ul><p><strong>使用场景：</strong></p><ul><li>对数据一致性和高可用性有极高要求的场景。</li><li>需要避免数据丢失和脑裂问题的关键业务消息。</li><li>替代经典队列的镜像模式，提供更健壮的集群行为。</li></ul><h3 id="流式队列-Stream-Queue"><a href="#流式队列-Stream-Queue" class="headerlink" title="流式队列(Stream Queue)"></a>流式队列(Stream Queue)</h3><p><strong>特点：</strong></p><ul><li><strong>专为大数据流设计：</strong> 流式队列是 RabbitMQ 3.9 版本引入的最新队列类型，其设计目标是处理<strong>海量的、连续的、高吞吐量</strong>的消息流。</li><li><strong>类似 Kafka 的特性：</strong> 它吸收了 Kafka 等流处理系统的概念，例如：<ul><li><strong>追加日志 (Append-only Log)：</strong> 消息以追加的方式写入，像一个不可变的日志。</li><li><strong>多消费者并行消费：</strong> 多个消费者可以独立地追踪自己的消费进度（偏移量），从流的不同位置并行消费。</li><li><strong>消息保留策略：</strong> 消息可以被长期保留（例如，保留几天或直到达到某个大小限制），即使它们已经被消费者确认，也可以重新消费。这对于回溯、重放或处理慢速消费者非常有用。</li></ul></li><li><strong>高吞吐量：</strong> 通过优化内部存储和消费模型，流式队列可以提供比经典队列和仲裁队列更高的吞吐量，尤其是在大量消息的场景下。</li><li><strong>磁盘友好：</strong> 消息主要存储在磁盘上，但通过优化读写性能，依然能保持高吞吐。</li><li><strong>适用于历史数据回溯：</strong> 消费者可以从流的任意位置开始消费，或重新消费已处理过的消息。</li><li><strong>高可用：</strong> 流式队列也有其自身的复制机制来保证高可用性，但其细节与仲裁队列和经典镜像队列有所不同。</li></ul><p><strong>使用场景：</strong></p><ul><li>日志收集和分析。</li><li>IoT (物联网) 数据流处理。</li><li>事件溯源 (Event Sourcing)。</li><li>实时数据管道。</li><li>任何需要处理海量、连续、可回溯消息流的场景。</li></ul><p><strong>三种队列类型的比较总结</strong></p><div class="table-container"><table><thead><tr><th>特性</th><th>经典队列 (Classic Queues)</th><th>仲裁队列 (Quorum Queues)</th><th>流式队列 (Stream Queues)</th></tr></thead><tbody><tr><td><strong>设计目标</strong></td><td>通用消息，灵活配置</td><td>强一致性，高可用</td><td>大数据流，高吞吐，可回溯</td></tr><tr><td><strong>高可用</strong></td><td>需手动配置镜像（同步复制）</td><td>基于 Raft 算法，自动高可用（多数派）</td><td>自身复制机制，高可用</td></tr><tr><td><strong>一致性</strong></td><td>最终一致性（镜像）</td><td>强一致性</td><td>强一致性（内部实现）</td></tr><tr><td><strong>消息持久性</strong></td><td>可选（持久化/非持久化）</td><td>总是持久化</td><td>总是持久化，支持长期保留</td></tr><tr><td><strong>吞吐量</strong></td><td>单节点高，镜像模式有开销</td><td>比非镜像经典低，比镜像经典好（某些场景）</td><td>极高，尤其适合大数据流</td></tr><tr><td><strong>消费模型</strong></td><td>传统消息队列模型，消息一旦消费即移除</td><td>传统模型，但消费确认更强一致</td><td>类似 Kafka，支持多消费者独立追踪偏移量，可回溯</td></tr><tr><td><strong>内部实现</strong></td><td>基于内存/磁盘混合，分段存储</td><td>基于 Raft 日志，强一致性日志</td><td>追加日志，磁盘优化</td></tr><tr><td><strong>版本</strong></td><td>早期版本支持，默认</td><td>RabbitMQ 3.8+</td><td>RabbitMQ 3.9+</td></tr></tbody></table></div><h3 id="队列设置"><a href="#队列设置" class="headerlink" title="队列设置"></a>队列设置</h3><h4 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h4><p>设置队列属性max-priority,发送消息时设置priority属性排序.</p><h2 id="交换机类型"><a href="#交换机类型" class="headerlink" title="交换机类型"></a>交换机类型</h2><p><strong>交换机 (Exchange)</strong> 是消息路由的核心组件。生产者发送消息到交换机，而不是直接发送到队列。交换机接收到消息后，根据其类型和绑定的路由规则，将消息转发到一个或多个队列。</p><p>可以把交换机想象成一个邮局的分拣中心。当一封信（消息）到达邮局时，分拣中心（交换机）不会直接把它投递到某个邮箱（队列），而是会根据信封上的地址信息（路由键）和分拣规则（交换机类型及绑定），决定把这封信投递到哪些信箱。</p><p><strong>接收消息：</strong> 接收来自生产者的消息。</p><p><strong>路由消息：</strong> 根据自身类型和消息的<strong>路由键 (Routing Key)</strong>，以及与队列之间的<strong>绑定 (Binding)</strong> 规则，将消息转发到对应的队列。</p><p><strong>不存储消息：</strong> 交换机本身不存储消息，它只是一个消息转发器。如果一条消息到达交换机，但没有匹配到任何队列，那么这条消息就会被丢弃（除非配置了<strong>备份交换机</strong>）。</p><h3 id="直连交换机-Direct-Exchange"><a href="#直连交换机-Direct-Exchange" class="headerlink" title="直连交换机 (Direct Exchange)"></a>直连交换机 (Direct Exchange)</h3><p><strong>路由规则：</strong> 直连交换机根据消息的<strong>路由键（Routing Key)</strong>与<strong>队列和交换机之间的绑定键（Binding Key）</strong>进行精确匹配。</p><p><strong>工作方式：</strong> 只有当消息的路由键与队列的绑定键<strong>完全一致</strong>时，消息才会被转发到该队列。</p><p><strong>使用场景：</strong></p><ul><li><strong>点对点消息传递：</strong> 当你需要将消息发送到特定队列时。</li><li><strong>日志系统：</strong> 根据日志级别（如 <code>info</code>, <code>warning</code>, <code>error</code>）路由到不同的处理队列。</li></ul><p><strong>路由键</strong>和<strong>绑定键（Binding Key）\</strong>需要*<em>精确匹配*</em>。</p><p><strong>如何工作：</strong> 当一个队列与直连交换机绑定时，它会提供一个绑定键。如果消息的路由键与这个绑定键完全相同，交换机就会将消息转发到这个队列。</p><p><strong>示例：</strong></p><ul><li>队列 Q1 绑定到直连交换机 E1，绑定键是 <code>error</code>。</li><li>队列 Q2 绑定到直连交换机 E1，绑定键是 <code>info</code>。</li><li>生产者发送消息到 E1，路由键为 <code>error</code>。只有 Q1 会收到消息。</li><li>生产者发送消息到 E1，路由键为 <code>warning</code>。没有队列会收到消息（除非有备份交换机）。</li></ul><p><img data-src="https://s2.loli.net/2025/07/23/uvOSniRI79KlHjZ.png" alt="image-20250723152920972"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">directQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String exchangeName = <span class="string">&quot;amq.direct&quot;</span>;</span><br><span class="line">rabbitTemplate.convertAndSend(exchangeName,<span class="string">&quot;queue1&quot;</span>, <span class="string">&quot;hello,this is direct1 exhange&quot;</span>);</span><br><span class="line">rabbitTemplate.convertAndSend(exchangeName,<span class="string">&quot;queue2&quot;</span>, <span class="string">&quot;hello,this is direct2 exhange&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主题交换机-Topic-Exchange"><a href="#主题交换机-Topic-Exchange" class="headerlink" title="主题交换机 (Topic Exchange)"></a>主题交换机 (Topic Exchange)</h3><p><strong>路由规则：</strong> 主题交换机通过<strong>模式匹配</strong>的方式来路由消息，它也依赖于消息的路由键和绑定键。绑定键可以使用通配符：</p><ul><li><code>*</code> (星号)：匹配一个单词。</li><li><code>#</code> (井号)：匹配零个或多个单词。</li></ul><p><strong>示例：</strong></p><ul><li>队列 Q1 绑定到主题交换机 E2，绑定键是 <code>*.critical</code>。</li><li>队列 Q2 绑定到主题交换机 E2，绑定键是 <code>audit.#</code>。</li><li>生产者发送消息到 E2，路由键为 <code>log.critical</code>。Q1 会收到。</li><li>生产者发送消息到 E2，路由键为 <code>audit.user.login</code>。Q2 会收到。</li><li>生产者发送消息到 E2，路由键为 <code>report.summary</code>。都没有收到。</li></ul><p><img data-src="https://s2.loli.net/2025/07/23/Vi4tCgzQxNeEsGl.png" alt="image-20250723154158270"></p><p><strong>工作方式：</strong></p><ul><li>路由键和绑定键都是由句点 <code>.</code> 分隔的字符串（例如 <code>stock.usd.ny</code>）。</li><li>当消息的路由键与绑定键的模式匹配时，消息会被转发到对应的队列。</li></ul><p><strong>使用场景：</strong></p><ul><li><strong>日志订阅：</strong> 灵活地订阅不同来源、不同级别的日志。</li><li><strong>股票行情：</strong> 根据股票代码、货币类型等进行多维度的消息订阅。</li><li><strong>复杂事件处理：</strong> 需要根据事件类型或来源的层级结构进行路由</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topicQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String exchangeName = <span class="string">&quot;amq.topic&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName,<span class="string">&quot;china.weather&quot;</span>, <span class="string">&quot;hello,this is topic exhange&quot;</span>);</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName,<span class="string">&quot;china.news&quot;</span>, <span class="string">&quot;hello,this is topic exhange&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广播-扇形交换机-Fanout-Exchange"><a href="#广播-扇形交换机-Fanout-Exchange" class="headerlink" title="广播/扇形交换机 (Fanout Exchange)"></a>广播/扇形交换机 (Fanout Exchange)</h3><p>将接收到的消息广播到每一个跟其绑定的队列</p><p><strong>路由规则：</strong> 扇形交换机最简单，它会<strong>忽略</strong>消息的路由键。</p><p><strong>工作方式：</strong> 它会将接收到的所有消息广播到<strong>所有与它绑定的队列</strong>。</p><p><strong>关系：</strong> 扇形交换机<strong>完全忽略路由键</strong>, 无论消息的路由键是什么，扇形交换机都会将所有收到的消息广播到所有与它绑定的队列。路由键的存在只是为了符合协议要求，但其值没有任何路由意义。</p><p><strong>示例：</strong></p><ul><li>队列 Q1、Q2、Q3 都绑定到扇形交换机 E3。</li><li>生产者发送消息到 E3，路由键为任何值（例如 <code>my.key</code> 或 <code>whatever</code>）。Q1、Q2、Q3 都会收到消息。</li></ul><p><strong>使用场景：</strong></p><ul><li><strong>广播消息：</strong> 例如，通知所有在线用户某个系统维护消息。</li><li><strong>多任务处理：</strong> 一个任务触发后，需要多个不同的服务并行处理该任务的不同方面。</li><li><strong>缓存更新：</strong> 当数据更新时，通知所有需要更新缓存的服务。</li></ul><p><img data-src="https://s2.loli.net/2025/07/23/V12oSsUWA6M47c3.png" alt="image-20250723141958629"></p><p><img data-src="https://s2.loli.net/2025/07/23/y1GN8qE5B9toWRc.png" alt="image-20250723151942617"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fanoutQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String exchangeName = <span class="string">&quot;amq.fanout&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName,<span class="keyword">null</span>, <span class="string">&quot;hello,this is fanout exhange&quot;</span>);&#125;</span><br></pre></td></tr></table></figure><h3 id="头交换机-Headers-Exchange"><a href="#头交换机-Headers-Exchange" class="headerlink" title="头交换机 (Headers Exchange)"></a>头交换机 (Headers Exchange)</h3><p><strong>路由规则：</strong> 头交换机是<strong>最不常用</strong>的一种。它根据消息的<strong>头部属性（Headers）</strong>而不是路由键来路由消息。</p><p><strong>工作方式：</strong> 绑定时，你可以指定一系列的键值对（<code>x-match</code> 参数决定匹配规则：<code>any</code> 匹配任一，<code>all</code> 匹配所有）。消息的头部如果包含匹配的键值对，则会被转发。</p><p><strong>使用场景：</strong></p><ul><li>非常特殊的、基于复杂消息元数据的路由需求。</li><li>当路由键不足以表达所有路由逻辑时。</li></ul><p><strong>交换机的核心作用：</strong></p><ul><li>它是消息路由的<strong>第一站</strong>，解耦了生产者和队列。</li><li>不存储消息，只负责转发。</li></ul><p><strong>四种交换机类型及其路由规则：</strong></p><ul><li><strong>Direct (直连)：</strong> 精确匹配路由键。</li><li><strong>Topic (主题)：</strong> 模式匹配（<code>*</code>, <code>#</code> 通配符）。</li><li><strong>Fanout (扇形)：</strong> 广播到所有绑定队列，忽略路由键。</li><li><strong>Headers (头)：</strong> 根据消息头属性匹配（较少用）。</li><li><strong>面试时，能够清晰地解释每种类型的路由机制和适用场景是关键。</strong></li></ul><p><strong>路由键 (Routing Key) 和绑定键 (Binding Key) 的区别和联系：</strong></p><ul><li><strong>Routing Key：</strong> 生产者发送消息时附带的，描述消息的属性。</li><li><strong>Binding Key：</strong> 队列与交换机绑定时定义的，描述队列希望接收哪类消息。</li><li><strong>关系：</strong> 交换机根据这两者进行匹配，将消息路由到队列。它们的匹配规则取决于交换机的类型。</li></ul><h3 id="交换机设置"><a href="#交换机设置" class="headerlink" title="交换机设置"></a>交换机设置</h3><h4 id="持久化交换机"><a href="#持久化交换机" class="headerlink" title="持久化交换机"></a>持久化交换机</h4><p><strong>保证交换机本身的元数据不会因为 RabbitMQ 服务重启而丢失。</strong></p><p>持久化交换机的作用和重要性</p><p>当你声明一个交换机时，你可以将其设置为<strong>持久化（<code>durable = true</code>）\</strong>或*<em>非持久化（<code>durable = false</code>）*</em>。</p><ol><li><strong>保证交换机定义不丢失：</strong><ul><li><strong>作用：</strong> 当一个交换机被声明为持久化时，它的配置信息（名称、类型、是否是持久化等）会被 RabbitMQ 写入磁盘。</li><li><strong>重要性：</strong> 这意味着即使 RabbitMQ 服务器崩溃或被意外关闭，当它重新启动时，这个持久化交换机依然会自动被创建并恢复，无需应用程序重新声明它。这对于系统的稳定性和自恢复能力至关重要。</li></ul></li><li><strong>配合持久化队列和持久化消息，实现端到端的可靠性：</strong><ul><li><strong>作用：</strong> 持久化交换机本身并不能保证消息的持久性。它只是保证了“通道”的存在。要实现消息在 Broker 重启后不丢失，需要<strong>三者协同工作</strong>：<ol><li><strong>持久化交换机：</strong> 确保交换机定义不丢失。</li><li><strong>持久化队列：</strong> 确保队列定义及其内部存储的消息不丢失。</li><li><strong>持久化消息：</strong> 生产者发送消息时，将 <code>delivery_mode</code> 设置为 <code>2</code> (Persistent)，这样消息内容本身才会被写入磁盘。</li></ol></li><li><strong>重要性：</strong> 只有这三者都配置为持久化，才能在 RabbitMQ 服务器重启后，确保消息从生产者到达消费者前的整个传递路径上的数据都不会丢失，从而实现端到端的消息可靠性。</li></ul></li></ol><h4 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h4><p><strong>死信机制</strong>是 RabbitMQ 提供的一种处理无法被正常投递或消费的消息的机制，是消息可靠性设计的重要组成部分。</p><p>虽然 DLX/DLQ 不是交换机类型，但它是一个非常重要的概念，涉及到消息无法被消费时的处理。当消息出现以下情况时，会被转发到死信交换机：</p><ul><li>消息被消费者拒收 (rejected)，并且 <code>requeue</code> 参数设置为 <code>false</code>。</li><li>消息 TTL (Time-To-Live) 过期。</li><li>队列达到最大长度 (max-length)。</li></ul><h2 id="消息属性与投递属性"><a href="#消息属性与投递属性" class="headerlink" title="消息属性与投递属性"></a>消息属性与投递属性</h2><p>消息属性是<strong>生产者在发布消息时设置的</strong>元数据，随消息一起传递。它们通常用于描述消息的特性或提供额外的处理信息。 常见的消息属性包括：</p><ul><li><strong><code>content_type</code>：</strong> 消息体的数据类型（例如 <code>application/json</code>）。</li><li><strong><code>content_encoding</code>：</strong> 消息体的编码方式（例如 <code>gzip</code>）。</li><li><strong><code>headers</code>：</strong> 一个自定义的键值对映射，可以包含应用程序定义的任意元数据。</li><li><strong><code>delivery_mode</code>：</strong> 消息的持久性。<ul><li><code>1</code> (Non-persistent): 消息不会写入磁盘，Broker 重启后会丢失。</li><li><code>2</code> (Persistent): 消息会写入磁盘，Broker 重启后会保留（但还需要队列是持久化的）。</li></ul></li><li><strong><code>priority</code>：</strong> 消息的优先级（如果队列支持优先级）。</li><li><strong><code>correlation_id</code>：</strong> 用于关联请求和响应消息，常用于 RPC 模式。</li><li><strong><code>reply_to</code>：</strong> 用于指定响应消息应该发送到哪个队列，常用于 RPC 模式。</li><li><strong><code>expiration</code>：</strong> 消息的过期时间（TTL），过期后消息会成为死信。</li><li><strong><code>message_id</code>：</strong> 消息的唯一标识符，由生产者设置。</li><li><strong><code>timestamp</code>：</strong> 消息发布时的时间戳。</li><li><strong><code>type</code>：</strong> 消息类型（应用程序定义）。</li><li><strong><code>user_id</code>：</strong> 发布消息的用户 ID。</li><li><strong><code>app_id</code>：</strong> 发布消息的应用程序 ID。</li></ul><p>投递属性是 RabbitMQ <strong>在将消息投递给消费者时添加的</strong>元数据，它们不属于原始消息本身，而是描述了消息的投递状态。</p><p> <code>requeue</code> 和 <code>redelivered</code> 并不是消息本身的属性，而是与<strong>消息处理和确认机制</strong>相关的<strong>行为参数或状态标志</strong>。</p><ul><li><strong><code>requeue</code> (行为参数)</strong><ul><li><code>requeue</code> 是在消费者向 RabbitMQ 发送<strong>否定确认 (Negative Acknowledgment - <code>basic.reject</code> 或 <code>basic.nack</code>)</strong> 时使用的一个<strong>布尔参数</strong>。</li><li>当 <code>requeue</code> 设置为 <code>true</code> 时，表示消费者要求 RabbitMQ 将此消息<strong>重新放回队列</strong>。消息会通常被放回队列的头部或按优先级排序。</li><li>当 <code>requeue</code> 设置为 <code>false</code> 时，表示消费者拒绝此消息，并且<strong>不希望它重新入队</strong>。此时，如果队列配置了死信交换机（DLX），消息就会被路由到 DLX；否则，消息会被直接丢弃。</li></ul></li><li><strong><code>redelivered</code> (状态标志)</strong><ul><li><code>redelivered</code> 是一个<strong>布尔型的投递属性</strong>。</li><li>当 RabbitMQ 第一次将消息投递给某个消费者时，<code>redelivered</code> 标志为 <code>false</code>。</li><li>如果消息被<strong>重新入队</strong>（例如，消费者 <code>nack</code> 并 <code>requeue=true</code>，或者连接断开导致消息自动重新入队），那么当这条消息<strong>再次</strong>被投递给任何消费者时，它的 <code>redelivered</code> 标志就会被设置为 <code>true</code>。</li><li><strong>作用：</strong> 这个标志告诉消费者：“这条消息不是第一次被投递了，你可能已经处理过它或者它之前未能成功处理。”消费者可以根据这个标志来识别重复投递的消息，并采取相应的处理策略（例如，幂等处理、记录警告、发送到死信队列等）。</li></ul></li></ul><h2 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h2><hr><p>消息可靠性在分布式系统中是一个至关重要的概念，它指的是<strong>确保消息在从生产者到消费者的整个生命周期中不会丢失、不被重复处理，并且能够按照预期的顺序被处理</strong>。消息不丢失,消息不重复,消息有序性</p><h3 id="生产者可靠性"><a href="#生产者可靠性" class="headerlink" title="生产者可靠性"></a>生产者可靠性</h3><h4 id="生产者重连"><a href="#生产者重连" class="headerlink" title="生产者重连"></a>生产者重连</h4><p>由于网络波动,生产者可能出现连接mq失败的情况,可以设置连接超时和重试时间.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生产者超时重连</span></span><br><span class="line"><span class="meta">spring.rabbitmq.connection-timeout</span>= <span class="string">1s</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.retry.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.retry.initial-interval</span>=<span class="string">1000ms</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.retry.max-attempts</span>=<span class="string">3</span></span><br></pre></td></tr></table></figure><h4 id="生产者确认"><a href="#生产者确认" class="headerlink" title="生产者确认"></a>生产者确认</h4><p>如果路由失败,通过PublisherReturen返回路由异常原因,返回ACK.告知投递成功.</p><p>如果消息投递到了MQ并且入队成功,返回ACK,告知投递成功,其他情况发送nack.</p><p>RabbitMQ 提供了两种主要的生产者确认机制：</p><ol><li><strong>事务 (Transactions)</strong></li><li><strong>发布者确认 (Publisher Confirms)</strong></li></ol><p>RabbitMQ 的事务机制允许将一组消息的发送操作包装成一个原子单元。在事务中，要么所有消息都被 Broker 接收并处理，要么所有消息的操作都被回滚。</p><p>它涉及三个基本的 AMQP 命令：</p><ul><li><strong><code>Tx.Select</code></strong>: 声明当前通道进入事务模式。</li><li><strong><code>Tx.Commit</code></strong>: 提交事务。一旦提交，所有在事务期间发送的消息都被 Broker 确认接收。</li><li><strong><code>Tx.Rollback</code></strong>: 回滚事务。事务期间发送的所有消息都会被丢弃。</li></ul><p>优点</p><ul><li><strong>强一致性保证：</strong> 提供了严格的原子性，确保事务内的所有消息要么都成功，要么都失败。</li></ul><p>缺点</p><ul><li><strong>性能开销大：</strong> 每个 <code>Tx.Commit</code> 命令都会阻塞生产者，直到 Broker 响应。这意味着 Broker 需要对每个事务进行磁盘同步（如果消息是持久化的），这会大大<strong>降低消息的吞吐量</strong>。</li><li><strong>不适合高并发场景：</strong> 由于其阻塞特性，事务机制不适用于需要高吞吐量或低延迟的场景。</li></ul><p>发布者确认是 RabbitMQ 推荐的、更高效的生产者确认机制。它允许生产者异步地接收 Broker 的确认，而无需阻塞发送线程。</p><p>启用发布者确认后，Broker 会在以下两种情况下向生产者发送确认：</p><ul><li><strong><code>basic.ack</code> (肯定确认)：</strong><ul><li>表示消息已成功接收并<strong>持久化到磁盘</strong>（如果消息和队列都是持久化的），或者已成功<strong>路由到至少一个队列</strong>（如果消息是非持久化的）。</li><li>每个 <code>basic.ack</code> 都带有一个 <code>deliveryTag</code>（通道内递增的唯一标识符），可以确认单条消息或一批消息。</li></ul></li><li><strong><code>basic.nack</code> (否定确认)：</strong><ul><li>表示消息已被 Broker 接收，但由于某种原因<strong>未能被处理</strong>（例如，Broker 内部错误）。</li><li>这并不意味着消息丢失，而是 Broker 告诉生产者消息可能需要重新发送或进行其他处理</li></ul></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生产者确认机制</span></span><br><span class="line"><span class="comment"># 异步回调方式并且会返回deliveryId</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated </span></span><br><span class="line"><span class="comment"># simple 同步阻塞等待broker回执消息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 开启publisher return 机制 返回路由失败消息</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-returns</span>=<span class="string">true  </span></span><br></pre></td></tr></table></figure><p><strong>退回机制</strong></p><p>当publisher-returns属性设置为 <code>true</code> 时，如果生产者发送的消息<strong>无法被路由到任何队列</strong>（例如，因为路由键不匹配任何绑定，或者队列不存在），RabbitMQ Broker 会将这条消息”退回”给生产者</p><p>需要为 <code>RabbitTemplate</code> 设置一个 <code>ReturnsCallback</code>。</p><p>当消息被退回时，<code>ReturnsCallback</code> 会被异步调用，并接收一个 <code>ReturnedMessage</code> 对象作为参数。</p><p><code>ReturnedMessage</code> 对象包含了被退回的<strong>原始消息</strong>、<strong>退回的原因</strong>（<code>replyCode</code> 和 <code>replyText</code>，例如 <code>312 NO_ROUTE</code> 表示无路由）、<strong>发送时使用的交换机</strong>和<strong>路由键</strong>等信息。</p><p>退回回调是rabbitTemplate在初始化后设置的,因此可以在postConstrcut中,以及aware接口,BeanPostProcessor接口等实现.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonConfig</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        RabbitTemplate rabbitTemplate = applicationContext.getBean(RabbitTemplate.class);</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> RabbitTemplate.ReturnsCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span> </span>&#123;</span><br><span class="line">                Message message = returnedMessage.getMessage();</span><br><span class="line">                String exchange = returnedMessage.getExchange();<span class="comment">//发送的交换机</span></span><br><span class="line">                <span class="keyword">int</span> replyCode = returnedMessage.getReplyCode();</span><br><span class="line">                String replyText = returnedMessage.getReplyText();</span><br><span class="line">                log.info(<span class="string">&quot;message:&#123;&#125;,exchange:&#123;&#125;,replyCode:&#123;&#125;,replyText:&#123;&#125;&quot;</span>,message,exchange,replyCode,replyText);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>确认机制</strong></p><p>当设置<code>publisher-confirm-type</code>为 <code>CORRELATED</code> 时，Spring AMQP 启用了发布者确认机制，并提供了<strong>更细粒度、更强大的确认方式</strong>。这是<strong>推荐</strong>用于生产环境的配置。</p><ul><li><strong>确认方式：</strong> 允许你为每条发送的消息提供一个<strong>唯一的 <code>CorrelationData</code> 对象</strong>（通常包含一个消息 ID）。当 Broker 返回确认（<code>basic.ack</code> 或 <code>basic.nack</code>）时，这个 <code>CorrelationData</code> 对象会作为参数传递给 <code>RabbitTemplate</code> 的 <code>ConfirmCallback</code>。</li><li><strong>关联性：</strong> 这是核心优势。通过 <code>CorrelationData</code>，你可以<strong>精确地将 Broker 返回的确认与你发送的特定消息关联起来</strong>。这对于跟踪消息状态、实现重试逻辑、确保幂等性等非常关键。</li><li><strong>回调：</strong> 你必须设置 <code>RabbitTemplate</code> 的 <code>ConfirmCallback</code>。当 Broker 返回确认时，该回调会被异步调用。<code>ConfirmCallback</code> 会接收 <code>CorrelationData</code>、<code>ack</code>（是否成功确认）和 <code>cause</code>（如果 <code>ack</code> 为 <code>false</code>，表示原因）作为参数。</li><li><strong>异步性：</strong> 生产者可以持续发送消息，而无需等待 Broker 的确认。确认的回调是异步发生的，大大提高了吞吐量。</li></ul><p>设置 <code>RabbitTemplate</code> 的 <code>ConfirmCallback</code>。当 Broker 返回确认时，该回调会被异步调用。<code>ConfirmCallback</code> 会接收 <code>CorrelationData</code>、<code>ack</code>（是否成功确认）和 <code>cause</code>（如果 <code>ack</code> 为 <code>false</code>，表示原因）作为参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testPublisherConfirm</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line">        correlationData.getFuture().toCompletableFuture().thenAccept(<span class="keyword">new</span> Consumer&lt;CorrelationData.Confirm&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(CorrelationData.Confirm confirm)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (confirm.isAck()) &#123;</span><br><span class="line"><span class="comment">//                    ack成功,接收到ack</span></span><br><span class="line">                    log.info(<span class="string">&quot;消息成功,收到broker ack&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                    发送者确认机制,如果没有收到ack</span></span><br><span class="line">                    log.info(<span class="string">&quot;消息失败,收到broker nack,发送者没有收到ack:&#123;&#125;&quot;</span>,confirm.getReason());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).exceptionally(<span class="keyword">new</span> Function&lt;Throwable, Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">apply</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                log.error(throwable.getMessage(),throwable);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">&quot;amq.direct&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName,<span class="string">&quot;queue1&quot;</span>, <span class="string">&quot;hello,this is topic exhange&quot;</span>,correlationData);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/07/23/HCNPY9af2AxcIi4.png" alt="image-20250723215959341"></p><h3 id="消息队列可靠性"><a href="#消息队列可靠性" class="headerlink" title="消息队列可靠性"></a>消息队列可靠性</h3><p>默认情况下,会将接收到的消息保存在内存中,但:</p><ol><li>如果mq宕机,内存中的消息会丢失</li><li>内存空间有限,如果消费者故障或者处理过慢会导致消息堆积,引发mq阻塞</li></ol><h4 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h4><p>RabbitMQ实现数据持久化包括三个方面:</p><p>消息队列设置durable,发送消息设置delivery_mode为持久化(2)),交换机设置为持久.</p><p>持久化使得存储在磁盘避免崩溃数据丢失,同时当消息堆积过多时避免page out(也就是当 Broker 中的消息堆积过多，导致内存压力过大时，RabbitMQ 会将内存中一部分<strong>非活跃</strong>（未被消费者拉取）的消息<strong>暂时从内存中移除并写入到磁盘上</strong>，以释放内存资源)</p><p>注意在RabbitTemplate中(来自spring-boot-starter-amqp),消息的delivery_mode是2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    DEFAULT_DELIVERY_MODE = MessageDeliveryMode.PERSISTENT;</span><br><span class="line">    DEFAULT_PRIORITY = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(name, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseExchangeBuilder</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">BaseExchangeBuilder</span>&lt;<span class="title">B</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">AbstractBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String type;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> durable = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> autoDelete;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> internal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> delayed;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> ignoreDeclarationExceptions;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> declare = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> Object[] declaringAdmins;&#125;</span><br></pre></td></tr></table></figure><h4 id="Lazy-Queue"><a href="#Lazy-Queue" class="headerlink" title="Lazy Queue"></a>Lazy Queue</h4><p>惰性队列收到消息后直接存入磁盘而非内存,内存只保留最近消息.</p><p>消费者要消费消息时才会从磁盘中读取并加载到内存,支持数百万跳的消息存储.</p><p><strong>新版本都是惰性队列</strong></p><p>标准队列（非惰性队列）在消息堆积时的行为：</p><ul><li><strong>内存优先：</strong> 默认情况下，标准队列会尽可能地将消息保留在内存中，以提高消息的投递速度。只有当 Broker 的内存达到高水位线时，才会将消息 Page-out (从内存交换到磁盘)。</li><li><strong>内存峰值：</strong> 当消息生产者发送速度远超消费者，导致大量消息在队列中堆积时，这些消息会全部加载到内存中。这可能导致 Broker 内存急剧增长，甚至达到内存限制，触发流控或崩溃。</li><li><strong>频繁 Page-out/Page-in：</strong> 如果消息持续堆积，Broker 会频繁地进行 Page-out 和 Page-in 操作，这会导致大量的磁盘 I/O，严重影响系统性能和消息延迟。</li></ul><p>惰性队列的核心思想是<strong>“消息总是尽可能地写入磁盘，只有在需要投递时才加载到内存”</strong>。</p><p>它通过调整消息在队列中的存储策略来达到减少内存占用的目的：</p><ol><li><strong>主动写入磁盘：</strong> 与标准队列不同，惰性队列在接收到消息后，会<strong>立即或很快地将消息内容写入到磁盘</strong>，只在内存中保留少量消息元数据（如消息索引）。</li><li><strong>延迟加载：</strong> 只有当消息即将被消费者拉取时（例如，消费者连接并准备接收消息），惰性队列才会将这些消息从磁盘读取到内存中进行投递。</li><li><strong>内存占用低：</strong> 即使有大量消息堆积，内存中的实际消息内容非常少，从而大大降低了 Broker 的内存使用。</li></ol><p><img data-src="https://s2.loli.net/2025/07/23/fvJXcjB8t7Y1QIN.png" alt="image-20250723230903068"></p><p>Lazy Queue 的工作方式是把消息写入磁盘，但这并<strong>不意味着</strong>消息本身就是持久化的。当 RabbitMQ 收到一个消息时，它首先会根据消息的 <code>delivery_mode</code> 属性来判断：</p><ol><li>如果 <code>delivery_mode=1</code>（非持久化），RabbitMQ 会直接将消息写入 Lazy Queue 的磁盘存储中，但<strong>不会记录持久化日志</strong>。这意味着，如果 RabbitMQ 服务重启，这些消息是无法恢复的。</li><li>如果 <code>delivery_mode=2</code>（持久化），RabbitMQ 会将消息写入 Lazy Queue 的磁盘存储，并且会<strong>同步记录持久化日志</strong>。当服务重启时，RabbitMQ 会读取这些日志来恢复队列中的所有消息。</li></ol><p><strong>因此，Lazy Queue 只是改变了消息的“存放位置”（从内存到磁盘），而 <code>delivery_mode=2</code> 才是真正决定了消息在服务重启后是否能够“恢复”。</strong></p><p>懒惰队列的策略是<strong>“能不用内存就不用”</strong>。</p><ol><li><strong>触发时机</strong>：消息到达时，懒惰队列会<strong>立即</strong>（或者在很短的时间内）将消息写入磁盘。消息在内存中只保留极少量的元数据。</li><li><strong>内存使用</strong>：这个过程是<strong>主动的</strong>、<strong>即时</strong>的。无论队列中消息有多少，绝大多数消息都存储在磁盘上，因此 RabbitMQ 的内存占用非常稳定且低。</li><li><strong>对性能的影响</strong>：虽然消息写入磁盘会产生 I/O 开销，但这个开销是<strong>分散</strong>在消息到达时进行的。它避免了在系统内存高压时突然进行大量的磁盘 I/O，从而保证了 RabbitMQ 进程的稳定性和响应能力。</li></ol><h3 id="消费者可靠性"><a href="#消费者可靠性" class="headerlink" title="消费者可靠性"></a>消费者可靠性</h3><p>如果没有确认机制，当消息被投递给消费者后，即使消费者未能成功处理（例如，程序崩溃、网络中断、业务逻辑出错），Broker 也会认为消息已经发送，并将其从队列中删除。这就会导致<strong>消息丢失</strong>。</p><p>消费者确认机制正是为了解决这个问题，它在消费者和 Broker 之间建立了一种“消息处理状态”的反馈机制</p><h4 id="消费者确认机制"><a href="#消费者确认机制" class="headerlink" title="消费者确认机制"></a>消费者确认机制</h4><p>当消费者处理消息结束后,应该向RabbitMQ发送一个回执,告知MQ消息处理状态. </p><p>消费者处理结束后可以向MQ发送一个回执,告知自己消息的处理状态.</p><ul><li>ack:成功处理消息,MQ从队列中删除消息</li><li>nack:消息处理失败,MQ需要再次投递消息</li><li>reject:消息处理失败并拒绝该消息,从队列中删除.</li></ul><p><img data-src="https://s2.loli.net/2025/07/23/V6L9IWvfeUYTdrN.png" alt="image-20250723231753038"></p><p>SpringAMQP已经实现了消息确认功能,可以通过配置文件选择ACK处理方式.</p><p>none,manual,auto</p><p><img data-src="https://s2.loli.net/2025/07/23/XGb3OVvExu6Jmt8.png" alt="image-20250723232046254"></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 消费者确认机制</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.acknowledge-mode</span>=<span class="string">auto</span></span><br></pre></td></tr></table></figure><h4 id="消息失败"><a href="#消息失败" class="headerlink" title="消息失败"></a>消息失败</h4><p>当消费者出现异常后,消息会不断requeue到队列,再重新发送给消费者,然后再次异常,再次requeue,无限循环,导致mq消息处理飙升.</p><p>配置retry机制,设置最大尝试次数</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.listener.simple.acknowledge-mode</span>=<span class="string">auto</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.initial-interval</span>=<span class="string">1000ms</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.max-attempts</span>=<span class="string">3</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.multiplier</span>=<span class="string">2</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.stateless</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>当重试次数达到后直接抛弃消息,可以通过MessageRecoverer接口来处理,包括三种实现,可以直接reject并丢弃消息,也可以返回nack,重新入队,也可以将失败消息投递到指定的交换机.</p><p><img data-src="https://s2.loli.net/2025/07/23/GEYShOIwDZ9KnCQ.png" alt="image-20250723234838816"></p><p><img data-src="https://s2.loli.net/2025/07/24/KHnvIaoRCrUVsYz.png" alt="image-20250724003504963"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageRecoverer <span class="title">messageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RepublishMessageRecoverer(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务幂等性"><a href="#业务幂等性" class="headerlink" title="业务幂等性"></a>业务幂等性</h4><p>同一个业务执行一次或多次对业务状态的影响是一致的.</p><p>设置唯一消息id,可以直接设置消息属性,然后在消费者处将处理后的消息保存到数据库,当新消息</p><p><img data-src="https://s2.loli.net/2025/07/24/GHoW2eD1jNFbUQ4.png" alt="image-20250724104054206"></p><p>或者基于业务判断,例如在支付后修改订单状态,可以在修改订单状态后先查询订单状态判断状态是否是未支付,未支付才需要修改.</p><p><img data-src="https://s2.loli.net/2025/07/24/OJGYiMmEP45eaXA.png" alt="image-20250724105630177"></p><h3 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h3><p>生产者发送消息时指定一个时间,消费者不会立刻收到消息,而是在指定时刻之后才收到消息.</p><p>假设在交易之后还未付费,需要发送一个延时消息,在指定时间之后收到检查用户是否已经付费,如果付费则修改订单状态,如果没有付费,商品数量和订单状态都修改.</p><p><img data-src="https://s2.loli.net/2025/07/24/d1XV3agFZuc2EpU.png" alt="image-20250724110445201"></p><h4 id="死信交换机-1"><a href="#死信交换机-1" class="headerlink" title="死信交换机"></a>死信交换机</h4><p>当一个队列的消息满足以下情况之一时,就会成为死信:</p><ol><li>消费者使用basic.reject或者basic.nack,并且消息requeue参数为false.</li><li>消息达到了设置的expiration或者队列的x-max-ttl过期时间但无人消费.</li><li>队列消息堆积满了,最早的消息成为死信</li></ol><p>如果队列通过x-dead-letter-exchange指定交换了交换机,该队列中的死信就会投递到这个交换机.这个交换机就是DLX.</p><p><img data-src="https://s2.loli.net/2025/07/24/QqeEXnDsPTHOYrk.png" alt="image-20250724112010554"></p><p>也就是给一个交换机发送消息,然后一个队列接受,给这个队列设置超时时间和死信队列,当超时后到指定的队列中,消费者监听这个队列并进行处理.</p><h4 id="延迟消息插件"><a href="#延迟消息插件" class="headerlink" title="延迟消息插件"></a>延迟消息插件</h4><p>官方提供插件原生支持延迟消息功能. 插件的原理是设计一种支持延迟消息功能的交换机,当消息投递到交换机后可以延迟一段时间然后再投递到队列.</p><p>安装并启用插件,使用delayed交换机,同时设置消息头<code>x-delay</code>设置过期时间.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(value = &quot;direct.delayExchange&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        value = @Queue(value = &quot;direct.delayQueue&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listenMessage15</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;direct2, Spring接收到消费消息&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(exchangeName,<span class="string">&quot;queue1&quot;</span>, <span class="string">&quot;hihihi&quot;</span>,(msg)-&gt;&#123;</span><br><span class="line">    msg.getMessageProperties().setHeader(<span class="string">&quot;x-delay&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="comment">//   msg.getMessageProperties().setDelayLong(1000L);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>实现原理是,有一个时钟,当达到超时时间进行任务,因此对cpu压力较大. 适合延时时间较短的场景.</p><p>应用:取消超时订单</p><p><img data-src="https://s2.loli.net/2025/07/24/q4FaG2AV5BWoXxD.png" alt="image-20250724154804554"></p><p>订单完成后,发送延迟消息,进行延迟消息处理,监听对应的延迟消息队列,接收到消息id,查看订单是否已支付,如果支付,则return. 否则继续向延迟交换机发送消息,延迟时间可以设置更长一点.当延迟时间达到最大时间后,取消该订单并恢复库存(事务).</p><h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><p>最简单的消息发送,直接根据队列名字发送,不通过交换机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String queueName = <span class="string">&quot;hello.queue1&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(queueName, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接受消息上,spring-amqp提供声明式的消息监听,通过注解在方法上声明要监听的队列名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;hello.queue1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listenMessage</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;Spring接收到消费消息&quot;</span>+ msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个消费者绑定到同一个队列时,同一个消息只能被一个消费者消费,默认情况下将消息一次轮询投递给绑定在队列上的每一个消费者,没有考虑消费者是否已经处理完消息(消费者处理能力),可能出现消息堆积.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每次只能获取一条消息,处理完后再取</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.prefetch</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/07/23/3ANVlJm2jqtbDvh.png" alt="image-20250723141413063"></p><p>创建队列,交换机以及绑定关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanOutConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange  <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.fanoutExchange(<span class="string">&quot;exchange&quot;</span>).build();</span><br><span class="line"><span class="comment">//        return new FanoutExchange(&quot;exchange&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueue1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        return QueueBuilder.durable(&quot;queue&quot;).build();</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueue2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">binding</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了创建@Bean的方式,还可以通过注解方式.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(value = &quot;queue1&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(value = &quot;exchange1&quot;, type = &quot;direct&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;test1&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenQueue1</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/07/23/qDZUVliadH42pku.png" alt="image-20250723165130608"></p><div class="table-container"><table><thead><tr><th>元素</th><th>默认持久化属性 (<code>durable</code>)</th><th>默认 <code>delivery_mode</code></th><th>行为解释</th></tr></thead><tbody><tr><td><strong>消息</strong></td><td><strong>否</strong> (<code>delivery_mode=1</code>)</td><td><code>1</code> (非持久化)</td><td>Broker 重启会丢失，即使队列持久化。</td></tr><tr><td><strong>队列</strong></td><td><strong>是</strong> (<code>durable=true</code>)</td><td>N/A</td><td>Broker 重启后队列元数据不会丢失。</td></tr><tr><td><strong>交换机</strong></td><td><strong>是</strong> (<code>durable=true</code>)</td><td>N/A</td><td>Broker 重启后交换机元数据不会丢失。</td></tr></tbody></table></div><p>导出到 Google 表格</p><h2 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h2><p>如果发送的不是提供的Message对象或者字符串等,而是直接的pojo或者map,会通过消息转换器进行转换.  对消息对象的处理默认实现是SimpleMessageConverter,基于JDK的ObjectOutputStream完成序列化. 存在问题:JDK序列化消息可读性差,消息太大,有安全风险.</p><p>采用json序列化替代默认的JDK序列化</p><h2 id="面试重点"><a href="#面试重点" class="headerlink" title="面试重点"></a>面试重点</h2><h3 id="交换机（Exchange）的面试重点"><a href="#交换机（Exchange）的面试重点" class="headerlink" title="交换机（Exchange）的面试重点"></a>交换机（Exchange）的面试重点</h3><ol><li><p><strong>交换机的核心作用：</strong></p><ul><li>它是消息路由的<strong>第一站</strong>，解耦了生产者和队列。</li><li>不存储消息，只负责转发。</li></ul></li><li><p><strong>四种交换机类型及其路由规则：</strong></p><ul><li><strong>Direct (直连)：</strong> 精确匹配路由键。</li><li><strong>Topic (主题)：</strong> 模式匹配（<code>*</code>, <code>#</code> 通配符）。</li><li><strong>Fanout (扇形)：</strong> 广播到所有绑定队列，忽略路由键。</li><li><strong>Headers (头)：</strong> 根据消息头属性匹配（较少用）。</li><li><strong>面试时，能够清晰地解释每种类型的路由机制和适用场景是关键。</strong></li></ul></li><li><p><strong>路由键 (Routing Key) 和绑定键 (Binding Key) 的区别和联系：</strong></p><ul><li><strong>Routing Key：</strong> 生产者发送消息时附带的，描述消息的属性。</li><li><strong>Binding Key：</strong> 队列与交换机绑定时定义的，描述队列希望接收哪类消息。</li><li><strong>关系：</strong> 交换机根据这两者进行匹配，将消息路由到队列。它们的匹配规则取决于交换机的类型。</li></ul></li><li><p><strong>绑定 (Binding) 的概念：</strong></p><ul><li>它是交换机和队列之间的<strong>关联关系</strong>，定义了消息如何从交换机流向队列。</li></ul></li><li><p><strong>死信交换机 (Dead Letter Exchange, DLX) 和死信队列 (Dead Letter Queue, DLQ)：</strong></p><ul><li>虽然 DLX/DLQ 不是交换机类型，但它是一个非常重要的概念，涉及到消息无法被消费时的处理。当消息出现以下情况时，会被转发到死信交换机：<ul><li>消息被消费者拒收 (rejected)，并且 <code>requeue</code> 参数设置为 <code>false</code>。</li><li>消息 TTL (Time-To-Live) 过期。</li><li>队列达到最大长度 (max-length)。</li></ul></li><li>面试中常与消息可靠性、异常处理等话题结合考察。</li></ul></li><li><p><strong>持久化 (Durable) 交换机：</strong></p><ul><li>和队列一样，交换机也可以被声明为持久化的。这意味着即使 RabbitMQ 服务重启，交换机本身（及其类型、名称、配置）也不会丢失。</li><li><strong>注意：</strong> 持久化交换机只保证交换机的元数据不丢失，不保证消息本身。消息的持久化取决于消息的 <code>delivery_mode</code> 和队列的持久化配置。</li></ul></li><li><p><strong>消息丢失场景：</strong></p><ul><li>消息到达交换机，但没有匹配到任何队列（除非有备份交换机）。</li><li>消息被发送到非持久化交换机，且 RabbitMQ 服务重启。</li></ul></li><li><p><strong>备份交换机 (Alternate Exchange, AE)：</strong></p><p>当消息无法被路由到任何队列时，交换机可以将这些消息发送到预先配置的备份交换机。这对于捕获和处理那些未能成功路由的消息非常有用，防止消息静默丢失。</p><p>如果交换机收到的消息路由键没有匹配到任何队列，消息默认会被丢弃。这会引出<strong>备份交换机 (Alternate Exchange)</strong> 的概念，它可以在消息无法被路由时捕获这些消息。</p></li></ol><p><strong>死信交换机 (Dead Letter Exchange, DLX) 和死信队列 (Dead Letter Queue, DLQ)：</strong></p><ul><li>虽然 DLX/DLQ 不是交换机类型，但它是一个非常重要的概念，涉及到消息无法被消费时的处理。当消息出现以下情况时，会被转发到死信交换机：<ul><li>消息被消费者拒收 (rejected)，并且 <code>requeue</code> 参数设置为 <code>false</code>。</li><li>消息 TTL (Time-To-Live) 过期。</li><li>队列达到最大长度 (max-length)。</li></ul></li><li>面试中常与消息可靠性、异常处理等话题结合考察。</li></ul><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="使用Jackson2json转化器报错"><a href="#使用Jackson2json转化器报错" class="headerlink" title="使用Jackson2json转化器报错"></a>使用Jackson2json转化器报错</h3><p>如果在使用convertAndSend发送消息时可以发现,如果传输的本身就是Message,会直接传输,不做特别处理.但如果在RabbitListener中参数设置为Message,会报conversion异常,这是为什么呢. 核心原因是,在接受消息时,MessagingMessageConverter会调用Jackson2jsonConverter的fromMessage方法,它会根据消息的属性和头部进行推断类型,如果是没有,则会默认将Message的body二进制数据json反序列化为Object,如果转化失败就报错(比如是string的二进制数据).</p><p>下面是具体分析:</p><p>使用jacksonmessageconverter消息序列化机制</p><p>如果是传入对象,首先是Message直接返回,否则进行转换,调用这个converter的toMessage</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Message <span class="title">convertMessageIfNecessary</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Message msg) &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getRequiredMessageConverter().toMessage(object, <span class="keyword">new</span> MessageProperties());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// RabbitTemplate类中</span></span><br></pre></td></tr></table></figure><p>然后会在AbstactMessageConverter中调用toMessage方法,jackson2json本身没有toMessage方法,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">toMessage</span><span class="params">(Object object, <span class="meta">@Nullable</span> MessageProperties messagePropertiesArg, <span class="meta">@Nullable</span> Type genericType)</span> <span class="keyword">throws</span> MessageConversionException </span>&#123;</span><br><span class="line">    MessageProperties messageProperties = messagePropertiesArg;</span><br><span class="line">    <span class="keyword">if</span> (messagePropertiesArg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Message message = <span class="keyword">this</span>.createMessage(object, messageProperties, genericType);</span><br><span class="line">    messageProperties = message.getMessageProperties();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.createMessageIds &amp;&amp; messageProperties.getMessageId() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        messageProperties.setMessageId(UUID.randomUUID().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意new MessageProperties得到的消息content-type默认是<code>application/octet-stream</code>,然后通过AbstractJackson2MessageConverter的createMessage创建消息,这里就是关键了,这个converter的this.supportedContentType只有<code>application/json</code>,所以这里创建消息,并根据数据设置了长度的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">messageProperties.setContentType(<span class="keyword">this</span>.supportedContentType.toString());</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.supportedCTCharset == <span class="keyword">null</span>) &#123;</span><br><span class="line">    messageProperties.setContentEncoding(<span class="keyword">this</span>.getDefaultCharset());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">messageProperties.setContentLength((<span class="keyword">long</span>)bytes.length);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.getClassMapper() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    JavaType type = <span class="keyword">this</span>.objectMapper.constructType((Type)(genericType == <span class="keyword">null</span> ? objectToConvert.getClass() : genericType));</span><br><span class="line">    <span class="keyword">if</span> (genericType != <span class="keyword">null</span> &amp;&amp; !type.isContainerType() &amp;&amp; Modifier.isAbstract(type.getRawClass().getModifiers())) &#123;</span><br><span class="line">        type = <span class="keyword">this</span>.objectMapper.constructType(objectToConvert.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.getJavaTypeMapper().fromJavaType(type, messageProperties);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.getClassMapper().fromClass(objectToConvert.getClass(), messageProperties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Message(bytes, messageProperties);</span><br></pre></td></tr></table></figure><p>到此,toMessage结束.</p><p>而在接受消息时,在AbstactMessageListenerContainer中,接收到消息后调用onMessage方法,它会调用messagingMessageListenerAdapter中的toMessage方法,在这个方法中又调用toMessagingMessage方法,然后在其中调用fromMessage方法,在这里就是MessagingMessageConverter的fromMessage方法,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Message&lt;?&gt; toMessagingMessage(org.springframework.amqp.core.Message amqpMessage) &#123;</span><br><span class="line">    <span class="keyword">return</span> (Message)<span class="keyword">this</span>.getMessagingMessageConverter().fromMessage(amqpMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有一个extractPayload调用了extractMessage方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">extractPayload</span><span class="params">(org.springframework.amqp.core.Message message)</span> </span>&#123;</span><br><span class="line">    MessageProperties messageProperties = message.getMessageProperties();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        messageProperties.setTargetBean(<span class="keyword">this</span>.bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.method != <span class="keyword">null</span>) &#123;</span><br><span class="line">        messageProperties.setTargetMethod(<span class="keyword">this</span>.method);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.inferredArgumentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            messageProperties.setInferredArgumentType(<span class="keyword">this</span>.inferredArgumentType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MessagingMessageListenerAdapter.<span class="keyword">this</span>.extractMessage(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在extractMessage中获取了jackson2jsonMessageConverter,然后调用其fromMessage方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">extractMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    MessageConverter converter = <span class="keyword">this</span>.getMessageConverter();</span><br><span class="line">    <span class="keyword">return</span> converter != <span class="keyword">null</span> ? converter.fromMessage(message) : message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中会进行判断,如果不是octet-stream或者application/json以及null等,会报不支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">fromMessage</span><span class="params">(Message message, <span class="meta">@Nullable</span> Object conversionHint)</span> <span class="keyword">throws</span> MessageConversionException </span>&#123;</span><br><span class="line">    Object content = <span class="keyword">null</span>;</span><br><span class="line">    MessageProperties properties = message.getMessageProperties();</span><br><span class="line">    <span class="keyword">if</span> (properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String contentType = properties.getContentType();</span><br><span class="line">        <span class="keyword">if</span> ((!<span class="keyword">this</span>.assumeSupportedContentType || contentType != <span class="keyword">null</span> &amp;&amp; !contentType.equals(<span class="string">&quot;application/octet-stream&quot;</span>)) &amp;&amp; (contentType == <span class="keyword">null</span> || !contentType.contains(<span class="keyword">this</span>.supportedContentType.getSubtype()))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.log.isWarnEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.log.warn(<span class="string">&quot;Could not convert incoming message with content-type [&quot;</span> + contentType + <span class="string">&quot;], &#x27;&quot;</span> + <span class="keyword">this</span>.supportedContentType.getSubtype() + <span class="string">&quot;&#x27; keyword missing.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String encoding = <span class="keyword">this</span>.determineEncoding(properties, contentType);</span><br><span class="line">            content = <span class="keyword">this</span>.doFromMessage(message, conversionHint, properties, encoding);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (content == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.nullAsOptionalEmpty) &#123;</span><br><span class="line">            content = Optional.empty();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            content = message.getBody();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会在convertContent中进行转换得到目标对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">doFromMessage</span><span class="params">(Message message, Object conversionHint, MessageProperties properties, String encoding)</span> </span>&#123;</span><br><span class="line">    Object content = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        content = <span class="keyword">this</span>.convertContent(message, conversionHint, properties, encoding);</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MessageConversionException(<span class="string">&quot;Failed to convert Message content&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">convertContent</span><span class="params">(Message message, Object conversionHint, MessageProperties properties, String encoding)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Object content = <span class="keyword">null</span>;</span><br><span class="line">    JavaType inferredType = <span class="keyword">this</span>.javaTypeMapper.getInferredType(properties);</span><br><span class="line">    <span class="keyword">if</span> (inferredType != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.useProjectionForInterfaces &amp;&amp; inferredType.isInterface() &amp;&amp; !inferredType.getRawClass().getPackage().getName().startsWith(<span class="string">&quot;java.util&quot;</span>)) &#123;</span><br><span class="line">        content = <span class="keyword">this</span>.projectingConverter.convert(message, inferredType.getRawClass());</span><br><span class="line">        properties.setProjectionUsed(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inferredType != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.alwaysConvertToInferredType) &#123;</span><br><span class="line">        content = <span class="keyword">this</span>.tryConverType(message, encoding, inferredType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (content == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (conversionHint <span class="keyword">instanceof</span> ParameterizedTypeReference) &#123;</span><br><span class="line">            ParameterizedTypeReference&lt;?&gt; parameterizedTypeReference = (ParameterizedTypeReference)conversionHint;</span><br><span class="line">            content = <span class="keyword">this</span>.convertBytesToObject(message.getBody(), encoding, <span class="keyword">this</span>.objectMapper.getTypeFactory().constructType(parameterizedTypeReference.getType()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getClassMapper() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            JavaType targetJavaType = <span class="keyword">this</span>.getJavaTypeMapper().toJavaType(message.getMessageProperties());</span><br><span class="line">            content = <span class="keyword">this</span>.convertBytesToObject(message.getBody(), encoding, targetJavaType);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class&lt;?&gt; targetClass = <span class="keyword">this</span>.getClassMapper().toClass(message.getMessageProperties());</span><br><span class="line">            content = <span class="keyword">this</span>.convertBytesToObject(message.getBody(), encoding, targetClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到content,如果为null,则取message.body,然后将该对象包装为message</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (content == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.nullAsOptionalEmpty) &#123;</span><br><span class="line">        content = Optional.empty();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        content = message.getBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object convertedObject = <span class="keyword">this</span>.extractPayload(message);</span><br><span class="line"><span class="keyword">if</span> (convertedObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MessageConversionException(<span class="string">&quot;Message converter returned null&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    MessageBuilder&lt;Object&gt; builder = convertedObject <span class="keyword">instanceof</span> Message ? MessageBuilder.fromMessage((Message)convertedObject) : MessageBuilder.withPayload(convertedObject);</span><br><span class="line">    <span class="keyword">return</span> builder.copyHeadersIfAbsent(mappedHeaders).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现的问题是,如果send发送Message,在convertMessageIfNecessary会直接返回Message,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Message build = MessageBuilder.withBody(<span class="string">&quot;Helloaa aa &quot;</span>.getBytes(StandardCharsets.UTF_8)).build();</span><br><span class="line">rabbitTemplate.convertAndSend(exchangeName,<span class="string">&quot;queue1&quot;</span>, build);</span><br></pre></td></tr></table></figure><p>其content-type默认是octet-stream,其中的关键就是,这里根据消息属性判断targetJavaType是Object,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (content == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="comment">/// ....</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getClassMapper() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        JavaType targetJavaType = <span class="keyword">this</span>.getJavaTypeMapper().toJavaType(message.getMessageProperties());</span><br><span class="line">        content = <span class="keyword">this</span>.convertBytesToObject(message.getBody(), encoding, targetJavaType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体判断如下,首先根据属性判断,如果为空再根据”_<em>TypeId_</em>“头判断,如果还为空,就默认object了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JavaType <span class="title">toJavaType</span><span class="params">(MessageProperties properties)</span> </span>&#123;</span><br><span class="line">    JavaType inferredType = <span class="keyword">this</span>.getInferredType(properties);</span><br><span class="line">    <span class="keyword">if</span> (inferredType != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.canConvert(inferredType)) &#123;</span><br><span class="line">        <span class="keyword">return</span> inferredType;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String typeIdHeader = <span class="keyword">this</span>.retrieveHeaderAsString(properties, <span class="keyword">this</span>.getClassIdFieldName());</span><br><span class="line">        <span class="keyword">if</span> (typeIdHeader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.fromTypeHeader(properties, typeIdHeader);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.hasInferredTypeHeader(properties) ? <span class="keyword">this</span>.fromInferredTypeHeader(properties) : TypeFactory.defaultInstance().constructType(Object.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>content在进行convertBytesToObject转化过程中报异常,因为byte[]内容是字符串,但转为了Object,而且是通过jackson反序列化转的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(String content, JavaType valueType)</span> <span class="keyword">throws</span> JsonProcessingException, JsonMappingException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._assertNotNull(<span class="string">&quot;content&quot;</span>, content);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T)<span class="keyword">this</span>._readMapAndClose(<span class="keyword">this</span>._jsonFactory.createParser(content), valueType);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> JsonMappingException.fromUnexpectedIOE(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>return (T)this._readMapAndClose(this._jsonFactory.createParser(content), valueType);</code>出错. 所以核心原因还是类型设置为octet-stream会被认为是可以json反序列化的对象.如果直接传字符串,jackon会帮我们序列化为字符串,并在消息属性的头部headers设置<code>__TypeId__</code>类型为String. 但我们自己 手动序列化的数据并填充到Message显然不会有这些机制.</p><p><img data-src="https://s2.loli.net/2025/07/24/fde7GAnb34KDgUp.png" alt="image-20250724144930607"></p><p>这时什么时候设置的呢? 其实就是在AbstractJackson2MessageConverter的createMessage时,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.getClassMapper() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    JavaType type = <span class="keyword">this</span>.objectMapper.constructType((Type)(genericType == <span class="keyword">null</span> ? objectToConvert.getClass() : genericType));</span><br><span class="line">    <span class="keyword">if</span> (genericType != <span class="keyword">null</span> &amp;&amp; !type.isContainerType() &amp;&amp; Modifier.isAbstract(type.getRawClass().getModifiers())) &#123;</span><br><span class="line">        type = <span class="keyword">this</span>.objectMapper.constructType(objectToConvert.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.getJavaTypeMapper().fromJavaType(type, messageProperties);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.getClassMapper().fromClass(objectToConvert.getClass(), messageProperties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将对应的类型写入头部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fromJavaType</span><span class="params">(JavaType javaType, MessageProperties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.addHeader(properties, <span class="keyword">this</span>.getClassIdFieldName(), javaType.getRawClass());</span><br><span class="line">    <span class="keyword">if</span> (javaType.isContainerType() &amp;&amp; !javaType.isArrayType()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.addHeader(properties, <span class="keyword">this</span>.getContentClassIdFieldName(), javaType.getContentType().getRawClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (javaType.getKeyType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.addHeader(properties, <span class="keyword">this</span>.getKeyClassIdFieldName(), javaType.getKeyType().getRawClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><p>Netty 是一个高性能、事件驱动的异步网络应用框架，广泛用于构建可扩展的服务器和客户端程序.</p><p>基于 Java NIO(同步非阻塞IO)，但对其进行了封装和增强，使其更易于使用和性能更优。</p><h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>NIO是Netty 的基石。传统的 I/O（BIO）是阻塞的，每个连接都需要一个线程处理。N<strong>IO 允许单个线程处理多个 I/O 操作</strong>，通过 <strong>Selector</strong> 机制监听多个 Channel 上的事件，从而实现高并发。Netty 在 NIO 之上进行了抽象和优化，使其使用起来更加简单和高效。</p><h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><div class="table-container"><table><thead><tr><th>特性</th><th><code>select</code></th><th><code>poll</code></th><th><code>epoll</code></th></tr></thead><tbody><tr><td><strong>FD 数量限制</strong></td><td>默认 1024/2048 (固定位图)</td><td>无限制 (受限于内存)</td><td>无限制 (受限于内存)</td></tr><tr><td><strong>FD 传递</strong></td><td>每次调用完整复制 (<code>fd_set</code>)</td><td>每次调用完整复制 (<code>pollfd[]</code>)</td><td>一次注册，之后只返回就绪 FD</td></tr><tr><td><strong>效率</strong></td><td>O(N) (遍历所有 FD)</td><td>O(N) (遍历所有 FD)</td><td>O(K) (只遍历就绪 FD, K &lt;&lt; N)</td></tr><tr><td><strong>通知机制</strong></td><td>遍历查找</td><td>遍历查找</td><td>回调机制，内核通知就绪</td></tr><tr><td><strong>工作模式</strong></td><td>水平触发 (LT)</td><td>水平触发 (LT)</td><td>水平触发 (LT) / 边缘触发 (ET)</td></tr><tr><td><strong>“惊群”问题</strong></td><td>存在</td><td>存在</td><td>已优化，通常避免</td></tr><tr><td><strong>API 使用</strong></td><td>相对复杂</td><td>相对简单 (比 <code>select</code>)</td><td>需要三个系统调用 (<code>create</code>, <code>ctl</code>, <code>wait</code>)</td></tr><tr><td><strong>出现时间</strong></td><td>最早</td><td>较早</td><td>Linux 2.5.44+ (最新)</td></tr></tbody></table></div><p>“惊群”问题：<strong>当一个事件发生时，所有等待该事件的进程或线程都被唤醒，但实际上只有其中一个能够处理该事件，导致其他被唤醒的进程/线程做了无用功，并产生不必要的上下文切换开销，从而降低了系统效率和性能。</strong></p><p>FD传递指的是用户空间每次调用<code>select</code>或 <code>poll</code> 时，需要将 <code>fd_set</code>或<code>pollfd</code> 数组从用户空间<strong>完整地复制到内核空间</strong>, FD 就绪时，内核会修改对应 <code>pollfd</code> 结构体中的 <code>revents</code> 字段，并将其<strong>完整地复制回用户空间</strong>。</p><p>而在epoll中用户程序通过 <code>epoll_create()</code> 创建一个 <code>epoll</code> 实例。然后通过 <code>epoll_ctl()</code> <strong>一次性地将所有要监控的 FD 注册到内核的 <code>epoll</code> 事件表中</strong>，并指定感兴趣的事件。这个过程只需要将 FD 及其事件类型从用户空间复制到内核空间一次.</p><p><code>epoll_wait()</code> 调用时，内核<strong>只将就绪列表中的 FD 复制到用户空间</strong>。用户程序只需要遍历这些就绪的 FD 即可。</p><p>通知机制指的是内核修改了fd_set位图的值并完整返回,<code>fd_set</code> 仍然是一个<strong>位图 (bitmap)</strong>。它不像一个列表或数组那样直接给出就绪的 FD 列表。它只是在对应 FD 的位上设置为 1，而其他未就绪的 FD 的位仍为 0。为了知道具体是哪个文件描述符就绪了，用户程序必须遍历逐个检查,poll<code>也是类似的，它返回一个</code>pollfd<code>数组，你需要遍历这个数组来检查每个元素的</code>revents` 字段，找出就绪的 FD。</p><p>而 <code>epoll</code> 则不同，<code>epoll_wait</code> 会直接返回一个<strong>已就绪文件描述符的列表或数组</strong>，用户程序只需要遍历这个较小的就绪列表即可，因此效率更高，时间复杂度是 O(K)。</p><h3 id="Netty相比NIO改进"><a href="#Netty相比NIO改进" class="headerlink" title="Netty相比NIO改进"></a>Netty相比NIO改进</h3><p>Channel-&gt;NioSocketChannel/NioServerSocketChannel</p><p>Selector-&gt;EventLoop/EventLoppGroup</p><p>Buffer-&gt;ByteBuf</p><p>此外通过ChannelPipeline和ChannelHanlder来处理自定义事件.</p><h3 id="相比于直接使用Websocke优点"><a href="#相比于直接使用Websocke优点" class="headerlink" title="相比于直接使用Websocke优点"></a>相比于直接使用Websocke优点</h3><p>Netty 是一个高性能、异步事件驱动的网络应用框架，用于快速开发可维护的高性能协议服务器和客户端。它封装了 Java NIO（非阻塞 I/O），提供了高级 API，让开发者可以专注于业务逻辑，而无需关心底层复杂的网络编程细节（如线程管理、I/O 多路复用、协议编解码等）</p><p>WebSocket 是一种在单个 TCP 连接上进行<strong>全双工通信</strong>的协议。它允许服务器和客户端之间进行<strong>持久性连接</strong>，双方可以随时发送消息，而无需像传统的 HTTP 请求-响应模式那样每次都建立新连接。</p><h3 id="EventLoop-amp-EventLoopGroup-事件循环与事件循环组"><a href="#EventLoop-amp-EventLoopGroup-事件循环与事件循环组" class="headerlink" title="EventLoop &amp; EventLoopGroup 事件循环与事件循环组"></a>EventLoop &amp; EventLoopGroup 事件循环与事件循环组</h3><ul><li><strong>EventLoop:</strong> Netty 的核心线程模型。每个 <code>EventLoop</code> 是一个单线程，负责处理一个或多个 <strong>Channel</strong> 上的所有 I/O 事件（如连接建立、数据读写、断开连接），并执行关联的 <strong>ChannelHandler</strong>。它以事件驱动的方式运行，通过一个循环不断地从任务队列中获取事件并执行。</li><li><strong>EventLoopGroup:</strong> 包含一个或多个 <code>EventLoop</code> 的组。通常有两个 <code>EventLoopGroup</code>：<ul><li><strong>BossGroup (或 AcceptorGroup):</strong> 负责处理客户端的连接请求。一旦接受到连接，就会将连接注册到 WorkerGroup 中的某个 <code>EventLoop</code> 上。通常只有一个 <code>EventLoop</code> 或少量 <code>EventLoop</code>。</li><li><strong>WorkerGroup:</strong> 负责处理已建立连接的 I/O 读写事件和业务逻辑。包含多个 <code>EventLoop</code>，以实现并发处理。</li></ul></li></ul><p><strong>Channel 通道</strong> Netty 对网络连接的抽象。可以看作是连接双方进行数据传输的“通道”。所有的 I/O 操作都在 Channel 上进行。不同类型的 Channel 对应不同的传输协议（如 <code>NioSocketChannel</code> 用于 TCP/IP，<code>NioDatagramChannel</code> 用于 UDP）。</p><h3 id="ChannelHandler-amp-ChannelPipeline-处理器与处理器链"><a href="#ChannelHandler-amp-ChannelPipeline-处理器与处理器链" class="headerlink" title="ChannelHandler &amp; ChannelPipeline 处理器与处理器链"></a>ChannelHandler &amp; ChannelPipeline 处理器与处理器链</h3><ul><li><strong>ChannelHandler:</strong> 消息处理的核心组件。它是一个接口，定义了处理入站 (Inbound) 或出站 (Outbound) 事件的方法。<ul><li><strong>ChannelInboundHandler:</strong> 处理从网络读入的数据（入站事件），例如接收到连接、读取数据、处理异常等。</li><li><strong>ChannelOutboundHandler:</strong> 处理向网络写入的数据（出站事件），例如发送数据、连接断开等。</li><li>你可以自定义 <code>ChannelHandler</code> 来实现协议编解码、业务逻辑处理、日志记录、流量控制等功能。</li></ul></li><li><strong>ChannelPipeline:</strong> <code>ChannelHandler</code> 的链表。每个 <code>Channel</code> 都有一个 <code>ChannelPipeline</code>。当 I/O 事件发生时，数据会沿着 <code>ChannelPipeline</code> 在不同的 <code>ChannelHandler</code> 之间流动，形成一个责任链模式。<ul><li><strong>入站事件 (Inbound Event):</strong> 数据从网络流入，从 <code>ChannelPipeline</code> 的头部（第一个 <code>ChannelHandler</code>）开始，依次向后传递，直到链的尾部。</li><li><strong>出站事件 (Outbound Event):</strong> 数据从应用程序流出到网络，从 <code>ChannelPipeline</code> 的尾部（通常是触发写入操作的地方）开始，依次向前传递，直到链的头部。</li></ul></li></ul><h3 id="ByteBuf-字节缓冲区"><a href="#ByteBuf-字节缓冲区" class="headerlink" title="ByteBuf 字节缓冲区"></a>ByteBuf 字节缓冲区</h3><p> Netty 自己的高性能字节缓冲区，用于替换 Java NIO 的 <code>ByteBuffer</code>。<code>ByteBuf</code> 提供了许多优化和改进，使其更易于使用，例如：</p><ul><li><strong>读写指针分离：</strong> 独立的 <code>readerIndex</code> 和 <code>writerIndex</code>，避免了 <code>ByteBuffer</code> 复杂的 <code>flip()</code> 操作。</li><li><strong>动态扩容：</strong> 当容量不足时，可以自动扩容。</li><li><strong>零拷贝 (Zero-Copy)：</strong> 通过复合缓冲区（CompositeByteBuf）和切片（Slice）等机制，尽量减少数据在内存中的拷贝，提高性能。</li><li><strong>引用计数：</strong> 自动管理内存，防止内存泄漏。</li></ul><h3 id="Future-amp-Promise-异步结果与承诺"><a href="#Future-amp-Promise-异步结果与承诺" class="headerlink" title="Future &amp; Promise 异步结果与承诺"></a>Future &amp; Promise 异步结果与承诺</h3><ul><li><strong>Future:</strong> Java 并发包中的 <code>Future</code> 增强版。在 Netty 中，所有的 I/O 操作都是异步的，它们会立即返回一个 <code>ChannelFuture</code> 对象。你可以通过监听 <code>ChannelFuture</code> 来获取操作的最终结果（成功、失败或取消）。</li><li><strong>Promise:</strong> <code>Future</code> 的子接口，允许在某个点设置 <code>Future</code> 的结果，从而完成异步操作。</li></ul><h3 id="编解码器-Encoders-amp-Decoders"><a href="#编解码器-Encoders-amp-Decoders" class="headerlink" title="编解码器 (Encoders &amp; Decoders)"></a>编解码器 (Encoders &amp; Decoders)</h3><p><code>ChannelHandler</code> 的特殊形式，用于将原始字节数据转换为特定协议的消息对象，以及将消息对象转换回字节数据。</p><ul><li><strong>Decoder (入站):</strong> 将字节流解码成 Java 对象。</li><li><strong>Encoder (出站):</strong> 将 Java 对象编码成字节流。</li><li>Netty 提供了许多内置的编解码器（如 <code>StringEncoder</code>/<code>StringDecoder</code>、HTTP 编解码器），也支持自定义协议编解码。</li></ul><h2 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h2><p>关于 Netty 的问题通常会围绕其高性能、异步特性和核心组件展开。</p><p><strong>Netty 的优势和使用场景</strong></p><ul><li><strong>为什么用 Netty？</strong> 高性能、高并发、异步非阻塞、易于开发、稳定可靠、社区活跃。</li><li><strong>能用来做什么？</strong> RPC 框架（Dubbo、gRPC）、IM 系统、游戏服务器、大数据传输、消息中间件、HTTP 服务器、WebSocket 服务器、代理服务器等。</li></ul><ol><li><p><strong>Netty 的线程模型</strong></p><ul><li><strong>EventLoopGroup (Boss/Worker) 的作用？</strong> </li><li><strong>BossGroup (或 AcceptorGroup)</strong>：主要负责<strong>处理客户端的连接请求</strong>。当有新的客户端连接到来时，BossGroup 中的一个 <code>EventLoop</code> 会接受这个连接，并将其注册到 WorkerGroup 中的一个 <code>EventLoop</code> 上。BossGroup 通常只需要一个或少数 <code>EventLoop</code>。</li><li><strong>WorkerGroup</strong>：负责处理<strong>已建立连接的 I/O 读写事件和业务逻辑</strong>。WorkerGroup 包含多个 <code>EventLoop</code>，每个 <code>EventLoop</code> 都可以处理多个 <code>Channel</code>（连接）上的事件。</li></ul><p><strong>Channel 分配机制：</strong> 当 BossGroup 接受一个新连接后，它会使用一个<strong>轮询（Round-Robin）或其他策略，将这个新连接（<code>Channel</code>）注册到 WorkerGroup 中一个特定的 EventLoop</strong> 上。一旦一个 <code>Channel</code> 被分配给某个 <code>EventLoop</code>，该 <code>Channel</code> 的所有后续 I/O 事件（读、写、关闭等）都将由这个 <code>EventLoop</code> 线程负责处理，从而保证了单个 <code>Channel</code> 的事件处理是<strong>线程安全的和有序的</strong></p><ul><li><p><strong>为什么是单线程 EventLoop？</strong></p><p> 避免了多线程并发访问 <code>Channel</code> 带来的同步开销和复杂性，简化了并发编程模型。一个 <code>Channel</code> 上的所有事件都由同一个 <code>EventLoop</code> 线程顺序处理，保证了事件的顺序性。</p></li><li><p><strong>I/O 线程和业务线程分离：</strong> 业务逻辑如果在 <code>ChannelHandler</code> 中耗时过长，会阻塞 <code>EventLoop</code> 线程，影响其他 Channel 的 I/O 处理。如何解决？（使用 <code>EventLoop.execute()</code> 提交任务到 EventLoop 线程，或使用 <code>EventLoopGroup</code> 的 <code>next().submit()</code> 提交到另一个线程池）。</p></li></ul><p>如果 <code>ChannelHandler</code> 中的业务逻辑执行时间过长，确实会阻塞 <code>EventLoop</code> 线程，导致该 <code>EventLoop</code> 负责的其他 <code>Channel</code> 的 I/O 事件无法及时处理，影响系统的响应性和吞吐量。解决这个问题通常有两种方法：</p><ol><li><strong>提交任务到 EventLoop 线程：</strong> 对于一些轻量级但又不希望立即执行的任务，可以通过 <code>EventLoop.execute(Runnable task)</code> 或 <code>EventLoop.submit(Callable&lt;T&gt; task)</code> 将任务提交到 <code>EventLoop</code> 自身维护的任务队列中。这些任务会在 I/O 操作空闲时被 <code>EventLoop</code> 线程顺序执行，但如果任务依然耗时，仍可能阻塞。</li><li><strong>使用独立的业务线程池：</strong> 这是更常用的方法，适用于耗时长的业务逻辑。在 <code>ChannelHandler</code> 中，当接收到消息并需要进行耗时操作时，不直接在 <code>EventLoop</code> 线程中执行，而是将该业务逻辑<strong>提交到一个独立的业务线程池（例如 <code>ThreadPoolExecutor</code>）</strong>中执行。当业务逻辑处理完成后，再将结果通过 <code>ChannelHandlerContext</code> 写回 <code>Channel</code>。</li></ol></li><li><p><strong>ChannelPipeline 和 ChannelHandler</strong></p><ul><li><strong>ChannelPipeline 是什么？</strong> </li></ul><p><strong>ChannelPipeline</strong> 是一个 <code>ChannelHandler</code> 的有序链表。每个 <code>Channel</code> 都有且只有一个 <code>ChannelPipeline</code>。它扮演着事件处理的<strong>责任链</strong>角色，负责协调和管理 <code>ChannelHandler</code> 的执行顺序。</p><p>双向链表的设计是为了支持消息流的<strong>双向性</strong>：</p><ul><li><strong>入站事件 (Inbound Event)</strong>：数据从网络流入应用程序（例如客户端发送数据到服务器），事件从 <code>ChannelPipeline</code> 的<strong>头部</strong>（第一个 <code>ChannelHandler</code>）开始，依次向后传递。</li><li><p><strong>出站事件 (Outbound Event)</strong>：数据从应用程序流出到网络（例如服务器向客户端发送响应），事件从 <code>ChannelPipeline</code> 的<strong>尾部</strong>（通常是业务逻辑触发 <code>write</code> 操作）开始，依次向前传递</p></li><li><p><strong><code>ChannelInboundHandler</code> 和 <code>ChannelOutboundHandler</code> 的区别？</strong> </p></li></ul><p><strong><code>ChannelInboundHandler</code> (入站处理器)：</strong></p><ul><li><strong>职责：</strong> 主要处理从网络端流入到应用程序的事件，例如：连接激活 (<code>channelActive()</code>)、读取数据 (<code>channelRead()</code>)、连接断开 (<code>channelInactive()</code>)、处理异常 (<code>exceptionCaught()</code>) 等。</li><li><strong>处理顺序：</strong> 在 <code>ChannelPipeline</code> 中，入站事件从<strong>头部向尾部</strong>流动，依次经过每个 <code>ChannelInboundHandler</code>。</li></ul><p><strong><code>ChannelOutboundHandler</code> (出站处理器)：</strong></p><ul><li><strong>职责：</strong> 主要处理从应用程序流出到网络端的事件，例如：写入数据 (<code>write()</code>)、连接 (<code>connect()</code>)、绑定 (<code>bind()</code>)、关闭 (<code>close()</code>) 等。</li><li><p><strong>处理顺序：</strong> 在 <code>ChannelPipeline</code> 中，出站事件从<strong>尾部向头部</strong>流动，依次经过每个 <code>ChannelOutboundHandler</code>。</p></li><li><p><strong>如何自定义 Handler？</strong> 常见的 <code>SimpleChannelInboundHandler</code> 和 <code>ChannelDuplexHandler</code>。</p></li><li><strong><code>ChannelHandlerContext</code> 的作用？</strong> 用于与 Pipeline 中的其他 Handler 交互，以及触发事件。</li></ul><p><strong>ChannelHandlerContext</strong> 是 <code>ChannelHandler</code> 与 <code>ChannelPipeline</code> 以及其他 <code>ChannelHandler</code> 之间交互的桥梁。每个 <code>ChannelHandler</code> 被添加到 <code>ChannelPipeline</code> 时，都会创建一个对应的 <code>ChannelHandlerContext</code> 实例。</p><ul><li><strong>消息在 Pipeline 中传递的机制？</strong> <code>fireChannelRead()</code>、<code>write()</code> 等方法。</li></ul></li><li><p><strong>ByteBuf 内存管理</strong></p><ul><li><strong>为什么不用 <code>ByteBuffer</code> 而用 <code>ByteBuf</code>？</strong> 读写指针分离、动态扩容、引用计数、零拷贝。</li><li><strong><code>readerIndex</code> 和 <code>writerIndex</code>？</strong> 如何操作数据？</li><li><strong><code>ByteBuf</code> 的引用计数？</strong> 为什么重要？如何避免内存泄漏？（<code>retain()</code> 和 <code>release()</code>）</li><li><strong>堆内存 (Heap ByteBuf) 和直接内存 (Direct ByteBuf) 的区别？</strong> 优缺点？什么时候用哪个？（Direct ByteBuf 减少一次拷贝，适用于大文件传输；Heap ByteBuf 更易于 GC）。</li></ul></li><li><p><strong>零拷贝 (Zero-Copy)</strong></p><ul><li><strong>Netty 如何实现零拷贝？</strong> 概念、<code>FileRegion</code>、<code>CompositeByteBuf</code>、<code>ByteBuf.slice()</code>。</li><li><strong>零拷贝的优势？</strong> 减少 CPU 拷贝，提高 I/O 性能。</li></ul><h4 id="什么是-TCP-粘包-拆包？Netty-是如何解决的？"><a href="#什么是-TCP-粘包-拆包？Netty-是如何解决的？" class="headerlink" title="什么是 TCP 粘包/拆包？Netty 是如何解决的？"></a>什么是 TCP 粘包/拆包？Netty 是如何解决的？</h4><p><strong>回答要点：</strong></p><ul><li><strong>什么是粘包/拆包？</strong><ul><li>TCP 是一个<strong>流式协议</strong>，它不保证每次 <code>read()</code> 或 <code>write()</code> 系统调用对应一个完整的应用层消息。它会把应用层发送的数据看作一个字节流，可能会将小的消息合并（<strong>粘包</strong>）成一个大的 TCP 包发送，也可能将一个大的应用层消息拆分成多个小的 TCP 包（<strong>拆包</strong>）发送。</li><li><strong>粘包：</strong> 发送方发送了两个独立的小消息 A 和 B，TCP 层可能将它们合并成一个数据包发送，接收方一次性收到 A+B。</li><li><strong>拆包：</strong> 发送方发送一个大的消息 C，TCP 层可能将其拆分成多个数据包发送，接收方需要多次读取才能得到完整的 C。</li></ul></li><li><strong>为什么会发生？</strong><ul><li>TCP 缓冲区机制。</li><li>Nagle 算法（小数据包合并）。</li><li>发送方每次发送的数据量与接收方每次读取的数据量不一致。</li></ul></li><li><strong>Netty 如何解决？</strong><ul><li>Netty 不直接在 TCP 层解决，而是在<strong>应用层</strong>通过<strong>编解码器（Decoder）</strong>来解决。它提供了多种开箱即用的 <code>ChannelInboundHandler</code>（解码器），用于根据特定的应用层协议规则来解析字节流，将原始字节数据正确地分割成完整的、逻辑上的消息帧：<ul><li><strong><code>FixedLengthFrameDecoder</code>：</strong> 固定长度帧解码器，按照预设的固定长度切分消息。</li><li><strong><code>LineBasedFrameDecoder</code>：</strong> 行解码器，根据换行符（<code>\n</code> 或 <code>\r\n</code>）切分消息。</li><li><strong><code>DelimiterBasedFrameDecoder</code>：</strong> 分隔符解码器，根据用户指定的特殊分隔符切分消息。</li><li><strong><code>LengthFieldBasedFrameDecoder</code>：</strong> <strong>基于长度字段的帧解码器</strong>（最常用和推荐），在消息的头部包含一个表示消息体长度的字段。解码器会先读取这个长度字段，然后等待足够的数据到达，再截取对应长度的消息体。</li></ul></li></ul></li></ul></li><li><p><strong>编解码器 (Encoders/Decoders)</strong></p><ul><li><strong>编解码器的作用？</strong> 为什么需要它们？</li><li><strong>与 <code>ChannelHandler</code> 的关系？</strong></li></ul></li><li><p><strong>Netty 的异步特性</strong></p><ul><li><strong>I/O 操作都是异步的，如何获取结果？</strong> <code>ChannelFuture</code> 和 <code>ChannelFutureListener</code>。</li><li><strong><code>Promise</code> 和 <code>Future</code> 的区别？</strong></li></ul></li><li><p><strong>与 Java NIO 的关系和区别</strong></p><ul><li><strong>Netty 是对 Java NIO 的封装和增强，解决了哪些 NIO 的痛点？</strong> (API 复杂、Selector Bug、缓冲区管理困难、多线程处理等)。</li></ul></li><li><p><strong>Netty 的连接管理和心跳机制</strong></p><ul><li><strong>IdleStateHandler：</strong> 如何检测连接空闲？</li><li><strong>心跳消息：</strong> 如何实现客户端和服务端的心跳？</li></ul><p><strong><code>IdleStateHandler</code></strong> 是 Netty 提供的一个 <code>ChannelHandler</code>，用于检测连接的空闲状态（即在指定时间内没有读或写操作发生）。</p><ul><li><strong>原理：</strong> <code>IdleStateHandler</code> 会在 <code>ChannelPipeline</code> 中维护一个定时任务。当连接在指定的 <code>readerIdleTime</code>（读空闲时间）、<code>writerIdleTime</code>（写空闲时间）或 <code>allIdleTime</code>（总空闲时间）内没有相应的 I/O 操作时，它会触发一个 <strong><code>IdleStateEvent</code></strong> 事件，并将其传递到 <code>ChannelPipeline</code> 的下一个 <code>ChannelInboundHandler</code>。</li><li><strong>使用方式：</strong> 通常，你需要在 <code>IdleStateHandler</code> 之后再添加一个自定义的 <code>ChannelInboundHandler</code>（例如继承 <code>ChannelInboundHandlerAdapter</code>），并重写其 <code>userEventTriggered(ChannelHandlerContext ctx, Object evt)</code> 方法来捕获并处理 <code>IdleStateEvent</code>。</li></ul><p>心跳消息是利用 <code>IdleStateHandler</code> 检测到的空闲状态，在客户端或服务端发送的周期性短消息，用于维持连接的活性、检测连接的可用性以及防止因长时间空闲而被防火墙或路由器关闭。</p><p><strong>实现步骤：</strong></p><ol><li><strong>添加 <code>IdleStateHandler</code>：</strong> 在客户端和服务器端的 <code>ChannelPipeline</code> 中都添加 <code>IdleStateHandler</code>，配置合适的读/写/总空闲时间。</li><li><strong>自定义 <code>HeartbeatHandler</code>：</strong> 在 <code>IdleStateHandler</code> 之后添加一个自定义的 <code>ChannelInboundHandler</code>。</li><li><strong>处理 <code>IdleStateEvent</code>：</strong><ul><li><strong>客户端：</strong> 当检测到<strong>写空闲（<code>IdleState.WRITER_IDLE</code>）</strong>时，客户端发送一个心跳请求消息给服务器。</li><li><strong>服务端：</strong> 当检测到<strong>读空闲（<code>IdleState.READER_IDLE</code>）</strong>时，表示客户端可能已经断开或处于异常状态。此时，服务器可以发送一个心跳响应消息，或直接关闭连接。如果服务器也发送了心跳请求，它会期望客户端在指定时间内返回响应。</li></ul></li><li><strong>心跳消息的响应：</strong><ul><li>服务端收到心跳请求后，应该立即回复一个心跳响应消息。</li><li>客户端收到心跳响应后，确认连接正常。</li></ul></li><li><strong>超时处理：</strong><ul><li>如果在发送心跳请求后，在规定时间内没有收到心跳响应，则认为连接已断开，可以主动关闭连接。这通常在 <code>HeartbeatHandler</code> 中通过计数器实现。</li></ul></li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建两个线程组 boosGroup、workerGroup</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务端的启动对象，设置参数</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">//设置两个线程组boosGroup和workerGroup</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                <span class="comment">//设置服务端通道实现类型    </span></span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">//设置线程队列得到连接个数    </span></span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                <span class="comment">//设置保持活动连接状态    </span></span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                <span class="comment">//使用匿名内部类的形式初始化通道对象    </span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//给pipeline管道设置处理器</span></span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);<span class="comment">//给workerGroup的EventLoop对应的管道设置处理器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;java技术爱好者的服务端已经准备就绪...&quot;</span>);</span><br><span class="line">            <span class="comment">//绑定端口号，启动服务端</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.bind(<span class="number">6666</span>).sync();</span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><p>MongoDB 是一款流行的<strong>NoSQL 文档型数据库</strong>，以其<strong>灵活的数据模型、可伸缩性和高性能</strong>而闻名。它广泛应用于需要处理大量非结构化或半结构化数据、以及需要快速迭代的应用场景。在面试中，MongoDB 经常作为后端数据存储、大数据或微服务架构中的组件被提及。</p><h2 id="关键概念-1"><a href="#关键概念-1" class="headerlink" title="关键概念"></a>关键概念</h2><p><strong>Document (文档)</strong></p><ul><li><strong>核心单位：</strong> 文档是 MongoDB 中数据的基本单位，类似于关系型数据库中的<strong>行 (row)</strong>。</li><li><strong>JSON-like 格式：</strong> 文档以类似 JSON 的 BSON (Binary JSON) 格式存储。BSON 支持更多的数据类型（如日期、二进制数据）并且是二进制编码，这使得存储和传输更高效。</li><li><strong>无模式 (Schemaless/Schema-less)：</strong> 这是 MongoDB 最重要的特性之一。同一个集合中的文档可以拥有不同的字段，字段的类型也可以不同。这提供了极大的灵活性，方便快速迭代和适应变化的需求。</li><li><strong>面试点：</strong> 理解文档是 MongoDB 的核心，其无模式特性提供了灵活性</li></ul><p><strong>Collection (集合)</strong></p><ul><li><strong>逻辑分组：</strong> 集合是文档的逻辑分组，类似于关系型数据库中的<strong>表 (table)</strong>。</li><li><strong>无固定结构：</strong> 集合不强制文档的结构，但通常同一集合中的文档会包含类似或相关的数据。</li><li><strong>面试点：</strong> 知道集合是文档的容器，其无模式特性与集合的关系。</li></ul><p><strong>Database (数据库)</strong></p><ul><li><strong>容器：</strong> 数据库是集合的物理容器，类似于关系型数据库中的<strong>数据库 (database)</strong>。</li><li><strong>多数据库：</strong> 一个 MongoDB 实例可以承载多个数据库。</li><li><strong>面试点：</strong> 数据库是组织集合的单元。</li></ul><p><strong>_id 字段</strong></p><ul><li><strong>主键：</strong> 每个文档在创建时都会自动生成一个唯一的 <code>_id</code> 字段作为其主键，除非你手动指定。</li><li><strong>ObjectID：</strong> 默认情况下，<code>_id</code> 的类型是 <code>ObjectID</code>，它是一个 12 字节的 BSON 类型，结合了时间戳、机器标识符、进程 ID 和计数器，以确保全局唯一性。</li><li><strong>面试点：</strong> 了解 <code>_id</code> 的作用和 <code>ObjectID</code> 的组成。</li></ul><p><strong>Index (索引)</strong></p><ul><li><strong>提高查询效率：</strong> 索引是 MongoDB 提高查询性能的关键。它允许数据库快速定位数据，而无需扫描整个集合。</li><li><strong>种类：</strong> 支持单字段索引、复合索引、多键索引（用于数组字段）、文本索引（用于全文搜索）、地理空间索引等。</li><li><strong>面试点：</strong> 索引的重要性，以及不同类型索引的适用场景。<strong>复合索引</strong>和<strong>多键索引</strong>是常考点。</li></ul><p><strong>Aggregation (聚合)</strong></p><ul><li><strong>数据处理：</strong> 聚合操作允许你对数据进行复杂的处理，如分组、筛选、转换、计算等，以生成汇总报告或分析结果。</li><li><strong>聚合管道 (Aggregation Pipeline)：</strong> 这是 MongoDB 最强大的聚合工具。它由一系列阶段 (stages) 组成，数据在这些阶段中依次处理，每个阶段的输出作为下一个阶段的输入。</li><li><strong>面试点：</strong> 理解聚合管道的工作原理，常用阶段（<code>$match</code>, <code>$group</code>, <code>$project</code>, <code>$sort</code>, <code>$limit</code>, <code>$unwind</code>）及其用途。</li></ul><p><strong>Replication (副本集)</strong></p><ul><li><strong>高可用性与数据冗余：</strong> 副本集是 MongoDB 提供<strong>高可用性</strong>和<strong>数据冗余</strong>的机制。它是一组维护相同数据集的 MongoDB 实例。</li><li><strong>Primary-Secondary 架构：</strong> 副本集中有一个主节点 (Primary)，负责处理所有写入操作和读操作。其他是从节点 (Secondary)，它们复制主节点的数据，并可以处理读操作（如果配置允许）。</li><li><strong>自动故障转移：</strong> 当主节点发生故障时，副本集会自动选举一个从节点成为新的主节点，从而保证服务持续可用。</li><li><strong>面试点：</strong> <strong>高频考点。</strong> 理解副本集的工作原理，主从节点的作用，以及自动故障转移过程。</li></ul><p><strong>Sharding (分片)</strong></p><ul><li><strong>水平扩展：</strong> 分片是 MongoDB 提供<strong>水平扩展</strong>的方式，用于处理大量数据和高吞吐量操作。它将数据分布在多个独立的服务器（称为分片或 Shard）上。</li><li><strong>组成：</strong><ul><li><strong>Shard (分片)：</strong> 存储部分数据的独立副本集。</li><li><strong>Config Server (配置服务器)：</strong> 存储集群的元数据（分片信息、数据分布规则）。</li><li><strong>Mongos (路由进程)：</strong> 负责处理客户端请求，将请求路由到正确的分片，并聚合结果。</li></ul></li><li><strong>面试点：</strong> <strong>高频考点。</strong> 理解分片解决的问题（海量数据存储和高并发），以及分片集群的各个组件及其职责。</li></ul><p><strong>CRUD 操作 (Create, Read, Update, Delete)</strong></p><ul><li>MongoDB 提供了丰富的操作来对文档进行增删改查。</li><li><strong><code>insertOne()</code>, <code>insertMany()</code></strong>: 插入文档。</li><li><strong><code>find()</code>, <code>findOne()</code></strong>: 查询文档（支持强大的查询语言，包括嵌套文档查询、数组查询、聚合查询等）。</li><li><strong><code>updateOne()</code>, <code>updateMany()</code>, <code>replaceOne()</code></strong>: 更新文档。</li><li><strong><code>deleteOne()</code>, <code>deleteMany()</code></strong>: 删除文档。</li><li><strong>面试点：</strong> 熟悉基本的 CRUD 操作语法和常用查询方法。</li></ul><h2 id="关键问题-1"><a href="#关键问题-1" class="headerlink" title="关键问题"></a>关键问题</h2><h3 id="什么是-NoSQL-数据库？MongoDB-属于哪种-NoSQL-类型？"><a href="#什么是-NoSQL-数据库？MongoDB-属于哪种-NoSQL-类型？" class="headerlink" title="什么是 NoSQL 数据库？MongoDB 属于哪种 NoSQL 类型？"></a>什么是 NoSQL 数据库？MongoDB 属于哪种 NoSQL 类型？</h3><ul><li><p><strong>NoSQL 定义：</strong> Not Only SQL。它是一类不使用传统关系型数据库的表格模型存储数据的数据存储系统。NoSQL 数据库通常为了特定的数据模型和访问模式而优化，牺牲了部分关系型数据库的特性（如强 ACID 事务和 JOIN 操作）来换取更高的可伸缩性、灵活性和性能。</p></li><li><p><strong>MongoDB 类型：</strong> <strong>文档型数据库</strong>。数据以类似 JSON 的 BSON（Binary JSON）格式的文档形式存储</p><h3 id="MongoDB-的核心特点是什么？"><a href="#MongoDB-的核心特点是什么？" class="headerlink" title="MongoDB 的核心特点是什么？"></a>MongoDB 的核心特点是什么？</h3><ul><li><strong>文档模型：</strong> 数据以 BSON 格式的文档存储，结构灵活，无模式 (Schema-less)，易于开发迭代。</li><li><strong>高可用性：</strong> 通过<strong>副本集（Replica Set）</strong>实现自动故障转移和数据冗余。</li><li><strong>水平扩展：</strong> 通过<strong>分片（Sharding）</strong>技术将数据分布到多个服务器，处理海量数据和高并发。</li><li><strong>高性能：</strong> 文档模型、索引、内存映射文件等优化手段提供了出色的读写性能。</li><li><strong>丰富的查询语言：</strong> 支持强大的查询语言，包括嵌套文档查询、聚合框架等。</li></ul></li></ul><h3 id="MongoDB-的-id-字段有什么特殊之处？"><a href="#MongoDB-的-id-字段有什么特殊之处？" class="headerlink" title="MongoDB 的 _id 字段有什么特殊之处？"></a>MongoDB 的 <code>_id</code> 字段有什么特殊之处？</h3><ul><li><strong>主键：</strong> 每个 MongoDB 文档都必须包含一个 <code>_id</code> 字段，作为其在集合中的<strong>唯一主键</strong>。</li><li><strong>自动生成：</strong> 如果插入文档时未指定 <code>_id</code>，MongoDB 会自动生成一个 <code>ObjectID</code> 作为其值。</li><li><strong>ObjectID 组成：</strong> <code>ObjectID</code> 是一个 12 字节的 BSON 类型，它包含时间戳、机器标识符、进程 ID 和一个计数器，确保了全局唯一性。</li><li><strong>不可变性：</strong> <code>_id</code> 字段的值一旦创建就不可更改。</li></ul><h3 id="什么是副本集（Replica-Set）？它有什么作用？"><a href="#什么是副本集（Replica-Set）？它有什么作用？" class="headerlink" title="什么是副本集（Replica Set）？它有什么作用？"></a>什么是副本集（Replica Set）？它有什么作用？</h3><ul><li><strong>定义：</strong> 副本集是一组维护相同数据集的 MongoDB 实例。它由一个<strong>主节点 (Primary)</strong> 和一个或多个<strong>从节点 (Secondary)</strong> 组成。</li><li><strong>作用：</strong><ul><li><strong>高可用性：</strong> 当主节点发生故障时，副本集会自动选举一个健康的从节点成为新的主节点，确保服务持续可用，避免单点故障。</li><li><strong>数据冗余：</strong> 从节点复制主节点的数据，提供数据的多份副本，防止数据丢失。</li><li><strong>读扩展：</strong> 可以配置从节点处理读请求（但要注意读的最终一致性），从而分散主节点的读负载。</li></ul></li><li><strong>工作原理简述：</strong> 所有写入操作都在主节点上进行，然后通过<strong>操作日志 (Oplog)</strong> 异步复制到所有从节点。</li></ul><h3 id="什么是分片（Sharding）？为什么要使用分片？"><a href="#什么是分片（Sharding）？为什么要使用分片？" class="headerlink" title="什么是分片（Sharding）？为什么要使用分片？"></a>什么是分片（Sharding）？为什么要使用分片？</h3><ul><li><strong>定义：</strong> 分片是一种<strong>水平扩展（Horizontal Scaling）\</strong>的技术。它将大型数据集分布存储到多个独立的数据库实例（即*<em>分片/Shard*</em>）上。</li><li><strong>为什么要用：</strong><ul><li><strong>处理海量数据：</strong> 单个服务器的存储容量和内存有限，分片可以突破这些限制。</li><li><strong>高并发和吞吐量：</strong> 将查询和写入负载分散到多个分片上，提高系统的整体吞吐量。</li><li><strong>降低成本：</strong> 可以使用更多的廉价服务器替代少数昂贵的高配服务器。</li></ul></li><li><strong>分片集群的组成：</strong><ul><li><strong>Shards (分片)：</strong> 存储部分数据的独立副本集。</li><li><strong>Config Servers (配置服务器)：</strong> 存储集群的元数据（分片信息、数据分布规则）。</li><li><strong>Mongos (路由进程)：</strong> 处理客户端请求，将请求路由到正确的分片，并聚合结果。</li></ul></li></ul><h3 id="解释-MongoDB-的数据模型设计：嵌入式文档（Embedded-Documents）与引用（References）的区别和选择。"><a href="#解释-MongoDB-的数据模型设计：嵌入式文档（Embedded-Documents）与引用（References）的区别和选择。" class="headerlink" title="解释 MongoDB 的数据模型设计：嵌入式文档（Embedded Documents）与引用（References）的区别和选择。"></a>解释 MongoDB 的数据模型设计：嵌入式文档（Embedded Documents）与引用（References）的区别和选择。</h3><ul><li><strong>嵌入式文档：</strong> 将相关数据直接嵌套存储在同一个文档中。<ul><li><strong>优点：</strong> 单次查询即可获取所有数据，读性能好；原子性操作（对单个文档的更新）。</li><li><strong>缺点：</strong> 单文档大小限制（16MB）；数据冗余（如果子文档被多处引用）；更新复杂性（大文档更新或增长）。</li><li><strong>适用场景：</strong> 一对一、一对多关系（子文档数量有限且不常变），数据紧密耦合且经常一起查询。</li></ul></li><li><strong>引用：</strong> 通过存储另一个文档的 <code>_id</code> 来建立文档间的关联，类似关系型数据库的外键。需要使用 <code>$lookup</code> 或在应用层进行多次查询来获取关联数据。<ul><li><strong>优点：</strong> 减少数据冗余；突破文档大小限制；灵活处理多对多关系。</li><li><strong>缺点：</strong> 需要多次查询或使用 <code>$lookup</code>，性能可能不如嵌入式文档；查询逻辑可能更复杂。</li><li><strong>适用场景：</strong> 多对多关系；一对多关系（子文档数量多且动态增长）；数据独立性强，不总是与父文档一起查询。</li></ul></li><li><strong>选择策略：</strong> 核心原则是<strong>“应用程序如何使用数据”</strong>。优先考虑将那些原子性高、总是被一起查询的数据<strong>嵌入</strong>到文档中。对于那些独立存在、会被大量引用或可能变得很大的数据，使用<strong>引用</strong>。</li></ul><h3 id="什么是-MongoDB-的索引？有哪些常用的索引类型？"><a href="#什么是-MongoDB-的索引？有哪些常用的索引类型？" class="headerlink" title="什么是 MongoDB 的索引？有哪些常用的索引类型？"></a>什么是 MongoDB 的索引？有哪些常用的索引类型？</h3><ul><li><strong>作用：</strong> 索引是提高查询性能的关键。它允许数据库快速定位到匹配查询条件的文档，而无需扫描整个集合。</li><li><strong>常用类型：</strong><ul><li><strong>单字段索引：</strong> 在单个字段上创建。</li><li><strong>复合索引 (Compound Index)：</strong> 在多个字段上创建，字段顺序很重要（最左前缀原则），支持多字段查询和排序。</li><li><strong>多键索引 (Multikey Index)：</strong> 自动为包含<strong>数组</strong>的字段创建，为数组中每个元素创建索引条目，支持对数组内容的查询。</li><li><strong>文本索引 (Text Index)：</strong> 支持对字符串内容进行全文搜索。</li><li><strong>地理空间索引 (Geospatial Index)：</strong> 支持地理位置数据（如点、线、多边形）的查询。</li><li><strong>TTL 索引 (Time-to-Live Index)：</strong> 自动删除特定时间后过期的文档。</li></ul></li></ul><h3 id="什么是聚合框架（Aggregation-Framework）？常用的聚合阶段有哪些？"><a href="#什么是聚合框架（Aggregation-Framework）？常用的聚合阶段有哪些？" class="headerlink" title="什么是聚合框架（Aggregation Framework）？常用的聚合阶段有哪些？"></a>什么是聚合框架（Aggregation Framework）？常用的聚合阶段有哪些？</h3><ul><li><strong>定义：</strong> 聚合框架是 MongoDB 中进行数据处理和分析的强大工具。它允许你通过一系列的<strong>管道阶段 (Pipeline Stages)</strong> 来转换和组合文档，生成聚合结果。</li><li><strong>常用阶段：</strong><ul><li><strong><code>$match</code>：</strong> 过滤文档，只将符合条件的文档传递到下一个阶段。</li><li><strong><code>$group</code>：</strong> 按指定字段对文档进行分组，并对每个组执行聚合操作（如 <code>$sum</code>, <code>$avg</code>, <code>$count</code>）。</li><li><strong><code>$project</code>：</strong> 重构文档的形状，可以选择、排除或添加新字段。</li><li><strong><code>$sort</code>：</strong> 对文档进行排序。</li><li><strong><code>$limit</code>：</strong> 限制通过管道的文档数量。</li><li><strong><code>$skip</code>：</strong> 跳过指定数量的文档。</li><li><strong><code>$unwind</code>：</strong> 将文档中的数组字段“解构”，为数组中的每个元素生成一个单独的文档。</li><li><strong><code>$lookup</code>：</strong> 执行左外连接，从另一个集合中获取关联文档。</li></ul></li></ul><h3 id="MongoDB-如何保证数据一致性（特别是事务）？"><a href="#MongoDB-如何保证数据一致性（特别是事务）？" class="headerlink" title="MongoDB 如何保证数据一致性（特别是事务）？"></a>MongoDB 如何保证数据一致性（特别是事务）？</h3><ul><li><strong>原子性：</strong> MongoDB 的写入操作（如 <code>insertOne()</code>, <code>updateOne()</code>）在<strong>单个文档级别</strong>是原子性的。</li><li><strong>事务（MongoDB 4.0+）：</strong> 从 MongoDB 4.0 开始，引入了<strong>多文档事务（Multi-Document Transactions）</strong>。这意味着你可以在多个文档、多个集合乃至多个分片上执行符合 ACID 的事务。<ul><li><strong>隔离级别：</strong> 通常提供快照隔离，确保事务期间的数据一致性。</li><li><strong>限制：</strong> 相较于关系型数据库的事务，仍有一些限制（如性能开销、超时）。</li></ul></li><li><strong>副本集的一致性：</strong> 副本集通过 Oplog 复制实现最终一致性。你可以通过<strong>读偏好（Read Preference）</strong>和<strong>写关注（Write Concern）</strong>来调整一致性级别。<ul><li><strong>读偏好：</strong> 决定从主节点还是从节点读取数据（如 <code>primary</code>, <code>primaryPreferred</code>, <code>secondary</code>, <code>secondaryPreferred</code>, <code>nearest</code>）。</li><li><strong>写关注：</strong> 决定写入操作成功需要多少个节点的确认（如 <code>w:1</code> 写入主节点，<code>w:majority</code> 写入多数节点）。</li></ul></li></ul><h3 id="MongoDB-的缺点或局限性是什么？"><a href="#MongoDB-的缺点或局限性是什么？" class="headerlink" title="MongoDB 的缺点或局限性是什么？"></a>MongoDB 的缺点或局限性是什么？</h3><ul><li><strong>Join 操作：</strong> 虽然有 <code>$lookup</code>，但其功能和性能不如关系型数据库的 JOIN 强大和灵活。复杂的跨集合查询可能需要多次 <code>$lookup</code> 或在应用层处理。</li><li><strong>事务复杂性：</strong> 4.0+ 虽引入了多文档事务，但相较于关系型数据库，仍有学习成本和性能考量。</li><li><strong>模式缺失：</strong> 虽然是优势，但有时也可能导致数据混乱，需要应用层严格管理数据结构。</li><li><strong>数据冗余：</strong> 为了查询性能，可能需要牺牲范式化，导致数据冗余。</li><li><strong>内存使用：</strong> 有些操作（如排序、聚合）可能需要大量内存。</li></ul><h3 id="什么时候会选择-MongoDB-而不是关系型数据库？什么时候不选择？"><a href="#什么时候会选择-MongoDB-而不是关系型数据库？什么时候不选择？" class="headerlink" title="什么时候会选择 MongoDB 而不是关系型数据库？什么时候不选择？"></a>什么时候会选择 MongoDB 而不是关系型数据库？什么时候不选择？</h3><ul><li><strong>选择 MongoDB 的场景：</strong><ul><li>数据结构不固定，需要灵活的模式（Schema-less）。</li><li>高并发写入和大数据量存储。</li><li>需要水平扩展来应对业务增长。</li><li>对读性能要求高，且数据关联性不复杂。</li><li>需要存储非结构化或半结构化数据（如日志、用户画像、IoT 数据）。</li></ul></li><li><strong>不选择 MongoDB 的场景：</strong><ul><li>需要复杂的、跨多表的 JOIN 查询。</li><li>需要强事务一致性，尤其是有复杂的、跨多文档的 ACID 事务。</li><li>严格的范式化数据结构。</li><li>传统的 OLTP 业务，数据模型稳定且关联复杂。</li></ul></li></ul><h3 id="如何进行-MongoDB-的性能优化？"><a href="#如何进行-MongoDB-的性能优化？" class="headerlink" title="如何进行 MongoDB 的性能优化？"></a>如何进行 MongoDB 的性能优化？</h3><ul><li><strong>创建合适的索引：</strong> 根据查询模式创建单字段、复合、多键、文本等索引。</li><li><strong>优化查询：</strong> 避免全表扫描，使用 <code>$explain</code> 分析查询性能。</li><li><strong>数据模型设计：</strong> 合理选择嵌入式文档或引用，避免深层嵌套。</li><li><strong>读写分离：</strong> 利用副本集实现读写分离。</li><li><strong>分片：</strong> 针对大规模数据和高并发场景。</li><li><strong>硬件优化：</strong> 足够的内存（MongoDB 尽可能将数据放在内存中）、SSD 硬盘。</li><li><strong>聚合管道优化：</strong> 将 <code>$match</code> 放在管道前面尽可能过滤数据。</li></ul><h3 id="嵌入式文档与lookup操作"><a href="#嵌入式文档与lookup操作" class="headerlink" title="嵌入式文档与lookup操作"></a>嵌入式文档与lookup操作</h3><p>嵌入式文档是指一个文档内部包含另一个文档（或多个文档）。这意味着相关的子数据直接存储在父文档中，而不是作为单独的文档存储在另一个集合中并通过引用关联。</p><p><code>$lookup</code> 是 MongoDB 聚合管道（Aggregation Pipeline）中的一个阶段，它允许你执行<strong>左外连接（Left Outer Join）</strong>，从一个集合中的文档获取相关数据，并将其合并到另一个集合的文档中。</p><p>面试时，面试官通常会考察你如何根据业务场景和数据访问模式来选择嵌入式文档或引用加 <code>$lookup</code>。</p><ol><li><strong>数据的关联性/紧密性：</strong><ul><li>如果数据是<strong>强关联且总是被一起访问</strong>（例如，用户的地址和用户一起读取），优先考虑<strong>嵌入式文档</strong>。</li><li>如果数据是<strong>弱关联，或者不总是被一起访问</strong>（例如，订单中的商品详情，用户可能只看订单列表不看详情），考虑<strong>引用 + <code>$lookup</code></strong>。</li></ul></li><li><strong>读写模式：</strong><ul><li><strong>读多写少，且一起读：</strong> <strong>嵌入式文档</strong>通常性能更优。</li><li><strong>写入频繁，且子文档会被重复引用：</strong> <strong>引用 + <code>$lookup</code></strong> 可以减少数据冗余和更新复杂性。</li></ul></li><li><strong>数据大小和增长：</strong><ul><li>如果嵌入的子文档会<strong>变得非常大</strong>或者<strong>数量无限增长</strong>（接近 16MB 限制），使用<strong>引用 + <code>$lookup</code></strong>。</li><li>如果子文档<strong>相对较小且数量有限</strong>，可以考虑<strong>嵌入式文档</strong>。</li></ul></li><li><strong>一致性和原子性要求：</strong><ul><li>对<strong>强一致性要求高且需要原子操作</strong>的内部数据，<strong>嵌入式文档</strong>更安全。</li><li>涉及到<strong>多个集合的关联数据</strong>，通常需要应用层或 MongoDB 4.0+ 的多文档事务来保证一致性（如果使用引用）。</li></ul></li><li><strong>业务逻辑复杂性：</strong><ul><li>简单的聚合或联接，<code>$lookup</code> 也可以接受。</li><li>非常复杂的联接或需要跨集合的多次查询，可能需要重新评估数据模型或考虑将部分处理逻辑放到应用层。</li></ul></li></ol><h1 id="Elastic-Search"><a href="#Elastic-Search" class="headerlink" title="Elastic Search"></a>Elastic Search</h1><p>Elasticsearch 是一个基于 Apache Lucene 的分布式、RESTful 风格的搜索和分析引擎。它以其<strong>速度快、可伸缩性强</strong>以及能够处理<strong>海量数据</strong>而闻名。在面试中，Elasticsearch 经常作为大数据、搜索或微服务架构中的关键组件被问到。</p><p>ELK Stack (Elasticsearch, Logstash, Kibana) 技术栈核心</p><h2 id="关键概念-2"><a href="#关键概念-2" class="headerlink" title="关键概念"></a>关键概念</h2><p><img data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/elasticsearch/rumen-ad2b2f8c-5a19-4c5e-9bc7-cf7ba17830bf.jpg" alt="img"></p><p><strong>节点</strong></p><p>一个 Elasticsearch 实例就是一个节点。每个节点都有一个名称。</p><p>主要节点类型：</p><ul><li><strong>Master Node (主节点)</strong>：负责集群的管理任务，如创建/删除索引、跟踪节点状态、分片分配等。一个集群中只能有一个主节点，但可以有多个符合主节点条件的节点（master-eligible node）。</li><li><strong>Data Node (数据节点)</strong>：存储数据（分片）并执行数据相关操作（CRUD、搜索、聚合）。</li><li><strong>Ingest Node (摄入节点)</strong>：执行预处理管道，转换文档。</li><li><strong>Coordinating Node (协调节点)</strong>：默认所有节点都是协调节点，负责接收客户端请求，将请求路由到正确的数据节点，并汇集各数据节点的结果返回给客户端。</li></ul><p><strong>Cluster (集群)</strong></p><ul><li>一个集群由一个或多个<strong>节点 (Node)</strong> 组成，它们共同存储数据并提供索引和搜索能力。</li><li><strong>目的：</strong> 提供高可用性、可伸缩性和容错性。</li><li><strong>面试点：</strong> 知道集群如何协同工作，以及其分布式特性。</li></ul><p><strong>Document (文档)</strong></p><ul><li>类似关系数据库中的<strong>行 (row)</strong>。它是可被索引的最小单位。</li><li><strong>JSON 格式：</strong> 文档以 JSON (JavaScript Object Notation) 格式表示。</li><li><strong>唯一 ID：</strong> 每个文档在它所属的索引中都有一个唯一的 ID。</li><li><strong>面试点：</strong> 理解文档是 Elasticsearch 存储和搜索的原子单元。</li></ul><p><strong>Index (索引)</strong></p><ul><li>类似关系数据库中的<strong>数据库 (database)</strong>。它是拥有相似特性的文档的集合。</li><li><strong>逻辑概念：</strong> 一个索引实际上在物理上分布在多个<strong>分片 (Shard)</strong> 上。</li><li><strong>面试点：</strong> 理解索引是逻辑上的分组，是可搜索的最高层级。</li></ul><p><strong>Type (类型)</strong> - <strong>在 Elasticsearch 7.x 及更高版本中已废弃！</strong></p><ul><li>在 6.x 及以前版本中，一个索引可以包含多个类型，类似关系数据库中的<strong>表 (table)</strong>。</li><li><strong>面试点：</strong> <strong>强调它已被废弃，并解释原因</strong>（Mapping 冲突、性能问题）。对于 7.x+ 版本，一个索引通常只对应一个类型或根本没有显式类型。</li></ul><p><strong>Field (字段)</strong></p><ul><li>类似关系数据库中的<strong>列 (column)</strong>。文档由多个字段组成。</li><li><strong>面试点：</strong> 字段是文档中的基本数据单元</li></ul><p><strong>Mapping (映射)</strong></p><ul><li>类似关系数据库中的<strong>表结构 (schema)</strong>。它定义了文档及其字段的类型、如何存储以及如何被索引。</li><li><strong>动态映射：</strong> Elasticsearch 默认支持动态映射，即当你索引一个新文档时，如果其中包含新的字段，Elasticsearch 会尝试猜测其数据类型并自动创建映射。</li><li><strong>显式映射：</strong> 最佳实践是显式定义映射，特别是对于文本字段，以控制它们的分析方式。</li><li><strong>面试点：</strong> 理解 Mapping 的作用，以及动态映射和显式映射的区别。<code>keyword</code> 和 <code>text</code> 类型字段的区别是高频考点。<ul><li><strong><code>text</code> 类型：</strong> 用于全文本字段，会被分词器处理（例如，”Hello World” 可能被分成 “hello” 和 “world”）。可用于全文搜索。</li><li><strong><code>keyword</code> 类型：</strong> 用于结构化数据（如 ID、标签、国家代码），不会被分词。适用于过滤、聚合、排序。</li></ul></li></ul><p><strong>Shard (分片)</strong></p><ul><li><strong>物理存储单元：</strong> 一个索引的数据被分成多个分片。每个分片都是一个独立的 Lucene 索引。</li><li><strong>目的：</strong><ul><li><strong>横向扩展：</strong> 允许你水平扩展存储容量和吞吐量。</li><li><strong>并行处理：</strong> 允许在多个节点上并行执行搜索和聚合操作，提高性能。</li></ul></li><li><strong>主分片 (Primary Shard)：</strong> 存储原始数据。</li><li><strong>副本分片 (Replica Shard)：</strong> 主分片的副本，用于提供高可用性（当主分片失效时可以提升为新主分片）和提升搜索吞吐量。</li><li><strong>面试点：</strong> <strong>高频考点</strong>。理解分片是 Elasticsearch 可伸缩和高可用的基石。区分主分片和副本分片的作用，以及它们如何分布在集群中</li></ul><p><strong>Replicas (副本)</strong></p><ul><li><strong>作用：</strong> 副本分片是主分片的精确拷贝。</li><li><strong>目的：</strong><ul><li><strong>高可用性：</strong> 当某个节点上的主分片失败时，副本可以立即提升为新的主分片，确保数据不丢失和服务的连续性。</li><li><strong>提高查询性能：</strong> 搜索请求可以同时在主分片和其副本分片上执行，分散负载，提高吞吐量。</li></ul></li><li><strong>面试点：</strong> 理解副本如何保障高可用和提升查询性能，以及副本数量的设置对存储和查询性能的影响。</li></ul><p><strong>Analysers (分析器)</strong></p><ul><li><strong>作用：</strong> 在索引文本数据时，将原始文本转换为可搜索的<strong>词项 (terms)</strong> 的过程。</li><li><strong>组成：</strong> 由一个<strong>字符过滤器 (character filters)</strong>、一个<strong>分词器 (tokenizer)</strong> 和零个或多个<strong>词项过滤器 (token filters)</strong> 组成。</li><li><strong>面试点：</strong> 理解分析器在全文搜索中的重要性。常见的分析器如 <code>standard</code> 分析器。能解释分词（tokenization）和词项过滤（如小写转换、停用词移除、同义词处理）的概念。</li></ul><p><strong>Query DSL (查询领域特定语言)</strong></p><ul><li>Elasticsearch 强大的查询语言，基于 JSON。</li><li><strong>面试点：</strong> 知道如何使用 Query DSL 进行各种复杂的搜索，如全文搜索、词语匹配、范围查询、布尔组合查询等。</li></ul><p><strong>Aggregations (聚合)</strong></p><ul><li>Elasticsearch 强大的统计分析功能。允许你从数据中提取和计算出复杂的统计信息，例如分组、求和、平均值、最大/最小值等。</li><li><strong>面试点：</strong> 了解聚合的用途，例如用于仪表盘、统计报表等。</li></ul><h2 id="关键问题-2"><a href="#关键问题-2" class="headerlink" title="关键问题"></a>关键问题</h2><h3 id="什么是-Elasticsearch？它的核心特点是什么？"><a href="#什么是-Elasticsearch？它的核心特点是什么？" class="headerlink" title="什么是 Elasticsearch？它的核心特点是什么？"></a>什么是 Elasticsearch？它的核心特点是什么？</h3><ul><li><strong>定义：</strong> Elasticsearch 是一个基于 Apache Lucene 的<strong>分布式、RESTful 风格的搜索和分析引擎</strong>。</li><li><strong>核心特点：</strong><ul><li><strong>分布式：</strong> 能够横向扩展，处理海量数据。</li><li><strong>近实时（Near Real-time）：</strong> 数据从索引到可搜索只有毫秒级的延迟。</li><li><strong>高可用和可伸缩：</strong> 通过集群、分片和副本机制提供。</li><li><strong>RESTful API：</strong> 通过 HTTP 和 JSON 进行交互，易于使用。</li><li><strong>全文搜索：</strong> 强大的全文搜索能力，支持复杂查询。</li><li><strong>聚合分析：</strong> 强大的聚合功能，用于数据分析和报表。</li></ul></li></ul><h3 id="请解释-Elasticsearch-中的集群（Cluster）、节点（Node）、索引（Index）、类型（Type-已废弃）、文档（Document）和字段（Field）之间的关系和作用。"><a href="#请解释-Elasticsearch-中的集群（Cluster）、节点（Node）、索引（Index）、类型（Type-已废弃）、文档（Document）和字段（Field）之间的关系和作用。" class="headerlink" title="请解释 Elasticsearch 中的集群（Cluster）、节点（Node）、索引（Index）、类型（Type - 已废弃）、文档（Document）和字段（Field）之间的关系和作用。"></a>请解释 Elasticsearch 中的集群（Cluster）、节点（Node）、索引（Index）、类型（Type - 已废弃）、文档（Document）和字段（Field）之间的关系和作用。</h3><ul><li><strong>集群 (Cluster)：</strong> 一个或多个节点的集合，共同存储数据并提供搜索和分析功能。是 Elasticsearch 的最高逻辑单位。</li><li><strong>节点 (Node)：</strong> 一个 Elasticsearch 实例。每个节点在集群中扮演不同角色（如 Master 节点、Data 节点、Ingest 节点、Coordinating 节点）。</li><li><strong>索引 (Index)：</strong> 逻辑上相关文档的集合，类似关系型数据库的<strong>数据库</strong>。物理上，一个索引由一个或多个<strong>分片 (Shard)</strong> 组成。</li><li><strong>类型 (Type)：</strong> <strong>在 Elasticsearch 7.x 及更高版本中已废弃！</strong> 在 6.x 及以前版本中，类型是索引下的逻辑分组，类似关系型数据库的<strong>表</strong>。面试时务必强调其已废弃。</li><li><strong>文档 (Document)：</strong> 可被索引的最小数据单元，以 JSON 格式表示，类似关系型数据库的<strong>行</strong>。每个文档都有一个唯一的 ID。</li><li><strong>字段 (Field)：</strong> 文档中的数据单元，类似关系型数据库的<strong>列</strong>。</li></ul><h3 id="Elasticsearch-中的分片（Shard）和副本（Replica）有什么作用？它们如何实现高可用和可伸缩？"><a href="#Elasticsearch-中的分片（Shard）和副本（Replica）有什么作用？它们如何实现高可用和可伸缩？" class="headerlink" title="Elasticsearch 中的分片（Shard）和副本（Replica）有什么作用？它们如何实现高可用和可伸缩？"></a>Elasticsearch 中的<strong>分片（Shard）</strong>和<strong>副本（Replica）</strong>有什么作用？它们如何实现高可用和可伸缩？</h3><ul><li><strong>分片 (Shard)：</strong><ul><li><strong>作用：</strong> 是一个索引的<strong>物理存储单元</strong>，一个 Lucene 索引。一个索引被分成多个分片，这些分片可以分布在集群的不同节点上。</li><li><strong>目的：</strong> 实现<strong>横向扩展</strong>（存储容量和吞吐量），并支持<strong>并行处理</strong>查询。</li></ul></li><li><strong>副本 (Replica)：</strong><ul><li><strong>作用：</strong> 是主分片的一个<strong>完整副本</strong>。</li><li><strong>目的：</strong> 实现<strong>高可用性</strong>（当主分片所在的节点故障时，副本可以提升为新的主分片，防止数据丢失和中断服务）和<strong>提高查询吞吐量</strong>（搜索请求可以在主分片和副本上并行执行，分摊负载）。</li></ul></li><li><strong>高可用和可伸缩：</strong><ul><li><strong>高可用：</strong> 通过副本机制，即使部分节点或分片失效，数据仍然可用，服务不会中断。</li><li><strong>可伸缩性：</strong> 通过增加分片数量和节点数量，可以将数据和查询负载分布到更多机器上，实现线性扩展。</li></ul></li></ul><h3 id="什么是倒排索引（Inverted-Index）？Elasticsearch-为什么用它？"><a href="#什么是倒排索引（Inverted-Index）？Elasticsearch-为什么用它？" class="headerlink" title="什么是倒排索引（Inverted Index）？Elasticsearch 为什么用它？"></a>什么是<strong>倒排索引（Inverted Index）</strong>？Elasticsearch 为什么用它？</h3><ul><li><strong>定义：</strong> 倒排索引是 Elasticsearch 实现<strong>快速全文搜索</strong>的核心数据结构。<ul><li>传统数据库的“正向索引”是从文档（行）到关键词（列）。</li><li>倒排索引则是从<strong>关键词 (Term)</strong> 到包含该关键词的<strong>文档 ID 列表</strong>。</li></ul></li><li><strong>示例：</strong><ul><li>文档1: “The quick brown fox”</li><li>文档2: “Quick foxes are quick”</li><li><strong>倒排索引：</strong><ul><li><code>the</code>: [文档1]</li><li><code>quick</code>: [文档1, 文档2]</li><li><code>brown</code>: [文档1]</li><li><code>fox</code>: [文档1]</li><li><code>foxes</code>: [文档2]</li><li><code>are</code>: [文档2]</li></ul></li></ul></li><li><strong>为什么用它：</strong><ul><li><strong>极快的全文搜索：</strong> 当你搜索一个或多个关键词时，可以直接在倒排索引中找到包含这些关键词的所有文档 ID，而无需扫描所有文档。</li><li><strong>高效过滤和聚合：</strong> 也是实现高效过滤和聚合的基础。</li></ul></li></ul><h3 id="Elasticsearch-中的-Mapping（映射）是什么？text-类型和-keyword-类型有什么区别？"><a href="#Elasticsearch-中的-Mapping（映射）是什么？text-类型和-keyword-类型有什么区别？" class="headerlink" title="Elasticsearch 中的 Mapping（映射）是什么？text 类型和 keyword 类型有什么区别？"></a>Elasticsearch 中的 <strong>Mapping（映射）</strong>是什么？<code>text</code> 类型和 <code>keyword</code> 类型有什么区别？</h3><ul><li><strong>Mapping 定义：</strong> Mapping 类似于关系型数据库中的<strong>表结构（Schema）</strong>。它定义了文档及其字段的数据类型、如何存储以及如何被索引和查询。</li><li><strong>作用：</strong> 控制字段如何被分析（分词）、如何被索引以及是否可以被搜索、聚合和排序。</li><li><strong><code>text</code> 类型 vs <code>keyword</code> 类型：</strong> 这是最常考的区别！<ul><li><strong><code>text</code> 类型：</strong><ul><li>用于<strong>全文文本</strong>字段，例如文章内容、产品描述。</li><li>在索引时会被<strong>分词器 (Analyzer)</strong> 处理，将文本分解为独立的<strong>词项 (Terms)</strong>。</li><li>适用于<strong>全文搜索</strong>（例如，搜索 “quick brown fox”，即使只搜 “quick” 也能找到）。</li><li><strong>不适用于精确匹配、排序或聚合</strong>（因为已经被分词）。</li></ul></li><li><strong><code>keyword</code> 类型：</strong><ul><li>用于<strong>精确值</strong>的字段，例如 ID、邮箱地址、标签、国家代码。</li><li><strong>不会被分词器处理</strong>，整个值被视为一个单一的词项。</li><li>适用于<strong>精确匹配、过滤、排序和聚合</strong>。</li><li><strong>不适用于全文搜索</strong>。</li></ul></li></ul></li><li><strong>面试重点：</strong> 能够清晰解释这两种类型的区别和适用场景。例如，一个商品标题字段，可能同时需要 <code>text</code> 类型用于搜索，<code>keyword</code> 类型用于精确过滤或聚合。</li></ul><h3 id="什么是分析器（Analyzer）？它由哪些部分组成？"><a href="#什么是分析器（Analyzer）？它由哪些部分组成？" class="headerlink" title="什么是分析器（Analyzer）？它由哪些部分组成？"></a>什么是<strong>分析器（Analyzer）</strong>？它由哪些部分组成？</h3><ul><li><strong>定义：</strong> 分析器是 Elasticsearch 在索引和搜索<strong>文本数据</strong>时，将原始文本转换为可搜索的<strong>词项 (Terms)</strong> 的过程。</li><li><strong>组成：</strong> 一个分析器由以下三部分组成：<ol><li><strong>字符过滤器 (Character Filters)：</strong> 在文本被分词前，进行预处理，例如移除 HTML 标签、替换特殊字符。</li><li><strong>分词器 (Tokenizer)：</strong> 将文本分解为独立的词项（tokens）。例如，<code>standard</code> 分词器按空格和标点符号分词。</li><li><strong>词项过滤器 (Token Filters)：</strong> 对分词器生成的词项进行进一步处理，例如转换为小写、移除停用词 (stop words)、添加同义词、词干提取等。</li></ol></li><li><strong>面试重点：</strong> 理解分析器在全文搜索中的核心作用，以及其三部分的职能。例如，搜索“Running Shoes”，分析器可能将其处理成“run”、“shoe”，这样搜索“run”也能找到。</li></ul><h3 id="Elasticsearch-的写入（索引）流程是怎样的？"><a href="#Elasticsearch-的写入（索引）流程是怎样的？" class="headerlink" title="Elasticsearch 的写入（索引）流程是怎样的？"></a>Elasticsearch 的写入（索引）流程是怎样的？</h3><ol><li>客户端发送写入请求（<code>PUT</code> 或 <code>POST</code> 文档）到集群中的<strong>任一节点</strong>（通常是协调节点）。</li><li>协调节点根据文档的 ID 和索引的路由规则计算出该文档应属于的<strong>主分片</strong>。</li><li>协调节点将请求转发到<strong>主分片所在的 Data 节点</strong>。</li><li>主分片所在节点将文档写入主分片，并将其写入<strong>事务日志 (Translog)</strong>。</li><li>主分片将请求并行转发到所有<strong>副本分片所在的 Data 节点</strong>。</li><li>副本分片所在节点将文档写入副本分片，并写入其自己的 Translog。</li><li>所有副本分片成功写入后，向主分片返回确认。</li><li>主分片收到所有副本确认后，向协调节点返回确认。</li><li>协调节点向客户端返回成功响应。</li></ol><p><strong>面试重点：</strong> 强调写入操作首先在主分片上进行，然后同步到副本分片，并涉及 Translog 的持久化来保证数据安全性。</p><h3 id="Elasticsearch-的查询（搜索）流程是怎样的？"><a href="#Elasticsearch-的查询（搜索）流程是怎样的？" class="headerlink" title="Elasticsearch 的查询（搜索）流程是怎样的？"></a>Elasticsearch 的查询（搜索）流程是怎样的？</h3><ol><li>客户端发送搜索请求到集群中的<strong>任一节点</strong>（协调节点）。</li><li>协调节点将请求广播到<strong>索引的所有主分片和副本分片</strong>（协调节点会随机选择一个分片来处理请求，通常是主分片或其一个副本）。</li><li>每个分片执行搜索请求的两个阶段：<ul><li><strong>Query Phase (查询阶段 / Scatter)：</strong> 每个分片执行查询，找到匹配的文档，并返回文档 ID 和得分（Score）到协调节点。</li><li><strong>Fetch Phase (取回阶段 / Gather)：</strong> 协调节点将所有分片返回的文档 ID 和得分进行合并、排序，选出最终需要的文档 ID。然后，协调节点再次向相应分片请求这些完整文档的内容。</li></ul></li><li>协调节点收集所有完整文档，并根据排序要求返回给客户端。</li></ol><p><strong>面试重点：</strong> 强调查询是“分而治之”的思想，分为查询和取回两个阶段，涉及协调节点的分发和结果聚合。</p><h3 id="如何保证-Elasticsearch-的数据一致性？"><a href="#如何保证-Elasticsearch-的数据一致性？" class="headerlink" title="如何保证 Elasticsearch 的数据一致性？"></a>如何保证 Elasticsearch 的数据一致性？</h3><ul><li><strong>写关注 (Write Consistency)：</strong> 在写入操作时，可以通过 <code>replication</code> 参数设置写关注：<ul><li><code>quorum</code> (默认)：需要主分片和大多数副本分片写入成功才返回。</li><li><code>one</code>：只需主分片写入成功。</li><li><code>all</code>：所有分片（主分片和所有副本分片）写入成功。</li><li><strong>面试重点：</strong> 了解不同的写关注级别对写入性能和数据安全性的影响。</li></ul></li><li><strong>Translog (事务日志)：</strong> 每个分片都有一个 Translog，所有操作在被 Lucene 写入磁盘前都会先写入 Translog，确保即使发生宕机，也能从 Translog 恢复未持久化的操作。</li><li><strong>刷新 (Refresh) 和提交 (Commit)：</strong><ul><li><strong>Refresh (刷新)：</strong> Translog 中的数据会定期刷新到 Lucene 的文件系统缓存中，此时数据变得<strong>可搜索</strong>（默认 1 秒刷新一次）。</li><li><strong>Commit (提交)：</strong> Lucene 会定期进行 fsync 操作，将数据<strong>持久化</strong>到磁盘。</li></ul></li><li><strong>最终一致性：</strong> Elasticsearch 追求的是<strong>最终一致性</strong>。这意味着写入数据后，可能在极短的时间内（通常是 Refresh 间隔）无法立即被搜索到，但最终会达到一致状态。</li></ul><h3 id="常见的-Elasticsearch-性能优化策略有哪些？"><a href="#常见的-Elasticsearch-性能优化策略有哪些？" class="headerlink" title="常见的 Elasticsearch 性能优化策略有哪些？"></a>常见的 Elasticsearch 性能优化策略有哪些？</h3><ul><li><strong>索引优化：</strong><ul><li><strong>合理设计 Mapping：</strong> 选择正确的数据类型（尤其是 <code>text</code> vs <code>keyword</code>），避免不必要的字段索引（<code>&quot;index&quot;: false</code>）。</li><li><strong>分片数量：</strong> 合理设置主分片数量，通常建议一个分片大小在 20GB-50GB 左右。过多的分片会增加管理开销，过少则限制扩展性。</li><li><strong>副本数量：</strong> 增加副本可以提高读吞吐量和高可用性，但会增加写入开销和存储成本。</li></ul></li><li><strong>查询优化：</strong><ul><li><strong>使用合适的查询类型：</strong> 优先使用 <code>term</code>、<code>match</code> 等简单查询，避免复杂的正则或通配符查询。</li><li><strong>避免深分页：</strong> 使用 <code>search_after</code> 或 <code>scroll</code> API 代替 <code>from</code>/<code>size</code> 进行深分页。</li><li><strong>缓存：</strong> 利用 Elasticsearch 的查询缓存和字段数据缓存。</li><li><strong>聚合优化：</strong> 将 <code>_source</code> 字段设置为 <code>false</code>（如果不需要返回原始文档），只返回聚合结果。</li></ul></li><li><strong>硬件优化：</strong><ul><li><strong>内存：</strong> 分配足够的 JVM 堆内存（通常是物理内存的一半，不超过 32GB）。</li><li><strong>SSD 硬盘：</strong> 对于 I/O 密集型操作至关重要。</li><li><strong>CPU：</strong> 足够的核数来处理查询和索引操作。</li></ul></li><li><strong>JVM 优化：</strong> 合理配置 JVM 堆内存大小和垃圾回收器。</li><li><strong>慢查询日志：</strong> 开启并分析慢查询日志，找出性能瓶颈。</li></ul><h3 id="Elasticsearch-集群可能遇到哪些问题？如何解决？"><a href="#Elasticsearch-集群可能遇到哪些问题？如何解决？" class="headerlink" title="Elasticsearch 集群可能遇到哪些问题？如何解决？"></a>Elasticsearch 集群可能遇到哪些问题？如何解决？</h3><ul><li><strong>脑裂 (Split-Brain)：</strong> 当网络分区时，集群可能分裂成多个子集群，每个子集群都选举出自己的 Master 节点，导致数据不一致。<ul><li><strong>解决方案：</strong> 配置 <code>discovery.zen.minimum_master_nodes</code> 参数（投票节点数的一半加一），确保只有多数节点存活的子集群才能选举出 Master。</li></ul></li><li><strong>集群健康状态 (Cluster Health)：</strong><ul><li><strong>Red (红色)：</strong> 至少一个主分片不可用，数据丢失或部分索引不可用，集群处于危险状态。</li><li><strong>Yellow (黄色)：</strong> 所有主分片可用，但至少一个副本分片不可用。数据仍然完整，但冗余性降低，高可用性受损。</li><li><strong>Green (绿色)：</strong> 所有主分片和副本分片都可用，集群健康。</li><li><strong>面试重点：</strong> 能够解释不同颜色的含义和应对措施。</li></ul></li><li><strong>磁盘空间不足：</strong> 索引拒绝写入，集群可能变红。<ul><li><strong>解决方案：</strong> 增加磁盘空间、删除旧数据、使用索引生命周期管理 (ILM)。</li></ul></li><li><strong>内存溢出 / JVM 垃圾回收频繁：</strong> 导致节点无响应或重启。<ul><li><strong>解决方案：</strong> 合理配置 JVM 堆内存，优化查询和索引操作。</li></ul></li></ul><h1 id="PostgreSql"><a href="#PostgreSql" class="headerlink" title="PostgreSql"></a>PostgreSql</h1><p>PostgreSQL 是一款功能强大、高度稳定且遵循 SQL 标准的<strong>开源对象关系型数据库管理系统 (ORDBMS)</strong>。它以其高级特性、严格的 ACID 兼容性和出色的可扩展性而闻名，常被认为是比 MySQL 更适合处理复杂业务逻辑和数据一致性要求高的场景。</p><h2 id="关键概念-3"><a href="#关键概念-3" class="headerlink" title="关键概念"></a>关键概念</h2><p>以下是 PostgreSQL 的一些核心概念，理解它们是掌握 PostgreSQL 的基础：</p><p>对象关系型数据库 (ORDBMS)</p><ul><li><strong>定义：</strong> PostgreSQL 不仅仅是一个传统的关系型数据库 (RDBMS)，它还是一个<strong>对象关系型数据库 (ORDBMS)</strong>。这意味着它融合了关系型数据库的优点和面向对象数据库的一些特性。</li><li><strong>特点：</strong><ul><li><strong>支持对象概念：</strong> 允许定义复杂的数据类型、函数重载和继承。</li><li><strong>丰富的内置数据类型：</strong> 除了标准的关系型数据类型（如整数、字符串、日期）外，PostgreSQL 还原生支持许多高级数据类型，如 <strong>JSONB</strong> (二进制 JSON)、<strong>数组 (Arrays)</strong>、<strong>XML</strong>、<strong>几何数据类型</strong>、<strong>范围类型</strong>、<strong>网络地址</strong>等。</li><li><strong>用户自定义类型：</strong> 你可以定义自己的数据类型和操作符，极大地扩展了数据库的功能。</li></ul></li><li><strong>重要性：</strong> 这是 PostgreSQL 与 MySQL 等纯 RDBMS 的一个显著区别，使其在处理半结构化数据、复杂业务逻辑和需要高度自定义的场景中更具优势。</li></ul><p>索引 (Index)</p><ul><li><strong>作用：</strong> 索引是提高数据检索效率的数据库对象。通过创建索引，数据库可以快速定位到满足查询条件的行，而无需扫描整个表。</li><li><strong>类型丰富：</strong> PostgreSQL 支持多种索引类型，包括：<ul><li><strong>B-tree：</strong> 最常用，适用于各种等值查询和范围查询。</li><li><strong>Hash：</strong> 适用于等值查询（较少用，因为不能保证 Crash-safe）。</li><li><strong>GIN (Generalized Inverted Index)：</strong> 适用于处理多值数据类型（如数组、JSONB）的包含查询。</li><li><strong>GiST (Generalized Search Tree)：</strong> 适用于复杂数据类型（如几何数据、全文搜索）和范围查询。</li><li><strong>BRIN (Block Range Index)：</strong> 适用于大型表，数据自然排序的场景，非常紧凑。</li></ul></li><li><strong>重要性：</strong> 合理地设计和使用索引是优化 PostgreSQL 查询性能的关键。</li></ul><p>事务 (Transaction) 和 ACID</p><ul><li><strong>事务：</strong> 事务是一组逻辑上相关的数据库操作，它们被视为一个单一的、不可分割的工作单元。</li><li><strong>ACID 特性：</strong> PostgreSQL 严格遵守 <strong>ACID</strong> (Atomicity, Consistency, Isolation, Durability) 原则。<ul><li><strong>原子性 (Atomicity)：</strong> 事务中的所有操作要么全部成功，要么全部失败回滚。</li><li><strong>一致性 (Consistency)：</strong> 事务完成后，数据库必须从一个一致状态转换到另一个一致状态。</li><li><strong>隔离性 (Isolation)：</strong> 并发执行的事务彼此独立，互不影响。</li><li><strong>持久性 (Durability)：</strong> 一旦事务提交，其所做的修改是永久性的，即使系统崩溃也不会丢失。</li></ul></li><li><strong>重要性：</strong> 严格的 ACID 兼容性是 PostgreSQL 可靠性和数据完整性的基石，尤其适用于金融、电商等对数据一致性要求极高的应用。</li></ul><p>多版本并发控制 (MVCC)</p><ul><li><strong>定义：</strong> PostgreSQL 实现并发控制的关键机制是 <strong>MVCC (Multi-Version Concurrency Control)</strong>。</li><li><strong>工作原理：</strong> 当一个事务修改数据时，PostgreSQL 不会直接覆盖旧数据，而是创建一个新的数据版本。读操作总是读取数据的旧版本，写操作则创建新版本。</li><li><strong>优势：</strong><ul><li><strong>读写不阻塞：</strong> 读操作和写操作通常不会相互阻塞，大大提高了并发性能。</li><li><strong>快照隔离：</strong> 每个事务都有一个“快照”，看到的是事务开始时的数据状态，避免了脏读、不可重复读和幻读（取决于隔离级别）。</li></ul></li><li><strong>重要性：</strong> MVCC 是 PostgreSQL 在高并发读写场景下表现出色的核心原因之一，也是其与 MySQL 等数据库在并发处理上差异较大的地方。</li></ul><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><ol><li><a href="https://javaguide.cn/high-performance/message-queue/rabbitmq-questions.html">https://javaguide.cn/high-performance/message-queue/rabbitmq-questions.html</a></li><li><a href="https://javabetter.cn/netty/rumen.html">https://javabetter.cn/netty/rumen.html</a></li><li><a href="https://javabetter.cn/mq/rabbitmq-rumen.html">https://javabetter.cn/mq/rabbitmq-rumen.html</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;消息队列功能很强大,它能使业务降低耦合,异步调用无需等待,下游服务故障不影响上游业务,缓存消息起到流量削峰填谷的作用. 这里介绍其中的RabbitMQ,此外在说一下Elastic Search和MongoDB.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>redis核心技术</title>
    <link href="https://www.sekyoro.top/2025/07/10/redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    <id>https://www.sekyoro.top/2025/07/10/redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</id>
    <published>2025-07-10T05:47:30.000Z</published>
    <updated>2025-08-05T12:01:51.172Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因为redis与mysql经常搭配使用,也是面试常问,这里记录一些常见基础题.<br><span id="more"></span></p><h1 id="数据类型与单线程模型"><a href="#数据类型与单线程模型" class="headerlink" title="数据类型与单线程模型"></a>数据类型与单线程模型</h1><h2 id="常用数据类型实现以及使用场景"><a href="#常用数据类型实现以及使用场景" class="headerlink" title="常用数据类型实现以及使用场景"></a>常用数据类型实现以及使用场景</h2><p><img data-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="img"></p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>实现:简单动态字符串</p><p>Redis 的字符串是<strong>二进制安全的</strong>，这意味着它们可以存储任何类型的数据，例如文本、图片或序列化的对象。</p><ul><li><strong>短字符串：</strong> 当字符串较短时（小于 44 字节），Redis 会使用 <code>embstr</code> 编码，将 <code>redisObject</code> 结构和字符串本身一起分配在一块连续的内存区域，从而减少内存碎片和提高存取效率。</li><li><strong>长字符串：</strong> 当字符串较长时，会使用 <code>raw</code> 编码，<code>redisObject</code> 指向一个单独分配的 SDS (Simple Dynamic String) 结构。SDS 不仅存储字符串内容，还包含长度信息和可用空间，使得字符串操作（如追加）更高效，并避免 C 语言字符串常见的缓冲区溢出问题。</li><li>如果存储的是整数值,并且大小在LONG_MAX范围则会采用INT编码,直接保存在redisObject的ptr位置,不再需要SDS</li></ul><p><strong>使用场景：</strong></p><ul><li><strong>缓存：</strong> 最常见的用途，存储用户会话、商品信息、HTML 片段等。</li><li><strong>计数器：</strong> 使用 <code>INCR</code>、<code>DECR</code> 命令实现网站访问量、点赞数、商品库存等。</li><li><strong>分布式锁：</strong> 利用 <code>SETNX</code> (SET if Not eXists) 命令实现分布式锁。</li><li><strong>限流：</strong> 结合过期时间对某个操作进行限流。</li></ul><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>Redis 列表是<strong>有序的字符串列表</strong>，底层实现随着版本和元素数量、大小的变化而变化，目的是优化内存和性能。</p><ul><li><strong><code>ziplist</code> (压缩列表)：</strong> 当列表元素较少且每个元素较小时，Redis 会使用 <code>ziplist</code> 编码。<code>ziplist</code> 是一块连续的内存，元素紧凑存储，内存效率很高。</li><li><strong><code>quicklist</code> (快速列表)：</strong> Redis 3.2 之后，<code>quicklist</code> 成为了列表的主要底层实现。<code>quicklist</code> 是一个由多个 <code>ziplist</code> 组成的双向链表。每个 <code>quicklist</code> 节点内部是一个 <code>ziplist</code>，存储少量元素，这样既利用了 <code>ziplist</code> 的内存效率，又保留了链表的快速增删和两端操作的特性。</li><li><strong><code>linkedlist</code> (双向链表)：</strong> 在很旧的版本中，当元素较多或较大时，会使用 <code>linkedlist</code>。但现在 <code>quicklist</code> 已经取代了它的地位。</li></ul><p><strong>使用场景：</strong></p><ul><li><strong>消息队列：</strong> <code>LPUSH</code> (左边入队) 和 <code>RPOP</code> (右边出队) 实现先进先出 (FIFO) 队列。</li><li><strong>任务队列：</strong> <code>BRPOP</code> (阻塞右边出队) 实现消费者阻塞等待任务。</li><li><strong>最新消息/动态：</strong> <code>LPUSH</code> 添加新消息，<code>LRANGE</code> 获取最新消息列表（如微博时间线、文章评论）。</li><li><strong>栈：</strong> <code>LPUSH</code> (入栈) 和 <code>LPOP</code> (出栈) 实现后进先出 (LIFO) 栈。</li></ul><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>Redis 哈希表用于存储<strong>字段-值对</strong>的集合，类似于 Java 的 <code>HashMap</code> 或 Python 的字典。</p><ul><li><strong><code>ziplist</code> (压缩列表)：</strong> 当哈希表的字段数量较少且字段值较小时，Redis 会使用 <code>ziplist</code> 编码。</li><li><strong><code>hashtable</code> (哈希表)：</strong> 当哈希表的字段数量或字段值较大时，Redis 会使用 <code>hashtable</code> 编码，这是一个真正的哈希表，基于数组和链表实现，支持动态扩容和缩容。</li></ul><p><strong>使用场景：</strong></p><ul><li><strong>存储对象：</strong> 存储用户资料、商品信息等，可以将一个对象的所有字段存储为一个哈希表的字段。</li><li><strong>购物车：</strong> 用户 ID 作为键，商品 ID 和数量作为哈希表的字段和值。</li><li><strong>计数器：</strong> 存储多个相关联的计数器，例如文章的点赞数、评论数和阅读数。</li></ul><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Redis 集合是<strong>无序的、不重复的字符串集合</strong>。</p><ul><li><strong><code>intset</code> (整数集合)：</strong> 当集合中只包含整数值，且元素数量较少时，Redis 会使用 <code>intset</code> 编码，它将整数有序地存储在一块连续的内存区域中，内存效率高。</li><li><strong><code>hashtable</code> (哈希表)：</strong> 当集合中包含非整数值，或者元素数量较多时，Redis 会使用 <code>hashtable</code> 编码。哈希表的键用于存储集合元素，值则被设置为 <code>NULL</code>，表示只有键有意义。</li></ul><p><strong>使用场景：</strong></p><ul><li><strong>标签系统：</strong> 存储文章的标签、用户的兴趣爱好。</li><li><strong>共同好友/关注：</strong> 使用 <code>SINTER</code> 命令计算共同好友。</li><li><strong>随机抽取：</strong> <code>SRANDMEMBER</code> 随机抽取集合中的元素（如抽奖）。</li><li><strong>判断某个元素是否存在：</strong> <code>SISMEMBER</code> 复杂度为 O(1)。</li><li><strong>去重：</strong> 自动去重。</li></ul><h4 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h4><p>Redis 有序集合是<strong>字符串集合，每个成员都会关联一个分数 (score)</strong>。集合中的成员是唯一的，但分数可以重复。元素总是按照分数进行升序排列，如果分数相同，则按字典序排列。</p><ul><li><strong><code>ziplist</code> (压缩列表)：</strong> 当有序集合的成员数量较少且成员和分数较小时，Redis 会使用 <code>ziplist</code> 编码。</li><li><strong><code>skiplist</code> (跳跃表) 和 <code>hashtable</code> (哈希表)：</strong> 当有序集合的成员数量或大小超出 <code>ziplist</code> 限制时，Redis 会同时使用 <code>skiplist</code> 和 <code>hashtable</code>。<ul><li><strong><code>skiplist</code>：</strong> 用于按分数范围或成员排名快速查找，高效支持范围查询和排名操作。</li><li><strong><code>hashtable</code>：</strong> 用于存储成员到分数的映射，实现 O(1) 复杂度的按成员查找分数。</li></ul></li></ul><p><strong>使用场景：</strong></p><ul><li><strong>排行榜：</strong> 游戏积分榜、商品销量榜、点赞数排行榜等。</li><li><strong>带权重的任务队列：</strong> 优先级队列，分数代表任务优先级或执行时间。</li><li><strong>范围查询：</strong> 获取分数在某个范围内的成员列表。</li><li><strong>按距离排序：</strong> 例如地理位置附近的人（结合地理哈希）。</li></ul><h3 id="使用的底层数据结构"><a href="#使用的底层数据结构" class="headerlink" title="使用的底层数据结构"></a>使用的底层数据结构</h3><h4 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h4><p>编码类型:RAW,EMBSTR,INT</p><p>相比于普通c语言字符数组优点:</p><p>不仅可以保存文本数据还可以保存二进制数据.  使用len属性表示长度,不以’\0’结尾,二进制安全</p><p>获取字符串长度O(1),拼接字符串等操作不会造成内存溢出,因为会进行预先分配空间.</p><p>基本编码方式是RAW,存储上限512MB,如果存储的SDS长度小于44字节，则会采用EMBSTR编码,内存变为连续的(而不是通过redisObject的ptr指向). 原因是redis底层分配内存以2^n使得redisObject小于64字节,减少了内存分配.</p><p>如果存储的是整数值,并且大小在LONG_MAX范围则会采用INT编码,直接保存在redisObject的ptr位置,不再需要SDS.</p><p><img data-src="https://cdn.nlark.com/yuque/0/2025/png/25410833/1752755991314-2f20e3b3-9aa3-4494-bf49-48ea529daaf7.png" alt="img"></p><h4 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h4><p>intset中元素唯一有序,具备类型升级机制,节省内存空间,底层采用二分查找</p><p>intset包含编码类型，元素个数与整数数组. 编码类型指定包含元素的类型</p><p><img data-src="https://cdn.nlark.com/yuque/0/2025/png/25410833/1752735691205-f5e95d48-30b5-4f75-886b-d321246a6a77.png" alt="img"></p><h4 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h4><p>特殊的双端链表,<strong>由一系列特殊编码的连续内存块组成</strong>. 可以在任意一端进行压入/弹出操作O(1)</p><p><img data-src="https://cdn.nlark.com/yuque/0/2025/png/25410833/1752740565844-5373d0d1-51aa-4572-9842-2c0ad7416c15.png" alt="img"></p><p>ntry每个节点也包含三个结构</p><p><img data-src="https://cdn.nlark.com/yuque/0/2025/png/25410833/1752740956433-3ffaded7-66fa-450f-8960-cf5cfdfe2094.png" alt="img"></p><p>包含上一个节点长度,编码属性,实际数据</p><p>编码属性记录了content的数据类型以及该entry内容的总长度.</p><p>如果是字符串</p><p><img data-src="https://cdn.nlark.com/yuque/0/2025/png/25410833/1752742351171-8abf2081-55b0-42d1-80ad-3692cbbbc49a.png" alt="img"></p><p><img data-src="https://cdn.nlark.com/yuque/0/2025/png/25410833/1752742682775-a2f8b405-48fa-4fa5-9c48-93b8ca085971.png" alt="img"></p><p>ziplist连锁更新问题,注意到其中每个节点有个previous_entry_length包含前一个节点占用字节数,而且是动态变化的,也就是说如果一个节点存储数据增加,导致占用字节数增加,当达到previous_entry_length一个阈值时导致后续节点字节数也增加,又恰好导致后续的节点占用字节数增加…</p><p><img data-src="https://cdn.nlark.com/yuque/0/2025/png/25410833/1752743224388-30fd1e2a-362e-4f23-84e1-2498b98e8850.png" alt="img"></p><p>listpack引入为 Redis 设计的<strong>紧凑型（compact）数据结构</strong>，用于高效地存储小型的列表（List）、哈希（Hash）、有序集合（Sorted Set）和集合（Set）的元素。它的主要目标是<strong>减少内存开销</strong>，特别是当这些数据结构包含少量、小尺寸的元素时</p><h4 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h4><h4 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h4><p>dict包括字典,哈希表以及哈希节点.</p><p><img data-src="https://cdn.nlark.com/yuque/0/2025/png/25410833/1752736677683-1a2ca974-682c-4d81-a4e8-3b866ab460bb.png" alt="img"></p><p>dict的渐进式rehash</p><p><img data-src="https://cdn.nlark.com/yuque/0/2025/png/25410833/1752739931411-abef6f94-f5c5-4f97-a7b6-8d82e679ae31.png" alt="img"></p><p><img data-src="https://cdn.nlark.com/yuque/0/2025/png/25410833/1752739974643-1ab9714e-98ee-4688-8413-43b85fdb889a.png" alt="img"></p><p>Dict内存不连续,使用指针过多,造成内存浪费</p><h4 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h4><p>ziplist与quicklist都需要不断遍历查询,跳表目的是提高查询效率</p><p>其元素按序排列存储,节点可能包含多个指针,指针跨度不同.</p><p>相当于分层的指针,一级指针包含所有元素,从最高级出发,如果没找到就跳到下一级</p><p><img data-src="https://cdn.nlark.com/yuque/0/2025/png/25410833/1752744992659-b6fc6e10-806b-4e27-a53d-6f6996678a18.png" alt="img"></p><p><img data-src="https://cdn.nlark.com/yuque/0/2025/png/25410833/1752745139855-32e93a45-508f-403c-802f-e2e1802b4db5.png" alt="img"></p><p><img data-src="https://cdn.nlark.com/yuque/0/2025/png/25410833/1752745172030-d6a56f19-6bcf-4fbd-84ae-5764a208ee72.png" alt="img"></p><p><img data-src="https://cdn.nlark.com/yuque/0/2025/png/25410833/1752745179378-a96e1d60-a238-4212-bf17-70cac9a3259d.png" alt="img"></p><h4 id="listpack"><a href="#listpack" class="headerlink" title="listpack"></a>listpack</h4><p>在 Redis 5.0 中，<code>listpack</code> 是一种全新的、更高效的编码方式，它被设计用来完全取代 <code>ziplist</code>，成为 <strong>Hash、List 和 Sorted Set</strong> 等数据结构在元素数量较少且元素值较小时的底层优化存储。</p><p><code>ziplist</code> 存在一个著名的缺陷叫做<strong>连锁更新 (Cascade Update)</strong>。</p><ul><li><code>ziplist</code> 中的每个元素在存储时，除了自身内容，还会存储<strong>前一个元素的长度</strong>。</li><li>如果前一个元素的长度发生变化，导致其存储的“前一个元素的长度”字段本身的编码长度也需要变化，就会引起一系列的连锁反应，导致后面所有元素的“前一个元素长度”字段都需要更新，可能带来 O(N) 的性能开销。</li><li>尽管 Redis 会尽量避免这种情况，但在特定场景下（例如大量小元素紧密排列，然后头部元素长度变化），连锁更新依然可能发生，影响性能。</li></ul><p>为了解决 <code>ziplist</code> 的这个根本性问题，Redis 5.0 引入了 <code>listpack</code>。</p><p><code>listpack</code> 的设计目标是：<strong>保持 <code>ziplist</code> 的紧凑内存布局，同时彻底避免连锁更新问题。</strong></p><ol><li><strong>连续内存块：</strong> 类似于 <code>ziplist</code>，<code>listpack</code> 也是将所有元素存储在<strong>一块连续的内存区域</strong>中，没有指针开销，内存效率极高。</li><li><strong>独立的元素编码：</strong> 这是 <code>listpack</code> 与 <code>ziplist</code> 最根本的区别。<ul><li>在 <code>listpack</code> 中，每个元素不再存储前一个元素的长度。</li><li>每个元素在编码时，会先记录<strong>自身内容的长度</strong>，然后才是实际内容。这意味着每个元素都是<strong>独立编码</strong>的，修改一个元素的长度不会影响到它前后的元素。</li></ul></li><li><strong>支持向前和向后遍历：</strong> 虽然不存储前一个元素的长度，但 <code>listpack</code> 仍然支持双向遍历。<ul><li>每个元素在编码自身长度时，会使用一种特殊的编码方式，使得可以从当前位置快速地计算出下一个元素的起始位置，以及从当前位置快速地找到前一个元素的起始位置。这通过在元素的末尾额外存储一个小的“反向跳跃”信息来实现（通常是元素总长度）。</li></ul></li><li><strong>变长编码：</strong> 元素内容和长度信息都采用变长编码，根据实际大小动态调整，进一步节省空间。</li></ol><p>Listpack 的优缺点</p><p><strong>优点：</strong></p><ul><li><strong>彻底解决连锁更新问题：</strong> 这是 <code>listpack</code> 最核心的优势。因为它移除了对前一个元素长度的依赖，修改一个元素不会引起连锁反应，从而保证了 O(1) 的插入和删除复杂度（在不考虑内存重新分配和数据移动的情况下）。</li><li><strong>内存效率高：</strong> 依然保持了紧凑的内存布局，没有指针开销，与 <code>ziplist</code> 相似。</li><li><strong>支持双向遍历：</strong> 虽然没有前驱长度信息，但巧妙的编码方式使其依然支持从两端高效地遍历。</li><li><strong>实现和维护相对简单：</strong> 相较于 <code>ziplist</code> 处理连锁更新的复杂逻辑，<code>listpack</code> 的内部逻辑更清晰。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>插入和删除的内存移动：</strong> 尽管避免了连锁更新，但由于是连续内存，在中间位置进行插入或删除操作时，仍然需要对后续元素进行<strong>内存拷贝和移动</strong>，最坏情况下是 O(N) 复杂度。因此，<code>listpack</code> 仍然不适合存储大量元素或频繁在中间位置变动的场景。</li></ul><h4 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h4><p>Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap通过最小的单位bit来进行的设置，表示某个元素的值或者状态，时间复杂度为O(1)。</p><p>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。</p><p>Bitmap 实际上就是普通的 Redis 字符串。一个字节有 8 位，所以 Redis 会将你设置的位映射到字符串的相应字节和位上。例如，设置第 0 位会影响第一个字节的第一个位，设置第 8 位会影响第二个字节的第一个位。</p><h4 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h4><p>HyperLogLog 是一种用于<strong>基数估算</strong>（即统计一个集合中不重复元素的数量，例如独立访客 UV）的概率型数据结构。它不是精确计数，而是以<strong>极小的内存开销</strong>（Redis 中每个 HyperLogLog 键固定占用 12KB 内存）来<strong>估算</strong>海量数据的基数，标准误差通常在 0.81% 左右。</p><p><strong>底层实现：</strong> HyperLogLog 基于 LogLog 算法的改进版，通过对输入元素进行哈希处理，并观察哈希值中前导零的数量来估算基数。它内部维护一个稀疏或密集表示的寄存器数组。</p><h4 id="geo"><a href="#geo" class="headerlink" title="geo"></a>geo</h4><p>Geo 是 Redis 3.2 引入的数据结构，用于存储地理空间信息（经度、纬度），并能够执行基于距离的查询。它实际上是<strong>有序集合 (Sorted Set) 的一个特化</strong>，利用 GeoHash 算法将二维的经纬度数据转换为一维的字符串，并存储在 Sorted Set 中。</p><h4 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h4><p>消息队列,相比于基于list实现的消息队列,支持:生成全局唯一id以及以消费者组形式消费数据.</p><p>Stream 是 Redis 5.0 引入的全新数据结构，它是一个<strong>只追加的（append-only）\</strong>数据结构，主要用于实现*<em>消息队列<strong>、</strong>事件日志<strong>和</strong>时间序列数据存储*</em>。它支持多消费者组模式，能够持久化消息，并允许消费者从指定位置开始读取。</p><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="bitmaps"><a href="#bitmaps" class="headerlink" title="bitmaps"></a>bitmaps</h4><p>BITFILED key GET u[dayOfMonth] 0</p><p>获得这个月截止到今天的签到情况</p><p>BITCOUNT key start end</p><p>获取从start到end范围为1的值</p><h4 id="stream消息队列"><a href="#stream消息队列" class="headerlink" title="stream消息队列"></a>stream消息队列</h4><p>XADD key id field value</p><p>XREAD </p><p>XGROUP CREATE key groupname ID</p><p>XREADGROUP GROUP groupname </p><p>XACK  key groupname ID  确认处理</p><p>XPENDING 查看待处理的(未ACK)的消息</p><h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h2><p>Redis 的“单线程”指的是其<strong>核心命令执行引擎是单线程的</strong></p><h3 id="Redis-为什么选择单线程？"><a href="#Redis-为什么选择单线程？" class="headerlink" title="Redis 为什么选择单线程？"></a>Redis 为什么选择单线程？</h3><p>在多线程并发编程中，为了保证数据的一致性，通常需要引入锁（互斥锁、读写锁等）来同步对共享资源的访问。锁会带来以下问题：</p><ul><li><strong>性能开销：</strong> 锁的获取和释放会消耗 CPU 资源，并且可能导致上下文切换。</li><li><strong>死锁和活锁：</strong> 多线程编程中常见的复杂并发问题。</li><li><strong>代码复杂性：</strong> 编写和维护正确的并发代码非常困难，容易出错。</li></ul><p>Redis 的作者认为，<strong>CPU 并不是 Redis 的主要瓶颈</strong>。对于内存数据库来说，瓶颈通常在于：</p><ul><li><strong>内存访问：</strong> Redis 是内存数据库，数据操作主要在内存中进行，速度非常快。</li><li><strong>网络 I/O：</strong> 客户端与 Redis 服务器之间的网络传输。</li></ul><p>因此，如果能避免多线程带来的复杂性和开销，而将主要精力放在优化内存操作和网络 I/O 上，反而能实现更高的性能和更简洁的设计。</p><p>Redis 的单线程模型主要基于 <strong>I/O 多路复用 (I/O Multiplexing)</strong> 技术，例如 Linux 上的 <code>epoll</code>、macOS 上的 <code>kqueue</code> 等。</p><p>其工作流程可以概括为：</p><ol><li><strong>I/O 多路复用器：</strong> Redis 的主线程使用 I/O 多路复用器来监听多个套接字（客户端连接）上的事件，例如连接建立、数据可读、数据可写等。</li><li><strong>事件循环 (Event Loop)：</strong> 主线程在一个无限循环中，不断地从 I/O 多路复用器中获取已经就绪的事件。</li><li><strong>串行执行：</strong> 每当一个事件就绪时（例如某个客户端发送了命令），Redis 主线程会将其对应的命令从事件队列中取出，<strong>串行地执行</strong>该命令。</li><li><strong>返回结果：</strong> 命令执行完成后，结果会被放入响应缓冲区，并等待网络 I/O 就绪后发送给客户端。</li></ol><p><strong>核心优势：</strong></p><ul><li><strong>无锁竞争：</strong> 因为所有命令都在一个线程中串行执行，Redis 内部的数据结构（如哈希表、跳跃表等）无需加锁，避免了锁带来的性能损耗和复杂性。</li><li><strong>简单高效：</strong> 避免了多线程并发控制的复杂性，使得代码更简洁，更容易维护和优化。</li><li><strong>高吞吐量：</strong> 内存操作速度快，I/O 多路复用使得单个线程能够同时处理大量并发连接，充分利用 CPU 的等待时间。</li></ul><p>虽然核心命令执行是单线程的，但为了进一步提升性能和处理一些耗时的后台任务，Redis 引入了少量其他线程：</p><p><img data-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B.jpg" alt="img"></p><p>后台线程相当于一个消费者，生产者把耗时任务丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务就去执行对应的方法即可。</p><p>关闭文件、AOF 刷盘、释放内存这三个任务都有各自的任务队列：</p><ul><li>BIO_CLOSE_FILE，关闭文件任务队列：当队列有任务后，后台线程会调用 close(fd) ，将文件关闭；</li><li>BIO_AOF_FSYNC，AOF刷盘任务队列：当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到队列中。当发现队列有任务后，后台线程会调用 fsync(fd)，将 AOF 文件刷盘.</li><li><p>BIO_LAZY_FREE，lazy free 任务队列：当队列有任务后，后台线程会 free(obj) 释放对象 / free(dict) 删除数据库所有对象 / free(skiplist) 释放跳表对象</p></li><li><p><strong>Redis 6.0 引入多线程 I/O (可选)：</strong></p><ul><li>这是 Redis 单线程模型在<strong>网络 I/O 层面</strong>的重大突破。</li><li>在 Redis 6.0 之后，你可以选择开启多线程 I/O。这意味着在<strong>解析客户端请求数据</strong>和<strong>向客户端回写响应数据</strong>这两个阶段，Redis 可以使用多个 I/O 线程并行处理。</li><li><strong>关键点：</strong> 即使开启了多线程 I/O，<strong>核心的命令执行（读写内存数据）仍然是单线程的</strong>。多线程 I/O 只是将网络数据的读取、协议解析以及响应的序列化、发送等任务并行化，从而减少了主线程在这些 I/O 上的耗时。</li><li>这对于处理大量小请求的场景，可以显著提高吞吐量。</li></ul></li></ul><p><strong>核心命令执行：</strong> 单线程，保证数据一致性，避免锁开销。</p><p><strong>I/O 多路复用：</strong> 单线程也能高效处理大量并发连接。</p><p><strong>后台任务：</strong> 部分耗时任务（如大键删除）或通过 <code>fork</code> 子进程（AOF 重写、RDB 持久化）或通过少量后台线程异步执行，避免阻塞主线程。</p><p><strong>Redis 6.0+ 的网络 I/O：</strong> 可以选择性地开启多线程，用于<strong>网络数据的读写和协议解析</strong>，但命令执行仍然单线程。</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><p>常见的缓存更新策略共有3种：</p><ul><li>Cache Aside（旁路缓存）策略；</li><li>Read/Write Through（读穿 / 写穿）策略；</li><li>Write Back（写回）策略；</li></ul><p>Cache Aside（旁路缓存）策略是最常用的，应用程序直接与「数据库、缓存」交互，并负责对缓存的维护，该策略又可以细分为「读策略」和「写策略」。</p><p><strong>写策略的步骤：</strong></p><ul><li>先更新数据库中的数据，再删除缓存中的数据。</li></ul><p><strong>读策略的步骤：</strong></p><ul><li>如果读取的数据命中了缓存，则直接返回数据；</li><li>如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。</li></ul><p>注意，写策略的步骤的顺序不能倒过来，即<strong>不能先删除缓存再更新数据库</strong>，原因是在「读+写」并发的时候，会出现缓存和数据库的数据不一致性的问题。</p><p><strong>Read/Write Through（读穿 / 写穿）策略</strong></p><p>Read/Write Through（读穿 / 写穿）策略原则是应用程序只和缓存交互，不再和数据库交互，而是由缓存和数据库交互，相当于更新数据库的操作由缓存自己代理了。</p><p><strong><em>1、Read Through 策略</em></strong></p><p>先查询缓存中数据是否存在，如果存在则直接返回，如果不存在，则由缓存组件负责从数据库查询数据，并将结果写入到缓存组件，最后缓存组件将数据返回给应用。</p><p><strong><em>2、Write Through 策略</em></strong></p><p>当有数据更新的时候，先查询要写入的数据在缓存中是否已经存在：</p><ul><li>如果缓存中数据已经存在，<strong>则更新缓存中的数据，并且由缓存组件同步更新到数据库中，然后缓存组件告知应用程序更新完成</strong>。</li><li>如果缓存中数据不存在，直接更新数据库，然后返回；</li></ul><p>Read Through/Write Through 策略的特点是由缓存节点而非应用程序来和数据库打交道，在我们开发过程中相比 Cache Aside 策略要少见一些，原因是我们经常使用的分布式缓存组件，无论是 Memcached 还是 <strong>Redis 都不提供写入数据库和自动加载数据库中的数据的功能</strong>。而在使用本地缓存的时候可以考虑使用这种策略。</p><p><strong>Write Back（写回）策略</strong></p><p>Write Back（写回）策略在更新数据的时候，只更新缓存，同时将缓存数据设置为脏的，然后立马返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行。</p><p>实际上，Write Back（写回）策略也不能应用到我们常用的数据库和缓存的场景中，因为 Redis 并没有异步更新数据库的功能。</p><p>Write Back 是计算机体系结构中的设计，比如 CPU 的缓存、操作系统中文件系统的缓存都采用了 Write Back（写回）策略。</p><p><strong>Write Back 策略特别适合写多的场景</strong>，因为发生写操作的时候， 只需要更新缓存，就立马返回了。比如，写文件的时候，实际上是写入到文件系统的缓存就返回了，并不会写磁盘。</p><p><strong>但是带来的问题是，数据不是强一致性的，而且会有数据丢失的风险</strong>，因为缓存一般使用内存，而内存是非持久化的，所以一旦缓存机器掉电，就会造成原本缓存中的脏数据丢失。所以你会发现系统在掉电之后，之前写入的文件会有部分丢失，就是因为 Page Cache 还没有来得及刷盘造成的。</p><h2 id="缓存雪崩、穿透、击穿"><a href="#缓存雪崩、穿透、击穿" class="headerlink" title="缓存雪崩、穿透、击穿"></a>缓存雪崩、穿透、击穿</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是<strong>缓存穿透</strong>的问题。</p><p>应对缓存穿透的方案，常见的方案有三种。</p><ul><li><strong>非法请求的限制</strong>：当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</li><li><strong>设置空值或者默认值</strong>：当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。</li><li><strong>使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在</strong>：我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在，即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>如果缓存中的<strong>某个热点数据过期</strong>了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是<strong>缓存击穿</strong>的问题。</p><p>应对缓存击穿可以采取前面说到两种方案：</p><ul><li>互斥锁方案（Redis 中使用 setNX 方法设置一个状态位，表示这是一种锁定状态），保证同一时间只有一个业务线程请求缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li><li>不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>当<strong>大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机</strong>时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是<strong>缓存雪崩</strong>的问题。</p><p>可以看到，发生缓存雪崩有两个原因：</p><ul><li>大量数据同时过期；</li><li>Redis 故障宕机；</li></ul><p>不同的诱因，应对的策略也会不同。</p><p><strong>大量数据同时过期</strong></p><p>针对大量数据同时过期而引发的缓存雪崩问题，常见的应对方法有下面这几种：</p><ul><li>均匀设置过期时间；</li><li>互斥锁；</li><li>后台更新缓存；</li></ul><ol><li>均匀设置过期时间</li></ol><p>如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时，<strong>给这些数据的过期时间加上一个随机数</strong>，这样就保证数据不会在同一时间过期。</p><ol><li>互斥锁</li></ol><p>当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p><p>实现互斥锁的时候，最好设置<strong>超时时间</strong>，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。</p><ol><li>后台更新缓存</li></ol><p>业务线程不再负责更新缓存，缓存也不设置有效期，而是<strong>让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新</strong>。</p><p>事实上，缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为<strong>当系统内存紧张的时候，有些缓存数据会被“淘汰”</strong>，而在缓存被“淘汰”到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，业务的视角就以为是数据丢失了。</p><p>解决上面的问题的方式有两种。</p><p>第一种方式，后台线程不仅负责定时更新缓存，而且也负责<strong>频繁地检测缓存是否有效</strong>，检测到缓存失效了，原因可能是系统紧张而被淘汰的，于是就要马上从数据库读取数据，并更新到缓存。</p><p>这种方式的检测时间间隔不能太长，太长也导致用户获取的数据是一个空值而不是真正的数据，所以检测的间隔最好是毫秒级的，但是总归是有个间隔时间，用户体验一般。</p><p>第二种方式，在业务线程发现缓存数据失效后（缓存数据被淘汰），<strong>通过消息队列发送一条消息通知后台线程更新缓存</strong>，后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好。</p><p>在业务刚上线的时候，我们最好提前把数据缓起来，而不是等待用户访问才来触发缓存构建，这就是所谓的<strong>缓存预热</strong>，后台更新缓存的机制刚好也适合干这个事情。</p><p><strong>故障宕机</strong></p><p>针对 Redis 故障宕机而引发的缓存雪崩问题，常见的应对方法有下面这几种：</p><ul><li>服务熔断或请求限流机制；</li><li>构建 Redis 缓存高可靠集群；</li></ul><ol><li>服务熔断或请求限流机制</li></ol><p>因为 Redis 故障宕机而导致缓存雪崩问题时，我们可以启动<strong>服务熔断</strong>机制，<strong>暂停业务应用对缓存服务的访问，直接返回错误</strong>，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。</p><p>服务熔断机制是保护数据库的正常允许，但是暂停了业务应用访问缓存服系统，全部业务都无法正常工作</p><p>为了减少对业务的影响，我们可以启用<strong>请求限流</strong>机制，<strong>只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务</strong>，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。</p><ol><li>构建 Redis 缓存高可靠集群</li></ol><p>服务熔断或请求限流机制是缓存雪崩发生后的应对方案，我们最好通过<strong>主从节点的方式构建 Redis 缓存高可靠集群</strong>。</p><p>如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。</p><h2 id="数据库与缓存如何保证一致性"><a href="#数据库与缓存如何保证一致性" class="headerlink" title="数据库与缓存如何保证一致性"></a>数据库与缓存如何保证一致性</h2><p>由于引入了缓存，那么在数据更新时，不仅要更新数据库，而且要更新缓存，这两个更新操作存在前后的问题</p><h3 id="删除缓存还是更新缓存"><a href="#删除缓存还是更新缓存" class="headerlink" title="删除缓存还是更新缓存"></a>删除缓存还是更新缓存</h3><p>如果是更新缓存,不管是先更新数据库还是先更新缓存都可能存在并发问题导致后执行操作的缓存被覆盖</p><p><img data-src="https://cdn.xiaolincoding.com//mysql/other/454a8228a6549176ad7e0484fba3c92b.png" alt="图片" style="zoom:50%;" /></p><p>使用旁路缓存策略,<strong>写策略的步骤：</strong></p><ul><li>更新数据库中的数据；</li><li>删除缓存中的数据。</li></ul><p><strong>读策略的步骤：</strong></p><ul><li>如果读取的数据命中了缓存，则直接返回数据；</li><li>如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。</li></ul><h2 id="先更新数据库还是先删除缓存"><a href="#先更新数据库还是先删除缓存" class="headerlink" title="先更新数据库还是先删除缓存"></a>先更新数据库还是先删除缓存</h2><p>如果是先删除缓存,当一个写请求到来,删除缓存后并更新数据库,若还没更新数据时另一个读请求读到了空缓存然后读取数据库内容并写入缓存,之后写请求才更新数据库.</p><p><img data-src="https://cdn.xiaolincoding.com//mysql/other/cc208c2931b4e889d1a58cb655537767.png" alt="图片" style="zoom:50%;" /></p><p><strong>先删除缓存，再更新数据库，在「读 + 写」并发的时候，还是会出现缓存和数据库的数据不一致的问题</strong>。</p><p>如果是先更新数据库再删除缓存,也可能出现问题. 例如一个写请求到来,而此时另一个读请求读到了空缓存然后读取数据库内容,这时写请求更新数据库并删除缓存,然后读请求更新缓存.</p><p><img data-src="https://cdn.xiaolincoding.com//mysql/other/1cc7401143e79383ead96582ac11b615.png" alt="图片" style="zoom:50%;" /></p><p>先更新数据库，再删除缓存也是会出现数据不一致性的问题，<strong>但是在实际中，这个问题出现的概率并不高</strong>。</p><p><strong>因为缓存的写入通常要远远快于数据库的写入</strong>，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。</p><p>而一旦请求 A 早于请求 B 删除缓存之前更新了缓存，那么接下来的请求就会因为缓存不命中而从数据库中重新读取数据，所以不会出现这种不一致的情况。</p><p>所以，<strong>「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的</strong>。</p><p>但是仍然可能存在问题，可以采用两种做法：</p><ul><li>在更新缓存前先加个<strong>分布式锁</strong>，保证同一时间只运行一个请求更新缓存，就会不会产生并发问题了，当然引入了锁后，对于写入的性能就会带来影响。</li><li>在更新完缓存时，给缓存加上较短的<strong>过期时间</strong>，这样即时出现缓存不一致的情况，缓存的数据也会很快过期，对业务还是能接受的。</li></ul><p>针对”先删除缓存，再更新数据库”方案在「读 + 写」并发请求而造成缓存不一致的解决办法是「<strong>延迟双删</strong>」</p><p>延迟双删实现的伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#删除缓存</span><br><span class="line">redis.delKey(X)</span><br><span class="line">#更新数据库</span><br><span class="line">db.update(X)</span><br><span class="line">#睡眠</span><br><span class="line">Thread.sleep(N)</span><br><span class="line">#再删除缓存</span><br><span class="line">redis.delKey(X)</span><br></pre></td></tr></table></figure><p>加了个睡眠时间，主要是为了确保请求 A 在睡眠的时候，请求 B 能够在这这一段时间完成「从数据库读取数据，再把缺失的缓存写入缓存」的操作，然后请求 A 睡眠完，再删除缓存。</p><p>所以，请求 A 的睡眠时间就需要大于请求 B 「从数据库读取数据 + 写入缓存」的时间。</p><p>但是具体睡眠多久其实是个<strong>玄学</strong>，很难评估出来，所以这个方案也只是<strong>尽可能</strong>保证一致性而已，极端情况下，依然也会出现缓存不一致的现象。</p><p>因此，还是比较建议用「先更新数据库，再删除缓存」的方案。</p><h2 id="如何保证先更新数据库-，再删除缓存这两个操作能执行成功"><a href="#如何保证先更新数据库-，再删除缓存这两个操作能执行成功" class="headerlink" title="如何保证先更新数据库 ，再删除缓存这两个操作能执行成功"></a>如何保证先更新数据库 ，再删除缓存这两个操作能执行成功</h2><p>“先更新数据库， 再删除缓存”其实是两个操作，问题在于，<strong>在删除缓存（第二个操作）的时候失败了，导致缓存中的数据是旧值，而数据库是最新值</strong>。</p><p>有两种方法：</p><ul><li>消息队列重试机制。</li><li>订阅 MySQL binlog，再操作缓存。</li></ul><p>可以引入<strong>消息队列</strong>，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。</p><ul><li>如果应用<strong>删除缓存失败</strong>，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是<strong>重试机制</strong>。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。</li><li>如果<strong>删除缓存成功</strong>，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。</li></ul><p><strong>订阅 MySQL binlog,再删除缓存</strong></p><p><strong>先更新数据库，再删缓存</strong>的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。</p><p>于是我们就可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除，阿里巴巴开源的 Canal 中间件就是基于这个实现的。</p><p>Canal 模拟 MySQL 主从复制的交互协议，<strong>把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据</strong>，供下游程序订阅使用。</p><p>将binlog日志采集发送到MQ队列里面，然后编写一个简单的缓存删除消息者订阅binlog日志，根据更新log删除缓存，并且通过ACK机制确认处理这条更新log，保证数据缓存一致性.</p><p><strong>必须是删除缓存成功，再回 ack 机制给消息队列</strong>，否则可能会造成消息丢失的问题，比如消费服务从消息队列拿到事件之后，直接回了 ack，然后再执行删除缓存操作的话，如果删除缓存的操作还是失败了，那么因为提前给消息队列回 ack了，就没办重试了。</p><p>所以，如果要想保证”先更新数据库，再删缓存”策略第二个操作能执行成功，我们可以使用：</p><ul><li>消息队列来重试缓存的删除，优点是保证缓存一致性的问题，缺点会对业务代码入侵</li><li>订阅 MySQL binlog + 消息队列 + 重试缓存的删除，优点是规避了代码入侵问题，也很好的保证缓存一致性的问题，缺点就是引入的组件比较多，对团队的运维能力比较有高要求。</li></ul><p>这两种方法有一个共同的特点，都是采用<strong>异步操作缓存</strong></p><h1 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h1><blockquote><p>Redis 的读写操作都是在内存中，所以 Redis 性能才会高，但是当 Redis 重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis 实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据。</p></blockquote><p>Redis的三种持久化机制:RDB AOF以及混合持久化</p><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>将某一时刻的内存数据以二进制的方式写入磁盘.</p><p>Redis 的 RDB (Redis Database) 快照是一种<strong>二进制格式的紧凑存储</strong>，它记录了 Redis 在某个时间点上的<strong>全量数据</strong>。</p><p>RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据.</p><p>RDB 快照的生成可以由以下几种方式触发：</p><ol><li><p><strong>手动触发：</strong></p><ul><li><strong><code>SAVE</code> 命令：</strong> 阻塞 Redis 主进程。在 RDB 文件生成期间，Redis 不会响应任何客户端请求。这在生产环境几乎不使用。 </li><li><strong><code>BGSAVE</code> 命令：</strong> <strong>非阻塞</strong>。Redis 会 <code>fork</code> 一个子进程来执行 RDB 文件生成任务。这是生产环境推荐的方式。</li></ul></li><li><p><strong>自动触发：</strong></p><ul><li>通过配置 <code>redis.conf</code> 中的 <code>save</code> 规则。例如：<ul><li><code>save 900 1</code>：表示 900 秒内至少 1 个键被修改，则自动执行 <code>BGSAVE</code>。</li><li><code>save 300 10</code>：表示 300 秒内至少 10 个键被修改，则自动执行 <code>BGSAVE</code>。</li><li><code>save 60 10000</code>：表示 60 秒内至少 10000 个键被修改，则自动执行 <code>BGSAVE</code>。</li></ul></li><li>每次自动触发时，都会执行一次 <code>BGSAVE</code>。</li><li>主从复制时，主节点向从节点同步数据也会触发 <code>BGSAVE</code>。</li><li>执行 <code>SHUTDOWN</code> 命令且配置了 RDB 持久化时，也会执行 <code>SAVE</code>。</li></ul><p>Redis+的快照是全量快照，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。所以执行快照是一个比较重的操作，如果频率太频繁，可能会对+Redis+性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多</p></li></ol><p>其中重要的是BGSAVE命令,使用fork创建新进程利用os提供的写时复制(COW),</p><p><code>BGSAVE</code> 命令的执行流程充分利用了操作系统的特性，以达到非阻塞持久化的目的：</p><ol><li><strong>客户端发送 <code>BGSAVE</code> 命令或自动触发条件满足。</strong></li><li><strong>主进程判断是否可以执行：</strong><ul><li>如果当前已经有一个 <code>BGSAVE</code> 或 <code>BGREWRITEAOF</code> 子进程正在运行，主进程会拒绝新的 <code>BGSAVE</code> 请求，以避免同时产生多个快照进程。</li></ul></li><li><strong>主进程 <code>fork()</code> 子进程：</strong><ul><li>Redis 主进程会调用操作系统提供的 <code>fork()</code> 系统调用，创建一个<strong>子进程</strong>。</li><li><code>fork()</code> 操作会复制父进程的<strong>页表</strong>，并创建一个与父进程几乎完全相同的子进程。这个子进程继承了父进程的所有内存副本、文件描述符等。</li><li><strong><code>fork()</code> 是唯一的可能导致主进程短暂阻塞的阶段</strong>。阻塞时间取决于服务器的 CPU 性能和 Redis 实例的内存大小。对于几十 GB 的实例，<code>fork</code> 阻塞通常在几十到几百毫秒。</li></ul></li><li><strong>写时复制 (Copy-on-Write, COW) 机制：</strong><ul><li>在 <code>fork()</code> 完成后，主进程和子进程会<strong>共享相同的物理内存页面</strong>。这些页面在此时被操作系统标记为<strong>只读</strong>。</li><li><strong>子进程：</strong> 子进程会遍历它所“看到”的内存数据（即 <code>fork</code> 瞬间的内存快照），并将其以 RDB 格式写入到磁盘上的一个临时文件 (<code>temp-XXXX.rdb</code>)。子进程只负责读取这些共享的内存页面，它不会修改它们。</li><li><strong>主进程：</strong> 主进程继续处理客户端的请求。<ul><li>如果主进程执行<strong>读操作</strong>，它会直接访问这些共享的、未被修改的内存页面。</li><li>如果主进程执行<strong>写操作</strong>（例如 <code>SET</code>、<code>DEL</code>），当它尝试修改某个共享的内存页面时，操作系统会触发 <strong>COW</strong> 机制：<ul><li>操作系统会为这个即将被修改的内存页面<strong>创建一个私有的副本</strong>。</li><li>主进程的内存地址映射会被更新，使其指向这个新复制出来的页面。</li><li>主进程的写操作会在这个新复制的页面上完成。</li><li><strong>子进程仍然读取原始的、未被修改的共享内存页面</strong>。</li></ul></li></ul></li></ul></li><li><strong>子进程完成写入并通知主进程：</strong><ul><li>子进程完成 RDB 文件的写入后，会向主进程发送一个信号。</li><li>在子进程写入完成之前，即使子进程崩溃，也不会影响主进程的正常运行和数据。</li></ul></li><li><strong>主进程替换 RDB 文件：</strong><ul><li>主进程收到子进程的成功信号后，会<strong>原子地用新生成的临时 RDB 文件替换掉旧的 RDB 文件</strong>（通常是重命名操作）。</li><li>这个替换操作是极快的，不会造成服务阻塞</li></ul></li></ol><p><img data-src="https://cdn.xiaolincoding.com//mysql/other/c34a9d1f58d602ff1fe8601f7270baa7-20230309232304226.png" alt="img"></p><p>也就是利用写时复制技术实现了在子进程进行读取内存写入新RDB文件时,主线程能够修改数据.</p><p>执行 bgsave 命令的时候，会通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，此时如果主线程执行读操作，则主线程和 bgsave 子进程互相不影响。</p><p>如果主线程执行写操作，则被修改的数据会复制一份副本，然后 bgsave 子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。</p><p><strong>优点：</strong></p><ul><li><strong>恢复速度快：</strong> RDB 文件是经过压缩的二进制格式，恢复时直接加载到内存即可，速度远快于 AOF 重放命令。</li><li><strong>文件紧凑：</strong> RDB 文件比 AOF 文件小得多，适合做备份和传输。</li><li><strong>更适合灾难恢复：</strong> 对数据的恢复点清晰。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>数据丢失风险：</strong> 无法做到实时持久化。如果在两次 RDB 快照之间 Redis 发生崩溃，最后一次快照之后的所有数据都将丢失。丢失的数据量取决于 <code>save</code> 配置的间隔时间。</li><li><strong><code>fork()</code> 阻塞：</strong> <code>BGSAVE</code> 命令在 <code>fork()</code> 阶段会短暂阻塞主进程，对于内存非常大的实例，这个阻塞可能比较明显。</li><li><strong>频繁 <code>fork()</code> 的开销：</strong> 如果配置的 <code>save</code> 规则过于频繁，或者写操作过于集中，可能导致频繁的 <code>fork()</code> 操作，增加系统开销。</li></ul><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。</p><p>Reids 是先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做其实有两个好处。</p><ul><li><strong>避免额外的检查开销</strong>：因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。</li><li><strong>不会阻塞当前写操作命令的执行</strong>：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。</li></ul><p>当然，这样做也会带来风险：</p><ul><li><strong>数据可能会丢失：</strong> 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。</li><li><strong>可能阻塞其他操作：</strong> 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。</li></ul><h3 id="AOF回写策略"><a href="#AOF回写策略" class="headerlink" title="AOF回写策略"></a>AOF回写策略</h3><p><img data-src="https://cdn.xiaolincoding.com//mysql/other/4eeef4dd1bedd2ffe0b84d4eaa0dbdea-20230309232249413.png" alt="img" style="zoom:67%;" /></p><ol><li>Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区；</li><li>然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；</li><li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。</li></ol><p>Redis 提供了 3 种写回硬盘的策略，控制的就是上面说的第三步的过程。 在 Redis.conf 配置文件中的 appendfsync 配置项可以有以下 3 种参数可填：</p><ul><li><strong>Always</strong>，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘； <strong>每次</strong>有新的写命令追加到 AOF 缓冲区时，都会立即执行 <code>fsync()</code> 操作，将缓冲区中的所有数据同步到磁盘。</li><li><strong>Everysec</strong>，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；Redis 会将 AOF 缓冲区的数据写入操作系统内存缓冲区，然后启动一个<strong>后台线程</strong>，<strong>每秒</strong>将这些数据同步到磁盘一次。</li><li><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。Redis 只负责将 AOF 缓冲区的数据写入操作系统内存缓冲区，<strong>不主动进行 <code>fsync()</code> 操作</strong>。数据何时同步到磁盘完全由操作系统决定（通常是每 30 秒或当缓冲区满时）。</li></ul><p><img data-src="https://cdn.xiaolincoding.com//mysql/other/98987d9417b2bab43087f45fc959d32a-20230309232253633.png" alt="img"></p><h3 id="AOF日志过大会触发什么机制"><a href="#AOF日志过大会触发什么机制" class="headerlink" title="AOF日志过大会触发什么机制"></a>AOF日志过大会触发什么机制</h3><p>AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。 如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。</p><p>所以，Redis 为了避免 AOF 文件越写越大，提供了 <strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p><h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>AOF 重写机制是在重写时，<strong>读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。</strong></p><p><img data-src="https://cdn.xiaolincoding.com//mysql/other/723d6c580c05400b3841bc69566dd61b-20230309232257343.png" alt="img"></p><p>Redis 的<strong>重写 AOF 过程是由子进程 *bgrewriteaof* 来完成的</strong>，这么做可以达到两个好处:</p><ul><li>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；</li><li>子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</li></ul><p>触发重写机制后，主进程就会创建重写 AOF 的子进程，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读，重写 AOF 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志（新的 AOF 文件）。</p><p><strong>但是重写过程中，主进程依然可以正常处理命令</strong>，那问题来了，重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，那么会发生写时复制，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢？</p><p>为了解决这种数据不一致问题，Redis 设置了一个 <strong>AOF 重写缓冲区</strong>，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。</p><p>在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会<strong>同时将这个写命令写入到 AOF 缓冲区和 AOF 重写缓冲区</strong>。</p><p><img data-src="https://cdn.xiaolincoding.com//mysql/other/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70-20230309232301042.png" alt="img"></p><p>在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p><ul><li>执行客户端发来的命令；</li><li>将执行后的写命令追加到 「AOF 缓冲区」；这是为了确保即使 AOF 重写失败，旧的 AOF 文件仍然是完整且最新的，不会丢失任何数据。</li><li>将执行后的写命令追加到 「AOF 重写缓冲区」；所有在重写期间新发生的写命令都会被缓存到这个独立的缓冲区中。 </li></ul><p>当子进程完成 AOF 重写工作（<em>扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</em>）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。</p><p>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p><ul><li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；</li><li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</li></ul><h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。</p><p>AOF 优点是丢失数据少，但是数据恢复不快。</p><p>为了集成了两者的优点， Redis 4.0 提出了<strong>混合使用 AOF 日志和内存快照</strong>，也叫混合持久化，既保证了 Redis 重启速度，又降低数据丢失风险。</p><p>混合持久化工作在 <strong>AOF 日志重写过程</strong>，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p><p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p><p>重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。</p><p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p><p><strong>混合持久化优点：</strong></p><ul><li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li></ul><p><strong>混合持久化缺点：</strong></p><ul><li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li><li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了</li></ul><h2 id="大-Key-对持久化影响"><a href="#大-Key-对持久化影响" class="headerlink" title="大 Key 对持久化影响"></a>大 Key 对持久化影响</h2><h3 id="对AOF日志影响"><a href="#对AOF日志影响" class="headerlink" title="对AOF日志影响"></a>对AOF日志影响</h3><p>AOF有三种写回磁盘策略,分别是：</p><ul><li>Always，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</li><li>Everysec，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li><li>No，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</li></ul><p>这三种策略只是在控制 fsync() 函数的调用时机。</p><p>当应用程序向文件写入数据时，内核通常先将数据复制到内核缓冲区中，然后排入队列，然后由内核决定何时写入硬盘。</p><p>如果想要应用程序向文件写入数据后，能立马将数据同步到硬盘，就可以调用 fsync() 函数，这样内核就会将内核缓冲区的数据直接写入到硬盘，等到硬盘写操作完成后，该函数才会返回。</p><ul><li>Always 策略就是每次写入 AOF 文件数据后，就执行 fsync() 函数；</li><li>Everysec 策略就会创建一个异步任务来执行 fsync() 函数；</li><li>No 策略就是永不执行 fsync() 函数;</li></ul><p>在使用 Always 策略的时候，主线程在执行完命令后，会把数据写入到 AOF 日志文件，然后会调用 fsync() 函数，将内核缓冲区的数据直接写入到硬盘，等到硬盘写操作完成后，该函数才会返回。</p><p><strong>当使用 Always 策略的时候，如果写入是一个大 Key，主线程在执行 fsync() 函数的时候，阻塞的时间会比较久，因为当写入的数据量很大的时候，数据同步到硬盘这个过程是很耗时的</strong>。</p><p>当使用 Everysec 策略的时候，由于是异步执行 fsync() 函数，所以大 Key 持久化的过程（数据同步磁盘）不会影响主线程。</p><p>当使用 No 策略的时候，由于永不执行 fsync() 函数，所以大 Key 持久化的过程不会影响主线程。</p><h3 id="AOF重写和RDB影响"><a href="#AOF重写和RDB影响" class="headerlink" title="AOF重写和RDB影响"></a>AOF重写和RDB影响</h3><p>当 AOF 日志写入了很多的大 Key，AOF 日志文件的大小会很大，那么很快就会触发 <strong>AOF 重写机制</strong>。</p><p>AOF 重写机制和 RDB 快照（bgsave 命令）的过程，都会分别通过 <code>fork()</code> 函数创建一个子进程来处理任务。</p><p>在创建子进程的过程中，<strong>操作系统会把父进程的「页表」复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系</strong>，而不会复制物理内存，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。</p><p>子进程就共享了父进程的物理内存数据了，这样能够节约物理内存资源，页表对应的页表项的属性会标记该物理内存的权限为<strong>只读</strong>。</p><p>随着 Redis 存在越来越多的大 Key，那么 Redis 就会占用很多内存，对应的页表就会越大。</p><p>在通过 <code>fork()</code> 函数创建子进程的时候，虽然不会复制父进程的物理内存，但是<strong>内核会把父进程的页表复制一份给子进程，如果页表很大，那么这个复制过程是会很耗时的，那么在执行 fork 函数的时候就会发生阻塞现象</strong>。<strong>fork 函数是由 Redis 主线程调用的，如果 fork 函数发生阻塞，那么意味着就会阻塞 Redis 主线程</strong>。由于 Redis 执行命令是在主线程处理的，所以当 Redis 主线程发生阻塞，就无法处理后续客户端发来的命令。</p><p>当父进程或者子进程在向共享内存发起写操作时，CPU 就会触发<strong>写保护中断</strong>，这个「写保护中断」是由于违反权限导致的，<strong>然后操作系统会在「写保护中断处理函数」里进行物理内存的复制，并重新设置其内存映射关系，将父子进程的内存读写权限设置为可读写</strong>，最后才会对内存进行写操作，这个过程被称为「<strong>写时复制(Copy On Write)</strong>」。</p><p>写时复制顾名思义，在发生写操作的时候，操作系统才会去复制物理内存，这样是为了防止 fork 创建子进程时，由于物理内存数据的复制时间过长而导致父进程长时间阻塞的问题。</p><p>如果创建完子进程后，<strong>父进程对共享内存中的大 Key 进行了修改，那么内核就会发生写时复制，会把物理内存复制一份，由于大 Key 占用的物理内存是比较大的，那么在复制物理内存这一过程中，也是比较耗时的，于是父进程（主线程）就会发生阻塞</strong>。</p><p>所以，有两个阶段会导致阻塞父进程：</p><ul><li>创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；</li><li>创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长；</li></ul><p>当 AOF 写回策略配置了 Always 策略，如果写入是一个大 Key，主线程在执行 fsync() 函数的时候，阻塞的时间会比较久，因为当写入的数据量很大的时候，数据同步到硬盘这个过程是很耗时的。</p><p>AOF 重写机制和 RDB 快照（bgsave 命令）的过程，都会分别通过 <code>fork()</code> 函数创建一个子进程来处理任务。会有两个阶段会导致阻塞父进程（主线程）：</p><ul><li>创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；</li><li>创建完子进程后，如果父进程修改了共享数据中的大 Key，就会发生写时复制，这期间会拷贝物理内存，由于大 Key 占用的物理内存会很大，那么在复制物理内存这一过程，就会比较耗时，所以有可能会阻塞父进程。</li></ul><blockquote><p>大 key 除了会影响持久化之外，还会有以下的影响：</p></blockquote><ul><li>客户端超时阻塞。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li><li>引发网络阻塞。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li><li>阻塞工作线程。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li><li>内存分布不均。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多。</li></ul><blockquote><p>如何避免大 Key 呢？</p></blockquote><p>最好在设计阶段，就把大 key 拆分成一个一个小 key。或者，定时检查 Redis 是否存在大 key ，如果该大 key 是可以删除的，不要使用 DEL 命令删除，因为该命令删除过程会阻塞主线程，而是用 unlink 命令（Redis 4.0+）删除大 key，因为该命令的删除过程是异步的，不会阻塞主线程。</p><h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><blockquote><p>主从如何进行同步</p><p>哨兵的节点故障转移</p><p>cluster集群的哈希槽</p><p>脑裂产生以及解决</p></blockquote><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>主从复制是 Redis 高可用服务的最基础的保证，实现方案就是将从前的一台 Redis 服务器，同步数据到多台从 Redis 服务器上，即一主多从的模式，且主从服务器之间采用的是「读写分离」的方式。</p><p><img data-src="https://cdn.xiaolincoding.com//mysql/other/2b7231b6aabb9a9a2e2390ab3a280b2d.png" alt="img" style="zoom:50%;" /></p><p>主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来写操作命令，然后执行这条命令。</p><p>具体来说，在主从服务器命令传播阶段，主服务器收到新的写命令后，会发送给从服务器。但是，主服务器并不会等到从服务器实际执行完命令后，再把结果返回给客户端，而是主服务器自己在本地执行完命令后，就会向客户端返回结果了。如果从服务器还没有执行主服务器同步过来的命令，主从服务器间的数据就不一致了。所以无法实现强一致性保证（主从数据时时刻刻保持一致），数据不一致是难以避免的。</p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>在使用 Redis 主从服务的时候，会有一个问题，就是当 Redis 的主从服务器出现故障宕机时，需要手动进行恢复。</p><p>兵模式做到了可以监控主从服务器，并且提供<strong>主从节点故障转移的功能。</strong></p><p><img data-src="https://cdn.xiaolincoding.com//mysql/other/26f88373d8454682b9e0c1d4fd1611b4.png" alt="img" style="zoom:67%;" /></p><h3 id="cluster分片集群"><a href="#cluster分片集群" class="headerlink" title="cluster分片集群"></a>cluster分片集群</h3><p>当 Redis 缓存数据量大到一台服务器无法缓存时，就需要使用 <strong>Redis 切片集群</strong>（Redis Cluster ）方案，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。</p><p>使用哈希槽来处理数据和节点之间的映射,<strong>一个切片集群共有 16384 个哈希槽</strong>，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步：</p><ul><li>根据键值对的 key，按照 CRC16计算一个 16 bit 的值。</li><li>再用 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。</li></ul><p>这些哈希槽怎么被映射到具体的 Redis 节点上的呢？有两种方案：</p><ul><li><strong>平均分配：</strong> 在使用 cluster create 命令创建 Redis 集群时，Redis 会自动把所有哈希槽平均分布到集群节点上。比如集群中有 9 个节点，则每个节点上槽的个数为 16384/9 个。</li><li><strong>手动分配：</strong> 可以使用 cluster meet 命令手动建立节点间的连接，组成集群，再使用 cluster addslots 命令，指定每个节点上的哈希槽个数。</li></ul><p>当读取或设置key时的流程.在Redis cluster模式下，节点对请求的处理过程如下：</p><ul><li>通过哈希槽映射，检查当前Redis key是否存在当前节点</li><li>若哈希槽不是由自身节点负责，就返回MOVED重定向</li><li>若哈希槽确实由自身负责，且key在slot中，则返回该key对应结果</li><li>若Redis key不存在此哈希槽中，检查该哈希槽是否正在迁出（MIGRATING）？</li><li>若Redis key正在迁出，返回ASK错误重定向客户端到迁移的目的服务器上</li><li>若哈希槽未迁出，检查哈希槽是否导入中？</li><li>若哈希槽导入中且有ASKING标记，则直接操作，否则返回MOVED重定向</li></ul><p>cluster集群管理重要命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 \</span><br><span class="line">127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \</span><br><span class="line">--cluster-replicas 1</span><br><span class="line">redis-cli --cluster check 127.0.0.1:7000</span><br><span class="line">redis-cli --cluster reshard 127.0.0.1:7000</span><br><span class="line">redis-cli --cluster rebalance 127.0.0.1:7000</span><br></pre></td></tr></table></figure><p>CLUSTER命令是redis-cli —cluster分片集群管理的底层指令,在要移除一个节点时,</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster reshard &lt;any_existing_node_ip&gt;:&lt;any_existing_node_port&gt;</span><br><span class="line">redis-cli --cluster del-node &lt;any_existing_node_ip&gt;:&lt;any_existing_node_port&gt; &lt;node_id_to_delete&gt;</span><br></pre></td></tr></table></figure><p>客户端给一个Redis实例发送数据读写操作时，如果这个实例上并没有相应的数据，会怎么样呢？</p><p>在Redis cluster模式下，节点对请求的处理过程如下：</p><ul><li>通过哈希槽映射，检查当前Redis key是否存在当前节点</li><li>若哈希槽<strong>不是由自身节点负责</strong>，就返回MOVED重定向</li><li>若哈希槽确实由自身负责，且key在slot中，则返回该key对应结果</li><li>若Redis key不存在此哈希槽中，检查该哈希槽是否正在迁出（MIGRATING）？</li><li>若Redis key正在迁出，返回ASK错误重定向客户端到迁移的目的服务器上</li><li>若哈希槽未迁出，检查哈希槽是否导入中？</li><li>若哈希槽导入中且有ASKING标记，则直接操作，否则返回MOVED重定向</li></ul><h4 id="MOVED重定向"><a href="#MOVED重定向" class="headerlink" title="MOVED重定向"></a>MOVED重定向</h4><p>其中MOVED重定向<code>MOVED</code> 重定向表示<strong>某个哈希槽（及其包含的数据）已经永久性地从当前节点迁移到了另一个节点</strong>。这意味着集群的拓扑结构已经发生了变化。</p><ul><li><strong>哈希槽迁移完成：</strong> 当一个哈希槽的迁移过程（通过 <code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;node_id&gt;</code> 命令）完全结束，该槽位被正式分配给新的目标节点时。</li><li><strong>客户端请求不属于当前节点的键：</strong> 客户端向一个节点发送了对某个键的请求，但计算得出该键所属的哈希槽不属于当前节点，而是由集群中的另一个节点负责。这通常发生在客户端的哈希槽映射缓存过期或不准确时。</li></ul><p>客户端给一个Redis实例发送数据读写操作时，如果计算出来的槽不是在该节点上，这时候它会返回MOVED重定向错误，MOVED重定向错误中，会将哈希槽所在的新实例的IP和port端口带回去。这就是Redis Cluster的MOVED重定向机制。</p><p><img data-src="https://cdn.xiaolincoding.com//picgo/1d4685f1f19d72aff8412498c05bed4a.png" alt="img" style="zoom:67%;" /></p><h4 id="ASK重定向"><a href="#ASK重定向" class="headerlink" title="ASK重定向"></a>ASK重定向</h4><p>Ask重定向一般发生于集群伸缩的时候。集群伸缩会导致槽迁移，当去源节点访问时，此时数据已经可能已经迁移到了目标节点，使用Ask重定向可以解决此种情况</p><p><code>ASK</code> 重定向表示<strong>某个哈希槽正在进行迁移（resharding）操作，当前键可能已经迁移到目标节点，或者在源节点上不存在（新写入的键）</strong>。这是一个<strong>临时性</strong>的重定向，发生在哈希槽迁移过程中，当源节点处于 <code>MIGRATING</code> 状态，而目标节点处于 <code>IMPORTING</code> 状态时。</p><p>在哈希槽迁移（例如 <code>reshard</code> 命令执行期间）的过程中，当客户端向<strong>源节点</strong>（<code>MIGRATING</code> 状态）发送对一个键的请求时：</p><ol><li>如果该键在源节点上<strong>不存在</strong>（可能是新创建的键，或者该键已经迁移到了目标节点，但客户端仍然向源节点请求），源节点会返回 <code>ASK &lt;hash_slot&gt; &lt;target_node_ip&gt;:&lt;target_node_port&gt;</code> 错误。</li><li>如果该键在源节点上<strong>存在且尚未被迁移</strong>，源节点会直接处理该命令，不会进行 <code>ASK</code> 重定向。</li></ol><p><img data-src="https://cdn.xiaolincoding.com//picgo/fe3703c3d045462a12b41a628ff26825.png" alt="img"></p><p>各个节点之间通过gossip协议互相通信,一个节点想要分享一些信息给网络中的其他的一些节点。于是，<strong>它周期性的随机选择一些节点，并把信息传递给这些节点</strong>。这些收到信息的节点接下来会做同样的事情，即把这些信息传递给其他一些随机选择的节点。一般而言，信息会周期性的传递给N个目标节点，而不只是一个。这个N被称为fanout</p><p>节点之前不断交换信息，交换的信息内容包括节点出现故障、新节点加入、主从节点变更信息、slot信息等等。gossip协议包含多种消息类型，包括ping，pong，meet，fail等等</p><p><img data-src="https://cdn.xiaolincoding.com//picgo/cd36f67141ebab2e43b2371a7fd51c8c.png" alt="img" style="zoom:67%;" /></p><ul><li>meet消息：通知新节点加入。消息发送者通知接收者加入到当前集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping、pong消息交换。</li><li>ping消息：节点每秒会向集群中其他节点发送 ping 消息，消息中带有自己已知的两个节点的地址、槽、状态信息、最后一次通信时间等</li><li>pong消息：当接收到ping、meet消息时，作为响应消息回复给发送方确认消息正常通信。消息中同样带有自己已知的两个节点信息。</li><li>fail消息：当节点判定集群内另一个节点下线时，会向集群内广播一个fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态。</li></ul><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>Redis集群实现了高可用，当集群内节点出现故障时，通过<strong>故障转移</strong>，以保证集群正常对外提供服务。</p><p>redis集群通过ping/pong消息，实现故障发现。这个环境包括<strong>主观下线和客观下线。</strong></p><ul><li><p><strong>主观下线</strong>：某个节点认为另一个节点不可用，即下线状态，这个状态并不是最终的故障判定，只能代表一个节点的意见，可能存在误判情况。</p></li><li><p><strong>客观下线</strong>：指标记一个节点真正的下线，集群内多个节点都认为该节点不可用，从而达成共识的结果。如果是持有槽的主节点故障，需要为该节点进行故障转移。</p></li><li><p>假如节点A标记节点B为主观下线，一段时间后，节点A通过消息把节点B的状态发到其它节点，当节点C接受到消息并解析出消息体时，如果发现节点B的pfail状态时，会触发客观下线流程；</p></li><li><p>当下线为主节点时，此时Redis Cluster集群为统计持有槽的主节点投票，看投票数是否达到一半，当下线报告统计数大于一半时，被标记为客观下线状态。</p></li><li><p>故障恢复：故障发现后，如果下线节点的是主节点，则需要在它的从节点中选一个替换它，以保证集群的高可用。流程如下：</p></li></ul><p><img data-src="https://cdn.xiaolincoding.com//picgo/9ca67fa36a0c084e315e843e6ef46197.png" alt="img"></p><ul><li>资格检查：检查从节点是否具备替换故障主节点的条件。</li><li>准备选举时间：资格检查通过后，更新触发故障选举时间。</li><li>发起选举：到了故障选举时间，进行选举。</li><li>选举投票：只有持有槽的主节点才有票，从节点收集到足够的选票（大于一半），触发替换主节点</li></ul><h2 id="Redis-Cluster的Hash-Slot-是16384"><a href="#Redis-Cluster的Hash-Slot-是16384" class="headerlink" title="Redis Cluster的Hash Slot 是16384"></a>Redis Cluster的Hash Slot 是16384</h2><p>减少节点之间传递哈希槽的数据量</p><p>减少哈希碰撞概率</p><p>哨兵模式已经实现了故障自动转移的能力，但业务规模的不断扩展，用户量膨胀，并发量持续提升，会出现了 Redis 响应慢的情况。</p><p>使用 Redis Cluster 集群，主要解决了大数据量存储导致的各种慢问题，同时也便于横向拓展。在面对千万级甚至亿级别的流量的时候，很多大厂的做法是在千百台的实例节点组成的集群上进行流量调度、服务治理的。</p><p>整个Redis数据库划分为16384个哈希槽，Redis集群可能有n个实例节点，每个节点可以处理0个 到至多 16384 个槽点，这些节点把 16384个槽位瓜分完成。</p><p>Cluster 是具备Master 和 Slave模式，Redis 集群中的每个实例节点都负责一些槽位，节点之间保持TCP通信，当Master发生了宕机， Redis Cluster自动会将对应的Slave节点选为Master，来继续提供服务。</p><p>客户端能够快捷的连接到服务端，主要是将slots与实例节点的映射关系存储在本地，当需要访问的时候，对key进行CRC16计算后，再对16384 取模得到对应的 Slot 索引，再定位到相应的实例上。实现高效的连接。</p><h3 id="集群脑裂导致的数据丢失"><a href="#集群脑裂导致的数据丢失" class="headerlink" title="集群脑裂导致的数据丢失"></a>集群脑裂导致的数据丢失</h3><p>导致集群脑裂的原因:主节点与集群中其他节点出现网络问题失去连接.</p><p>在 Redis 主从架构中，部署方式一般是「一主多从」，主节点提供写操作，从节点提供读操作。 如果<strong>主节点的网络突然发生了问题，它与所有的从节点都失联了，但是此时的主节点和客户端的网络是正常的，这个客户端并不知道 Redis 内部已经出现了问题，还在照样的向这个失联的主节点写数据（过程A），此时这些数据被旧主节点缓存到了缓冲区里，因为主从节点之间的网络问题，这些数据都是无法同步给从节点的</strong>。</p><p>这时，哨兵也发现主节点失联了，它就认为主节点挂了（但实际上主节点正常运行，只是网络出问题了），于是哨兵就会在「从节点」中选举出一个 leader 作为主节点，这时集群就有两个主节点了 —— <strong>脑裂出现了</strong>。</p><p>然后，网络突然好了，哨兵因为之前已经选举出一个新主节点了，它就会把旧主节点降级为从节点（A），然后从节点（A）会向新主节点请求数据同步，<strong>因为第一次同步是全量同步的方式，此时的从节点（A）会清空掉自己本地的数据，然后再做全量同步。所以，之前客户端在过程 A 写入的数据就会丢失了，也就是集群产生脑裂数据丢失的问题</strong>。</p><blockquote><p>由于网络问题，集群节点之间失去联系。主从数据不同步；重新平衡选举，产生两个主服务。等网络恢复，旧主节点会降级为从节点，再与新主节点进行同步复制的时候，由于会从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。</p></blockquote><p><strong>解决方案</strong></p><p>当主节点发现从节点下线或者通信超时的总数量小于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。</p><p>在 Redis 的配置文件中有两个参数我们可以设置：</p><ul><li>min-slaves-to-write x，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据。</li><li>min-slaves-max-lag x，主从数据复制和同步的延迟不能超过 x 秒，如果超过，主节点会禁止写数据。</li></ul><p>我们可以把 min-slaves-to-write 和 min-slaves-max-lag 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 N 和 T。</p><p>这两个配置项组合后的要求是，主库连接的从库中至少有 N 个从库，和主库进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主库就不会再接收客户端的写请求了。</p><p>即使原主库是假故障，它在假故障期间也无法响应哨兵心跳，也不能和从库进行同步，自然也就无法和从库进行 ACK 确认了。这样一来，min-slaves-to-write 和 min-slaves-max-lag 的组合要求就无法得到满足，<strong>原主库就会被限制接收客户端写请求，客户端也就不能在原主库中写入新数据了</strong>。</p><p><strong>等到新主库上线时，就只有新主库能接收和处理客户端请求，此时，新写的数据会被直接写到新主库中。而原主库会被哨兵降为从库，即使它的数据被清空了，也不会有新数据丢失。</strong></p><h2 id="如何判断Redis某个节点是否正常"><a href="#如何判断Redis某个节点是否正常" class="headerlink" title="如何判断Redis某个节点是否正常"></a>如何判断Redis某个节点是否正常</h2><p>判断 Redis 某个节点是否正常工作是一个常见的运维和开发需求。接下来我会详细讲述判断 Redis 节点正常工作五种常见方式。</p><p>第一种是采用 PING 命令，它是 Redis 内置命令，用于测试 Redis 服务是否可用。如果 Redis 节点正常工作，执行 PING 命令会返回 PONG。如果未收到 PONG 或连接超时，则说明节点可能存在问题。</p><p>第二种是采用 INFO 命令，它也是 Redis 内置命令，INFO 命令可以返回 Redis 节点的详细运行信息，包括内存使用、连接数、持久化状态等。通过解析这些信息，可以判断节点是否处于正常状态。例如，检查 role 字段可以确认节点是主节点还是从节点，检查 connected_clients 可以确认是否有过多的客户端连接。</p><p>第三种是采用 CLUSTER INFO 命令（集群模式），它还是 Redis 内置命令，如果 Redis 运行在集群模式下，可以使用 CLUSTER INFO 命令查看集群的状态。重点关注 cluster_state 字段，如果值为 ok，则表示集群正常；如果是 fail，则说明集群中有节点不可用。</p><p>第四种是采用 Telnet 或 Netcat，它们属于外部工具，用于测试 Redis 节点的端口是否可达。例如，尝试连接到 Redis 的默认端口 6379，如果连接失败，说明节点可能宕机或网络有问题。</p><p>第五种是采用监控系统，配置 Prometheus、Grafana 等监控工具，实时监控 Redis 的性能指标（如内存使用率、QPS、延迟等）。如果某些指标超出阈值或出现异常波动，可能是节点出现问题</p><h1 id="过期删除与内存淘汰策略"><a href="#过期删除与内存淘汰策略" class="headerlink" title="过期删除与内存淘汰策略"></a>过期删除与内存淘汰策略</h1><p>Redis 是可以对 key 设置过期时间的，因此需要有相应的机制将已过期的键值对删除，而做这个工作的就是过期键值删除策略。</p><p>通过expire以及setex, set key \<ex>等设置过期时间,ttl查看剩余时间.</p><h2 id="如何判定过期"><a href="#如何判定过期" class="headerlink" title="如何判定过期"></a>如何判定过期</h2><p>当对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间存储到一个<strong>过期字典</strong>（expires dict）中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;    <span class="comment">/* 数据库键空间，存放着所有的键值对 */</span></span><br><span class="line">    dict *expires; <span class="comment">/* 键的过期时间 */</span></span><br><span class="line">    ....</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>过期字典数据结构结构如下：</p><ul><li>过期字典的 key 是一个指针，指向某个键对象；</li><li>过期字典的 value 是一个 long long 类型的整数，这个整数保存了 key 的过期时间；</li></ul><p>字典实际上是哈希表，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找。当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：</p><ul><li>如果不在，则正常读取键值；</li><li>如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。</li></ul><h2 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h2><p> <strong>Redis 选择「惰性删除+定期删除」这两种策略配和使用</strong>，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。</p><p>定期删除策略的做法是，<strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong></p><p>定期删除策略的<strong>优点</strong>：</p><ul><li>通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。</li></ul><p>定期删除策略的<strong>缺点</strong>：</p><ul><li>内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。</li><li>难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放</li></ul><p>定期删除策略的做法：<strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong></p><p><em>1、这个间隔检查的时间是多长呢？</em></p><p>在 Redis 中，默认每秒进行 10 次过期检查一次数据库，此配置可通过 Redis 的配置文件 redis.conf 进行配置，配置键为 hz 它的默认值是 hz 10。</p><p>特别强调下，每次检查数据库并不是遍历过期字典中的所有 key，而是从数据库中随机抽取一定数量的 key 进行过期检查。</p><p><em>2、随机抽查的数量是多少呢？</em></p><p>我查了下源码，定期删除的实现在 expire.c 文件下的 <code>activeExpireCycle</code> 函数中，其中随机抽查的数量由 <code>ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP</code> 定义的，它是写死在代码中的，数值是 20。</p><p>也就是说，数据库每轮抽查时，会随机选择 20 个 key 判断是否过期。</p><p>接下来，详细说说 Redis 的定期删除的流程：</p><ol><li>从过期字典中随机抽取 20 个 key；</li><li>检查这 20 个 key 是否过期，并删除已过期的 key；</li><li>如果本轮检查的已过期 key 的数量，超过 5 个（20/4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。</li></ol><p>可以看到，定期删除是一个循环的流程。</p><p>那 Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。</p><p>惰性删除策略的做法是，<strong>不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。</strong></p><p>惰性删除策略的<strong>优点</strong>：</p><ul><li>因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 CPU 时间最友好。</li></ul><p>惰性删除策略的<strong>缺点</strong>：</p><ul><li>如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友</li></ul><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>当 Redis 的运行内存已经超过 Redis 设置的最大内存之后，则会使用内存淘汰策略删除符合条件的 key，以此来保障 Redis 高效的运行。在配置文件 redis.conf 中，可以通过参数 <code>maxmemory &lt;bytes&gt;</code> 来设定最大运行内存，只有在 Redis 的运行内存达到了我们设置的最大运行内存，才会触发内存淘汰策略。 不同位数的操作系统，maxmemory 的默认值是不同的：</p><ul><li>在 64 位操作系统中，maxmemory 的默认值是 0，表示没有内存大小限制，那么不管用户存放多少数据到 Redis 中，Redis 也不会对可用内存进行检查，直到 Redis 实例因内存不足而崩溃也无作为。</li><li>在 32 位操作系统中，maxmemory 的默认值是 3G，因为 32 位的机器最大只支持 4GB 的内存，而系统本身就需要一定的内存资源来支持运行，所以 32 位操作系统限制最大 3 GB 的可用内存是非常合理的，这样可以避免因为内存不足而导致 Redis 实例崩溃。</li></ul><p>Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。</p><p><em>1、不进行数据淘汰的策略</em></p><p><strong>noeviction</strong>（Redis3.0之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，会报错通知禁止写入，不淘汰任何数据，但是如果没用数据写入的话，只是单纯的查询或者删除操作的话，还是可以正常工作。</p><p><em>2、进行数据淘汰的策略</em></p><p>针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。</p><p>在设置了过期时间的数据中进行淘汰：</p><ul><li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li><li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li><li><strong>volatile-lru</strong>（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；</li><li><strong>volatile-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</li></ul><p>在所有数据范围内进行淘汰：</p><ul><li><strong>allkeys-random</strong>：随机淘汰任意键值;</li><li><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</li><li><strong>allkeys-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</li></ul><blockquote><p>什么是 LRU 算法？</p></blockquote><p><strong>LRU</strong> 全称是 Least Recently Used 翻译为<strong>最近最少使用</strong>，会选择淘汰最近最少使用的数据。</p><p>传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。</p><p>Redis 并没有使用这样的方式实现 LRU 算法，因为传统的 LRU 算法存在两个问题：</p><ul><li>需要用链表管理所有的缓存数据，这会带来额外的空间开销；</li><li>当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</li></ul><blockquote><p>Redis 是如何实现 LRU 算法的？</p></blockquote><p>Redis 实现的是一种<strong>近似 LRU 算法</strong>，目的是为了更好的节约内存，它的<strong>实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间</strong>。</p><p>当 Redis 进行内存淘汰时，会使用<strong>随机采样的方式来淘汰数据</strong>，它是随机取 5 个值（此值可配置），然后<strong>淘汰最久没有使用的那个</strong>。</p><p>Redis 实现的 LRU 算法的优点：</p><ul><li>不用为所有的数据维护一个大链表，节省了空间占用；</li><li><p>不用在每次数据访问时都移动链表项，提升了缓存的性能；</p><p>LRU 算法有一个问题，<strong>无法解决缓存污染问题</strong>，比如<strong>应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间</strong>，造成缓存污染。</p></li></ul><p>所以引入了LFU 算法,根据数据访问次数来淘汰数据，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p><p>所以， LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些。LFU 算法相比于 LRU 算法的实现，多记录了<strong>“数据的访问频次</strong>”的信息</p><p><strong>在 LRU 算法中</strong>，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。</p><p><strong>在 LFU 算法中</strong>，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，低 8bit 存储 logc(Logistic Counter)。</p><p>在每次 key 被访问时，会先对 logc 做一个衰减操作，衰减的值跟前后访问时间的差距有关系，如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大，这样实现的 LFU 算法是根据<strong>访问频率</strong>来淘汰数据的，而不只是访问次数。访问频率需要考虑 key 的访问是多长时间段内发生的。key 的先前访问距离当前时间越长，那么这个 key 的访问频率相应地也就会降低，这样被淘汰的概率也会更大。</p><ul><li>ldt 是用来<strong>记录 key 的访问时间戳</strong>；</li><li>logc 是用来<strong>记录 key 的访问频次</strong>，它的值越小表示使用频率越低，越容易淘汰，每个新加入的 key 的logc 初始值为 5。</li></ul><p>注意，logc 并不是单纯的访问次数，而是访问频次（访问频率），因为 <strong>logc 会随时间推移而衰减的</strong></p><p>对 logc 做完衰减操作后，就开始对 logc 进行增加操作，增加操作并不是单纯的 + 1，而是根据概率增加，如果 logc 越大的 key，它的 logc 就越难再增加。</p><p>所以，Redis 在访问 key 时，对于 logc 是这样变化的：</p><ol><li>先按照上次访问距离当前的时长，来对 logc 进行衰减；</li><li>然后，再按照一定概率增加 logc 的值</li></ol><p>redis.conf 提供了两个配置项，用于调整 LFU 算法从而控制 logc 的增长和衰减：</p><ul><li><code>lfu-decay-time</code> 用于调整 logc 的衰减速度，它是一个以分钟为单位的数值，默认值为1，lfu-decay-time 值越大，衰减越慢；</li><li><code>lfu-log-factor</code> 用于调整 logc 的增长速度，lfu-log-factor 值越大，logc 增长越慢</li></ul><h1 id="Redis在项目中应用"><a href="#Redis在项目中应用" class="headerlink" title="Redis在项目中应用"></a>Redis在项目中应用</h1><h2 id="如何设计缓存策略动态缓存热点数据"><a href="#如何设计缓存策略动态缓存热点数据" class="headerlink" title="如何设计缓存策略动态缓存热点数据"></a>如何设计缓存策略动态缓存热点数据</h2><p>由于数据存储受限，系统并不是将所有数据都需要存放到缓存中的，而<strong>只是将其中一部分热点数据缓存起来</strong>，所以我们要设计一个热点数据动态缓存的策略。</p><p>热点数据动态缓存的策略总体思路：<strong>通过数据最新访问时间来做排名，并过滤掉不常访问的数据，只留下经常访问的数据</strong>。</p><p>以电商平台场景中的例子，现在要求只缓存用户经常访问的 Top 1000 的商品。具体细节如下：</p><ul><li>先通过缓存系统做一个排序队列（比如存放 1000 个商品），系统会根据商品的访问时间，更新队列信息，越是最近访问的商品排名越靠前；</li><li>同时系统会定期过滤掉队列中排名最后的 200 个商品，然后再从数据库中随机读取出 200 个商品加入队列中；</li><li>这样当请求每次到达的时候，会先从队列中获取商品 ID，如果命中，就根据 ID 再从另一个缓存数据结构中读取实际的商品信息，并返回。</li></ul><p>在 Redis 中可以用 zadd 方法和 zrange 方法来完成排序队列和获取 200 个商品的操</p><h2 id="实现分布锁"><a href="#实现分布锁" class="headerlink" title="实现分布锁"></a>实现分布锁</h2><p><img data-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.jpg" alt="img" style="zoom:67%;" /></p><p>Redis 本身可以被多个客户端共享访问，正好就是一个共享存储系统，可以用来保存分布式锁，而且 Redis 的读写性能高，可以应对高并发的锁操作场景。</p><p>Redis 的 SET 命令有个 NX 参数可以实现「key不存在才插入」，所以可以用它来实现分布式锁：</p><ul><li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li><li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li></ul><p>基于 Redis 节点实现分布式锁时，对于加锁操作，我们需要满足三个条件。</p><ul><li>加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的方式完成，所以，我们使用 SET 命令带上 NX 选项来实现加锁；</li><li>锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以，我们在 SET 命令执行时加上 EX/PX 选项，设置其过期时间；</li><li>锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作，所以，我们使用 SET 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端；</li></ul><p>满足这三个条件的分布式命令如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock_key unique_value NX PX <span class="number">10000</span> </span><br></pre></td></tr></table></figure><ul><li>lock_key 就是 key 键；</li><li>unique_value 是客户端生成的唯一的标识，区分来自不同客户端的锁操作；</li><li>NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；</li><li>PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。</li></ul><p>而解锁的过程就是将 lock_key 键删除（del lock_key），但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以，解锁的时候，我们要先判断锁的 unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除。</p><p>可以看到，解锁是有两个操作，这时就需要 Lua 脚本来保证解锁的原子性，因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这样一来，就通过使用 SET 命令和 Lua 脚本在 Redis 单节点上完成了分布式锁的加锁和解锁。</p><blockquote><p>基于 Redis 实现分布式锁有什么优缺点？</p></blockquote><p>基于 Redis 实现分布式锁的<strong>优点</strong>：</p><ol><li>性能高效（这是选择缓存实现分布式锁最核心的出发点）。</li><li>实现方便。很多研发工程师选择使用 Redis 来实现分布式锁，很大成分上是因为 Redis 提供了 setnx 方法，实现分布式锁很方便。</li><li>避免单点故障（因为 Redis 是跨集群部署的，自然就避免了单点故障）。</li></ol><p>基于 Redis 实现分布式锁的<strong>缺点</strong>：</p><ul><li><p>超时时间不好设置</p><p>。如果锁的超时时间设置过长，会影响性能，如果设置的超时时间过短会保护不到共享资源。比如在有些场景中，一个线程 A 获取到了锁之后，由于业务代码执行时间可能比较长，导致超过了锁的超时时间，自动失效，注意 A 线程没执行完，后续线程 B 又意外的持有了锁，意味着可以操作共享资源，那么两个线程之间的共享资源就没办法进行保护了。</p><ul><li><strong>那么如何合理设置超时时间呢？</strong> 我们可以基于续约的方式设置超时时间：先给锁设置一个超时时间，然后启动一个守护线程，让守护线程在一段时间后，重新设置这个锁的超时时间。实现方式就是：写一个守护线程，然后去判断锁的情况，当锁快失效的时候，再次进行续约加锁，当主线程执行完成后，销毁续约锁即可，不过这种方式实现起来相对复杂。</li></ul></li><li><p><strong>Redis 主从复制模式中的数据是异步复制的，这样导致分布式锁的不可靠性</strong>。如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。</p></li></ul><h3 id="Redis如何解决集群情况下锁的可靠性"><a href="#Redis如何解决集群情况下锁的可靠性" class="headerlink" title="Redis如何解决集群情况下锁的可靠性"></a>Redis如何解决集群情况下锁的可靠性</h3><p>为了保证集群环境下分布式锁的可靠性，Redis 官方已经设计了一个分布式锁算法 Redlock</p><p>它是基于<strong>多个 Redis 节点</strong>的分布式锁，即使有节点发生了故障，锁变量仍然是存在的，客户端还是可以完成锁操作。官方推荐是至少部署 5 个 Redis 节点，而且都是主节点，它们之间没有任何关系，都是一个个孤立的节点。</p><p>Redlock 算法的基本思路，<strong>是让客户端和多个独立的 Redis 节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败</strong>。</p><p>这样一来，即使有某个 Redis 节点发生故障，因为锁的数据在其他节点上也有保存，所以客户端仍然可以正常地进行锁操作，锁的数据也不会丢失。</p><p>Redlock 算法加锁三个过程：</p><ul><li>第一步是，客户端获取当前时间（t1）。</li><li>第二步是，客户端按顺序依次向 N 个 Redis 节点执行加锁操作：<ul><li>加锁操作使用 SET 命令，带上 NX，EX/PX 选项，以及带上客户端的唯一标识。</li><li>如果某个 Redis 节点发生故障了，为了保证在这种情况下，Redlock 算法能够继续运行，我们需要给「加锁操作」设置一个超时时间（不是对「锁」设置超时时间，而是对「加锁操作」设置超时时间），加锁操作的超时时间需要远远地小于锁的过期时间，一般也就是设置为几十毫秒。</li></ul></li><li>第三步是，一旦客户端从超过半数（大于等于 N/2+1）的 Redis 节点上成功获取到了锁，就再次获取当前时间（t2），然后计算计算整个加锁过程的总耗时（t2-t1）。如果 t2-t1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败。</li></ul><p>可以看到，加锁成功要同时满足两个条件（<em>简述：如果有超过半数的 Redis 节点成功的获取到了锁，并且总耗时没有超过锁的有效时间，那么就是加锁成功</em>）：</p><ul><li>条件一：客户端从超过半数（大于等于 N/2+1）的 Redis 节点上成功获取到了锁；</li><li>条件二：客户端从大多数节点获取锁的总耗时（t2-t1）小于锁设置的过期时间。</li></ul><p>加<strong>锁成功后，客户端需要重新计算这把锁的有效时间，计算的结果是「锁最初设置的过期时间」减去「客户端从大多数节点获取锁的总耗时（t2-t1）」</strong>。如果计算的结果已经来不及完成共享数据的操作了，可以释放锁，以免出现还没完成数据操作，锁就过期了的情况。</p><p>加锁失败后，客户端向<strong>所有 Redis 节点发起释放锁的操作</strong>，释放锁的操作和在单节点上释放锁的操作一样，只要执行释放锁的 Lua 脚本就可以了。</p><h2 id="stream实现延迟队列"><a href="#stream实现延迟队列" class="headerlink" title="stream实现延迟队列"></a>stream实现延迟队列</h2><p>延迟队列是指把当前要做的事情，往后推迟一段时间再做。延迟队列的常见使用场景有以下几种：</p><ul><li>在淘宝、京东等购物平台上下单，超过一定时间未付款，订单会自动取消；</li><li>打车的时候，在规定时间没有车主接单，平台会取消你的单并提醒你暂时没有车主接单；</li><li>点外卖的时候，如果商家在10分钟还没接单，就会自动取消订单；</li></ul><p>在 Redis 可以使用有序集合（ZSet）的方式来实现延迟消息队列的，ZSet 有一个 Score 属性可以用来存储延迟执行的时间。</p><p><img data-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97.png" alt="img"></p><h2 id="数据库与缓存的一致性"><a href="#数据库与缓存的一致性" class="headerlink" title="数据库与缓存的一致性"></a>数据库与缓存的一致性</h2><p>更新缓存还是删缓存</p><p>先更新数据库还是先删缓存</p><p>延迟双删解决并发读写请求下的缓存不一致问题</p><p>如何保证先更新数据库再删除缓存操作能执行成功.</p><p>订阅mysql binlog,消息队列</p><p>订阅 MySQL Binlog 来解决缓存删除失败导致的数据不一致问题，是一种<strong>最终一致性</strong>的解决方案，也是目前业界公认的<strong>最可靠</strong>和<strong>最推荐</strong>的方式之一。它通过将数据变更的事件流作为驱动，确保数据库和缓存之间的数据保持同步。</p><h3 id="为什么会出现缓存删除失败问题？"><a href="#为什么会出现缓存删除失败问题？" class="headerlink" title="为什么会出现缓存删除失败问题？"></a>为什么会出现缓存删除失败问题？</h3><p>在“先更新数据库再删除缓存”的策略中，最常见的失败场景是：</p><ul><li><strong>数据库更新成功，但删除缓存操作失败。</strong> 这可能是由于网络问题、缓存服务宕机、Redis 连接超时等原因造成的。</li><li>一旦缓存删除失败，缓存中就会保留旧数据，而数据库中已经是新数据，导致<strong>数据不一致</strong>，用户可能会读取到脏数据。</li></ul><h3 id="订阅-Binlog-的解决方案原理"><a href="#订阅-Binlog-的解决方案原理" class="headerlink" title="订阅 Binlog 的解决方案原理"></a>订阅 Binlog 的解决方案原理</h3><p>这种方案的核心思想是：应用程序只负责更新数据库，而<strong>缓存的更新或删除则由一个独立的、专门的服务来完成，该服务通过监听 MySQL 的 Binlog 来感知数据库的变化</strong>。</p><p>Binlog（Binary Log）是 MySQL 的二进制日志，它记录了所有对数据库进行更改的事件，包括数据插入、更新、删除等操作的详细信息。</p><p>具体流程如下：</p><ol><li><strong>应用程序操作数据库：</strong><ul><li>业务应用层只进行数据库操作（<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>）。</li><li><strong>应用程序不再直接负责删除缓存。</strong></li></ul></li><li><strong>Binlog 实时同步到中间件：</strong><ul><li><strong>变更数据捕获 (Change Data Capture, CDC) 工具</strong>（例如 <strong>Canal</strong>、<strong>Debezium</strong> 等）作为 Binlog 的消费者，连接到 MySQL 数据库，并模拟成一个 MySQL 从库。</li><li>它会实时地读取 MySQL 的 Binlog，捕获所有的数据变更事件。</li><li>捕获到的变更事件会被发送到一个<strong>消息队列</strong>（例如 <strong>Kafka</strong>、<strong>RabbitMQ</strong> 等）。消息队列在这里起到了缓冲、解耦和削峰的作用，确保事件不会丢失，并且能够异步处理。</li></ul></li><li><strong>缓存同步服务消费消息：</strong><ul><li>一个独立的<strong>缓存同步服务</strong>（或称为“数据同步服务”）作为消息队列的消费者，订阅 Binlog 变更事件对应的消息主题。</li><li>当该服务收到数据库变更事件时，它会解析事件内容，知道是哪个表、哪条记录发生了什么变化。</li></ul></li><li><strong>根据事件类型操作缓存：</strong><ul><li><strong>对于更新 (UPDATE) 或删除 (DELETE) 事件：</strong> 缓存同步服务根据事件中的主键或唯一标识符，找到对应的缓存键，并执行<strong>缓存删除操作</strong>。</li><li><strong>对于插入 (INSERT) 事件：</strong> 如果业务需要，也可以选择预热缓存，将新数据插入到缓存中。但通常删除旧缓存是更常见的操作。</li></ul></li><li><strong>失败重试与告警：</strong><ul><li>如果缓存同步服务在删除缓存时遇到问题（例如，Redis 服务不可用），它会将该操作标记为失败，并利用消息队列的<strong>重试机制</strong>（如 Kafka 的死信队列、Spring Cloud Stream 的重试策略等）进行重试。</li><li>如果多次重试仍然失败，可以触发告警通知运维人员介入</li></ul></li></ol><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>使用<strong>Redis + Kafka实现缓存与数据库的一致性</strong>，在写入数据时，可以将操作信息发送到Kafka等消息队列，然后由消费者（可以是一个专门的服务）来处理数据库和缓存的同步。这种方案通过消息队列解耦了数据库和缓存的操作，确保两者的一致性。Kafka的可靠性保证了消息不丢失，因此可以保障一致性，但需要额外的基础设施来管理消息队列。</p><p>其次是使用<strong>Redis + TCC事务管理</strong>，TCC（Try-Confirm-Cancel）事务模型适用于分布式事务管理。在写入Redis和MySQL时，可以先在Redis进行预写操作（Try），然后确认MySQL的数据更新（Confirm），如果遇到失败，可以取消Redis的操作（Cancel）。这种方式通过分布式事务的处理，能够确保两者一致性，但需要额外的事务管理中间件，增加系统复杂度。</p><p>最后是使用<strong>分布式数据库中间件（如Sentinel, Canal等）</strong>，Redis的高可用架构可以借助Sentinel实现主从复制，保证缓存的高可用性和一致性。与此同时，Canal可以作为MySQL的增量数据订阅工具，实时同步数据库变更到Redis缓存。通过这种方式，可以实现高效的数据一致性保障，但配置和维护较为复杂。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ol><li><a href="https://xiaolincoding.com/redis/base/redis_interview.html">Redis 常见面试题 | 小林coding</a></li><li><a href="https://www.bilibili.com/video/BV1cr4y1671t/?spm_id_from=333.337.search-card.all.click&amp;vd_source=177ef88aa6608bc3652c72d71b0aa098">黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案+黑马点评实战项目_哔哩哔哩_bilibili</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为redis与mysql经常搭配使用,也是面试常问,这里记录一些常见基础题.&lt;br&gt;</summary>
    
    
    
    
    <category term="Redis" scheme="https://www.sekyoro.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>coding agent in real world</title>
    <link href="https://www.sekyoro.top/2025/07/01/coding-agent-in-real-world/"/>
    <id>https://www.sekyoro.top/2025/07/01/coding-agent-in-real-world/</id>
    <published>2025-07-01T07:09:55.000Z</published>
    <updated>2025-07-01T09:41:55.116Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近AI辅助编程特别火,主要是从llm时代,比如gpt4,llama4,claude,gemini等大模型出来后,再到cursor的vibe coding,最后到现在的<a href="https://openai.com/index/openai-codex/">OpenAI Codex | OpenAI</a>,<a href="https://ai-claude.net/code/">Claude Code</a>以及<a href="https://github.com/google-gemini/gemini-cli">google-gemini.</a>anthropic提出了MCP与cli工具,旗下的模型评测效果也很不错,在这些方面,似乎anthropic,openai是领跑者,而meta和google都紧随其后,微软主要是资助openai,而在国内主要是字节Coze,豆包等工具. </p><p>之前一段时间流行过的文生图/文生视频等模型或应用热度也在明显降低,比如<a href="https://openai.com/sora/">Sora | OpenAI</a>,<a href="https://jimeng.jianying.com/">即梦AI - 即刻造梦</a>,<a href="https://app.klingai.com/cn/">可灵 </a>,<a href="https://hailuoai.com/">海螺视频</a>,<a href="https://www.heygen.com/">HeyGen</a>,.但是在视频创作领域,这些工具已经逐渐成了基本功能了. 国内主要是字节和minimax,快手等公司持续发力.</p><span id="more"></span><p>在AI IDE上,主要有Cursor,vscode,trae,cline,windsurf等本地工具,主要特点是通过tab不断vibe coding以及agent模式的利用上下文编辑代码. 个人感觉这类工具本身差别不大. 还有web版的<a href="https://bolt.new/">bolt.new</a>,<a href="https://v0.dev/">v0 by Vercel</a>以及<a href="https://lovable.dev/">Lovable</a>.</p><p>而现在,在google开源了gemini cli后,似乎出现了新的范式,其主要优点就是免费+开源.</p><p>类似的AI工具还有<a href="https://jules.google.com/task">Jules</a>,<a href="https://agent.minimax.io/">MiniMax Agent</a>,<a href="https://aws.amazon.com/cn/q/developer/"> Amazon Q 开发者版 – AWS</a>,<a href="https://www.manusai.io/">Manus AI - The World’s First General-Purpose AI Assistant Launching in 2025</a>等等.但大多需要收费(一般除了google和meta,这两家公司还是够给力的),一般都是给一定的credit,用完了就需要给钱了.</p><p>作为成熟的开发者,价格比较高的产品我们就不使用了. 挑选下来还不错的工具有google jules,amazon q,gemini cli,此外国内还有<a href="https://github.com/bytedance/UI-TARS-desktop">bytedance/UI-TARS-desktop</a></p><p>这种工具一般都集成了许多功能,包括联网搜索等,而也有一些工具可以让我们更好阅读代码,比如<a href="https://deepwiki.com/">DeepWiki</a>.</p><p>最后还有cogni<a href="https://devin.ai/">Devin | The AI Software Engineer</a>，<a href="https://swe-agent.com/latest/"> SWE-agent </a>,<a href="https://github.com/stitionai/devika">devika</a>这类大杀器,比较早研究AI辅助编程的工具.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近AI辅助编程特别火,主要是从llm时代,比如gpt4,llama4,claude,gemini等大模型出来后,再到cursor的vibe coding,最后到现在的&lt;a href=&quot;https://openai.com/index/openai-codex/&quot;&gt;OpenAI Codex | OpenAI&lt;/a&gt;,&lt;a href=&quot;https://ai-claude.net/code/&quot;&gt;Claude Code&lt;/a&gt;以及&lt;a href=&quot;https://github.com/google-gemini/gemini-cli&quot;&gt;google-gemini.&lt;/a&gt;anthropic提出了MCP与cli工具,旗下的模型评测效果也很不错,在这些方面,似乎anthropic,openai是领跑者,而meta和google都紧随其后,微软主要是资助openai,而在国内主要是字节Coze,豆包等工具. &lt;/p&gt;
&lt;p&gt;之前一段时间流行过的文生图/文生视频等模型或应用热度也在明显降低,比如&lt;a href=&quot;https://openai.com/sora/&quot;&gt;Sora | OpenAI&lt;/a&gt;,&lt;a href=&quot;https://jimeng.jianying.com/&quot;&gt;即梦AI - 即刻造梦&lt;/a&gt;,&lt;a href=&quot;https://app.klingai.com/cn/&quot;&gt;可灵 &lt;/a&gt;,&lt;a href=&quot;https://hailuoai.com/&quot;&gt;海螺视频&lt;/a&gt;,&lt;a href=&quot;https://www.heygen.com/&quot;&gt;HeyGen&lt;/a&gt;,.但是在视频创作领域,这些工具已经逐渐成了基本功能了. 国内主要是字节和minimax,快手等公司持续发力.&lt;/p&gt;</summary>
    
    
    
    
    <category term="coding agent" scheme="https://www.sekyoro.top/tags/coding-agent/"/>
    
  </entry>
  
  <entry>
    <title>mysql学习:基于mysql实战45讲</title>
    <link href="https://www.sekyoro.top/2025/07/01/mysql%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E4%BA%8Emysql%E5%AE%9E%E6%88%9845%E8%AE%B2/"/>
    <id>https://www.sekyoro.top/2025/07/01/mysql%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E4%BA%8Emysql%E5%AE%9E%E6%88%9845%E8%AE%B2/</id>
    <published>2025-07-01T04:12:54.000Z</published>
    <updated>2025-08-05T15:24:51.867Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>基于极客时间中的MySQL实战45讲以及小林coding,可以查看<a href="https://uaxe.github.io/geektime-docs/">极客时间文档</a>,相关github仓库<a href="https://github.com/it-ebooks-0/geektime-books">it-ebooks-0/geektime-books: :books: 极客时间电子书</a>和<a href="https://github.com/zkep/my-geektime">zkep/my-geektime: 👏 极客时间下载器 &amp; 在线文档</a></p><span id="more"></span><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p><img data-src="https://s2.loli.net/2025/07/01/UnhSHTDM9sx8F3W.png" alt="image-20250701121849232"></p><p>目前mysql版本基本大于8.0,而经典老版本5.7一些功能在新版本中已经移除(比如查询缓存).</p><p>MySQL 的架构共分为两层：<strong>Server 层和存储引擎层</strong>，</p><ul><li><strong>Server 层负责建立连接、分析和执行 SQL</strong>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。</li><li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。</li></ul><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>连接器用于客户端建立连接,获取权限,维持和管理连接. </p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时。</p><p>数据库里面，<strong>长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接</strong>。<strong>短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个</strong>。</p><p>建立连接的过程通常是比较复杂的，所以建议在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p><p>但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，<strong>这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM）</strong>，从现象看就是MySQL异常重启了。</p><p>怎么解决这个问题呢？你可以考虑以下两种方案。</p><ol><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>连接建立完成后,就可以执行语句了。执行逻辑就会来到第二步：查询缓存。</p><p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端.</p><p><strong>对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空</strong>。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。</p><blockquote><p>需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。</p></blockquote><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>进行词法分析,语法、语义解析</p><p>如果输入的 SQL 语句语法不对，就会在分析器这个阶段报错</p><p>经过分析器后，接着就要进入执行 SQL 查询语句的流程了，每条<code>SELECT</code> 查询语句流程主要可以分为下面这三个阶段：</p><ul><li>prepare 阶段，也就是预处理阶段；</li><li>optimize 阶段，也就是优化阶段；</li><li>execute 阶段，也就是执行阶段；</li></ul><p>在优化器之前会有个有预处理阶段,会检查表不存在或者字段不存在的情况</p><ul><li>检查 SQL 查询语句中的表或者字段是否存在；</li><li>将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列；</li></ul><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p><strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>执行器与存储引擎交互得到多条记录.</p><p>以下面查询语句为例，看看执行器是怎么工作的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为 const 进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：</p><ul><li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 <code>id = 1</code> 交给存储引擎，<strong>让存储引擎定位符合条件的第一条记录</strong>。</li><li>存储引擎通过主键索引的 B+ 树结构定位到 id = 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；</li><li>执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。</li><li>执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。</li></ul><p>索引下推能够减少<strong>二级索引</strong>在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。</p><h2 id="执行查询语句流程"><a href="#执行查询语句流程" class="headerlink" title="执行查询语句流程"></a>执行查询语句流程</h2><p>执行一条 SQL 查询语句，期间发生了什么？</p><ul><li>连接器：建立连接，管理连接、校验用户身份；</li><li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li><li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li><li>执行 SQL：执行 SQL 共有三个阶段：<ul><li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li><li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li><li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul></li></ul><h2 id="一行记录是如何存储的"><a href="#一行记录是如何存储的" class="headerlink" title="一行记录是如何存储的"></a>一行记录是如何存储的</h2><p>MySQL 存储的行为是由存储引擎实现的，MySQL 支持多种存储引擎，不同的存储引擎保存的文件自然也不同。</p><p>一个数据库database包含哪些文件?假设包含一个表t_order</p><p>共有三个文件，这三个文件分别代表着：</p><ul><li>db.opt，用来存储当前数据库的默认字符集和字符校验规则。</li><li>t_order.frm ，t_order 的<strong>表结构</strong>会保存在这个文件。<strong>在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义</strong>。</li><li>t_order.ibd，t_order 的<strong>表数据</strong>会保存在这个文件。<strong>表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件</strong>（文件名：表名字.<strong>ibd</strong>）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。</li></ul><p>一张数据库表的数据是保存在” 表名字.ibd “的文件里的，这个文件也称为独占表空间文件</p><p><strong>表空间由段（segment）、区（extent）、页（page）、行（row）组成</strong>，InnoDB存储引擎的逻辑存储结构</p><p><img data-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png" alt="img"></p><p><strong>数据库表中的记录都是按行（row）进行存放的</strong>，每行记录根据不同的行格式，有不同的存储结构.</p><p>记录是按照行来存储的，但是<strong>数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据</strong>，效率会非常低。</p><p>因此，<strong>InnoDB 的数据是按「页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。<strong>默认每个页的大小为 16KB</strong>，也就是最多能保证 16KB 的连续存储空间。</p><p>页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p><p>页的类型有很多，常见的有数据页、undo 日志页、溢出页等等。<strong>数据表中的行记录是用「数据页」来管理的</strong></p><p><img data-src="https://cdn.xiaolincoding.com//mysql/other/243b1466779a9e107ae3ef0155604a17.png" alt="图片" style="zoom:67%;" /></p><p>B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机 I/O 是非常慢的。</p><p>解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I/O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。</p><p>那具体怎么解决呢？</p><p><strong>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了</strong>。</p><p>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。</p><ul><li>索引段：存放 B + 树的非叶子节点的区的集合；</li><li>数据段：存放 B + 树的叶子节点的区的集合；</li><li>回滚段：存放的是回滚数据的区的集合，之前讲事务隔离时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。</li></ul><h3 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h3><p>InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。</p><ul><li>Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。</li><li>由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，<strong>Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录</strong>，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。</li><li>Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默<strong>认使用 Dynamic 行格式。</strong></li></ul><p><img data-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png" alt="img">一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分。</p><p>记录的额外信息包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息。</p><p>varchar(n) 和 char(n) 的区别是什么，相信大家都非常清楚，char 是定长的，varchar 是变长的，变长字段实际存储的数据的长度（大小）不固定的。</p><p>所以，在存储数据的时候，也要把数据占用的大小存起来，存到「变长字段长度列表」里面，读取数据的时候才能根据这个「变长字段长度列表」去读取对应长度的数据。其他 TEXT、BLOB 等变长字段也是这么实现的。</p><h3 id="记录的额外信息"><a href="#记录的额外信息" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h3><h4 id="变长字段列表"><a href="#变长字段列表" class="headerlink" title="变长字段列表"></a>变长字段列表</h4><p>变长字段长度列表存储变长字段的真实数据占用的字节数会按照列的顺序<strong>逆序存放</strong></p><p>这部分专门用于存储变长字段（如 <code>VARCHAR</code>, <code>VARBINARY</code>, <code>TEXT</code>, <code>BLOB</code>）的实际长度。</p><ul><li><p><strong>顺序：</strong> 这些长度值是按照字段在表中定义的<strong>逆序</strong>存储的。例如，如果表有 <code>c1 VARCHAR(10), c2 VARCHAR(20)</code>，那么长度列表会先存储 <code>c2</code> 的长度，再存储 <code>c1</code> 的长度。</p></li><li><p><strong>大小：</strong> 每个长度值根据字段实际长度的不同，可能占用 1 字节或 2 字节。</p></li><li><p>变长字段字节数列表不是必须的。</p><p><strong>当数据表没有变长字段的时候，比如全部都是 int 类型的字段，这时候表里的行格式就不会有「变长字段长度列表」了</strong>，因为没必要，不如去掉以节省空间。</p><p>所以「变长字段长度列表」只出现在数据表有变长字段的时候。</p></li></ul><p><strong>逆序存储原因</strong></p><p>主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</p><p>「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率</strong>。</p><p>同样的道理， NULL 值列表的信息也需要逆序存放。</p><h4 id="空值列表"><a href="#空值列表" class="headerlink" title="空值列表"></a>空值列表</h4><p>这部分用于标记哪些列的值为 NULL。</p><ul><li><strong>按位表示：</strong> 它是一个位图，每个位对应一个允许为 NULL 的列。如果某个位是 1，则表示对应的列值为 NULL；如果是 0，则表示不为 NULL。</li><li><strong>节省空间：</strong> 这样可以节省存储 NULL 值的实际空间。如果列不允许为 NULL（<code>NOT NULL</code>），则不会在这个位图中占用空间。</li><li><strong>顺序：</strong> 同样是按照列在表中定义的<strong>逆序</strong>存储，但只包含允许为 NULL 的列</li></ul><p>表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中。</p><p>如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。</p><ul><li>二进制位的值为<code>1</code>时，代表该列的值为NULL。</li><li>二进制位的值为<code>0</code>时，代表该列的值不为NULL。</li></ul><p>另外，NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 <code>0</code>。</p><p>NULL 值列表也不是必须的。</p><p><strong>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了</strong>。</p><p>所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。</p><h4 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h4><p>比较重要的：</p><ul><li>delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。</li><li>next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li><li>record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</li></ul><h3 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h3><p>这是存储所有列的实际值的地方。</p><ul><li><strong>定长字段：</strong> 定长字段（如 <code>INT</code>, <code>CHAR(N)</code>）会直接存储其固定长度的值。</li><li><strong>变长字段：</strong> 变长字段则存储其真实的数据内容。</li><li><strong>溢出页存储 (Off-page Storage)：</strong> 对于 <code>TEXT</code> 和 <code>BLOB</code> 这种非常大的变长字段，如果其数据超过了数据页的存储限制（大约 8KB），InnoDB 会将其<strong>部分或全部数据存储到独立的溢出页（Overflow Pages）中</strong>。在实际数据区，只存储指向这些溢出页的 20 字节指针。这就是 <code>DYNAMIC</code> 和 <code>COMPRESSED</code> 行格式的主要优化之处，它们对于溢出数据的存储方式更灵活。<code>COMPACT</code> 和 <code>REDUNDANT</code> 会尽可能将数据存储在行内，只有在无法存储时才溢出。</li></ul><p>还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer.</p><ul><li><p>row_id 如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。</p></li><li><p>trx_id事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。</p></li><li>roll_pointer<strong>记录上一个版本的指针</strong>。roll_pointer 是必需的，占用 7 个字节。</li></ul><h3 id="varchar-n-含义以及n最大取值"><a href="#varchar-n-含义以及n最大取值" class="headerlink" title="varchar(n)含义以及n最大取值"></a>varchar(n)含义以及n最大取值</h3><p><code>VARCHAR(n)</code> 的存储空间由以下两部分组成：</p><ul><li><p><strong>实际数据长度：</strong> 存储字符串的实际字节数。</p></li><li><p><strong>长度前缀：</strong> 用于记录字符串实际长度的字节数。</p><ul><li><p>如果字符串的实际长度小于或等于 255 字节，需要 1 个字节来存储长度。</p></li><li><p>如果字符串的实际长度大于 255 字节，但小于或等于 65535 字节，需要 2 个字节来存储长度。</p><p><strong>NULL 标识</strong>，如果不允许为NULL，这部分不需要    </p><p><code>n</code> 代表的是该 <code>VARCHAR</code> 列能够存储的<strong>最大字符数</strong>。</p></li></ul><p>例如，<code>VARCHAR(255)</code> 表示这个列最多可以存储 255 个字符。</p></li></ul><p><strong>MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节</strong>。</p><p>也就是说，一行记录除了 TEXT、BLOBs 类型的列，限制最大为 65535 字节，注意是一行的总长度，不是一列。varchar(n) 字段类型的 n 代表的是最多存储的字符数量,因此,要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占用多少字节，比如 ascii 字符集， 1 个字符占用 1 字节，那么 varchar(100) 意味着最大能允许存储 100 字节的数据。</p><p><strong>一行数据的最大字节数 65535，其实是包含「变长字段长度列表」和 「NULL 值列表」所占用的字节数的</strong>。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去 storage overhead 占用的字节数。</p><p>因为我们存储字段类型为 varchar(n) 的数据时，其实分成了三个部分来存储：</p><ul><li>真实数据</li><li>真实数据占用的字节数</li><li><p>NULL 标识，如果不允许为NULL，这部分不需要</p><p>varchar(n) 中 n 最大值时，需要减去 <strong>变长字段长度列表</strong>和 <strong>NULL 值列表</strong>所占用的字节数的。所以，<strong>在数据库表只有一个 varchar(n) 字段且字符集是 ascii 的情况下，varchar(n) 中 n 最大值 = 65535 - 2 - 1 = 65532</strong>。</p></li></ul><h3 id="行溢出问题"><a href="#行溢出问题" class="headerlink" title="行溢出问题"></a>行溢出问题</h3><p>一个页默认16KB,也就16384字节,如果包含的一条记录行总大小超过了16KB会怎样.</p><p>这时一个页可能就存不了一条记录。这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong>。</p><p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到溢出页中。在一般情况下，<strong>InnoDB 的数据都是存放在 数据页中。但是当发生行溢出时，溢出的数据会存放到溢出页中</strong>。</p><p>在compact行格式中,当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在“溢出页”中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</p><p>Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。这<strong>两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中</strong></p><h2 id="执行更新语句流程"><a href="#执行更新语句流程" class="headerlink" title="执行更新语句流程"></a>执行更新语句流程</h2><p>查询语句的那一套流程，更新语句也是同样会走一遍：</p><ul><li>客户端先通过连接器建立连接，连接器自会判断用户身份；</li><li>因为这是一条 update 语句，所以不需要经过查询缓存，但是表上有更新语句，是会把整个表的查询缓存清空的，所以说查询缓存很鸡肋，在 MySQL 8.0 就被移除这个功能了；</li><li>解析器会通过词法分析识别出关键字 update，表名等等，构建出语法树，接着还会做语法分析，判断输入的语句是否符合 MySQL 语法；</li><li>预处理器会判断表和字段是否存在；</li><li>优化器确定执行计划，因为 where 条件中的 id 是主键索引，所以决定要使用 id 这个索引；</li><li>执行器负责具体执行，找到这一行，然后更新。</li></ul><p>不过，更新语句的流程会涉及到 undo log（回滚日志）、redo log（重做日志） 、binlog （归档日志）这三种日志：</p><ul><li><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li><li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li><li><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</li></ul><p>具体更新一条记录 <code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code> 的流程如下:</p><ol><li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：<ul><li>如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li><li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li></ul></li><li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：<ul><li>如果一样的话就不进行后续更新流程；</li><li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li></ul></li><li>开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li><li>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 <strong>WAL 技术</strong>，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li><li>至此，一条记录更新完了。</li><li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li><li>事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：<ul><li><strong>prepare 阶段</strong>：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li><li><strong>commit 阶段</strong>：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</li></ul></li><li>至此，一条更新语句执行完成。</li></ol><h3 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h3><h4 id="Undo-log"><a href="#Undo-log" class="headerlink" title="Undo log"></a>Undo log</h4><p><strong><code>Undo Log</code> 是一种逻辑日志，它记录了数据在被修改前的样子。</strong> 简单来说，它记录的是“如何撤销一个操作”的信息。当事务对数据进行修改时，InnoDB 不会直接覆盖旧数据，而是会把旧数据的版本写入到 <code>Undo Log</code> 中。</p><p>undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。</p><p>当一个事务执行过程中遇到错误，或者用户显式地发出 <code>ROLLBACK</code> 命令时，InnoDB 会利用 <code>Undo Log</code> 中记录的信息，将所有对数据库的修改<strong>撤销</strong>，使数据回到事务开始之前的状态。</p><p>这确保了事务的“要么全部成功，要么全部失败”的特性。</p><p>它记录了回滚（Undo）操作所需的信息,每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里。如果你执行了一个 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 操作：</p><ul><li>对于 <strong><code>INSERT</code> 操作</strong>：<code>Undo Log</code> 记录的是该行数据的 <strong>主键信息</strong>，当需要回滚时，通过主键将新插入的行删除。</li><li>对于 <strong><code>DELETE</code> 操作</strong>：<code>Undo Log</code> 记录的是被删除行的 <strong>完整数据</strong>，当需要回滚时，通过这些数据将行重新插入。</li><li>对于 <strong><code>UPDATE</code> 操作</strong>：<code>Undo Log</code> 记录的是被更新行的 <strong>旧值</strong>（修改前的数据），当需要回滚时，通过这些旧值将数据恢复。</li></ul><p>这些 <code>Undo Log</code> 存储在回滚段（Rollback Segment）中，位于共享表空间（System Tablespace）或单独的 <code>undo tablespace</code> 文件中。</p><p>在发生回滚时，就读取 undo log 里的数据，然后做原先相反操作。比如当 delete 一条记录时，undo log 中会把记录中的内容都记下来，然后执行回滚操作的时候，就读取 undo log 里的数据，然后进行 insert 操作。</p><p>针对 delete 操作和 update 操作会有一些特殊的处理：</p><ul><li>delete操作实际上不会立即直接删除，而是将delete对象打上delete flag，标记为删除，最终的删除操作是purge线程完成的。</li><li>update分为两种情况：update的列是否是主键列。<ul><li>如果不是主键列，在undo log中直接反向记录是如何update的。即update是直接进行的。</li><li>如果是主键列，update分两部执行：先删除该行，再插入一行目标行。</li></ul></li></ul><p>一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务id：</p><ul><li>通过 trx_id 可以知道该记录是被哪个事务修改的；</li><li>通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链</li></ul><p><img data-src="https://s2.loli.net/2025/08/04/bXDK2qPA9J4NxCW.png" alt="image-20250804232535302"></p><p>对于「读提交」和「可重复读」隔离级别的事务来说，它们的<strong>快照读（普通 select 语句）是通过 Read View + undo log 来实现的</strong>，它们的区别在于创建 Read View 的时机不同：</p><ul><li>「读提交」隔离级别是在<strong>每个 select 都会生成一个新的 Read View</strong>，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</li><li>「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。</li></ul><p>这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列（trx_id 和 roll_pointer）」的比对，如果不满足可见行，就会顺着 undo log 版本链里找到满足其可见性的记录，从而控制并发事务访问同一个记录时的行为，这就叫 MVCC(多版本并发控制).</p><p>undo log 两大作用：</p><ul><li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li><li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li></ul><blockquote><p>undo log 是如何刷盘（持久化到磁盘）的？</p><p>undo log 和数据页的刷盘策略是一样的，都需要通过 redo log 保证持久化。</p><p>buffer pool 中有 undo 页，对 undo 页的修改也都会记录到 redo log。redo log 会每秒刷盘，提交事务时也会刷盘，数据页和 undo 页都是靠这个机制保证持久化的</p></blockquote><p>1.什么是 Undo Log？它的主要作用是什么？</p><ul><li><strong>回答要点：</strong> 逻辑日志，记录数据修改前的状态。两大作用是实现事务的<strong>原子性（回滚）</strong> 和 <strong>隔离性（MVCC）</strong>。</li></ul><ol><li>Undo Log 是如何实现事务回滚的？请举例说明。</li></ol><ul><li><strong>回答要点：</strong><ul><li><strong>Insert 回滚：</strong> 记录主键，回滚时删除新插入的行。</li><li><strong>Delete 回滚：</strong> 记录被删除的完整行数据，回滚时重新插入。</li><li><strong>Update 回滚：</strong> 记录更新前的旧值，回滚时用旧值覆盖新值。</li></ul></li></ul><ol><li>Undo Log 和 Redo Log 有什么区别和联系？</li></ol><ul><li><strong>回答要点：</strong><ul><li><strong>Undo Log：</strong> <strong>逻辑日志</strong>，记录<strong>修改前</strong>的数据（旧版本），用于<strong>回滚</strong>和<strong>MVCC</strong>。保证原子性和隔离性。</li><li><strong>Redo Log：</strong> <strong>物理日志</strong>，记录<strong>修改后</strong>的数据（新版本）以及操作类型，用于<strong>崩溃恢复</strong>（Crash Recovery）和<strong>持久性</strong>。保证持久性。</li><li><strong>联系：</strong> 它们都是事务日志，都是为了保证事务的 ACID 特性。Redo Log 保证已提交事务的持久性（即使系统崩溃也能恢复），Undo Log 保证未提交事务的原子性（回滚到事务开始前）。</li></ul></li></ul><ol><li>Undo Log 是如何实现 MVCC 的？（核心问题）</li></ol><ul><li><strong>回答要点：</strong><ul><li><strong>隐藏列：</strong> 每行数据都有两个隐藏列：<code>DB_TRX_ID</code>（最近一次修改该行的事务 ID）和 <code>DB_ROLL_PTR</code>（指向该行在 <code>Undo Log</code> 中上一个版本的指针）。</li><li><strong>Read View：</strong> 每个事务开始时，会生成一个 <code>Read View</code>（视图），其中包含当前活跃的事务 ID 列表。</li><li><strong>版本链：</strong> 当数据被修改时，旧版本的数据会记录在 <code>Undo Log</code> 中，并通过 <code>DB_ROLL_PTR</code> 形成一个版本链。</li><li><strong>可见性判断：</strong> 事务查询数据时，会根据 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断当前版本是否可见。如果不可见，就沿着 <code>DB_ROLL_PTR</code> 链回溯到 <code>Undo Log</code> 中查找更早的版本，直到找到对当前事务可见的那个版本。</li><li><strong>快照读：</strong> MVCC 主要支持<strong>快照读（Snapshot Read）</strong>。</li></ul></li></ul><ol><li>Undo Log 会被清除吗？什么时候清除？</li></ol><ul><li><strong>回答要点：</strong><ul><li><strong>会清除。</strong> <code>Undo Log</code> 并不是永久保存的。</li><li>当<strong>所有活跃事务</strong>都不再需要某个 <code>Undo Log</code> 版本时，这个 <code>Undo Log</code> 就会被<strong>标记为可清除</strong>。</li><li>InnoDB 有一个后台线程会定期回收这些不再需要的 <code>Undo Log</code> 空间。</li><li>如果存在<strong>长时间运行的事务</strong>（例如一个很大的查询或一个未提交的事务），它可能会长时间持有 <code>Read View</code>，导致大量的 <code>Undo Log</code> 无法被及时清除，从而占用大量磁盘空间，甚至导致数据库性能问题（例如 <code>history list length</code> 过长）。</li></ul></li></ul><ol><li>为什么长事务会导致数据库性能问题？</li></ol><ul><li><strong>回答要点：</strong><ul><li><strong>Undo Log 无法回收：</strong> 长事务会长时间持有 <code>Read View</code>，导致它所开启之前的 <code>Undo Log</code> 记录都无法被清理，占用大量磁盘空间。</li><li><strong>查询性能下降：</strong> 其他事务查询旧版本数据时，需要回溯更长的 <code>Undo Log</code> 链，增加 I/O 和 CPU 开销。</li><li><strong>刷新脏页受阻：</strong> <code>Undo Log</code> 过多也会影响脏页的刷新，导致内存中的脏页无法及时写入磁盘。</li></ul></li></ul><p><code>Undo Log</code> 的数据存储在 <strong>回滚段（Rollback Segment）</strong> 中。</p><ul><li><strong>文件类型：</strong><ul><li>在 MySQL 5.7 之前，回滚段位于<strong>共享表空间</strong>（<code>ibdata1</code>）中。</li><li>在 MySQL 5.7 及以后的版本，推荐将 <code>Undo Log</code> 独立出来，存储在单独的 <strong>Undo 表空间文件</strong>中，通常命名为 <code>undo001</code>, <code>undo002</code> 等。这个配置由 <code>innodb_undo_tablespaces</code> 参数控制。</li></ul></li></ul><p><strong>关键点：</strong> * 默认情况下在 <code>ibdata1</code> 中。</p><ul><li>推荐配置为独立文件，便于管理和回收空间。</li></ul><h4 id="Redo-log"><a href="#Redo-log" class="headerlink" title="Redo log"></a>Redo log</h4><p><strong>Redo Log 是一种物理日志，它记录了对数据页的修改。</strong> 简单来说，它记录的是“数据被修改成了什么样子”。当事务对数据进行修改时，InnoDB 会先将修改操作写入到 Redo Log 中，而不是直接写入数据文件.Redo Log 记录的是数据页的物理修改，例如“对页号 X 的偏移量 Y 处的数据从 A 变为 B”。它不关心业务逻辑，只关心数据块的字节变化。</p><p>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，<strong>这个时候更新就算完成了</strong>。</p><p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。</p><p>InnoDB 遵循 <strong>WAL (Write-Ahead Logging)</strong> 策略，即“先写日志，再写磁盘”。</p><ol><li>当一个事务需要修改数据时，InnoDB 会先将这些修改操作（比如“将数据页 X 的偏移量 Y 处的值从 A 改为 B”）写入到 <strong>Redo Log Buffer</strong> (内存中的一块区域)。</li><li>Redo Log Buffer 中的数据会根据一定策略（比如事务提交、Buffer Pool 刷盘等）刷入到磁盘上的 <strong>Redo Log 文件</strong> (通常是 <code>ib_logfile0</code>, <code>ib_logfile1</code> 等)。</li><li>只有当 Redo Log 记录成功写入到磁盘（或至少同步到操作系统的文件缓存）后，事务才会被确认为“提交成功”。</li><li>实际的数据页的修改（从 Buffer Pool 刷写到数据文件）可以稍后进行，即使系统在数据页刷盘前崩溃，也可以通过 Redo Log 来恢复。</li></ol><p><img data-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/wal.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="img" style="zoom:67%;" /></p><blockquote><p>被修改 Undo 页面，需要记录对应 redo log 吗？</p></blockquote><p>需要。开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。</p><p>不过，<strong>在内存修改该 Undo 页面后，也是需要记录对应的 redo log，因为undo log也要实现持久性的保护</strong>。</p><p>写入 redo log 的方式使用了追加操作， 所以磁盘操作是<strong>顺序写</strong>，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是<strong>随机写</strong>。</p><p>磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。</p><p>针对「顺序写」为什么比「随机写」更快这个问题，可以比喻为你有一个本子，按照顺序一页一页写肯定比写一个字都要找到对应页写快得多。</p><p>可以说这是 WAL 技术的另外一个优点：<strong>MySQL 的写操作从磁盘的「随机写」变成了「顺序写」</strong>，提升语句的执行性能。这是因为 MySQL 的写操作并不是立刻更新到磁盘上，而是先记录在日志上，然后在合适的时间再更新到磁盘上 。</p><p>至此， 针对为什么需要 redo log 这个问题我们有两个答案：</p><ul><li><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li><li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</li></ul><blockquote><p>产生的 redo log 是直接写入磁盘的吗？</p></blockquote><p>不是的。</p><p>实际上， 执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I/O 操作，而且磁盘的运行速度远慢于内存。</p><p>所以，redo log 也有自己的缓存—— <strong>redo log buffer</strong>，每当产生一条 redo log 时，会先写入到 redo log buffer.redo log buffer 默认大小 16 MB，可以通过 <code>innodb_log_Buffer_size</code> 参数动态的调整大小，增大它的大小可以让 MySQL 处理「大事务」是不必写入磁盘，进而提升写 IO 性能。</p><h4 id="redo-log刷盘时机"><a href="#redo-log刷盘时机" class="headerlink" title="redo log刷盘时机"></a>redo log刷盘时机</h4><p>缓存在 redo log buffer 里的 redo log 还是在内存中，它什么时候刷新到磁盘？</p><p>主要有下面几个时机：</p><ul><li>MySQL 正常关闭时；</li><li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li><li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li><li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘.这个策略可由 innodb_flush_log_at_trx_commit 参数控制</li></ul><ol><li>什么是 Redo Log？它的主要作用是什么？</li></ol><ul><li><strong>回答要点：</strong> 物理日志，记录数据页的修改（新版本）。核心作用是实现事务的<strong>持久性</strong>，用于<strong>崩溃恢复</strong>。</li></ul><ol><li>Redo Log 和 Undo Log 有什么区别和联系？</li></ol><ul><li><strong>回答要点：</strong><ul><li><strong>Redo Log：</strong> <strong>物理日志</strong>，记录<strong>修改后</strong>的数据状态，用于<strong>崩溃恢复</strong>，保证<strong>持久性</strong>。</li><li><strong>Undo Log：</strong> <strong>逻辑日志</strong>，记录<strong>修改前</strong>的数据状态，用于<strong>事务回滚</strong>和 <strong>MVCC</strong>，保证<strong>原子性</strong>和<strong>隔离性</strong>。</li><li><strong>联系：</strong> 它们都是事务日志，都是为了保证事务的 ACID 特性。Redo Log 保证已提交事务的持久性，Undo Log 保证未提交事务的原子性。两者配合，构成了 InnoDB 事务处理的核心机制。</li></ul></li></ul><ol><li>为什么 Redo Log 可以实现崩溃恢复？</li></ol><ul><li><strong>回答要点：</strong> 基于 <strong>WAL (Write-Ahead Logging)</strong> 策略。事务提交时，只需确保 Redo Log 写入磁盘，而无需等待数据页真正写入磁盘。即使系统崩溃，重启时可以通过 Redo Log 重放那些已经提交但未刷盘的操作，确保数据不丢失。</li></ul><ol><li>Redo Log 是如何保证事务提交的“快速性”和“持久性”的？</li></ol><ul><li><strong>回答要点：</strong><ul><li><strong>快速性（缓冲）：</strong> 事务提交时，不需要立即将脏页从 Buffer Pool 刷到磁盘，而是先将操作记录到 Redo Log Buffer，然后刷到 Redo Log 文件。由于 Redo Log 是<strong>顺序写入</strong>的，效率很高。</li><li><strong>持久性（同步）：</strong> 通过 <code>innodb_flush_log_at_trx_commit</code> 参数控制 Redo Log 刷盘策略，可以保证在事务提交时，Redo Log 记录已经同步到磁盘，从而确保持久性。<ul><li><code>1</code>：每次事务提交时，Redo Log 都写入文件并同步到磁盘，最安全，但性能开销大。</li><li><code>0</code>：每秒将 Redo Log 写入文件并同步到磁盘，性能高，但可能丢失 1 秒的数据。</li><li><code>2</code>：每次事务提交时，Redo Log 写入文件但不立即同步到磁盘，由操作系统负责同步，性能和安全折中。</li></ul></li></ul></li></ul><ol><li>Redo Log 文件的大小和数量对性能有什么影响？</li></ol><ul><li><strong>回答要点：</strong><ul><li><strong>文件大小（<code>innodb_log_file_size</code>）：</strong> 越大，<code>checkpoint</code> 刷脏的频率越低，可以减少磁盘 I/O，提高写入性能。但恢复时间会变长。</li><li><strong>文件数量（<code>innodb_log_files_in_group</code>）：</strong> 通常为 2 个或更多，形成一个环形缓冲区。数量通常不影响性能太多，主要受大小影响。</li><li><strong>环形写入：</strong> Redo Log 是以循环覆盖的方式写入的，当写到最后一个文件末尾时，会回到第一个文件开头继续写。</li></ul></li></ul><ol><li>什么是 Checkpoint？它与 Redo Log 有何关系？</li></ol><ul><li><strong>回答要点：</strong><ul><li><strong>Checkpoint (检查点)：</strong> 是一个时间点或位置，表示在某个时间点之前，所有已记录在 Redo Log 中的数据页修改，都已经被成功写入到磁盘上的数据文件了。</li><li><strong>关系：</strong> Checkpoint 的作用是<strong>缩短恢复时间</strong>和<strong>刷新脏页</strong>。在崩溃恢复时，InnoDB 只需从最近的 Checkpoint 开始重放 Redo Log，而不需要从 Redo Log 的最开始。Checkpoint 机制通过将脏页刷到磁盘，使得 Redo Log 中对应的那部分空间可以被重用。</li></ul></li></ul><ol><li>Redo Log 是物理日志还是逻辑日志？为什么？</li></ol><ul><li><strong>回答要点：</strong><ul><li><strong>物理日志：</strong> Redo Log 记录的是数据页的物理修改，例如“对页号 X 的偏移量 Y 处的数据从 A 变为 B”。它不关心业务逻辑，只关心数据块的字节变化。</li><li><strong>为什么是物理日志：</strong> 因为恢复时直接根据这些物理修改信息操作数据页，效率更高。而 Undo Log 记录的是逻辑操作（如 INSERT 了一行，DELETE 了一行），恢复时需要逆向执行逻辑操作。</li></ul></li></ul><p><strong>存储位置：</strong> <code>Redo Log</code> 存储在 MySQL 数据目录下的两个或多个文件中。</p><ul><li><strong>文件类型：</strong> 这些文件通常以 <code>ib_logfile</code> 开头，例如 <code>ib_logfile0</code>, <code>ib_logfile1</code>。</li><li><strong>工作方式：</strong> <code>Redo Log</code> 文件构成一个<strong>环形写入</strong>的日志组。当一个文件写满后，会切换到下一个文件，写到最后一个文件末尾后，再回到第一个文件开头继续写入，循环覆盖。</li></ul><p><strong>关键点：</strong> * 文件名固定，通常为 <code>ib_logfileX</code>。</p><ul><li>以循环方式写入，所以文件数量和大小是固定的。</li></ul><h4 id="Bin-log"><a href="#Bin-log" class="headerlink" title="Bin log"></a>Bin log</h4><p>undo log 和 redo log 这两个日志都是 Innodb 存储引擎生成的。MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。</p><ul><li>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：<ul><li>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</li><li>ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；</li><li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</li></ul></li><li><p>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；</p></li><li><p>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</p></li><li>redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志</li></ul><p><strong>存储位置：</strong> <code>Binlog</code> 存储在 MySQL 数据目录下。</p><p><strong>文件类型：</strong></p><ul><li>索引文件：<code>binlog.index</code>，记录所有 Binlog 文件的列表。</li><li>数据文件：<code>binlog.000001</code>, <code>binlog.000002</code> 等，每个文件记录一段时期的 Binlog 事件。</li></ul><p><strong>工作方式：</strong> 当 Binlog 文件达到一定大小（由 <code>max_binlog_size</code> 控制）或者重启 MySQL 服务时，会进行<strong>日志切换（Rotate）</strong>，生成一个新的 Binlog 文件。</p><p>Bin Log 主要用于以下两个核心功能：</p><ol><li>数据库复制 (Replication)</li></ol><p>这是 Bin Log 最主要的作用。</p><ul><li><strong>原理：</strong> 在主从复制架构中，主服务器会将 Bin Log 的内容实时同步给所有从服务器。</li><li><strong>作用：</strong> 从服务器接收到 Bin Log 的事件后，会按顺序<strong>重放 (Replay)</strong> 这些事件，从而保证主从数据库的数据最终是一致的。这使得主从架构成为可能，为高可用和读写分离提供了基础。</li></ul><ol><li>数据恢复 (Point-in-Time Recovery)</li></ol><ul><li><strong>原理：</strong> 当数据库发生意外，比如误删数据后，可以通过 Bin Log 将数据恢复到指定的时间点。</li><li><strong>作用：</strong> 你可以先用全量备份文件将数据库恢复到某个备份点，然后再利用备份时间点之后的 Bin Log 事件，将数据逐一重放，直到恢复到误操作发生前的状态。</li></ul><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。</p><p>MySQL 主从复制是一个异步过程，核心是<strong>二进制日志（Binlog）</strong>。整个过程可以分为三个关键步骤：</p><ul><li><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。</li><li><strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</li><li><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据</li></ul><p>这个过程一般是<strong>异步</strong>的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。</p><ol><li><strong>主库记录（Binlog Dump）</strong><ul><li>当主库上的数据发生任何修改（<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>DDL</code> 等），这些操作都会被记录到主库的<strong>二进制日志（Binlog）</strong> 中。</li><li>从库启动复制后，会连接到主库。主库会为每个从库创建一个<strong>Binlog Dump 线程</strong>，该线程负责将 Binlog 中的事件（Events）发送给从库。</li></ul></li><li><strong>从库接收（I/O Thread）</strong><ul><li>从库有一个<strong>I/O 线程</strong>，它负责连接主库，并请求主库的 Binlog Dump 线程发送 Binlog。</li><li>从库的 I/O 线程接收到 Binlog 事件后，会将这些事件顺序地写入到本地的一个文件，这个文件被称为<strong>中继日志（Relay Log）</strong>。</li></ul></li><li><strong>从库应用（SQL Thread）</strong><ul><li>从库还有一个<strong>SQL 线程</strong>，它负责读取中继日志中的事件。</li><li>SQL 线程会按顺序<strong>重放（Replay）</strong> 这些事件，将主库上执行过的操作，在从库上也重新执行一遍，从而保证主从数据的一致性</li></ul></li></ol><p>事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。</p><p>在事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 文件中，并清空 binlog cache.</p><p><code>sync_binlog</code> 参数用于控制 MySQL 在事务提交时，将 Binlog 从内存缓存（Binlog Cache）同步到磁盘文件的频率。它有三个可选值：</p><ul><li><strong><code>sync_binlog = 0</code> (默认值，不推荐)</strong><ul><li><strong>时机：</strong> 事务提交后，MySQL 仅仅将 Binlog <strong>写入文件系统缓存</strong>。至于什么时候从缓存刷到磁盘，完全依赖于操作系统自身的调度。</li><li><strong>性能：</strong> <strong>最高</strong>。因为减少了磁盘 I/O，写入操作非常快。</li><li><strong>风险：</strong> <strong>最高</strong>。一旦数据库服务器或操作系统崩溃，内存缓存中的 Binlog 数据会全部丢失。如果主从复制依赖这些 Binlog，就会导致主从数据不一致，甚至数据丢失。</li></ul></li><li><strong><code>sync_binlog = 1</code></strong><ul><li><strong>时机：</strong> <strong>每次事务提交</strong>时，MySQL 都会立即将 Binlog 从缓存写入文件，并<strong>强制同步到磁盘</strong>。</li><li><strong>性能：</strong> <strong>最低</strong>。因为每次提交都伴随着一次昂贵的磁盘 I/O 操作，在高并发场景下性能开销非常大。</li><li><strong>风险：</strong> <strong>最低</strong>。这是最安全、最可靠的设置，能够保证 Binlog 的持久性，确保在任何情况下（包括操作系统崩溃或断电）都不会丢失已提交的事务数据。这也是实现<strong>半同步复制</strong>和<strong>数据恢复</strong>的基础。</li></ul></li><li><strong><code>sync_binlog = N</code> (N &gt; 1)</strong><ul><li><strong>时机：</strong> 每提交 <strong>N 次事务</strong>后，MySQL 才将 Binlog 刷入磁盘。</li><li><strong>性能：</strong> 介于 <code>0</code> 和 <code>1</code> 之间，是性能与安全性的折中方案。</li><li><strong>风险：</strong> 如果在第 N 次刷盘前发生崩溃，可能会丢失最多 N-1 次事务的 Binlog 数据</li></ul></li></ul><p>在MySQL中系统默认的设置是 sync_binlog = 0，也就是不做任何强制性的磁盘刷新指令，这时候的性能是最好的，但是风险也是最大的。因为<strong>一旦主机发生异常重启，还没持久化到磁盘的数据就会丢失</strong>。而当 sync_binlog 设置为 1 的时候，是最安全但是性能损耗最大的设置。因为当设置为 1 的时候，即使主机发生异常重启，最多丢失一个事务的 binlog，而已经持久化到磁盘的数据就不会有影响，不过就是对写入性能影响太大。</p><p>如果能容少量事务的 binlog 日志丢失的风险，为了提高写入的性能，一般会 sync_binlog 设置为 100~1000 中的某个数值。</p><h3 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h3><p>Innodb引擎设计了缓冲池,当需要读取的数据不在缓冲池中,就从磁盘中加入到缓冲池,当修改的数据在缓冲池中,就直接修改并标记为脏页.</p><p>有了 Buffer Poo 后：</p><ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li><li>当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），<strong>为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘</strong></li></ul><p>InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。</p><p>在 MySQL 启动的时候，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的<code>16KB</code>的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页</strong>。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。</p><p>所以，MySQL 刚启动的时候，你会观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小，这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，申请物理内存，接着将虚拟地址和物理地址建立映射关系。</p><p>Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 Undo 页，修改缓存、自适应哈希索引、锁信息等等。</p><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><h4 id="redo-log与bin-log数据不一致性"><a href="#redo-log与bin-log数据不一致性" class="headerlink" title="redo log与bin log数据不一致性"></a>redo log与bin log数据不一致性</h4><p>假设一个事务对数据进行了修改。</p><ul><li><strong>如果先写 Redo Log，再写 Binlog</strong>：<ol><li>Redo Log 写入成功，事务提交，但 Binlog 写入失败（例如 MySQL 崩溃）。</li><li>此时，数据库会认为事务已提交，恢复后数据会存在。</li><li>但 Binlog 中没有这条记录。如果这是一个主从架构，从库将不会收到这条修改，导致<strong>主从数据不一致</strong>。</li></ol></li><li><strong>如果先写 Binlog，再写 Redo Log</strong>：<ol><li>Binlog 写入成功，但 Redo Log 写入失败（例如 MySQL 崩溃）。</li><li>此时，Binlog 中有这条记录，从库会执行这个操作，数据存在。</li><li>但主库 Redo Log 没提交，恢复后会进行回滚，数据丢失。同样导致<strong>主从数据不一致</strong>。</li></ol></li></ul><p><strong>MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决</strong>，两阶段提交其实是<strong>分布式事务一致性协议</strong>，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。</p><h4 id="两阶段提交过程"><a href="#两阶段提交过程" class="headerlink" title="两阶段提交过程"></a>两阶段提交过程</h4><p><strong>两阶段提交把单个事务的提交拆分成了 2 个阶段，分别是「准备（Prepare）阶段」和「提交（Commit）阶段」</strong>，每个阶段都由协调者（Coordinator）和参与者（Participant）共同完成。注意，不要把提交（Commit）阶段和 commit 语句混淆了，commit 语句执行的时候，会包含提交（Commit）阶段。</p><p>在 MySQL 的 InnoDB 存储引擎中，开启 binlog 的情况下，MySQL 会同时维护 binlog 日志与 InnoDB 的 redo log，为了保证这两个日志的一致性，MySQL 使用了<strong>内部 XA 事务</strong>，内部 XA 事务<strong>由 binlog 作为协调者，存储引擎是参与者</strong>。</p><p>当客户端执行 commit 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务，<strong>分两阶段来完成 XA 事务的提交</strong>.</p><p>事务的提交过程有两个阶段，就是<strong>将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog</strong>，具体如下：</p><ul><li><strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit = 1 的作用）；</li><li><strong>commit 阶段</strong>：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog = 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；</li></ul><p><img data-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%B4%A9%E6%BA%83%E7%82%B9.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="时刻 A 与时刻 B"></p><p>不管是时刻 A（redo log 已经写入磁盘， binlog 还没写入磁盘），还是时刻 B （redo log 和 binlog 都已经写入磁盘，还没写入 commit 标识）崩溃，<strong>此时的 redo log 都处于 prepare 状态</strong>。</p><p>在 MySQL 重启后会按顺序扫描 redo log 文件，碰到处于 prepare 状态的 redo log，就拿着 redo log 中的 XID 去 binlog 查看是否存在此 XID：</p><ul><li><strong>如果 binlog 中没有当前内部 XA 事务的 XID，说明 redolog 完成刷盘，但是 binlog 还没有刷盘，则回滚事务</strong>。对应时刻 A 崩溃恢复的情况。</li><li><strong>如果 binlog 中有当前内部 XA 事务的 XID，说明 redolog 和 binlog 都已经完成了刷盘，则提交事务</strong>。对应时刻 B 崩溃恢复的情况。</li></ul><p>可以看到，<strong>对于处于 prepare 阶段的 redo log，即可以提交事务，也可以回滚事务，这取决于是否能在 binlog 中查找到与 redo log 相同的 XID</strong>，如果有就提交事务，如果没有就回滚事务。这样就可以保证 redo log 和 binlog 这两份日志的一致性了。</p><p>所以说，<strong>两阶段提交是以 binlog 写成功为事务提交成功的标识</strong>，因为 binlog 写成功了，就意味着能在 binlog 中查找到与 redo log 相同的 XID。</p><blockquote><p>处于 prepare 阶段的 redo log 加上完整 binlog，重启就提交事务，MySQL 为什么要这么设计?</p></blockquote><p>binlog 已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。</p><p>所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。</p><blockquote><p>事务没提交的时候，redo log 会被持久化到磁盘吗？</p></blockquote><p>会,事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些缓存在 redo log buffer 里的 redo log 也会被「后台线程」每隔一秒一起持久化到磁盘。</p><p>也就是说，<strong>事务没提交的时候，redo log 也是可能被持久化到磁盘的</strong>。</p><p>有的同学可能会问，如果 mysql 崩溃了，还没提交事务的 redo log 已经被持久化磁盘了，mysql 重启后，数据不就不一致了？</p><p>放心，这种情况 mysql 重启会进行回滚操作，因为事务没提交的时候，binlog 是还没持久化到磁盘的。</p><p>所以， redo log 可以在事务没提交之前持久化到磁盘，但是 binlog 必须在事务提交之后，才可以持久化到磁盘</p><h4 id="两阶段提交问题"><a href="#两阶段提交问题" class="headerlink" title="两阶段提交问题"></a>两阶段提交问题</h4><p>两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差，主要有两个方面的影响：</p><ul><li><strong>磁盘 I/O 次数高</strong>：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。</li><li><strong>锁竞争激烈</strong>：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。</li></ul><p><strong>磁盘I/O次数高原因</strong></p><p>binlog 和 redo log 在内存中都对应的缓存空间，binlog 会缓存在 binlog cache，redo log 会缓存在 redo log buffer，它们持久化到磁盘的时机分别由下面这两个参数控制。一般我们为了避免日志丢失的风险，会将这两个参数设置为 1：</p><ul><li>当 sync_binlog = 1 的时候，表示每次<strong>提交事务都会将 binlog cache 里的 binlog 直接持久到磁盘</strong>；</li><li>当 innodb_flush_log_at_trx_commit = 1 时，表<strong>示每次事务提交时，都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</strong>；</li></ul><p>可以看到，如果 sync_binlog 和 当 innodb_flush_log_at_trx_commit 都设置为 1，那么在每个事务提交过程中， 都会<strong>至少调用 2 次刷盘操作</strong>，一次是 redo log 刷盘，一次是 binlog 落盘，所以这会成为性能瓶颈。</p><p><strong>MySQL 引入了 binlog 组提交（group commit）机制，当有多个事务提交的时候，会将多个 binlog 刷盘操作合并成一个，从而减少磁盘 I/O 的次数</strong>，如果说 10 个事务</p><blockquote><p><strong>组提交</strong>是一种优化技术，它旨在将多个事务的提交操作<strong>批量化处理</strong>。在没有组提交的情况下，每个事务的提交都可能需要独立的磁盘 I/O，这在高并发场景下会成为严重的性能瓶颈。</p></blockquote><p>通过组提交，MySQL 将多个事务的提交请求收集在一起，然后用一次磁盘 I/O 操作完成所有这些事务的日志写入，从而有效地减少了磁盘的等待时间。依次排队刷盘的时间成本是 10，那么将这 10 个事务一次性一起刷盘的时间成本则近似于 1。</p><p>引入了<strong>组提交机制</strong>后，prepare 阶段不变，只针对 commit 阶段，将 commit 阶段拆分为三个过程：</p><ul><li><strong>flush 阶段</strong>：多个事务按进入的顺序将 binlog 从 cache 写入文件（不刷盘）；</li><li><strong>sync 阶段</strong>：对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）；</li><li><strong>commit 阶段</strong>：各个事务按顺序做 InnoDB commit 操作；</li></ul><p><strong>每个阶段都有一个队列</strong>，<strong>每个阶段有锁进行保护，因此保证了事务写入的顺序，第一个进入队列的事务会成为 leader，leader领导所在队列的所有事务</strong>，全权负责整队的操作，完成后通知队内其他事务操作结束。</p><p>对每个阶段引入了队列后，锁就只针对每个队列进行保护，不再锁住提交事务的整个过程，可以看的出来，<strong>锁粒度减小了，这样就使得多个阶段可以并发执行，从而提升效率</strong>。</p><h5 id="prepare阶段"><a href="#prepare阶段" class="headerlink" title="prepare阶段"></a>prepare阶段</h5><p>prepare阶段主要做的是设置redo log 的XID(事务id)与prepare状态,然后进行redo log的刷盘.</p><p>在 MySQL 5.6 的组提交逻辑中，每个事务各自执行 prepare 阶段，也就是各自将 redo log 刷盘，这样就没办法对 redo log 进行组提交。</p><p>所以在 MySQL 5.7 版本中，做了个改进，<strong>在 prepare 阶段不再让事务各自执行 redo log 刷盘操作，而是推迟到组提交的 flush 阶段，也就是说 prepare 阶段融合在了 flush 阶段</strong>。</p><p>这个优化是将 redo log 的刷盘延迟到了 flush 阶段之中，sync 阶段之前。通过延迟写 redo log 的方式，为 redolog 做了一次组写入，这样 binlog 和 redo log 都进行了优化。</p><h5 id="flush阶段"><a href="#flush阶段" class="headerlink" title="flush阶段"></a>flush阶段</h5><p>第一个事务会成为 flush 阶段的 Leader，此时后面到来的事务都是 Follower. 在redo log组提交下,获取队列中的事务组，由事务组的 Leader 对 redo log 做一次 write + fsync，即一次将同组事务的 redolog 刷盘。</p><p>完成了 prepare 阶段后，将这一组事务执行过程中产生的 binlog 写入 binlog 文件（调用 write，不会调用 fsync，所以不会刷盘，binlog 缓存在操作系统的文件系统中）。flush 阶段队列的作用是<strong>用于支撑 redo log 的组提交</strong>。如果在这一步完成后数据库崩溃，由于 binlog 中没有该组事务的记录，所以 MySQL 会在重启后回滚该组事务。</p><h5 id="sync阶段"><a href="#sync阶段" class="headerlink" title="sync阶段"></a>sync阶段</h5><p>一组事务的 binlog 写入到 binlog 文件后，并不会马上执行刷盘的操作，而是<strong>会等待一段时间</strong>，这个等待的时长由 <code>Binlog_group_commit，_sync_delay</code> 参数控制，<strong>目的是为了组合更多事务的 binlog，然后再一起刷盘</strong>，在等待的过程中，如果事务的数量提前达到了 <code>Binlog_group_commit_sync_no_delay_count</code> 参数设置的值，就不用继续等待了，就马上将 binlog 刷盘。可以知道 sync 阶段队列的作用是<strong>用于支持 binlog 的组提交</strong>。</p><p>如果想提升 binlog 组提交的效果，可以通过设置下面这两个参数来实现：</p><ul><li><code>binlog_group_commit_sync_delay= N</code>，表示在等待 N 微妙后，直接调用 fsync，将处于文件系统中 page cache 中的 binlog 刷盘，也就是将「 binlog 文件」持久化到磁盘。</li><li><code>binlog_group_commit_sync_no_delay_count = N</code>，表示如果队列中的事务数达到 N 个，就忽视binlog_group_commit_sync_delay 的设置，直接调用 fsync，将处于文件系统中 page cache 中的 binlog 刷盘。</li></ul><h5 id="commit阶段"><a href="#commit阶段" class="headerlink" title="commit阶段"></a>commit阶段</h5><p>进入 commit 阶段，调用引擎的提交事务接口，将 redo log 状态设置为 commit。commit 阶段队列的作用是承接 sync 阶段的事务，完成最后的引擎提交，使得 sync 可以尽早的处理下一组事务，最大化组提交的效率。</p><p>在早期的 MySQL 版本中，通过使用 prepare_commit_mutex 锁来保证事务提交的顺序，在一个事务获取到锁时才能进入 prepare 阶段，一直到 commit 阶段结束才能释放锁，下个事务才可以继续进行 prepare 操作。</p><p>通过加锁虽然完美地解决了顺序一致性的问题，但在并发量较大的时候，就会导致对锁的争用，性能不佳。</p><div class="table-container"><table><thead><tr><th>特性</th><th><strong>老版本 (5.6 之前)</strong></th><th><strong>新版本 (5.7 / 8.0)</strong></th></tr></thead><tbody><tr><td><strong>并发策略</strong></td><td>使用全局互斥锁 <code>prepare_commit_mutex</code> 将提交过程<strong>串行化</strong></td><td>使用队列和组提交机制,减小了锁粒度，实现了<strong>并行提交</strong></td></tr><tr><td><strong>Binlog 写入</strong></td><td>每个事务独立竞争锁，然后写入 Binlog，导致频繁 I/O</td><td>多个事务排队，由专门线程<strong>批量写入</strong> Binlog，减少 I/O</td></tr><tr><td><strong>性能</strong></td><td>高并发写入场景下，<code>prepare_commit_mutex</code> 成为<strong>瓶颈</strong></td><td>显著提高了并发提交的性能，<code>prepare_commit_mutex</code> 不再是瓶颈</td></tr></tbody></table></div><p>事务在提交的时候，需要将 binlog 和 redo log 持久化到磁盘，那么如果出现 MySQL 磁盘 I/O 很高的现象，可以通过控制以下参数，来 “延迟” binlog 和 redo log 刷盘的时机，从而降低磁盘 I/O 的频率：</p><ul><li>设置组提交的两个参数： binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，延迟 binlog 刷盘的时机，从而减少 binlog 的刷盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但即使 MySQL 进程中途挂了，也没有丢失数据的风险，因为 binlog 早被写入到 page cache 了，只要系统没有宕机，缓存在 page cache 里的 binlog 就会被持久化到磁盘。</li><li>将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000），表示每次提交事务都 write，但累积 N 个事务后才 fsync，相当于延迟了 binlog 刷盘的时机。但是这样做的风险是，主机掉电时会丢 N 个事务的 binlog 日志。</li><li>将 innodb_flush_log_at_trx_commit 设置为 2。表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache，专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存，然后交由操作系统控制持久化到磁盘的时机。但是这样做的风险是，主机掉电的时候会丢数据。</li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h2><ul><li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。</li><li><strong>一致性（Consistency）</strong>：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。</li><li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。</li><li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p><ul><li>持久性是通过 redo log （重做日志）来保证的；</li><li>原子性是通过 undo log（回滚日志） 来保证的；</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li><li>一致性则是通过持久性+原子性+隔离性来保证；</li></ul><h2 id="并行事务遇到的问题"><a href="#并行事务遇到的问题" class="headerlink" title="并行事务遇到的问题"></a>并行事务遇到的问题</h2><p>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。</p><p>那么在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题。</p><p>脏读:如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</p><p>不可重复读:在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了现象</p><p>幻读:在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了幻读现象.</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低</p><p>第一种是<strong>读取未提交</strong>（READ UNCOMMITTED），在这个隔离级别下，事务可以读取其他事务尚未提交的数据，可能会发生脏读、不可重复读、幻读。当你在执行一个查询时，如果一个事务正在修改数据，但尚未提交，其他事务仍然可以看到这个未提交的数据。这虽然提供了最高的并发性，但也带来了数据一致性的风险，比如读取到不一致的数据。</p><p>第二种是<strong>读取已提交</strong>（READ COMMITTED），在这个隔离级别下，事务只能读取其他事务已提交的数据，可能会发生不可重复读、幻读。当你在执行一个查询时，只有那些已经提交的事务对当前事务可见。然而，不可重复读问题依然存在：如果在同一个事务中多次查询相同的数据，可能会得到不同的结果，因为其他事务可能在查询间修改了数据。</p><p>第三种是<strong>可重复读</strong>（REPEATABLE READ），在这个隔离级别下，事务在执行期间会锁定查询的数据行，确保该数据在事务完成前不会被其他事务修改。当你在执行一个查询时，同一事务中的查询结果不会变化，即使其他事务修改了数据，当前事务也看不到变化的数据。然而，这个级别仍然存在幻读问题，即在查询过程中，其他事务可能会插入新的数据行，导致当前事务查询的数据集发生变化。</p><p>第四种是<strong>可串行化</strong>（SERIALIZABLE），在这个隔离级别下，事务的执行会像是串行执行的，即一个事务执行完成后，另一个事务才能开始。当你在执行一个查询时，不仅当前查询的数据不会被修改，其他事务也不能插入新的数据行。这个级别提供了最高的数据一致性，但代价是性能的显著下降，因为它限制了并发操作。</p><p>MySQL 在<strong>可重复读隔离级别</strong>下，可以很大程度上避免幻读现象的发生（注意是很大程度避免，并不是彻底避免），所以 MySQL 并不会使用串行化隔离级别来避免幻读现象的发生，因为使用串行化隔离级别会影响性能。</p><p>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象，解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><p>这四种隔离级别具体是如何实现的呢？</p><ul><li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li><li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li><li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 <strong>Read View \</strong>来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。*<em>「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View*</em>。</li></ul><p>执行「开始事务」命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，分别是：</p><ul><li>第一种：begin/start transaction 命令；</li><li>第二种：start transaction with consistent snapshot 命令；</li></ul><p>这两种开启事务的命令，事务的启动时机是不同的：</p><ul><li>执行了 begin/start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了第一条 select 语句，才是事务真正启动的时机；</li><li>执行了 start transaction with consistent snapshot 命令，就会马上启动事务。</li></ul><h2 id="MVCC如何实现"><a href="#MVCC如何实现" class="headerlink" title="MVCC如何实现"></a>MVCC如何实现</h2><p><strong>MVCC 的核心思想</strong>是：</p><ol><li><strong>读不阻塞写，写不阻塞读：</strong> 允许多个事务同时读写数据，而不会因为读写操作相互加锁而产生阻塞。</li><li><strong>多版本：</strong> 当一个事务修改一行数据时，InnoDB 不会直接覆盖旧数据，而是会创建该行的一个新版本。旧版本的数据会通过 <strong>Undo Log</strong> 链表连接起来，形成一个历史版本链。</li><li><strong>快照读（Snapshot Read）：</strong> 普通的 <code>SELECT</code> 语句（不加锁的读）会读取一个基于事务开始时的快照，从而看到一致性的数据。</li><li><strong>当前读（Current Read）：</strong> <code>SELECT ... FOR SHARE</code> 或 <code>SELECT ... FOR UPDATE</code> 这样的语句会读取最新的数据版本，并对数据加锁。</li></ol><p><code>Read View</code> 本质上是一个<strong>事务在某一刻开启时，所有活跃（未提交）事务的列表</strong>。它记录了“<strong>我（当前事务）开始时，世界上有哪些事务还在跑</strong>”。这个视图是用来判断查询到的数据版本是否对当前事务可见的关键。</p><p>当你执行一个普通的 <code>SELECT</code> 语句时，InnoDB 会检查该行数据（的某个版本）的事务 ID（<code>DB_TRX_ID</code>）以及其他信息，并与 <code>Read View</code> 中的活跃事务列表进行比较，从而判断这个版本的数据是否应该被当前事务看到。</p><h3 id="Read-View是什么"><a href="#Read-View是什么" class="headerlink" title="Read View是什么"></a>Read View是什么</h3><p>一个 <code>Read View</code> 主要包含以下几个核心组成部分：</p><ol><li><strong><code>m_ids</code> (活跃事务 ID 列表)：</strong> 一个列表中，包含了在创建 <code>Read View</code> 时，所有当前活跃（即已启动但尚未提交或回滚）的事务的 ID。</li><li><strong><code>min_trx_id</code> (最小活跃事务 ID)：</strong> <code>m_ids</code> 列表中最小的事务 ID。比这个 ID 小的所有事务都已经提交了。</li><li><strong><code>max_trx_id</code> (下一个可分配的事务 ID)：</strong> 一个未来的值，表示系统<strong>即将</strong>分配给下一个新事务的 ID。比这个 ID 大的事务（或者说，<code>max_trx_id</code> 及之后的所有事务）都是在 <code>Read View</code> 创建之后才启动的。 这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1；</li><li><strong><code>creator_trx_id</code> (创建者事务 ID)：</strong> 创建这个 <code>Read View</code> 的事务本身的 ID</li></ol><p><img data-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png" alt="img"></p><p>此外,使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：</p><ul><li><p>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</p></li><li><p>roll_pointer，每次对某条聚簇索引记录进行改动时，都<strong>会把旧版本的记录写入到 undo 日志中</strong>，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</p><p>因此通过min_trx_id,m_ids以及max_trx_id将read view分成不同情况.</p></li></ul><p><img data-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/ReadView.drawio.png" alt="img" style="zoom:67%;" /></p><p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p><ul><li><p>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</p></li><li><p>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</p></li><li><p>如果记录的 trx_id 值在 Read View 的min_trx_id和max_trx_id</p><p>之间，需要判断 trx_id 是否在 m_ids 列表中：</p><ul><li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li></ul></li></ul><p>这种<strong>通过版本链来控制并发事务访问</strong>同一个记录时的行为就叫 MVCC（多版本并发控制）</p><h2 id="可重复读如何工作"><a href="#可重复读如何工作" class="headerlink" title="可重复读如何工作"></a>可重复读如何工作</h2><p>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View。</p><p>MVCC 是实现可重复读的核心。当一个事务（我们称之为 T1）开启并执行第一次快照读（<code>SELECT</code> 语句，不加锁的读）时，InnoDB 会为这个事务创建一个 <strong>Read View（读视图）</strong>。</p><p>这个 <code>Read View</code> 就像一个<strong>时间戳</strong>，记录了 T1 事务开始时，数据库中所有活跃（未提交）事务的 ID 列表。</p><p><strong><code>Read View</code> 的生命周期：</strong></p><p>在 <code>Repeatable Read</code> 隔离级别下，一个事务的 <code>Read View</code> 是在<strong>该事务第一次执行快照读时创建，并贯穿该事务的整个生命周期，直到事务提交或回滚</strong>。</p><p><strong>查询可见性判断：</strong></p><p>当 T1 事务执行后续的 <code>SELECT</code> 查询时，它会拿着这个固定的 <code>Read View</code> 去判断每个数据行版本是否可见。判断规则如下：</p><ul><li><strong>如果一个数据版本是由比 <code>Read View</code> 中最小活跃事务 ID（<code>min_trx_id</code>）更小的事务 ID 创建的（也就是说，这个版本在 T1 事务开始前就已存在并提交），那么这个版本对 T1 可见。</strong></li><li><strong>如果一个数据版本是由 <code>Read View</code> 中活跃事务 ID 列表（<code>m_ids</code>）中的任何一个事务创建的（也就是说，这个版本在 T1 事务开始时正在被修改，且未提交），那么这个版本对 T1 不可见。</strong></li><li><strong>如果一个数据版本是由比 <code>Read View</code> 中最大事务 ID（<code>max_trx_id</code>）更大的事务 ID 创建的（也就是说，这个版本是在 T1 事务开始之后才创建的），那么这个版本对 T1 不可见。</strong></li><li><strong>如果数据版本是由 T1 事务自己创建的，则可见。</strong></li></ul><p><strong>通过这种机制，T1 事务在整个过程中，每次查询都会看到一个固定的、一致的数据快照，即使其他事务在这期间修改或删除了数据并提交，T1 也看不到这些变更。</strong></p><p><strong>例子：</strong></p><ol><li><p>事务 A 启动。</p></li><li><p>事务 A 第一次执行 <code>SELECT * FROM accounts WHERE id = 10;</code> (假设读到 balance = 100)。此时，事务 A 的 <code>Read View</code> 被创建。</p></li><li><p>事务 B 启动，将 <code>id = 10</code> 的 <code>balance</code> 修改为 50，并提交。</p></li><li><p>事务 A 第二次执行 <code>SELECT * FROM accounts WHERE id = 10;</code>。</p><ul><li>因为事务 A 的 <code>Read View</code> 在第一次查询时就已经固定了，事务 B 的修改发生在事务 A 的 <code>Read View</code> 创建之后且事务 B 事务 ID 大于<code>min_trx_id</code>，所以事务 A 依然看到的是 <code>balance = 100</code>。事务 B 的修改对事务 A 是不可见的。</li></ul><p>也就是说可重复读会沿着undo log链中数据行的roll_pointer找到合适的trx_id进行读取.</p></li></ol><p>在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select .. for update 语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。</p><p><strong>读提交隔离级别</strong>是在每次读取数据时，都会生成一个新的 Read View,这个read view中的m_ids以及min_trx_id等记录跟同一个事务之前的read view很可能不同.</p><p>也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p><h2 id="幻读如何解决"><a href="#幻读如何解决" class="headerlink" title="幻读如何解决"></a>幻读如何解决</h2><p>幻读指的是在同一个事务中，两次执行相同的范围查询（例如 <code>SELECT ... WHERE condition</code>），但第二次查询的结果集显示，满足查询条件的行数增加了或减少了。</p><p>同一个查询在不同的时间产生不同的结果集时，事务中就会出现所谓的幻象问题。例如，如果 SELECT 执行了两次，但第二次返回了第一次没有返回的行</p><p>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><h3 id="快照读情况下"><a href="#快照读情况下" class="headerlink" title="快照读情况下"></a>快照读情况下</h3><p>普通select进行快照读,也就是按照隔离级别读取对应版本数据.</p><p>可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是开始事务后（执行 begin 语句后），在执行第一个查询语句后，会创建一个 Read View，<strong>后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的</strong>，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题</p><h3 id="当前读情况下"><a href="#当前读情况下" class="headerlink" title="当前读情况下"></a>当前读情况下</h3><p>MySQL 里除了普通查询是快照读，其他都是<strong>当前读</strong>，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。</p><p>另外，<code>select ... for update</code> 这种查询语句是当前读，每次执行的时候都是读取最新的数据。</p><p><strong>Innodb 引擎为了解决「可重复读」隔离级别使用「当前读」而造成的幻读问题，就引出了间隙锁</strong>。</p><p>可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读</p><p>例如,在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id = 5 的记录并提交。接着，事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。</p><p>除了上面这一种场景会发生幻读现象之外，还有下面这个场景也会发生幻读现象。</p><ul><li>T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。</li><li>T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；</li><li>T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</li></ul><p><strong>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句</strong>，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h2><p>索引（Index）是一种用于加速数据库查询操作的数据结构，它的核心作用是提升查询的速度。从本质上来说，索引的作用就是帮助快速定位有序双向链表中的元素，从而减少数据扫描的范围，提高查询效率。接下来，我会详细讲述索引的基本概念和原理。</p><p>第一个是<strong>索引的基本概念</strong>，</p><p>索引是数据库中一种独特的数据结构，它并不直接存储表中的数据，而是通过创建一个新的数据结构来指向数据表中的具体记录。可以把它类比为字典的目录：当我们查字典时，首先会根据单词的起始字母找到目录页，然后通过目录页中的页码快速定位到具体的单词位置。在这个过程中，目录页就相当于索引表，而目录项就是索引本身。</p><p>然而，索引比字典目录更加复杂，因为数据库需要处理动态的数据操作，比如插入、删除和更新等操作。这些操作会导致索引发生变化，因此数据库需要维护索引的一致性和高效性。</p><p>第二个是<strong>索引的原理</strong>，</p><p>当你在MySQL中创建一个索引时， 首先，MySQL会选择一种数据结构来存储索引，最常见的结构是B+树。B+树是一种自平衡的树形结构，叶子节点存储所有数据，而非叶子节点存储索引信息。它的每个节点包含多个键值对，每个键值对指向一个数据块。 然后，索引会根据数据列的值进行排序，将相应的数据行指向叶子节点。</p><p>当你执行一个查询时， 首先，MySQL会利用索引的树结构，根据查询条件快速定位到数据的范围，而无需扫描全表。通过从根节点开始，逐层向下遍历B+树，最终可以找到符合条件的数据。 其次，如果索引指向的列已经包含查询条件，MySQL可以直接从索引中获取数据，避免了全表扫描，提高了查询速度。 最后，如果查询条件涉及多个列，MySQL会使用复合索引来进一步提高查找效率，通过联合多个列的索引来加速多条件查询。</p><p>按照四个角度来分类索引。</p><ul><li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li><li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li><li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li><li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li></ul><p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</li></ul><p>主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：</p><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li></ul><p><strong>回表查询</strong></p><p>回表查询是指数据库在执行查询时，<strong>先通过索引找到对应的“行 ID”（例如 InnoDB 的主键值）</strong>，<strong>然后再根据这个行 ID 到原始数据表中（聚簇索引/B+树的叶子节点）获取所有完整的行数据</strong>。</p><p>简单来说，就是查询所需的所有列数据<strong>不在索引本身</strong>中，需要“回到”数据表（或叫<strong>聚簇索引</strong>的叶子节点）去取。</p><p><strong>覆盖索引</strong></p><p>覆盖索引是指查询语句所需要的所有数据列（包括 <code>SELECT</code> 子句中的列和 <code>WHERE</code>、<code>ORDER BY</code>、<code>GROUP BY</code> 子句中使用的列）<strong>都可以在索引中直接找到，而无需再回到数据表（聚簇索引）进行回表查询</strong>。</p><p><strong>索引下推</strong></p><p>现在我们知道，对于联合索引（a, b），在执行 <code>select * from table where a &gt; 1 and b = 2</code> 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？</p><ul><li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。</li><li>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</li></ul><p>当你的查询语句的执行计划里，出现了 Extra 为 <code>Using index condition</code>，那么说明使用了索引下推的优化</p><p><strong>索引区分度</strong></p><p>另外，建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中<strong>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到</strong>。</p><p>区分度就是某个字段 column 不同值的个数「除以」表的总行数.性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 UUID 这类字段就比较适合做索引或排在联合索引列的靠前的位置。</p><p>因为如果索引的区分度很小，假设字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是”30%”）很高的时候，它一般会忽略索引，进行全表扫描。</p><h2 id="聚簇索引与二级索引"><a href="#聚簇索引与二级索引" class="headerlink" title="聚簇索引与二级索引"></a>聚簇索引与二级索引</h2><p>索引又可以分成聚簇索引和非聚簇索引（二级索引），它们区别就在于叶子节点存放的是什么数据：</p><ul><li>聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；</li><li>二级索引的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。</p><p><img data-src="https://cdn.xiaolincoding.com//mysql/other/7c635d682bd3cdc421bb9eea33a5a413.png" alt="图片" style="zoom: 80%;" /></p><p>InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键；</li></ul><p>一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引/辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。</p><p><img data-src="https://cdn.xiaolincoding.com//mysql/other/3104c8c3adf36e8931862fe8a0520f5d.png" alt="图片" style="zoom:80%;" /></p><h2 id="什么时候需要索引"><a href="#什么时候需要索引" class="headerlink" title="什么时候需要索引"></a>什么时候需要索引</h2><p>索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：</p><ul><li>需要占用物理空间，数量越大，占用空间越大；</li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li><li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护</li></ul><h3 id="什么时候适用索引？"><a href="#什么时候适用索引？" class="headerlink" title="什么时候适用索引？"></a>什么时候适用索引？</h3><ul><li>字段有唯一性限制的，比如商品编码；</li><li>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li><li>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li></ul><h3 id="什么时候不需要创建索引？"><a href="#什么时候不需要创建索引？" class="headerlink" title="什么时候不需要创建索引？"></a>什么时候不需要创建索引？</h3><ul><li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</li><li>字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li><li>表数据太少的时候，不需要创建索引；</li><li>经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li></ul><h2 id="InnoDB如何存储数据"><a href="#InnoDB如何存储数据" class="headerlink" title="InnoDB如何存储数据"></a>InnoDB如何存储数据</h2><p><strong>InnoDB 的数据是按「数据页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。</p><p>数据页包括文件头,文件尾,页头以及页目录等信息</p><p><img data-src="https://cdn.xiaolincoding.com//mysql/other/243b1466779a9e107ae3ef0155604a17.png" alt="图片" style="zoom:67%;" /></p><p><strong>数据页中的用户记录按照「主键」顺序组成单向链表</strong>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p><p>因此，数据页中有一个<strong>页目录</strong>，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。</p><p><img data-src="https://cdn.xiaolincoding.com//mysql/other/261011d237bec993821aa198b97ae8ce.png" alt="图片" style="zoom:50%;" /></p><p>页目录创建的过程如下：</p><ol><li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li><li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）</li><li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），<strong>每个槽相当于指针指向了不同组的最后一个记录</strong>。</li></ol><p>从图可以看到，<strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表。</p><h3 id="如何使用B-树进行查询"><a href="#如何使用B-树进行查询" class="headerlink" title="如何使用B+树进行查询"></a>如何使用B+树进行查询</h3><p><strong>InnoDB 采用了 B+ 树作为索引</strong>。磁盘的 I/O 操作次数对索引的使用效率至关重要，因此在构造索引的时候，我们更倾向于采用“矮胖”的 B+ 树数据结构，这样所需要进行的磁盘 I/O 次数更少，而且 B+ 树 更适合进行关键字的范围查询。InnoDB 里的 B+ 树中的<strong>每个节点都是一个数据页</strong>.</p><ul><li>只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li><li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li><li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li></ul><p>再看看 B+ 树如何实现快速查找主键为 6 的记录，以上图为例子：</p><ul><li>从根节点开始，通过二分法快速定位到符合页内范围包含查询值的页，因为查询的主键值为 6，在[1, 7)范围之间，所以到页 30 中查找更详细的目录项；</li><li>在非叶子节点（页30）中，继续通过二分法快速定位到符合页内范围包含查询值的页，主键值大于 5，所以就到叶子节点（页16）查找记录；</li><li>接着，在叶子节点（页16）中，通过槽查找记录时，使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到主键为 6 的记录。</li></ul><p>可以看到，在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。定位到该页后，又会在该页内进行二分法快速定位记录所在的分组（槽号），最后在分组内进行遍历查找</p><h2 id="为什么使用B-树作为索引的数据类型"><a href="#为什么使用B-树作为索引的数据类型" class="headerlink" title="为什么使用B+树作为索引的数据类型"></a>为什么使用B+树作为索引的数据类型</h2><p>B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。</p><p>另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</p><p>对于有 N 个叶子节点的 B+Tree，其搜索复杂度为<code>O(logdN)</code>，其中 d 表示节点允许的最大子节点个数为 d 个。</p><p>在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据。</p><p>而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 <code>O(logN)</code>，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。</p><p>Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。</p><p>但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。</p><h3 id="B树-红黑树与B-树的特别点以及区别"><a href="#B树-红黑树与B-树的特别点以及区别" class="headerlink" title="B树,红黑树与B+树的特别点以及区别"></a>B树,红黑树与B+树的特别点以及区别</h3><p>B+树、B树和红黑树是常见的平衡树数据结构，尤其在数据库、文件系统和内存中应用的十分广泛。</p><p>第一个方面是<strong>数据存储位置</strong>。B+树将所有数据存储在叶子节点，非叶子节点只存储索引键；B树则将数据存储在叶子节点和非叶子节点中，所有节点都存储数据；而红黑树则在每个节点中都存储数据。</p><p>第二个方面是<strong>叶子节点结构</strong>。B+树通过链表连接叶子节点，这使得范围查询和顺序遍历非常高效；B树的叶子节点不一定通过链表连接，缺乏直接支持范围查询的结构；红黑树没有专门的叶子节点结构，所有节点通过指针连接。</p><p>第三个方面是<strong>索引查找效率</strong>。B+树的查找操作最终都在叶子节点完成，查找路径统一，效率较高；B树的查找操作可能在非叶子节点完成，查找路径不统一，效率稍低；红黑树的查找路径统一，时间复杂度为O(log n)，每次操作通过旋转和重新染色来保持平衡。</p><p>第四个方面是<strong>树的高度</strong>。B+树由于扇出较高（每个节点存储多个键），树的高度通常较低，查询效率较高；B树由于非叶子节点也存储数据，扇出较小，树的高度较高；红黑树作为二叉查找树，树的高度较高，每个节点最多有两个子节点，树的深度较大。</p><p>第五个方面是<strong>顺序访问效率</strong>。B+树通过链表连接叶子节点，支持高效的顺序访问，尤其在范围查询时表现出色；B树没有直接的顺序访问机制，顺序访问效率较低；红黑树也缺乏顺序访问机制，顺序遍历效率较低。</p><p>第六个方面是<strong>磁盘I/O效率</strong>。B+树由于非叶子节点只存储索引，扇出高，可以减少磁盘访问次数，因此磁盘I/O效率非常优秀；B树稍逊于B+树，因为非叶子节点也存储数据，导致扇出较小，磁盘访问次数略多；红黑树的磁盘I/O效率较差，因为树的高度较高，每次查找可能需要频繁访问磁盘。</p><p>第七个方面是<strong>适用场景</strong>。B+树常用于数据库索引、文件系统索引，适合大规模数据的存储和检索，尤其在需要高效范围查询时；B树适用于数据库索引和文件系统索引，但相比B+树，查找效率稍低；红黑树适用于内存中的数据结构，如Java中的TreeMap和TreeSet，适合存储符号表、集合、关联数组等内存数据。</p><p>第八个方面是<strong>平衡性</strong>。B+树将所有叶子节点置于同一层，平衡性非常好；B树平衡性较好，但查找路径不统一，效率稍逊；红黑树通过旋转和染色来保持平衡，查找路径统一，操作保持平衡。</p><p>第九个方面是<strong>插入/删除操作</strong>。B+树的插入和删除操作可能会引发节点分裂和合并，操作较复杂；B树的插入和删除操作也可能引发节点分裂和合并，操作较复杂；红黑树通过旋转和染色保持平衡，操作相对简单。</p><p>第十个方面是<strong>实现复杂度</strong>。B+树的实现较复杂，尤其是在处理链表结构和节点分裂/合并时；B树的实现也较复杂，涉及节点分裂/合并，但相对较为简单；红黑树的实现相对简单，通过旋转和染色来保持平衡。</p><p>第十一个方面是<strong>空间利用率</strong>。B+树的空间利用率较高，非叶子节点只存储索引，存储效率较好；B树的空间利用率较低，非叶子节点存储数据和索引，存储效率较低；红黑树的空间利用率较高，所有节点都存储数据，且由于树的平衡性，内存利用效率较好。</p><p>MySQL 是会将数据持久化在硬盘，而存储功能是由 MySQL 存储引擎实现的，所以讨论 MySQL 使用哪种数据结构作为索引，实际上是在讨论存储引使用哪种数据结构作为索引，InnoDB 是 MySQL 默认的存储引擎，它就是采用了 B+ 树作为索引的数据结构。</p><p>要设计一个 MySQL 的索引数据结构，<strong>不仅仅考虑数据结构增删改的时间复杂度，更重要的是要考虑磁盘 I/O 的操作次数。因为索引和记录都是存放在硬盘</strong>，硬盘是一个非常慢的存储设备，我们在查询数据的时候，最好能在尽可能少的磁盘 I/O的操作次数内完成。</p><p><strong>二分查找树虽然是一个天然的二分结构，能很好的利用二分查找快速定位数据，但是它存在一种极端的情况，每当插入的元素都是树内最大的元素，就会导致二分查找树退化成一个链表</strong>，此时查询复杂度就会从 O(logn)降低为 O(n)。</p><p>为了解决二分查找树退化成链表的问题，就出现了<strong>自平衡二叉树，保证了查询操作的时间复杂度就会一直维持在 O(logn) 。但是它本质上还是一个二叉树，每个节点只能有 2 个子节点，随着元素的增多，树的高度会越来越高。</strong></p><p>而树的高度决定于磁盘 I/O 操作的次数，因为树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作，也就是说树的高度就等于每次查询数据时磁盘 IO 操作的次数，所以树的高度越高，就会影响查询性能。</p><p>B 树和 B+ 都是通过多叉树的方式，会将树的高度变矮，所以这两个数据结构非常适合检索存于磁盘中的数据。</p><p>但是 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：</p><ul><li>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。</li><li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</li><li>B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。</li></ul><h2 id="优化索引方法"><a href="#优化索引方法" class="headerlink" title="优化索引方法"></a>优化索引方法</h2><p>常见优化索引的方法：</p><ul><li>前缀索引优化；</li></ul><p>使用某个字段中字符串的前几个字符建立索引，那我们为什么需要使用前缀来建立索引呢？</p><p>使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</p><p>不过，前缀索引有一定的局限性，例如：order by 就无法使用前缀索引；无法把前缀索引用作覆盖索引</p><ul><li>覆盖索引优化；</li></ul><p>覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。</p><p>使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。</p><ul><li>主键索引最好是自增的；</li></ul><p>InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。</p><p><strong>如果我们使用自增主键</strong>，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</p><p><strong>如果我们使用非自增主键</strong>，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。<strong>页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</strong>。</p><p>因此，在使用 InnoDB 存储引擎时，如果没有特别的业务需求，建议使用自增字段作为主键。</p><p>另外，主键字段的长度不要太大，因为<strong>主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小</strong></p><ul><li>防止索引失效</li></ul><h2 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h2><p>发生索引失效的情况：</p><ul><li>当使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中<strong>对索引列做了计算、函数、类型转换操作</strong>，这些情况下都会造成索引失效；</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，<strong>如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列</strong>，那么索引会失效。</li><li>当查询中使用了 NOT 或 != 操作符时，索引可能会失效。例如，WHERE column != ‘value’ 或 WHERE NOT column = ‘value’ 这样的查询条件通常会导致数据库放弃使用索引，因为这类操作需要扫描大量数据来排除不符合条件的记录</li></ul><p>当 MySQL 使用复合索引时，它会从左到右匹配索引列。</p><p>一旦遇到一个<strong>范围查询（<code>&gt;</code>、<code>&lt;</code>、<code>BETWEEN</code>、<code>LIKE &#39;前缀%&#39;</code> 等）</strong>的列，索引的<strong>查找功能（Index Seek）</strong>就会停止在这个列上。</p><p>范围查询后面的索引列，虽然在物理上依然存在于索引中，但它们无法再用于进一步的<strong>索引匹配</strong>来缩小扫描范围。它们可能仍然用于<strong>索引覆盖</strong>（避免回表）或帮助进行 <code>filesort</code> 优化，但不再是查询优化器选择的索引查找路径的一部分。</p><h3 id="索引使用左或左右模糊匹配"><a href="#索引使用左或左右模糊匹配" class="headerlink" title="索引使用左或左右模糊匹配"></a>索引使用左或左右模糊匹配</h3><p>具体来说,当使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效。<strong>因为索引 B+ 树是按照”索引值”有序排列存储的，只能根据前缀进行比较</strong>。</p><h3 id="对索引使用函数、表达式、隐式类型转换"><a href="#对索引使用函数、表达式、隐式类型转换" class="headerlink" title="对索引使用函数、表达式、隐式类型转换"></a>对索引使用函数、表达式、隐式类型转换</h3><p>因为<strong>索引保存的是索引字段的原始值，而不是经过函数计算后的值</strong>，自然就没办法走索引了。</p><p>不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</p><p>举个例子，对 length(name) 的计算结果建立一个名为 idx_name_length 的索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t_user <span class="keyword">add</span> key idx_name_length ((length(name)));</span><br></pre></td></tr></table></figure><p>然后再用下面这条查询语句，这时候就会走索引了。</p><p>mysql的隐式类型转换规则:在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较.</p><h3 id="联合索引非最左前缀匹配"><a href="#联合索引非最左前缀匹配" class="headerlink" title="联合索引非最左前缀匹配"></a>联合索引非最左前缀匹配</h3><p>对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。</p><p>那么<strong>多个普通字段组合在一起创建的索引就叫做联合索引</strong>，也叫组合索引。</p><p>创建联合索引时，需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。联合索引要能正确使用需要遵循<strong>最左匹配原则</strong></p><p>如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p><ul><li>where a=1；</li><li>where a=1 and b=2 and c=3；</li><li>where a=1 and b=2；</li></ul><p>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</p><p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p><ul><li>where b=2；</li><li>where c=3；</li><li>where b=2 and c=3；</li></ul><p>有一个比较特殊的查询条件：where a = 1 and c = 3 ，符合最左匹配吗？</p><p>这种其实严格意义上来说是属于索引截断，不同版本处理方式也不一样。</p><p>MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。</p><p>从 MySQL 5.6 之后，有一个<strong>索引下推功能</strong>，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。</p><p>索引下推的大概原理是：截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 <code>(a, b, c)</code> 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。</p><h3 id="where字句中的OR"><a href="#where字句中的OR" class="headerlink" title="where字句中的OR"></a>where字句中的OR</h3><p>在 WHERE 子句中，如果<strong>在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列</strong>，那么索引会失效。</p><p>这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</p><p>这里介绍的六种索引失效情况:</p><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li><li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li><li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul><h3 id="explain执行计划"><a href="#explain执行计划" class="headerlink" title="explain执行计划"></a>explain执行计划</h3><p>explain查看执行计划</p><p>对于执行计划，参数有：</p><ul><li>possible_keys 字段表示可能用到的索引；</li><li>key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；</li><li>key_len 表示索引的长度；</li><li>rows 表示扫描的数据行数。</li><li>type 表示数据扫描类型，我们需要重点看这个</li></ul><p>type 字段就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的<strong>执行效率从低到高的顺序为</strong>：</p><ul><li>All（全表扫描）；</li><li>index（全索引扫描）；</li><li>range（索引范围扫描）；</li><li>ref（非唯一索引扫描）；</li><li>eq_ref（唯一索引扫描）；</li><li>const（结果只有一条的主键或唯一索引扫描）。</li></ul><p>all 是最坏的情况，因为采用了全表扫描的方式。index 和 all 差不多，只不过 index 对索引表进行全扫描，<strong>这样做的好处是不再需要对数据进行排序</strong>，但是开销依然很大。所以，要尽量避免全表扫描和全索引扫描。</p><p>range 表示采用了索引范围扫描，一般在 where 子句中使用 &lt; 、&gt;、in、between 等关键词，只检索给定范围的行，属于范围查找。<strong>从这一级别开始，索引的作用会越来越明显，因此我们需要尽量让 SQL 查询可以使用到 range 这一级别及以上的 type 访问方式</strong>。</p><p>ref 类型表示采用了非唯一索引，或者是唯一索引的非唯一性前缀，返回数据返回可能是多条。因为虽然使用了索引，<strong>但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描</strong>。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描。</p><p>eq_ref 类型是<strong>使用主键或唯一索引时产生的访问方式，通常使用在多表联查中。比如，对两张表进行联查，关联条件是两张表的 user_id 相等</strong>，且 user_id 是唯一索引，那么使用 EXPLAIN 进行执行计划查看的时候，type 就会显示 eq_ref。</p><p>const 类型表示<strong>使用了主键或者唯一索引与常量值进行比较</strong>，比如 select name from product where id=1。</p><p>需要说明的是 const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，<strong>const 是与常量进行比较，查询效率会更快，而 eq_ref 通常用于多表联查中</strong>。</p><blockquote><p>除了关注 type，也要关注 extra 显示的结果。</p></blockquote><p>这里说几个重要的参考指标：</p><ul><li>Using filesort ：当查询语句中包含 ORDER BY 操作，而且<strong>无法利用索引完成排序操作的时候</strong>， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。</li><li>Using temporary：使了用临时表保存中间结果，MySQL <strong>在对查询结果排序时使用临时表</strong>，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。</li><li>Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。</li></ul><h2 id="count-和-count-1-有什么区别？哪个性能最好？"><a href="#count-和-count-1-有什么区别？哪个性能最好？" class="headerlink" title="count(*) 和 count(1) 有什么区别？哪个性能最好？"></a>count(*) 和 count(1) 有什么区别？哪个性能最好？</h2><p>count() 是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是<strong>统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个</strong>。</p><h3 id="count作用原理"><a href="#count作用原理" class="headerlink" title="count作用原理"></a>count作用原理</h3><p>count() 是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是<strong>统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个</strong>。</p><p>使用 MyISAM 引擎时，执行 count 函数只需要 O(1 )复杂度，这是因为每张 MyISAM 的数据表都有一个 meta 信息有存储了row_count值，由表级锁保证一致性，所以直接读取 row_count 值就是 count 函数的执行结果。</p><p>InnoDB <strong>不像 MyISAM 那样维护一个精确的行数计数器</strong>。这是因为 InnoDB 遵循 <strong>MVCC（多版本并发控制）</strong> 机制。</p><ul><li>在 MVCC 下，同一个表在不同事务中可能看到不同的行数（因为有些行可能只对当前事务可见，而对其他事务不可见）。</li><li>维护一个精确的实时计数器会与 MVCC 冲突，并导致非常高的并发开销，因为每次查询都需要在不同事务版本之间进行复杂的判断。</li></ul><p><strong>没有 <code>WHERE</code> 条件的 <code>COUNT(\*)</code>：</strong> InnoDB 会选择一个<strong>最小的非聚簇索引（二级索引）</strong> 来进行<strong>全索引扫描</strong>，只遍历索引的叶子节点来计数。如果表上没有二级索引，它就会遍历<strong>聚簇索引（主键索引）</strong>。这个过程仍然需要扫描 B+Tree 的部分或全部叶子节点。</p><p><strong>有 <code>WHERE</code> 条件的 <code>COUNT(\*)</code>：</strong> MySQL 会根据 <code>WHERE</code> 条件选择最合适的索引（或者进行全表扫描）来定位符合条件的行，然后逐一计数。</p><p><code>COUNT()</code> 主要有以下几种用法：</p><ol><li><strong><code>COUNT(*)</code>：</strong><ul><li>统计表中<strong>所有行的数量</strong>，无论行中的列是否包含 <code>NULL</code> 值。</li><li>这是最常见的用法，也是 SQL 标准中推荐的计算行数的方法。</li></ul></li><li><strong><code>COUNT(expression)</code>：</strong><ul><li>统计 <code>expression</code>（通常是一个列名，例如 <code>COUNT(column_name)</code>）<strong>不为 <code>NULL</code> 的行数量</strong>。</li><li>如果 <code>expression</code> 是一个具体的列名，且该列允许 <code>NULL</code> 值，那么包含 <code>NULL</code> 值的行将不会被计数。</li><li>如果 <code>expression</code> 是一个常量（例如 <code>COUNT(1)</code>），则它的作用与 <code>COUNT(*)</code> 相同，都会统计所有行。</li></ul></li><li><strong><code>COUNT(DISTINCT expression)</code>：</strong><ul><li>统计 <code>expression</code> <strong>不为 <code>NULL</code> 且唯一的值的数量</strong>。</li></ul></li></ol><h3 id="count-1-count-count-主键-count-字段"><a href="#count-1-count-count-主键-count-字段" class="headerlink" title="count(1) count(*) count(主键) count(字段)"></a>count(1) count(*) count(主键) count(字段)</h3><h4 id="count-主键"><a href="#count-主键" class="headerlink" title="count(主键)"></a>count(主键)</h4><p>在通过 count 函数统计有多少个记录时，MySQL 的 server 层会维护一个名叫 count 的变量。</p><p>server 层会循环向 InnoDB 读取一条记录，如果 count 函数指定的参数不为 NULL，那么就会将变量 count 加 1，直到符合查询的全部记录被读完，就退出循环。最后将 count 变量的值发送给客户端。InnoDB 是通过 B+ 树来保存记录的，根据索引的类型又分为聚簇索引和二级索引，它们区别在于，聚簇索引的叶子节点存放的是实际数据，而二级索引的叶子节点存放的是主键值，而不是实际数据。如果表里只有主键索引，没有二级索引时，那么，InnoDB 循环遍历聚簇索引，将读取到的记录返回给 server 层，然后读取记录中的 id 值，就会 id 值判断是否为 NULL，如果不为 NULL，就将 count 变量加 1。</p><p>这是因为相同数量的二级索引记录可以比聚簇索引记录占用更少的存储空间，所以二级索引树比聚簇索引树小，这样遍历二级索引的 I/O 成本比遍历聚簇索引的 I/O 成本小，因此「优化器」优先选择的是二级索引。</p><p>当你执行 <code>COUNT(主键列名)</code> 时：</p><ul><li>根据 <code>COUNT(expression)</code> 的定义，数据库需要检查主键列的值是否为 <code>NULL</code>。</li><li>然而，由于主键的<strong>非空性</strong>，我们知道主键列的任何值<strong>都不可能</strong>是 <code>NULL</code>。</li></ul><p>因此，数据库的查询优化器非常聪明，它会识别出这种特殊情况：</p><ul><li>当 <code>COUNT()</code> 的参数是<strong>主键列</strong>时，优化器会知道这个列永远不为 <code>NULL</code>。</li><li>所以，它会<strong>优化掉“检查是否为 <code>NULL</code>”这一步</strong>，直接将 <code>COUNT(主键列)</code> 的行为等同于 <code>COUNT(*)</code> 或 <code>COUNT(1)</code>。它会去计算所有行的数量，因为它知道主键列的每一个值都是有效的、非空的</li></ul><h4 id="count-1"><a href="#count-1" class="headerlink" title="count(1)"></a>count(1)</h4><p>如果表里只有主键索引，没有二级索引时。那么，InnoDB 循环遍历聚簇索引（主键索引），将读取到的记录返回给 server 层，<strong>但是不会读取记录中的任何字段的值</strong>，因为 count 函数的参数是 1，不是字段，所以不需要读取记录中的字段值。参数 1 很明显并不是 NULL，因此 server 层每从 InnoDB 读取到一条记录，就将 count 变量加 1。</p><p>可以看到，count(1) 相比 count(主键字段) 少一个步骤，就是不需要读取记录中的字段值，所以通常会说 count(1) 执行效率会比 count(主键字段) 高一点。</p><p>但是，如果表里有二级索引时，InnoDB 循环遍历的对象就二级索引了</p><h4 id="count"><a href="#count" class="headerlink" title="count(*)"></a>count(*)</h4><p><strong>count(<code>\*</code>) 其实等于 count(<code>0</code>)</strong>，也就是说，当你使用 count(<code>*</code>) 时，MySQL 会将 <code>*</code> 参数转化为参数 0 来处理。</p><p><strong>count(*) 执行过程跟 count(1) 执行过程基本一样的</strong>，性能没有什么差异。</p><p>而且 MySQL 会对 count(*) 和 count(1) 有个优化，如果有多个二级索引的时候，优化器会使用key_len 最小的二级索引进行扫描。</p><p>只有当没有二级索引的时候，才会采用主键索引来进行统计</p><h4 id="count-普通字段"><a href="#count-普通字段" class="headerlink" title="count(普通字段)"></a>count(普通字段)</h4><p>count(字段) 的执行效率相比前面的 count(1)、 count(*)、 count(主键字段) 执行效率是最差的。</p><p>count(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。</p><p>所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。</p><p>再来，就是不要使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。。</p><h3 id="如何优化count"><a href="#如何优化count" class="headerlink" title="如何优化count(*)"></a>如何优化count(*)</h3><p>如果业务对于统计个数不需要很精确，比如搜索引擎在搜索关键词的时候，给出的搜索结果条数是一个大概值</p><p>可以使用show table status或EXPLAIN SELECT COUNT(*) FROM table_name输出结果中的 <code>rows</code> 字段会给出优化器预估的行数。这个值通常不精确，但对于快速获取一个大概的数字很有用。</p><p>对于允许少量延迟的计数需求，维护一个独立的计数器是最高效的方法。将这个计数值保存到单独的一张计数表中。当在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，我们需要额外维护这个计数表。</p><ul><li><strong>原理：</strong><ul><li><strong>缓存：</strong> 将 <code>COUNT(*)</code> 的结果缓存到 Redis、Memcached 等缓存系统中，并设置过期时间。</li><li><strong>计数器表：</strong> 创建一个专门的表来存储各个实体的计数。例如 <code>product_counts (product_id INT PRIMARY KEY, view_count INT, sales_count INT)</code>。</li></ul></li><li><strong>实现：</strong><ul><li><strong>异步更新：</strong> 通过应用程序代码或消息队列，在数据发生增删改时异步更新计数器。</li><li><strong>触发器（不推荐用于高并发）：</strong> 可以在数据库层面使用触发器来自动更新计数器表，但触发器本身会增加写入开销，在高并发场景下可能成为瓶颈。</li></ul></li><li><strong>优点：</strong> 极高的读取性能，因为直接从内存缓存或小型计数器表获取。</li><li><strong>缺点：</strong> 计数可能存在短暂的延迟或不一致性；增加了系统的复杂性。</li><li><strong>适用场景：</strong> 网站访客数、商品浏览量、论坛帖子数等对实时性要求不那么高的场景。</li></ul><h2 id="MySQL分页优化"><a href="#MySQL分页优化" class="headerlink" title="MySQL分页优化"></a>MySQL分页优化</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">0</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>mysql内部分为<strong>server层</strong>和<strong>存储引擎层</strong>。一般情况下存储引擎都用innodb。</p><p>server层有很多模块，其中需要关注的是<strong>执行器</strong>是用于跟存储引擎打交道的组件。</p><p>执行器可以通过调用存储引擎提供的接口，将一行行数据取出，当这些数据完全符合要求（比如满足其他where条件），则会放到<strong>结果集</strong>中，最后返回给调用mysql的<strong>客户端</strong>.</p><h3 id="基于主键索引的分页"><a href="#基于主键索引的分页" class="headerlink" title="基于主键索引的分页"></a>基于主键索引的分页</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table order by id limit 6000000, 10;</span><br></pre></td></tr></table></figure><p>server层会调用innodb的接口，由于offset=6000000，会在innodb里的主键索引中获取到第0到（6000000 + 10）条<strong>完整行数据</strong>，<strong>返回给server层之后根据offset的值挨个抛弃，最后只留下最后面的size条</strong>，也就是10条数据，放到server层的结果集中，返回给客户端。</p><p>可以看出，<strong>当offset非0时，server层会从引擎层获取到很多无用的数据，而当select后面是*号时，就需要拷贝完整的行信息</strong>，<strong>拷贝完整数据</strong>跟<strong>只拷贝行数据里的其中一两个列字段</strong>耗时是不同的，这就让原本就耗时的操作变得更多.</p><p>因为前面的offset条数据最后都是不要的，就算将完整字段都拷贝来了又有什么用呢，所以可以将sql语句修改成下面这样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where id &gt;=(select id from table order by id limit 6000000, 1) order by id limit 10;</span><br></pre></td></tr></table></figure><p>上面这条sql语句，里面先执行子查询 <code>select id from page order by id limit 6000000, 1</code>, 这个操作，其实也是将在innodb中的主键索引中获取到<code>6000000+1</code>条数据，然后server层会抛弃前6000000条，只保留最后一条数据的id。</p><p>但不同的地方在于，<strong>在返回server层的过程中，只会拷贝数据行内的id这一列，而不会拷贝数据行的所有列</strong>，当数据量较大时，这部分的耗时还是比较明显的。</p><p>在拿到了上面的id之后，假设这个id正好等于6000000，那sql就变成了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id <span class="operator">&gt;=</span>(<span class="number">6000000</span>) <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这样innodb再走一次<strong>主键索引</strong>，通过B+树快速定位到id=6000000的行数据，时间复杂度是lg(n)，然后向后取10条数据。</p><h3 id="基于非主键索引的分页"><a href="#基于非主键索引的分页" class="headerlink" title="基于非主键索引的分页"></a>基于非主键索引的分页</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from page table by user_name  limit 0, 10;</span><br></pre></td></tr></table></figure><p>server层会调用innodb的接口，在innodb里的非主键索引中获取到第0条数据对应的主键id后，<strong>回表</strong>到主键索引中找到对应的完整行数据，然后返回给server层，server层将其放到结果集中，返回给客户端。非主键索引的limit过程，比主键索引的limit过程，多了个回表的消耗</p><p>当limit offset过大时如果优化器分析回表操作次数过多会使用全表扫描</p><p>这种情况也能通过一些方式去优化。比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from page t1, (select id from page order by user_name limit 6000000, 100) t2  WHERE t1.id = t2.id;</span><br></pre></td></tr></table></figure><p>通过<code>select id from page order by user_name limit 6000000, 100</code>。先走innodb层的user_name非主键索引取出id，因为只拿主键id，<strong>不需要回表</strong>.</p><h3 id="深度分页问题"><a href="#深度分页问题" class="headerlink" title="深度分页问题"></a>深度分页问题</h3><p>当offset变得超大时，比如到了百万千万的量级就导致了<strong>深度分页</strong>.</p><p>通过<code>limit offset size</code>分页的形式去分批获取，刚开始都是好的，等慢慢地，哪天数据表变得奇大无比，就有可能出现前面提到的<strong>深度分页</strong>问题。</p><h4 id="取出全表数据或下一页连续滚动加载"><a href="#取出全表数据或下一页连续滚动加载" class="headerlink" title="取出全表数据或下一页连续滚动加载"></a>取出全表数据或下一页连续滚动加载</h4><p>可以将所有的数据<strong>根据id主键进行排序</strong>，然后分批次取，将当前批次的最大id作为下次筛选的条件进行查询。</p><p>这种方法的核心思想是<strong>记住上次查询的位置</strong>，而不是通过偏移量来跳过数据。它适用于可以找到一个唯一且有序的列（通常是主键或唯一索引列）作为“书签”的场景。</p><ul><li><strong>原理：</strong> 不使用 <code>OFFSET</code>，而是记录上一页最后一条记录的 ID（或其他有序列的值），然后查询下一页时从这个 ID 之后开始。</li><li><strong>示例：</strong><ul><li>第一页：<code>SELECT * FROM products ORDER BY id ASC LIMIT 10;</code> (假设最后一条记录 id 是 10)</li><li>第二页：<code>SELECT * FROM products WHERE id &gt; 10 ORDER BY id ASC LIMIT 10;</code></li><li>第 N 页：<code>SELECT * FROM products WHERE id &gt; [上一页最大ID] ORDER BY id ASC LIMIT 10;</code></li></ul></li><li><strong>优点：</strong> 无论页码多深，查询效率都非常高，因为它总是从一个已知点开始，进行固定数量的扫描。</li><li><strong>缺点：</strong> 不支持“跳到第 X 页”的需求，只支持“下一页/上一页”或连续滚动加载的场景。</li></ul><h4 id="给用户做分页展示"><a href="#给用户做分页展示" class="headerlink" title="给用户做分页展示"></a>给用户做分页展示</h4><p>优化 <code>LIMIT offset, pageSize</code> 的子查询</p><p>这种方法适用于仍然需要支持“跳到第 X 页”的场景，但尝试减少主查询的回表成本。</p><ul><li><strong>原理：</strong> 先通过一个子查询只查出目标页的<strong>主键 ID</strong>，这通常能利用索引快速完成。然后，再通过这些 ID 回表查询完整的数据。</li><li><strong>示例：</strong> <code>SELECT p.* FROM products p INNER JOIN (SELECT id FROM products ORDER BY id ASC LIMIT 100000, 10) AS sub ON p.id = sub.id;</code></li><li><strong>优点：</strong><ul><li>子查询 <code>(SELECT id FROM products ORDER BY id ASC LIMIT 100000, 10)</code> 只扫描和排序 <code>id</code> 这一列（如果 <code>id</code> 是主键，可以走聚簇索引的索引部分或覆盖索引），这比扫描所有列要快得多。</li><li><code>INNER JOIN</code> 后，回表操作是基于精确的 ID 列表，通常效率较高。</li></ul></li><li><strong>缺点：</strong> 仍然需要扫描和排序 <code>offset + pageSize</code> 个 ID。当 <code>offset</code> 非常大时，子查询本身还是会有性能问题。但在某些情况下，尤其是有覆盖索引支持子查询时，比直接 <code>SELECT * LIMIT OFFSET</code> 要好。</li></ul><p>如果实现翻页需求,类似谷歌搜索时看到的翻页功能,不需要offset过多数据,一般十几页就够了.</p><p>如果要做搜索或筛选类的页面的话，就使用elastic search，并且也需要控制展示的结果数，比如一万以内，这样不至于让分页过深.</p><p>如果因为各种原因，必须使用mysql。那同样，也需要控制下返回结果数量，比如数量1k以内。这样就能勉强支持各种翻页，跳页（比如突然跳到第6页然后再跳到第106页）。</p><p>但如果能从产品的形式上就做成不支持跳页会更好，比如<strong>只支持上一页或下一页</strong>。这样就可以使用上面提到的start_id方式，采用分批获取，每批数据以start_id为起始位置。这个解法最大的好处是不管翻到多少页，查询速度永远稳定</p><ul><li><code>limit offset, size</code> 比 <code>limit size</code> 要慢，且offset的值越大，sql的执行速度越慢。</li><li>当offset过大，会引发<strong>深度分页</strong>问题，目前不管是mysql还是es都没有很好的方法去解决这个问题。只能通过限制查询数量或分批获取的方式进行规避。</li><li>遇到深度分页的问题，多思考其原始需求，大部分时候是不应该出现深度分页的场景的，必要时多去影响产品经理。</li><li>如果数据量很少，比如1k的量级，且长期不太可能有巨大的增长，还是用<code>limit offset, size</code> 的方案吧，整挺好，能用就行。</li></ul><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>根据加锁的范围，可以分为<strong>全局锁、表级锁和行锁</strong>三类。</p><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock</span><br></pre></td></tr></table></figure><p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：</p><ul><li>对数据的增删改操作，比如 insert、delete、update等语句；</li><li>对表结构的更改操作，比如 alter table、drop table 等语句。</li></ul><p>如果要释放全局锁，则要执行这条命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure><p>当会话断开了，全局锁会被自动释放。</p><p>加全局锁主要用在数据备份的时候,使得数据只读,避免备份时的数据不一致性问题.如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。</p><blockquote><p>既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？</p></blockquote><p>有的，如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</p><p>因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。</p><p>备份数据库的工具是 mysqldump，在<strong>使用 mysqldump 时加上 <code>–single-transaction</code> 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。</strong></p><p>InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。</p><p>但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>MySQL 里面表级别的锁有这几种：</p><ul><li>表锁；</li><li>元数据锁（MDL）;</li><li>意向锁；</li><li>AUTO-INC 锁；</li></ul><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lock tables table_name read;</span><br><span class="line">lock tables table_name write;</span><br></pre></td></tr></table></figure><p>read表锁是共享读锁,允许当前会话读取被锁定的表但阻止其他会话对这些表进行写操作.</p><p>write表锁是独占写锁,允许当前会话读写被锁定的表但阻止其他会话对这些表进行任何操作.</p><p>表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p><p>如果在某个线程 A 中执行 <code>lock tables t1 read, t2 write</code>; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。</p><p>当会话退出后，也会释放所有表锁。</p><p>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式，不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，<strong>InnoDB 实现了颗粒度更细的行级锁</strong></p><h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>对数据库表进行操作时，会自动给这个表加上 MDL：</p><ul><li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li><li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li></ul><p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p><p>当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</p><p>反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。</p><p>元数据锁是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p><p>那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：</p><ol><li>首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；</li><li>然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；</li><li>接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</li></ol><p>那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。因为申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p><p>所以为了能安全的对表结构进行变更，<strong>在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更</strong>。</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><ul><li>在使用 InnoDB 引擎的表里对某些记录加上”共享锁”之前，需要先在表级别加上一个「意向共享锁」；</li><li>在使用 InnoDB 引擎的表里对某些纪录加上”独占锁”之前，需要先在表级别加上一个「意向独占锁」；</li></ul><p>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且<strong>意向锁之间也不会发生冲突</strong>，<strong>只会和共享表锁（lock tables … read）和独占表锁（</strong>lock tables … write）发生冲突。</p><p>普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>先在表上加上意向共享锁，然后对读取的记录加共享锁</span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>先表上加上意向独占锁，然后对读取的记录加独占锁</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure><p>表锁和行锁是满足读读共享、读写互斥、写写互斥的。</p><p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p><p>在加上独占表锁时就会检查表上是否有意向独占锁,不用去遍历每个记录是否加行锁.</p><p>意向锁的目的是为了快速判断表里是否有记录被加锁</p><h3 id="AUCO-INC锁"><a href="#AUCO-INC锁" class="headerlink" title="AUCO-INC锁"></a>AUCO-INC锁</h3><p>表里的主键通常都会设置成自增的，这是通过对主键字段声明 <code>AUTO_INCREMENT</code> 属性实现的。</p><p>之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 <strong>AUTO-INC 锁</strong>实现的。</p><p>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p><p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p><p>那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 <code>AUTO_INCREMENT</code> 修饰的字段的值是连续递增的。</p><p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p><blockquote><p>在老版本,自增字段通过表级锁AUTO-INC锁执行插入语句后再释放.</p></blockquote><p>在新版本,<code>AUTO-INC</code> 锁的工作机制在不同版本和模式下有所不同：</p><ol><li>传统模式（<code>innodb_autoinc_lock_mode=0</code>）</li></ol><p>这是最悲观的模式，也是最早的实现方式。</p><ul><li><strong>加锁机制</strong>：在执行 <code>INSERT</code> 语句时，无论是单行插入还是批量插入，都会对<strong>整个表</strong>加一个 <code>AUTO-INC</code> 表锁。</li><li><strong>并发性</strong>：当一个事务持有这个锁时，其他所有试图插入数据的事务都会被阻塞，直到锁被释放。这使得自增值严格连续，但<strong>并发性能非常差</strong>。</li></ul><ol><li>连续模式（<code>innodb_autoinc_lock_mode=1</code>）</li></ol><p>这是MySQL 5.1之后引入的默认模式，旨在提高并发性。</p><ul><li><strong>加锁机制</strong>：<ul><li><strong>对于单行插入</strong>：MySQL只在分配自增值时加一个<strong>轻量级锁</strong>，分配完后立即释放，锁定的时间非常短。</li><li><strong>对于批量插入</strong>：为了保证批量插入的自增值是连续的，MySQL会像传统模式一样加一个<code>AUTO-INC</code>表锁，直到语句执行完毕才释放。</li></ul></li><li><strong>并发性</strong>：这种模式在单行插入时有很高的并发性。对于批量插入，虽然性能有所牺牲，但保证了自增值的连续性。</li></ul><ol><li>交错模式（<code>innodb_autoinc_lock_mode=2</code>）</li></ol><p>这是MySQL 8.0的推荐模式。</p><ul><li><strong>加锁机制</strong>：完全移除了<code>AUTO-INC</code>表锁。所有插入操作都只在分配自增值时加一个轻量级的锁，分配完后立即释放。</li><li><strong>并发性</strong>：并发性能最高，<strong>自增值的生成完全不会阻塞其他事务</strong>。</li><li><strong>问题</strong>：由于不同事务的自增值是交错分配的，<strong>不能保证自增值的连续性</strong>。当一个事务回滚时，其已经分配的自增值会形成“空洞”，永远不会被使用。</li></ul><p>当 innodb_autoinc_lock_mode = 2 是性能最高的方式，但是当搭配 binlog 的日志格式是 statement 一起使用的时候，在「主从复制的场景」中会发生<strong>数据不一致的问题</strong>。</p><p>如果 innodb_autoinc_lock_mode = 2，意味着「申请自增主键后就释放锁，不必等插入语句执行完」。那么就可能出现这样的情况：</p><ul><li>session B 先插入了两个记录，(1,1,1)、(2,2,2)；</li><li>然后，session A 来申请自增 id 得到 id=3，插入了（3,5,5)；</li><li>之后，session B 继续执行，插入两条记录 (4,3,3)、 (5,4,4)。</li></ul><p>可以看到，<strong>session B 的 insert 语句，生成的 id 不连续</strong>。</p><p>当「主库」发生了这种情况，binlog 面对 t2 表的更新只会记录这两个 session 的 insert 语句，如果 binlog_format=statement，记录的语句就是原始语句。记录的顺序要么先记 session A 的 insert 语句，要么先记 session B 的 insert 语句。</p><p>但不论是哪一种，这个 binlog 拿去「从库」执行，这时从库是按「顺序」执行语句的，只有当执行完一条 SQL 语句后，才会执行下一条 SQL。因此，在<strong>从库上「不会」发生像主库那样两个 session 「同时」执行向表 t2 中插入数据的场景。所以，在备库上执行了 session B 的 insert 语句，生成的结果里面，id 都是连续的。这时，主从库就发生了数据不一致</strong>。</p><p>要解决这问题，binlog 日志格式要设置为 row，这样在 binlog 里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，从库的自增值就是什么。</p><p>所以，<strong>当 innodb_autoinc_lock_mode = 2 时，并且 binlog_format = row，既能提升并发性，又不会出现数据一致性问题</strong>。</p><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。</p><p>前面也提到，普通的 select 语句是不会对记录加锁的，因为它属于快照读。如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为<strong>锁定读</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>对读取的记录加共享锁</span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>对读取的记录加独占锁</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure><p>上面这两条语句必须在一个事务中，<strong>因为当事务提交了，锁就会被释放</strong>，所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit = 0</p><p>普通的 select 语句是不会对记录加锁的（除了串行化隔离级别），因为它属于快照读，是通过 MVCC（多版本并发控制）实现的。</p><h4 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h4><p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p><ul><li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li><li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li></ul><p>插入、删除以及更新的DML语句会加互斥锁,select xx for update也会加互斥锁</p><p>而select xx for share会加共享锁.当事务执行 commit 后，事务过程中生成的锁都会被释放</p><h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p>Gap Lock 称为间隙锁，存在于可重复读隔离级别和串行化隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</p><p>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，<strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong>。</p><h4 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h4><p>记录锁 +间隙锁的组合，锁定一个范围，并且锁定记录本身。</p><p>对于记录锁，要考虑 X 型与 S 型关系，X 型的记录锁与 X 型的记录锁是冲突的</p><h4 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h4><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p><p>插入意向锁名字虽然有意向锁，但是它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong>。如果说间隙锁锁住的是一个区间，那么<strong>插入意向锁</strong>锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。</p><p>插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。</p><h2 id="Mysql如何加行级锁"><a href="#Mysql如何加行级锁" class="headerlink" title="Mysql如何加行级锁"></a>Mysql如何加行级锁</h2><p>行级锁加锁规则比较复杂，不同的场景，加锁的形式是不同的。</p><p><strong>加锁的对象是索引，加锁的基本单位是 next-key lock</strong>，它是由记录锁和间隙锁组合而成的，<strong>next-key lock 是前开后闭区间，而间隙锁是前开后开区间</strong>。</p><p>但是，next-key lock 在一些场景下会退化成记录锁或间隙锁。<strong>在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成记录锁或间隙锁</strong>。</p><h3 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="headerlink" title="唯一索引等值查询"></a>唯一索引等值查询</h3><p>当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：</p><ul><li>当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会<strong>退化成「记录锁」</strong>。</li><li>当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会<strong>退化成「间隙锁」</strong></li></ul><p>如果是用二级索引（不管是不是非唯一索引，还是唯一索引）进行锁定读查询的时候，除了会对二级索引项加行级锁（如果是唯一索引的二级索引，加锁规则和主键索引的案例相同），而且还会对查询到的记录的主键索引项上加「记录锁」</p><p>可以通过 <code>select * from performance_schema.data_locks\G;</code> 这条语句，查看事务执行 SQL 过程中加了什么锁.<strong>加锁的对象是针对索引</strong>，因为这里查询语句扫描的 B+ 树是聚簇索引树，即主键索引树，所以是对主键索引加锁。将对应记录的主键索引加记录锁后，就意味着其他事务无法对该记录进行更新和删除操作了。</p><h3 id="唯一索引范围查询"><a href="#唯一索引范围查询" class="headerlink" title="唯一索引范围查询"></a>唯一索引范围查询</h3><p>当唯一索引进行范围查询时，<strong>会对每一个扫描到的索引加 next-key 锁，然后如果遇到下面这些情况，会退化成记录锁或者间隙锁</strong>：</p><ul><li>情况一：针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 next-key 锁会<strong>退化成记录锁</strong>。</li><li>情况二：针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中：<ul><li>当条件值的记录不在表中，那么不管是「小于」还是「小于等于」条件的范围查询，<strong>扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁</strong>，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。</li><li>当条件值的记录在表中，如果是「小于」条件的范围查询，<strong>扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁</strong>，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；如果「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。</li></ul></li></ul><h3 id="非唯一索引等值查询"><a href="#非唯一索引等值查询" class="headerlink" title="非唯一索引等值查询"></a>非唯一索引等值查询</h3><p>当我们用非唯一索引进行等值查询的时候，<strong>因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以在加锁时，同时会对这两个索引都加锁，但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁</strong>。</p><p>针对非唯一索引等值查询时，查询的记录存不存在，加锁的规则也会不同：</p><ul><li>当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是<strong>非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁</strong>。</li><li>当查询的记录「不存在」时，<strong>扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁</strong>。</li></ul><h3 id="非唯一索引范围查询"><a href="#非唯一索引范围查询" class="headerlink" title="非唯一索引范围查询"></a>非唯一索引范围查询</h3><p><strong>非唯一索引范围查询，索引的 next-key lock 不会有退化为间隙锁和记录锁的情况</strong>，也就是非唯一索引进行范围查询时，对二级索引记录加锁都是加 next-key 锁。</p><h4 id="没有使用索引的加锁"><a href="#没有使用索引的加锁" class="headerlink" title="没有使用索引的加锁"></a>没有使用索引的加锁</h4><p><strong>如果锁定读查询语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞</strong>。</p><p>不只是锁定读查询语句不加索引才会导致这种情况，update 和 delete 语句如果查询条件不加索引，那么由于扫描的方式是全表扫描，于是就会对每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表。</p><p>因此，<strong>在线上在执行 update、delete、select … for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了</strong>，这是挺严重的问题</p><p>InnoDB 存储引擎的默认事务隔离级别是「可重复读」，但是在这个隔离级别下，在多个事务并发的时候，会出现幻读的问题，所谓的幻读是指在同一事务下，连续执行两次同样的查询语句，第二次的查询语句可能会返回之前不存在的行。</p><p>因此 InnoDB 存储引擎自己实现了行锁，通过 next-key 锁（记录锁和间隙锁的组合）来锁住记录本身和记录之间的“间隙”，防止其他事务在这个记录之间插入新的记录，从而避免了幻读现象。当我们执行 update 语句时，实际上是会对记录加独占锁（X 锁）的，如果其他事务对持有独占锁的记录进行修改时是会被阻塞的。另外，这个锁并不是执行完 update 语句就会释放的，而是会等事务结束时才会释放。</p><p>在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁。加锁的位置准确的说，锁是加在索引上的而非行上。</p><p>在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁。加锁的位置准确的说，锁是加在索引上的而非行上。</p><p>比如，在 update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁，也就是只会给一行记录加锁。</p><p>因为事务 A的 update 语句中 where 条件没有索引列，触发了全表扫描，在扫描过程中会对索引加锁，所以全表扫描的场景下，所有记录都会被加锁，也就是这条 update 语句产生了 4 个记录锁和 5 个间隙锁，相当于锁住了全表。<strong>在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了</strong>。</p><p>可以设置sql_safe_updates=1,update 语句必须满足如下条件之一才能执行成功：</p><ul><li>使用 where，并且 where 条件中必须有索引列；</li><li>使用 limit；</li><li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li></ul><p>delete 语句必须满足以下条件能执行成功：</p><ul><li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li></ul><p>如果 where 条件带上了索引列，但是优化器最终扫描选择的是全表，而不是索引的话，我们可以<strong>使用 <code>force index([index_name])</code> 可以告诉优化器使用哪个索引</strong>，以此避免有几率锁全表带来的隐患。</p><h3 id="Mysql发生死锁"><a href="#Mysql发生死锁" class="headerlink" title="Mysql发生死锁"></a>Mysql发生死锁</h3><p>I<strong>nnodb 引擎为了解决「可重复读」隔离级别下的幻读问题，就引出了 next-key 锁</strong>，它是记录锁和间隙锁的组合。</p><ul><li>Record Lock，记录锁，锁的是记录本身；</li><li>Gap Lock，间隙锁，锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。</li></ul><p>死锁的四个必要条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。</p><p>在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：</p><ul><li><p><strong>设置事务等待锁的超时时间</strong>。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 <code>innodb_lock_wait_timeout</code> 是用来设置超时时间的，默认值时 50 秒。</p><p>当发生超时后，就出现下面这个提示：</p></li></ul><p><img data-src="https://cdn.xiaolincoding.com//mysql/other/c296c1889f0101d335699311b4ef20a8.png" alt="图片"></p><ul><li><p><strong>开启主动死锁检测</strong>。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑，默认就开启。</p><p>当检测到死锁后，就会出现下面这个提示：</p></li></ul><p><img data-src="https://cdn.xiaolincoding.com//mysql/other/f380ef357d065498d8d54ad07f145e09.png" alt="图片"></p><p>上面这个两种策略是「当有死锁发生时」的避免方式。</p><p>我们可以回归业务的角度来预防死锁，对订单做幂等性校验的目的是为了保证不会出现重复的订单，那我们可以直接将 order_no 字段设置为唯一索引列，利用它的唯一性来保证订单表不会出现重复的订单，不过有一点不好的地方就是在我们插入一个已经存在的订单记录时就会抛出异常。</p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p> MySQL 的数据是存储在磁盘里的，但是也不能每次都从磁盘里面读取数据，这样性能是极差的。要想提升查询性能，加个缓存就行了嘛。所以，当数据从磁盘中取出后，缓存内存中，下次查询同样的数据的时候，直接从内存中读取。</p><p>为此，Innodb 存储引擎设计了一个<strong>缓冲池（*Buffer Pool*）</strong>，来提高数据库的读写性能。</p><p>innodb引擎使用了Buffer Pool提升读取和修改效率.有了缓冲池后：</p><ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li><li>当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。</li></ul><p>InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。</p><p>在 MySQL 启动的时候，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的<code>16KB</code>的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页</strong>。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。</p><p>所以，MySQL 刚启动的时候，你会观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小，这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，接着将虚拟地址和物理地址建立映射关系。</p><p>Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 undo 页，change buffer缓存、自适应哈希索引、锁信息等等。</p><p>为了更好的管理这些在 Buffer Pool 中的缓存页，InnoDB 为每一个缓存页都创建了一个<strong>控制块</strong>，控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等。</p><p><strong>控制块也是占有内存空间的，它是放在 Buffer Pool 的最前面</strong>，接着才是缓存页. </p><h3 id="管理空闲页"><a href="#管理空闲页" class="headerlink" title="管理空闲页"></a>管理空闲页</h3><p>Buffer Pool 是一片连续的内存空间，当 MySQL 运行一段时间后，这片连续的内存空间中的缓存页既有空闲的，也有被使用的。为了避免遍历整个buffer pool,为了快速找到空闲的缓存页，可以使用链表结构，将空闲缓存页的「控制块」作为链表的节点，这个链表称为 <strong>Free 链表</strong>（空闲链表）</p><p>Free 链表上除了有控制块，还有一个头节点，该头节点包含链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息。</p><p>Free 链表节点是一个一个的控制块，而每个控制块包含着对应缓存页的地址，<strong>所以相当于 Free 链表节点都对应一个空闲的缓存页</strong>。</p><p>有了 Free 链表后，每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除。</p><h3 id="管理脏页"><a href="#管理脏页" class="headerlink" title="管理脏页"></a>管理脏页</h3><p>设计 Buffer Pool 除了能提高读性能，还能提高写性能，也就是<strong>更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页</strong>标记为<strong>脏页</strong>，然后再由后台线程将脏页写入到磁盘。</p><p>那为了能快速知道哪些缓存页是脏的，于是就设计出 <strong>Flush 链表</strong>，它跟 Free 链表类似的，链表的节点也是控制块，区别在于 Flush 链表的元素都是脏页。有了 Flush 链表后，后台线程就可以遍历 Flush 链表，将脏页写入到磁盘。</p><h3 id="LRU链表提高缓冲命中率"><a href="#LRU链表提高缓冲命中率" class="headerlink" title="LRU链表提高缓冲命中率"></a>LRU链表提高缓冲命中率</h3><p>Buffer Pool 的大小是有限的，对于一些频繁访问的数据我们希望可以一直留在 Buffer Pool 中，而一些很少访问的数据希望可以在某些时机可以淘汰掉，从而保证 Buffer Pool 不会因为满了而导致无法再缓存新的数据，同时还能保证常用数据留在 Buffer Pool 中。</p><p>要实现这个，最容易想到的就是 LRU（Least recently used）算法。</p><p>该算法的思路是，<strong>链表头部的节点是最近使用的，而链表末尾的节点是最久没被使用的。那么，当空间不够了，就淘汰最久没被使用的节点</strong>，从而腾出空间。</p><p>简单的 LRU 算法的实现思路是这样的：</p><ul><li>当访问的页在 Buffer Pool 里，就直接把该页对应的 LRU 链表节点移动到链表的头部。</li><li>当访问的页不在 Buffer Pool 里，除了要把页放入到 LRU 链表的头部，还要淘汰 LRU 链表末尾的节点。</li></ul><p>Buffer Pool 里有三种页和链表来管理数据。</p><ul><li>Free Page（空闲页），表示此页未被使用，位于 Free 链表；</li><li>Clean Page（干净页），表示此页已被使用，但是页面未发生修改，位于LRU 链表。</li><li>Dirty Page（脏页），表示此页「已被使用」且「已经被修改」，其数据和磁盘上的数据已经不一致。当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了干净页。脏页同时存在于 LRU 链表和 Flush 链表。</li></ul><h4 id="普通LRU链表缺点"><a href="#普通LRU链表缺点" class="headerlink" title="普通LRU链表缺点"></a>普通LRU链表缺点</h4><ul><li>预读失效；</li></ul><p>程序是有空间局部性的，靠近当前被访问数据的数据，在未来很大概率会被访问到。</p><p>所以，MySQL 在加载数据页时，会提前把它相邻的数据页一并加载进来，目的是为了减少磁盘 IO。但是可能这些<strong>被提前加载进来的数据页，并没有被访问</strong>，相当于这个预读是白做了，这个就是<strong>预读失效</strong>。如果使用简单的 LRU 算法，就会把预读页放到 LRU 链表头部，而当 Buffer Pool空间不够的时候，还需要把末尾的页淘汰掉。</p><p>如果这些预读页如果一直不会被访问到，就会出现一个很奇怪的问题，不会被访问的预读页</p><p>要避免预读失效带来影响，最好就是<strong>让预读的页停留在 Buffer Pool 里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在 Buffer Pool 里的时间尽可能长</strong>。</p><p>MySQL 改进了 LRU 算法，将 LRU 划分了 2 个区域<strong>：</strong>old 区域 和 young 区域<strong>。young 区域在 LRU 链表的前半部分，old 区域则是在后半部分.old 区域占整个 LRU 链表长度的比例可以通过 <code>innodb_old_blocks_pct</code> 参数来设置，默认是 37.</strong>划分这两个区域后，<strong>预读的页就只需要加入到 old 区域的头部</strong>，当页被真正访问的时候，才将页插入 young 区域的头部。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。</p><ul><li>Buffer Pool 污染；</li></ul><p>当某一个 SQL 语句<strong>扫描了大量的数据</strong>时，在 Buffer Pool 空间比较有限的情况下，可能会将 <strong>Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了</strong>，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 <strong>Buffer Pool 污染</strong>。</p><p>注意， Buffer Pool 污染并不只是查询语句查询出了大量的数据才出现的问题，即使查询出来的结果集很小，也会造成 Buffer Pool 污染。</p><p>在一个数据量非常大的表，执行了这条语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> name <span class="keyword">like</span> &quot;%xiaolin%&quot;;</span><br></pre></td></tr></table></figure><p>可能这个查询出来的结果就几条记录，但是由于这条语句会发生索引失效，所以这个查询过程是全表扫描的，接着会发生如下的过程：</p><ul><li>从磁盘读到的页加入到 LRU 链表的 old 区域头部；</li><li>当从页里读取行记录时，也就是页被访问的时候，就要将该页放到 young 区域头部；</li><li>接下来拿行记录的 name 字段和字符串 xiaolin 进行模糊匹配，如果符合条件，就加入到结果集里；</li><li>如此往复，直到扫描完表中的所有记录。</li></ul><p>经过这一番折腾，原本 young 区域的热点数据都会被替换掉。</p><p>像前面这种全表扫描的查询，很多缓冲页其实只会被访问一次，但是它却只因为被访问了一次而进入到 young 区域，从而导致热点数据被替换了。</p><p>LRU 链表中 young 区域就是热点数据，只要我们提高进入到 young 区域的门槛，就能有效地保证 young 区域里的热点数据不会被替换掉。</p><p>MySQL 是这样做的，进入到 young 区域条件增加了一个<strong>停留在 old 区域的时间判断</strong>。</p><p>具体是这样做的，在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：</p><ul><li>如果后续的访问时间与第一次访问的时间<strong>在某个时间间隔内</strong>，那么<strong>该缓存页就不会被从 old 区域移动到 young 区域的头部</strong>；</li><li>如果后续的访问时间与第一次访问的时间<strong>不在某个时间间隔内</strong>，那么<strong>该缓存页移动到 young 区域的头部</strong>；</li></ul><p>这个间隔时间是由 <code>innodb_old_blocks_time</code> 控制的，默认是 1000 ms。</p><p>也就说，<strong>只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部</strong>，这样就解决了 Buffer Pool 污染的问题 。</p><p>另外，MySQL 针对 young 区域其实做了一个优化，<strong>为了防止 young 区域节点频繁移动到头部。young 区域前面 1/4 被访问不会移动到链表头部，只有后面的 3/4被访问了才会</strong></p><p>也就是说上面全索引读取到的数据页放在old区后,对页中的数据进行访问的时候,</p><h3 id="脏页刷盘时机"><a href="#脏页刷盘时机" class="headerlink" title="脏页刷盘时机"></a>脏页刷盘时机</h3><p>引入了 Buffer Pool 后，当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，但是磁盘中还是原数据。</p><p>因此，脏页需要被刷入磁盘，保证缓存和磁盘数据一致，但是若每次修改数据都刷入磁盘，则性能会很差，因此一般都会在一定时机进行批量刷盘。</p><p>可能大家担心，如果在脏页还没有来得及刷入到磁盘时，MySQL 宕机了，不就丢失数据了吗？</p><p>这个不用担心，InnoDB 的更新操作采用的是 Write Ahead Log 策略，即先写日志，再写入磁盘，通过 redo log 日志让 MySQL 拥有了崩溃恢复能力。</p><p>下面几种情况会触发脏页的刷新：</p><ul><li>当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；</li><li>Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；</li><li>MySQL 认为空闲时，后台线程会定期将适量的脏页刷入到磁盘；</li><li>MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；</li></ul><p>在我们开启了慢 SQL 监控后，如果你发现<strong>「偶尔」会出现一些用时稍长的 SQL</strong>，这可能是因为脏页在刷新到磁盘时可能会给数据库带来性能开销，导致数据库操作抖动。</p><p>如果间断出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小</p><p>Innodb 存储引擎设计了一个<strong>缓冲池（*Buffer Pool*）</strong>，来提高数据库的读写性能。</p><p>Buffer Pool 以页为单位缓冲数据，可以通过 <code>innodb_buffer_pool_size</code> 参数调整缓冲池的大小，默认是 128 M。</p><p>Innodb 通过三种链表来管理缓页：</p><ul><li>Free List （空闲页链表），管理空闲页；</li><li>Flush List （脏页链表），管理脏页；</li><li>LRU List，管理脏页+干净页，将最近且经常查询的数据缓存在其中，而不常查询的数据就淘汰出去。；</li></ul><p>InnoDB 对 LRU 做了一些优化，我们熟悉的 LRU 算法通常是将最近查询的数据放到 LRU 链表的头部，而 InnoDB 做 2 点优化：</p><ul><li>将 LRU 链表 分为<strong>young 和 old 两个区域</strong>，加入缓冲池的页，优先插入 old 区域；页被访问时，才进入 young 区域，目的是为了解决预读失效的问题。</li><li>当<strong>「页被访问」且「 old 区域停留时间超过 <code>innodb_old_blocks_time</code> 阈值（默认为1秒）」</strong>时，才会将页插入到 young 区域，否则还是插入到 old 区域，目的是为了解决批量数据访问，大量热数据淘汰的问题。</li></ul><p>可以通过调整 <code>innodb_old_blocks_pct</code> 参数，设置 young 区域和 old 区域比例。</p><p>在开启了慢 SQL 监控后，如果你发现「偶尔」会出现一些用时稍长的 SQL，这可<strong>因为脏页在刷新到磁盘时导致数据库性能抖动。如果在很短的时间出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小</strong>。</p><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="删除表中部分数据为什么文件没有减小以及表重建"><a href="#删除表中部分数据为什么文件没有减小以及表重建" class="headerlink" title="删除表中部分数据为什么文件没有减小以及表重建"></a>删除表中部分数据为什么文件没有减小以及表重建</h2><ol><li>共享表空间模式（<code>ibdata1</code>）</li></ol><p>如果你使用的是<strong>共享表空间模式</strong>（即 <code>innodb_file_per_table = OFF</code>），那么所有 InnoDB 表的数据、索引以及系统元数据都存放在一个或少数几个名为 <code>ibdataX</code> 的文件中。</p><ul><li><strong>工作原理</strong>：当你删除表或数据时，这些空间并不会被立即释放。它们会被标记为“可重用”，并留在 <code>ibdata1</code> 文件内部。</li><li><strong>为什么不缩小</strong>：<code>ibdata1</code> 文件只会不断增大，而不会自动收缩。这是为了避免频繁的系统调用和 I/O 开销，因为收缩文件是一个复杂且昂贵的操作。</li><li><strong>如何回收空间</strong>：要回收这部分空间，你需要执行一个非常繁琐的操作：<ol><li>备份所有数据库。</li><li>删除所有数据文件（包括 <code>ibdata*</code> 文件）。</li><li>重启 MySQL，让它重新创建新的、干净的 <code>ibdata1</code> 文件。</li><li>恢复所有备份</li></ol></li></ul><hr><p>当你删除数据库中的表时，如果发现数据库文件大小没有变化，这通常是因为 MySQL 的存储引擎（尤其是 <strong>InnoDB</strong>）没有立即将释放的空间归还给操作系统。</p><ol><li>共享表空间模式（<code>ibdata1</code>）</li></ol><p>如果你使用的是<strong>共享表空间模式</strong>（即 <code>innodb_file_per_table = OFF</code>），那么所有 InnoDB 表的数据、索引以及系统元数据都存放在一个或少数几个名为 <code>ibdataX</code> 的文件中。</p><ul><li><strong>工作原理</strong>：当你删除表或数据时，这些空间并不会被立即释放。它们会被标记为“可重用”，并留在 <code>ibdata1</code> 文件内部。</li><li><strong>为什么不缩小</strong>：<code>ibdata1</code> 文件只会不断增大，而不会自动收缩。这是为了避免频繁的系统调用和 I/O 开销，因为收缩文件是一个复杂且昂贵的操作。</li><li><strong>如何回收空间</strong>：要回收这部分空间，你需要执行一个非常繁琐的操作：<ol><li>备份所有数据库。</li><li>删除所有数据文件（包括 <code>ibdata*</code> 文件）。</li><li>重启 MySQL，让它重新创建新的、干净的 <code>ibdata1</code> 文件。</li><li>恢复所有备份。</li></ol></li></ul><ol><li>独占表空间模式（<code>.ibd</code>）</li></ol><p>如果你使用的是<strong>独占表空间模式</strong>（即 <code>innodb_file_per_table = ON</code>），那么每个 InnoDB 表都有一个独立的 <code>.ibd</code> 文件。</p><ul><li><p><strong>工作原理</strong>：当你删除一张表时，MySQL 会<strong>直接删除</strong>对应的 <code>.ibd</code> 文件。这种情况下，磁盘空间会立即被操作系统回收。</p></li><li><p><strong>为什么有时也不缩小</strong>：</p><ul><li><p><strong>碎片化</strong>：如果你只是删除了表中的部分数据（例如 <code>DELETE FROM table;</code>），而没有删除表本身，那么这些空间同样会被标记为“可重用”。虽然这些空间位于独立的 <code>.ibd</code> 文件中，但文件本身并不会自动缩小。</p></li><li><p><strong>如何回收空间</strong>：在这种情况下，你需要对表进行<strong>重建（Rebuilding）</strong>，才能真正回收空间。你可以使用以下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> your_table_name ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE <span class="keyword">TABLE</span> your_table_name;</span><br></pre></td></tr></table></figure><p>这些命令会重新整理表数据，清除碎片，从而减小 <code>.ibd</code> 文件的大小。</p></li></ul></li></ul><p>数据库文件大小没有变化，最常见的原因是文件<strong>碎片化</strong>。</p><ul><li>如果你使用的是<strong>共享表空间</strong>，那么即使删除了表，空间也无法自动回收。这是该模式最大的缺点。</li><li>如果你使用的是<strong>独占表空间</strong>，那么删除表文件本身会回收空间。但如果你只是删除了数据，则需要<strong>重建表</strong>才能回收碎片化空间。</li></ul><hr><p>表重建（Table Rebuilding）是一种数据库操作，指的是通过<strong>重新创建一张新的表</strong>来替换原有的表，以达到优化存储结构、回收空间和提升性能的目的。</p><h3 id="为什么需要表重建？"><a href="#为什么需要表重建？" class="headerlink" title="为什么需要表重建？"></a>为什么需要表重建？</h3><p>在数据库的日常操作中，尤其是对于 InnoDB 存储引擎，随着时间的推移，表数据会因为频繁的增删改（<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>）操作而产生<strong>碎片（Fragmentation）</strong>。</p><ul><li><strong>删除操作</strong>：当你删除一行数据时，它占据的空间并不会立即被操作系统回收，而是被标记为“可重用”。这些“洞”散布在数据文件中。</li><li><strong>更新操作</strong>：当 <code>UPDATE</code> 导致数据行变长时，新数据可能无法存放在原来的位置，需要移动到新的位置，并在原位置留下碎片。</li></ul><p>这种碎片化会导致：</p><ol><li><strong>磁盘空间浪费</strong>：被标记为可重用的空间无法被操作系统回收，导致数据文件持续增大。</li><li><strong>I/O 效率降低</strong>：数据不再是连续存储，查询时需要更多的磁盘 I/O 操作来获取数据，影响查询性能。</li></ol><p>表重建的本质是一个“<strong>先复制，后替换</strong>”的过程。它通常包含以下步骤：</p><ol><li><strong>创建新表</strong>：在后台创建一个新的、结构相同的空表。</li><li><strong>复制数据</strong>：将旧表中的数据以连续、紧凑的方式复制到新表中。在这个过程中，所有碎片都会被清除。<br><strong>Copy data</strong>: Copy data from an old table to a new table in a continuous, compact manner. In this process, all debris is removed.</li><li><strong>重新构建索引</strong>：在新表中，所有索引都会被重新构建，同样是连续、紧凑的。</li><li><strong>原子替换</strong>：用一个原子的操作（例如，通过 <code>RENAME TABLE</code>），将旧表和新表进行互换。新表接管旧表的名称和所有权，旧表被删除。</li></ol><p>这个过程会暂时占用额外的磁盘空间，因为新旧两份表的数据会同时存在。</p><h3 id="如何进行表重建？"><a href="#如何进行表重建？" class="headerlink" title="如何进行表重建？"></a>如何进行表重建？</h3><p>在 MySQL 中，进行表重建有几种常见的方法：</p><ol><li><code>OPTIMIZE TABLE</code></li></ol><p>这是最简单、最直接的表重建方式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE <span class="keyword">TABLE</span> your_table_name;</span><br></pre></td></tr></table></figure><ul><li><strong>工作原理</strong>：对于 InnoDB 引擎，<code>OPTIMIZE TABLE</code> 实际上就是执行了一次表重建操作。它会重新整理数据，回收碎片空间。</li><li><strong>缺点</strong>：在执行期间，表会被<strong>锁定</strong>，导致无法进行写操作（<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>），在高并发场景下会影响业务。</li></ul><ol><li><code>ALTER TABLE</code></li></ol><p><code>ALTER TABLE</code> 语句也可以用来触发表重建，通常会与 <code>ENGINE=InnoDB</code> 结合使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> your_table_name ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><ul><li><strong>工作原理</strong>：即使你没有修改表的存储引擎，执行这条命令也会强制 MySQL 以新的、紧凑的格式重新创建表，达到表重建的目的。</li><li><strong>缺点</strong>：同样会锁定表，影响并发。</li></ul><ol><li>在线表重建（Online DDL）</li></ol><p>从 MySQL 5.6 开始，InnoDB 引入了<strong>在线 DDL（Online DDL）</strong> 功能，这是一种<strong>不锁定表、不影响读写操作的表重建方式</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> your_table_name ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><ul><li><strong>工作原理</strong>：MySQL 会在后台创建一个临时表并复制数据。在这个过程中，它会记录所有对旧表的修改，并在复制完成后，将这些修改应用到新表上，最后原子性地进行表替换。整个过程几乎不会中断业务。</li><li><strong>优点</strong>：<strong>不阻塞</strong>表的读写操作，对高并发业务友好。</li><li><strong>缺点</strong>：这个过程会消耗额外的 CPU 和 I/O 资源，并且可能会在表替换的瞬间有短暂的锁等待。</li></ul><h2 id="长事务问题以及如何查询长事务"><a href="#长事务问题以及如何查询长事务" class="headerlink" title="长事务问题以及如何查询长事务"></a>长事务问题以及如何查询长事务</h2><p>长事务是指那些持续时间较长、长时间未提交的事务。它们通常被认为是数据库性能的“杀手”，因为它会占用大量资源，影响系统的稳定性和并发能力。</p><p>长事务引发的问题</p><ol><li><strong>资源占用与阻塞</strong>：长事务在执行期间会持有锁资源，这会阻塞其他需要访问相同数据或资源的事务，导致大量锁等待。如果一个长事务占用的锁是关键资源，整个数据库的吞吐量都会急剧下降。</li><li><strong>Undo Log 空间膨胀</strong>：事务在修改数据时，会将旧数据版本写入 <strong>Undo Log</strong>。Undo Log 的空间只有在事务提交后才能被清理。长事务会长时间占用 Undo Log，导致 Undo Log 文件持续增大，占用大量的磁盘空间。</li><li><strong>影响 MVCC 性能</strong>：长事务会长时间持有 <strong>Read View</strong>。其他事务在进行快照读（Snapshot Read）时，如果需要读取早于该长事务开启时的数据，就需要沿着 Undo Log 的版本链进行回溯，这会增加大量的 I/O 开销和 CPU 消耗。</li><li><p><strong>死锁风险增加</strong>：长事务由于持有锁的时间长，与其他事务发生循环等待的几率也会增加，从而导致死锁。</p></li><li><p>使用 <code>information_schema</code> 数据库</p></li></ol><p><code>information_schema</code> 提供了关于数据库服务器的元数据信息，我们可以通过查询其中的 <code>innodb_trx</code> 表来获取当前所有正在运行的事务信息。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    trx_id,</span><br><span class="line">    trx_state,</span><br><span class="line">    trx_started,</span><br><span class="line">    trx_mysql_thread_id,</span><br><span class="line">    trx_query,</span><br><span class="line">    trx_operation_state,</span><br><span class="line">    (UNIX_TIMESTAMP() - UNIX_TIMESTAMP(trx_started)) <span class="keyword">AS</span> trx_running_time</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    information_schema.innodb_trx</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    trx_state = <span class="string">&#x27;RUNNING&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    trx_running_time <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><ul><li><strong><code>trx_id</code></strong>: 事务的唯一ID。</li><li><strong><code>trx_started</code></strong>: 事务开始的时间。</li><li><strong><code>trx_mysql_thread_id</code></strong>: 事务所在的 MySQL 线程ID，可以配合 <code>SHOW PROCESSLIST</code> 使用。</li><li><strong><code>trx_query</code></strong>: 事务正在执行的 SQL 语句。</li><li><strong><code>trx_running_time</code></strong>: 事务已经运行的时长（秒），这是判断长事务的关键指标。</li></ul><p><strong>使用 <code>performance_schema</code> 数据库</strong></p><p><code>performance_schema</code> 提供了更详细和实时的性能数据，包括事务和会话信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    t.thread_id,</span><br><span class="line">    t.processlist_id,</span><br><span class="line">    t.processlist_user,</span><br><span class="line">    t.processlist_host,</span><br><span class="line">    t.processlist_db,</span><br><span class="line">    p.event_name <span class="keyword">AS</span> lock_type,</span><br><span class="line">    p.duration <span class="keyword">AS</span> lock_duration</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    performance_schema.events_transactions_current t</span><br><span class="line"><span class="keyword">JOIN</span></span><br><span class="line">    performance_schema.events_waits_current p</span><br><span class="line">    <span class="keyword">ON</span> t.thread_id <span class="operator">=</span> p.thread_id</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    t.state <span class="operator">=</span> <span class="string">&#x27;ACTIVE&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    lock_duration <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><ul><li><strong><code>events_transactions_current</code></strong>: 提供当前活跃事务的信息。</li><li><strong><code>events_waits_current</code></strong>: 提供线程正在等待的事件（例如锁等待）信息，可以帮助你定位长事务的原因。</li></ul><ol><li>使用 <code>SHOW PROCESSLIST</code> 命令</li></ol><p><code>SHOW PROCESSLIST</code> 可以快速查看所有正在运行的线程，这对于识别长事务非常有帮助。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">FULL</span> PROCESSLIST;</span><br></pre></td></tr></table></figure><ul><li><strong><code>ID</code></strong>: 线程ID，对应 <code>innodb_trx</code> 表中的 <code>trx_mysql_thread_id</code>。</li><li><strong><code>Time</code></strong>: 线程状态持续的时间（秒），如果这个值很大，可能是一个长事务。</li><li><strong><code>State</code></strong>: 线程的当前状态，例如 <code>Locked</code>、<code>Waiting for table metadata lock</code> 等状态可能表明有长事务在阻塞其他操作。</li><li><strong><code>Info</code></strong>: 线程正在执行的 SQL 语句。</li></ul><h2 id="双写缓冲与change-buffer"><a href="#双写缓冲与change-buffer" class="headerlink" title="双写缓冲与change buffer"></a>双写缓冲与change buffer</h2><p><strong>核心目的</strong>：保证数据页的<strong>原子性写入</strong>，解决<strong>部分写失败</strong>（Partial Write Failure）问题。</p><p>在 InnoDB 中，数据最终是存储在磁盘的数据文件中的。一个数据页（通常为 16KB）写入磁盘不是一个原子操作，而是分多次进行的。如果在写入过程中，比如只写了 4KB，而数据库突然崩溃（如断电），就会导致数据页损坏。</p><p>双写缓冲机制就是为了防止这种情况：</p><ol><li><strong>第一次写</strong>：当 InnoDB 准备将脏页（Dirty Page，内存中被修改的数据页）刷新到磁盘时，它不会直接写入数据文件，而是先写入到<strong>双写缓冲区</strong>。这个缓冲区是一个位于系统表空间 <code>ibdata1</code> 中的连续存储区域。</li><li><strong>第二次写</strong>：双写缓冲区中的数据被一次性地刷新到磁盘。</li><li><strong>最终写</strong>：如果双写缓冲区中的数据写入成功，InnoDB 才会将脏页真正写入到数据文件的正确位置。</li></ol><p><strong>崩溃恢复</strong></p><p>如果数据库在写入过程中崩溃，InnoDB 会进行以下恢复操作：</p><ul><li><strong>如果最终写失败</strong>：数据库重启后，会检查双写缓冲区中的数据和数据文件中的数据。如果发现数据文件中的数据页损坏，它会从双写缓冲区中找到完整的数据页副本，将其恢复到数据文件中。</li><li><strong>如果第一次写失败</strong>：双写缓冲区中的数据也未写入，不会影响数据文件。</li></ul><p>双写缓冲牺牲了一些性能（多了一次写操作），但极大地增强了数据页写入的<strong>可靠性</strong>。</p><p><strong>Change Buffer（变更缓冲）</strong></p><p><strong>核心目的</strong>：提高数据库的<strong>写入性能</strong>，尤其是针对<strong>非唯一二级索引</strong>的插入、更新和删除操作。</p><p>当对一个表进行 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 操作时，如果涉及修改非唯一二级索引，InnoDB 的默认行为是：</p><ol><li>修改内存中的数据页。</li><li>修改内存中的非唯一二级索引页。</li><li>将这两个脏页异步刷新到磁盘。</li></ol><p>但如果非唯一二级索引页<strong>不在内存中</strong>，InnoDB 必须先从磁盘将索引页加载到内存，然后再进行修改。这个过程会产生大量的<strong>随机 I/O</strong>，极大地影响性能。</p><p>Change Buffer 的作用就是：</p><ol><li>当<strong>需要修改的非唯一二级索引页不在内存中时，InnoDB 不会立即去磁盘加载，而是将这个“变更操作”记录到 Change Buffer </strong>中**。</li><li>Change Buffer 中的数据会在后台（或在数据库关闭时）被<strong>合并（Merge）</strong>到真正的索引页中。</li></ol><p>Change Buffer 中的内容是持久化的。数据库重启后，InnoDB 会执行<strong>恢复</strong>操作，将 Change Buffer 中的变更应用到磁盘上的索引页。</p><p>Change Buffer 主要适用于<strong>写多读少</strong>的业务场景，比如日志系统、电商秒杀系统等。因为这些场景下，非唯一二级索引的写入操作远多于读取。</p><p><strong>注意</strong>：</p><ul><li>Change Buffer 只对<strong>非唯一二级索引</strong>有效。对于主键索引和唯一二级索引，由于需要检查唯一性，InnoDB 必须立即将对应的索引页加载到内存中，无法使用 Change Buffer。</li><li>Change Buffer 在<strong>读多写少</strong>的场景下可能适得其反，因为大量的读取操作会频繁触发 Change Buffer 的合并操作，反而增加了开销。</li></ul><h2 id="临时表与sort-buffer"><a href="#临时表与sort-buffer" class="headerlink" title="临时表与sort buffer"></a>临时表与sort buffer</h2><p>MySQL 优化器在执行某些复杂查询时，为了提高效率，会在内部自动创建和管理临时表。</p><p><strong>触发条件</strong>：</p><ul><li><strong><code>GROUP BY</code> 或 <code>ORDER BY</code></strong>：当这些操作的列无法被索引覆盖时。</li><li><strong><code>UNION</code></strong>：在执行 <code>UNION</code> 操作时。</li><li><strong>子查询</strong>：在处理某些复杂的子查询时。</li><li><strong><code>DISTINCT</code></strong>：在对大量数据进行去重时。</li></ul><p><strong>性能开销</strong>：临时表会占用磁盘空间和内存。如果临时表数据量非常大，可能会导致 I/O 频繁，影响性能。</p><p><strong>内存 vs. 磁盘</strong>：MySQL 会优先在内存中（<code>tmp_table_size</code> 和 <code>max_heap_table_size</code> 变量控制）创建内部临时表。如果数据量超过阈值，它会自动转换为磁盘上的 InnoDB 或 MyISAM 表，这会带来额外的 I/O 开销。</p><p><strong><code>innodb_temp_data_file_path</code></strong>：在 InnoDB 存储引擎中，所有的用户创建的临时表和内部临时表数据都存放在一个共享的临时表空间中。你可以在 MySQL 5.7+ 中通过这个参数配置临时表空间文件。</p><p><code>Sort Buffer</code>（排序缓冲区）是 MySQL 在内存中为每个<strong>需要排序的线程</strong>分配的一块缓冲区。它的主要作用是存储查询结果，然后在内存中进行排序。</p><p>当 MySQL 执行一个查询时，如果需要对结果集进行排序（例如使用了 <code>ORDER BY</code> 或 <code>GROUP BY</code>），并且无法通过索引来完成这个排序操作时，就会使用 <code>Sort Buffer</code>。     </p><p><code>Using filesort</code> 是一个明显的性能警示，它告诉我们：</p><ol><li>查询使用了 <code>ORDER BY</code> 或 <code>GROUP BY</code>。</li><li>MySQL 无法利用索引来完成排序。</li><li>查询将使用 <code>Sort Buffer</code>，并且可能需要进行磁盘上的外部排序。</li></ol><h2 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h2><p>致慢查询的原因有很多，但归根结底，都可以归结为两个核心问题：<strong>数据量大</strong>和<strong>数据访问效率低</strong>。</p><ol><li>索引问题</li></ol><p>这是最常见、最核心的慢查询原因。</p><ul><li><strong>缺少索引：</strong> 当 <code>WHERE</code> 子句中的条件列没有索引时，数据库为了找到符合条件的行，不得不进行<strong>全表扫描（Full Table Scan）</strong>。这意味着它会逐行检查表中的每一条记录，直到找到所有匹配的行，这在高数据量下是灾难性的。</li><li><strong>索引失效：</strong> 即使创建了索引，也可能因为一些不当的 SQL 写法导致索引无法被使用。例如：<ul><li>在索引列上使用函数：<code>WHERE YEAR(order_date) = 2023</code>。</li><li>在索引列上进行类型转换：<code>WHERE user_id = &#39;12345&#39;</code>（<code>user_id</code> 是整型）。</li><li>模糊查询以 <code>%</code> 开头：<code>WHERE name LIKE &#39;%john%&#39;</code>。</li></ul></li><li><strong>选择了错误的索引：</strong> 数据库优化器可能会因为统计信息不准确等原因，选择了不是最优的索引，导致查询性能不佳。</li></ul><ol><li>SQL 语句本身的问题</li></ol><ul><li><strong>复杂的 JOIN：</strong> 当一个查询涉及到多个表的 <code>JOIN</code> 操作时，如果没有正确的索引和优化，可能会生成非常大的中间结果集，导致查询效率低下。</li><li><strong>大批量的数据返回：</strong> <code>SELECT *</code> 这种查询如果返回大量不必要的列，会增加网络传输和内存开销。</li><li><strong>不合理的 <code>ORDER BY</code> 和 <code>GROUP BY</code>：</strong> 如果 <code>ORDER BY</code> 或 <code>GROUP BY</code> 的列没有索引，数据库需要对结果集进行额外的<strong>文件排序（Using filesort）</strong> 或创建<strong>临时表（Using temporary）</strong>，这会消耗大量的 CPU 和内存资源。</li></ul><ol><li>数据表和数据库设计问题</li></ol><ul><li><strong>表结构不合理：</strong> 如果一个表设计得非常“宽”（即包含太多列），或者字段类型选择不当（例如，使用 <code>VARCHAR</code> 存储日期），都会影响查询性能。</li><li><strong>没有进行分库分表：</strong> 当单表数据量达到千万甚至上亿级别时，即使有索引，也会因为索引树过大而影响查询性能。此时，分库分表是解决性能瓶颈的有效手段。</li></ul><ol><li>数据库配置和硬件问题</li></ol><ul><li><strong>数据库配置不当：</strong> 比如 <code>innodb_buffer_pool_size</code> 设置过小，导致数据库无法在内存中缓存足够的热点数据，频繁地进行磁盘 I/O。</li><li><strong>硬件瓶颈：</strong> 磁盘 I/O 速度慢、CPU 核心数不足、内存不足等硬件问题，都会直接导致查询变慢。</li></ul><ol><li>并发与锁问题</li></ol><ul><li><strong>锁等待：</strong> 如果一个查询需要访问的行被其他长事务锁住，它就会进入等待状态，导致查询变慢。</li><li><strong>死锁：</strong> 在复杂的并发场景下，如果发生死锁，事务会被回滚，同样会影响性能和用户体验</li></ul><ol><li>开启慢查询日志</li></ol><p>首先，你需要让 MySQL 记录下这些慢查询。慢查询日志（Slow Query Log）是 MySQL 自带的诊断工具，可以记录所有执行时间超过 <code>long_query_time</code> 的 SQL 语句。</p><p>在 <code>my.cnf</code> 或 <code>my.ini</code> 配置文件中添加或修改以下配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment"># 开启慢查询日志</span></span><br><span class="line"><span class="attr">slow_query_log</span> = <span class="literal">ON</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置慢查询日志文件路径</span></span><br><span class="line"><span class="attr">slow_query_log_file</span> = /var/lib/mysql/mysql-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置慢查询阈值（单位：秒），这里设置为 1 秒</span></span><br><span class="line"><span class="attr">long_query_time</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录没有使用索引的查询</span></span><br><span class="line"><span class="attr">log_queries_not_using_indexes</span> = <span class="literal">ON</span></span><br></pre></td></tr></table></figure><p>配置完成后，重启 MySQL 服务，它就会开始记录慢查询。</p><p>2.有了慢查询日志后，你需要工具来分析它。日志文件通常包含大量信息，直接阅读非常困难。<strong>使用 <code>mysqldumpslow</code></strong>：MySQL 自带的工具，可以对慢查询日志进行汇总和排序，帮助你快速找出最频繁、平均执行时间最长或锁定时间最长的慢查询。</p><p>3.当你找到一个需要优化的慢查询后，下一步就是分析它的执行计划。<code>EXPLAIN</code> 命令可以模拟优化器执行 SQL 查询，并告诉你数据库将如何处理这个查询，包括使用了哪些索引、扫描了多少行、是否使用了临时表等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">25</span> <span class="keyword">AND</span> city <span class="operator">=</span> <span class="string">&#x27;Shanghai&#x27;</span>;</span><br></pre></td></tr></table></figure><p>重点关注 <code>EXPLAIN</code> 结果中的几个关键字段：</p><ul><li><strong><code>type</code></strong>：这是最重要的指标，它表示 MySQL 查找数据的方式。<ul><li><strong><code>const</code></strong>、<strong><code>eq_ref</code></strong>：非常高效，通常是主键或唯一索引查找。</li><li><strong><code>ref</code></strong>、<strong><code>range</code></strong>：较好，使用了索引。</li><li><strong><code>index</code></strong>：全索引扫描，通常比全表扫描好。</li><li><strong><code>ALL</code></strong>：全表扫描，性能最差，需要重点优化。</li></ul></li><li><strong><code>key</code></strong>：实际使用的索引。如果为 <code>NULL</code>，表示没有使用索引。</li><li><strong><code>rows</code></strong>：MySQL 估计要扫描的行数，值越小越好。</li><li><strong><code>Extra</code></strong>：额外信息，其中一些值需要特别注意：<ul><li><strong><code>Using filesort</code></strong>：表示需要额外的排序操作，通常可以创建合适的索引来避免。</li><li><strong><code>Using temporary</code></strong>：表示需要创建临时表，这通常是性能瓶颈。</li></ul></li></ul><p>根据 <code>EXPLAIN</code> 的分析结果，可以采取以下策略进行优化：</p><ul><li><p><strong>创建或优化索引</strong>：</p><ul><li>为 <code>WHERE</code>、<code>ORDER BY</code>、<code>GROUP BY</code> 子句中使用的列创建索引。</li><li>使用<strong>联合索引</strong>来覆盖查询中的多个列，避免 <code>Using filesort</code> 和全表扫描。</li><li><strong>覆盖索引（Covering Index）</strong>：如果查询的所有列都包含在索引中，MySQL 可以直接从索引中返回数据，而无需回表（访问聚簇索引），这会显著提高性能。</li></ul></li><li><p><strong>优化 SQL 语句</strong>：</p><ul><li><strong>避免全表扫描</strong>：检查 <code>EXPLAIN</code> 的 <code>type</code> 字段，确保没有 <code>ALL</code>。</li><li><strong>优化 <code>JOIN</code></strong>：确保 <code>JOIN</code> 语句的连接条件上有索引，并且小表驱动大表。</li><li><strong>避免使用函数</strong>：不在索引列上使用函数（例如 <code>WHERE YEAR(date_column) = 2023</code>），这会导致索引失效。</li><li><strong>使用 <code>LIMIT</code></strong>：在查询只需要部分结果时，使用 <code>LIMIT</code> 限制返回行数。</li></ul></li><li><p><strong>更改数据库或表结构</strong>：</p><ul><li><strong>分库分表</strong>：当单表数据量过大时，考虑垂直拆分（按列）或水平拆分（按行）。</li><li><strong>冗余字段</strong>：适当增加冗余字段，减少 <code>JOIN</code> 操作。</li></ul></li><li><p><strong>硬件和系统层面</strong>：</p><ul><li><strong>增加缓存</strong>：使用 Redis、Memcached 等缓存系统来缓存热点数据，减少数据库查询压力。</li><li><strong>升级硬件</strong>：升级 CPU、内存或使用更快的 SSD 硬盘。</li></ul><p><strong>1.慢查询的解决方案</strong></p><p>解决MySQL慢查询问题的方案可以按照资源消耗从少到多的顺序排列，像金字塔一样逐步提升。以下是从资源消耗少到多的常见优化方式：</p><p>(1)SQL优化</p><p>合理使用索引：确保查询字段使用了索引。对于WHERE、JOIN、ORDER BY、GROUP BY等操作的字段，应该创建相应的索引。</p><p>(2)索引优化</p><p>创建复合索引：对于多个字段联合查询，创建复合索引（注意索引顺序）。</p><p>删除冗余索引：定期清理无用索引，减少索引维护的负担。</p><p>避免索引覆盖不必要的字段：有时候一个大字段（如TEXT或BLOB）放入索引会增加存储开销，应该避免。</p><p>更新统计信息：定期更新表的统计信息，帮助优化器选择更合适的执行计划。</p><p>(3)数据库配置优化</p><p>调整缓存设置：增加innodb_buffer_pool_size，确保更多的数据能够缓存到内存中。调整query_cache_size，如果适用，启用查询缓存（对于更新频繁的应用不推荐）。</p><p>调整连接设置：如增加max_connections，但要注意数据库承载能力。</p><p>调整临时表大小：如果临时表经常写入磁盘，可以通过调整tmp_table_size和max_heap_table_size来避免此问题。</p><p>增加排序缓存：增加sort_buffer_size来提高ORDER BY和GROUP BY操作的效率。</p><p>(4)架构优化</p><p>分库分表：对于单表数据量过大的情况，使用分库分表策略，将数据分散到不同的数据库或表中，减少每个查询的负载。</p><p>读写分离：通过主从复制，减少主库的查询压力，读请求分发到从库。</p><p>数据库集群：使用分布式数据库系统，解决单机性能瓶颈。</p><p>(5)硬件升级</p><p>增加内存：通过增加内存，提高缓存命中率，减少磁盘IO。</p><p>更换更快的磁盘：使用SSD代替传统的硬盘，提升磁盘IO性能。</p><p>增加CPU处理能力：提升CPU性能，减少数据库查询的CPU瓶颈。</p></li></ul><h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h3 id="与传统的JDBC相比，MyBatis的优点"><a href="#与传统的JDBC相比，MyBatis的优点" class="headerlink" title="与传统的JDBC相比，MyBatis的优点"></a>与传统的JDBC相比，MyBatis的优点</h3><ul><li>基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任 何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重用。</li><li>与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不 需要手动开关连接；</li><li>很好的与各种数据库兼容，因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持。</li><li>能够与 Spring 很好的集成，开发效率高</li><li>提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射 标签，支持对象关系组件维护。</li></ul><p>MyBatis 在 <strong>SQL 灵活性</strong>、<strong>动态 SQL 支持</strong>、<strong>结果集映射</strong>和<strong>与 Spring 整合</strong>方面表现卓越，尤其适合重视 SQL 可控性的项目。</p><ul><li>SQL 与代码解耦，灵活可控：MyBatis 允许开发者直接编写和优化 SQL，相比全自动 ORM（如 Hibernate），MyBatis 让开发者明确知道每条 SQL 的执行逻辑，便于性能调优。</li><li>动态 SQL 的强大支持：比如可以动态拼接SQL，通过 <code>&lt;if&gt;</code>, <code>&lt;choose&gt;</code>, <code>&lt;foreach&gt;</code> 等标签动态生成 SQL，避免 Java 代码中繁琐的字符串拼接。</li><li>自动映射与自定义映射结合：自动将查询结果字段名与对象属性名匹配（如驼峰转换）。</li><li>插件扩展机制：可编写插件拦截 SQL 执行过程，实现分页、性能监控、SQL 改写等通用逻辑。</li><li>与 Spring 生态无缝集成：通过 <code>@MapperScan</code> 快速扫描 Mapper 接口，结合 Spring 事务管理，配置简洁高效。</li></ul><h3 id="Mybatis里的-和-的区别"><a href="#Mybatis里的-和-的区别" class="headerlink" title="Mybatis里的 # 和 $ 的区别"></a>Mybatis里的 # 和 $ 的区别</h3><ul><li>Mybatis 在处理 #{} 时，会创建预编译的 SQL 语句，将 SQL 中的 #{} 替换为 ? 号，在执行 SQL 时会为预编译 SQL 中的占位符（?）赋值，调用 PreparedStatement 的 set 方法来赋值，预编译的 SQL 语句执行效率高，并且可以防止SQL 注入，提供更高的安全性，适合传递参数值。</li><li>Mybatis 在处理 ${} 时，只是创建普通的 SQL 语句，然后在执行 SQL 语句时 MyBatis 将参数直接拼入到 SQL 里，不能防止 SQL 注入，因为参数直接拼接到 SQL 语句中，如果参数未经过验证、过滤，可能会导致安全问题。</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于极客时间中的MySQL实战45讲以及小林coding,可以查看&lt;a href=&quot;https://uaxe.github.io/geektime-docs/&quot;&gt;极客时间文档&lt;/a&gt;,相关github仓库&lt;a href=&quot;https://github.com/it-ebooks-0/geektime-books&quot;&gt;it-ebooks-0/geektime-books: :books: 极客时间电子书&lt;/a&gt;和&lt;a href=&quot;https://github.com/zkep/my-geektime&quot;&gt;zkep/my-geektime: 👏 极客时间下载器 &amp;amp; 在线文档&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="mysql" scheme="https://www.sekyoro.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>文件分片上传分析</title>
    <link href="https://www.sekyoro.top/2025/05/12/%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%86%E6%9E%90/"/>
    <id>https://www.sekyoro.top/2025/05/12/%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%86%E6%9E%90/</id>
    <published>2025-05-12T12:26:12.000Z</published>
    <updated>2025-05-13T16:02:04.899Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在实现文件上传时,通常会去讨论文件分片上传、秒传以及断点续传等问题,这里整理一下解决方法.<br><span id="more"></span></p><div class="table-container"><table><thead><tr><th>问题</th><th>分片上传的好处</th></tr></thead><tbody><tr><td>大文件上传超时 / 失败</td><td>分片失败可重传，避免全部重传</td></tr><tr><td>网络不稳定</td><td>分片可以断点续传</td></tr><tr><td>并发能力弱</td><td>分片可并发上传提高速度</td></tr><tr><td>浏览器限制（如 body 大小）</td><td>避免单次请求过大被限制</td></tr><tr><td>支持上传进度显示</td><td>每片进度可追踪</td></tr></tbody></table></div><p>文件分片上传是一种将大文件分割成多个小片段（分片），然后逐个上传这些分片的技术。这种方法有几个优点，包括提高上传的成功率、减少内存占用以及支持断点续传等。下面简要介绍文件分片上传的概念和实现方法。</p><p><strong>前端流程：</strong></p><ol><li>选择文件并读取其大小</li><li>将文件按固定大小（如 1MB）切片（使用 <code>Blob.slice</code>）</li><li>逐片上传（可并发）</li><li>上传成功后通知服务器进行合并</li></ol><p>可以通过hash分片验证是否已经上传,从而提升用户文件上传体验.</p><h3 id="Hash检测-实现秒传"><a href="#Hash检测-实现秒传" class="headerlink" title="Hash检测 实现秒传"></a>Hash检测 实现秒传</h3><p><strong>秒传的关键是“文件去重”</strong> —— 客户端通过<strong>计算文件指纹（如 MD5、SHA256）</strong>，先向服务器查询是否已存在相同文件，如果存在则<strong>跳过上传</strong>，直接“秒传成功”。</p><h4 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h4><ol><li>前端计算文件 hash（通常用 <code>CryptoJS</code>、<code>spark-md5</code>）。</li><li>发请求询问服务器：这个 hash 是否已上传？</li><li>如果服务器返回“存在”：<ul><li>返回文件地址（或秒传成功）</li></ul></li><li>否则再走正常上传流程。</li></ol><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul><li>前端文件 hash 计算是异步的，推荐使用 <code>Web Worker</code> 加速。</li><li>服务端需要维护文件 hash 与实际文件路径的映射表（如 Redis、数据库）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">const file = ref&lt;File | null&gt;(null);</span><br><span class="line">const handleFileChange = (event:Event)=&gt; &#123;</span><br><span class="line">  const target = event.target as HTMLInputElement;</span><br><span class="line">  if (target.files &amp;&amp; target.files.length &gt; 0) &#123;</span><br><span class="line">    file.value = target.files[0] as File;</span><br><span class="line">    console.log(file.value.name);</span><br><span class="line">    const chunks = calculateChunks(file.value);</span><br><span class="line">    calculateHash(chunks).then((hash) =&gt; &#123;</span><br><span class="line">      console.log(&quot;File hash:&quot;, hash);</span><br><span class="line">    &#125;).catch((error) =&gt; &#123;</span><br><span class="line">      console.error(&quot;Error calculating hash:&quot;, error);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const calculateChunks = (file:File):Blob[]=&gt;&#123;</span><br><span class="line">  const size = file.size;</span><br><span class="line">  const chunks:Blob[] = [];</span><br><span class="line">  let start = 0;</span><br><span class="line">  while(start &lt; size)&#123;</span><br><span class="line">    const end = Math.min(start + CHUNK_SIZE, size);</span><br><span class="line">    const chunk = file.slice(start, end);</span><br><span class="line">    chunks.push(chunk);</span><br><span class="line">    start = end;</span><br><span class="line">  &#125;</span><br><span class="line">  return chunks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const calculateHash = async(chunks:Blob[])=&gt;&#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">   const size = chunks.length;</span><br><span class="line">  console.log(`一共有$&#123;size&#125;个分片`);</span><br><span class="line">  const targets:Blob[] = [];</span><br><span class="line">  const fileReader = new FileReader();</span><br><span class="line">  chunks.forEach((chunk:Blob, index) =&gt; &#123;</span><br><span class="line">    if(index == 0 || index == size - 1)&#123;</span><br><span class="line">      targets.push(chunk);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    targets.push(chunk.slice(0, 2));</span><br><span class="line">    targets.push(chunk.slice(CHUNK_SIZE/2, CHUNK_SIZE/2 + 2));</span><br><span class="line">    targets.push(chunk.slice(CHUNK_SIZE - 2, CHUNK_SIZE));</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  fileReader.readAsArrayBuffer(new Blob(targets));</span><br><span class="line">    const spark =new SparkMD5.ArrayBuffer();</span><br><span class="line">  fileReader.onload = (event:ProgressEvent&lt;FileReader&gt;) =&gt; &#123;</span><br><span class="line">    const arrayBuffer = event.target?.result as ArrayBuffer;</span><br><span class="line">    spark.append(arrayBuffer);</span><br><span class="line">    resolve(spark.end());</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  fileReader.onerror = (event:ProgressEvent&lt;FileReader&gt;) =&gt; &#123;</span><br><span class="line">    console.error(&quot;Error reading file:&quot;, event);</span><br><span class="line">    reject(event);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="切片上传"><a href="#切片上传" class="headerlink" title="切片上传"></a>切片上传</h3><p>上传表单<code>form/multipart</code>数据,包括切片索引以及hash信息,后端每次下载切片到一个文件夹下.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uploadChunks = <span class="keyword">async</span> (chunks: Blob[]) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> data = chunks.map(<span class="function">(<span class="params">chunk: Blob, index: number</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">    formData.append(<span class="string">&quot;fileHash&quot;</span>, fileHash.value <span class="keyword">as</span> string);</span><br><span class="line">    formData.append(<span class="string">&quot;chunk&quot;</span>, chunk);</span><br><span class="line">    formData.append(<span class="string">&quot;size&quot;</span>, chunk.size.toString());</span><br><span class="line">    formData.append(<span class="string">&quot;chunkIndex&quot;</span>, index.toString());</span><br><span class="line">    formData.append(<span class="string">&quot;chunkHash&quot;</span>, fileHash.value + <span class="string">&quot;-&quot;</span> + index);</span><br><span class="line">    <span class="keyword">return</span> formData;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> MAX_REQUEST = <span class="number">6</span>;</span><br><span class="line">  <span class="comment">// 并发请求</span></span><br><span class="line">  <span class="keyword">const</span> taskPool: <span class="built_in">Promise</span>&lt;Response&gt;[] = [];</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; data.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> task = fetch(<span class="string">&quot;http://localhost:3000/upload&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">      <span class="attr">body</span>: data[index],</span><br><span class="line">    &#125;);</span><br><span class="line">    taskPool.push(task);</span><br><span class="line"></span><br><span class="line">    task</span><br><span class="line">      .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (response.ok) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;分片上传成功&quot;</span>);</span><br><span class="line">          taskPool.splice(taskPool.indexOf(task), <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.error(<span class="string">&quot;分片上传失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&quot;Error uploading chunk:&quot;</span>, error);</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">if</span> (taskPool.length == MAX_REQUEST) &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.race(taskPool)</span><br><span class="line">        .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (result.ok) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;分片上传成功&quot;</span>);</span><br><span class="line">            taskPool.splice(taskPool.indexOf(task), <span class="number">1</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">&quot;分片上传失败&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 只要有一个完成就返回</span></span><br><span class="line">          <span class="comment">// 如果上传成功,移除该任务</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.error(<span class="string">&quot;Error uploading chunk:&quot;</span>, error);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(taskPool);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>大文件切成多个小块（如每块 1MB），<strong>逐个上传</strong>，上传完毕后由服务器<strong>合并为完整文件</strong>。</p><h4 id="实现步骤：-1"><a href="#实现步骤：-1" class="headerlink" title="实现步骤："></a>实现步骤：</h4><ol><li><p>前端将文件切片，通常通过：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chunk = file.slice(start, end);</span><br></pre></td></tr></table></figure></li><li><p>每个切片附带索引和文件唯一标识（如 hash）上传。</p></li><li><p>后端接收每个切片，按 hash 和索引编号保存。</p></li><li><p>前端上传完所有切片后，请求服务端<strong>合并文件</strong>。</p></li></ol><h4 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h4><ul><li>客户端：控制并发上传（推荐并发数 3～5）。</li><li>服务端：需要记录哪些切片已经上传（可用 Redis 或文件夹索引）。</li><li>最后合并文件时可用 <code>fs.appendFile</code> 或 <code>fs.createWriteStream</code></li></ul><h3 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeRequest = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> reqData = &#123;</span><br><span class="line">    <span class="attr">fileHash</span>: fileHash.value,</span><br><span class="line">    <span class="attr">fileName</span>: fileName.value,</span><br><span class="line">    <span class="attr">fileTotalSize</span>: file.value?.size,</span><br><span class="line">    <span class="attr">chunkSize</span>: CHUNK_SIZE,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&quot;http://localhost:3000/merge&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(reqData),</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (response.ok) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;文件合并成功&quot;</span>);</span><br><span class="line">    alert(<span class="string">&quot;合并成功&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;文件合并失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">&quot;/merge&quot;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 合并文件 json请求</span></span><br><span class="line">  <span class="keyword">const</span> &#123; fileHash, fileName, fileTotalSize, chunkSize &#125; = req.body;</span><br><span class="line">  <span class="keyword">const</span> chunkFile = path.resolve(UPLOAD_DIR, fileHash + getSuffix(fileName));</span><br><span class="line">  <span class="keyword">if</span> (fs.existsSync(chunkFile)) &#123;</span><br><span class="line">    res.status(<span class="number">200</span>).json(&#123;</span><br><span class="line">      <span class="attr">ok</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&quot;文件已经存在&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> chunkDir = path.resolve(UPLOAD_DIR, fileHash);</span><br><span class="line">    <span class="keyword">if</span> (!fs.existsSync(chunkDir)) &#123;</span><br><span class="line">      res.status(<span class="number">401</span>).json(&#123;</span><br><span class="line">        <span class="attr">ok</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&quot;合并失败,请重新上传&quot;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取目录下文件</span></span><br><span class="line">    <span class="keyword">const</span> mergeFilePath = chunkFile;</span><br><span class="line">    <span class="keyword">const</span> chunkPaths = <span class="keyword">await</span> fse.readdir(chunkDir);</span><br><span class="line">    <span class="keyword">if</span> (chunkPaths.length === <span class="number">0</span>) &#123;</span><br><span class="line">      res.status(<span class="number">401</span>).json(&#123;</span><br><span class="line">        <span class="attr">ok</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&quot;合并失败,请重新上传&quot;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    chunkPaths.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>] - b.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> tasks = chunkPaths.map(<span class="function">(<span class="params">chunkPath, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 读取文件</span></span><br><span class="line">        <span class="keyword">const</span> chunkFilePath = path.resolve(chunkDir, chunkPath);</span><br><span class="line">        <span class="comment">// const fileBuffer = fs.readFileSync(chunkFilePath);</span></span><br><span class="line">        <span class="comment">// 写入文件</span></span><br><span class="line">        <span class="keyword">const</span> readStream = fse.createReadStream(chunkFilePath);</span><br><span class="line">        <span class="keyword">const</span> writeStream = fse.createWriteStream(mergeFilePath, &#123;</span><br><span class="line">          <span class="attr">start</span>: index * chunkSize,</span><br><span class="line">          <span class="attr">end</span>: (index + <span class="number">1</span>) * chunkSize,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// writeStream.on(&quot;finish&quot;, async () =&gt; &#123;</span></span><br><span class="line">        <span class="comment">//   console.log(`删除文件$&#123;chunkFilePath&#125;`);</span></span><br><span class="line">        <span class="comment">//   await fse.unlink(chunkFilePath);</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          pipeline(readStream, writeStream).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fse.unlinkSync(chunkFilePath);</span><br><span class="line">            resolve();</span><br><span class="line">          &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(err);</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fs.appendFileSync(mergeFilePath, fileBuffer);</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="built_in">Promise</span>.all(tasks);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      res.status(<span class="number">401</span>).json(&#123;</span><br><span class="line">        <span class="attr">ok</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&quot;合并失败,请重新上传&quot;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> files = <span class="keyword">await</span> fse.readdir(chunkDir);</span><br><span class="line">    <span class="keyword">const</span> fileCount = files.length;</span><br><span class="line">    <span class="built_in">console</span>.log(fileCount)</span><br><span class="line">    <span class="keyword">if</span> (fileCount === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">await</span> fse.rmdir(chunkDir);</span><br><span class="line">    &#125;</span><br><span class="line">    res.status(<span class="number">200</span>).json(&#123;</span><br><span class="line">      <span class="attr">ok</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&quot;合并成功&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在切片上传完毕之后再发送merge请求.</p><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">const</span> verifyHash =  <span class="keyword">async</span>(hash: string,<span class="attr">fileName</span>:string) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">&quot;http://localhost:3000/verify&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      <span class="attr">fileHash</span>: hash,</span><br><span class="line">      <span class="attr">fileName</span>: fileName,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">resp</span>=&gt;</span>resp.json())</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">existFile</span>:!result.shouldUpload,<span class="attr">existChunks</span>:result?.existChunks&#125;;</span><br><span class="line">  &#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;Error verifying file hash:&quot;</span>, error);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line">app.post(<span class="string">&quot;/verify&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; fileHash, fileName &#125; = req.body;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回服务器已经上传成功的切片索引</span></span><br><span class="line">  <span class="keyword">const</span> chunkDir = path.resolve(UPLOAD_DIR, fileHash);</span><br><span class="line">  <span class="keyword">if</span> (fs.existsSync(chunkDir)) &#123;</span><br><span class="line">    <span class="comment">// 如果存在该目录,查看其中的最大文件索引</span></span><br><span class="line">    <span class="keyword">const</span> files = fs.readdirSync(chunkDir);</span><br><span class="line">    <span class="comment">// const maxIndex = Math.max(...files.map((fileName) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   return parseInt(fileName.split(&quot;-&quot;)[1]);</span></span><br><span class="line">    <span class="comment">// &#125;));</span></span><br><span class="line">    res.status(<span class="number">200</span>).json(&#123;</span><br><span class="line">      <span class="attr">ok</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&quot;完整文件不存在&quot;</span>,</span><br><span class="line">      <span class="attr">shouldUpload</span>:<span class="literal">true</span>,</span><br><span class="line">      <span class="attr">existChunks</span>: files,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 验证是否已经有合并后的完整文件</span></span><br><span class="line">  <span class="keyword">const</span> suffix = getSuffix(fileName);</span><br><span class="line">  <span class="keyword">const</span> filePath = path.resolve(UPLOAD_DIR, fileHash + suffix);</span><br><span class="line">  <span class="keyword">if</span> (fs.existsSync(filePath)) &#123;</span><br><span class="line">    res.status(<span class="number">200</span>).json(&#123;</span><br><span class="line">      <span class="attr">ok</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&quot;文件已经存在&quot;</span>,</span><br><span class="line">      <span class="attr">shouldUpload</span>:<span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.status(<span class="number">200</span>).json(&#123;</span><br><span class="line">      <span class="attr">ok</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&quot;完整文件不存在&quot;</span>,</span><br><span class="line">      <span class="attr">shouldUpload</span>:<span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h4><p><strong>上传中断后</strong>，可以<strong>只上传未完成的部分</strong>，而不用从头开始。</p><h4 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h4><ul><li>通常与<strong>分片上传结合使用</strong>。</li><li>客户端在重试上传前，先向服务端询问已上传的切片列表。</li><li>客户端只上传未完成的切片，最后合并。</li></ul><h4 id="关键点：-1"><a href="#关键点：-1" class="headerlink" title="关键点："></a>关键点：</h4><ul><li>客户端需记录上传状态（如切片状态、索引）。</li><li>服务端提供接口返回已有的切片（如 <code>/upload/status?fileHash=xxx</code>）。</li><li>文件 hash 一定要稳定，用于唯一标识该文件上传任务。</li></ul><h3 id="服务端解决方案"><a href="#服务端解决方案" class="headerlink" title="服务端解决方案"></a>服务端解决方案</h3><div class="table-container"><table><thead><tr><th>技术点</th><th>实现方式</th></tr></thead><tbody><tr><td>存储切片</td><td>保存到本地临时目录 or 对象存储（如 OSS、S3）</td></tr><tr><td>存储状态</td><td>Redis（高效） or MongoDB/MySQL</td></tr><tr><td>文件合并</td><td><code>fs.createWriteStream</code> + <code>fs.createReadStream</code></td></tr><tr><td>断点续传状态</td><td>文件夹结构 + index.json、数据库记录</td></tr></tbody></table></div><h3 id="推荐前端工具库"><a href="#推荐前端工具库" class="headerlink" title="推荐前端工具库"></a>推荐前端工具库</h3><ul><li><code>spark-md5</code>：快速计算文件 hash（支持分片 hash）</li><li><code>axios</code>：支持中断、重试、并发控制</li><li>可配合 <code>Web Worker</code> 和 <code>FileReader</code> 异步读取文件<h4 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h4></li></ul><p>Web Workers 是一种让网页内容在后台线程中运行脚本的方式。工作线程可以在不影响用户界面的情况下执行任务。此外，它们可以使用 <code>fetch()</code> 或 <code>XMLHttpRequest</code> API 发起网络请求。一旦创建，一个工作线程可以通过向创建它的 JavaScript 代码指定的事件处理器发送消息来与其通信（反之亦然）</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">Using Web Workers - Web APIs | MDN</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fileInput = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;fileInput&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;result&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Worker 实例</span></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;hash-worker.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  result.textContent = <span class="string">&#x27;文件 MD5: &#x27;</span> + event.data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fileInput.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> file = <span class="built_in">this</span>.files[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (!file) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取文件为 ArrayBuffer，发送给 Worker</span></span><br><span class="line">  <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">  reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    worker.postMessage(reader.result); <span class="comment">// ArrayBuffer 发送给 Worker</span></span><br><span class="line">  &#125;;</span><br><span class="line">  reader.readAsArrayBuffer(file);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/importScripts">WorkerGlobalScope: importScripts() method - Web APIs | MDN</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 spark-md5（注意路径）或使用 CDN + importScripts</span></span><br><span class="line">importScripts(<span class="string">&#x27;https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrayBuffer = event.data;</span><br><span class="line">  <span class="keyword">const</span> spark = <span class="keyword">new</span> self.SparkMD5.ArrayBuffer();</span><br><span class="line">  spark.append(arrayBuffer);</span><br><span class="line">  <span class="keyword">const</span> hash = spark.end();</span><br><span class="line">  postMessage(hash);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>主线程不卡顿。</li><li>计算任务可异步处理，提升用户体验。</li><li><code>ArrayBuffer</code> 是可转移对象，性能更好（不会拷贝，只是转移）。</li></ul><p><strong>注意事项</strong></p><ul><li>Worker 中<strong>无法访问 DOM</strong>、<code>window</code>。</li><li>Worker 是异步的，不支持 <code>alert</code>、<code>confirm</code> 等。</li><li>跨域引用 <code>worker.js</code> 时需要注意同源策略，或使用 Blob 方式创建 Worker。</li></ul><h3 id="实战优化"><a href="#实战优化" class="headerlink" title="实战优化"></a>实战优化</h3><ul><li><p>支持大文件（如 1GB+），首选分片上传 + 秒传。</p></li><li><p>支持上传失败重试（单个切片失败可重试）。</p></li><li><p>使用服务端合并标记（如 <code>done.flag</code>）避免重复合并。</p></li><li><p>上传前先校验文件 hash，实现秒传。</p></li><li><p>提供进度回调、UI反馈。</p></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在实现文件上传时,通常会去讨论文件分片上传、秒传以及断点续传等问题,这里整理一下解决方法.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Netty初探</title>
    <link href="https://www.sekyoro.top/2025/05/08/Netty%E5%88%9D%E6%8E%A2/"/>
    <id>https://www.sekyoro.top/2025/05/08/Netty%E5%88%9D%E6%8E%A2/</id>
    <published>2025-05-08T09:50:39.000Z</published>
    <updated>2025-05-14T03:06:12.248Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Netty 是一个基于 Java NIO 的异步、事件驱动的网络应用框架，旨在简化 TCP/UDP 等协议服务器和客户端的开发。它封装了底层的 NIO 细节，提供了易用的 API，广泛应用于高性能网络通信场景，如 Dubbo、RocketMQ、Elasticsearch 等中间件。<br><span id="more"></span></p><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><ol><li>Channel</li></ol><p>表示一个网络连接的抽象，如 SocketChannel。它是数据读写的通道，支持异步非阻塞操作。</p><ol><li>EventLoop &amp; EventLoopGroup</li></ol><p>EventLoop 是处理 I/O 操作的核心，绑定到一个线程，负责处理 Channel 的所有事件。EventLoopGroup 是 EventLoop 的集合，用于管理多个 EventLoop，实现多线程处理。<a href="https://www.processon.com/view/6575bdbf4861d5331582478d?utm_source=chatgpt.com">developer.aliyun.com+2processon.com+2learn.lianglianglee.com+2</a><a href="https://developer.aliyun.com/article/533797?utm_source=chatgpt.com">developer.aliyun.com</a></p><ol><li>ChannelHandler &amp; ChannelPipeline</li></ol><p>ChannelHandler 是处理入站和出站数据的处理器，ChannelPipeline 是 ChannelHandler 的链式结构，定义了数据处理的流程。</p><ol><li>Bootstrap &amp; ServerBootstrap</li></ol><p>用于初始化客户端和服务器的辅助类，配置 Channel、EventLoopGroup、Handler 等。</p><ol><li>ByteBuf</li></ol><p>Netty 自定义的字节缓冲区，替代了 JDK 的 ByteBuffer，提供更高效的内存管理和读写操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个容量为 256 字节的缓冲区</span></span><br><span class="line">ByteBuf buffer = Unpooled.buffer(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用已存在的字节数组创建 ByteBuf（共享数据）</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">ByteBuf wrappedBuffer = Unpooled.wrappedBuffer(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制字节数组创建 ByteBuf（数据独立）</span></span><br><span class="line">ByteBuf copiedBuffer = Unpooled.copiedBuffer(data);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Echo服务器"><a href="#Echo服务器" class="headerlink" title="Echo服务器"></a>Echo服务器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">             .channel(NioServerSocketChannel.class)</span><br><span class="line">             .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> EchoServerHandler());</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture f = b.bind(port).sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;Echo server started on port &quot;</span> + port);</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> EchoServer(<span class="number">8080</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ctx.write(msg); <span class="comment">// 将接收到的消息写回客户端</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        ctx.flush(); <span class="comment">// 刷新所有待处理的消息到远程节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close(); <span class="comment">// 关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Http服务器"><a href="#Http服务器" class="headerlink" title="Http服务器"></a>Http服务器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpHelloWorldServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpHelloWorldServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">             .channel(NioServerSocketChannel.class)</span><br><span class="line">             .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">65536</span>));</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;FullHttpRequest&gt;() &#123;</span><br><span class="line">                         <span class="meta">@Override</span></span><br><span class="line">                         <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, FullHttpRequest req)</span> </span>&#123;</span><br><span class="line">                             FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(</span><br><span class="line">                                     HttpVersion.HTTP_1_1,</span><br><span class="line">                                     HttpResponseStatus.OK,</span><br><span class="line">                                     ctx.alloc().buffer().writeBytes(<span class="string">&quot;Hello, World!&quot;</span>.getBytes())</span><br><span class="line">                             );</span><br><span class="line">                             response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">                             response.headers().set(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes());</span><br><span class="line">                             ctx.writeAndFlush(response);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture f = b.bind(port).sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;HTTP server started on port &quot;</span> + port);</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HttpHelloWorldServer(<span class="number">8080</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="WebSocket服务器"><a href="#WebSocket服务器" class="headerlink" title="WebSocket服务器"></a>WebSocket服务器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.stream.ChunkedWriteHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebSocketServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">             .channel(NioServerSocketChannel.class)</span><br><span class="line">             .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">65536</span>));</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">&quot;/ws&quot;</span>));</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;TextWebSocketFrame&gt;() &#123;</span><br><span class="line">                         <span class="meta">@Override</span></span><br><span class="line">                         <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> </span>&#123;</span><br><span class="line">                             System.out.println(<span class="string">&quot;Received: &quot;</span> + msg.text());</span><br><span class="line">                             ctx.channel().writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">&quot;Echo: &quot;</span> + msg.text()));</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture f = b.bind(port).sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;WebSocket server started on port &quot;</span> + port);</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> WebSocketServer(<span class="number">8080</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;Netty 是一个基于 Java NIO 的异步、事件驱动的网络应用框架，旨在简化 TCP/UDP 等协议服务器和客户端的开发。它封装了底层的 NIO 细节，提供了易用的 API，广泛应用于高性能网络通信场景，如 Dubbo、RocketMQ、Elasticsearch 等中间件。&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>TinyWebServer项目学习</title>
    <link href="https://www.sekyoro.top/2025/03/20/TinyHttpServer%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2025/03/20/TinyHttpServer%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-03-20T09:46:11.000Z</published>
    <updated>2025-03-25T08:28:26.634Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>经典的C++ Linux网络编程项目.<br><span id="more"></span></p><blockquote><p>不相关的话:</p><p>C++后端相关项目集中体现在:Linux环境编程,网络编程,并发(多线程)编程</p><p>常见项目就是webserver以及基于moduo等库进行业务开发(聊天服务,结合mysql,redis)等.比如下面项目:</p><p><a href="https://zhuanlan.zhihu.com/p/688641400">从易到难，推荐9个适合练手的C++项目 - 知乎</a></p><p><a href="https://www.cnblogs.com/xiaokang-coding/p/18531816">应届生必看！23 个高质量 C++ 项目推荐，校招简历秒加分 - 江小康 - 博客园</a></p><p><a href="https://www.nowcoder.com/discuss/353157418395836416">我整理了10个可以写到简历上的C++项目_牛客网</a></p><p><a href="https://zhuanlan.zhihu.com/p/17138007124">GitHub项目推荐—适合练手的13个C++开源项目 - 知乎</a></p></blockquote><h2 id="并发同步方法"><a href="#并发同步方法" class="headerlink" title="并发同步方法"></a>并发同步方法</h2><p>在多线程并发条件下,对于共享资源,需要用锁机制解决.在c++标准中,有<code>mutex</code>,<code>condition_variable</code>以及新增的<code>barrier</code>,<code>latch</code>,<code>counting_semaphore</code>等机制.</p><p>这里使用了linux上的信号量<code>sem_t</code>和<code>pthread_mutex_t</code>锁机制.</p><h3 id="sem-t"><a href="#sem-t" class="headerlink" title="sem_t"></a>sem_t</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sem_t</span> sem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> waitSeconds)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(waitSeconds));</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sem); <span class="comment">// 尝试获取信号量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; is running.\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;sem); <span class="comment">// 释放信号量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sem, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 初始化信号量，初始值为2</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(task, <span class="string">&quot;A&quot;</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(task, <span class="string">&quot;B&quot;</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(task, <span class="string">&quot;C&quot;</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;sem); <span class="comment">// 销毁信号量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>sem_wait</code> 函数用于等待一个信号量。它会尝试减少（减1）信号量的计数值。如果信号量的值大于0，则该函数会将信号量的值减1，并立即返回。</p><p>如果信号量的值为0，则调用 <code>sem_wait</code> 的线程或进程会被阻塞，直到另一个线程或进程通过调用 <code>sem_post</code> 增加了信号量的值，使得其大于0为止。</p><p>常用于表示“获取”一个资源或进入临界区。<strong>当信号量代表可用资源的数量时，<code>sem_wait</code> 可以理解为尝试占用一个资源。</strong>成功时返回 <code>0</code>,失败时返回 <code>-1</code> 并设置 <code>errno</code></p><p>​    <code>sem_post</code>函数用于增加（加1）信号量的计数值，并通知可能正在等待该信号量的一个线程或进程。该函数总是成功地将信号量的值加1。</p><p>如果有其他线程或进程正在等待这个信号量（即因为信号量的值为0而被阻塞），那么其中一个等待的线程或进程会被唤醒并继续执行。常用于表示“释放”一个资源或离开临界区。<strong>当某个线程完成了对共享资源的操作后，可以通过调用 <code>sem_post</code> 来通知其他线程可以继续操作该资源</strong>。成功时返回 <code>0</code>,失败时返回 <code>-1</code> 并设置 <code>errno</code></p><h3 id="pthread-mutex-t"><a href="#pthread-mutex-t" class="headerlink" title="pthread_mutex_t"></a>pthread_mutex_t</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ITERATIONS 100000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">increment_counter</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ITERATIONS; ++i) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex); <span class="comment">// 加锁</span></span><br><span class="line">        ++counter;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex); <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Mutex init failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>, increment_counter, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Thread creation failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Final counter value: %d\n&quot;</span>, counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pthread_mutex_t</code> 是 POSIX 线程（也称为 pthreads）库中用于实现互斥锁（mutex）的数据类型。互斥锁是一种同步机制，用于保护共享资源免受并发访问的影响，从而避免数据竞争和不一致的状态。</p><p>互斥锁：互斥锁是一种同步原语，用于确保在任何给定时间只有一个线程可以访问特定的代码段或共享资源。</p><p>初始化与销毁：互斥锁需要先初始化才能使用，并且在不再需要时应该被销毁以释放相关资源。</p><p>加锁与解锁：通过 <code>pthread_mutex_lock()</code> 和 <code>pthread_mutex_unlock()</code> 函数来控制对临界区的访问。</p><ol><li><p><strong>初始化互斥锁</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>mutex</code>: 要初始化的互斥锁指针。</li><li><code>attr</code>: 互斥锁属性（通常可以传入 <code>NULL</code> 使用默认属性）。</li><li>返回值：成功返回 <code>0</code>，失败返回错误码。</li></ul></li><li><p><strong>销毁互斥锁</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>mutex</code>: 要销毁的互斥锁指针。</li><li>返回值：成功返回 <code>0</code>，失败返回错误码。</li></ul></li><li><p><strong>加锁</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>mutex</code>: 要加锁的互斥锁指针。</li><li>返回值：成功返回 <code>0</code>，失败返回错误码。</li></ul></li><li><p><strong>尝试加锁</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>mutex</code>: 要尝试加锁的互斥锁指针。</li><li>返回值：成功返回 <code>0</code>，如果锁已经被其他线程持有则返回 <code>EBUSY</code>，失败返回其他错误码。</li></ul></li><li><p><strong>解锁</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>mutex</code>: 要解锁的互斥锁指针。</li><li>返回值：成功返回 <code>0</code>，失败返回错误码。</li></ul></li></ol><h3 id="pthread-cond-t"><a href="#pthread-cond-t" class="headerlink" title="pthread_cond_t"></a>pthread_cond_t</h3><p>在 POSIX 线程（也称为 pthreads）中，条件变量（<code>pthread_cond_t</code>）是一种用于线程间通信的同步机制。条件变量允许一个线程等待某个条件成立，而另一个线程可以在满足条件时通知等待的线程继续执行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">int</span> fill_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> use_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    buffer[fill_ptr] = value;</span><br><span class="line">    fill_ptr = (fill_ptr + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = buffer[use_ptr];</span><br><span class="line">    use_ptr = (use_ptr + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        item = <span class="built_in">rand</span>() % <span class="number">100</span>; <span class="comment">// 生产随机数</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (count == BUFFER_SIZE) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond_var, &amp;mutex); <span class="comment">// 缓冲区满，等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">put</span>(item);</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond_var); <span class="comment">// 通知消费者</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond_var, &amp;mutex); <span class="comment">// 缓冲区空，等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        item = <span class="built_in">get</span>();</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond_var); <span class="comment">// 通知生产者</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Consumed: %d\n&quot;</span>, item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> prod_thread, cons_thread;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;cond_var, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;prod_thread, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;cons_thread, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(prod_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(cons_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;cond_var);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>初始化条件变量</strong></p><ul><li><p>```c++<br>int pthread_cond_init(pthread_cond_t <em>cond, const pthread_condattr_t </em>attr);</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">     -</span> <span class="code">`cond`</span>: 指向要初始化的条件变量。</span><br><span class="line"><span class="bullet">     -</span> <span class="code">`attr`</span>: 条件变量属性，通常设置为 <span class="code">`NULL`</span> 使用默认属性。</span><br><span class="line"><span class="bullet">     -</span> 返回值：成功返回 <span class="code">`0`</span>，错误则返回非零错误码。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> <span class="strong">**销毁条件变量**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> <span class="code">```c++</span></span><br><span class="line"><span class="code">     int pthread_cond_destroy(pthread_cond_t *cond);</span></span><br></pre></td></tr></table></figure><ul><li><code>cond</code>: 要销毁的条件变量。</li><li>返回值：成功返回 <code>0</code>，错误则返回非零错误码。</li></ul></li></ul></li></ol><p>等待和通知</p><ol><li><p><strong>等待条件变量</strong></p><ul><li><p>```c++<br>int pthread_cond_wait(pthread_cond_t <em>cond, pthread_mutex_t </em>mutex);</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">     -</span> <span class="code">`cond`</span>: 条件变量。</span><br><span class="line"><span class="bullet">     -</span> <span class="code">`mutex`</span>: 保护共享资源的互斥锁，必须是在调用前已经锁定的同一个互斥锁。</span><br><span class="line"><span class="bullet">     -</span> 功能：原子地解锁互斥锁并使当前线程进入等待状态，直到被其他线程通过 <span class="code">`pthread_cond_signal`</span> 或 <span class="code">`pthread_cond_broadcast`</span> 唤醒。唤醒后，在重新开始执行之前会自动重新获取互斥锁。</span><br><span class="line"><span class="bullet">     -</span> 返回值：成功返回 <span class="code">`0`</span>，错误则返回非零错误码。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> <span class="strong">**定时等待条件变量**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> <span class="code">```c++</span></span><br><span class="line"><span class="code">     int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);</span></span><br></pre></td></tr></table></figure><ul><li><code>cond</code>: 条件变量。</li><li><code>mutex</code>: 保护共享资源的互斥锁。</li><li><code>abstime</code>: 绝对超时时间点，使用 <code>struct timespec</code> 定义。</li><li>功能：类似于 <code>pthread_cond_wait</code>，但是它会在指定的时间过后自动返回，即使条件尚未满足。</li><li>返回值：成功返回 <code>0</code>，超时返回 <code>ETIMEDOUT</code>，其他错误则返回相应的错误码。</li></ul></li></ul></li><li><p><strong>通知单个等待线程</strong></p><ul><li><p>```c++<br>int pthread_cond_signal(pthread_cond_t *cond);</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">     -</span> <span class="code">`cond`</span>: 条件变量。</span><br><span class="line"><span class="bullet">     -</span> 功能：唤醒至少一个正在等待该条件变量的线程。如果有多个线程在等待，则具体唤醒哪一个由实现定义。</span><br><span class="line"><span class="bullet">     -</span> 返回值：成功返回 <span class="code">`0`</span>，错误则返回非零错误码。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> <span class="strong">**广播通知所有等待线程**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> <span class="code">```c++</span></span><br><span class="line"><span class="code">     int pthread_cond_broadcast(pthread_cond_t *cond);</span></span><br></pre></td></tr></table></figure><ul><li><code>cond</code>: 条件变量。</li><li>功能：唤醒所有正在等待该条件变量的线程。</li><li>返回值：成功返回 <code>0</code>，错误则返回非零错误码</li></ul></li></ul></li></ol><h2 id="异步日志写入"><a href="#异步日志写入" class="headerlink" title="异步日志写入"></a>异步日志写入</h2><p>文件读写是IO操作,会引起系统中断的耗时操作. 通过异步写入,</p><p>IO操作设计的阻塞/非阻塞与同步/异步区分:</p><ol><li><strong>阻塞 vs 非阻塞</strong>主要关注于如何处理未准备好数据的情况:是立即返回还是等待。</li><li><strong>同步 vs 异步</strong>则更多地涉及到整个I/O操作流程的设计理念:是否需要等待I/O操作完成才能继续执行。</li></ol><p>利用<strong>单例模式</strong>创建了日志类,这样每个线程都共享这个实例.</p><p>通过多线程写入文件,避免IO的阻塞.  如果使用异步写入,主线程将日志写入到一个阻塞列表,创建的读出线程读取这个阻塞列表并将内容写入文件. </p><p>这个过程涉及到生产者-消费者问题,在加入数据时,判断队列是否满,如果满则返回false表明不能再添加,同时唤醒条件变量等待的线程(也就是读取线程). 如果没满则添加数据,同时也唤醒读取线程.</p><p>当读取数据时,如果队列为空,则阻塞读取线程,释放锁,让写入线程写入阻塞列表(缓冲区). </p><p>所以异步日志创建时就会创建一个消费者线程用于读取数据并写入到文件. 设计一个缓冲区(阻塞队列),利用上面的并发同步方法,也就是一个生产者-消费者模型.</p><p>此外日志有根据日期写入到不同的文件,此外写入的行数超出要求的行数时会另外创建一个日志.</p><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>复用数据库的连接. 创建包含多个连接的连接池,初始化时根据账号密码以及数据库url创建连接存入list列表,这是个共享资源也需要使用锁进行保护. 这里使用信号量,根据连接数初始化信号量,每当获得一个连接,使用sem.wait(),信号量-1,信号量机制是当信号量为0时进行阻塞,否则减1. 当释放一个连接(将一个连接加入连接池),使用sem.post()信号量加1并唤醒阻塞线程. 对于一些共享资源,比如m_FreeConn和m_CurConn等变量进行锁保护.</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>在I/O模型中，同步I/O和异步I/O主要的区别是内核向应用程序通知的是就绪事件还是完成事件，以及是由应用程序还是由内核来完成I/O的读写操作</p><blockquote><p>同步I/O：内核向应用程序通知就绪事件，由应用程序自身来完成I/O的读写操作<br>异步I/O：由内核来完成I/O的读写后向应用程序通知完成事件 </p></blockquote><p>在并发模式中，同步和异步的主要区别是<strong><em>\</em>功能完成的流程是否是顺序化的，是否需要等待**</strong> </p><blockquote><ul><li>同步：当遇到阻塞任务时，会一直等待，直到该任务处理完成，程序完全按照代码顺序执行；</li><li>异步：程序的执行需要由系统事件驱动，程序的执行是不确定的，没有顺序上的要求 </li></ul></blockquote><h3 id="事件处理模式"><a href="#事件处理模式" class="headerlink" title="事件处理模式"></a>事件处理模式</h3><h4 id="Reactor模式和Proactor模式"><a href="#Reactor模式和Proactor模式" class="headerlink" title="Reactor模式和Proactor模式"></a>Reactor模式和Proactor模式</h4><p>​    <strong>Reactor模式</strong>是一种事件驱动的设计模式，主要用于处理并发的输入操作（如网络连接或文件I/O）。它的主要思想是<strong>将所有I/O操作分派给一个专门的事件循环来处理，这个事件循环会监听多个事件源，并在相应的事件发生时调用对应的处理器（Handler）</strong>。这种模式非常适合于需要处理大量并发连接的应用程序，比如Web服务器。</p><blockquote><p>Reactor 模式的核心是使用事件循环监听多个文件描述符（如套接字），并在事件发生时调用相应的处理器</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventHandler</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">EventHandler</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handle_event</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reactor</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    fd_set read_fds; <span class="comment">// 监听的文件描述符集合</span></span><br><span class="line">    <span class="keyword">int</span> max_fd;      <span class="comment">// 最大文件描述符</span></span><br><span class="line">    std::vector&lt;EventHandler*&gt; handlers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Reactor</span>() : <span class="built_in">max_fd</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">FD_ZERO</span>(&amp;read_fds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register_handler</span><span class="params">(<span class="keyword">int</span> fd, EventHandler* handler)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">FD_SET</span>(fd, &amp;read_fds);</span><br><span class="line">        <span class="keyword">if</span> (fd &gt; max_fd) &#123;</span><br><span class="line">            max_fd = fd;</span><br><span class="line">        &#125;</span><br><span class="line">        handlers.<span class="built_in">push_back</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run_event_loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            fd_set tmp_fds = read_fds;</span><br><span class="line">            <span class="keyword">int</span> ret = <span class="built_in">select</span>(max_fd + <span class="number">1</span>, &amp;tmp_fds, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;Select error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max_fd; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(i, &amp;tmp_fds)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> handler : handlers) &#123;</span><br><span class="line">                        handler-&gt;<span class="built_in">handle_event</span>(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadHandler</span> :</span> <span class="keyword">public</span> EventHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle_event</span><span class="params">(<span class="keyword">int</span> fd)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> bytes = <span class="built_in">read</span>(fd, buffer, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (bytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer[bytes] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Received: &quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Client disconnected.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务器套接字</span></span><br><span class="line">    <span class="keyword">int</span> server_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    sockaddr_in server_addr&#123;&#125;;</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(server_fd, <span class="keyword">reinterpret_cast</span>&lt;sockaddr*&gt;(&amp;server_addr), <span class="built_in"><span class="keyword">sizeof</span></span>(server_addr));</span><br><span class="line">    <span class="built_in">listen</span>(server_fd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    Reactor reactor;</span><br><span class="line">    ReadHandler read_handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册服务器套接字</span></span><br><span class="line">    reactor.<span class="built_in">register_handler</span>(server_fd, &amp;read_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行事件循环</span></span><br><span class="line">    reactor.<span class="built_in">run_event_loop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>Proactor模式</strong>是一种异步的事件处理模式，与Reactor模式不同，它允许操作在后台执行，当操作完成时通知应用程序。通常，Proactor模式<strong>涉及到的操作如读写文件或网络I/O都是通过操作系统提供的异步I/O服务来实现</strong>的。然而，在某些不支持异步I/O的操作系统上，<strong>可以通过同步I/O结合多线程或者回调机制来模拟Proactor模式的效果。这意味着主线程可以提交I/O操作给一个工作线程池，然后继续处理其他任务</strong>，而工作线程会在I/O操作完成后通过某种方式（例如回调函数）通知主线程</p><blockquote><p>Proactor 模式依赖于异步 I/O 操作，通常由操作系统提供支持。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proactor</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;aiocb*&gt; aio_controls; <span class="comment">// 异步 I/O 控制块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Proactor</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> cb : aio_controls) &#123;</span><br><span class="line">            <span class="keyword">delete</span> cb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start_read</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">        aiocb* cb = <span class="keyword">new</span> <span class="built_in">aiocb</span>();</span><br><span class="line">        <span class="built_in">memset</span>(cb, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(aiocb));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">        cb-&gt;aio_fildes = fd;</span><br><span class="line">        cb-&gt;aio_buf = buffer;</span><br><span class="line">        cb-&gt;aio_nbytes = <span class="built_in"><span class="keyword">sizeof</span></span>(buffer) - <span class="number">1</span>;</span><br><span class="line">        cb-&gt;aio_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        aio_controls.<span class="built_in">push_back</span>(cb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">aio_read</span>(cb) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Error starting async read.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Async read started on fd: &quot;</span> &lt;&lt; fd &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait_for_completion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> cb : aio_controls) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">aio_error</span>(cb) == EINPROGRESS) &#123;</span><br><span class="line">                <span class="built_in">usleep</span>(<span class="number">1000</span>); <span class="comment">// 等待操作完成</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">ssize_t</span> bytes = <span class="built_in">aio_return</span>(cb);</span><br><span class="line">            <span class="keyword">if</span> (bytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Async read completed. Data: &quot;</span></span><br><span class="line">                          &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(cb-&gt;aio_buf) &lt;&lt; std::endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;Async read failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开一个文件进行异步读取</span></span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Proactor proactor;</span><br><span class="line">    proactor.<span class="built_in">start_read</span>(fd); <span class="comment">// 开始异步读取</span></span><br><span class="line">    proactor.<span class="built_in">wait_for_completion</span>(); <span class="comment">// 等待完成</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>特性</th><th>Reactor 模式</th><th>Proactor 模式</th></tr></thead><tbody><tr><td><strong>核心机制</strong></td><td>同步 I/O，事件驱动</td><td>异步 I/O，操作系统支持</td></tr><tr><td><strong>适用场景</strong></td><td>高并发连接，如网络服务器</td><td>高性能 I/O 密集型应用</td></tr><tr><td><strong>复杂度</strong></td><td>较低，易于理解和实现</td><td>较高，需要操作系统支持异步 I/O</td></tr><tr><td><strong>效率</strong></td><td>受限于同步 I/O</td><td>更高效，I/O 操作在后台完成</td></tr><tr><td><strong>典型实现</strong></td><td><code>select</code>、<code>poll</code>、<code>epoll</code></td><td>POSIX AIO、Windows Overlapped I/O</td></tr></tbody></table></div><blockquote><ul><li>reactor模式中，主线程(<strong>I/O处理单元</strong>)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(<strong>逻辑单元</strong> )，读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由<strong>同步I/O</strong>实现。</li><li>proactor模式中，主线程和内核负责处理读写数据、接受新连接等I/O操作，工作线程仅负责业务逻辑，如处理客户请求。通常由<strong>异步I/O</strong>实现。</li></ul></blockquote><h3 id="并发编程模式"><a href="#并发编程模式" class="headerlink" title="并发编程模式"></a>并发编程模式</h3><h4 id="半同步-半异步模式"><a href="#半同步-半异步模式" class="headerlink" title="半同步/半异步模式"></a>半同步/半异步模式</h4><p><strong>半同步/半异步（Half-Sync/Half-Async）模式</strong>是一种设计模式，用于处理不同类型的并发任务。它通过分离同步和异步的任务处理路径，使得系统能够更高效地管理资源并提高响应速度。这种模式特别适用于那些需要同时处理同步任务（如用户界面交互）和异步任务（如后台计算或I/O操作）的应用场景.</p><p><strong>同步层（Synchronous Layer）</strong>：负责处理需要立即响应的任务，例如用户界面的交互事件。这些任务通常要求快速响应以提供良好的用户体验。</p><p><strong>队列（Queue）</strong>：作为同步层和异步层之间的桥梁，用于传递消息或任务。同步层将任务放入队列中，异步层从队列中取出任务进行处理。</p><p><strong>异步层（Asynchronous Layer）</strong>：负责执行耗时较长的任务，比如文件I/O、网络通信或者复杂的计算。这些任务不会阻塞主线程，从而保证了系统的流畅性。</p><h4 id="半同步-半反应堆模式"><a href="#半同步-半反应堆模式" class="headerlink" title="半同步/半反应堆模式"></a>半同步/半反应堆模式</h4><p><strong>半同步/半反应堆（Half-Sync/Half-Reactor）</strong>模式是一种混合的设计模式，它<strong>结合了同步和异步处理的优势来管理并发连接</strong>。这种模式通常用于服务器程序中，旨在提高系统的性能和可扩展性。</p><p><strong>Reactor部分</strong>：主要负责监听多个文件描述符（如套接字），并在相应的事件发生时（比如有新的连接请求或数据到达）通知对应的事件处理器。</p><ul><li>主线程运行一个事件循环，调用 <code>select</code>、<code>poll</code> 或者更高效的 <code>epoll</code> 等函数等待感兴趣的事件发生。</li><li>当检测到新的连接请求时，主线程接受该连接，并将其交给工作线程池中的某个线程处理。</li></ul><p><strong>Worker部分</strong>：每个工作线程独立地处理从主线程接收过来的具体连接上的读写操作。</p><ul><li>工作线程执行同步的I/O操作，这意味着它们会在读取或写入数据时阻塞，直到操作完成。</li><li>尽管如此，由于这些操作是在单独的线程中进行的，因此不会影响主线程对新连接的响应速度。</li></ul><h4 id="与半同步-半反应堆的区别"><a href="#与半同步-半反应堆的区别" class="headerlink" title="与半同步/半反应堆的区别"></a>与半同步/半反应堆的区别</h4><ul><li><strong>半同步/半反应堆</strong>：主要用于服务器程序中，其中主线程（Reactor部分）监听新的连接请求，然后将新建立的连接交给工作线程处理。这是一种专门针对网络编程的设计模式，强调的是如何有效地管理和分发多个并发连接。</li><li><strong>半同步/半异步模式</strong>：更加通用，不仅仅局限于网络编程。它可以应用于任何需要同时处理同步任务（如UI更新）和异步任务（如后台数据处理）的场景。其重点在于如何通过分离同步和异步的任务处理路径来优化系统性能和响应速度。</li></ul><p><a href="https://blog.csdn.net/qq_35423154/article/details/108930574?ops_request_misc=%7B%22request%5Fid%22%3A%22168103147416800192255531%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=168103147416800192255531&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-108930574-null-null.142^v82^insert_down1,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=半同步%2F半异步并发模式&amp;spm=1018.2226.3001.4187">Linux网络编程 | 并发模式：半同步/半异步模式、领导者/追随者模式_linux 网络编程 leadfollow模式-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/58860015">高山仰之可极，谈半同步/半异步网络并发模型 - 知乎</a></p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>五种I/O模型</p><blockquote><ul><li><strong>阻塞IO</strong>:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作</li><li><strong>非阻塞IO</strong>:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I/O执行系统调用总是立即返回，不管时间是否已经发生，若时间没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept，recv和send，事件未发生时，errno通常被设置成eagain</li><li><strong>信号驱动IO</strong>:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。</li><li><strong>IO复用</strong>:linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数</li><li><strong>异步IO</strong>:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</li></ul><p><strong>注意：阻塞I/O，非阻塞I/O，信号驱动I/O和I/O复用都是同步I/O。同步I/O指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行I/O操作，异步I/O是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成I/O操作。</strong></p></blockquote><p><strong>IO多路复用</strong>是一种允许单个进程监视多个文件描述符（如套接字、管道等）的技术，当其中任意一个文件描述符准备好进行读写操作时，该技术能够通知应用程序。这种方法可以显著提高服务器程序的性能，因为它避免了为每个连接创建单独线程或进程所带来的开销。</p><blockquote><p>单线程Polling API的常规用法是：</p><p>让Polling API监控服务端socket的状态，然后开始死循循环，循环过程中主要有三种逻辑分支：</p><ol><li>服务端socket的状态变为可读，即表示有客户端发起连接，此时就调用accept建立连接，得到一个客户端fd。将其加入到Polling API的监控集合，并标记其为可读。</li><li>客户端fd的状态变为可读，则调用read/recv从fd读取数据，然后执行业务逻辑，处理完，再将其加入到Polling API的监控集合，并标记其为可写。</li><li>客户端fd的状态变为可写，则调用write/send将数据发送给客户端。</li></ol></blockquote><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p><code>select</code>函数监视一组文件描述符，等待它们中的任何一个变为可读、可写或发生异常条件。</p><p>通过三个位图（fd_set类型）来分别表示需要监视的可读、可写及异常事件集合。</p><p>当调用<code>select</code>时，<strong>内核会阻塞当前进程，直到指定的文件描述符集合中的至少一个准备就绪</strong>。</p><p>返回值有响应的文件描述符个数.如果超时，则返回0；如果出错，则返回-1。</p><ol><li><p>在调用 <code>select</code> 之前，你需要将感兴趣的文件描述符添加到 <code>fd_set</code> 中（通过 <code>FD_SET</code>）。</p></li><li><p>当 <code>select</code> 返回时，<strong><code>fd_set</code> 中的内容会被更新，仅保留那些已经“就绪”的文件描述符</strong>。</p></li><li><p>换句话说，<code>select</code> 会清除未就绪的文件描述符，只留下那些可以进行读、写或异常处理的文件描述符。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">          fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>nfds</code>: 要监视的最大文件描述符加1。</li><li><code>readfds</code>, <code>writefds</code>, <code>exceptfds</code>: 分别指向要监视的可读、可写及异常事件的文件描述符集合。</li><li><code>timeout</code>: 等待的时间限制，若设置为NULL则无限期等待。</li></ul><ol><li><code>FD_ZERO</code></li></ol><ul><li><p><strong>功能</strong>：清空一个 <code>fd_set</code> 集合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><ol><li><code>FD_SET</code></li></ol><ul><li><p><strong>功能</strong>：将一个特定的文件描述符添加到一个 <code>fd_set</code> 集合中。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="constructor">FD_SET(<span class="params">int</span> <span class="params">fd</span>, <span class="params">fd_set</span> <span class="operator">*</span><span class="params">set</span>)</span>;</span><br></pre></td></tr></table></figure></li></ul><ol><li><code>FD_CLR</code></li></ol><ul><li><p><strong>功能</strong>：从一个 <code>fd_set</code> 集合中移除一个特定的文件描述符。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="constructor">FD_CLR(<span class="params">int</span> <span class="params">fd</span>, <span class="params">fd_set</span> <span class="operator">*</span><span class="params">set</span>)</span>;</span><br></pre></td></tr></table></figure></li></ul><ol><li><code>FD_ISSET</code></li></ol><ul><li><p><strong>功能</strong>：检查一个特定的文件描述符是否在某个 <code>fd_set</code> 集合中。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="constructor">FD_ISSET(<span class="params">int</span> <span class="params">fd</span>, <span class="params">fd_set</span> <span class="operator">*</span><span class="params">set</span>)</span>;</span><br></pre></td></tr></table></figure></li></ul><p>fd_set数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fd_set for select and pselect.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* XPG4.2 requires this member name.  Otherwise avoid the name</span></span><br><span class="line"><span class="comment">       from the global namespace.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __USE_XOPEN</span></span><br><span class="line">    <span class="comment">// __FD_SETSIZE = 1024 表示fd_set是个包含一个1024bit数组的结构体</span></span><br><span class="line">    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __FDS_BITS(set) ((set)-&gt;fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __FDS_BITS(set) ((set)-&gt;__fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125; fd_set;</span><br></pre></td></tr></table></figure><h4 id="select示例代码"><a href="#select示例代码" class="headerlink" title="select示例代码"></a>select示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">fd_set read_fds, active_fds;</span><br><span class="line"> <span class="keyword">int</span> max_fd = sockfd;</span><br><span class="line"> std::vector&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; clients_fd;</span><br><span class="line"> <span class="built_in">FD_ZERO</span>(&amp;read_fds);</span><br><span class="line"> <span class="built_in">FD_SET</span>(sockfd, &amp;read_fds);</span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="comment">// 轮询select 直到有连接</span></span><br><span class="line">   timeval timeout&#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">   read_fds = active_fds;</span><br><span class="line">   <span class="comment">// select阻塞,直到相应文件描述符就绪(可读,可写或异常)</span></span><br><span class="line">   <span class="comment">// 成功返回时(&gt;=1),fd_set内容更新,仅保留就绪的fd</span></span><br><span class="line">   <span class="keyword">int</span> ret = <span class="built_in">select</span>(max_fd + <span class="number">1</span>, &amp;read_fds, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &amp;timeout);</span><br><span class="line">   <span class="built_in">errif</span>(ret &lt; <span class="number">0</span>, <span class="string">&quot;select failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(sockfd, &amp;read_fds)) &#123;</span><br><span class="line">     <span class="comment">// 服务器可读(有connect连接)</span></span><br><span class="line">     sockaddr_in client_addr;</span><br><span class="line">     <span class="keyword">socklen_t</span> client_addr_len = <span class="built_in"><span class="keyword">sizeof</span></span>(client_addr);</span><br><span class="line">     <span class="built_in">bzero</span>(&amp;client_addr, client_addr_len);</span><br><span class="line">     <span class="keyword">int</span> client_sockfd =</span><br><span class="line">         <span class="built_in">accept</span>(sockfd, (struct sockaddr *)&amp;client_addr, &amp;client_addr_len);</span><br><span class="line">     <span class="built_in">FD_SET</span>(client_sockfd, &amp;active_fds);</span><br><span class="line">     max_fd = std::<span class="built_in">max</span>(client_sockfd, max_fd);</span><br><span class="line">     clients_fd.<span class="built_in">push_back</span>(client_sockfd);</span><br><span class="line"></span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;New connection, socket fd: &quot;</span> &lt;&lt; client_sockfd</span><br><span class="line">               &lt;&lt; <span class="string">&quot;, IP: &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(client_addr.sin_addr)</span><br><span class="line">               &lt;&lt; <span class="string">&quot;, Port: &quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(client_addr.sin_port) &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> it = clients_fd.<span class="built_in">begin</span>(); it != clients_fd.<span class="built_in">end</span>();) &#123;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> client_fd = *it;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(client_fd, &amp;read_fds)) &#123;</span><br><span class="line">       <span class="comment">//客户端可读数据</span></span><br><span class="line">       <span class="comment">// 读取数据</span></span><br><span class="line">       <span class="keyword">char</span> read_bytes[<span class="number">1024</span>]&#123;&#125;;</span><br><span class="line">       <span class="keyword">size_t</span> bytes_len = <span class="built_in">read</span>(client_fd, read_bytes, <span class="built_in"><span class="keyword">sizeof</span></span>(read_bytes));</span><br><span class="line">       <span class="keyword">if</span> (bytes_len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;client closed...\n&quot;</span>;</span><br><span class="line">         <span class="built_in">close</span>(client_fd);</span><br><span class="line">         <span class="built_in">FD_CLR</span>(client_fd, &amp;active_fds);</span><br><span class="line">         it = clients_fd.<span class="built_in">erase</span>(it);</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         std::string resp =</span><br><span class="line">             <span class="string">&quot;你好,你发送了&quot;</span> + std::<span class="built_in">string</span>(read_bytes, bytes_len);</span><br><span class="line">         <span class="built_in">errif</span>(<span class="built_in">write</span>(client_fd, resp.<span class="built_in">c_str</span>(), resp.<span class="built_in">size</span>()) == <span class="number">-1</span>,</span><br><span class="line">               <span class="string">&quot;write socket failed&quot;</span>);</span><br><span class="line">         ++it;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       ++it;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;client_fd : clients_fd) &#123;</span><br><span class="line">   <span class="comment">// 关闭所有客户端</span></span><br><span class="line">   <span class="built_in">close</span>(client_fd);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// close 关闭服务端</span></span><br><span class="line"> <span class="built_in">close</span>(sockfd);</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>支持跨平台使用，几乎所有类Unix系统都支持。</li></ul><p><strong>缺点</strong></p><ul><li><strong>文件描述符集合大小有限制</strong>（通常为1024）。</li><li>每次调用都需要重新构建文件描述符集合。</li><li>效率较低，随着监听的文件描述符数量增加性能下降明显。</li></ul><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p><code>poll</code>与<code>select</code>类似，但它使用了一个结构体数组来代替<code>select</code>中的位图。</p><p>这使得它可以处理更多数量的文件描述符，并且没有像<code>select</code>那样的固定上限。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>fds</code>: 指向一个包含多个<code>pollfd</code>结构体的数组，每个结构体描述了一个文件描述符及其感兴趣的事件。</li><li><code>nfds</code>: 数组中元素的数量。</li><li><code>timeout</code>: 等待的时间限制，单位为毫秒。</li></ul><p>pollfd数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Data structure describing a polling request.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;<span class="comment">/* File descriptor to poll.  */</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> events;<span class="comment">/* Types of events poller cares about.  */</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> revents;<span class="comment">/* Types of events that actually occurred.  */</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong><code>fd</code></strong>：要监视的文件描述符。</p></li><li><p><code>events</code></p><p>：请求监视的事件类型，可以是以下标志的组合：</p><ul><li><code>POLLIN</code>：有数据可读。</li><li><code>POLLPRI</code>：有紧急数据可读。</li><li><code>POLLOUT</code>：准备好写数据。</li><li><code>POLLRDHUP</code>（自 Linux 2.6.17 起）：TCP连接被对端关闭，或对端关闭了写入一半的连接。</li><li><code>POLLERR</code>：发生错误。</li><li><code>POLLHUP</code>：挂起。</li><li><code>POLLNVAL</code>：无效请求；指定的文件描述符无效。</li></ul></li><li><p><strong><code>revents</code></strong>：实际发生的事件，由内核在 <code>poll</code> 调用返回时填充。</p></li></ul><p>事件类型如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Event types that can be polled for.  These bits may be set in `events&#x27;</span></span><br><span class="line"><span class="comment">   to indicate the interesting event types; they will appear in `revents&#x27;</span></span><br><span class="line"><span class="comment">   to indicate the status of the file descriptor.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLIN0x001<span class="comment">/* There is data to read.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLPRI0x002<span class="comment">/* There is urgent data to read.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLOUT0x004<span class="comment">/* Writing now will not block.  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Event types always implicitly polled for.  These bits need not be set in</span></span><br><span class="line"><span class="comment">   `events&#x27;, but they will appear in `revents&#x27; to indicate the status of</span></span><br><span class="line"><span class="comment">   the file descriptor.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLERR0x008<span class="comment">/* Error condition.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLHUP0x010<span class="comment">/* Hung up.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLNVAL0x020<span class="comment">/* Invalid polling request.  */</span></span></span><br></pre></td></tr></table></figure><h4 id="poll示例代码"><a href="#poll示例代码" class="headerlink" title="poll示例代码"></a>poll示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;pollfd&gt; poll_fds;</span><br><span class="line">pollfd server_pollfd;</span><br><span class="line">server_pollfd.fd = sockfd;</span><br><span class="line">server_pollfd.events = POLLIN; <span class="comment">// 设置事件</span></span><br><span class="line">poll_fds.<span class="built_in">push_back</span>(server_pollfd);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="built_in">poll</span>(poll_fds.<span class="built_in">data</span>(), poll_fds.<span class="built_in">size</span>(), <span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">errif</span>(ret &lt; <span class="number">0</span>, <span class="string">&quot;poll error&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (poll_fds.<span class="built_in">at</span>(<span class="number">0</span>).revents &amp; POLLIN) &#123;</span><br><span class="line">    <span class="comment">// 数据读入事件</span></span><br><span class="line">    <span class="comment">// serverfd可读,即可accept</span></span><br><span class="line">    sockaddr_in client_addr&#123;&#125;;</span><br><span class="line">    <span class="keyword">socklen_t</span> addr_len = <span class="built_in"><span class="keyword">sizeof</span></span>(client_addr);</span><br><span class="line">    <span class="keyword">int</span> client_fd = <span class="built_in">accept</span>(sockfd, (struct sockaddr *)&amp;client_addr,</span><br><span class="line">                           (<span class="keyword">socklen_t</span> *)&amp;addr_len);</span><br><span class="line">    <span class="built_in">errif</span>(client_fd == <span class="number">-1</span>, <span class="string">&quot;accept failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pollfd client_pollfd;</span><br><span class="line">    client_pollfd.fd = client_fd;</span><br><span class="line">    client_pollfd.events = POLLIN;</span><br><span class="line">    poll_fds.<span class="built_in">push_back</span>(client_pollfd);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;New connection, socket fd: &quot;</span> &lt;&lt; client_fd</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, IP: &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(client_addr.sin_addr)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, Port: &quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(client_addr.sin_port) &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = poll_fds.<span class="built_in">begin</span>() + <span class="number">1</span>; it != poll_fds.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">char</span> bytes_read[<span class="number">1024</span>]&#123;&#125;;</span><br><span class="line">    pollfd &amp;client_pollfd = *it;</span><br><span class="line">    <span class="keyword">size_t</span> read_bytes_len =</span><br><span class="line">        <span class="built_in">read</span>(client_pollfd.fd, bytes_read, <span class="built_in"><span class="keyword">sizeof</span></span>(bytes_read));</span><br><span class="line">    <span class="keyword">if</span> (read_bytes_len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 关闭</span></span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;client closed...\n&quot;</span>;</span><br><span class="line">      <span class="built_in">close</span>(client_pollfd.fd);</span><br><span class="line">      it = poll_fds.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// echo</span></span><br><span class="line">      std::string resp =</span><br><span class="line">          <span class="string">&quot;你好,你的请求是&quot;</span> + std::<span class="built_in">string</span>(bytes_read, read_bytes_len);</span><br><span class="line">      <span class="built_in">write</span>(client_pollfd.fd, resp.<span class="built_in">data</span>(), resp.<span class="built_in">size</span>());</span><br><span class="line">      ++it;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 关闭所有客户端连接</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pfd : poll_fds) &#123;</span><br><span class="line">      <span class="built_in">close</span>(pfd.fd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>不受文件描述符数量的限制。</li><li>对于大量文件描述符的情况比<code>select</code>更高效。</li></ul><p><strong>缺点</strong></p><ul><li>在大量文件描述符的情况下，效率仍然不高，因为每次调用都需要遍历整个文件描述符列表。</li></ul><p>对于大量文件描述符的情况，<code>poll</code> 的性能优于 <code>select</code>，因为它不需要每次调用前都重新初始化文件描述符集合。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><ul><li><code>epoll</code>是Linux特有的高级IO多路复用机制，旨在克服<code>select</code>和<code>poll</code>的局限性。</li><li><p>它采用事件驱动的方式，只有当某个文件描述符有事件发生时才会被通知，而不是每次都检查所有文件描述符的状态。</p></li><li><p><code>epoll_create1</code>: 创建一个新的epoll实例。</p></li><li><code>epoll_ctl</code>: 向epoll实例添加、修改或删除关注的文件描述符。</li><li><code>epoll_wait</code>: 等待事件的发生。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建epoll实例</span></span><br><span class="line"><span class="comment">/* Creates an epoll instance.  Returns an fd for the new instance.</span></span><br><span class="line"><span class="comment">   The &quot;size&quot; parameter is a hint specifying the number of file</span></span><br><span class="line"><span class="comment">   descriptors to be associated with the new instance.  The fd</span></span><br><span class="line"><span class="comment">   returned by epoll_create() should be closed with close().  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Same as epoll_create but with an FLAGS parameter.  The unused SIZE</span></span><br><span class="line"><span class="comment">   parameter has been dropped.  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// 控制epoll实例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待事件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>当使用 <code>epoll_create</code> 或 <code>epoll_create1</code> 函数创建一个新的 <code>epoll</code> 实例时，<strong>Linux 内核会在内部创建一个“事件表”</strong>。<strong>这个事件表本质上是一个动态调整大小的数据结构，用来跟踪所有被注册到该 <code>epoll</code> 实例上的文件描述符及其感兴趣的事件类型</strong>（如可读、可写等）。通过这种方式，应用程序可以向内核注册多个文件描述符，并指定对每个文件描述符感兴趣的事件类型。</p></blockquote><p><strong>epoll_ctl</strong></p><ul><li><p><strong><code>epfd</code></strong>：指向由 <code>epoll_create</code> 或 <code>epoll_create1</code> 创建的 <code>epoll</code> 实例的文件描述符。</p></li><li><p><code>op</code></p><p>：指定要执行的操作类型，可以是以下值之一：</p><ul><li><strong><code>EPOLL_CTL_ADD</code></strong>：将新的文件描述符加入到 <code>epoll</code> 实例的监视列表中，并关联相应的事件。</li><li><strong><code>EPOLL_CTL_MOD</code></strong>：修改已经存在于 <code>epoll</code> 实例中的文件描述符所关注的事件。</li><li><strong><code>EPOLL_CTL_DEL</code></strong>：从 <code>epoll</code> 实例中移除一个文件描述符，不再监视其事件。</li></ul></li><li><p><strong><code>fd</code></strong>：要操作的目标文件描述符。</p></li><li><p><strong><code>event</code></strong>：指向 <code>struct epoll_event</code> 结构体的指针，包含与该文件描述符相关联的事件信息（当 <code>op</code> 是 <code>EPOLL_CTL_ADD</code> 或 <code>EPOLL_CTL_MOD</code> 时需要）。对于 <code>EPOLL_CTL_DEL</code> 操作，此参数可以为 <code>NULL</code>，因为此时仅关心移除文件描述符本身。</p></li></ul><p><strong>epoll_event结构体</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> events;<span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;<span class="comment">/* User data variable */</span></span><br><span class="line">&#125; __EPOLL_PACKED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">uint32_t</span> u32;</span><br><span class="line">  <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>events</code></strong>：</p><ul><li>表示需要监视的事件类型。</li><li>它是一个位掩码（bitmask），可以是以下标志的组合：<ul><li><strong><code>EPOLLIN</code></strong>：表示文件描述符可读（有数据可读）。</li><li><strong><code>EPOLLOUT</code></strong>：表示文件描述符可写（可以写入数据）。</li><li><strong><code>EPOLLRDHUP</code></strong>：表示对端关闭了连接或关闭了写入方向（自 Linux 2.6.17 起支持）。</li><li><strong><code>EPOLLPRI</code></strong>：表示有紧急数据可读（例如带外数据）。</li><li><strong><code>EPOLLERR</code></strong>：表示发生了错误。</li><li><strong><code>EPOLLHUP</code></strong>：表示挂起（hang up），通常表示对端关闭了连接。</li><li><strong><code>EPOLLET</code></strong>：启用边缘触发模式（Edge-Triggered, ET）。默认是水平触发模式（Level-Triggered, LT）。</li><li><strong><code>EPOLLONESHOT</code></strong>：表示事件只会触发一次，之后需要重新添加到 <code>epoll</code> 实例中。</li></ul></li></ul></li><li><p><strong><code>data</code></strong>：</p><ul><li><p>这是一个联合体（union），允许用户将任意数据与文件描述符关联起来。</p></li><li><p>定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>    *ptr;  <span class="comment">// 指针类型</span></span><br><span class="line">    <span class="keyword">int</span>      fd;   <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">uint32_t</span> u32;  <span class="comment">// 32位无符号整数</span></span><br><span class="line">    <span class="keyword">uint64_t</span> u64;  <span class="comment">// 64位无符号整数</span></span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure></li><li><p>最常见的用法是通过 <code>fd</code> 字段存储文件描述符，以便在事件触发时快速定位对应的文件描述符。</p></li></ul></li></ul><h4 id="epoll示例代码"><a href="#epoll示例代码" class="headerlink" title="epoll示例代码"></a>epoll示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> epoll_fd = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line"> <span class="built_in">errif</span>(epoll_fd == <span class="number">-1</span>, <span class="string">&quot;epoll creation failed&quot;</span>);</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">int</span> MAX_EVENTS = <span class="number">10</span>;</span><br><span class="line"> epoll_event ev, events[MAX_EVENTS];</span><br><span class="line"> ev.events = POLLIN | EPOLLET; <span class="comment">// 水平触发模式</span></span><br><span class="line"> ev.data.fd = sockfd;</span><br><span class="line"> <span class="comment">// 添加服务端fd</span></span><br><span class="line"> ret = <span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, sockfd, &amp;ev);</span><br><span class="line"> <span class="built_in">errif</span>(ret == <span class="number">-1</span>, <span class="string">&quot;ctl failed&quot;</span>);</span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="comment">// 等待事件</span></span><br><span class="line">   <span class="keyword">int</span> nfds = <span class="built_in">epoll_wait</span>(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">   <span class="built_in">errif</span>(nfds == <span class="number">-1</span>, <span class="string">&quot;epoll waut failed&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> ((events[<span class="number">0</span>].data.fd == sockfd) &amp;&amp; (events[<span class="number">0</span>].events &amp; POLLIN)) &#123;</span><br><span class="line">     <span class="comment">// accept就绪</span></span><br><span class="line">     sockaddr_in client_addr;</span><br><span class="line">     <span class="keyword">socklen_t</span> client_addr_len = <span class="built_in"><span class="keyword">sizeof</span></span>(client_addr);</span><br><span class="line">     <span class="keyword">int</span> client_fd =</span><br><span class="line">         <span class="built_in">accept</span>(sockfd, (struct sockaddr *)&amp;client_addr, &amp;client_addr_len);</span><br><span class="line">     epoll_event ev;</span><br><span class="line">     ev.events = EPOLLIN | EPOLLET; <span class="comment">// 水平触发模式</span></span><br><span class="line">     ev.data.fd = client_fd;</span><br><span class="line">     <span class="comment">// 将客户端连接加入epoll实例</span></span><br><span class="line">     ret = <span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, client_fd, &amp;ev);</span><br><span class="line">     <span class="built_in">errif</span>(ret == <span class="number">-1</span>, <span class="string">&quot;ctl failed&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAX_EVENTS; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (events[i].events &amp; POLLIN) &#123;</span><br><span class="line">       <span class="keyword">int</span> client_fd = events[i].data.fd;</span><br><span class="line">       <span class="comment">// read就绪</span></span><br><span class="line">       <span class="keyword">char</span> bytes_read[<span class="number">1024</span>]&#123;&#125;;</span><br><span class="line">       <span class="keyword">size_t</span> bytes_read_len = <span class="built_in">read</span>(client_fd, bytes_read, <span class="built_in"><span class="keyword">sizeof</span></span>(bytes_read));</span><br><span class="line">       <span class="keyword">if</span> (bytes_read_len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;client connection closed...\n&quot;</span>;</span><br><span class="line">         <span class="built_in">close</span>(client_fd);</span><br><span class="line">         <span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_DEL, client_fd, <span class="literal">nullptr</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         std::string resp =</span><br><span class="line">             <span class="string">&quot;你好,你发送了:&quot;</span> + std::<span class="built_in">string</span>(bytes_read, bytes_read_len);</span><br><span class="line">         <span class="built_in">write</span>(client_fd, resp.<span class="built_in">data</span>(), resp.<span class="built_in">size</span>());</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">     <span class="built_in">close</span>(epoll_fd);</span><br></pre></td></tr></table></figure><ul><li>默认情况下，<code>epoll</code> 使用水平触发模式（Level-Triggered, LT），即只要文件描述符处于就绪状态，<code>epoll_wait</code> 就会一直返回。</li><li>通过设置 <code>EPOLLET</code> 标志，可以启用边缘触发模式（Edge-Triggered, ET）。在这种模式下，只有当文件描述符的状态发生变化时，<code>epoll_wait</code> 才会返回。</li></ul><p><strong>优点</strong></p><ul><li>高效地管理大量文件描述符。</li><li>只返回活跃的文件描述符，减少了不必要的上下文切换。</li><li>支持边缘触发（Edge Triggered）和水平触发（Level Triggered）两种模式。</li></ul><p><strong>缺点</strong></p><ul><li>仅适用于Linux操作系统，不具有跨平台兼容性。</li></ul><p><strong>注意事项</strong></p><ol><li><strong>边缘触发模式的使用</strong>：<ul><li>在边缘触发模式下，必须一次性读取完所有可用数据，否则可能会丢失事件。</li></ul></li><li><strong>错误处理</strong>：<ul><li>示例代码中包含了基本的错误处理，在实际应用中应更全面地处理各种异常情况。</li></ul></li><li><strong>缓冲区大小</strong>：<ul><li>确保 <code>BUFFER_SIZE</code> 足够大，以避免数据截断。</li></ul></li></ol><p>​    设置epoll触发事件时可以设置水平触发(LT)和边缘触发(ET).</p><p>如果使用 LT 模式，只要文件描述符处于就绪状态（例如，对于读操作而言，意味着有数据可读），每次调用 <code>epoll_wait()</code> 都会返回该文件描述符。这意味着<strong>即使没有完全读取所有可用的数据，在后续的 <code>epoll_wait()</code> 调用中，只要还有未处理的数据，这个文件描述符仍然会被标记为就绪</strong>。</p><p>​    ET 模式仅在文件描述符的状态发生变化时触发一次通知（即从不可读变为可读或反之）。这意味着如果你在一个 <code>epoll_wait()</code> 返回后没有完全处理完所有可用的数据，<strong>那么在下一次调用 <code>epoll_wait()</code> 之前，即使文件描述符仍然处于就绪状态，也不会再次收到通知。因此，你需要确保一次性读取尽可能多的数据直到没有更多数据为止</strong>。</p><ul><li><p>选择 LT 还是 ET 主要取决于你的应用需求</p><ul><li>如果你需要简单的实现，并且对偶尔的重复通知不敏感，LT 是更好的选择。</li><li>如果你追求高性能，并且能够保证每次都能高效地处理所有数据，ET 则可能更适合。</li></ul></li><li><p>通常建议</p><ul><li>对于大多数情况，默认使用 LT 模式即可满足需求。</li><li>在需要处理大量并发连接并且希望减少系统开销的情况下，可以考虑使用 ET 模式，但需要小心处理以避免错过事件。</li></ul><h4 id="LT-模式示例"><a href="#LT-模式示例" class="headerlink" title="LT 模式示例"></a><strong>LT 模式示例</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.events = EPOLLIN;</span><br><span class="line">event.data.fd = listen_sock;</span><br><span class="line"></span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, listen_sock, &amp;event);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">epoll_wait</span>(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (events[i].data.fd == listen_sock) &#123;</span><br><span class="line">            <span class="comment">// 接受新连接...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 处理现有连接上的数据...</span></span><br><span class="line">            <span class="comment">// LT 模式下，如果有剩余数据未读，下次 epoll_wait 仍会通知</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ET-模式示例"><a href="#ET-模式示例" class="headerlink" title="ET 模式示例"></a><strong>ET 模式示例</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.events = EPOLLIN | EPOLLET; <span class="comment">// 启用 ET 模式</span></span><br><span class="line">event.data.fd = listen_sock;</span><br><span class="line"></span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, listen_sock, &amp;event);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">epoll_wait</span>(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (events[i].data.fd == listen_sock) &#123;</span><br><span class="line">            <span class="comment">// 接受新连接...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ET 模式下，需要循环读取直到 EAGAIN 或 EWOULDBLOCK</span></span><br><span class="line">            <span class="keyword">while</span> ((nread = <span class="built_in">read</span>(events[i].data.fd, buf, <span class="built_in"><span class="keyword">sizeof</span></span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 处理读取到的数据...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nread == <span class="number">-1</span> &amp;&amp; errno != EAGAIN) &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>ET 模式的特点</strong>：只会在文件描述符状态发生变化时触发一次通知，因此需要开发者确保在每次事件触发时尽可能多地处理数据。</li><li>为什么需要 <code>while</code> 循环<ul><li>确保读取所有可用数据，避免遗漏。</li><li><strong>防止因为缓冲区大小限制或数据分段到达而导致未处理的数据残留</strong>。</li><li>提高数据处理的效率和可靠性。</li></ul></li></ul></li></ul><blockquote><p>在网络编程中，特别是在高并发场景下，以下情况可能导致数据未被完全读取：</p><ul><li><strong>TCP 流的特性</strong>：<ul><li>TCP 是面向流的协议，数据是以字节流的形式传输的，而不是固定大小的消息包。接收方可能会收到部分数据，也可能收到多个消息拼接在一起的数据。</li><li>即使当前已经触发了“可读”事件，你并不能假设一次 <code>read()</code> 调用就能读取到完整的数据块。</li></ul></li><li><strong>缓冲区的限制</strong>：<ul><li>每次调用 <code>read()</code> 时，操作系统内核会将数据从内核缓冲区复制到用户空间缓冲区。如果用户空间缓冲区不足以容纳所有数据，则只能读取一部分数据。</li><li>剩余的数据仍然存在于内核缓冲区中，但在 ET 模式下，如果没有新的事件触发，这些数据将不会被通知给应用程序。</li></ul></li></ul></blockquote><div class="table-container"><table><thead><tr><th>特性</th><th><code>select</code></th><th><code>poll</code></th><th><code>epoll</code></th></tr></thead><tbody><tr><td><strong>跨平台支持</strong></td><td>是</td><td>是</td><td>否（仅Linux）</td></tr><tr><td><strong>最大文件描述符数</strong></td><td>有限制（通常是1024）</td><td>无限制</td><td>无限制</td></tr><tr><td><strong>性能</strong></td><td>随文件描述符数量增加而降低</td><td>相对较好，但仍有改进空间</td><td>非常高效，适合高并发场景</td></tr><tr><td><strong>事件通知方式</strong></td><td>轮询所有文件描述符</td><td>轮询所有文件描述符</td><td>仅通知活跃的文件描述符</td></tr></tbody></table></div><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>实现了一个定时器,定时器包括截至时间,回调函数以及client_data.</p><p>超时的时候调用回调函数,执行将fd从epoll中去除并close(fd),user_count—的操作. 并实现定时器队列,按照定时器的截至事件升序.</p><p>webserver包含多个client_data,client_data包含fd,address以及定时器用于控制超时事件.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">WebServer::WebServer() &#123;</span><br><span class="line">  <span class="comment">// http_conn类对象</span></span><br><span class="line">  users = <span class="keyword">new</span> http_conn[MAX_FD]; <span class="comment">// 为每个连接创建一个http_conn和client_data对象</span></span><br><span class="line">  <span class="comment">// 用户数据</span></span><br><span class="line">  users_timer = <span class="keyword">new</span> client_data[MAX_FD];</span><br><span class="line">  <span class="comment">// root文件夹路径</span></span><br><span class="line">  <span class="keyword">char</span> server_path[<span class="number">200</span>];</span><br><span class="line">  getcwd(server_path, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置文件根目录</span></span><br><span class="line">  <span class="keyword">char</span> root[<span class="number">6</span>] = <span class="string">&quot;/root&quot;</span>;</span><br><span class="line">  m_root = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(server_path) + <span class="built_in">strlen</span>(root) + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(m_root, server_path);</span><br><span class="line">  <span class="built_in">strcat</span>(m_root, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关书籍和资料"><a href="#相关书籍和资料" class="headerlink" title="相关书籍和资料"></a>相关书籍和资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/689466361">《Linux高性能服务器编程》</a></li><li><a href="https://www.manongbook.com/linux/681.html">Linux多线程服务端编程</a></li><li><a href="https://zhuanlan.zhihu.com/p/460399249">《TCP/IP网络编程》学习笔记 - 知乎</a></li></ul><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxNzU2MzcwMw==&amp;mid=2649274278&amp;idx=4&amp;sn=caa323faf0c51d882453c0e0c6a62282&amp;chksm=83ffbefeb48837e841a6dbff292217475d9075e91cbe14042ad6e55b87437dcd01e6d9219e7d&amp;cur_album_id=1339230165934882817&amp;scene=189#wechat_redirect">最新版Web服务器项目详解 - 02 半同步半反应堆线程池（上）</a></p><p>Unix环境高级编程</p><p>Unix网络编程</p><p>类似项目github上有很多</p><p><a href="https://github.com/forthespada/MyPoorWebServer">forthespada/MyPoorWebServer: 一款可运行的基于C++ 实现的WebServer服务器，基于《TCPIP网络编程》和《Linux高性能服务器编程》实现的服务器项目。</a></p><p><a href="https://github.com/linyacool/WebServer">linyacool/WebServer: A C++ High Performance Web Server</a></p><p><a href="https://github.com/Wlgls/30daysCppWebServer">Wlgls/30daysCppWebServer</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;经典的C++ Linux网络编程项目.&lt;br&gt;</summary>
    
    
    
    
    <category term="c++" scheme="https://www.sekyoro.top/tags/c/"/>
    
    <category term="webserver" scheme="https://www.sekyoro.top/tags/webserver/"/>
    
  </entry>
  
  <entry>
    <title>Java项目大赏(实习版)</title>
    <link href="https://www.sekyoro.top/2025/03/20/Java%E9%A1%B9%E7%9B%AE%E5%A4%A7%E8%B5%8F-%E5%AE%9E%E4%B9%A0%E7%89%88/"/>
    <id>https://www.sekyoro.top/2025/03/20/Java%E9%A1%B9%E7%9B%AE%E5%A4%A7%E8%B5%8F-%E5%AE%9E%E4%B9%A0%E7%89%88/</id>
    <published>2025-03-20T09:38:06.000Z</published>
    <updated>2025-07-24T13:09:29.308Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近在准备实习,找一些<del>烂大街</del>经典项目练练手.<br><span id="more"></span></p><h1 id="苍穹外卖"><a href="#苍穹外卖" class="headerlink" title="苍穹外卖"></a>苍穹外卖</h1><p>一个项目通常包含公共类(常量,工具以及异常)部分以及实体类部分</p><p><img data-src="https://s2.loli.net/2025/04/22/q8oS52LepZjOgHc.png" alt="image-20250422144407360"></p><p>此外还有service,controller,mapper(repository)层以及一些配置类,拦截器等</p><h4 id="Jwt登录验证"><a href="#Jwt登录验证" class="headerlink" title="Jwt登录验证"></a>Jwt登录验证</h4><ol><li>用户登录请求</li></ol><p>客户端（通常是浏览器或App）发送包含用户名和密码的登录请求到后端。</p><ol><li>服务端验证身份</li></ol><p>后端接收请求，验证用户名和密码是否正确：</p><ul><li>正确：生成 JWT，返回给客户端</li><li>错误：返回认证失败响应</li></ul><ol><li>服务端生成 JWT</li></ol><p>服务端使用 <strong>密钥</strong> 对 payload 进行签名，生成一个完整的 token：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bashCopyEditeyJhbGciOiJIUzI<span class="number">1</span><span class="symbol">NiIsInR5</span>cCI<span class="number">6</span>IkpX<span class="attr">VCJ9</span>.    <span class="attr"># Header</span></span><br><span class="line"><span class="attr">eyJ1</span>c<span class="number">2</span>VySWQiOjEyMywidX<span class="symbol">Nlcm5</span>hbWUiOiJ<span class="number">0</span>b<span class="number">20</span>iLCJleHAiOjE<span class="number">3</span>MT<span class="name">M1</span><span class="symbol">NjgwMDB9</span>.  <span class="attr"># Payload</span></span><br><span class="line"><span class="attr">SflKxwRJSMeKKF2</span>QT<span class="number">4</span>fwpMeJf<span class="number">36</span>POk<span class="number">6</span>yJV_adQssw<span class="number">5</span>c  <span class="attr"># Signature</span></span><br></pre></td></tr></table></figure><blockquote><p>服务端此后 <strong>不再保存用户状态</strong>，所有认证信息都由 token 自带。</p></blockquote><ol><li>客户端保存 JWT</li></ol><p>客户端收到 token 后，通常将其存储在：</p><ul><li><code>localStorage</code> / <code>sessionStorage</code></li><li>cookie（慎用，需设置 <code>HttpOnly</code> 和 <code>Secure</code>）</li></ul><ol><li>客户端携带 JWT 访问资源</li></ol><p>客户端每次请求受保护的资源时，在请求头中携带 token：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Authorization:</span> Bearer <span class="params">&lt;token&gt;</span></span><br></pre></td></tr></table></figure><ol><li>服务端验证 JWT</li></ol><ul><li>服务端提取 token，验证签名是否合法、是否过期。</li><li>若合法，解析 payload，拿到 <code>userId</code> 等信息，并执行业务逻辑。</li></ul><h3 id="🔐-JWT-的结构"><a href="#🔐-JWT-的结构" class="headerlink" title="🔐 JWT 的结构"></a>🔐 JWT 的结构</h3><p>JWT 是一个由三部分组成的字符串，用 <code>.</code> 分隔：</p><ol><li>Header（头部）</li></ol><p>描述签名的算法及类型，通常是这样的：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jsonCopyEdit&#123;</span></span><br><span class="line"><span class="keyword"></span>  <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Payload（有效载荷）</li></ol><p>存放业务数据，不应包含敏感信息，因为它是明文的。常见字段：</p><div class="table-container"><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td><code>sub</code></td><td>主题（Subject）</td></tr><tr><td><code>exp</code></td><td>过期时间（Expiration Time）</td></tr><tr><td><code>iat</code></td><td>签发时间（Issued At）</td></tr><tr><td><code>userId</code></td><td>自定义字段，通常是用户唯一标识</td></tr><tr><td><code>roles</code></td><td>自定义字段，表示用户权限角色</td></tr></tbody></table></div><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;userId&quot;</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;tom&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;exp&quot;</span>: <span class="number">1713568000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Signature（签名）</li></ol><p>由 header 和 payload 使用密钥 <code>secret</code> 签名生成，用于防篡改。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEditHMACSHA256(</span><br><span class="line">  <span class="name">base64UrlEncode</span>(<span class="name">header</span>) + <span class="string">&quot;.&quot;</span> + base64UrlEncode(<span class="name">payload</span>),</span><br><span class="line">  secret</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>🧾 JWT 优点</strong></p><ul><li>无需在服务端存储 Session，实现 <strong>无状态认证</strong></li><li>可跨服务、跨域使用（适合微服务）</li><li>自带用户信息，减少查库压力</li><li>易扩展，可加入权限、组织、平台等字段</li></ul><p><strong>⚠️ 安全建议</strong></p><ul><li><strong>token 不要放敏感信息</strong>（明文可读）</li><li>设置合理的 <strong>过期时间</strong></li><li>通过 <code>HTTPS</code> 传输，防止中间人攻击</li><li>使用 <code>HttpOnly + Secure</code> 的 cookie 保存（如 SSR）</li></ul><h4 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h4><p>开放接口规范有Swagger(springfox)和<strong>OpenAPI</strong>(目前常用).</p><p>可以使用springdoc-openapi或Knife4j工具通过添加注解生成规范</p><p><a href="https://github.com/springdoc/springdoc-openapi">springdoc/springdoc-openapi: Library for OpenAPI 3 with spring-boot</a></p><p><a href="https://doc.xiaominfo.com/docs/quick-start">快速开始 | Knife4j</a></p><p><img data-src="https://s2.loli.net/2025/04/22/QKmht3v8O4pyAPC.png" alt="image-20250422195017608"></p><h4 id="新增员工"><a href="#新增员工" class="headerlink" title="新增员工"></a>新增员工</h4><p>增加mapper的插入语句增加员工信息,注意插入错误处理.</p><p>以及通过interceptor,threadlocal存储登录信息.</p><h4 id="分页查询员工"><a href="#分页查询员工" class="headerlink" title="分页查询员工"></a>分页查询员工</h4><p>利用mybatis的pagehelper插件,其通过拦截执行的查询语句修改其中的LIMIT返回结果.首先设置页大小和需要查询的页.</p><ol><li><code>PageHelper.startPage(pageNum, pageSize)</code></li></ol><p>用于设置当前页码和每页条数，<strong>必须在执行查询语句之前调用</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>); <span class="comment">// 第1页，每页10条</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectAll();</span><br><span class="line">PageInfo&lt;User&gt; pageInfo = <span class="keyword">new</span> PageInfo&lt;&gt;(users);</span><br></pre></td></tr></table></figure><ol><li><code>PageHelper.offsetPage(offset, limit)</code></li></ol><p>按偏移量方式分页，适合流式加载等场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.offsetPage(<span class="number">20</span>, <span class="number">10</span>); <span class="comment">// 跳过前20条，查询10条</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectAll();</span><br></pre></td></tr></table></figure><p>然后在mapper中的sql语句中直接写查询条件,返回Page结果.</p><div class="table-container"><table><thead><tr><th>问题/注意点</th><th>说明</th></tr></thead><tbody><tr><td>startPage 必须紧跟查询语句</td><td>否则分页不起作用（建议不要有中间处理逻辑）</td></tr><tr><td>不支持多线程共享分页上下文</td><td>每次分页只作用于当前线程</td></tr></tbody></table></div><p><code>Page&lt;T&gt;</code>：继承自 <code>ArrayList&lt;T&gt;</code>，直接包含结果数据 + 分页信息；</p><p><code>PageInfo&lt;T&gt;</code>：是一个额外封装类，包含分页信息（适合返回给前端）；</p><h4 id="POJO中日期序列化"><a href="#POJO中日期序列化" class="headerlink" title="POJO中日期序列化"></a>POJO中日期序列化</h4><p><img data-src="https://s2.loli.net/2025/04/23/28JgwEfF7bZNsQz.png" alt="image-20250423140945684"></p><p>在 Spring Boot 项目中，如果你使用的是 Jackson（Spring Boot 默认的 JSON 序列化库），<strong>可以通过配置 <code>ObjectMapper</code> 或 <code>application.yml</code> 来自定义 <code>LocalDateTime</code> / <code>LocalDate</code> / <code>LocalTime</code> 的序列化格式</strong>。</p><p>✅ 方法一：在全局 <code>ObjectMapper</code> 中注册时间模块（推荐）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectMapper <span class="title">objectMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">        JavaTimeModule javaTimeModule = <span class="keyword">new</span> JavaTimeModule();</span><br><span class="line">        <span class="comment">// LocalDateTime</span></span><br><span class="line">        javaTimeModule.addSerializer(LocalDateTime.class,</span><br><span class="line">                <span class="keyword">new</span> LocalDateTimeSerializer(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));</span><br><span class="line">        javaTimeModule.addDeserializer(LocalDateTime.class,</span><br><span class="line">                <span class="keyword">new</span> LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LocalDate</span></span><br><span class="line">        javaTimeModule.addSerializer(LocalDate.class,</span><br><span class="line">                <span class="keyword">new</span> LocalDateSerializer(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>)));</span><br><span class="line">        javaTimeModule.addDeserializer(LocalDate.class,</span><br><span class="line">                <span class="keyword">new</span> LocalDateDeserializer(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LocalTime</span></span><br><span class="line">        javaTimeModule.addSerializer(LocalTime.class,</span><br><span class="line">                <span class="keyword">new</span> LocalTimeSerializer(DateTimeFormatter.ofPattern(<span class="string">&quot;HH:mm:ss&quot;</span>)));</span><br><span class="line">        javaTimeModule.addDeserializer(LocalTime.class,</span><br><span class="line">                <span class="keyword">new</span> LocalTimeDeserializer(DateTimeFormatter.ofPattern(<span class="string">&quot;HH:mm:ss&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        mapper.registerModule(javaTimeModule);</span><br><span class="line">        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); <span class="comment">// 防止序列化为时间戳</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ 方法二：使用 <code>@JsonFormat</code> 注解在字段上局部配置</p><p>适合只对个别字段格式化时使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDto</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createdTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDate date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h3><p><img data-src="https://s2.loli.net/2025/04/29/J3v6auIHbXNZxkT.png" alt="image-20250429162721846"></p><h3 id="Spring-Task"><a href="#Spring-Task" class="headerlink" title="Spring Task"></a>Spring Task</h3><p><img data-src="https://s2.loli.net/2025/04/30/iE9YtUfMhqRXn46.png" alt="image-20250430210633413"></p><h3 id="Websocket主动推送订单消息"><a href="#Websocket主动推送订单消息" class="headerlink" title="Websocket主动推送订单消息"></a>Websocket主动推送订单消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.standard.ServerEndpointExporter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerEndpointExporter <span class="title">serverEndpointExporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServerEndpointExporter 会自动扫描所有 @ServerEndpoint 注解的类。</p><p>注册到 Servlet 容器的 WebSocket 运行时（ServerContainer）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/ws/students&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentWebSocketEndpoint</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储所有连接的会话（线程安全）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;Session&gt; sessions = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        sessions.add(session);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            session.getBasicRemote().sendText(<span class="string">&quot;Connected to Student WebSocket&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 收到客户端消息，广播给所有连接</span></span><br><span class="line">        <span class="keyword">for</span> (Session s : sessions) &#123;</span><br><span class="line">            s.getBasicRemote().sendText(<span class="string">&quot;Message: &quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        sessions.remove(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session, Throwable throwable)</span> </span>&#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广播学生更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadcastStudentUpdate</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Session session : sessions) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                session.getBasicRemote().sendText(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Apache-Echarts展示信息"><a href="#Apache-Echarts展示信息" class="headerlink" title="Apache Echarts展示信息"></a>Apache Echarts展示信息</h3><h3 id="Apache-POI"><a href="#Apache-POI" class="headerlink" title="Apache POI"></a>Apache POI</h3><h1 id="黑马点评"><a href="#黑马点评" class="headerlink" title="黑马点评"></a>黑马点评</h1><p>缓存作用: 降低后端负载,提升读写速度</p><p>开发成本和维护一致性问题</p><h3 id="Redis学习"><a href="#Redis学习" class="headerlink" title="Redis学习"></a>Redis学习</h3><p><a href="https://redis.io/docs/latest/develop/clients/jedis/">Jedis guide (Java) | Docs</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化 Jedis 连接</span></span><br><span class="line">        jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>); <span class="comment">// 假设 Redis 服务运行在本地，默认端口为 6379</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Connected to Redis&quot;</span>);</span><br><span class="line">        <span class="comment">// 清空 Redis 数据库，确保测试环境干净</span></span><br><span class="line">        jedis.flushAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在每个测试方法执行之后运行</span></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 关闭 Jedis 连接</span></span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;Disconnected from Redis&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;proanimer&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">        String name = jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        jedis.hset(<span class="string">&quot;user:1&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;proanimer&quot;</span>);</span><br><span class="line">        jedis.hset(<span class="string">&quot;user:2&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;24&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/04/12/TEPKoIHGYOma4Jy.png" alt="image-20250412221454173" style="zoom: 50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisConnectionFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//配置连接池</span></span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">10</span>);</span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        jedisPoolConfig.setMaxWait(Duration.of(<span class="number">10</span>, ChronoUnit.SECONDS));</span><br><span class="line">        <span class="comment">// 创建连接池</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(jedisPoolConfig,<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h3><p><a href="https://spring.io/projects/spring-data-redis">Spring Data Redis</a></p><p><img data-src="https://s2.loli.net/2025/04/13/IPJL4xzF2aGAOfN.png" alt="image-20250413141133598" style="zoom:50%;" /></p><h4 id="序列化器"><a href="#序列化器" class="headerlink" title="序列化器"></a>序列化器</h4><p>在使用 Spring Data Redis 时，序列化器（Serializer）用于<strong>将 Java 对象转换为适合存储在 Redis 中的格式</strong>（如字节数组），并在从 Redis 读取数据时将其反序列化回 Java 对象。选择合适的序列化器对于确保数据正确性以及优化性能非常重要。默认序列化器是JDK序列化器.</p><ol><li><code>JdkSerializationRedisSerializer</code></li></ol><ul><li><strong>描述</strong>：这是默认的序列化器，使用 Java 的序列化机制来处理对象。</li><li><strong>优点</strong>：支持任意类型的 Java 对象。</li><li><strong>缺点</strong>：生成的数据较大，效率较低，并且只有在同一 JVM 环境下才能正确反序列化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">    RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    template.setConnectionFactory(factory);</span><br><span class="line">    template.setValueSerializer(<span class="keyword">new</span> JdkSerializationRedisSerializer());</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>StringRedisSerializer</code></li></ol><ul><li><strong>描述</strong>：专门用于字符串的序列化器，能够高效地处理字符串类型的数据。</li><li><strong>优点</strong>：简单、快速，适用于大多数键值对场景。</li><li><strong>缺点</strong>：仅限于字符串类型的数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, String&gt; <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">    StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">    template.setConnectionFactory(factory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>GenericJackson2JsonRedisSerializer</code></li></ol><ul><li><strong>描述</strong>：使用 Jackson 库将对象序列化为 JSON 格式。</li><li><strong>优点</strong>：易于阅读和调试，支持复杂对象结构。</li><li><strong>缺点</strong>：相对于其他二进制格式（如 Protocol Buffers），JSON 的体积更大，解析速度较慢。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">    RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    template.setConnectionFactory(factory);</span><br><span class="line">    template.setValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>Jackson2JsonRedisSerializer</code></li></ol><ul><li><strong>描述</strong>：类似于 <code>GenericJackson2JsonRedisSerializer</code>，但它允许你指定序列化的具体类型。</li><li><strong>优点</strong>：可以更精确地控制序列化过程。</li><li><strong>缺点</strong>：需要提前知道序列化对象的确切类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, MyObject&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">    RedisTemplate&lt;String, MyObject&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    template.setConnectionFactory(factory);</span><br><span class="line">    Jackson2JsonRedisSerializer&lt;MyObject&gt; serializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(MyObject.class);</span><br><span class="line">    template.setValueSerializer(serializer);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>OxmSerializer</code></li></ol><ul><li><strong>描述</strong>：用于 XML 数据的序列化/反序列化。</li><li><strong>优点</strong>：适用于需要以 XML 格式存储数据的场景。</li><li><strong>缺点</strong>：XML 数据通常比 JSON 更大，处理速度也较慢。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">    RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    template.setConnectionFactory(factory);</span><br><span class="line">    OxmSerializer serializer = <span class="keyword">new</span> Jaxb2Marshaller(); <span class="comment">// 示例使用 JAXB</span></span><br><span class="line">    template.setValueSerializer(serializer);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>自定义序列化器</li></ol><p>根据业务需求，你也可以实现自己的序列化器，只需要实现 <code>RedisSerializer&lt;T&gt;</code> 接口即可。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRedisSerializer</span> <span class="keyword">implements</span> <span class="title">RedisSerializer</span>&lt;<span class="title">MyCustomType</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(MyCustomType t) <span class="keyword">throws</span> SerializationException &#123;</span><br><span class="line">        <span class="comment">// 实现序列化逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyCustomType <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> SerializationException </span>&#123;</span><br><span class="line">        <span class="comment">// 实现反序列化逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在配置中使用自定义序列化器</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, MyCustomType&gt; <span class="title">customRedisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">    RedisTemplate&lt;String, MyCustomType&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    template.setConnectionFactory(factory);</span><br><span class="line">    template.setValueSerializer(<span class="keyword">new</span> CustomRedisSerializer());</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/04/13/VKJzFQulyvWTSfa.png" alt="image-20250413160821439"></p><h3 id="基于Session的登陆"><a href="#基于Session的登陆" class="headerlink" title="基于Session的登陆"></a>基于Session的登陆</h3><p><img data-src="https://s2.loli.net/2025/03/20/VqbA8F34U17C9xZ.png" alt="image-20250320175751672"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">sendCode</span><span class="params">(String phone, HttpSession session)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        1.校验</span></span><br><span class="line">      <span class="comment">/*  String phoneRegex = &quot;^1[3-9]\\d&#123;9&#125;$&quot;;</span></span><br><span class="line"><span class="comment">        if (!phone.matches(phoneRegex)) &#123;</span></span><br><span class="line"><span class="comment">            return Result.fail(&quot;手机号格式错误&quot;);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">boolean</span> phoneInvalid = RegexUtils.isPhoneInvalid(phone);</span><br><span class="line"><span class="comment">//        2.如果不符合</span></span><br><span class="line">        <span class="keyword">if</span> (phoneInvalid) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        3.符合,生成验证码</span></span><br><span class="line">        String code = RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"><span class="comment">//        4.保存验证码到session</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;code&quot;</span>, code);</span><br><span class="line"><span class="comment">//        5.发送验证码</span></span><br><span class="line">        log.debug(StrUtil.format(<span class="string">&quot;发送验证码成功，验证码：&#123;&#125;&quot;</span>, code));</span><br><span class="line"><span class="comment">//        返回ok</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        1.校验手机号和验证码</span></span><br><span class="line">        String phone = loginForm.getPhone();</span><br><span class="line">        <span class="keyword">boolean</span> phoneInvalid = RegexUtils.isPhoneInvalid(phone);</span><br><span class="line">        <span class="keyword">if</span> (phoneInvalid) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String code = loginForm.getCode();</span><br><span class="line">        String codeInSession = (String) session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!code.equals(codeInSession)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        2.查询用户</span></span><br><span class="line">        User user = query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//            不存在 创建用户</span></span><br><span class="line">            user = createUserWithPhone(phone);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        3.保存用户信息到session</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;user&quot;</span>, BeanUtil.copyProperties(user, UserDTO.class));</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> User <span class="title">createUserWithPhone</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setPhone(phone);</span><br><span class="line">        user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomNumbers(<span class="number">8</span>));</span><br><span class="line">        save(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注册登录问题,可以使用拦截器方便注册登陆以及校验权限,  从基于session到基于redis</p><p>基于session的登陆, 验证码存在session中,在拦截器中获取session或者请求头中的信息,</p><p>可以使用ThreadLocal,在拦截器方法中存储用户信息避免其他线程访问. 登陆成功将发送生成的token给客户端,并且存在服务端session中.</p><p>每次访问,在进行权限校验中,根据token在session得到用户信息,如果有就通过权限校验.</p><p>通过重写WebMvcConfigure类添加拦截器与路径,重写Interceptor类</p><blockquote><p>WebMvcConfigure类可以用于添加拦截器与静态资源处理以及CORS等等.</p><p>Interceptor类允许你在请求被 <strong>Controller 处理之前</strong>、<strong>Controller 处理之后但在视图渲染之前</strong>、以及<strong>整个请求处理完成之后</strong>进行拦截和处理。它提供了一种灵活的方式来对请求进行预处理和后处理，而无需修改 Controller 或业务逻辑代码。</p><p><code>HandlerInterceptor</code> 的主要作用是实现 AOP（面向切面编程）的理念，对 Web 请求处理流程进行<strong>横向切割</strong>，用于实现一些通用的功能，例如：</p><ol><li><strong>权限校验/身份认证：</strong> 在请求到达 Controller 之前，检查用户是否已登录或是否有权限访问某个资源。</li><li><strong>日志记录：</strong> 记录请求的进入、退出时间，以及请求参数、响应状态等信息。</li><li><strong>性能监控：</strong> 计算请求的处理时间，进行性能分析。</li><li><strong>数据预处理：</strong> 在 Controller 处理之前对请求参数进行一些统一的格式化或校验。</li><li><strong>跨域处理：</strong> 添加或修改响应头，处理 CORS 相关的逻辑。</li><li><strong>国际化：</strong> 根据用户请求的语言设置，切换对应的语言环境。</li><li><strong>会话管理：</strong> 检查会话状态，或进行会话续期。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的token</span></span><br><span class="line">        String token = request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.基于TOKEN获取redis中的用户</span></span><br><span class="line">        String key  = LOGIN_USER_KEY + token;</span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">        <span class="comment">// 3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.将查询到的hash数据转为UserDTO</span></span><br><span class="line">        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> UserDTO(), <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 6.存在，保存用户信息到 ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">// 7.刷新token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 8.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="集群的session共享问题"><a href="#集群的session共享问题" class="headerlink" title="集群的session共享问题"></a>集群的session共享问题</h4><p><img data-src="https://s2.loli.net/2025/04/14/xZREAUpPzkQBiVF.png" alt="image-20250414154105418"></p><h4 id="基于Redis的短信登陆"><a href="#基于Redis的短信登陆" class="headerlink" title="基于Redis的短信登陆"></a>基于Redis的短信登陆</h4><p><img data-src="https://s2.loli.net/2025/04/14/bVvPz25pxkyMqB9.png" alt="image-20250414161242250"></p><p>基于session的问题  多台tomcat不共享session</p><p>使用基于redis的登陆注册</p><p>当登陆时，如果使用账号+手机验证码形式，当前端发送验证码请求，将手机号码和生成的手机验证码存在对应的缓存中，然后登陆时校验。成功就返回一个token，然后将token存在缓存中.可以使用user_id作key.   </p><p>  在使用session登陆时,存储信息直接利用了servlet,tomcat提供的session机制,服务器会创建对应会话的session并返回JSESSIONID给客户端,客户端会主动携带该id,服务器直接访问对应的session对象及其包含属性即可.</p><p>而使用redis登陆,确定缓存的值对象类型</p><p><img data-src="https://s2.loli.net/2025/07/15/5lLUKEwJnexXoua.png" alt="image-20250715141126358"></p><p>当进入用户权限网页时,读取httpservletRequest中的参数,从请求中获取token,在缓存中查找,找到就满足.  客户端将token放在sessionStorage中进行保存,请求时放在header中的<code>authorization</code>头中,服务端在对应请求头中拿到token.</p><h4 id="优化拦截器"><a href="#优化拦截器" class="headerlink" title="优化拦截器"></a>优化拦截器</h4><p><img data-src="https://s2.loli.net/2025/04/14/36voF12n9YepEkI.png" alt="image-20250414210106336"></p><p>原本的拦截器只拦截需要权限的controller,但是如果已经有cookie的用户只访问不需要权限的controller就不会更新redis.   也就是说已登陆用户访问不需要权限的网页不会更新缓存,导致一段时间后失效.</p><p><img data-src="https://s2.loli.net/2025/04/14/sUTIzrhMgqNpR7H.png" alt="image-20250414210226312"></p><p>因此添加全局拦截器,访问所有页面,如果是已登陆用户,更新缓存中TTL,否则什么也不做,直接放行,对于需要权限的拦截器进行检测.</p><h4 id="登陆以及权限校验关键问题"><a href="#登陆以及权限校验关键问题" class="headerlink" title="登陆以及权限校验关键问题"></a>登陆以及权限校验关键问题</h4><p><strong>基于session或者基于redis缓存</strong></p><p>session存在tomcat集群不共享的问题,当请求切换到不同tomcat服务时导致数据丢失</p><p><strong>拦截器配置  通过interceptor或者自己通过AOP实现校验</strong></p><p>通过拦截器,在请求或者session中拿到校验信息</p><p>可以使用ThreadLocal在拦截器中直接在session或者redis中获得信息</p><p><strong>此外还有基于JWT的无状态认证机制,服务器本身不存储session.</strong></p><p>在登陆成功后,客户端每次携带jwt,JWT本身存储了用户的一些关键信息,具体来说,JWT包含头部,负载,签名.</p><p>头部包含算法类型,负载包括注册声明、公共声明以及私有声明. 签名是通过密钥加密后的头部和负载加密. </p><blockquote><p>Payload 部分是 Base64url 编码的，不是加密的。这意味着任何人都可以解码 Payload 并读取其中的内容。因此，绝不能在 Payload 中存放敏感信息</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>,</span><br><span class="line">  </span><br><span class="line">   <span class="attr">&quot;sub&quot;</span>: <span class="string">&quot;user_123&quot;</span>,        <span class="comment">// 用户ID</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Alice Smith&quot;</span>,    <span class="comment">// 用户名</span></span><br><span class="line">  <span class="attr">&quot;roles&quot;</span>: [<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;user&quot;</span>], <span class="comment">// 用户角色</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span>: <span class="number">1752496261</span>,        <span class="comment">// 过期时间戳</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span>: <span class="number">1752492661</span>         <span class="comment">// 签发时间戳  //注意这些部分都会进行base64编码</span></span><br><span class="line">  </span><br><span class="line">  <span class="string">&quot;signature&quot;</span>:HMACSHA256(base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> + base64UrlEncode(payload), secret) <span class="comment">//使用 Header 中指定的算法（如 HS256 或 RS256）和服务器端的密钥 (Secret Key)（对于对称加密，如 HS256）或私钥（对于非对称加密，如 RS256）对连接后的字符串进行签名。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，这三部分用点连接起来，就构成了完整的 JWT 字符串，例如： <code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</code></p><h3 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h3><p><img data-src="https://s2.loli.net/2025/04/14/HTdpXizlnASGQqv.png" alt="image-20250414220321389"></p><p><img data-src="https://s2.loli.net/2025/04/14/jc9OQH8oFwMLz5K.png" alt="image-20250414233753517"></p><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p><img data-src="https://s2.loli.net/2025/04/15/p72NIzH9MfZaxnR.png" alt="image-20250415103603707"></p><p><img data-src="https://s2.loli.net/2025/04/15/y7bowaDxTL2f8GJ.png" alt="image-20250415103926298"></p><div class="table-container"><table><thead><tr><th>策略</th><th>读操作</th><th>写操作</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>Cache Aside</strong></td><td>先查缓存，再查数据库</td><td>更新数据库后删除缓存</td><td>简单、灵活、一致性较好</td><td>存在短暂不一致、未命中时性能较差</td><td>数据读多写少、一致性要求不高</td></tr><tr><td><strong>Read/Write Through</strong></td><td>缓存负责未命中处理</td><td>缓存负责同步到数据库</td><td>透明性好、一致性好</td><td>复杂性高、可能成为性能瓶颈</td><td>数据一致性要求高</td></tr><tr><td><strong>Write Behind Caching</strong></td><td>先查缓存，再查数据库</td><td>异步批量写回数据库</td><td>写性能高、吞吐量大</td><td>数据丢失风险、一致性差</td><td>数据写多读少、一致性要求低</td></tr></tbody></table></div><p><img data-src="https://s2.loli.net/2025/04/15/TU3KbireNcB4G67.png" alt="image-20250415105910579"></p><p><img data-src="https://s2.loli.net/2025/04/15/CFEZY2mKqnwljAW.png" alt="image-20250415111429325"></p><p><img data-src="https://s2.loli.net/2025/04/15/LqgUJKSZD9Gfad6.png" alt="image-20250415111703513"></p><div class="table-container"><table><thead><tr><th>名称</th><th>触发场景</th><th>结果</th><th>常见解决方案</th></tr></thead><tbody><tr><td>缓存穿透</td><td>请求的数据本就不存在（DB 也无）</td><td>每次请求都打到数据库</td><td>缓存空值、布隆过滤器</td></tr><tr><td>缓存击穿</td><td>某个热点 key 恰好过期了</td><td>大量请求同时访问 DB，瞬时压力大</td><td>加互斥锁、热点预热</td></tr><tr><td>缓存雪崩</td><td>大量 key 在同一时间过期</td><td>缓存失效，数据库压力激增</td><td>加随机过期时间、限流、降级</td></tr></tbody></table></div><p>布隆过滤器是基于一个 <strong>bit 数组</strong> + 多个 <strong>哈希函数</strong>：</p><ol><li>初始创建一个很大的 bit 数组（如 1 亿位，全是 0）。</li><li>插入元素时，用多个哈希函数对元素哈希，得到多个下标位置，把这些位置设为 1。</li><li>查询时，对待查元素用相同的哈希函数求下标：<ul><li>若所有对应 bit 位都是 1 → 可能存在</li><li>有任意一个 bit 是 0 → 一定不存在</li></ul></li></ol><p><img data-src="https://s2.loli.net/2025/04/15/MozbdO6Ly2aCI4E.png" alt="image-20250415133050673"></p><p><img data-src="https://s2.loli.net/2025/04/15/aujZnwSzgiUxloL.png" alt="image-20250415143221507"></p><p><img data-src="https://s2.loli.net/2025/04/15/xBTlfUn6WmDpwIJ.png" alt="image-20250415144016106"></p><p><img data-src="https://s2.loli.net/2025/04/15/Tcd5tCruUKo6wvM.png" alt="image-20250415144408811"></p><p><img data-src="https://s2.loli.net/2025/04/15/x5ayubhtcrSK8qQ.png" alt="image-20250415144944179"></p><p><img data-src="https://s2.loli.net/2025/04/15/EBpdcml8I7tLvxU.png" alt="image-20250415145118864"></p><h3 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h3><p>全局ID生成器,在分布式系统下用来生成全局唯一ID的工具.</p><p>满足:唯一性,高可用,高性能,递增性,安全性.</p><p><img data-src="https://s2.loli.net/2025/04/15/3LSmM7p8e5gfXcN.png" alt="image-20250415194042557"></p><p><img data-src="https://s2.loli.net/2025/04/15/tXm5rvyNMhbxeYL.png" alt="image-20250415231649294" style="zoom:67%;" /></p><p><img data-src="https://s2.loli.net/2025/04/16/zTXyB8Uo7RKWmc2.png" alt="image-20250416162534054" style="zoom:67%;" /></p><h4 id="悲观锁-乐观锁"><a href="#悲观锁-乐观锁" class="headerlink" title="悲观锁  乐观锁"></a>悲观锁  乐观锁</h4><p><img data-src="https://s2.loli.net/2025/04/16/9QRuCerNJpmcHaf.png" alt="image-20250416192913692"></p><p>乐观锁的关键是判断之前查询得到的数据是否被修改过.常见方式:</p><ol><li>版本号法</li></ol><p>给数据添加版本号,每次更新的时候查询数据对应的版本,如果版本号跟之前的不同则表明更新过了. </p><p><img data-src="https://s2.loli.net/2025/04/16/3tu9mqXVNyoDZYT.png" alt="image-20250416194812142"></p><ol><li>CAS法</li></ol><p><img data-src="https://s2.loli.net/2025/04/16/eCKmRn4QDs7pSLA.png" alt="image-20250416212059026" style="zoom:67%;" /></p><p>一人一单,使用悲观锁,加锁. 但在分布式系统下,多个实例下进程不相干,无法进行线程同步,需要实现分布式锁.</p><p>分布式锁:满足分布式系统或集群模式下多进程可见并且互斥的锁</p><p><img data-src="https://s2.loli.net/2025/04/17/t4sZY1NizPOvRcX.png" alt="image-20250417095719500"></p><p>基于Redis的分布式锁</p><p>使用<code>setnx</code></p><p><img data-src="https://s2.loli.net/2025/04/17/JBC3Xe1HPmpfnwa.png" alt="image-20250417124148443"></p><p>注意如果出现业务耗时超过key的ttl,导致其他线程拿到锁,在删除锁时检查value是否一致。</p><p>redis lua脚本</p><p><img data-src="https://s2.loli.net/2025/04/17/X7GMsSg59QjnaRf.png" alt="image-20250417133641854"></p><p><img data-src="https://s2.loli.net/2025/04/17/AG1vHk7s2u6FexB.png" alt="image-20250417143320701"></p><h4 id="Redisson可重入锁"><a href="#Redisson可重入锁" class="headerlink" title="Redisson可重入锁"></a>Redisson可重入锁</h4><p><img data-src="https://s2.loli.net/2025/04/17/2jkGcgNIYylmQL8.png" alt="image-20250417152425433"></p><h4 id="可重试-更新超时时间"><a href="#可重试-更新超时时间" class="headerlink" title="可重试/更新超时时间"></a>可重试/更新超时时间</h4><p><img data-src="https://s2.loli.net/2025/04/17/lytxPu8ZirBRH5s.png" alt="image-20250417181249028"></p><p><img data-src="https://s2.loli.net/2025/04/17/EYhwIoeVBgmkHfU.png" alt="image-20250417181558824"></p><p>所以利用redis缓存作分布式锁的需要核心解决的<strong>可重入</strong>和<strong>超时重试机制</strong>.</p><h4 id="主从一致性问题"><a href="#主从一致性问题" class="headerlink" title="主从一致性问题"></a>主从一致性问题</h4><p>一、单机多实例（适合开发和测试环境）</p><p>配置不同的实例端口,多个配置文件启动多个实例.</p><p>二、多机集群,在每台服务器上创建一个 Redis 配置文件（如 <code>redis-cluster.conf</code>），并添加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><ul><li><code>cluster-enabled yes</code>：启用集群模式。</li><li><code>cluster-config-file nodes.conf</code>：指定集群节点配置文件。</li><li><code>cluster-node-timeout 5000</code>：设置节点超时时间（毫秒）</li></ul><p><img data-src="https://s2.loli.net/2025/04/17/UiIyGpJA4RoP7Dh.png" alt="image-20250417232039727"></p><p><img data-src="https://s2.loli.net/2025/04/18/cn3NCI9O24upUlg.png" alt="image-20250418111401540"></p><p><img data-src="https://s2.loli.net/2025/04/18/IRiKpLMBV1cCUs3.png" alt="image-20250418143910127"></p><p><img data-src="https://s2.loli.net/2025/04/18/bS3QAUKsTHoRY1q.png" alt="image-20250418182224084"></p><h4 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h4><p><img data-src="https://s2.loli.net/2025/04/18/ayrfSevJ8TdGUF3.png" alt="image-20250418200244539"></p><h4 id="基于list数据结构"><a href="#基于list数据结构" class="headerlink" title="基于list数据结构"></a>基于list数据结构</h4><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）一个列表最多可以包含 2^32^ -1个元素。主要利用<code>BRPOP</code>移除列表元素,如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止. 同时通过<code>LPUSH</code>添加值.</p><p><img data-src="https://s2.loli.net/2025/04/18/9ih5CDwLBlKNERW.png" alt="image-20250418203901472"></p><h5 id="pubsub-点对点消息消息模型"><a href="#pubsub-点对点消息消息模型" class="headerlink" title="pubsub 点对点消息消息模型"></a>pubsub 点对点消息消息模型</h5><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p><p>Redis 客户端可以订阅任意数量的频道。</p><p><img data-src="https://www.runoob.com/wp-content/uploads/2014/11/pubsub2.png" alt="img"></p><p><img data-src="https://www.runoob.com/wp-content/uploads/2014/11/pubsub1.png" alt="img"></p><p><img data-src="https://s2.loli.net/2025/04/18/7LEADu5klUBta8Q.png" alt="image-20250418210559430"></p><p><img data-src="https://s2.loli.net/2025/04/18/2lE9g7iU3WBpsIy.png" alt="image-20250418210832702"></p><h5 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h5><p>Redis Stream 是 Redis 5.0 版本新增加的数据结构。</p><p>Redis Stream 主要用于消息队列(MQ，Message Queue),Redis 本身是有一个 Redis 发布订阅 (pub/sub) 来实现消息队列的功能，但它有个缺点就是消<strong>息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃</strong>。</p><p>简单来说发布订阅 (pub/sub) 可以分发消息，但<strong>无法记录历史消息。</strong></p><p><strong>而 Redis Stream 提供了消息的持久化和主备复制功能</strong>，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p><p><img data-src="https://www.runoob.com/wp-content/uploads/2020/09/en-us_image_0167982791.png" alt="img"></p><ul><li><strong>Stream</strong>: 在 Redis 中，一个 Stream 就是一个追加日志类型的键值对集合。</li><li><strong>Entry</strong>: 每个流中的元素称为 Entry 或者 Message，由唯一标识符（ID）和数据字段组成。</li><li><strong>Consumer Group</strong>: 允许不同的消费者组从同一个流中读取消息，每个组可以独立地跟踪自己已经消费的消息位置。</li><li><strong>ID</strong>: 每条消息都有一个唯一的 ID，格式为 <code>&lt;timestamp&gt;-&lt;sequence&gt;</code>，其中时间戳是消息添加时的时间，序列号用于区分同一毫秒内添加的消息。</li></ul><p><img data-src="https://s2.loli.net/2025/04/18/N41xhBcZ6qTWUiG.png" alt="image-20250418223626722"></p><p><img data-src="https://s2.loli.net/2025/04/18/JE9ZNCxDHaBWpw1.png" alt="image-20250418224505431" style="zoom: 33%;" /></p><h5 id="基于Stream的消息队列-消费者组"><a href="#基于Stream的消息队列-消费者组" class="headerlink" title="基于Stream的消息队列-消费者组"></a>基于Stream的消息队列-消费者组</h5><p><img data-src="https://s2.loli.net/2025/04/18/oTspnQeVrkqgOcv.png" alt="image-20250418225321965"></p><p>给消费者分类,消息漏读,消息确认避免消息丢失.</p><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>XADD</code></td><td>添加消息到 Stream</td></tr><tr><td><code>XRANGE</code> / <code>XREVRANGE</code></td><td>范围读取消息（正/反向）</td></tr><tr><td><code>XREAD</code></td><td>阻塞或非阻塞读取消息</td></tr><tr><td><code>XGROUP CREATE</code></td><td>创建消费者组</td></tr><tr><td><code>XREADGROUP</code></td><td>按消费者组读取消息</td></tr><tr><td><code>XACK</code></td><td>确认消息已处理</td></tr><tr><td><code>XPENDING</code></td><td>查看待处理（未 ack）消息</td></tr><tr><td><code>XDEL</code></td><td>删除指定消息</td></tr><tr><td><code>XTRIM</code></td><td>裁剪旧消息，控制 Stream 大小</td></tr><tr><td><code>XLEN</code></td><td>获取 Stream 长度</td></tr><tr><td><code>XINFO</code></td><td>获取 Stream / Consumer 详细信息</td></tr></tbody></table></div><h4 id="创建组"><a href="#创建组" class="headerlink" title="创建组"></a>创建组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATE mystream mygroup $ MKSTREAM</span><br></pre></td></tr></table></figure><blockquote><p>创建名为 <code>mygroup</code> 的消费者组，<code>$</code> 从最新消息开始消费，<code>MKSTREAM</code> 可自动创建 Stream。</p></blockquote><h4 id="读取消息"><a href="#读取消息" class="headerlink" title="读取消息"></a>读取消息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP mygroup consumer1 COUNT 2 STREAMS mystream &gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>&gt;</code> 表示读取尚未分配的消息（新消息）。</p></blockquote><h4 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XACK mystream mygroup 1686900000000-0</span><br></pre></td></tr></table></figure><h4 id="查看未确认消息"><a href="#查看未确认消息" class="headerlink" title="查看未确认消息"></a>查看未确认消息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XPENDING mystream mygroup</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>XINFO STREAM mystream</code></td><td>查看 stream 本体信息</td></tr><tr><td><code>XINFO GROUPS mystream</code></td><td>查看所有消费者组信息</td></tr><tr><td><code>XINFO CONSUMERS mystream mygroup</code></td><td>查看某个消费者组中各个消费者状态</td></tr></tbody></table></div><p><img data-src="https://s2.loli.net/2025/04/18/sVrCm1K7YTewhaq.png" alt="image-20250418233032176"></p><p>消费者组中的多消费者争抢消息体现在</p><p>在 Redis Stream 中使用 <strong>消费者组（Consumer Group）</strong> 时，有个关键的机制是：</p><blockquote><p>➤ <strong>同一个消费者组内，一个消息只会被分配给一个消费者处理。</strong></p></blockquote><p>这意味着：</p><ul><li><p>如果消费者 A <strong>已经读取并 ack（确认）了一条消息</strong>，那么：</p><ul><li>同组内的消费者 B 是 <strong>无法再读取这条消息</strong> 的。</li><li>除非你专门指定消息 ID 重新读取（例如用 <code>XREADGROUP</code> + 指定 ID）。</li></ul></li><li><p>如果你希望 <strong>消费者 B</strong> 能“读到之前被其他消费者已处理的消息”，你必须显式指定 ID，并该消息<strong>未被 ack</strong>或使用 <code>XPENDING</code> 查找。</p><h5 id="✅如何让消费者读取“历史消息”？"><a href="#✅如何让消费者读取“历史消息”？" class="headerlink" title="✅如何让消费者读取“历史消息”？"></a>✅如何让消费者读取“历史消息”？</h5><p>场景 1：消息还未被 ack（pending）</p><p>可以通过 <code>XPENDING</code> + <code>XCLAIM</code> 把消息“抢过来”：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEditPendingMessages pending = stringRedisTemplate.ops<span class="constructor">ForStream()</span></span><br><span class="line">    .pending(<span class="string">&quot;mystream&quot;</span>, <span class="string">&quot;mygroup&quot;</span>, <span class="module-access"><span class="module"><span class="identifier">Range</span>.</span></span>unbounded<span class="literal">()</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (PendingMessage message : pending) &#123;</span><br><span class="line">    <span class="comment">// 把未 ack 的消息交给当前消费者</span></span><br><span class="line">    List&lt;MapRecord&lt;String, Object, Object&gt;&gt; records = stringRedisTemplate.ops<span class="constructor">ForStream()</span>.claim(</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Consumer</span>.</span></span>from(<span class="string">&quot;mygroup&quot;</span>, <span class="string">&quot;consumer2&quot;</span>),</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Duration</span>.</span></span><span class="keyword">of</span><span class="constructor">Seconds(5)</span>,</span><br><span class="line">        message.get<span class="constructor">Id()</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景 2：消息已被 ack，想重复读取</p><p>Redis 默认设计下是不会让你“重复消费”被 ack 的消息的，<strong>但你可以手动读取它（不是 group 模式）</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用消费者组，直接用 XREAD + ID</span></span><br><span class="line">List&lt;MapRecord&lt;String, Object, Object&gt;&gt; records = stringRedisTemplate.opsForStream()</span><br><span class="line">    .read(StreamOffset.fromStart(<span class="string">&quot;mystream&quot;</span>)); <span class="comment">// 或者用具体 ID</span></span><br></pre></td></tr></table></figure><p>也可以用 <code>XRANGE</code> 来精确读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取某条历史消息</span></span><br><span class="line">stringRedisTemplate.opsForStream()</span><br><span class="line">    .range(<span class="string">&quot;mystream&quot;</span>, Range.closed(<span class="string">&quot;1682390889639-0&quot;</span>, <span class="string">&quot;1682390889639-0&quot;</span>));</span><br></pre></td></tr></table></figure><p>| 场景                                | 是否能重新读取                 |<br>| —————————————————- | ——————————————— |<br>| 消费者组内，消息已被 ack            | ❌（除非用非 group 方式手动读） |<br>| 消费者组内，消息未被 ack（pending） | ✅（可以用 XCLAIM 抢回来）      |<br>| 想让多个消费者都能读一条消息        | ❌（组内不支持；需非 group 读） |</p></li></ul><p><img data-src="https://s2.loli.net/2025/04/18/ay8uA5fSi3RvTMV.png" alt="image-20250418233143096"></p><p><img data-src="https://s2.loli.net/2025/04/19/4rg9LteAzoDlaWb.png" alt="image-20250419131039088" style="zoom:50%;" /></p><p><img data-src="https://s2.loli.net/2025/04/19/muwJasz9gGTxAHK.png" alt="image-20250419131059130"></p><h3 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h3><h4 id="点赞功能"><a href="#点赞功能" class="headerlink" title="点赞功能"></a>点赞功能</h4><p><img data-src="https://s2.loli.net/2025/04/20/p92Zqc4evEjimXY.png" alt="image-20250420143555600"></p><h4 id="点赞排行榜"><a href="#点赞排行榜" class="headerlink" title="点赞排行榜"></a>点赞排行榜</h4><p><img data-src="https://s2.loli.net/2025/04/20/Y2jI3QHEemkOBvi.png" alt="image-20250420144640978"></p><h4 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h4><p>写两个接口,一个查看是否关注,另一个进行关注或取关.</p><p>关注的数据表设计为user_id和follower_id. 为一个关注记录</p><p><img data-src="https://s2.loli.net/2025/04/20/OqkUF4G21LYZM5K.png" alt="image-20250420200822771"></p><p><img data-src="https://s2.loli.net/2025/04/20/hNcu5avy2WmPBMk.png" alt="image-20250420200856032"></p><h4 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h4><p><img data-src="https://s2.loli.net/2025/04/20/thV71ZUKQlaqs3i.png" alt="image-20250420200600057"></p><p>在新增关注时添加缓存,同时利用redis中的set交集操作在缓存中得到共同关注</p><h4 id="关注推送"><a href="#关注推送" class="headerlink" title="关注推送"></a>关注推送</h4><p><img data-src="https://s2.loli.net/2025/04/20/gCqrxOB86TdfhLb.png" alt="image-20250420220334492"></p><p><img data-src="https://s2.loli.net/2025/04/21/8wXL5PpFBWu1c6K.png" alt="image-20250421092155097"></p><p>通过推模式,通过分页滚动读取关注用户发布的博客数据. 用户发布博客时将博客id加入关注自己的粉丝的收件箱, 使用sorted set,以时间戳为score(即推模式)</p><p><img data-src="https://s2.loli.net/2025/04/21/9IYeW5iocs3u1PB.png" alt="image-20250421224913326"></p><p>关键是利用最新的时间戳去拿最新的博客id,同时利用偏移量滤去相同的时间戳(默认不会重复). 如果考虑发布时间重复,也可以在存储score时在时间戳基础上加一个随机值避免score重复.</p><h4 id="附近商户"><a href="#附近商户" class="headerlink" title="附近商户"></a>附近商户</h4><p><a href="https://www.runoob.com/redis/redis-geo.html">Redis GEO | 菜鸟教程</a></p><p>Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作，该功能在 Redis 3.2 版本新增。</p><p>Redis GEO 操作方法有：</p><ul><li>geoadd：添加地理位置的坐标。</li><li>geopos：获取地理位置的坐标。</li><li>geodist：计算两个位置之间的距离。</li><li>georadius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</li><li>georadiusbymember：根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合。</li><li>geohash：返回一个或多个位置对象的 geohash 值。</li></ul><p>geoadd 用于存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。</p><p>geoadd 语法格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOADD key longitude latitude member [longitude latitude member ...]</span><br></pre></td></tr></table></figure><ul><li>m ：米，默认单位。</li><li>km ：千米。</li><li>mi ：英里。</li><li>ft ：英尺。</li><li>WITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。</li><li>WITHCOORD: 将位置元素的经度和纬度也一并返回。</li><li>WITHHASH: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。</li><li>COUNT 限定返回的记录数。</li><li>ASC: 查找结果根据距离从近到远排序。</li><li>DESC: 查找结果根据从远到近排序。</li></ul><h4 id="用户签到"><a href="#用户签到" class="headerlink" title="用户签到"></a>用户签到</h4><p><img data-src="https://s2.loli.net/2025/04/22/61cqOWxZMwnfemh.png" alt="image-20250422105634699"></p><p><img data-src="https://s2.loli.net/2025/04/22/aGspbuONkSMdqxf.png" alt="image-20250422111632294"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line"><span class="keyword">int</span> dayOfYear = now.getDayOfYear();</span><br><span class="line"><span class="keyword">int</span> year = now.getYear();</span><br><span class="line">String key = SIGN_KEY + UserHolder.getUser().getId()+ <span class="string">&quot;:&quot;</span> + year;</span><br><span class="line">Boolean signSuccess = stringRedisTemplate.opsForValue().setBit(key, dayOfYear-<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">if</span> (BooleanUtil.isTrue(signSuccess)) &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;签到失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="签到统计"><a href="#签到统计" class="headerlink" title="签到统计"></a>签到统计</h4><p>使用<code>bitfield</code>查询一个范围内的二进制返回十进制数据.</p><p><img data-src="https://s2.loli.net/2025/04/22/dfuNzSwYlVOsJD1.png" alt="image-20250422121102888"></p><h4 id="UV统计-HyperLogLog"><a href="#UV统计-HyperLogLog" class="headerlink" title="UV统计  HyperLogLog"></a>UV统计  HyperLogLog</h4><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p><img data-src="https://s2.loli.net/2025/04/22/MEm6zF5nt28TBch.png" alt="image-20250422121540587"></p><p><img data-src="https://s2.loli.net/2025/04/22/ztXRO9DFqkU68xV.png" alt="image-20250422122336390"></p><h1 id="EasyChat"><a href="#EasyChat" class="headerlink" title="EasyChat"></a>EasyChat</h1><h3 id="登录注册"><a href="#登录注册" class="headerlink" title="登录注册"></a>登录注册</h3><p><img data-src="https://s2.loli.net/2025/05/02/C8LFUSamDZfsJPA.png" alt="image-20250502155041889"></p><p><img data-src="https://s2.loli.net/2025/05/02/WABFut1yEYeLSPa.png" alt="image-20250502195913653"></p><h4 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h4><p>登陆时检查心跳缓存避免别处登陆,完成后保存用户信息缓存,并查询联系人存在缓存中.</p><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>注册完成后,主要是创建了机器人账号并加入了会话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Date curDate = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">SysSettingDto sysSettingDto = redisComponet.getSysSetting();</span><br><span class="line">String contactId = sysSettingDto.getRobotUid();</span><br><span class="line">String contactName = sysSettingDto.getRobotNickName();</span><br><span class="line">String senMessage = sysSettingDto.getRobotWelcome();</span><br><span class="line">senMessage = StringTools.cleanHtmlTag(senMessage);</span><br><span class="line"><span class="comment">//增加机器人好友</span></span><br><span class="line">UserContact userContact = <span class="keyword">new</span> UserContact();</span><br><span class="line">userContact.setUserId(userId);</span><br><span class="line">userContact.setContactId(contactId);</span><br><span class="line">userContact.setContactType(UserContactTypeEnum.USER.getType());</span><br><span class="line">userContact.setCreateTime(curDate);</span><br><span class="line">userContact.setStatus(UserContactStatusEnum.FRIEND.getStatus());</span><br><span class="line">userContact.setLastUpdateTime(curDate);</span><br><span class="line">userContactMapper.insert(userContact);</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加会话信息</span></span><br><span class="line">String sessionId = StringTools.getChatSessionId4User(<span class="keyword">new</span> String[]&#123;userId, contactId&#125;);</span><br><span class="line">ChatSession chatSession = <span class="keyword">new</span> ChatSession();</span><br><span class="line">chatSession.setLastMessage(senMessage);</span><br><span class="line">chatSession.setSessionId(sessionId);</span><br><span class="line">chatSession.setLastReceiveTime(curDate.getTime());</span><br><span class="line"><span class="keyword">this</span>.chatSessionMapper.insert(chatSession);</span><br><span class="line"></span><br><span class="line">ChatSessionUser applySessionUser = <span class="keyword">new</span> ChatSessionUser();</span><br><span class="line">applySessionUser.setUserId(userId);</span><br><span class="line">applySessionUser.setContactId(contactId);</span><br><span class="line">applySessionUser.setContactName(contactName);</span><br><span class="line">applySessionUser.setSessionId(sessionId);</span><br><span class="line"><span class="keyword">this</span>.chatSessionUserMapper.insertOrUpdate(applySessionUser);</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加聊天消息</span></span><br><span class="line">ChatMessage chatMessage = <span class="keyword">new</span> ChatMessage();</span><br><span class="line">chatMessage.setSessionId(sessionId);</span><br><span class="line">chatMessage.setMessageType(MessageTypeEnum.CHAT.getType());</span><br><span class="line">chatMessage.setMessageContent(senMessage);</span><br><span class="line">chatMessage.setSendUserId(contactId);</span><br><span class="line">chatMessage.setSendUserNickName(contactName);</span><br><span class="line">chatMessage.setSendTime(curDate.getTime());</span><br><span class="line">chatMessage.setContactId(userId);</span><br><span class="line">chatMessage.setContactType(UserContactTypeEnum.USER.getType());</span><br><span class="line">chatMessage.setStatus(MessageStatusEnum.SENDED.getStatus());</span><br><span class="line">chatMessageMapper.insert(chatMessage);</span><br></pre></td></tr></table></figure><h4 id="保存用户信息"><a href="#保存用户信息" class="headerlink" title="保存用户信息"></a>保存用户信息</h4><p>更新用户信息,controller参数设置为userInfo,然后将其中的不能修改的信息设置为null.</p><p>如果更改了昵称,更新缓存中的用户信息,键为token. </p><p>除了更新userinfo表,如果昵称不一样还要更新chat_session_user表,根据contact</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新相关表冗余的字段</span></span><br><span class="line">String contactNameUpdate = null;</span><br><span class="line"><span class="keyword">if</span> (!dbInfo.get<span class="constructor">NickName()</span>.equals(userInfo.get<span class="constructor">NickName()</span>)) &#123;</span><br><span class="line">    contactNameUpdate = userInfo.get<span class="constructor">NickName()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (contactNameUpdate<span class="operator"> == </span>null) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新token中的昵称</span></span><br><span class="line">TokenUserInfoDto tokenUserInfoDto = redisComponet.get<span class="constructor">TokenUserInfoDtoByUserId(<span class="params">userInfo</span>.<span class="params">getUserId</span>()</span>);</span><br><span class="line">tokenUserInfoDto.set<span class="constructor">NickName(<span class="params">contactNameUpdate</span>)</span>;</span><br><span class="line">redisComponet.save<span class="constructor">TokenUserInfoDto(<span class="params">tokenUserInfoDto</span>)</span>;</span><br><span class="line"></span><br><span class="line">chatSessionUserService.update<span class="constructor">RedundanceInfo(<span class="params">contactNameUpdate</span>, <span class="params">userInfo</span>.<span class="params">getUserId</span>()</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">StringTools</span>.</span></span>is<span class="constructor">Empty(<span class="params">contactName</span>)</span>) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">ChatSessionUser updateInfo = <span class="keyword">new</span> <span class="constructor">ChatSessionUser()</span>;</span><br><span class="line">updateInfo.set<span class="constructor">ContactName(<span class="params">contactName</span>)</span>;</span><br><span class="line"><span class="comment">// 更新chat_session_user中的contact_name</span></span><br><span class="line">ChatSessionUserQuery chatSessionUserQuery = <span class="keyword">new</span> <span class="constructor">ChatSessionUserQuery()</span>;</span><br><span class="line">chatSessionUserQuery.set<span class="constructor">ContactId(<span class="params">contactId</span>)</span>;</span><br><span class="line">this.chatSessionUserMapper.update<span class="constructor">ByParam(<span class="params">updateInfo</span>, <span class="params">chatSessionUserQuery</span>)</span>;</span><br></pre></td></tr></table></figure><p>然后针对联系人,发送名称更新的ws消息.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">UserContactQuery userContactQuery = <span class="keyword">new</span> UserContactQuery();</span><br><span class="line">userContactQuery.setContactType(UserContactTypeEnum.USER.getType());</span><br><span class="line">userContactQuery.setContactId(contactId);</span><br><span class="line">userContactQuery.setStatus(UserContactStatusEnum.FRIEND.getStatus());</span><br><span class="line">List&lt;UserContact&gt; userContactList = userContactMapper.selectList(userContactQuery);</span><br><span class="line"><span class="keyword">for</span> (UserContact userContact : userContactList) &#123;</span><br><span class="line">    MessageSendDto messageSendDto = <span class="keyword">new</span> MessageSendDto();</span><br><span class="line">    messageSendDto.setContactType(contactTypeEnum.getType());</span><br><span class="line">    messageSendDto.setContactId(userContact.getUserId());</span><br><span class="line">    messageSendDto.setExtendData(contactName);</span><br><span class="line">    messageSendDto.setMessageType(MessageTypeEnum.CONTACT_NAME_UPDATE.getType());</span><br><span class="line">    messageSendDto.setSendUserId(contactId);</span><br><span class="line">    messageSendDto.setSendUserNickName(contactName);</span><br><span class="line">    messageHandler.sendMessage(messageSendDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上传的头像文件不为空,则下载到服务器对应路径. BASE_FOLDER+FILE+AVATAR+user_id.jpg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (avatarFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String baseFolder = appConfig.getProjectFolder() + Constants.FILE_FOLDER_FILE;</span><br><span class="line">    File targetFileFolder = <span class="keyword">new</span> File(baseFolder + Constants.FILE_FOLDER_AVATAR_NAME);</span><br><span class="line">    <span class="keyword">if</span> (!targetFileFolder.exists()) &#123;</span><br><span class="line">        targetFileFolder.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    String filePath = targetFileFolder.getPath() + <span class="string">&quot;/&quot;</span> + userInfo.getUserId() + Constants.IMAGE_SUFFIX;</span><br><span class="line">    avatarFile.transferTo(<span class="keyword">new</span> File(filePath));</span><br><span class="line">    avatarCover.transferTo(<span class="keyword">new</span> File(filePath + Constants.COVER_IMAGE_SUFFIX));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h4><p>直接查询即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TokenUserInfoDto tokenUserInfoDto = getTokenUserInfo(request);</span><br><span class="line">UserInfo userInfo = userInfoService.getUserInfoByUserId(tokenUserInfoDto.getUserId());</span><br><span class="line">UserInfoVO userInfoVO = CopyTools.copy(userInfo, UserInfoVO.class);</span><br><span class="line">userInfoVO.setAdmin(tokenUserInfoDto.getAdmin());</span><br><span class="line"><span class="keyword">return</span> getSuccessResponseVO(userInfoVO);</span><br></pre></td></tr></table></figure><h4 id="更新密码"><a href="#更新密码" class="headerlink" title="更新密码"></a>更新密码</h4><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><h3 id="群组管理"><a href="#群组管理" class="headerlink" title="群组管理"></a>群组管理</h3><p><img data-src="https://s2.loli.net/2025/05/02/XZeaDzgW8tl5LMA.png" alt="image-20250502195944284"></p><p><img data-src="https://s2.loli.net/2025/05/02/psnG2CViDxzf8YQ.png" alt="image-20250502200016447"></p><h4 id="查看自己群聊"><a href="#查看自己群聊" class="headerlink" title="查看自己群聊"></a>查看自己群聊</h4><p>查询user_contact表,群组owner是自己,创建时间降序,群组状态正常.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     TokenUserInfoDto tokenUserInfoDto = getTokenUserInfo(request);</span><br><span class="line">       GroupInfoQuery infoQuery = <span class="keyword">new</span> GroupInfoQuery();</span><br><span class="line">       infoQuery.setGroupOwnerId(tokenUserInfoDto.getUserId());</span><br><span class="line">       infoQuery.setOrderBy(<span class="string">&quot;create_time desc&quot;</span>);</span><br><span class="line">infoQuery.setStatus(GroupStatusEnum.NORMAL.getStatus());</span><br><span class="line">       List&lt;GroupInfo&gt; groupInfoList = <span class="keyword">this</span>.groupInfoService.findListByParam(infoQuery);</span><br><span class="line">       <span class="keyword">return</span> getSuccessResponseVO(groupInfoList);</span><br></pre></td></tr></table></figure><h4 id="查看群聊信息"><a href="#查看群聊信息" class="headerlink" title="查看群聊信息"></a>查看群聊信息</h4><p>根据groupId,首先看群聊是否存在,以及自己是否在群聊中,查询user_contact表(设置联系状态是好友),如果在群聊中才能继续查看. 查询groupInfo表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TokenUserInfoDto tokenUserInfoDto = getTokenUserInfo(request);</span><br><span class="line">UserContact userContact = <span class="keyword">this</span>.userContactService.getUserContactByUserIdAndContactId(tokenUserInfoDto.getUserId(), groupId);</span><br><span class="line"><span class="keyword">if</span> (userContact == <span class="keyword">null</span> || !UserContactStatusEnum.FRIEND.getStatus().equals(userContact.getStatus())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">&quot;你不在群聊或者群聊不存在或已经解散&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">GroupInfo groupInfo = <span class="keyword">this</span>.groupInfoService.getGroupInfoByGroupId(groupId);</span><br><span class="line"><span class="keyword">if</span> (groupInfo == <span class="keyword">null</span> || !GroupStatusEnum.NORMAL.getStatus().equals(groupInfo.getStatus())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">&quot;群聊不存在或已经解散&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> groupInfo;</span><br></pre></td></tr></table></figure><p>同时查询user_contact表查询群成员个数一起返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userContactQuery.setContactId(groupId);</span><br><span class="line">Integer memberCount = <span class="keyword">this</span>.userContactService.findCountByParam(userContactQuery);</span><br><span class="line">groupInfo.setMemberCount(memberCount);</span><br></pre></td></tr></table></figure><p>上面是查看群聊信息,但不包含群聊中成员,还有一个接口可以查询群成员,也就是在user_contact表中查看contact_id是群id,状态是联系人的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GroupInfo groupInfo = getGroupDetailCommon(request, groupId);</span><br><span class="line">UserContactQuery userContactQuery = <span class="keyword">new</span> UserContactQuery();</span><br><span class="line">userContactQuery.setContactId(groupId);</span><br><span class="line">userContactQuery.setQueryUserInfo(<span class="keyword">true</span>);</span><br><span class="line">userContactQuery.setOrderBy(<span class="string">&quot;create_time asc&quot;</span>);</span><br><span class="line">userContactQuery.setStatus(UserContactStatusEnum.FRIEND.getStatus());</span><br><span class="line">List&lt;UserContact&gt; userContactList = <span class="keyword">this</span>.userContactService.findListByParam(userContactQuery);</span><br><span class="line">GroupInfoVO groupInfoVo = <span class="keyword">new</span> GroupInfoVO();</span><br><span class="line">groupInfoVo.setGroupInfo(groupInfo);</span><br><span class="line">groupInfoVo.setUserContactList(userContactList);</span><br><span class="line"><span class="keyword">return</span> getSuccessResponseVO(groupInfoVo);</span><br></pre></td></tr></table></figure><h4 id="创建-更新群聊"><a href="#创建-更新群聊" class="headerlink" title="创建/更新群聊"></a>创建/更新群聊</h4><p>创建与更新群聊接口类似,传入groupId,如果为空则创建群聊.</p><p>一个用户创建群聊个数有限,所以先进行查询看是否满足条件. </p><p>满足之后,插入群聊信息,user_contact联系信息,用户联系人缓存更新,channelContextUtils加入群组channelGroup,插入chat_session_user表,插入session_user表,插入chat_message表,最后发送messageSendDto.</p><p>如果是更新群聊,则更新群组信息,更新user_contact表与chat_session_user表(主要更新群聊名称)</p><p>更新chat_session_user中contact_name.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ChatSessionUser updateInfo = <span class="keyword">new</span> ChatSessionUser();</span><br><span class="line">updateInfo.setContactName(contactName);</span><br><span class="line"></span><br><span class="line">ChatSessionUserQuery chatSessionUserQuery = <span class="keyword">new</span> ChatSessionUserQuery();</span><br><span class="line">chatSessionUserQuery.setContactId(contactId);</span><br><span class="line"><span class="keyword">this</span>.chatSessionUserMapper.updateByParam(updateInfo, chatSessionUserQuery);</span><br></pre></td></tr></table></figure><p>然后发送ws消息通知群聊成员更改了群名称.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MessageSendDto messageSendDto = <span class="keyword">new</span> MessageSendDto();</span><br><span class="line">messageSendDto.setContactType(UserContactTypeEnum.getByPrefix(contactId).getType());</span><br><span class="line">messageSendDto.setContactId(contactId);</span><br><span class="line">messageSendDto.setExtendData(contactName);</span><br><span class="line">messageSendDto.setMessageType(MessageTypeEnum.CONTACT_NAME_UPDATE.getType());</span><br><span class="line">messageHandler.sendMessage(messageSendDto);</span><br></pre></td></tr></table></figure><p>用户更改昵称其实类似,也需要向他的联系人通知</p><p>如果上传了群聊头像文件,则存储到一个文件路径, basePath+FILE_FOLDER_FILE+FILE_FOLDER_AVATAR_NAME+群聊id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String baseFolder = appConfig.getProjectFolder() + Constants.FILE_FOLDER_FILE;</span><br><span class="line">File targetFileFolder = <span class="keyword">new</span> File(baseFolder + Constants.FILE_FOLDER_AVATAR_NAME);</span><br><span class="line"><span class="keyword">if</span> (!targetFileFolder.exists()) &#123;</span><br><span class="line">    targetFileFolder.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">String filePath = targetFileFolder.getPath() + <span class="string">&quot;/&quot;</span> + groupInfo.getGroupId() + Constants.IMAGE_SUFFIX;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    avatarFile.transferTo(<span class="keyword">new</span> File(filePath));</span><br><span class="line">    avatarCover.transferTo(<span class="keyword">new</span> File(filePath + Constants.COVER_IMAGE_SUFFIX));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    logger.error(<span class="string">&quot;头像上传失败&quot;</span>, e);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">&quot;头像上传失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解散群聊"><a href="#解散群聊" class="headerlink" title="解散群聊"></a>解散群聊</h4><p>更新group_info状态群聊被解散,更新联系人user_contact状态为删除(contact_id为群id),删除对应缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新群解散状态</span></span><br><span class="line">GroupInfo updateInfo = <span class="keyword">new</span> GroupInfo();</span><br><span class="line">updateInfo.setStatus(GroupStatusEnum.DISSOLUTION.getStatus());</span><br><span class="line"><span class="keyword">this</span>.groupInfoMapper.updateByGroupId(updateInfo, groupId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新user_contact状态 删除</span></span><br><span class="line">UserContactQuery userContactQuery = <span class="keyword">new</span> UserContactQuery();</span><br><span class="line">userContactQuery.setContactId(groupId);</span><br><span class="line">userContactQuery.setContactType(UserContactTypeEnum.GROUP.getType());</span><br><span class="line"></span><br><span class="line">UserContact updateUserContact = <span class="keyword">new</span> UserContact();</span><br><span class="line">updateUserContact.setStatus(UserContactStatusEnum.DEL.getStatus());</span><br><span class="line">userContactMapper.updateByParam(updateUserContact, userContactQuery);</span><br><span class="line"><span class="comment">// 删除对应联系人缓存</span></span><br><span class="line">List&lt;UserContact&gt; userContactList = <span class="keyword">this</span>.userContactMapper.selectList(userContactQuery);</span><br><span class="line">    <span class="keyword">for</span> (UserContact userContact : userContactList) &#123;</span><br><span class="line">        redisComponet.removeUserContact(userContact.getUserId(), userContact.getContactId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>除此之外,更新chat_session表群解散消息和时间,插入chat_message表更新群解散消息,GROUP_CONTEXT_MAP删除群组channelGroup</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String sessionId = StringTools.getChatSessionId4Group(groupId);</span><br><span class="line">Date curTime = <span class="keyword">new</span> Date();</span><br><span class="line">String messageContent = MessageTypeEnum.DISSOLUTION_GROUP.getInitMessage();</span><br><span class="line"><span class="comment">//更新会话消息</span></span><br><span class="line">ChatSession chatSession = <span class="keyword">new</span> ChatSession();</span><br><span class="line">chatSession.setLastMessage(messageContent);</span><br><span class="line">chatSession.setLastReceiveTime(curTime.getTime());</span><br><span class="line">chatSessionMapper.updateBySessionId(chatSession, sessionId);</span><br><span class="line"><span class="comment">//记录消息消息表</span></span><br><span class="line">ChatMessage chatMessage = <span class="keyword">new</span> ChatMessage();</span><br><span class="line">chatMessage.setSessionId(sessionId);</span><br><span class="line">chatMessage.setSendTime(curTime.getTime());</span><br><span class="line">chatMessage.setContactType(UserContactTypeEnum.GROUP.getType());</span><br><span class="line">chatMessage.setStatus(MessageStatusEnum.SENDED.getStatus());</span><br><span class="line">chatMessage.setMessageType(MessageTypeEnum.DISSOLUTION_GROUP.getType());</span><br><span class="line">chatMessage.setContactId(groupId);</span><br><span class="line">chatMessage.setMessageContent(messageContent);</span><br><span class="line">chatMessageMapper.insert(chatMessage);</span><br></pre></td></tr></table></figure><p>还需要给发送群成员ws消息,告知群组解散.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//发送解散群消息</span></span><br><span class="line">        MessageSendDto messageSendDto = <span class="module-access"><span class="module"><span class="identifier">CopyTools</span>.</span></span>copy(chatMessage, <span class="module-access"><span class="module"><span class="identifier">MessageSendDto</span>.</span></span><span class="keyword">class</span>);</span><br><span class="line">        messageHandler.send<span class="constructor">Message(<span class="params">messageSendDto</span>)</span>;</span><br><span class="line"> <span class="comment">// 在channelContextUtils.java中 给群聊channelGroup发送消息,这个group中的所有channel,也就是群成员都会接收到这个群解散消息</span></span><br><span class="line">ChannelGroup group = <span class="module-access"><span class="module"><span class="identifier">GROUP_CONTEXT_MAP</span>.</span></span>get(messageSendDto.get<span class="constructor">ContactId()</span>);</span><br><span class="line"><span class="keyword">if</span> (group<span class="operator"> == </span>null) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">group.write<span class="constructor">AndFlush(<span class="params">new</span> TextWebSocketFrame(JSON.<span class="params">toJSONString</span>(<span class="params">messageSendDto</span>)</span>));</span><br><span class="line"><span class="comment">// 然后移除GROUP_CONTEXT_MAP中的channelGroup并关闭group</span></span><br><span class="line">  <span class="keyword">if</span> (MessageTypeEnum.DISSOLUTION_GROUP<span class="operator"> == </span>messageTypeEnum) &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">GROUP_CONTEXT_MAP</span>.</span></span>remove(messageSendDto.get<span class="constructor">ContactId()</span>);</span><br><span class="line">            group.close<span class="literal">()</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="退出群聊"><a href="#退出群聊" class="headerlink" title="退出群聊"></a>退出群聊</h4><p>除了检查传递过来的groupId是否合法之外(群存在且未解散,创建者不能退出群聊),查询user_contact,更新状态为删除(代码中直接删除了行记录)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GroupInfo groupInfo = groupInfoMapper.selectByGroupId(groupId);</span><br><span class="line"><span class="keyword">if</span> (groupInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ResponseCodeEnum.CODE_600);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建者不能退出群聊，只能解散群</span></span><br><span class="line"><span class="keyword">if</span> (userId.equals(groupInfo.getGroupOwnerId())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ResponseCodeEnum.CODE_600);</span><br><span class="line">&#125;</span><br><span class="line">Integer count = userContactMapper.deleteByUserIdAndContactId(userId, groupId);</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ResponseCodeEnum.CODE_600);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入chat_session_user表退群消息以及chat_message消息,更新联系人缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">UserInfo userInfo = userInfoMapper.selectByUserId(userId);</span><br><span class="line"></span><br><span class="line">String sessionId = StringTools.getChatSessionId4Group(groupId);</span><br><span class="line">Date curTime = <span class="keyword">new</span> Date();</span><br><span class="line">String messageContent = String.format(messageTypeEnum.getInitMessage(), userInfo.getNickName());</span><br><span class="line"><span class="comment">//更新会话消息</span></span><br><span class="line">ChatSession chatSession = <span class="keyword">new</span> ChatSession();</span><br><span class="line">chatSession.setLastMessage(messageContent);</span><br><span class="line">chatSession.setLastReceiveTime(curTime.getTime());</span><br><span class="line">chatSessionMapper.updateBySessionId(chatSession, sessionId);</span><br><span class="line"><span class="comment">//记录消息消息表</span></span><br><span class="line">ChatMessage chatMessage = <span class="keyword">new</span> ChatMessage();</span><br><span class="line">chatMessage.setSessionId(sessionId);</span><br><span class="line">chatMessage.setSendTime(curTime.getTime());</span><br><span class="line">chatMessage.setContactType(UserContactTypeEnum.GROUP.getType());</span><br><span class="line">chatMessage.setStatus(MessageStatusEnum.SENDED.getStatus());</span><br><span class="line">chatMessage.setMessageType(messageTypeEnum.getType());</span><br><span class="line">chatMessage.setContactId(groupId);</span><br><span class="line">chatMessage.setMessageContent(messageContent);</span><br><span class="line">chatMessageMapper.insert(chatMessage);</span><br></pre></td></tr></table></figure><p>然后就是使用messageHandler发送消息,有人退群了发送给群组channelGroup,也就是所有群成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UserContactQuery userContactQuery = <span class="keyword">new</span> UserContactQuery();</span><br><span class="line">userContactQuery.setContactId(groupId);</span><br><span class="line">userContactQuery.setStatus(UserContactStatusEnum.FRIEND.getStatus());</span><br><span class="line">Integer memberCount = <span class="keyword">this</span>.userContactMapper.selectCount(userContactQuery); <span class="comment">// 发送了群成员个数</span></span><br><span class="line"></span><br><span class="line">MessageSendDto messageSendDto = CopyTools.copy(chatMessage, MessageSendDto.class);</span><br><span class="line">messageSendDto.setExtendData(userId); <span class="comment">// 发送了退群人</span></span><br><span class="line">messageSendDto.setMemberCount(memberCount);</span><br><span class="line">messageHandler.sendMessage(messageSendDto);</span><br></pre></td></tr></table></figure><h4 id="删除或者添加群成员"><a href="#删除或者添加群成员" class="headerlink" title="删除或者添加群成员"></a>删除或者添加群成员</h4><p>还是类似的流程,先判断成员id和群组id本身是不是在user_contact成员状态,如果是才能进行下一步. 删除和添加类似,如果是删除成员,操作类似成员退出群成员,但message类型是REMOVE_GROUP(12, “%s被管理员移出了群聊”, “被管理员移出了群聊”).而不是LEAVE_GROUP,user_contact,chat_session,chat_message表更新(代码中user_contact记录被删除),消息也会发送给群组,会在处理时删除缓存,以及移除组中的channel.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">group.writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(JSON.toJSONString(messageSendDto)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除群聊</span></span><br><span class="line">MessageTypeEnum messageTypeEnum = MessageTypeEnum.getByType(messageSendDto.getMessageType());</span><br><span class="line"><span class="keyword">if</span> (MessageTypeEnum.LEAVE_GROUP == messageTypeEnum || MessageTypeEnum.REMOVE_GROUP == messageTypeEnum) &#123;</span><br><span class="line">    String userId = (String) messageSendDto.getExtendData();</span><br><span class="line">    redisComponet.removeUserContact(userId, messageSendDto.getContactId());</span><br><span class="line">    Channel channel = USER_CONTEXT_MAP.get(userId);</span><br><span class="line">    <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    group.remove(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是添加群成员,类似addContact,applyuserId是contactId,联系人是群组id. 具体流程类似,更新/插入user_contact状态,更新缓存,更新chat_session表,添加群组channel,更新chat_message,最后发送消息(主要目的是当前机子可能没有该群组的channel,通过redisson发布订阅,其他机子取出CONTEXT_MAP中的channel,不为空就发送消息).</p><p>假设一个场景,有许多用户登陆了不同服务器</p><p><img data-src="https://s2.loli.net/2025/07/22/XnkZECm7cG23dlD.png" alt="image-20250722160015745"></p><h4 id="加入群聊"><a href="#加入群聊" class="headerlink" title="加入群聊"></a>加入群聊</h4><p>类似添加好友addContact</p><h3 id="联系人管理"><a href="#联系人管理" class="headerlink" title="联系人管理"></a>联系人管理</h3><p><img data-src="https://s2.loli.net/2025/05/05/vODxw84bH7LguBa.png" alt="image-20250505174711397"></p><p><img data-src="https://s2.loli.net/2025/05/02/psnG2CViDxzf8YQ.png" alt="image-20250502200016447"></p><h4 id="搜索用户"><a href="#搜索用户" class="headerlink" title="搜索用户"></a>搜索用户</h4><p>需要使用user_info表根据传过来的用户id查询,如果是用户,还需要查询昵称、性别等信息.</p><p>如果是群聊,还会返回群名称. 同时查询user_contact表设置联系状态.</p><h4 id="申请添加联系人"><a href="#申请添加联系人" class="headerlink" title="申请添加联系人"></a>申请添加联系人</h4><p>添加联系人时,首先判断一些信息,比如contact_id是否合法(存在),是否被拉黑等. </p><p>user_contact_apply表包含apply_id为主键,意味着可以同一用户可以申请多次添加联系人</p><p><img data-src="https://s2.loli.net/2025/07/21/qXQrNahUbLdZw5p.png" alt="image-20250721225848826"></p><p>省去对参数的校验,首先查询user_contact表状态是否被拉黑了,被拉黑就无法申请了. </p><p>当满足这些条件,然后判断是否需要申请还是直接就能添加.</p><h4 id="直接添加联系人"><a href="#直接添加联系人" class="headerlink" title="直接添加联系人"></a>直接添加联系人</h4><p>如果能直接添加,就进行添加好友操作(如果是群聊需要判断是否超出人数)</p><p>能想到的操作就是,插入user_contact表,<strong>如果是好友,就需要互相添加.</strong>,如果是群组,直接插入一条即可(user_id,group_id)</p><p><img data-src="https://s2.loli.net/2025/07/21/Mf9eRWBC2mu1plw.png" alt="image-20250721215035264"></p><p>也就是user_id分别为申请人和接收人,然后更新联系人缓存.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserContact&gt; contactList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//申请人添加对方</span></span><br><span class="line">UserContact userContact = <span class="keyword">new</span> UserContact();</span><br><span class="line">userContact.setUserId(applyUserId);</span><br><span class="line">userContact.setContactId(contactId);</span><br><span class="line">userContact.setContactType(contactType);</span><br><span class="line">userContact.setCreateTime(curDate);</span><br><span class="line">userContact.setLastUpdateTime(curDate);</span><br><span class="line">userContact.setStatus(UserContactStatusEnum.FRIEND.getStatus());</span><br><span class="line">contactList.add(userContact);</span><br><span class="line"><span class="comment">//如果是申请好友 接收人添加申请人  群组不用添加对方为好友</span></span><br><span class="line"><span class="keyword">if</span> (UserContactTypeEnum.USER.getType().equals(contactType)) &#123;</span><br><span class="line">    userContact = <span class="keyword">new</span> UserContact();</span><br><span class="line">    userContact.setUserId(receiveUserId);</span><br><span class="line">    userContact.setContactId(applyUserId);</span><br><span class="line">    userContact.setContactType(contactType);</span><br><span class="line">    userContact.setCreateTime(curDate);</span><br><span class="line">    userContact.setLastUpdateTime(curDate);</span><br><span class="line">    userContact.setStatus(UserContactStatusEnum.FRIEND.getStatus());</span><br><span class="line">    contactList.add(userContact);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//批量加入</span></span><br><span class="line">userContactMapper.insertOrUpdateBatch(contactList);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是好友申请,接收人也添加申请人为联系人</span></span><br><span class="line"><span class="keyword">if</span> (UserContactTypeEnum.USER.getType().equals(contactType)) &#123;</span><br><span class="line">    redisComponet.addUserContact(receiveUserId, applyUserId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//审核通过，将申请人的联系人添加上 我 或 群组</span></span><br><span class="line">redisComponet.addUserContact(applyUserId, contactId);</span><br></pre></td></tr></table></figure><p>在创建好友联系后,就是创建会话以及消息信息了,具体操作也是表插入/更新操作.</p><p>具体来说,对于用户会话表,包括(user_id,contact_id,)session_id,contact_name</p><p><img data-src="https://s2.loli.net/2025/07/21/rn2d8Njp3DWHQYB.png" alt="image-20250721091337069"></p><p>插入这个数据不难,但需要考虑可能之前这两人就是好友但进行过删好友操作,这条记录不会删除,所以就进行更新. 注意这个表也是(user_id,contact_id)联合主键,如果是好友,也需要插入相互的两条用户会话.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询接收人信息</span></span><br><span class="line">    UserInfo contactUser = <span class="keyword">this</span>.userInfoMapper.selectByUserId(contactId);</span><br><span class="line">    applySessionUser.setContactName(contactUser.getNickName());</span><br><span class="line">    chatSessionUserList.add(applySessionUser);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受人session</span></span><br><span class="line">    ChatSessionUser contactSessionUser = <span class="keyword">new</span> ChatSessionUser();</span><br><span class="line">    contactSessionUser.setUserId(contactId);</span><br><span class="line">    contactSessionUser.setContactId(applyUserId);</span><br><span class="line">    contactSessionUser.setSessionId(sessionId);</span><br><span class="line">    contactSessionUser.setLastReceiveTime(curDate.getTime());</span><br><span class="line">    contactSessionUser.setLastMessage(applyInfo);</span><br><span class="line">    <span class="comment">//查询申请人信息</span></span><br><span class="line">    UserInfo applyUserInfo = <span class="keyword">this</span>.userInfoMapper.selectByUserId(applyUserId);</span><br><span class="line">    contactSessionUser.setContactName(applyUserInfo.getNickName());</span><br><span class="line">    chatSessionUserList.add(contactSessionUser);</span><br><span class="line">    <span class="keyword">this</span>.chatSessionUserMapper.insertOrUpdateBatch(chatSessionUserList);</span><br></pre></td></tr></table></figure><p>对于会话记录,只需要插入/更新一条,核心是更新最新消息和接收时间. (sql使用INSERT INTO xxx on duplicate key update xx)插入或者更新冗余键.向表中插入新行时，如果遇到与现有行的 <strong>PRIMARY KEY（主键）</strong> 或 <strong>UNIQUE KEY（唯一键）</strong> 冲突的情况，则执行 <code>UPDATE</code> 操作</p><p><img data-src="https://s2.loli.net/2025/07/21/oKpGdkxvjiJtVC2.png" alt="image-20250721091312712"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建会话</span></span><br><span class="line">ChatSession chatSession = <span class="keyword">new</span> ChatSession();</span><br><span class="line">chatSession.setSessionId(sessionId);</span><br><span class="line">chatSession.setLastReceiveTime(curDate.getTime());</span><br><span class="line">chatSession.setLastMessage(applyInfo);</span><br><span class="line"><span class="keyword">this</span>.chatSessionMapper.insertOrUpdate(chatSession);</span><br></pre></td></tr></table></figure><p>主要更新最新消息和时间.</p><p>最后更新消息内容,插入消息表,消息表主键message_id,记录了消息的发送者和接收者,session_id,消息类型,文件类型等.只需要插入一条即可,不需要互相插入.</p><p><img data-src="https://s2.loli.net/2025/07/21/nFU6EcNfQlRx8Oz.png" alt="image-20250721202934542"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录消息消息表</span></span><br><span class="line">ChatMessage chatMessage = <span class="keyword">new</span> ChatMessage();</span><br><span class="line">chatMessage.setSessionId(sessionId);</span><br><span class="line">chatMessage.setMessageType(MessageTypeEnum.ADD_FRIEND.getType());</span><br><span class="line">chatMessage.setMessageContent(applyInfo);</span><br><span class="line">chatMessage.setSendUserId(applyUserId);</span><br><span class="line">chatMessage.setSendUserNickName(applyUserInfo.getNickName());</span><br><span class="line">chatMessage.setSendTime(curDate.getTime());</span><br><span class="line">chatMessage.setContactId(contactId);</span><br><span class="line">chatMessage.setContactType(UserContactTypeEnum.USER.getType());</span><br><span class="line">chatMessage.setStatus(MessageStatusEnum.SENDED.getStatus());</span><br><span class="line">chatMessageMapper.insert(chatMessage);</span><br></pre></td></tr></table></figure><p>最后利用messageSendDto发送给用户以及接收者(因为成功加了好友).</p><p>注意设置的消息类型有多种,比如添加好友成功<code>ADD_FRIEND(1, &quot;&quot;, &quot;添加好友打招呼消息&quot;)</code>,群组创建成功等消息类型,以及文件上传,强制下线,退出群聊等等消息都会通过ws发给用户并记录在chatMessage的类型中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">INIT(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;连接WS获取信息&quot;</span>),</span><br><span class="line">ADD_FRIEND(<span class="number">1</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;添加好友打招呼消息&quot;</span>),</span><br><span class="line">CHAT(<span class="number">2</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;普通聊天消息&quot;</span>),</span><br><span class="line">GROUP_CREATE(<span class="number">3</span>, <span class="string">&quot;群组已经创建好，可以和好友一起畅聊了&quot;</span>, <span class="string">&quot;群创建成功&quot;</span>),</span><br><span class="line">CONTACT_APPLY(<span class="number">4</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;好友申请&quot;</span>),</span><br><span class="line">MEDIA_CHAT(<span class="number">5</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;媒体文件&quot;</span>),</span><br><span class="line">FILE_UPLOAD(<span class="number">6</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;文件上传完成&quot;</span>),</span><br><span class="line">FORCE_OFF_LINE(<span class="number">7</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;强制下线&quot;</span>),</span><br><span class="line">DISSOLUTION_GROUP(<span class="number">8</span>, <span class="string">&quot;群聊已解散&quot;</span>, <span class="string">&quot;解散群聊&quot;</span>),</span><br><span class="line">ADD_GROUP(<span class="number">9</span>, <span class="string">&quot;%s加入了群组&quot;</span>, <span class="string">&quot;加入群聊&quot;</span>),</span><br><span class="line">CONTACT_NAME_UPDATE(<span class="number">10</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;更新群昵称&quot;</span>),</span><br><span class="line">LEAVE_GROUP(<span class="number">11</span>, <span class="string">&quot;%s退出了群聊&quot;</span>, <span class="string">&quot;退出群聊&quot;</span>),</span><br><span class="line">REMOVE_GROUP(<span class="number">12</span>, <span class="string">&quot;%s被管理员移出了群聊&quot;</span>, <span class="string">&quot;被管理员移出了群聊&quot;</span>),</span><br><span class="line">ADD_FRIEND_SELF(<span class="number">13</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;添加好友打招呼消息发送给自己&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MessageSendDto messageSendDto = CopyTools.copy(chatMessage, MessageSendDto.class);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送给接受好友申请的人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">messageHandler.sendMessage(messageSendDto);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送给申请人 发送人就是接收人，联系人就是申请人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">messageSendDto.setMessageType(MessageTypeEnum.ADD_FRIEND_SELF.getType());</span><br><span class="line">messageSendDto.setContactId(applyUserId);</span><br><span class="line">messageSendDto.setExtendData(contactUser);</span><br><span class="line">messageHandler.sendMessage(messageSendDto);</span><br></pre></td></tr></table></figure><p>因为是好友添加成功所以需要向双方都发送ws消息,但接收者,消息类型和内容不太相同.</p><p>如果添加的是群组,同样的首先插入user_contact表,这时只需要插入一条记录即可.同时更新申请者联系人缓存.此外还要将这个用户channel加入群聊channelGroup中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加入群组</span></span><br><span class="line">         ChatSessionUser chatSessionUser = <span class="keyword">new</span> ChatSessionUser();</span><br><span class="line">         chatSessionUser.setUserId(applyUserId);</span><br><span class="line">         chatSessionUser.setContactId(contactId);</span><br><span class="line">         GroupInfo groupInfo = <span class="keyword">this</span>.groupInfoMapper.selectByGroupId(contactId);</span><br><span class="line">         chatSessionUser.setContactName(groupInfo.getGroupName());</span><br><span class="line">         chatSessionUser.setSessionId(sessionId);</span><br><span class="line">         <span class="keyword">this</span>.chatSessionUserMapper.insertOrUpdate(chatSessionUser);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//将群组加入到用户的联系人列表</span></span><br><span class="line">         redisComponet.addUserContact(applyUserId, groupInfo.getGroupId());</span><br><span class="line"></span><br><span class="line">         channelContextUtils.addUser2Group(applyUserId, groupInfo.getGroupId());</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser2Group</span><span class="params">(String userId, String groupId)</span> </span>&#123;</span><br><span class="line">    Channel channel = USER_CONTEXT_MAP.get(userId);</span><br><span class="line">    add2Group(groupId, channel);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add2Group</span><span class="params">(String groupId, Channel context)</span> </span>&#123;</span><br><span class="line">    ChannelGroup group = GROUP_CONTEXT_MAP.get(groupId);</span><br><span class="line">    <span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</span><br><span class="line">        group = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line">        GROUP_CONTEXT_MAP.put(groupId, group);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    group.add(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后插入/更新chat_session_user表(因为后续要添加会话消息),也只需要插入一条,而chat_session表插入/更新消息和接收时间,chat_session中的消息类型以及内容就是添加群消息.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UserInfo applyUserInfo = <span class="keyword">this</span>.userInfoMapper.selectByUserId(applyUserId);</span><br><span class="line"></span><br><span class="line">String sendMessage = String.format(MessageTypeEnum.ADD_GROUP.getInitMessage(), applyUserInfo.getNickName());</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加session信息</span></span><br><span class="line">ChatSession chatSession = <span class="keyword">new</span> ChatSession();</span><br><span class="line">chatSession.setSessionId(sessionId);</span><br><span class="line">chatSession.setLastReceiveTime(curDate.getTime());</span><br><span class="line">chatSession.setLastMessage(sendMessage);</span><br><span class="line"><span class="keyword">this</span>.chatSessionMapper.insertOrUpdate(chatSession);</span><br></pre></td></tr></table></figure><p>最后还是需要使用messageHandler发送messagesendDto,发送给群的有人进入了群的消息.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送群消息</span></span><br><span class="line">MessageSendDto messageSend = CopyTools.copy(chatMessage, MessageSendDto.class);</span><br><span class="line">messageSend.setContactId(groupInfo.getGroupId());</span><br><span class="line"><span class="comment">//获取群人数量</span></span><br><span class="line">UserContactQuery userContactQuery = <span class="keyword">new</span> UserContactQuery();</span><br><span class="line">userContactQuery.setContactId(contactId);</span><br><span class="line">userContactQuery.setStatus(UserContactStatusEnum.FRIEND.getStatus());</span><br><span class="line">Integer memberCount = <span class="keyword">this</span>.userContactMapper.selectCount(userContactQuery);</span><br><span class="line">messageSend.setMemberCount(memberCount);</span><br><span class="line">messageSend.setContactName(groupInfo.getGroupName());</span><br><span class="line">messageHandler.sendMessage(messageSend);</span><br></pre></td></tr></table></figure><h4 id="插入申请请求"><a href="#插入申请请求" class="headerlink" title="插入申请请求"></a>插入申请请求</h4><p>请求的状态枚举如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INIT(<span class="number">0</span>, <span class="string">&quot;待处理&quot;</span>),</span><br><span class="line">PASS(<span class="number">1</span>, <span class="string">&quot;已同意&quot;</span>),</span><br><span class="line">REJECT(<span class="number">2</span>, <span class="string">&quot;已拒绝&quot;</span>),</span><br><span class="line">BLACKLIST(<span class="number">3</span>, <span class="string">&quot;已拉黑&quot;</span>);;</span><br></pre></td></tr></table></figure><p>如果不能直接添加,就需要插入/更新user_contact_apply表.</p><p>如果不存在该记录(通过user_id，contact_id,receiver_id创建了唯一索引),则直接插入请求信息.</p><p>否则更新user_contact_apply状态为待处理(也就是说)并更新请求时间和请求信息.</p><p>此外,申请消息会通过ws发送给接收者(如果没有user_contact_apply记录或者其状态不为待处理)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dbApply == <span class="keyword">null</span> || !UserContactApplyStatusEnum.INIT.getStatus().equals(dbApply.getStatus())) &#123;</span><br><span class="line">    <span class="comment">//如果是待处理状态就不发消息，避免重复发送</span></span><br><span class="line">    <span class="comment">//发送ws消息</span></span><br><span class="line">    MessageSendDto messageSend = <span class="keyword">new</span> MessageSendDto();</span><br><span class="line">    messageSend.setMessageType(MessageTypeEnum.CONTACT_APPLY.getType());</span><br><span class="line">    messageSend.setMessageContent(applyInfo);</span><br><span class="line">    messageSend.setContactId(receiveUserId);</span><br><span class="line">    messageHandler.sendMessage(messageSend);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>messageSendDto成员如下,包括消息id,会话id,发送和接受这,消息内容,发送时间以及消息类型等等.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSendDto</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1045752033171142417L</span>;</span><br><span class="line">    <span class="comment">//消息ID</span></span><br><span class="line">    <span class="keyword">private</span> Long messageId;</span><br><span class="line">    <span class="comment">//会话ID</span></span><br><span class="line">    <span class="keyword">private</span> String sessionId;</span><br><span class="line">    <span class="comment">//发送人</span></span><br><span class="line">    <span class="keyword">private</span> String sendUserId;</span><br><span class="line">    <span class="comment">//发送人昵称</span></span><br><span class="line">    <span class="keyword">private</span> String sendUserNickName;</span><br><span class="line">    <span class="comment">//联系人ID</span></span><br><span class="line">    <span class="keyword">private</span> String contactId;</span><br><span class="line">    <span class="comment">//联系人名称</span></span><br><span class="line">    <span class="keyword">private</span> String contactName;</span><br><span class="line">    <span class="comment">//消息内容</span></span><br><span class="line">    <span class="keyword">private</span> String messageContent;</span><br><span class="line">    <span class="comment">//最后的消息</span></span><br><span class="line">    <span class="keyword">private</span> String lastMessage;</span><br><span class="line">    <span class="comment">//消息类型</span></span><br><span class="line">    <span class="keyword">private</span> Integer messageType;</span><br><span class="line">    <span class="comment">//发送时间</span></span><br><span class="line">    <span class="keyword">private</span> Long sendTime;</span><br><span class="line">    <span class="comment">//联系人类型</span></span><br><span class="line">    <span class="keyword">private</span> Integer contactType;</span><br><span class="line">    <span class="comment">//扩展信息</span></span><br><span class="line">    <span class="keyword">private</span> T extendData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息状态 0:发送中  1:已发送 对于文件是异步上传用状态处理</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件信息</span></span><br><span class="line">    <span class="keyword">private</span> Long fileSize;</span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line">    <span class="keyword">private</span> Integer fileType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//群员</span></span><br><span class="line">    <span class="keyword">private</span> Integer memberCount;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="查询申请请求"><a href="#查询申请请求" class="headerlink" title="查询申请请求"></a>查询申请请求</h4><p>查询user_contact_apply表,receiver_id是自己id的记录,因为这个表包含联合主键(apply_user_id,contact_id,receiver_id).  按照last_apply_time降序,还可以返回联系人昵称.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;base_result_map&quot;</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">    a.*</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;query.queryContactInfo&quot;</span>&gt;</span></span><br><span class="line">        ,CASE</span><br><span class="line">        WHEN a.contact_type = 0 THEN u.nick_name</span><br><span class="line">        WHEN a.contact_type = 1 THEN g.group_name</span><br><span class="line">        END as contactName</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    FROM</span><br><span class="line">    user_contact_apply a</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;query.queryContactInfo&quot;</span>&gt;</span></span><br><span class="line">        LEFT JOIN user_info u ON u.user_id = a.apply_user_id and a.receive_user_id = #&#123;query.receiveUserId&#125;</span><br><span class="line">        LEFT JOIN group_info g ON g.group_id = a.contact_id and a.receive_user_id = #&#123;query.receiveUserId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;query_condition&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;query.orderBy!=null&quot;</span>&gt;</span></span><br><span class="line">        order by $&#123;query.orderBy&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;query.simplePage!=null&quot;</span>&gt;</span></span><br><span class="line">        limit #&#123;query.simplePage.start&#125;,#&#123;query.simplePage.end&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="处理申请请求"><a href="#处理申请请求" class="headerlink" title="处理申请请求"></a>处理申请请求</h4><p>除了正常流程的参数检验和合法之外,更新user_contact_apply表状态,如果允许请求,执行上述添加联系人操作,如果拒绝,后端什么也不做,如果是拉黑,user_contact状态记录为<strong>第一次被拉黑</strong>,后续不再允许申请添加,然后插入/更新user_contact表</p><h3 id="联系人详情-删除和拉黑联系人"><a href="#联系人详情-删除和拉黑联系人" class="headerlink" title="联系人详情,删除和拉黑联系人"></a>联系人详情,删除和拉黑联系人</h3><p>加载联系人,也就是从user_contact表中查询,根据user_id和contact_id查询,如果是查询联系人,同时也会查询联系人名字、性别等信息,如果是群组,也会查询群昵称和群人数等. 此外,user_contact的状态必须是朋友,或者被删除,被拉黑. 也就是说如果被其删除,但没有删除联系人,也能加载它.</p><p>联系人详情有两个接口,一个获取任意用户的信息,通过contact_id获取用户信息,并返回联系状态.</p><p>如果是查询联系人详情,会设置查询状态,如果不是好友,被删除,被拉黑或者被首次拉黑,其余报异常. 因为如果被删除/拉黑依然能查看状态.</p><p>删除和拉黑好友时处理类似,首先修改user_contact状态,如果是删除,还需要增加被删除的一条(contact_id,user_id)记录,拉黑类似. 然后需要删除双方联系人缓存. 因为缓存中只保存好友关系的联系人,删除和被删除,拉黑和被拉黑都不存在,这个缓存内容是用来发送聊天消息的.</p><h3 id="获取用户信息、修改密码与退出登录"><a href="#获取用户信息、修改密码与退出登录" class="headerlink" title="获取用户信息、修改密码与退出登录"></a>获取用户信息、修改密码与退出登录</h3><h3 id="后台管理"><a href="#后台管理" class="headerlink" title="后台管理"></a>后台管理</h3><p>用户管理  靓号管理  群组管理</p><h3 id="登陆时加载消息"><a href="#登陆时加载消息" class="headerlink" title="登陆时加载消息"></a>登陆时加载消息</h3><blockquote><p>离线消息处理</p></blockquote><p>在登陆校验完成后,<strong>将联系人存入缓存,将token和用户信息存入缓存</strong>,并返回用户信息.</p><p>当客户端发送ws连接时,会携带token,服务端利用token获取用户信息,然后加载聊天消息.</p><p>具体来说,在缓存中获取联系人,将自己的channel加入群聊的channelGroup中(如果没有创建channelGroup放入GROUP_CONTEXT_MAP中)</p><p>然后将自己的channel放入USER_CONTEXT_MAP中,更新用户心跳缓存和最新登陆时间.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">String channelId = channel.id().toString();</span><br><span class="line">        AttributeKey attributeKey = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!AttributeKey.exists(channelId)) &#123;</span><br><span class="line">            attributeKey = AttributeKey.newInstance(channel.id().toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            attributeKey = AttributeKey.valueOf(channel.id().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        channel.attr(attributeKey).set(userId);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; contactList = redisComponet.getUserContactList(userId);</span><br><span class="line">        <span class="keyword">for</span> (String groupId : contactList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (groupId.startsWith(UserContactTypeEnum.GROUP.getPrefix())) &#123;</span><br><span class="line">                add2Group(groupId, channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        USER_CONTEXT_MAP.put(userId, channel);</span><br><span class="line">        redisComponet.saveUserHeartBeat(userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新用户最后连接时间</span></span><br><span class="line">        UserInfo updateInfo = <span class="keyword">new</span> UserInfo();</span><br><span class="line">        updateInfo.setLastLoginTime(<span class="keyword">new</span> Date());</span><br><span class="line">        userInfoMapper.updateByUserId(updateInfo, userId);</span><br></pre></td></tr></table></figure><p>首先<strong>查询用户会话信息,也就是chat_session_user表,相同的聊天双方,sessionId相同,主键是user_id和contact_id联合主键,根据user_id查看用户会话可以获取有聊天会话的联系人信息,如果是群聊也会查询群聊人数,</strong>chat_session表主键是session_id.</p><p>在mapper中,查询用户会话信息就是获取chat_session_user聊天会话对方名称,id以及session会话最新的聊天信息,如果是群聊还要查群聊人数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 1、查询会话信息 查询用户所有会话，避免换设备会话不同步</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         ChatSessionUserQuery sessionUserQuery = <span class="keyword">new</span> ChatSessionUserQuery();</span><br><span class="line">         sessionUserQuery.setUserId(userId);</span><br><span class="line">         sessionUserQuery.setOrderBy(<span class="string">&quot;last_receive_time desc&quot;</span>);</span><br><span class="line">         List&lt;ChatSessionUser&gt; chatSessionList = chatSessionUserMapper.selectList(sessionUserQuery);</span><br><span class="line">         WsInitData wsInitData = <span class="keyword">new</span> WsInitData();</span><br><span class="line">         wsInitData.setChatSessionList(chatSessionList);</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;base_result_map&quot;</span>&gt;</span></span><br><span class="line">    SELECT u.*,</span><br><span class="line">    c.last_message lastMessage,</span><br><span class="line">    c.last_receive_time lastReceiveTime,</span><br><span class="line">    case when SUBSTRING(contact_id, 1, 1) =&#x27;G&#x27;</span><br><span class="line">    THEN (select count(1) from user_contact uc where uc.contact_id = u.contact_id)</span><br><span class="line">    else 0</span><br><span class="line">    end memberCount</span><br><span class="line">    FROM chat_session_user u inner join chat_session c on c.session_id = u.session_id</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;query_condition&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;query.orderBy!=null&quot;</span>&gt;</span></span><br><span class="line">        order by $&#123;query.orderBy&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;query.simplePage!=null&quot;</span>&gt;</span></span><br><span class="line">        limit #&#123;query.simplePage.start&#125;,#&#123;query.simplePage.end&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后需要给客户端发送离线时其他人的聊天消息(离线之前的消息通过客户端查数据库),</p><p>查询流程是: 首先查询联系人,如果是群聊,联系的id是群组id,同时加上自己的id作为contact_id,查询chatMessage消息.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">           * 2、查询聊天消息</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="comment">//查询用户的联系人</span></span><br><span class="line">          UserContactQuery contactQuery = <span class="keyword">new</span> UserContactQuery();</span><br><span class="line">          contactQuery.setContactType(UserContactTypeEnum.GROUP.getType());</span><br><span class="line">          contactQuery.setUserId(userId);</span><br><span class="line">          List&lt;UserContact&gt; groupContactList = userContactMapper.selectList(contactQuery);</span><br><span class="line">          List&lt;String&gt; groupIdList = groupContactList.stream().map(item -&gt; item.getContactId()).collect(Collectors.toList());</span><br><span class="line">          <span class="comment">//将自己也加进去</span></span><br><span class="line">          groupIdList.add(userId);</span><br><span class="line"></span><br><span class="line">          ChatMessageQuery messageQuery = <span class="keyword">new</span> ChatMessageQuery();</span><br><span class="line">          messageQuery.setContactIdList(groupIdList);</span><br><span class="line">          messageQuery.setLastReceiveTime(lastOffTime);</span><br><span class="line">          List&lt;ChatMessage&gt; chatMessageList = chatMessageMapper.selectList(messageQuery);</span><br><span class="line">          wsInitData.setChatMessageList(chatMessageList);</span><br></pre></td></tr></table></figure><p>最后查询好友申请数,也就是contact_apply中还未处理的消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3、查询好友申请</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UserContactApplyQuery applyQuery = <span class="keyword">new</span> UserContactApplyQuery();</span><br><span class="line">    applyQuery.setReceiveUserId(userId);</span><br><span class="line">    applyQuery.setLastApplyTimestamp(sourceLastOffTime);</span><br><span class="line">    applyQuery.setStatus(UserContactApplyStatusEnum.INIT.getStatus());</span><br><span class="line">    Integer applyCount = userContactApplyMapper.selectCount(applyQuery);</span><br><span class="line">    wsInitData.setApplyCount(applyCount);</span><br></pre></td></tr></table></figure><p>最后要将这些消息发送给用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送消息</span></span><br><span class="line">MessageSendDto messageSendDto = <span class="keyword">new</span> MessageSendDto();</span><br><span class="line">messageSendDto.setMessageType(MessageTypeEnum.INIT.getType()); <span class="comment">// messageSendDto设置ws消息类型</span></span><br><span class="line">messageSendDto.setContactId(userId);</span><br><span class="line">messageSendDto.setExtendData(wsInitData);</span><br><span class="line"></span><br><span class="line">sendMsg(messageSendDto, userId);</span><br></pre></td></tr></table></figure><h3 id="聊天"><a href="#聊天" class="headerlink" title="聊天"></a>聊天</h3><p>主要使用ws发送消息,但多机环境下向不同服务器发送ws消息不共享,使用Redisson基于rediss消息订阅发送消息,解决集群环境下发送消息(因为集群中的服务器都通过redission订阅了相同主题)</p><p><img data-src="https://s2.loli.net/2025/07/21/y6cuUbi5AOKPRVr.png" alt="image-20250721223758683"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;messageHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MessageHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE_TOPIC = <span class="string">&quot;message.topic&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ChannelContextUtils channelContextUtils;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lisMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RTopic rTopic = redissonClient.getTopic(MESSAGE_TOPIC);</span><br><span class="line">        rTopic.addListener(MessageSendDto.class, (MessageSendDto, sendDto) -&gt; &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;收到广播消息:&#123;&#125;&quot;</span>, JSON.toJSONString(sendDto));</span><br><span class="line">            channelContextUtils.sendMessage(sendDto);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(MessageSendDto sendDto)</span> </span>&#123;</span><br><span class="line">        RTopic rTopic = redissonClient.getTopic(MESSAGE_TOPIC);</span><br><span class="line">        rTopic.publish(sendDto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库设计上,使用chat_session,chat_session_user以及chat_message表</p><p>session表包括sessionId(与聊天双方相关)以及最新消息和接收时间</p><p><img data-src="https://s2.loli.net/2025/07/21/oKpGdkxvjiJtVC2.png" alt="image-20250721091312712"></p><p>chat_session_user表包括sessionId(与聊天双方相关)以及最新消息和接收时间. 一个chat_session_user表对应一个session表,通过session_id查询最新的消息.</p><p><img data-src="https://s2.loli.net/2025/07/21/rn2d8Njp3DWHQYB.png" alt="image-20250721091337069"></p><p>chat_message表包括具体消息,包括发送者和接收者,sessionId,messageId以及消息类型,文件类型,状态,发送者昵称,文件类型,文件名称等</p><p><img data-src="https://s2.loli.net/2025/07/21/nFU6EcNfQlRx8Oz.png" alt="image-20250721202934542"></p><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>用户向联系人发送消息,主要就是插入chat_message表以及更新session表,messageHandler发送消息.</p><p>难点是处理文件上传和message发送状态.  首先判断不是机器人,如果不是,判断聊天contact_id是否合法.  </p><p>接着判断消息类型和contact类型,如果是用户,就是用户之间聊天,生成sessionId方式不同,接着更新chat_session表,如果是group,消息类型不是创建群这种消息,就需要带着userId,表明谁发送的存储在chat_session表中. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (UserContactTypeEnum.USER == contactTypeEnum) &#123;</span><br><span class="line">    sessionId = StringTools.getChatSessionId4User(<span class="keyword">new</span> String[]&#123;sendUserId, contactId&#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sessionId = StringTools.getChatSessionId4Group(contactId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新会话消息</span></span><br><span class="line">ChatSession chatSession = <span class="keyword">new</span> ChatSession();</span><br><span class="line">chatSession.setLastMessage(messageContent);</span><br><span class="line"><span class="keyword">if</span> (UserContactTypeEnum.GROUP == contactTypeEnum &amp;&amp; !MessageTypeEnum.GROUP_CREATE.getType().equals(messageTypeEnum.getType())) &#123;</span><br><span class="line">    chatSession.setLastMessage(tokenUserInfoDto.getNickName() + <span class="string">&quot;：&quot;</span> + messageContent);</span><br><span class="line">&#125;</span><br><span class="line">lastMessage = chatSession.getLastMessage();</span><br><span class="line"><span class="comment">//如果是媒体文件</span></span><br><span class="line">chatSession.setLastReceiveTime(curTime);</span><br><span class="line">chatSessionMapper.updateBySessionId(chatSession, sessionId);</span><br><span class="line"><span class="comment">//记录消息消息表</span></span><br><span class="line">chatMessage.setSessionId(sessionId);</span><br><span class="line">chatMessage.setSendUserId(sendUserId);</span><br><span class="line">chatMessage.setSendUserNickName(tokenUserInfoDto.getNickName());</span><br><span class="line">chatMessage.setSendTime(curTime);</span><br><span class="line">chatMessage.setContactType(contactTypeEnum.getType());</span><br><span class="line">chatMessage.setStatus(status);</span><br><span class="line">chatMessageMapper.insert(chatMessage);</span><br></pre></td></tr></table></figure><p>如果发送的是文件类型,由于需要上传,消息类型设置为正在发送,等文件上传完毕再更新.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer status = MessageTypeEnum.MEDIA_CHAT == messageTypeEnum ? MessageStatusEnum.SENDING.getStatus() : MessageStatusEnum.SENDED.getStatus();</span><br></pre></td></tr></table></figure><p>最后通过messageHandler发送消息</p><p>如果是机器人,机器人会直接发送消息过去,也就是再次调用saveMessage方法本身,再在方法中通过messageHandler发送回用户.</p><p>最后会将发送的消息再传到客户端,方便拿到消息id.</p><h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><p>controller参数包括messageId,检查发送者是否messageId对应消息的发送者.是上传文件,首先检查文件大小限制.然后直接上传即可(没有做秒传,分片续传等).</p><p>下载的路径遵循BASE_FOLDER+FILE+yyyyMM+messageid.suffix</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String fileName = file.getOriginalFilename();</span><br><span class="line">String fileExtName = StringTools.getFileSuffix(fileName);</span><br><span class="line">String fileRealName = messageId + fileExtName;</span><br><span class="line">String month = DateUtil.format(<span class="keyword">new</span> Date(message.getSendTime()), DateTimePatternEnum.YYYYMM.getPattern());</span><br><span class="line">File folder = <span class="keyword">new</span> File(appConfig.getProjectFolder() + Constants.FILE_FOLDER_FILE + month);</span><br><span class="line"><span class="keyword">if</span> (!folder.exists()) &#123;</span><br><span class="line">    folder.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File uploadFile = <span class="keyword">new</span> File(folder.getPath() + <span class="string">&quot;/&quot;</span> + fileRealName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    file.transferTo(uploadFile);</span><br><span class="line">    <span class="keyword">if</span> (cover != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cover.transferTo(<span class="keyword">new</span> File(uploadFile.getPath() + Constants.COVER_IMAGE_SUFFIX));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.error(<span class="string">&quot;上传文件失败&quot;</span>, e);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">&quot;文件上传失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后更新chat_message表,利用拿到的messageId,状态改为已发送.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ChatMessage updateInfo = <span class="keyword">new</span> <span class="constructor">ChatMessage()</span>;</span><br><span class="line">updateInfo.set<span class="constructor">Status(MessageStatusEnum.SENDED.<span class="params">getStatus</span>()</span>);</span><br><span class="line">ChatMessageQuery messageQuery = <span class="keyword">new</span> <span class="constructor">ChatMessageQuery()</span>;</span><br><span class="line">messageQuery.set<span class="constructor">MessageId(<span class="params">messageId</span>)</span>;</span><br><span class="line">chatMessageMapper.update<span class="constructor">ByParam(<span class="params">updateInfo</span>, <span class="params">messageQuery</span>)</span>;</span><br></pre></td></tr></table></figure><p>最后通过messageHandler发送给消息的接收者,表明文件上传成功,可以下载了.消息内容包含messageId,这样接收者可以利用这个id下载文件</p><h4 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h4><p>注意文件包括用户/群聊头像还包括消息中的文件,如果是消息id(全为整数),就会根据消息id查询发送时间,拼接为文件路径,然后下载. 首先检查消息接收者是否符合.</p><p>然后通过消息id和发送时间找到对应路径的文件,BASE_FOLDER+FILE+yyyyMM+message_id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String month = DateUtil.format(<span class="keyword">new</span> Date(message.getSendTime()), DateTimePatternEnum.YYYYMM.getPattern());</span><br><span class="line">File folder = <span class="keyword">new</span> File(appConfig.getProjectFolder() + Constants.FILE_FOLDER_FILE + month);</span><br><span class="line"><span class="keyword">if</span> (!folder.exists()) &#123;</span><br><span class="line">    folder.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">String fileName = message.getFileName();</span><br><span class="line">String fileExtName = StringTools.getFileSuffix(fileName);</span><br><span class="line">String fileRealName = messageId + fileExtName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cover != <span class="keyword">null</span> &amp;&amp; cover) &#123;</span><br><span class="line">    fileRealName = fileRealName + Constants.COVER_IMAGE_SUFFIX;</span><br><span class="line">&#125;</span><br><span class="line">File file = <span class="keyword">new</span> File(folder.getPath() + <span class="string">&quot;/&quot;</span> + fileRealName);</span><br><span class="line"><span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ResponseCodeEnum.CODE_602);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> file;</span><br></pre></td></tr></table></figure><p>否则是用户/群聊Id(U或者G前缀),拼接用户id找到路径然后下载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String avatarFolderName = Constants.FILE_FOLDER_FILE + Constants.FILE_FOLDER_AVATAR_NAME;</span><br><span class="line">String avatarPath = appConfig.getProjectFolder() + avatarFolderName + fileId + Constants.IMAGE_SUFFIX;</span><br><span class="line"><span class="keyword">if</span> (showCover) &#123;</span><br><span class="line">    avatarPath = avatarPath + Constants.COVER_IMAGE_SUFFIX;</span><br><span class="line">&#125;</span><br><span class="line">file = <span class="keyword">new</span> File(avatarPath);</span><br><span class="line"><span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ResponseCodeEnum.CODE_602);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下载使用<code>FileInputStream</code>和<code>HttpServletResponse.getOutputStream()</code>,每次读1024字节(1KB),避免文件过大.注意设置response头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;application/x-msdownload; charset=UTF-8&quot;</span>);</span><br><span class="line">response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;&quot;</span>);</span><br><span class="line">response.setContentLengthLong(file.length());</span><br></pre></td></tr></table></figure><p>主要设置content-type,content-disposition,content-length头</p><h1 id="EasyPan"><a href="#EasyPan" class="headerlink" title="EasyPan"></a>EasyPan</h1><p><a href="https://docs.qq.com/doc/DY1JTbU9kSkRPUUVY">03.Java项目创建</a></p><h3 id="IDE设置"><a href="#IDE设置" class="headerlink" title="IDE设置"></a>IDE设置</h3><h4 id="JDK位置设置"><a href="#JDK位置设置" class="headerlink" title="JDK位置设置"></a>JDK位置设置</h4><p><img data-src="https://s2.loli.net/2025/05/14/Wpwxn17jzJYgNiZ.png" alt="image-20250514230635404"></p><h4 id="编译器自动构建与热交换"><a href="#编译器自动构建与热交换" class="headerlink" title="编译器自动构建与热交换"></a>编译器自动构建与热交换</h4><p><img data-src="https://s2.loli.net/2025/05/14/IouNVMneLkvw5xd.png" alt="image-20250514230730743"></p><p><img data-src="https://s2.loli.net/2025/05/14/fHxKr3uUjsJwGTV.png" alt="image-20250514230903350"></p><p><img data-src="https://s2.loli.net/2025/05/14/VIFQjYLmdoMyuT4.png" alt="image-20250514230936534"></p><h4 id="设置Maven位置"><a href="#设置Maven位置" class="headerlink" title="设置Maven位置"></a>设置Maven位置</h4><p><img data-src="https://s2.loli.net/2025/05/14/AYdCIP8NLceGyig.png" alt="image-20250514231336188"></p><h4 id="设置文件编码"><a href="#设置文件编码" class="headerlink" title="设置文件编码"></a>设置文件编码</h4><p><img data-src="https://s2.loli.net/2025/05/14/gfJ2BtnGVdkwj4a.png" alt="image-20250514231119345"></p><h4 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h4><p><img data-src="https://s2.loli.net/2025/05/14/PWJutmFC9iZyXNn.png" alt="image-20250514231258500"></p><p>或创建Spring Boot项目</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="POM-xml"><a href="#POM-xml" class="headerlink" title="POM.xml"></a>POM.xml</h4><h5 id="项目基本信息"><a href="#项目基本信息" class="headerlink" title="项目基本信息"></a>项目基本信息</h5><ul><li><code>&lt;modelVersion&gt;</code>：指定 POM 模型的版本，通常为 <code>4.0.0</code>。</li><li><code>&lt;groupId&gt;</code>：定义项目所属的组织或公司，通常使用反向域名表示。</li><li><code>&lt;artifactId&gt;</code>：项目的唯一标识符，通常对应项目名称。</li><li><code>&lt;version&gt;</code>：项目的当前版本号。</li><li><code>&lt;packaging&gt;</code>：指定项目的打包方式，如 <code>jar</code>、<code>war</code> 等。</li><li><code>&lt;name&gt;</code>：项目的名称。</li><li><code>&lt;description&gt;</code>：项目的简要描述。</li></ul><h5 id="继承与模块管理"><a href="#继承与模块管理" class="headerlink" title="继承与模块管理"></a>继承与模块管理</h5><ul><li><code>&lt;parent&gt;</code>：指定当前项目继承的父 POM，便于共享统一的配置和依赖管理。</li><li><code>&lt;modules&gt;</code>：在多模块项目中，列出所有子模块的目录名称。</li></ul><h5 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h5><ul><li><code>&lt;dependencies&gt;</code>：列出项目所需的所有依赖项。</li><li><code>&lt;dependencyManagement&gt;</code>：用于统一管理依赖的版本信息，子项目可以引用而无需指定版本。</li><li><code>&lt;repositories&gt;</code>：指定额外的远程仓库地址，以获取依赖。</li></ul><h5 id="构建配置"><a href="#构建配置" class="headerlink" title="构建配置"></a>构建配置</h5><ul><li><p><code>&lt;build&gt;</code>：定义项目的构建相关配置。</p><ul><li><code>&lt;sourceDirectory&gt;</code>：指定源代码目录。</li><li><code>&lt;outputDirectory&gt;</code>：指定编译输出目录。</li><li><code>&lt;plugins&gt;</code>：配置构建过程中使用的插件，如 <code>maven-compiler-plugin</code> 等。</li></ul><p><strong>默认目录结构</strong></p><ul><li><strong>主源代码目录</strong>：<code>src/main/java</code></li><li><strong>主资源目录</strong>：<code>src/main/resources</code></li><li><strong>测试源代码目录</strong>：<code>src/test/java</code></li><li><strong>测试资源目录</strong>：<code>src/test/resources</code></li><li><strong>构建输出目录</strong>：<code>target/</code></li><li><strong>主类输出目录</strong>：<code>target/classes</code></li><li><strong>测试类输出目录</strong>：`target/test-classes</li></ul><p>这些默认设置源自于 Maven 的 Super POM<a href="https://maven.apache.org/ref/3.9.9/maven-model-builder/super-pom.html">Maven Model Builder – Super POM</a>，所有项目在未显式配置的情况下都会继承这些设置</p><p><strong>自定义输入目录</strong></p><p>如果项目结构不同于 Maven 的默认结构，可以在 <code>pom.xml</code> 中自定义输入目录。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>src/my-src<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>src/my-test<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/my-resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述配置将主源代码目录更改为 <code>src/my-src</code>，测试源代码目录更改为 <code>src/my-test</code>，资源目录更改为 <code>src/my-resources</code>。</p></li></ul><h5 id="属性定义"><a href="#属性定义" class="headerlink" title="属性定义"></a>属性定义</h5><ul><li><code>&lt;properties&gt;</code>：定义可在 POM 中引用的变量，便于统一管理版本号等信息。 </li></ul><h5 id="构建环境与发布配置"><a href="#构建环境与发布配置" class="headerlink" title="构建环境与发布配置"></a>构建环境与发布配置</h5><ul><li><code>&lt;profiles&gt;</code>：定义不同的构建配置，便于在不同环境下使用。</li><li><code>&lt;distributionManagement&gt;</code>：配置项目的发布信息，如部署到的仓库地址等。</li></ul><p><a href="https://maven.apache.org/guides/introduction/introduction-to-the-pom.html">Introduction to the POM – Maven</a></p><h4 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h4><blockquote><p>Spring Boot 使用 Commons Logging 进行所有内部日志记录，但底层日志实现保持开放。为 Java Util Logging、Log4j2 和 Logback 提供了默认配置。在每种情况下，日志记录器都预先配置为使用控制台输出，同时也可以选择文件输出。</p></blockquote><p><img data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongju/logback-6ba1b465-5533-49dd-b875-48a10ba29f8e.png" alt="img" style="zoom:67%;" /></p><p>当前版本logback中重要组件包括appender,也就是配置日志的输出目的地，通过 name 属性指定名字，通过 class 属性指定目的地：</p><ul><li>ch.qos.logback.core.ConsoleAppender：输出到控制台。</li><li>ch.qos.logback.core.FileAppender：输出到文件。</li><li>ch.qos.logback.core.rolling.RollingFileAppender：文件大小超过阈值时产生一个新文件。</li></ul><p>encoder,logger以及root,它只支持一个属性——level，值可以为：TRACE、DEBUG、INFO、WARN、ERROR、ALL、OFF.</p><p><strong><code>&lt;property&gt;</code></strong>：定义的变量可以在整个配置文件中通过 <code>$&#123;&#125;</code> 引用，便于维护和修改。</p><p><strong><code>&lt;appender&gt;</code></strong>：定义日志的输出方式。</p><ul><li><strong><code>ConsoleAppender</code></strong>：将日志输出到控制台。</li><li><strong><code>RollingFileAppender</code></strong>：将日志输出到文件，并支持按时间滚动生成新文件。</li></ul><p><strong><code>&lt;logger&gt;</code></strong>：为特定的包或类设置日志级别和输出方式。</p><p><strong><code>&lt;root&gt;</code></strong>：定义默认的日志级别和输出方式，适用于未被其他 <code>logger</code> 捕获的日志。</p><p>pattern 用来指定日志的输出格式：</p><ul><li><code>%d</code>：输出的时间格式。</li><li><code>%thread</code>：日志的线程名。</li><li><code>%-5level</code>：日志的输出级别，填充到 5 个字符。比如说 info 只有 4 个字符，就填充一个空格，这样日志信息就对齐了。</li><li><code>%logger&#123;length&#125;</code>：logger 的名称，length 用来缩短名称。没有指定表示完整输出；0 表示只输出 logger 最右边点号之后的字符串；其他数字表示输出小数点最后边点号之前的字符数量。</li><li><code>%msg</code>：日志的具体信息。</li><li><code>%n</code>：换行符。</li><li><code>%relative</code>：输出从程序启动到创建日志记录的时间，单位为毫秒。</li></ul><p><code>logback-spring.xml</code>提供了<code>&lt;springProperty&gt;</code>以及<code>&lt;springProfile&gt;</code>可以读取springBoot配置文件中的属性.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;stdot&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss,GMT+8&#125; [%p][%c][%M][%L]-&gt; %m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/$&#123;LOG_FOLDER&#125;/$&#123;LOG_FILE_NAME&#125;<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;fileNamePattern&gt;$&#123;log.path&#125;/$&#123;LOG_FOLDER&#125;/$&#123;LOG_FILE_NAME&#125;.%d&#123;yyyy-MM-dd&#125;.%i&lt;/fileNamePattern&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;totalSizeCap&gt;5G&lt;/totalSizeCap&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;maxHistory&gt;30&lt;/maxHistory&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/rollingPolicy&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- rollover daily --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/$&#123;LOG_FOLDER&#125;/$&#123;LOG_FILE_NAME&#125;.%d&#123;yyyy-MM-dd&#125;.%i<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- each file should be at most 100MB, keep 60 days worth of history, but at most 20GB --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>60<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>20GB<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss,GMT+8&#125; [%p][%c][%M][%L]-&gt; %m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">&quot;context&quot;</span> <span class="attr">name</span>=<span class="string">&quot;log.path&quot;</span> <span class="attr">source</span>=<span class="string">&quot;project.folder&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">&quot;context&quot;</span> <span class="attr">name</span>=<span class="string">&quot;log.root.level&quot;</span> <span class="attr">source</span>=<span class="string">&quot;log.root.level&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_FOLDER&quot;</span> <span class="attr">value</span>=<span class="string">&quot;logs&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_FILE_NAME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;easypan.log&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--    &lt;logger name=&quot;top.sekyoro.easypan&quot; level=&quot;$&#123;log.root.level&#125;&quot;&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;appender-ref ref=&quot;stdot&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;appender-ref ref=&quot;file&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/logger&gt;   --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;$&#123;log.root.level&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;stdot&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://docs.spring.io/spring-boot/reference/features/logging.html#features.logging.logback-extensions">Logging :: Spring Boot</a></li><li><a href="https://logback.qos.ch/manual/encoders.html">Chapter 5: Encoders</a></li><li><a href="https://logback.qos.ch/codes.html#layoutInsteadOfEncoder">Logback Error Codes</a></li><li><a href="https://javabetter.cn/gongju/logback.html#_03、把-log4j-properties-转成-logback-test-xml">Logback：Spring Boot内置的日志处理框架 | 二哥的Java进阶之路</a></li><li><a href="https://docs.spring.io/spring-boot/docs/2.1.8.RELEASE/reference/html/boot-features-logging.html#boot-features-logback-extensions">26. Logging</a></li></ul><h4 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h4><h5 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h5><ul><li><code>server.port=8080</code>：设置应用的端口号。</li><li><code>server.servlet.context-path=/api</code>：设置应用的上下文路径。</li></ul><h5 id="应用信息"><a href="#应用信息" class="headerlink" title="应用信息"></a>应用信息</h5><ul><li><code>spring.application.name=myapp</code>：设置应用的名称。</li></ul><h5 id="数据源配置（以-MySQL-为例）"><a href="#数据源配置（以-MySQL-为例）" class="headerlink" title="数据源配置（以 MySQL 为例）"></a>数据源配置（以 MySQL 为例）</h5><ul><li><code>spring.datasource.url=jdbc:mysql://localhost:3306/db_example</code></li><li><code>spring.datasource.username=root</code></li><li><code>spring.datasource.password=secret</code></li><li><code>spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</code></li><li><code>spring.jpa.hibernate.ddl-auto=update</code>：设置 JPA 的 DDL 策略。</li></ul><h5 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h5><ul><li><code>logging.level.root=INFO</code>：设置根日志级别。</li><li><code>logging.level.com.example=DEBUG</code>：设置特定包的日志级别。</li><li><code>logging.file.name=logs/app.log</code>：设置日志文件名称。</li><li><code>logging.pattern.console=%d&#123;yyyy-MM-dd HH:mm:ss&#125; - %msg%n</code>：设置控制台日志输出格式</li></ul><h5 id="邮件配置"><a href="#邮件配置" class="headerlink" title="邮件配置"></a>邮件配置</h5><ul><li><code>spring.mail.host=smtp.example.com</code></li><li><code>spring.mail.port=587</code></li><li><code>spring.mail.username=user@example.com</code></li><li><code>spring.mail.password=secret</code></li><li><code>spring.mail.properties.mail.smtp.auth=true</code></li><li><code>spring.mail.properties.mail.smtp.starttls.enable=true</code></li></ul><h5 id="安全配置"><a href="#安全配置" class="headerlink" title="安全配置"></a>安全配置</h5><ul><li><code>spring.security.user.name=admin</code></li><li><code>spring.security.user.password=secret</code></li><li><code>spring.security.user.roles=USER,ADMIN</code></li></ul><h5 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h5><ul><li><code>spring.cache.type=simple</code>：设置缓存类型。</li><li><code>spring.cache.cache-names=users,transactions</code>：定义缓存名称。</li></ul><h5 id="国际化配置"><a href="#国际化配置" class="headerlink" title="国际化配置"></a>国际化配置</h5><ul><li><code>spring.messages.basename=messages</code>：设置消息资源文件的基础名称。</li><li><code>spring.messages.encoding=UTF-8</code>：设置消息资源文件的编码。</li></ul><h5 id="测试配置"><a href="#测试配置" class="headerlink" title="测试配置"></a>测试配置</h5><ul><li><code>spring.main.allow-bean-definition-overriding=true</code>：允许覆盖 Bean 定义。</li><li><code>spring.profiles.active=dev</code>：设置活动的配置文件。</li></ul><p><strong>注意</strong>:1.新版本中,<code>spring.mvc.throw-exception-if-no-handler-found</code> 属性已被<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/deprecated-list.html">弃用</a>，建议不再使用。默认情况下,Spring Boot 会返回 404 响应，无需额外配置。</p><p>2.<code>spring.mvc.favicon.enable=false</code>配置属性已弃用。此外，Spring Boot 不再提供默认的 favicon，因为此图标可被视为信息泄露,可以增加对应handler.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FaviconConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/favicon.ico&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/static/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.baeldung-cn.com/spring-boot-favicon">Spring Boot中favicon的指南 | Baeldung中文网</a></p><p>相关文档</p><ul><li><a href="https://docs.spring.io/spring-boot/appendix/application-properties/index.html">Common Application Properties :: Spring Boot</a></li><li><a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/common-application-properties.html">Appendix A. Common application properties</a></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应用服务 WEB 访问端口</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">7090</span></span><br><span class="line"><span class="meta">server.servlet.context-path</span>=<span class="string">/api</span></span><br><span class="line"><span class="comment">#session过期时间 60M 一个小时</span></span><br><span class="line"><span class="meta">server.servlet.session.timeout</span>=<span class="string">PT60M</span></span><br><span class="line"><span class="comment">#处理favicon</span></span><br><span class="line"><span class="comment">#spring.mvc.favicon.enable=false</span></span><br><span class="line"><span class="comment">#异常处理</span></span><br><span class="line"><span class="comment">#spring.mvc.throw-exception-if-no-handler-found=true</span></span><br><span class="line"><span class="meta">spring.web.resources.add-mappings</span>=<span class="string">false</span></span><br><span class="line"><span class="comment">#数据库配置</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/easypan?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.pool-name</span>=<span class="string">HikariCPDatasource</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.minimum-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.idle-timeout</span>=<span class="string">180000</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.maximum-pool-size</span>=<span class="string">10</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.auto-commit</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.max-lifetime</span>=<span class="string">1800000</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.connection-timeout</span>=<span class="string">30000</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.connection-test-query</span>=<span class="string">SELECT 1</span></span><br><span class="line"><span class="comment">#发送邮件配置相关</span></span><br><span class="line"><span class="comment"># 配置邮件服务器的地址 smtp.qq.com</span></span><br><span class="line"><span class="meta">spring.mail.host</span>=<span class="string">smtp.qq.com</span></span><br><span class="line"><span class="comment"># 配置邮件服务器的端口（465或587）</span></span><br><span class="line"><span class="meta">spring.mail.port</span>=<span class="string">465</span></span><br><span class="line"><span class="comment"># 配置用户的账号</span></span><br><span class="line"><span class="meta">spring.mail.username</span>=<span class="string">test@qq.com</span></span><br><span class="line"><span class="comment"># 配置用户的密码</span></span><br><span class="line"><span class="meta">spring.mail.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment"># 配置默认编码</span></span><br><span class="line"><span class="meta">spring.mail.default-encoding</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="comment"># SSL 连接配置</span></span><br><span class="line"><span class="meta">spring.mail.properties.mail.smtp.socketFactory.class</span>=<span class="string">javax.net.ssl.SSLSocketFactory</span></span><br><span class="line"><span class="comment"># 开启 debug，这样方便开发者查看邮件发送日志</span></span><br><span class="line"><span class="meta">spring.mail.properties.mail.debug</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#邮件配置结束</span></span><br><span class="line"><span class="comment">#Spring redis配置</span></span><br><span class="line"><span class="comment"># Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="meta">spring.data.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="meta">spring.data.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.data.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment"># 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.data.redis.jedis.pool.max-active</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.data.redis.jedis.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment"># 连接池中的最大空闲连接</span></span><br><span class="line"><span class="meta">spring.data.redis.jedis.pool.max-idle</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 连接池中的最小空闲连接</span></span><br><span class="line"><span class="meta">spring.data.redis.jedis.pool.min-idle</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line"><span class="meta">spring.data.redis.timeout</span>=<span class="string">2000</span></span><br></pre></td></tr></table></figure><h3 id="业务重点流程"><a href="#业务重点流程" class="headerlink" title="业务重点流程"></a>业务重点流程</h3><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p><img data-src="https://s2.loli.net/2025/07/22/Udzg4jYavtVsL3Z.png" alt="image-20250722174319746"></p><p>表中(file_id,user_id)为联合主键. controller参数包含fileId,file,fileName,filePid,fileMd5,chunkIndex,chunks. </p><p>当刚开始上传时,chunkIndex=0,查看filemd5是否包含这个文件,并且当前空闲空间+文件空间大于总空间,如果查到了,则直接上传,如果文件名重复,重命名,插入数据库(file_id和文件名可能不同,还需要在数据库中插入)</p><p>然后更新使用空间,然后返回秒传响应即可. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chunkIndex=0下</span></span><br><span class="line">FileInfoQuery infoQuery = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line">infoQuery.setFileMd5(fileMd5);</span><br><span class="line">infoQuery.setSimplePage(<span class="keyword">new</span> SimplePage(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">infoQuery.setStatus(FileStatusEnums.USING.getStatus());</span><br><span class="line">List&lt;FileInfo&gt; dbFileList = <span class="keyword">this</span>.fileInfoMapper.selectList(infoQuery);</span><br><span class="line"><span class="comment">//秒传</span></span><br><span class="line"><span class="keyword">if</span> (!dbFileList.isEmpty()) &#123;</span><br><span class="line">    FileInfo dbFile = dbFileList.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//判断文件状态</span></span><br><span class="line">    <span class="keyword">if</span> (dbFile.getFileSize() + spaceDto.getUseSpace() &gt; spaceDto.getTotalSpace()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ResponseCodeEnum.CODE_904);</span><br><span class="line">    &#125;</span><br><span class="line">    dbFile.setFileId(fileId);</span><br><span class="line">    dbFile.setFilePid(filePid);</span><br><span class="line">    dbFile.setUserId(webUserDto.getUserId());</span><br><span class="line">    dbFile.setFileMd5(<span class="keyword">null</span>);</span><br><span class="line">    dbFile.setCreateTime(curDate);</span><br><span class="line">    dbFile.setLastUpdateTime(curDate);</span><br><span class="line">    dbFile.setStatus(FileStatusEnums.USING.getStatus());</span><br><span class="line">    dbFile.setDelFlag(FileDelFlagEnums.USING.getFlag());</span><br><span class="line">    dbFile.setFileMd5(fileMd5);</span><br><span class="line">    fileName = autoRename(filePid, webUserDto.getUserId(), fileName);</span><br><span class="line">    dbFile.setFileName(fileName);</span><br><span class="line">    <span class="keyword">this</span>.fileInfoMapper.insert(dbFile);</span><br><span class="line">    resultDto.setStatus(UploadStatusEnums.UPLOAD_SECONDS.getCode());</span><br><span class="line">    <span class="comment">//更新用户空间使用</span></span><br><span class="line">    updateUserSpace(webUserDto, dbFile.getFileSize());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resultDto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后获取这个切片当前占用存储,如果大于总空间就报异常.</p><p>然后确定下载的chunk路径,BASE_FOLDER+FILE+user_id_file_id+chunkIndex,然后下载到对应位置,增加占用的临时存储空间.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暂存在临时目录</span></span><br><span class="line">String tempFolderName = appConfig.getProjectFolder() + Constants.FILE_FOLDER_TEMP;</span><br><span class="line">String currentUserFolderName = webUserDto.getUserId() + fileId;</span><br><span class="line"><span class="comment">//创建临时目录</span></span><br><span class="line">tempFileFolder = <span class="keyword">new</span> File(tempFolderName + currentUserFolderName);</span><br><span class="line"><span class="keyword">if</span> (!tempFileFolder.exists()) &#123;</span><br><span class="line">    tempFileFolder.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断磁盘空间</span></span><br><span class="line">Long currentTempSize = redisComponent.getFileTempSize(webUserDto.getUserId(), fileId);</span><br><span class="line"><span class="keyword">if</span> (file.getSize() + currentTempSize + spaceDto.getUseSpace() &gt; spaceDto.getTotalSpace()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ResponseCodeEnum.CODE_904);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File newFile = <span class="keyword">new</span> File(tempFileFolder.getPath() + <span class="string">&quot;/&quot;</span> + chunkIndex);</span><br><span class="line">file.transferTo(newFile);</span><br><span class="line"><span class="comment">//保存临时大小</span></span><br><span class="line">redisComponent.saveFileTempSize(webUserDto.getUserId(), fileId, file.getSize());</span><br><span class="line"><span class="comment">//不是最后一个分片，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (chunkIndex &lt; chunks - <span class="number">1</span>) &#123;</span><br><span class="line">    resultDto.setStatus(UploadStatusEnums.UPLOADING.getCode());</span><br><span class="line">    <span class="keyword">return</span> resultDto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不是最后一个分片,直接返回,响应设置上传状态.</p><p>当上传完最后一个文件分片时,表示上传完成,将相关文件信息插入数据库,文件状态设置为TRANSFER. 也做了缩略图处理,如果是视频,生成缩略图(使用ffmepg String cmd = “ffmpeg -i %s -y -vframes 1 -vf scale=%d:%d/a %s”;),如果是图片,也可以压缩得到缩略图String cmd = “ffmpeg -i %s -vf scale=%d:-1 %s -y”; 此外,视频会进行切割,得到不同的ts片段和m3u8索引文件. 如果是h.265转为h.264,h.264转成ts,然后进行切片得到ts文件与m3u8索引文件.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建同名切片目录</span></span><br><span class="line">File tsFolder = <span class="keyword">new</span> File(videoFilePath.substring(<span class="number">0</span>, videoFilePath.lastIndexOf(<span class="string">&quot;.&quot;</span>)));</span><br><span class="line"><span class="keyword">if</span> (!tsFolder.exists()) &#123;</span><br><span class="line">    tsFolder.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String CMD_GET_CODE = <span class="string">&quot;ffprobe -v error -select_streams v:0 -show_entries stream=codec_name %s&quot;</span>;</span><br><span class="line">String cmd = String.format(CMD_GET_CODE, videoFilePath);</span><br><span class="line">String result = ProcessUtils.executeCommand(cmd, <span class="keyword">false</span>);</span><br><span class="line">result = result.replace(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">result = result.substring(result.indexOf(<span class="string">&quot;=&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">String codec = result.substring(<span class="number">0</span>, result.indexOf(<span class="string">&quot;[&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//转码</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;hevc&quot;</span>.equals(codec)) &#123;</span><br><span class="line">    String newFileName = videoFilePath.substring(<span class="number">0</span>, videoFilePath.lastIndexOf(<span class="string">&quot;.&quot;</span>)) + <span class="string">&quot;_&quot;</span> + videoFilePath.substring(videoFilePath.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    <span class="keyword">new</span> File(videoFilePath).renameTo(<span class="keyword">new</span> File(newFileName));</span><br><span class="line">    String CMD_HEVC_264 = <span class="string">&quot;ffmpeg -i %s -c:v libx264 -crf 20 %s&quot;</span>;</span><br><span class="line">    cmd = String.format(CMD_HEVC_264, newFileName, videoFilePath);</span><br><span class="line">    ProcessUtils.executeCommand(cmd, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">new</span> File(newFileName).delete();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String CMD_TRANSFER_2TS = <span class="string">&quot;ffmpeg -y -i %s  -vcodec copy -acodec copy -bsf:v h264_mp4toannexb %s&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> String CMD_CUT_TS = <span class="string">&quot;ffmpeg -i %s -c copy -map 0 -f segment -segment_list %s -segment_time 30 %s/%s_%%4d.ts&quot;</span>;</span><br><span class="line"></span><br><span class="line">String tsPath = tsFolder + <span class="string">&quot;/&quot;</span> + Constants.TS_NAME;</span><br><span class="line"><span class="comment">//生成.ts</span></span><br><span class="line">cmd = String.format(CMD_TRANSFER_2TS, videoFilePath, tsPath);</span><br><span class="line">ProcessUtils.executeCommand(cmd, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//生成索引文件.m3u8 和切片.ts</span></span><br><span class="line">cmd = String.format(CMD_CUT_TS, tsPath, tsFolder.getPath() + <span class="string">&quot;/&quot;</span> + Constants.M3U8_NAME, tsFolder.getPath(), fileId);</span><br><span class="line">ProcessUtils.executeCommand(cmd, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//删除index.ts</span></span><br><span class="line"><span class="keyword">new</span> File(tsPath).delete();</span><br></pre></td></tr></table></figure><p>同时异步进行文件合并,文件合并就是将chunks写入到一个文件中.同时更新数据库中文件状态.</p><p>在事务提交之后调用合并,截取封面以及视频编码等业务.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务提交后调用异步方法</span></span><br><span class="line">TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronization() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fileInfoService.transferFile(fileInfo.getFileId(), webUserDto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="文件预览"><a href="#文件预览" class="headerlink" title="文件预览"></a>文件预览</h3><h4 id="普通文件预览"><a href="#普通文件预览" class="headerlink" title="普通文件预览"></a>普通文件预览</h4><h4 id="缩略图预览"><a href="#缩略图预览" class="headerlink" title="缩略图预览"></a>缩略图预览</h4><h4 id="视频预览"><a href="#视频预览" class="headerlink" title="视频预览"></a>视频预览</h4><p>返回m3u8索引文件以及ts文件,</p><p>如果是下载ts文件,为了避免下载单个文件过大或者说进行播放时需要分片播放,可以通过在请求头携带range</p><p>而响应头携带</p><p><code>206</code> 响应通常伴随的头部：</p><p>当服务器返回 <code>206 Partial Content</code> 状态码时，通常会同时设置以下响应头：</p><ol><li><p><strong><code>Content-Range</code></strong>:</p><ul><li><strong>作用：</strong> 这是最重要的头，它明确告知客户端当前响应体中包含的是<strong>整个资源的哪一部分</strong>，以及<strong>整个资源的总大小</strong>。</li><li><strong>格式：</strong> <code>Content-Range: bytes &lt;start&gt;-&lt;end&gt;/&lt;total_length&gt;</code></li><li><strong>示例：</strong> <code>Content-Range: bytes 1024-2047/2048</code> 表示响应体中是文件的第 1024 字节到第 2047 字节，整个文件总大小是 2048 字节。</li></ul></li><li><p><strong><code>Content-Length</code></strong>:</p><ul><li><strong>作用：</strong> 表示<strong>当前响应体中实际传输的字节数</strong>（即 <code>end - start + 1</code>）。</li><li><strong>示例：</strong> 如果 <code>Content-Range</code> 是 <code>bytes 1024-2047/2048</code>，那么 <code>Content-Length</code> 应该是 <code>1024</code>。</li></ul></li><li><p><strong><code>Content-Type</code></strong>:</p><ul><li><strong>作用：</strong> 仍然需要指示响应体中内容的媒体类型（MIME type），即使是部分内容。</li></ul></li><li><p><strong><code>Accept-Ranges</code></strong>:</p><ul><li><strong>作用：</strong> 通常在第一次（完整）请求时就设置 <code>Accept-Ranges: bytes</code>，告诉客户端服务器支持范围请求。如果服务器返回 <code>206</code> 状态码，这意味着它肯定支持 <code>bytes</code> 范围。</li></ul><hr><p>分片下载，也称为<strong>断点续传（Resumable Download）或范围请求（Range Request）</strong>，是 HTTP 协议允许客户端只请求资源的部分内容的一种机制。当客户端需要进行分片下载时，它会在请求头中携带特定的信息来告诉服务器它想要哪些部分的数据。</p><h5 id="分片下载时客户端请求头携带的关键信息"><a href="#分片下载时客户端请求头携带的关键信息" class="headerlink" title="分片下载时客户端请求头携带的关键信息"></a>分片下载时客户端请求头携带的关键信息</h5><p>在分片下载场景中，客户端的 HTTP 请求头主要会携带以下一个或多个关键信息：</p><p><code>Range</code> 请求头</p><p>这是进行分片下载<strong>最核心、最重要</strong>的请求头。它明确告诉服务器客户端想要获取资源内容的哪一部分。</p><ul><li><p><strong>作用：</strong> 指示客户端请求的是文件的特定字节范围。</p></li><li><p><strong>格式：</strong> <code>Range: bytes=&lt;start&gt;-&lt;end&gt;</code></p><ul><li><code>&lt;start&gt;</code>: 想要获取的起始字节偏移量（从 0 开始计数）。</li><li><code>&lt;end&gt;</code>: 想要获取的结束字节偏移量。</li></ul></li><li><p><strong>常用变体：</strong></p><ul><li><strong>请求从某个字节到文件末尾：</strong> <code>Range: bytes=1024-</code><ul><li>这表示客户端想要从文件的第 1024 字节开始，一直到文件末尾的所有内容。</li></ul></li><li><strong>请求文件的最后 N 个字节：</strong> <code>Range: bytes=-500</code><ul><li>这表示客户端想要文件的最后 500 个字节。</li></ul></li><li><strong>请求多个不连续的范围：</strong> <code>Range: bytes=0-100, 200-300</code> (服务器不一定支持，但 HTTP 规范允许)<ul><li>这表示客户端想要第 0-100 字节和第 200-300 字节。</li></ul></li></ul></li><li><p><strong>示例：</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/path/to/large_file.zip</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">Range</span><span class="punctuation">: </span>bytes=5242880-10485759  # 请求文件的第 5MB 到 第 10MB 部分</span><br></pre></td></tr></table></figure></li></ul><p><code>If-Range</code> 请求头 (用于条件范围请求)</p><p>这个请求头通常与 <code>Range</code> 一起使用，以实现<strong>条件性断点续传</strong>。它允许客户端在请求特定范围之前，先验证资源是否在上次下载后被修改过。</p><ul><li><p><strong>作用：</strong> 如果服务器上资源的 <code>ETag</code> 或 <code>Last-Modified</code> 日期与 <code>If-Range</code> 中的值匹配，服务器才会返回请求的范围内容（<code>206 Partial Content</code>）。否则，服务器会忽略 <code>Range</code> 头，并返回整个文件（<code>200 OK</code>），因为资源已经被修改，部分内容可能已经不再有效。</p></li><li><p><strong>格式：</strong></p><ul><li><code>If-Range: &quot;&lt;ETag_value&gt;&quot;</code> (使用资源的 ETag)</li><li><code>If-Range: &lt;HTTP-date&gt;</code> (使用资源的 Last-Modified 日期)</li></ul></li><li><p><strong>示例：</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/path/to/large_file.zip</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">Range</span><span class="punctuation">: </span>bytes=5242880-         # 客户端请求续传</span><br><span class="line"><span class="attribute">If-Range</span><span class="punctuation">: </span>&quot;abcdef1234567890&quot;  # 如果资源的ETag与此匹配，则继续传输范围内容</span><br></pre></td></tr></table></figure><ul><li>如果服务器发现文件的 ETag 变了，说明文件被修改了，它会返回整个文件（<code>200 OK</code>）。</li><li>如果 ETag 没变，服务器就会返回请求的范围内容（<code>206 Partial Content</code>）。</li></ul></li></ul></li></ol><p>重要响应状态码:206 部分内容 301 永久重定向 302 暂时重定向 </p><h3 id="目录相关"><a href="#目录相关" class="headerlink" title="目录相关"></a>目录相关</h3><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p>首先校验文件名字,在当前目录下不能有重名的</p><p>插入file_info表,设置FOLER类型,插入即可. 但注意插入完成后再次进行查询确保只有一个 </p><p>这时因为在并发条件下,如果一个两个事务执行,开始时它们查到没有重名,而进行插入,其中一个拿到互斥锁插入成功并提交事务. 释放锁后,另一个拿到锁也进行插入,插入后需要进行当前读看是否唯一.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">checkFileName(filePid, userId, folderName, FileFolderTypeEnums.FOLDER.getType());</span><br><span class="line">Date curDate = <span class="keyword">new</span> Date();</span><br><span class="line">FileInfo fileInfo = <span class="keyword">new</span> FileInfo();</span><br><span class="line">fileInfo.setFileId(StringTools.getRandomString(Constants.LENGTH_10));</span><br><span class="line">fileInfo.setUserId(userId);</span><br><span class="line">fileInfo.setFilePid(filePid);</span><br><span class="line">fileInfo.setFileName(folderName);</span><br><span class="line">fileInfo.setFolderType(FileFolderTypeEnums.FOLDER.getType());</span><br><span class="line">fileInfo.setCreateTime(curDate);</span><br><span class="line">fileInfo.setLastUpdateTime(curDate);</span><br><span class="line">fileInfo.setStatus(FileStatusEnums.USING.getStatus());</span><br><span class="line">fileInfo.setDelFlag(FileDelFlagEnums.USING.getFlag());</span><br><span class="line"><span class="keyword">this</span>.fileInfoMapper.insert(fileInfo);</span><br><span class="line"></span><br><span class="line">FileInfoQuery fileInfoQuery = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line">fileInfoQuery.setFilePid(filePid);</span><br><span class="line">fileInfoQuery.setUserId(userId);</span><br><span class="line">fileInfoQuery.setFileName(folderName);</span><br><span class="line">fileInfoQuery.setFolderType(FileFolderTypeEnums.FOLDER.getType());</span><br><span class="line">fileInfoQuery.setDelFlag(FileDelFlagEnums.USING.getFlag());</span><br><span class="line">Integer count = <span class="keyword">this</span>.fileInfoMapper.selectCount(fileInfoQuery); <span class="comment">// select xx for update</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">&quot;文件夹&quot;</span> + folderName + <span class="string">&quot;已经存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fileInfo.setFileName(folderName);</span><br><span class="line">fileInfo.setLastUpdateTime(curDate);</span><br><span class="line"><span class="keyword">return</span> fileInfo;</span><br></pre></td></tr></table></figure><h4 id="获取当前目录"><a href="#获取当前目录" class="headerlink" title="获取当前目录"></a>获取当前目录</h4><p>传入路径,路径是每个目录的id相连,比如11122/3344,表示在这个目录下.</p><p>获取这两个目录的信息,相当于获取了从根目录到当前目录的所有目录信息</p><h4 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h4><p>根据传入的fileId判断文件是否存在(是否合法),然后检查文件名是否重复,不重复再进行更新文件名称.</p><p>重命名类似新建目录,重命名完成后也需要看是否唯一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">FileInfo fileInfo = <span class="keyword">this</span>.fileInfoMapper.selectByFileIdAndUserId(fileId, userId);</span><br><span class="line"><span class="keyword">if</span> (fileInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fileInfo.getFileName().equals(fileName)) &#123;</span><br><span class="line">    <span class="keyword">return</span> fileInfo;</span><br><span class="line">&#125;</span><br><span class="line">String filePid = fileInfo.getFilePid();</span><br><span class="line">checkFileName(filePid, userId, fileName, fileInfo.getFolderType());</span><br><span class="line"><span class="comment">//文件获取后缀</span></span><br><span class="line"><span class="keyword">if</span> (FileFolderTypeEnums.FILE.getType().equals(fileInfo.getFolderType())) &#123;</span><br><span class="line">    fileName = fileName + StringTools.getFileSuffix(fileInfo.getFileName());</span><br><span class="line">&#125;</span><br><span class="line">Date curDate = <span class="keyword">new</span> Date();</span><br><span class="line">FileInfo dbInfo = <span class="keyword">new</span> FileInfo();</span><br><span class="line">dbInfo.setFileName(fileName);</span><br><span class="line">dbInfo.setLastUpdateTime(curDate);</span><br><span class="line"><span class="keyword">this</span>.fileInfoMapper.updateByFileIdAndUserId(dbInfo, fileId, userId);</span><br><span class="line"></span><br><span class="line">FileInfoQuery fileInfoQuery = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line">fileInfoQuery.setFilePid(filePid);</span><br><span class="line">fileInfoQuery.setUserId(userId);</span><br><span class="line">fileInfoQuery.setFileName(fileName);</span><br><span class="line">fileInfoQuery.setDelFlag(FileDelFlagEnums.USING.getFlag());</span><br><span class="line">Integer count = <span class="keyword">this</span>.fileInfoMapper.selectCount(fileInfoQuery);</span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">&quot;文件名&quot;</span> + fileName + <span class="string">&quot;已经存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fileInfo.setFileName(fileName);</span><br><span class="line">fileInfo.setLastUpdateTime(curDate);</span><br><span class="line"><span class="keyword">return</span> fileInfo;</span><br></pre></td></tr></table></figure><h4 id="获取所有目录"><a href="#获取所有目录" class="headerlink" title="获取所有目录"></a>获取所有目录</h4><p>获得父目录id,同时为了方便移动文件,传递需要移动文件的id,排除掉这些文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FileInfoQuery query = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line">query.setUserId(getUserInfoFromSession(session).getUserId());</span><br><span class="line">query.setFilePid(filePid);</span><br><span class="line">query.setFolderType(FileFolderTypeEnums.FOLDER.getType());</span><br><span class="line"><span class="keyword">if</span> (!StringTools.isEmpty(currentFileIds)) &#123;</span><br><span class="line">    query.setExcludeFileIdArray(currentFileIds.split(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">query.setDelFlag(FileDelFlagEnums.USING.getFlag());</span><br><span class="line">query.setOrderBy(<span class="string">&quot;create_time desc&quot;</span>);</span><br><span class="line">List&lt;FileInfo&gt; fileInfoList = fileInfoService.findListByParam(query);</span><br><span class="line"><span class="keyword">return</span> getSuccessResponseVO(CopyTools.copyList(fileInfoList, FileInfoVO.class));</span><br></pre></td></tr></table></figure><h4 id="移动文件-目录"><a href="#移动文件-目录" class="headerlink" title="移动文件/目录"></a>移动文件/目录</h4><p>首先判断传入的文件id是否合法,比如文件是否存在,移动到的目录是否存在,然后取出移动到的目录的所有文件名放在一个map中,遍历需要移动的文件,如果名称在map中,则进行重命名,然后更新文件信息,例如pid(目录)和文件名.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FileInfoQuery query = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line">query.setFilePid(filePid);</span><br><span class="line">query.setUserId(userId);</span><br><span class="line">List&lt;FileInfo&gt; dbFileList = fileInfoService.findListByParam(query);</span><br><span class="line"></span><br><span class="line">Map&lt;String, FileInfo&gt; dbFileNameMap = dbFileList.stream().collect(Collectors.toMap(FileInfo::getFileName, Function.identity(), (file1, file2) -&gt; file2));</span><br><span class="line"><span class="comment">//查询选中的文件</span></span><br><span class="line">query = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line">query.setUserId(userId);</span><br><span class="line">query.setFileIdArray(fileIdArray);</span><br><span class="line">List&lt;FileInfo&gt; selectFileList = fileInfoService.findListByParam(query);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将所选文件重命名</span></span><br><span class="line"><span class="keyword">for</span> (FileInfo item : selectFileList) &#123;</span><br><span class="line">    FileInfo rootFileInfo = dbFileNameMap.get(item.getFileName());</span><br><span class="line">    <span class="comment">//文件名已经存在，重命名被还原的文件名</span></span><br><span class="line">    FileInfo updateInfo = <span class="keyword">new</span> FileInfo();</span><br><span class="line">    <span class="keyword">if</span> (rootFileInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String fileName = StringTools.rename(item.getFileName());</span><br><span class="line">        updateInfo.setFileName(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">    updateInfo.setFilePid(filePid);</span><br><span class="line">    <span class="keyword">this</span>.fileInfoMapper.updateByFileIdAndUserId(updateInfo, item.getFileId(), userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回收站回收、还原以及彻底删除文件"><a href="#回收站回收、还原以及彻底删除文件" class="headerlink" title="回收站回收、还原以及彻底删除文件"></a>回收站回收、还原以及彻底删除文件</h3><h4 id="回收文件-目录"><a href="#回收文件-目录" class="headerlink" title="回收文件/目录"></a>回收文件/目录</h4><p>将传入的文件id依次加入到list中,如果它是目录,再递归将其下的文件放入list中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findAllSubFolderFileIdList</span><span class="params">(List&lt;String&gt; fileIdList, String userId, String fileId, Integer delFlag)</span> </span>&#123;</span><br><span class="line">    fileIdList.add(fileId);</span><br><span class="line">    FileInfoQuery query = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line">    query.setUserId(userId);</span><br><span class="line">    query.setFilePid(fileId);</span><br><span class="line">    query.setDelFlag(delFlag);</span><br><span class="line">    query.setFolderType(FileFolderTypeEnums.FOLDER.getType());</span><br><span class="line">    List&lt;FileInfo&gt; fileInfoList = <span class="keyword">this</span>.fileInfoMapper.selectList(query);</span><br><span class="line">    <span class="keyword">for</span> (FileInfo fileInfo : fileInfoList) &#123;</span><br><span class="line">        findAllSubFolderFileIdList(fileIdList, userId, fileInfo.getFileId(), delFlag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样选中的所有文件目录以及子目录都在list中,都进行更新为删除状态即可.</p><p>然后再将选中的文件和目录更新为回收状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">String[] fileIdArray = fileIds.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">FileInfoQuery query = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line">query.setUserId(userId);</span><br><span class="line">query.setFileIdArray(fileIdArray);</span><br><span class="line">query.setDelFlag(FileDelFlagEnums.USING.getFlag());</span><br><span class="line">List&lt;FileInfo&gt; fileInfoList = <span class="keyword">this</span>.fileInfoMapper.selectList(query);</span><br><span class="line"><span class="keyword">if</span> (fileInfoList.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; delFilePidList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (FileInfo fileInfo : fileInfoList) &#123;</span><br><span class="line">    findAllSubFolderFileIdList(delFilePidList, userId, fileInfo.getFileId(), FileDelFlagEnums.USING.getFlag());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将目录下的所有文件更新为已删除</span></span><br><span class="line"><span class="keyword">if</span> (!delFilePidList.isEmpty()) &#123;</span><br><span class="line">    FileInfo updateInfo = <span class="keyword">new</span> FileInfo();</span><br><span class="line">    updateInfo.setDelFlag(FileDelFlagEnums.DEL.getFlag());</span><br><span class="line">    <span class="keyword">this</span>.fileInfoMapper.updateFileDelFlagBatch(updateInfo, userId, delFilePidList, <span class="keyword">null</span>, FileDelFlagEnums.USING.getFlag());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将选中的文件更新为回收站</span></span><br><span class="line">List&lt;String&gt; delFileIdList = Arrays.asList(fileIdArray);</span><br><span class="line">FileInfo fileInfo = <span class="keyword">new</span> FileInfo();</span><br><span class="line">fileInfo.setRecoveryTime(<span class="keyword">new</span> Date());</span><br><span class="line">fileInfo.setDelFlag(FileDelFlagEnums.RECYCLE.getFlag());</span><br><span class="line"><span class="keyword">this</span>.fileInfoMapper.updateFileDelFlagBatch(fileInfo, userId, <span class="keyword">null</span>, delFileIdList, FileDelFlagEnums.USING.getFlag());</span><br></pre></td></tr></table></figure><h3 id="回收站相关"><a href="#回收站相关" class="headerlink" title="回收站相关"></a>回收站相关</h3><h4 id="加载回收站文件"><a href="#加载回收站文件" class="headerlink" title="加载回收站文件"></a>加载回收站文件</h4><p>设置好文件删除标志即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FileInfoQuery query = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line">query.setPageSize(pageSize);</span><br><span class="line">query.setPageNo(pageNo);</span><br><span class="line">query.setUserId(getUserInfoFromSession(session).getUserId());</span><br><span class="line">query.setOrderBy(<span class="string">&quot;recovery_time desc&quot;</span>);</span><br><span class="line">query.setDelFlag(FileDelFlagEnums.RECYCLE.getFlag());</span><br><span class="line">PaginationResultVO result = fileInfoService.findListByPage(query);</span><br><span class="line"><span class="keyword">return</span> getSuccessResponseVO(convert2PaginationVO(result, FileInfoVO.class));</span><br></pre></td></tr></table></figure><h4 id="回收站文件复原"><a href="#回收站文件复原" class="headerlink" title="回收站文件复原"></a>回收站文件复原</h4><p>关键是需要复原目录中的所有文件,同时如果文件在复原的目录中有重名需要改名.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String[] fileIdArray = fileIds.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">FileInfoQuery query = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line">query.setUserId(userId);</span><br><span class="line">query.setFileIdArray(fileIdArray);</span><br><span class="line">query.setDelFlag(FileDelFlagEnums.RECYCLE.getFlag());</span><br><span class="line">List&lt;FileInfo&gt; fileInfoList = <span class="keyword">this</span>.fileInfoMapper.selectList(query);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; delFileSubFolderFileIdList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//找到所选文件子目录文件ID</span></span><br><span class="line"><span class="keyword">for</span> (FileInfo fileInfo : fileInfoList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (FileFolderTypeEnums.FOLDER.getType().equals(fileInfo.getFolderType())) &#123;</span><br><span class="line">        findAllSubFolderFileIdList(delFileSubFolderFileIdList, userId, fileInfo.getFileId(), FileDelFlagEnums.DEL.getFlag());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取要复原的所有文件的id以及子目录的id,迭代的获取文件id,将文件状态都更新为在使用(从DELETE到USING).</p><p>然后默认恢复文件到根目录,获取根目录中的所有文件放在一个map中,遍历回收站中文件如果有重名更新名字,然后更新状态(从RECYCLE到USING)</p><h4 id="删除回收站文件"><a href="#删除回收站文件" class="headerlink" title="删除回收站文件"></a>删除回收站文件</h4><p>直接删除即可.</p><p>更新用户可用空间以及缓存.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">String[] fileIdArray = fileIds.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">FileInfoQuery query = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line">query.setUserId(userId);</span><br><span class="line">query.setFileIdArray(fileIdArray);</span><br><span class="line"><span class="keyword">if</span> (!adminOp) &#123;</span><br><span class="line">    query.setDelFlag(FileDelFlagEnums.RECYCLE.getFlag());</span><br><span class="line">&#125;</span><br><span class="line">List&lt;FileInfo&gt; fileInfoList = <span class="keyword">this</span>.fileInfoMapper.selectList(query);</span><br><span class="line">List&lt;String&gt; delFileSubFolderFileIdList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//找到所选文件子目录文件ID</span></span><br><span class="line"><span class="keyword">for</span> (FileInfo fileInfo : fileInfoList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (FileFolderTypeEnums.FOLDER.getType().equals(fileInfo.getFolderType())) &#123;</span><br><span class="line">        findAllSubFolderFileIdList(delFileSubFolderFileIdList, userId, fileInfo.getFileId(), FileDelFlagEnums.DEL.getFlag());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除所选文件，子目录中的文件</span></span><br><span class="line"><span class="keyword">if</span> (!delFileSubFolderFileIdList.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fileInfoMapper.delFileBatch(userId, delFileSubFolderFileIdList, <span class="keyword">null</span>, adminOp ? <span class="keyword">null</span> : FileDelFlagEnums.DEL.getFlag());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除所选文件</span></span><br><span class="line"><span class="keyword">this</span>.fileInfoMapper.delFileBatch(userId, <span class="keyword">null</span>, Arrays.asList(fileIdArray), adminOp ? <span class="keyword">null</span> : FileDelFlagEnums.RECYCLE.getFlag());</span><br><span class="line"></span><br><span class="line">Long useSpace = <span class="keyword">this</span>.fileInfoMapper.selectUseSpace(userId);</span><br><span class="line">UserInfo userInfo = <span class="keyword">new</span> UserInfo();</span><br><span class="line">userInfo.setUseSpace(useSpace);</span><br><span class="line"><span class="keyword">this</span>.userInfoMapper.updateByUserId(userInfo, userId);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置缓存</span></span><br><span class="line">UserSpaceDto userSpaceDto = redisComponent.getUserSpaceUse(userId);</span><br><span class="line">userSpaceDto.setUseSpace(useSpace);</span><br><span class="line">redisComponent.saveUserSpaceUse(userId, userSpaceDto);</span><br></pre></td></tr></table></figure><h3 id="外部分享文件"><a href="#外部分享文件" class="headerlink" title="外部分享文件"></a>外部分享文件</h3><h4 id="创建下载链接"><a href="#创建下载链接" class="headerlink" title="创建下载链接"></a>创建下载链接</h4><p>主要是返回一个密码给用户端,用户端后续携带下载文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FileInfo fileInfo = fileInfoService.getFileInfoByFileIdAndUserId(fileId, userId);</span><br><span class="line"><span class="keyword">if</span> (fileInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ResponseCodeEnum.CODE_600);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (FileFolderTypeEnums.FOLDER.getType().equals(fileInfo.getFolderType())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ResponseCodeEnum.CODE_600);</span><br><span class="line">&#125;</span><br><span class="line">String code = StringTools.getRandomString(Constants.LENGTH_50);</span><br><span class="line">DownloadFileDto downloadFileDto = <span class="keyword">new</span> DownloadFileDto();</span><br><span class="line">downloadFileDto.setDownloadCode(code);</span><br><span class="line">downloadFileDto.setFilePath(fileInfo.getFilePath());</span><br><span class="line">downloadFileDto.setFileName(fileInfo.getFileName());</span><br><span class="line"></span><br><span class="line">redisComponent.saveDownloadCode(code, downloadFileDto);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> getSuccessResponseVO(code);</span><br></pre></td></tr></table></figure><p>根据fileId,userId获取文件信息,将文件信息与code存入缓存</p><h4 id="下载文件-1"><a href="#下载文件-1" class="headerlink" title="下载文件"></a>下载文件</h4><p>根据传入的code获取缓存中的文件信息,根据文件信息拼接下载地址下载文件.注意设置response的响应头.content-type和content-disposition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DownloadFileDto downloadFileDto = redisComponent.getDownloadCode(code);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == downloadFileDto) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">String filePath = appConfig.getProjectFolder() + Constants.FILE_FOLDER_FILE + downloadFileDto.getFilePath();</span><br><span class="line">String fileName = downloadFileDto.getFileName();</span><br><span class="line">response.setContentType(<span class="string">&quot;application/x-msdownload; charset=UTF-8&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (request.getHeader(<span class="string">&quot;User-Agent&quot;</span>).toLowerCase().indexOf(<span class="string">&quot;msie&quot;</span>) &gt; <span class="number">0</span>) &#123;<span class="comment">//IE浏览器</span></span><br><span class="line">    fileName = URLEncoder.encode(fileName, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fileName = <span class="keyword">new</span> String(fileName.getBytes(<span class="string">&quot;UTF-8&quot;</span>), <span class="string">&quot;ISO8859-1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=\&quot;&quot;</span> + fileName + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">readFile(response, filePath);</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/07/24/PKgE1ckHUmQdXWZ.png" alt="image-20250724203722676"></p><p>分享文件就是创建分享信息,并设置shared插入file_share表.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ShareValidTypeEnums typeEnum = ShareValidTypeEnums.getByType(share.getValidType());</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == typeEnum) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ResponseCodeEnum.CODE_600);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (typeEnum != ShareValidTypeEnums.FOREVER) &#123;</span><br><span class="line">    share.setExpireTime(DateUtil.getAfterDate(typeEnum.getDays()));</span><br><span class="line">&#125;</span><br><span class="line">Date curDate = <span class="keyword">new</span> Date();</span><br><span class="line">share.setShareTime(curDate);</span><br><span class="line"><span class="keyword">if</span> (StringTools.isEmpty(share.getCode())) &#123;</span><br><span class="line">    share.setCode(StringTools.getRandomString(Constants.LENGTH_5));</span><br><span class="line">&#125;</span><br><span class="line">share.setShareId(StringTools.getRandomString(Constants.LENGTH_20));</span><br><span class="line"><span class="keyword">this</span>.fileShareMapper.insert(share);</span><br></pre></td></tr></table></figure><p>其他人要来下载,传入sharedId,查表获得分享信息,同时增加分享浏览次数.并将分享信息存入session</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/checkShareCode&quot;)</span></span><br><span class="line"><span class="meta">@GlobalInterceptor(checkLogin = false, checkParams = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseVO <span class="title">checkShareCode</span><span class="params">(HttpSession session,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="meta">@VerifyParam(required = true)</span> String shareId,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="meta">@VerifyParam(required = true)</span> String code)</span> </span>&#123;</span><br><span class="line">    SessionShareDto shareSessionDto = fileShareService.checkShareCode(shareId, code);</span><br><span class="line">    session.setAttribute(Constants.SESSION_SHARE_KEY + shareId, shareSessionDto);</span><br><span class="line">    <span class="keyword">return</span> getSuccessResponseVO(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getShareInfo&quot;)</span></span><br><span class="line"><span class="meta">@GlobalInterceptor(checkLogin = false, checkParams = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseVO <span class="title">getShareInfo</span><span class="params">(<span class="meta">@VerifyParam(required = true)</span> String shareId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getSuccessResponseVO(getShareInfoCommon(shareId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ShareInfoVO <span class="title">getShareInfoCommon</span><span class="params">(String shareId)</span> </span>&#123;</span><br><span class="line">    FileShare share = fileShareService.getFileShareByShareId(shareId);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == share || (share.getExpireTime() != <span class="keyword">null</span> &amp;&amp; <span class="keyword">new</span> Date().after(share.getExpireTime()))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ResponseCodeEnum.CODE_902.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line">    ShareInfoVO shareInfoVO = CopyTools.copy(share, ShareInfoVO.class);</span><br><span class="line">    FileInfo fileInfo = fileInfoService.getFileInfoByFileIdAndUserId(share.getFileId(), share.getUserId());</span><br><span class="line">    <span class="keyword">if</span> (fileInfo == <span class="keyword">null</span> || !FileDelFlagEnums.USING.getFlag().equals(fileInfo.getDelFlag())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ResponseCodeEnum.CODE_902.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line">    shareInfoVO.setFileName(fileInfo.getFileName());</span><br><span class="line">    UserInfo userInfo = userInfoService.getUserInfoByUserId(share.getUserId());</span><br><span class="line">    shareInfoVO.setNickName(userInfo.getNickName());</span><br><span class="line">    shareInfoVO.setAvatar(userInfo.getQqAvatar());</span><br><span class="line">    shareInfoVO.setUserId(userInfo.getUserId());</span><br><span class="line">    <span class="keyword">return</span> shareInfoVO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后后续通过sharedId可以获得分享的文件信息和分享者等信息.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResponseVO <span class="title">getShareLoginInfo</span><span class="params">(HttpSession session, <span class="meta">@VerifyParam(required = true)</span> String shareId)</span> </span>&#123;</span><br><span class="line">    SessionShareDto shareSessionDto = getSessionShareFromSession(session, shareId);</span><br><span class="line">    <span class="keyword">if</span> (shareSessionDto == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getSuccessResponseVO(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ShareInfoVO shareInfoVO = getShareInfoCommon(shareId);</span><br><span class="line">    <span class="comment">//判断是否是当前用户分享的文件</span></span><br><span class="line">    SessionWebUserDto userDto = getUserInfoFromSession(session);</span><br><span class="line">    <span class="keyword">if</span> (userDto != <span class="keyword">null</span> &amp;&amp; userDto.getUserId().equals(shareSessionDto.getShareUserId())) &#123;</span><br><span class="line">        shareInfoVO.setCurrentUser(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shareInfoVO.setCurrentUser(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getSuccessResponseVO(shareInfoVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的,通过shareId获取文件表,注意检查对应的文件id等于filePid或者filePid文件的filePid</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SessionShareDto shareSessionDto = checkShare(session, shareId);</span><br><span class="line">FileInfoQuery query = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line"><span class="keyword">if</span> (!StringTools.isEmpty(filePid) &amp;&amp; !Constants.ZERO_STR.equals(filePid)) &#123;</span><br><span class="line">    fileInfoService.checkRootFilePid(shareSessionDto.getFileId(), shareSessionDto.getShareUserId(), filePid);</span><br><span class="line">    query.setFilePid(filePid);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    query.setFileId(shareSessionDto.getFileId());</span><br><span class="line">&#125;</span><br><span class="line">query.setUserId(shareSessionDto.getShareUserId());</span><br><span class="line">query.setOrderBy(<span class="string">&quot;last_update_time desc&quot;</span>);</span><br><span class="line">query.setDelFlag(FileDelFlagEnums.USING.getFlag());</span><br><span class="line">PaginationResultVO resultVO = fileInfoService.findListByPage(query);</span><br><span class="line"><span class="keyword">return</span> getSuccessResponseVO(convert2PaginationVO(resultVO, FileInfoVO.class));</span><br></pre></td></tr></table></figure><p>获取对应文件信息.</p><p>下载类似的,首先通过createDownloadUrl创建下载连接以及code,存入缓存,然后后续可以下载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/createDownloadUrl/&#123;shareId&#125;/&#123;fileId&#125;&quot;)</span></span><br><span class="line"><span class="meta">@GlobalInterceptor(checkLogin = false, checkParams = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseVO <span class="title">createDownloadUrl</span><span class="params">(HttpSession session,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="meta">@PathVariable(&quot;shareId&quot;)</span> <span class="meta">@VerifyParam(required = true)</span> String shareId,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="meta">@PathVariable(&quot;fileId&quot;)</span> <span class="meta">@VerifyParam(required = true)</span> String fileId)</span> </span>&#123;</span><br><span class="line">    SessionShareDto shareSessionDto = checkShare(session, shareId);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.createDownloadUrl(fileId, shareSessionDto.getShareUserId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下载</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/download/&#123;code&#125;&quot;)</span></span><br><span class="line"><span class="meta">@GlobalInterceptor(checkLogin = false, checkParams = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="meta">@PathVariable(&quot;code&quot;)</span> <span class="meta">@VerifyParam(required = true)</span> String code)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.download(request, response, code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程是首先checkShareCode通过sharedId进行校验并设置session,更新文件浏览次数,然后通过getShareLoginInfo获取shareInfoVO.</p><h1 id="EasyLive"><a href="#EasyLive" class="headerlink" title="EasyLive"></a>EasyLive</h1><h3 id="参考博主"><a href="#参考博主" class="headerlink" title="参考博主"></a>参考博主</h3><p><a href="https://space.bilibili.com/499388891">程序员老罗的个人空间-程序员老罗个人主页-哔哩哔哩视频</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在准备实习,找一些&lt;del&gt;烂大街&lt;/del&gt;经典项目练练手.&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://www.sekyoro.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP与HTTP编程</title>
    <link href="https://www.sekyoro.top/2025/03/12/TCP-IP%E4%B8%8EHTTP%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.sekyoro.top/2025/03/12/TCP-IP%E4%B8%8EHTTP%E7%BC%96%E7%A8%8B/</id>
    <published>2025-03-12T07:05:02.000Z</published>
    <updated>2025-03-19T13:42:30.598Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>复习基础知识. TCP/IP以及HTTP是计算机网络以及互联网开发的基础.<br><span id="more"></span></p><p><a href="https://www.runoob.com/tcpip/tcpip-tutorial.html">TCP/IP 教程 | 菜鸟教程</a></p><p><a href="https://www.runoob.com/np/tcp-protocol.html">TCP 协议 | 菜鸟教程</a></p><p><a href="https://www.geeksforgeeks.org/tcp-ip-model/">TCP/IP Model - GeeksforGeeks</a></p><p><a href="https://www.w3school.com.cn/tcpip/index.asp">TCP/IP 教程</a></p><p><a href="https://liaoxuefeng.com/books/java/network/basic/index.html">网络编程基础 - Java教程 - 廖雪峰的官方网站</a></p><p>相关书籍:<a href="https://github.com/wengjianhong/Kunlun/tree/master/PDF">Kunlun/PDF at master · wengjianhong/Kunlun</a></p><p>Linux命令查看:<a href="https://www.man7.org/linux/man-pages/">Linux man pages online</a></p><p><a href="https://linux.die.net/">Linux Documentation</a></p><p><a href="https://www.kernel.org/doc/man-pages/">The Linux man-pages project</a></p><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>TCP/IP 是用于因特网 (Internet) 的通信协议。计算机通信协议是对那些计算机必须遵守以便彼此通信的的规则的描述。</p><p>TCP/IP 是供已连接因特网的计算机进行通信的通信协议。</p><p>TCP/IP 指传输控制协议/网际协议（<strong>Transmission Control Protocol Internet Protocol</strong>）。</p><p>TCP/IP 定义了电子设备（比如计算机）如何连入因特网，以及数据如何在它们之间传输的标准</p><p><img data-src="https://s2.loli.net/2025/03/15/JdNpVR5weBxFmI2.png" alt="image-20250315132629613"></p><blockquote><p>通过数据链路层和传输层的数据都有限制,如图. 在传输层不能超过TCP最大报文段长度(MSS). 比如一次写入大于MSS的数据,再加上HTTP头部信息,超过了MSS后在传输层会将这些信息分段.</p></blockquote><p><img data-src="https://s2.loli.net/2025/03/15/lxrdIhWqZcEs5tf.png" alt="image-20250315132914577"></p><blockquote><p>每个层会加上头部或头尾部</p></blockquote><p>TCP/IP协议栈属于操作系统(内核态)的行为,</p><p>应⽤程序（浏览器）通过调⽤ Socket 库，来委托协议栈⼯作。协议栈的上半部分有两块，分别是负责收发 数据的 TCP 和 UDP 协议，这两个传输协议会接受应⽤层的委托执⾏收发数据的操作。</p><p><img data-src="https://s2.loli.net/2025/03/15/aVJc2KbCXsxEvPh.png" alt="image-20250315164613174"></p><p>用户态通过使用socket库结合对应HTTP协议搭建应用程序</p><h4 id="传输层TCP协议"><a href="#传输层TCP协议" class="headerlink" title="传输层TCP协议"></a>传输层TCP协议</h4><blockquote><p>TCP数据包格式</p></blockquote><p><img data-src="https://s2.loli.net/2025/03/15/GroHmCts5Z4WjJL.png" alt="image-20250315165319850"></p><p>​    ⾸先，源端⼝号和⽬标端⼝号是不可少的，如果没有这两个端⼝号，数据就不知道应该发给哪个应⽤.</p><p>​     接下来有包的序号，这个是为了解决包乱序的问题。 还有应该有的是确认号，⽬的是确认发出去对⽅是否有收到.(超时重传,通过定时器和确认序号ack)</p><p>​    如果没有收到就应该重新发送，直到送达， 这个是为了解决丢包的问题。 接下来还有⼀些状态位。例如  SYN 是发起⼀个连接， ACK 是回复， RST 是重新连接， FIN 是结束连接等。TCP 是⾯向连接的，因⽽双⽅要维护连接的状态，这些带状态位的包的发送，会引起双⽅的状态 变更。 还有⼀个重要的就是窗⼝⼤⼩.(面向连接)</p><p>​    TCP 要做流量控制，通信双⽅各声明⼀个窗⼝（缓存⼤⼩），标识⾃⼰当前能够的处理能⼒，别发送的太快，撑死我，也别发的太慢，饿死我。 除了做流量控制以外.(流量控制,通过窗口大小的滑动窗口机制)</p><p>​    TCP还会做拥塞控制，对于真正的通路堵⻋不堵⻋，它⽆能为⼒，唯⼀能做的就是控制⾃⼰，也即控制发送的速度(TCP采用了几种算法来动态地调整发送速率以适应网络状况).</p><blockquote><ul><li><strong>流量控制</strong>专注于匹配发送方与接收方之间的处理能力，防止发送方发送超出接收方处理能力的数据量。</li><li><strong>拥塞控制</strong>则着眼于整个网络的状态，试图找到合适的发送速率，既不过度占用网络资源导致拥塞，也不过于保守浪费带宽。</li></ul></blockquote><ol><li>慢启动（Slow Start）</li></ol><p>当一个TCP连接开始时，发送方不知道网络的状态，也不知道接收方能够接受数据的速度。慢启动阶段通过指数增长的方式逐渐增加拥塞窗口（Congestion Window, cwnd）的大小，以便探测网络的容量。初始时，cwnd通常设置为一个小值（如1个最大段大小MSS）。每成功接收到一个ACK确认，cwnd就增加一个MSS。这个过程持续到遇到首个丢包事件或者达到慢启动阈值（ssthresh）。</p><ol><li>拥塞避免（Congestion Avoidance）</li></ol><p>一旦cwnd的值达到或超过ssthresh，TCP进入拥塞避免阶段。在这个阶段，cwnd的增长速度变缓，采用线性增长方式，即每次往返时间（RTT）只允许cwnd增加一个MSS/cwnd。这有助于更精细地探测网络的最大吞吐量，而不会像慢启动那样迅速使网络过载。</p><ol><li>快速重传（Fast Retransmit）</li></ol><p>快速重传机制用于在未超时的情况下检测到丢包。如果发送方连续收到三个对同一数据段的重复ACK，这意味着该数据段可能已经丢失，发送方将立即重传丢失的数据段，而不是等待定时器超时。这样做可以更快地恢复丢失的数据包，减少等待时间。</p><ol><li>快速恢复（Fast Recovery）</li></ol><p>快速恢复与快速重传配合使用。当发送方由于收到三次重复ACK而触发快速重传后，它会进入快速恢复状态。在此状态下，发送方不执行慢启动，而是调整ssthresh到当前cwnd的一半，并从那里继续尝试增大cwnd，直到不再收到重复的ACK为止。这有助于快速从丢包中恢复，而不必回到慢启动状态。</p><blockquote><p>连接时三次握手</p><p>这个所谓的「连接」，只是双⽅计算机⾥维护⼀个状态机，在连接建⽴的过程中，双⽅的状态变化时序图 </p></blockquote><p>在 HTTP 传输数据之前，⾸先需要 TCP 建⽴连接，TCP 连接的建⽴，通常称为三次握⼿。</p><p><img data-src="https://s2.loli.net/2025/03/15/ld7fpEhMHxOzgNt.png" alt="image-20250315165832577"></p><p>三次握⼿⽬的是保证双⽅都有发送和接收的能⼒。</p><p>使用netstat -antp,查看tcp连接状态</p><p><img data-src="https://s2.loli.net/2025/03/15/bQADsTaFn9R7oNt.png" alt="image-20250315173636652"></p><p><img data-src="https://s2.loli.net/2025/03/15/c7VGWhk6n3rS98C.png" alt="image-20250315181426136"></p><h4 id="网络层IP协议"><a href="#网络层IP协议" class="headerlink" title="网络层IP协议"></a>网络层IP协议</h4><p>TCP 模块在执⾏连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成⽹络包发送给通信对象</p><p><img data-src="https://s2.loli.net/2025/03/15/ne5z3l6mODxcG1J.png" alt="image-20250315182247041"></p><p>因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的协议号，要填写为  TCP。 06 （⼗六进制）,表示协议为TCP</p><blockquote><p>在 Linux 操作系统,可以使⽤  route -n 命令查看当前系统的路由表</p></blockquote><p>IP数据包包括首部长度和总长度. 此外当IP数据包大于底层协议所允许的大小(MTU)时进行分片.</p><p>IP分片的主要特点：</p><ul><li><strong>标识（Identification）</strong>：所有分片都共享相同的标识值，以便目标主机可以识别这些分片属于同一个原始数据报。</li><li><strong>标志（Flags）</strong>：包含三个比特位，其中两个用于控制是否还有更多的分片以及是否允许分片。</li><li><strong>片偏移（Fragment Offset）</strong>：表示该分片在原始数据报中的位置，帮助接收端按照正确的顺序重组数据报。</li></ul><p>分片过程</p><ol><li>当一个IP数据包准备发送时，如果其大小超过了出站接口的MTU，则需要进行分片。</li><li>每个生成的分片<strong>都将包含源地址、目的地址、标识字段和标志字段等信息。</strong></li><li>除了最后一个分片外，其他所有分片都将填充到它们的最大长度，而最后一个分片可能小于最大长度。</li><li>接收方收到所有分片后，根据标识字段、标志字段和片偏移字段重组原始数据报</li></ol><p>⽣成了 IP 头部之后，接下来⽹络包还需要在 IP 头部的前⾯加上 MAC 头部。<strong>在 MAC 包头⾥需要发送⽅ MAC 地址和接收⽅⽬标 MAC 地址，⽤于两点之间的传输</strong>。 ⼀般在 TCP/IP 通信⾥，MAC 包头的协议类型只使⽤： 0800 ： IP 协议 0806 ： ARP 协议</p><p>当不知道MAC地址时,需要  ARP 协议帮我们找到路由器的 MAC 地址。</p><blockquote><p>ARP 协议会在以太⽹中以⼴播的形式，对以太⽹所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC  地址告诉我”。 然后就会有⼈回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。</p></blockquote><p><strong>如果对⽅和⾃⼰处于同⼀个⼦⽹中，那么通过上⾯的操作就可以得到对⽅的 MAC 地址</strong>。然后将这 个 MAC 地址写⼊ MAC 头部，MAC 头部就完成了。</p><p>操作系统会把本次查询结果放到⼀块叫做 ARP 缓存的内存空间留着以后⽤，不过缓存的时间 就⼏分钟。 也就是说，在发包时： 先查询 ARP 缓存，如果其中已经保存了对⽅的 MAC 地址，就不需要发送 ARP 查询，直接使⽤ ARP  缓存中的地址。 ⽽当 ARP 缓存中不存在对⽅ MAC 地址时，则发送 ARP ⼴播查询。</p><p>⽹络包只是存放在内存中的⼀串⼆进制数字信息，没有办法直接发送给对⽅。因此需要将数字信息 转换为电信号，才能在⽹线上传输，也就是说，这才是真正的数据发送过程。 负责执⾏这⼀操作的是⽹卡，要控制⽹卡还需要靠⽹卡驱动程序。 ⽹卡驱动获取⽹络包之后，会将其复制到⽹卡内的缓存区中，接着会在其开头加上报头和起始帧分界符， 在末尾加上⽤于检测错误的帧校验序列</p><p><img data-src="https://s2.loli.net/2025/03/16/lRTEm9kAhZMtqD8.png" alt="image-20250316153840683"></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP是应用层协议,类似的应用层协议有FTP,SFTP,TELNET等. HTTP协议对于请求报文和响应报文有不同的格式要求. HTTP版本有1.0,1.1与2.0.</p><p><img data-src="https://s2.loli.net/2025/03/15/BpEqolHja4TALvS.png" alt="image-20250315154823886"></p><h2 id="进一步"><a href="#进一步" class="headerlink" title="进一步"></a>进一步</h2><h3 id="IPV4与IPV6"><a href="#IPV4与IPV6" class="headerlink" title="IPV4与IPV6"></a>IPV4与IPV6</h3><h3 id="RPC与HTTP"><a href="#RPC与HTTP" class="headerlink" title="RPC与HTTP"></a>RPC与HTTP</h3><ul><li><strong>RPC（Remote Procedure Call，远程过程调用）</strong>:是一种协议，允许一个程序通过网络请求另一个地址空间中的子程序或服务，而无需了解底层网络细节。它旨在让开发者像调用本地函数一样调用远程服务。</li><li><strong>HTTP（Hypertext Transfer Protocol，超文本传输协议）</strong>:是一个用于传输超媒体文档的应用层协议，主要用于Web浏览器与Web服务器之间的通信。尽管最初设计是为了支持网页浏览，但HTTP也被广泛应用于构建RESTful API等服务接口</li></ul><h3 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h3><ul><li>HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺 陷，在 TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输。</li><li>HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次 握⼿之后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输。</li><li>两者的默认端⼝不⼀样，HTTP 默认端⼝号是 80，HTTPS 默认端⼝号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的</li></ul><p>HTTPS 在 HTTP 与 TCP 层之间加⼊了  SSL/TLS 协议，可以解决安全⻛险： 信息加密：交互信息⽆法被窃取，但你的号会因为「⾃身忘记」账号⽽没。 校验机制：⽆法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾⼴ 告。 身份证书：证明淘宝是真的淘宝⽹，但你的钱还是会因为「剁⼿」⽽没。</p><h2 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h2><p>代码随想录、阿秀、labuladong、小林coding、JavaGuide</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;复习基础知识. TCP/IP以及HTTP是计算机网络以及互联网开发的基础.&lt;br&gt;</summary>
    
    
    
    
    <category term="TCP/IP" scheme="https://www.sekyoro.top/tags/TCP-IP/"/>
    
    <category term="HTTP" scheme="https://www.sekyoro.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>mini-java-guide</title>
    <link href="https://www.sekyoro.top/2025/03/09/mini-java-guide/"/>
    <id>https://www.sekyoro.top/2025/03/09/mini-java-guide/</id>
    <published>2025-03-09T02:10:08.000Z</published>
    <updated>2025-07-19T08:05:01.826Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>学习很潮很流行的Java以及相关框架.<br><span id="more"></span></p><p><a href="https://liaoxuefeng.com/books/java/introduction/index.html">简介 - Java教程 - 廖雪峰的官方网站</a></p><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="Java基础-1"><a href="#Java基础-1" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="1-java-lang"><a href="#1-java-lang" class="headerlink" title="1. java.lang.*"></a>1. java.lang.*</h3><p>这是默认导入的包，包含基本类和接口。</p><ul><li><strong>Object</strong>：所有类的超类。</li><li><strong>String</strong>：不可变字符串类，用于文本处理。</li><li><strong>StringBuilder/StringBuffer</strong>：可变字符串类，适用于频繁修改字符串的场景。<code>StringBuffer</code>是线程安全的版本。</li><li><strong>System</strong>：提供系统相关的信息和操作，如<code>System.out.println()</code>打印输出。</li><li><strong>Math</strong>：提供数学计算的方法，如三角函数、对数等。</li><li><strong>Integer, Double 等包装类</strong>：基本类型的对象表示形式，支持自动装箱/拆箱。</li></ul><h3 id="2-java-util"><a href="#2-java-util" class="headerlink" title="2. java.util.*"></a>2. java.util.*</h3><p>包含了集合框架、日期时间工具、随机数生成器等实用工具类。</p><ul><li><strong>Collection 接口及其实现类</strong>（如ArrayList, LinkedList, HashSet, TreeSet等）：提供了不同类型的集合实现。</li><li><strong>Map 接口及其实现类</strong>（如HashMap, TreeMap等）：键值对存储结构。</li><li><strong>Iterator</strong>：遍历集合的标准方式。</li><li><strong>Date, Calendar, LocalDate, LocalDateTime</strong>（Java 8+）：处理日期和时间。</li><li><strong>Random</strong>：生成伪随机数。</li><li><strong>Arrays</strong>：提供操作数组的各种静态方法。</li></ul><p>函数式编程(function)包提供了一些功能接口</p><ul><li><p><strong><code>Function&lt;T, R&gt;</code></strong>：接受一个参数并返回结果。</p></li><li><p><strong><code>Predicate&lt;T&gt;</code></strong>：接受一个输入参数并返回布尔值。方法签名：`boolean test(T t)``</p></li><li><p><code>`BiFunction&lt;T, U, R&gt;</code>：接受两个输入参数并返回结果。<strong>方法签名</strong>：<code>R apply(T t, U u)</code></p></li><li><p><code>UnaryOperator&lt;T&gt;</code> ：接受一个参数并返回相同类型的值，是 <code>Function&lt;T, T&gt;</code> 的特化形式。 <strong>方法签名</strong>：<code>T apply(T t)</code></p></li><li><p><code>BinaryOperator&lt;T&gt;</code>：接受两个相同类型的参数并返回相同类型的值，是 <code>BiFunction&lt;T, T, T&gt;</code> 的特化形式。 <strong>方法签名</strong>：`T apply(T t, T u)```</p></li><li><p><code>BiPredicate&lt;T, U&gt;</code>：接受两个输入参数并返回布尔值。<strong>方法签名</strong>：<code>boolean test(T t, U u)</code>,用于需要基于两个输入值进行条件判断的场景</p></li><li><p><strong><code>Supplier&lt;T&gt;</code></strong>：适用于你需要从无到有地“生产”数据的场合。它不接收任何参数，但是可以返回你所需要的类型的实例。这使得它非常适合用于延迟初始化、配置加载等场景。</p></li><li><strong><code>BiConsumer&lt;T, U&gt;</code></strong>：当你需要处理或操作一对相关的值，并且这些操作的结果并不重要（即不需要返回值）时非常有用。比如，你可能想要记录一组键值对的日志，或者将两个值合并在一起而不关心最终结果。</li></ul><h3 id="3-java-io"><a href="#3-java-io" class="headerlink" title="3. java.io.*"></a>3. java.io.*</h3><p>提供输入输出流的支持，用于读写文件或进行网络通信。</p><ul><li><strong>InputStream/OutputStream</strong>：字节流基类。</li><li><strong>Reader/Writer</strong>：字符流基类。</li><li><strong>File</strong>：文件或目录路径名的抽象表示形式。</li><li><strong>BufferedReader/BufferedWriter, BufferedInputStream/BufferedOutputStream</strong>：提高I/O效率的缓冲类。</li></ul><h3 id="4-java-nio"><a href="#4-java-nio" class="headerlink" title="4. java.nio.*"></a>4. java.nio.*</h3><p>新的I/O API，提供了更高效的非阻塞I/O操作。</p><ul><li><strong>Path, Paths</strong>：用于处理文件系统路径。</li><li><strong>Files</strong>：提供对文件的操作方法。</li><li><strong>ByteBuffer</strong>及其他缓冲区类型：用于高效地管理字节序列。</li></ul><h3 id="5-java-net"><a href="#5-java-net" class="headerlink" title="5. java.net.*"></a>5. java.net.*</h3><p>网络编程相关的API。</p><ul><li><strong>URL, URI</strong>：统一资源定位符/标识符。</li><li><strong>URLConnection</strong>：与URL建立连接。</li><li><strong>Socket, ServerSocket</strong>：TCP/IP套接字编程的基础类。</li><li><strong>DatagramPacket, DatagramSocket</strong>：UDP协议的支持。</li></ul><h3 id="6-java-text"><a href="#6-java-text" class="headerlink" title="6. java.text.*"></a>6. java.text.*</h3><p>用于格式化和解析文本。</p><ul><li><strong>NumberFormat, DecimalFormat</strong>：数字格式化。</li><li><strong>DateFormat, SimpleDateFormat</strong>：日期格式化。</li><li><strong>MessageFormat</strong>：根据模式格式化消息。</li></ul><h3 id="7-java-time"><a href="#7-java-time" class="headerlink" title="7. java.time.*"></a>7. java.time.*</h3><p>Java 8引入的新日期时间API。</p><ul><li><strong>Instant</strong>：表示时间线上的一点。</li><li><strong>LocalDate, LocalTime, LocalDateTime</strong>：分别表示不带时区的日期、时间和日期时间。</li><li><strong>ZonedDateTime, OffsetDateTime</strong>：带有时区信息的日期时间。</li></ul><h3 id="8-并发相关"><a href="#8-并发相关" class="headerlink" title="8. 并发相关"></a>8. 并发相关</h3><ul><li><strong>Thread</strong>：创建和控制线程。</li><li><strong>Runnable</strong>：线程执行的目标接口。</li><li><strong>ExecutorService, Executors</strong>：更高级别的线程管理。</li><li><strong>Lock, ReentrantLock</strong>：比同步块更灵活的锁定机制。</li><li><strong>ConcurrentHashMap</strong>：线程安全的哈希表实现。</li></ul><h3 id="9-其他"><a href="#9-其他" class="headerlink" title="9. 其他"></a>9. 其他</h3><ul><li><strong>Optional</strong>（Java 8+）：避免空指针异常的一种设计模式。</li><li><strong>Stream API</strong>（Java 8+）：提供了一种高效且易于使用的集合元素处理方式。</li></ul><div class="table-container"><table><thead><tr><th>访问修饰符</th><th>同一类</th><th>同一包</th><th>子类（不同包）</th><th>全局</th></tr></thead><tbody><tr><td><code>public</code></td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td><code>protected</code></td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>默认</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td><code>private</code></td><td>是</td><td>否</td><td>否</td><td>否</td></tr></tbody></table></div><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>成员内部类,静态内部类,局部内部类,匿名内部类</p><p><img data-src="https://s2.loli.net/2025/03/19/XA1uEi8Q4GBOYeL.png" alt="image-20250319142346062"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">outerclass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String age;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">innerclass</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;This is an inner class&quot;</span>);</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/19/oHwP9Ub47rKRhyu.png" alt="image-20250319142856906"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">innercls</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is an inner class&quot;</span>);</span><br><span class="line">        System.out.println(innercls.<span class="keyword">this</span>);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img data-src="https://s2.loli.net/2025/03/19/BG9x3zCAEjU7IlX.png" alt="image-20250319144727002"></p><p><img data-src="https://s2.loli.net/2025/03/19/GyptQ1F3KcbhIZo.png" alt="image-20250319150803696"></p><h3 id="集合Collection与Map"><a href="#集合Collection与Map" class="headerlink" title="集合Collection与Map"></a>集合Collection与Map</h3><p>数组和集合的区别：</p><p>数组</p><ul><li><p><strong>固定大小</strong>：数组一旦创建，其大小是固定的，不能动态增加或减少元素。</p></li><li><p><strong>类型安全</strong>：数组可以是基本数据类型（如 <code>int[]</code>, <code>double[]</code>）或对象类型（如 <code>String[]</code>）。对于对象类型的数组，所有元素都必须是该类的实例或者 <code>null</code>。</p></li><li><p><strong>内存连续</strong>：数组中的元素在内存中是连续存储的，这使得访问速度非常快，因为可以通过计算偏移量直接访问任何元素（时间复杂度为 O(1)）。</p></li><li><p>声明方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] numbers = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; <span class="comment">// 创建一个包含5个整数的数组</span></span><br><span class="line">String[] names = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>&#125;; <span class="comment">// 初始化时赋值</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>优点</strong></p><ul><li>访问速度快，支持随机访问。</li><li>对于小规模、固定数量的数据集非常适合。</li></ul><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p><strong>定义与特性</strong></p><ul><li><p><strong>动态大小</strong>：<code>List</code> 接口的主要实现类（如 <code>ArrayList</code>, <code>LinkedList</code>）允许动态添加和删除元素，这意味着你可以根据需要扩展或缩小列表的大小。</p></li><li><p><strong>接口与实现</strong>：<code>List</code> 是一个接口，常用的实现包括 <code>ArrayList</code> 和 <code>LinkedList</code>。<code>ArrayList</code> 底层基于数组实现，而 <code>LinkedList</code> 则是一个双向链表。</p></li><li><p><strong>类型安全</strong>：<code>List</code> 只能存储对象，不能直接存储基本数据类型（但可以使用自动装箱/拆箱功能处理基本数据类型）。</p></li><li><p>声明方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">names.add(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;Bob&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><p><strong>优点</strong></p><ul><li>动态大小，方便添加和删除元素。</li><li>提供了丰富的操作方法，比如 <code>add()</code>, <code>remove()</code>, <code>get()</code>, <code>indexOf()</code> 等等。</li><li>更好的抽象层次，代码更加灵活易读。</li></ul><p><strong>缺点</strong></p><ul><li>相比于数组，某些操作可能效率较低，例如在 <code>ArrayList</code> 中插入或删除中间位置的元素会导致其他元素移动；而在 <code>LinkedList</code> 中查找元素则需要从头或尾遍历整个列表。</li></ul><p>ArrayList使用数组实现,查询快,增删慢</p><p>LinkedList使用双向链表实现,查询慢,增删快,尤其对于首尾操作</p><p><img data-src="https://s2.loli.net/2025/03/18/JHyvrF3A1SiuIel.png" alt="image-20250318215401958"></p><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p><img data-src="https://s2.loli.net/2025/03/18/VPxZDv3EGAcUpXs.png" alt="image-20250318220123427"></p><p>HashSet使用哈希表实现,增删改查性能较好 </p><p><img data-src="https://s2.loli.net/2025/03/18/zGuoR1B98kEKLxS.png" alt="image-20250318220818128"></p><p><img data-src="https://s2.loli.net/2025/03/18/cQr1mCLgliJtbvz.png" alt="image-20250318221151248"></p><p>HashSet去重主要依赖于两个关键方法：<code>hashCode()</code> 和 <code>equals()</code>。</p><ol><li><strong>hashCode() 方法</strong>：<ul><li>当你尝试将一个对象添加到 HashSet 中时，HashSet 会首先调用这个对象的 <code>hashCode()</code> 方法来计算该对象的哈希值。</li><li>这个哈希值决定了对象在内部哈希表中的存储位置（即所谓的“桶”）。</li></ul></li><li><strong>equals() 方法</strong>：<ul><li>如果两个对象有相同的哈希值（或者它们被分配到了同一个桶中），HashSet 将使用 <code>equals()</code> 方法来进一步检查这两个对象是否真正相等。</li><li>如果 <code>equals()</code> 返回 <code>true</code>，则认为这两个对象是重复的，新对象不会被添加到集合中。如果 <code>equals()</code> 返回 <code>false</code>，即使哈希值相同，这两个对象也被认为是不同的，并且都会被添加到集合中。</li></ul></li></ol><p>对于自定义类的对象，如果你希望它们能够正确地在 HashSet 中进行去重，你需要重写 <code>hashCode()</code> 和 <code>equals()</code> 方法，以确保具有相同业务含义的对象返回相同的哈希码并且 <code>equals()</code> 方法也返回 <code>true</code>。</p><p>TreeSet底层基于红黑树,可排序,不重复,无索引</p><p><img data-src="https://s2.loli.net/2025/03/18/GrE4zd586Jh9jAO.png" alt="image-20250318231528714"></p><p><img data-src="https://s2.loli.net/2025/03/18/DvQmr3tiWezX2xq.png" alt="image-20250318234747847"></p><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p><img data-src="https://s2.loli.net/2025/03/19/wiUs3FnHfLKgjkQ.png" alt="image-20250319103421264"></p><p><img data-src="https://s2.loli.net/2025/03/19/zEqWugTiRUsaK7C.png" alt="image-20250319104523905"></p><p>Map的遍历方式</p><p><img data-src="https://s2.loli.net/2025/03/19/Dq6nC1eRwIlMUmS.png" alt="image-20250319110144222"></p><p><strong>使用 for-each 循环和 entrySet()</strong></p><p>这是最常用的遍历方式之一，因为它提供了对键和值的访问。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.<span class="keyword">Entry</span>&lt;String, Integer&gt; <span class="keyword">entry</span> : <span class="type">map.entrySet</span>()) &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="keyword">entry</span>.getKey() + <span class="string">&quot;: &quot;</span> + <span class="keyword">entry</span>.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用迭代器</strong></p><p>使用迭代器可以更灵活地控制遍历过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 Java 8 的 Stream API</strong></p><p>通过 <code>stream()</code> 方法可以利用 Stream API 来遍历或进行其他操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.entrySet().stream().forEach(entry -&gt; </span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue())</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>或者对于某些特定的操作，比如过滤、映射等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.entrySet().stream()</span><br><span class="line">   .filter(entry -&gt; entry.getValue() &gt; <span class="number">1</span>)</span><br><span class="line">   .forEach(entry -&gt; System.out.println(entry.getKey()));</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/19/ycB948TkMLeEwmr.png" alt="image-20250319114156720"></p><p>Stream流包括中间方法和最终方法,中间方法使用filter,map,调用完成后会返回新的流</p><p><img data-src="https://s2.loli.net/2025/03/19/qfkja1eAIUKObEX.png" alt="image-20250319120025921"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; alist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">alist.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">alist.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">List&lt;String&gt; list = alist.stream().map((String a) -&gt; a + <span class="string">&quot;a&quot;</span>).toList();</span><br><span class="line">List&lt;Double&gt; blist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.stream().filter(s-&gt; !s.isEmpty()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">list.stream().sorted(Comparator.comparingDouble(String::length).reversed()).forEach(System.out::println);</span><br><span class="line">blist.stream().sorted(Double::compare).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去重 limit只需要一个参数 skip跳过前几个</span></span><br><span class="line">blist.stream().distinct().skip(<span class="number">1</span>).limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成map</span></span><br><span class="line">list.stream().collect(Collectors.toMap(Function.identity(), String::length)).forEach((k, v) -&gt; System.out.println(k + <span class="string">&quot;:&quot;</span> + v));</span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; a = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 合并两个流</span></span><br><span class="line">Stream.concat(a, integerStream).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>java集合类-&gt;实现的数据结构</p><p>Collections List Set HashSet LinkedHashSet TreeSet</p><p>Map</p><p>HashMap LinkedHashMap TreeMap</p><p><strong><code>HashMap</code></strong></p><ul><li><strong>底层实现：</strong> JDK 8 之前是<strong>数组 + 链表</strong>；JDK 8 及之后是<strong>数组 + 链表/红黑树</strong>。当链表长度超过阈值（默认为 8）时，链表会转换为红黑树，以提高查找效率（从 O(N) 优化到 O(log N)）。</li><li><strong>特点：</strong><ul><li><strong>非线程安全：</strong> 在多线程环境下，如果不进行同步处理，可能出现数据不一致或死循环（早期版本）等问题。</li><li><strong>允许键和值为 <code>null</code>：</strong> 最多允许一个键为 <code>null</code>，允许多个值为 <code>null</code>。</li><li><strong>无序性：</strong> 不保证元素的迭代顺序。</li><li><strong>性能：</strong> 增删查的平均时间复杂度为 O(1)。</li></ul></li><li><strong>适用场景：</strong> 单线程环境或需要高性能的非线程安全哈希表场景。</li></ul><p>Hashtable(线程安全)</p><p><strong><code>Hashtable</code></strong></p><ul><li><strong>底层实现：</strong> 也是基于<strong>数组 + 链表</strong>。</li><li><strong>特点：</strong><ul><li><strong>线程安全：</strong> 所有公共方法都使用了 <code>synchronized</code> 关键字进行同步，因此是线程安全的。</li><li><strong>不允许键和值为 <code>null</code>：</strong> 如果尝试插入 <code>null</code> 键或 <code>null</code> 值，会抛出 <code>NullPointerException</code>。</li><li><strong>性能：</strong> 由于同步开销，性能比 <code>HashMap</code> 低。</li></ul></li></ul><p>ArrayList与LinkedList区别</p><p>动态数组 连续内存 查询O(1) 增删需要移动元素O(N)</p><p>双向链表 查询O(N) 首位增删O(1)</p><p>HashMap原理,如何扩容</p><p>数组+链表/红黑树 插入元素时进行哈希,使用链地址法解决哈希冲突</p><p>当 <code>HashMap</code> 中的元素数量 <code>size</code> 达到 <code>capacity * loadFactor</code> 时，<code>HashMap</code> 就会进行扩容操作。这个过程在 <code>resize()</code> 方法中实现。</p><h4 id="扩容流程："><a href="#扩容流程：" class="headerlink" title="扩容流程："></a>扩容流程：</h4><ol><li><strong>创建新数组：</strong><ul><li><code>HashMap</code> 会创建一个新的 <code>Node</code> 数组，其容量是原数组的两倍。例如，如果原容量是 16，新容量就是 32。</li></ul></li><li><strong>数据迁移（Rehash）：</strong><ul><li>这是扩容中最耗时的一步。<code>HashMap</code> 会遍历原数组中的每一个桶。</li><li>对于每个桶中的链表或红黑树，会将其中的所有 <code>Node</code> 元素<strong>重新计算哈希值和在新数组中的索引位置</strong>，然后移动到新数组中对应的桶里。</li></ul></li></ol><p>为什么是两倍扩容？为什么是 2 的幂次方？</p><ul><li><strong>两倍扩容：</strong> 使得 <code>capacity</code> 始终保持为 2 的幂次方，这对于通过位运算 <code>hash &amp; (capacity - 1)</code> 来快速计算索引至关重要。如果 <code>capacity</code> 不是 2 的幂次方，那么 <code>hash % capacity</code> 的性能会降低，并且哈希值分布可能不均匀，增加冲突。</li><li><strong>计算索引的优化：</strong> 当容量从 <code>N</code> 扩容到 <code>2N</code> 时，一个键在旧数组中的索引是 <code>hash &amp; (N - 1)</code>。在新数组中，它的索引是 <code>hash &amp; (2N - 1)</code>。<ul><li>对于每个 <code>Node</code>，它的新的索引位置要么和旧索引相同，要么是旧索引 <code>+ N</code>。</li><li>这个判断依据是 <code>(hash &amp; N)</code> 是否为 <code>0</code>。如果为 <code>0</code>，则新索引不变；如果不为 <code>0</code>，则新索引是旧索引 <code>+ N</code>。</li><li>这种设计避免了对每个元素重新进行复杂的取模运算，<strong>显著提高了数据迁移的效率</strong>。</li></ul></li></ul><p>在 JDK 8 中，<code>resize</code> 过程也进行了优化，它不再需要重新计算每个元素的哈希值，而是利用了容量是 2 的幂次方的特性。</p><p>当容量从 <code>N</code> 变为 <code>2N</code> 时，对于一个节点 <code>e</code>，它的新索引只会有两种情况：<code>e.hash &amp; (N-1)</code> (即原位置) 或者 <code>e.hash &amp; (N-1) + N</code> (即原位置 + N)。 这个判断可以简化为查看 <code>e.hash</code> 的第 <code>N</code> 位（即 <code>(hash &amp; N)</code>）是 <code>0</code> 还是 <code>1</code>。</p><ul><li>如果 <code>(hash &amp; N) == 0</code>，则节点仍在原索引位置。</li><li>如果 <code>(hash &amp; N) != 0</code>，则节点会移动到 <code>原索引 + N</code> 的位置。</li></ul><p>这样，在扩容时，每个桶的链表（或红黑树）可以被<strong>分成两条链表（或红黑树）</strong>，一条留在原位置，另一条移动到新位置（原位置 + N），从而大大提高了数据迁移的效率，避免了逐个重新哈希。</p><p>红黑树 -&gt;B,B+树区别</p><p>红黑树是一种<strong>自平衡的二叉查找树（Binary Search Tree, BST）</strong>。它通过给节点着色（红色或黑色）并遵循一系列规则来保证树的平衡，<strong>确保任何路径从根节点到叶子节点的最长路径不会超过最短路径的两倍</strong>，<strong>从而使所有操作的时间复杂度保持在 O(logN)。</strong></p><p><strong>平衡通过颜色和旋转：</strong> 通过节点的颜色（红/黑）属性和插入/删除时的<strong>旋转（Rotations）</strong>和<strong>重新着色（Recoloring）</strong>操作来维持近似平衡。</p><p><strong>所有数据都在节点中：</strong> 每个节点都存储着实际的键值对。</p><p><strong>高度：</strong> 树的高度相对较小，但比 AVL 树（另一种平衡二叉树）可能略高，但其插入和删除的平均性能更好。</p><h3 id="B-树-B-Tree"><a href="#B-树-B-Tree" class="headerlink" title="B 树 (B-Tree)"></a>B 树 (B-Tree)</h3><ul><li><strong>基本概念：</strong> B 树是一种<strong>多路平衡查找树</strong>。与二叉树不同，B 树的每个节点可以有<strong>多个子节点</strong>（通常多于两个）。它的设计核心是为了<strong>优化磁盘 I/O 操作</strong>，因为磁盘读写是块（block）为单位的，B 树通过增加节点的分支数（阶数）来降低树的高度，从而减少磁盘访问次数。</li><li><strong>核心特性：</strong><ol><li><strong>多路（M 阶树）：</strong> 每个节点可以有 <code>M</code> 个子节点（<code>M &gt; 2</code>），并包含 <code>M-1</code> 个键。</li><li><strong>节点内有序：</strong> 每个节点中的键值是排序的。</li><li><strong>节点内存储数据：</strong> <strong>非叶子节点和叶子节点都可以存储实际的键值数据</strong>（或指向数据的指针）。</li><li><strong>所有叶子节点在同一层：</strong> 这保证了从根到任何叶子节点的查找路径长度相同，因此查找效率稳定。</li><li><strong>为磁盘优化：</strong> 节点的大小通常被设计为与磁盘块大小相匹配，一次磁盘 I/O 可以读取更多的键。</li></ol></li><li><strong>典型应用场景：</strong><ul><li><strong>文件系统和数据库索引：</strong> B 树被广泛应用于文件系统（如 NTFS, HFS+）和某些数据库系统（如 MongoDB）的索引结构。</li><li><strong>数据量大，无法完全加载到内存：</strong> 当数据存储在磁盘等外部存储介质上，且需要最小化磁盘 I/O 次数时，B 树是理想选择。</li></ul></li></ul><hr><h3 id="3-B-树-B-Tree"><a href="#3-B-树-B-Tree" class="headerlink" title="3. B+ 树 (B+ Tree)"></a>3. B+ 树 (B+ Tree)</h3><ul><li><p><strong>基本概念：</strong> B+ 树是 B 树的一种<strong>变体</strong>，它对 B 树进行了进一步的优化，使其更适合于<strong>数据库索引</strong>和文件系统。B+ 树的核心特点是<strong>所有的数据都存储在叶子节点，并且叶子节点之间通过链表连接</strong>。</p></li><li><p><strong>核心特性：</strong></p><ol><li><strong>多路（M 阶树）：</strong> 与 B 树类似，每个节点可以有 <code>M</code> 个子节点。</li><li><strong>非叶子节点只存储键（索引）：</strong> 非叶子节点（内部节点）只存储键（或索引），不存储实际的键值数据。这使得每个非叶子节点可以存储更多的键，从而降低树的高度，进一步减少磁盘 I/O。</li><li><strong>所有数据都在叶子节点：</strong> 所有的实际键值数据（或指向数据的指针）都存储在<strong>叶子节点</strong>中。</li><li><strong>叶子节点通过链表连接：</strong> 所有叶子节点构成一个<strong>有序的链表</strong>。</li><li><strong>所有键都在叶子节点出现：</strong> 即使是存在于非叶子节点中的键，也会在叶子节点中再次出现。</li></ol></li><li><p><strong>典型应用场景：</strong></p><ul><li><strong>关系型数据库索引（如 MySQL 的 InnoDB 存储引擎）：</strong> 这是 B+ 树最主要的应用场景。</li><li><strong>需要高效的范围查询和全表扫描：</strong> 由于叶子节点通过链表连接且包含所有数据，范围查询变得非常高效，只需找到起始叶子节点，然后沿着链表遍历即可。全表扫描也只需遍历叶子节点链表。</li></ul><h3 id="红黑树、B-树、B-树的主要区别总结"><a href="#红黑树、B-树、B-树的主要区别总结" class="headerlink" title="红黑树、B 树、B+ 树的主要区别总结"></a>红黑树、B 树、B+ 树的主要区别总结</h3><p>| 特性           | 红黑树 (Red-Black Tree)                                      | B 树 (B-Tree)                                   | B+ 树 (B+ Tree)                                              |<br>| ——————— | —————————————————————————————— | ———————————————————————- | —————————————————————————————— |<br>| <strong>结构类型</strong>   | <strong>二叉查找树</strong> (每个节点最多 2 个子节点)                     | <strong>多路查找树</strong> (每个节点可以有 M 个子节点)      | <strong>多路查找树</strong> (B 树的变体，每个节点可以有 M 个子节点)       |<br>| <strong>平衡方式</strong>   | 节点着色 (红/黑) + 旋转 + 重新着色                           | 节点分裂/合并 (所有叶子节点在同一层)            | 节点分裂/合并 (所有叶子节点在同一层)                         |<br>| <strong>数据存储</strong>   | <strong>所有节点</strong>都存储键值对                                     | <strong>非叶子节点和叶子节点</strong>都可能存储键值数据      | <strong>只有叶子节点</strong>存储键值数据，非叶子节点只存储键（索引）     |<br>| <strong>查询路径</strong>   | 从根到目标节点的路径长度可能不同 (近似平衡)                  | 从根到任何键的路径长度相同 (所有叶子在同一层)   | <strong>所有查找必须达到叶子节点</strong>，路径长度相同，查询效率稳定     |<br>| <strong>范围查询</strong>   | 效率相对较低，需要中序遍历                                   | 效率一般，需要进行多节点的中序遍历              | <strong>效率高</strong>，所有叶子节点通过链表连接，可顺序遍历             |<br>| <strong>磁盘 I/O</strong>   | 针对内存设计，<strong>不考虑磁盘 I/O 优化</strong>，树高较高，可能导致多次 I/O | 为磁盘优化，降低树高，减少 I/O 次数             | <strong>进一步优化磁盘 I/O</strong>，非叶子节点只存索引，可装更多键，树更矮胖，且范围查询更高效 |<br>| <strong>典型应用</strong>   | 内存中的集合 (<code>TreeMap</code>, <code>std::map</code>)                         | 文件系统 (部分)、一些 NoSQL 数据库 (如 MongoDB) | <strong>关系型数据库索引</strong> (如 MySQL 的 InnoDB), 文件系统          |<br>| <strong>父节点冗余</strong> | 无                                                           | 有 (键可能出现在父节点和其子节点中)             | <strong>有</strong> (非叶子节点的键也会出现在其子节点中，最终在叶子节点中) |</p></li></ul><p>如果你主要处理<strong>内存中的数据</strong>，且需要高效的<strong>单点查找、插入和删除</strong>（且对范围查询不那么敏感），<strong>红黑树</strong>通常是更好的选择，因为它实现相对简单，且在内存中性能优异。</p><p>如果你处理<strong>大量数据，需要存储在磁盘上</strong>，并且要<strong>最小化磁盘 I/O 次数</strong>，<strong>B 树</strong>是一个好的选择。</p><p>如果你处理的是<strong>数据库索引</strong>或需要<strong>频繁进行范围查询</strong>的场景，<strong>B+ 树</strong>无疑是最佳选择，因为它通过将所有数据集中在叶子节点并用链表连接，极大地优化了范围查找和全表扫描的性能。</p><p>concurrentHashMap实现  JDK7 分段锁 JDK8+ CAS+synchronized+Node</p><p>JDK 8 对 <code>ConcurrentHashMap</code> 进行了<strong>彻底的重构</strong>，放弃了分段锁的设计，转而采用 <strong>CAS（Compare-And-Swap）+ <code>synchronized</code> + 红黑树</strong> 的混合策略。</p><p>核心思想：</p><p><strong>取消 Segment 概念：</strong> JDK 8 中不再有 <code>Segment</code> 类。取而代之的是一个由 <code>Node</code> 数组组成的哈希表。</p><ol><li><strong>锁的粒度：</strong><ul><li><strong>读操作：</strong> 大部分读操作仍然是无锁的，通过 <code>volatile</code> 和 <code>final</code> 关键字保证可见性。</li><li><strong>写操作：</strong> 写操作（put、remove）只锁定发生冲突的哈希桶的<strong>头节点（Node）</strong>。当多个线程操作不同的哈希桶时，它们之间不会互相阻塞，实现了更高的并发度。</li><li><strong><code>synchronized</code> 代替 <code>ReentrantLock</code>：</strong> JDK 8 使用 <code>synchronized</code> 关键字替代了 <code>ReentrantLock</code>。这是因为 JDK 8 对 <code>synchronized</code> 关键字进行了大量优化，使其性能已经非常接近甚至超越了 <code>ReentrantLock</code>，并且代码实现更为简洁。</li></ul></li><li><strong>链表转红黑树：</strong> 与 <code>HashMap</code> 类似，当链表长度超过阈值（默认为 8）时，链表会转换为红黑树，以提高查找效率（从 O(N) 优化到 O(log N)）。这在哈希冲突严重时能有效避免性能下降。</li><li><strong>CAS 操作：</strong> 在进行一些非阻塞操作（如扩容时的迁移、<code>size</code> 统计）时，会利用 CAS 操作来保证原子性。例如，在修改 <code>size</code> 变量时，会使用 <code>CAS</code> 操作。</li></ol><p><code>ConcurrentHashMap</code> 在 JDK 7 中的实现 (分段锁 Segment)</p><p>在 JDK 7 中，<code>ConcurrentHashMap</code> 主要通过<strong>分段锁（Segment）</strong>的机制来实现高并发。</p><p>核心思想：</p><ol><li><strong>分段（Segmentation）：</strong> 整个 <code>ConcurrentHashMap</code> 被分成若干个独立的段（Segment），每个段都是一个独立的 <code>ReentrantLock</code>。默认情况下，通常有 16 个或更多个段，这意味着理论上可以支持 16 个或更多个并发的写入操作。</li><li><strong>写操作的并发：</strong> 当一个线程需要写入（put、remove）数据时，它只需要锁定数据所在的那个 Segment，而其他线程仍然可以并发地访问（读写）其他 Segment。这大大减少了锁的粒度。</li><li><strong>读操作的并发：</strong> 大多数读操作（get）是无锁的。它通过 <code>volatile</code> 关键字来保证数据的可见性，允许多个线程同时读取。在某些情况下（如 Segment 的 <code>modCount</code> 发生变化），可能需要进行二次检查以确保数据一致性。</li><li><strong>结构：</strong><ul><li>内部有一个 <code>Segment</code> 数组，<code>Segment</code> 继承自 <code>ReentrantLock</code>。</li><li>每个 <code>Segment</code> 内部包含一个 <code>HashEntry</code> 数组（类似于 <code>HashMap</code> 的底层数组）和链表结构。</li><li>哈希函数会先确定键属于哪个 Segment，然后再在该 Segment 内部计算哈希值，定位到具体的 <code>HashEntry</code> 数组索引。</li></ul></li></ol><p>多线程安全环境下使用集合,线程安全的集合.</p><p><strong>面试题：</strong> 如何在多线程环境下使用集合？请列举并解释几种线程安全的集合类。</p><ul><li><strong><code>Vector</code> 和 <code>Hashtable</code>：</strong><ul><li><strong>原理：</strong> 通过在每个方法上加 <code>synchronized</code> 关键字实现粗粒度同步（锁住整个对象）。</li><li><strong>缺点：</strong> 性能低下，因为同一时间只有一个线程能访问集合的任何方法，并发度很低。</li></ul></li><li><strong><code>Collections.synchronizedList/Set/Map()</code>：</strong><ul><li><strong>原理：</strong> 这是一系列工厂方法，它返回一个由底层非线程安全集合（如 <code>ArrayList</code>, <code>HashMap</code>）包装而成的线程安全版本。同样是通过 <code>synchronized</code> 关键字对所有方法进行同步。</li><li><strong>缺点：</strong> 与 <code>Vector</code>/<code>Hashtable</code> 类似，也是粗粒度同步，性能瓶颈明显。</li></ul></li><li><strong><code>ConcurrentHashMap</code>：</strong> (推荐用于并发Map)<ul><li><strong>原理：</strong> 采用<strong>分段锁（Segment）</strong>（JDK 7）或 <strong>CAS + Synchronized + Node</strong>（JDK 8）实现更细粒度的并发控制。在 JDK 8 中，取消了 Segment，直接使用 <code>synchronized</code> 锁住哈希桶的头节点，结合 CAS 操作，实现了更高的并发度。</li><li><strong>特点：</strong> 读操作通常不需要加锁，写操作只锁住受影响的部分，大大提高了并发性能。</li><li><strong>适用场景：</strong> 高并发场景下对 Map 的读写操作。</li></ul></li><li><strong><code>CopyOnWriteArrayList</code> 和 <code>CopyOnWriteArraySet</code>：</strong> (推荐用于并发List/Set，写少读多)<ul><li><strong>原理：</strong> 写时复制（Copy-On-Write）。当对集合进行写操作（添加、修改、删除）时，会先复制一份底层数组，在新数组上完成修改，然后将新数组的引用指向集合。读操作则不需要加锁，直接读取旧数组。</li><li><strong>特点：</strong><ul><li><strong>读写分离：</strong> 读操作完全是无锁的，性能极高。</li><li><strong>写操作开销大：</strong> 每次写操作都会复制整个数组，对于数据量大且写操作频繁的场景，性能会很差。</li><li><strong>数据一致性：</strong> 读到的可能是旧版本的数据（写操作过程中），是<strong>最终一致性</strong>。</li></ul></li><li><strong>适用场景：</strong> 读操作远远多于写操作的并发场景，例如黑名单、白名单、事件监听器列表等。</li></ul></li></ul><h4 id="异常、泛型与集合框架"><a href="#异常、泛型与集合框架" class="headerlink" title="异常、泛型与集合框架"></a>异常、泛型与集合框架</h4><p>Java中异常的类继承体系</p><p><img data-src="https://s2.loli.net/2025/03/11/yhg79kQxwJiCBO6.png" alt="image-20250311153912955"></p><p>运行时异常(extends RuntimeException:数组索引越界</p><p>编译异常(extends Exception). 编译时异常需要通过try-catch或throw丢出异常进行处理,</p><p>运行时异常不需要特别处理</p><p>此外异常可以分为业务类和运行逻辑类,一些代码中的异常应该被catch然后向上抛给业务类或者直接处理. </p><p><img data-src="https://s2.loli.net/2025/03/11/XR4zx7ycNQiSBlt.png" alt="image-20250311175150716"></p><p>泛型允许编写可以<strong>处理不同类型数据的类、接口和方法，而无需在代码中明确指定具体类型</strong>。泛型提供了更强的类型检查，并且消除了对类型转换的需求，从而使得代码更加安全和易于维护。</p><p><strong>类型参数</strong>：在定义泛型类或方法时使用占位符（通常为大写字母如 <code>T</code>, <code>E</code>, <code>K</code>, <code>V</code> 等），代表实际应用中的类型。</p><ul><li><strong>类型安全</strong>：编译器会在编译期进行类型检查，减少运行时出现的 <code>ClassCastException</code> 错误。</li><li><strong>消除类型转换</strong>：由于类型信息在编译时已知，因此不需要显式的类型转换。</li></ul><h4 id="使用泛型类"><a href="#使用泛型类" class="headerlink" title="使用泛型类"></a>使用泛型类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">integerBox.set(<span class="number">10</span>);</span><br><span class="line">Integer intValue = integerBox.get();</span><br><span class="line"></span><br><span class="line">Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">stringBox.set(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">String strValue = stringBox.get();</span><br></pre></td></tr></table></figure><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>你也可以定义泛型方法，即在方法级别上使用泛型。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(T[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T element : array) &#123;</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[] intArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    String[] stringArray = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    printArray(intArray);</span><br><span class="line">    printArray(stringArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>&lt;T&gt;</code> 在方法签名前声明了类型参数，这样这个方法就可以接受任意类型的数组作为参数。</p><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>类似地，也可以定义泛型接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实现这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringContainer</span> <span class="keyword">implements</span> <span class="title">Container</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        items.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Java 泛型是在 Java 5 中引入的，而在此之前已经存在了大量的 Java 代码库。如果直接在 JVM 层面实现泛型支持，那么这些现有的代码可能会因为缺乏泛型信息而不兼容。通过类型擦除，Java 编译器能够在编译时移除泛型类型信息，并将泛型代码转换为非泛型代码，这样就可以确保新旧代码可以无缝地一起工作</p></blockquote><p><strong>通配符</strong></p><p>有时可能需要编写能够与多种类型工作的代码，但并不需要知道这些类型的具体细节。这时可以使用通配符 <code>?</code>：</p><ul><li><strong>无界通配符</strong>：<code>&lt;?&gt;</code> 表示可以是任何类型。</li><li><strong>有界通配符</strong>：<code>&lt;? extends T&gt;</code> 和 <code>&lt;? super T&gt;</code> 分别表示类型必须是 <code>T</code> 或其子类，以及 <code>T</code> 或其父类。</li></ul><p><strong>泛型的优点</strong></p><ol><li><strong>类型安全</strong>：编译器可以在编译时进行更多的类型检查，减少运行时错误。</li><li><strong>消除强制类型转换</strong>：不再需要手动将对象转换回原始类型。</li><li><strong>提高代码重用性</strong>：通过泛型，相同的逻辑可以应用于不同的数据类型。</li></ol><p>Java集合是一种容器,类似于数组但集合的大小可变.</p><p><img data-src="https://s2.loli.net/2025/03/14/8tKapiLbw7csMlP.png" alt="image-20250314192425271"></p><p><img data-src="https://s2.loli.net/2025/03/14/ZL6IFGzBio5Pbc2.png" alt="image-20250314230501695"></p><h3 id="多线程与线程池"><a href="#多线程与线程池" class="headerlink" title="多线程与线程池"></a>多线程与线程池</h3><p><img data-src="https://s2.loli.net/2025/03/19/WxNStmTMp2D5viR.png" alt="image-20250319170141141"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sekyoro.tutorThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: workspace</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span>: com.sekyoro.tutorThread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span>: threadDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: proanimer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/3/19 16:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">easyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">miniThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a mini thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">miniCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">miniCallable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">miniCallable</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Calculating...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">threadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        Thread et = <span class="keyword">new</span> easyThread();</span><br><span class="line">        et.start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> miniThread()).start();</span><br><span class="line"></span><br><span class="line">        Callable&lt;Integer&gt; mc = <span class="keyword">new</span> miniCallable();</span><br><span class="line">        FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">        <span class="keyword">new</span> Thread(ft).start();</span><br><span class="line">        Integer i = ft.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/19/8Dlxb1zAqTgOWyF.png" alt="image-20250319171222472"></p><p>线程同步解决线程安全问题</p><p><strong>同步代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/19/S8WiOA2HE5gwVUT.png" alt="image-20250319173439131"></p><p><strong>同步方法</strong></p><p><img data-src="https://s2.loli.net/2025/03/19/y1U9gKj6fHmab8k.png" alt="image-20250319173832373"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">          money -= m;   </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>Lock锁</strong></p><p><img data-src="https://s2.loli.net/2025/03/19/bBamC6ND3n7TcEO.png" alt="image-20250319174259793"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure><p>显式锁（Explicit Lock）</p><ul><li><p>ReentrantLock 类提供了比synchronized更灵活的锁操作，例如可中断的锁等待、尝试非阻塞获取锁、超时获取锁等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 受保护的代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// 确保释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li>读写锁（ReadWriteLock）</li></ol><p>ReadWriteLock 接口 和 ReentrantReadWriteLock 实现类.允许多个读操作同时进行，但在写操作时排斥所有其他读写操作。适用于读多写少的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">rwl.readLock().lock(); <span class="comment">// 获取读锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 读取操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    rwl.readLock().unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rwl.writeLock().lock(); <span class="comment">// 获取写锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 写入操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    rwl.writeLock().unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>条件变量（Condition）</li></ol><p>Condition 接口与显式锁配合使用，提供类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    condition.await(); <span class="comment">// 相当于 wait()</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    condition.signal(); <span class="comment">// 相当于 notify()</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>StampedLock</li></ol><p>StampedLock 类是Java 8引入的一种新的锁类型，支持乐观读锁策略，适用于读多写少且大部分读操作不会发生冲突的情况。它提供了三种模式：写锁、悲观读锁和乐观读锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> stamp = stampedLock.readLock(); <span class="comment">// 悲观读锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 读取操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    stampedLock.unlockRead(stamp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stamp = stampedLock.writeLock(); <span class="comment">// 写锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 写入操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    stampedLock.unlockWrite(stamp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> optimisticStamp = stampedLock.tryOptimisticRead(); <span class="comment">// 乐观读锁</span></span><br><span class="line"><span class="comment">// 验证并使用乐观读锁...</span></span><br><span class="line"><span class="keyword">if</span> (!stampedLock.validate(optimisticStamp)) &#123;</span><br><span class="line">    <span class="comment">// 如果验证失败，则需要重新获取悲观读锁或写锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池</strong></p><ol><li>ThreadPoolExecutor创建线程池</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建线程池</span></span><br><span class="line">ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用线程池处理任务</span></span><br><span class="line">Runnable myRunnable = <span class="keyword">new</span> MyRunnable(<span class="number">3</span>);</span><br><span class="line">pool.execute(<span class="keyword">new</span> MyRunnable(<span class="number">3</span>)); <span class="comment">//提交任务</span></span><br><span class="line">pool.execute(<span class="keyword">new</span> MyRunnable(<span class="number">3</span>)); <span class="comment">//提交任务</span></span><br><span class="line">pool.execute(<span class="keyword">new</span> MyRunnable(<span class="number">3</span>)); <span class="comment">//提交任务</span></span><br><span class="line">pool.execute(<span class="keyword">new</span> MyRunnable(<span class="number">3</span>)); <span class="comment">//提交任务</span></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/19/yTXM2Brukzw7IC8.png" alt="image-20250319205156594"></p><p><img data-src="https://s2.loli.net/2025/03/19/yIabTL2S9J4vDlX.png" alt="image-20250319205627740"></p><ol><li>利用Executors创建线程池</li></ol><p><img data-src="https://s2.loli.net/2025/03/19/A8KrfdjOShZTsnU.png" alt="image-20250319210516204"></p><p>利用ThreadPoolExecutor设置不同参数调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                              <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                              <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="反射、注解与动态代理"><a href="#反射、注解与动态代理" class="headerlink" title="反射、注解与动态代理"></a>反射、注解与动态代理</h3><p>反射是指在运行时动态地获取类的信息以及操作对象的能力。通常情况下，Java 编译器会在编译期确定所有类型和成员变量的访问权限及调用方式，而反射则允许你在运行时进行这些操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一: 直接通过类名获取</span></span><br><span class="line">Class&lt;?&gt; clazz = MyClass.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二: 使用对象的 getClass() 方法</span></span><br><span class="line">MyClass obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">clazz = obj.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三: 通过全限定类名字符串</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的class类可以用来<strong>创建实例</strong>、<strong>访问字段</strong>、<strong>调用方法</strong>等</p><p>创建实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 假设 MyClass 有一个无参构造函数</span></span><br><span class="line">    Object obj = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取指定参数类型的构造函数</span></span><br><span class="line">    Constructor&lt;MyClass&gt; constructor = clazz.getConstructor(paramType.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建实例</span></span><br><span class="line">    MyClass instance = constructor.newInstance(args);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注解（Annotations）</strong>是一种元数据形式，它提供了关于程序代码的额外信息，但这些信息并不直接改变程序的运行逻辑。注解自 Java 5 引入以来，已经成为 Java 开发中不可或缺的一部分，用于简化开发流程、提供配置信息、增强代码的功能等</p><ul><li><strong>定义</strong>：注解是接口的一种特殊形式，它通过 <code>@interface</code> 关键字来定义，并可以附加到类、方法、变量、参数、包声明等语言元素上。</li><li><strong>用途</strong>：主要用于编译时检查、运行时处理和生成源代码或文档。</li></ul><ol><li><strong>标记注解</strong>：没有成员变量，仅作为标记使用，如 <code>@Override</code>。</li><li><strong>单值注解</strong>：只有一个值，通常省略名称直接指定值，如 <code>@SuppressWarnings(&quot;unchecked&quot;)</code>。</li><li><strong>完整注解</strong>：包含多个成员变量，需要明确指定每个成员的值。</li></ol><p>元注解是指用来注解其他注解的注解，主要包括以下几个：</p><ul><li><code>@Retention</code>：定义了注解的存在阶段（SOURCE, CLASS, RUNTIME）。</li><li><code>@Target</code>：指定了注解可以应用的目标元素类型（TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE 等）。</li><li><code>@Documented</code>：表明这个注解应该被 javadoc 工具记录。</li><li><code>@Inherited</code>：允许子类继承父类中的注解。</li><li><code>@Repeatable</code>：从 Java 8 开始支持，表示相同的注解可以在同一地方多次使用。</li></ul><p><strong>注解的解析</strong></p><p>检查方法和类等是否包含对应注解,若包含则进行相关调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">annotationDemo annotationDemo = <span class="keyword">new</span> annotationDemo();</span><br><span class="line"> Class&lt;?&gt; aClass = annotationDemo.class;</span><br><span class="line"> Method[] methods = aClass.getMethods();</span><br><span class="line"> <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">     <span class="keyword">if</span> (method.isAnnotationPresent( MyTest.class)) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             MyTest declaredAnnotation = method.getDeclaredAnnotation(MyTest.class);</span><br><span class="line">             method.invoke(annotationDemo);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>动态代理</strong></p><p>Proxy.newProxyInstance创建代理,参数包括类加载器,需要实现的接口,和代理需要做的事情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StarService <span class="title">createProxy</span><span class="params">(StarService starService)</span></span>&#123;</span><br><span class="line">        StarService o = (StarService)Proxy.newProxyInstance(ProxyUtils.class.getClassLoader(), starService.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">               String methodName = method.getName();</span><br><span class="line">               <span class="keyword">if</span>(<span class="string">&quot;sing&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;sing a song: &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     System.out.println(<span class="string">&quot;dance a dance&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">                <span class="keyword">if</span>(method.getReturnType().equals(Void.TYPE)) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       <span class="keyword">return</span>  method.invoke(starService,args);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h4><p>类加载过程主要包括三个阶段：<strong>加载</strong>、<strong>链接</strong>和<strong>初始化</strong>。</p><ul><li><strong>加载</strong>：通过类的全限定名获取定义此类的二进制字节流，并将其转换为方法区中的运行时数据结构，在内存中生成一个代表该类的 <code>java.lang.Class</code> 对象。</li><li><strong>链接</strong>：包括验证、准备和解析三个步骤。验证确保被加载类的正确性；准备则为类变量分配内存并设置默认初始值；解析是将类、接口、字段和方法的符号引用转为直接引用的过程。</li><li><strong>初始化</strong>：执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程，对静态变量和静态代码块进行初始化。</li></ul><p>Java 类加载器使用双亲委派模型来搜索类或资源。<strong>当一个类加载器收到类加载请求时，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成</strong>，每一层的类加载器都是如此，因此所有的类加载请求最终都会传送到顶层的启动类加载器。<strong>只有当父类加载器无法加载该类时，子类加载器才会尝试自己加载</strong></p><p>Java 提供了三种内置的类加载器：</p><ul><li><strong>Bootstrap ClassLoader</strong>：这是最顶层的类加载器，由本地代码实现，通<strong>常用于加载核心 JDK 类库</strong>（如 <code>rt.jar</code>）。 无法直接访问,显示为null</li><li><strong>Extension ClassLoader</strong>：扩展类加载器，<strong>用来加载位于 <code>$JAVA_HOME/jre/lib/ext</code> 目录下的 JAR 包</strong>。 (目前使用PlatformClassLoader,加载 JDK 提供的平台模块中的类，例如 <code>java.sql</code>, <code>java.xml</code>, <code>javax.*</code> 等模块化的平台类。)</li><li><strong>Application ClassLoader</strong>：应用程序类加载器，<strong>负责加载用户类路径（ClassPath）上指定的类库</strong></li></ul><p>Java 提供了一些常用的方法来操作类加载器：</p><p><strong>(1) <code>loadClass(String name)</code></strong></p><p>加载指定名称的类或接口。如果已经加载过，则直接返回对应的 <code>Class</code> 对象；如果没有，则按照双亲委派机制尝试加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) <code>findClass(String name)</code></strong></p><p>查找指定名称的类。默认实现会抛出 <code>ClassNotFoundException</code> 异常，通常需要自定义类加载器覆盖此方法以提供具体的类查找逻辑。</p><p><strong>(3) <code>defineClass(byte[] b, int off, int len)</code></strong></p><p>将一个字节数组转换成一个类的 <code>Class</code> 对象。一般不直接调用，主要用于自定义类加载器。</p><p><strong>(4) <code>getResource(String name)</code> 和 <code>getResourceAsStream(String name)</code></strong></p><p>用于查找资源文件。前者返回资源的 URL，后者返回资源的输入流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL resourceUrl = getClass().getClassLoader().getResource(<span class="string">&quot;config.properties&quot;</span>);</span><br><span class="line">InputStream inputStream = getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;config.properties&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>(5) <code>getParent()</code></strong></p><p>返回该类加载器的父类加载器。注意，Bootstrap ClassLoader 没有父类加载器，所以对于 Bootstrap ClassLoader 调用 <code>getParent()</code> 将返回 <code>null</code>。</p><p><strong>4. 自定义类加载器</strong></p><p>有时我们需要根据特定的需求来自定义类加载器。可以通过继承 <code>java.lang.ClassLoader</code> 并重写 <code>findClass</code> 方法来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = loadClassData(name); <span class="comment">// 实现类数据加载逻辑</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String className) &#123;</span><br><span class="line">        <span class="comment">// 加载类数据的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是实现自定义类加载器的基本步骤：</p><ol><li><p>继承 <code>ClassLoader</code></p><ul><li>创建一个类并继承 <code>ClassLoader</code>。</li></ul></li><li><p>重写 <code>findClass()</code> 方法(遵从双亲委派机制)</p><ul><li>实现自定义的类加载逻辑。</li></ul></li><li><p>调用 <code>defineClass()</code> 方法</p><ul><li>将字节码转换为 <code>Class</code> 对象。</li></ul><p>class对象相同需要classloader相同,相同的classloader进行loadclass相同的类得到的class相同</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载类的根路径</span></span><br><span class="line">    <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(String classPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 读取类的字节码</span></span><br><span class="line">        <span class="keyword">byte</span>[] classData = loadClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;Class not found: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解密字节码</span></span><br><span class="line">        <span class="keyword">byte</span>[] decryptedClassData = decrypt(classData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义类</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, decryptedClassData, <span class="number">0</span>, decryptedClassData.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载类的字节码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String className) &#123;</span><br><span class="line">        String path = classPath + className.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">             ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">            <span class="keyword">int</span> buffer;</span><br><span class="line">            <span class="keyword">while</span> ((buffer = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟解密过程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] data) &#123;</span><br><span class="line">        <span class="comment">// 简单的异或解密</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">            data[i] = (<span class="keyword">byte</span>) (data[i] ^ <span class="number">0xFF</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义类加载器</span></span><br><span class="line">        CustomClassLoader customClassLoader = <span class="keyword">new</span> CustomClassLoader(<span class="string">&quot;path/to/classes/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用自定义类加载器加载类</span></span><br><span class="line">        Class&lt;?&gt; clazz = customClassLoader.loadClass(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Loaded class: &quot;</span> + clazz.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建实例并调用方法</span></span><br><span class="line">        Object instance = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">        clazz.getMethod(<span class="string">&quot;sayHello&quot;</span>).invoke(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程上下文加载器"><a href="#线程上下文加载器" class="headerlink" title="线程上下文加载器"></a>线程上下文加载器</h4><p>线程上下文类加载器（Thread Context ClassLoader）是 Java 提供的一种机制，允许开发者在线程中设置和获取类加载器。这种机制主要用于解决某些特定场景下类加载的问题，尤其是在复杂的类层次结构或模块化系统中。</p><p><strong>线程上下文类加载器的作用</strong></p><ol><li><strong>解决类加载器隔离问题</strong>：<ul><li>在 Java 应用程序中，不同的类加载器可能会形成类加载器树，这导致了类加载器之间的隔离性。</li><li>例如，在 Web 容器或 OSGi 等环境中，不同应用或模块可能使用不同的类加载器来加载各自的类。在这种情况下，如果一个类需要加载另一个类加载器负责加载的类，则会遇到问题。</li><li>线程上下文类加载器提供了一种绕过双亲委派模型的方式，允许当前线程使用指定的类加载器来加载类。</li></ul></li><li><strong>支持框架和库的开发</strong>：<ul><li>许多框架和库（如 JNDI、JDBC 驱动等）依赖于线程上下文类加载器来加载必要的类。</li><li>这些框架通常不知道具体的类加载器，因此它们可以利用线程上下文类加载器来动态地加载所需的类。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadContextClassLoaderExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取默认的上下文类加载器</span></span><br><span class="line">            ClassLoader defaultClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            System.out.println(<span class="string">&quot;默认的上下文类加载器: &quot;</span> + defaultClassLoader);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建一个新的类加载器（例如自定义类加载器）</span></span><br><span class="line">            ClassLoader customClassLoader = <span class="keyword">new</span> CustomClassLoader();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置新的上下文类加载器</span></span><br><span class="line">            Thread.currentThread().setContextClassLoader(customClassLoader);</span><br><span class="line">            System.out.println(<span class="string">&quot;设置后的上下文类加载器: &quot;</span> + Thread.currentThread().getContextClassLoader());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用上下文类加载器加载类</span></span><br><span class="line">            Class&lt;?&gt; clazz = Thread.currentThread().getContextClassLoader().loadClass(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;加载的类: &quot;</span> + clazz.getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 实现类的查找逻辑</span></span><br><span class="line">        <span class="keyword">byte</span>[] classData = loadClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String className) &#123;</span><br><span class="line">        <span class="comment">// 模拟从文件或其他来源读取类数据的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p><img data-src="https://s2.loli.net/2025/03/20/iZdH8kUa9LYAFQW.png" alt="image-20250320221417773"></p><p>程序计数器: 线程私有</p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>判断对象可以回收</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>工作原理</p><ol><li><strong>初始化</strong>：每当创建一个新的对象时，该对象的引用计数器被初始化为1。</li><li><strong>增加引用</strong>：每当有新的引用指向这个对象时（例如，将对象赋值给另一个变量），该对象的引用计数加1。</li><li><strong>减少引用</strong>：每当某个引用不再指向该对象时（例如，变量超出作用域或重新赋值），该对象的引用计数减1。</li><li><strong>回收内存</strong>：当一个对象的引用计数降为0时，表示没有其他引用指向该对象，这时就可以立即回收该对象所占用的内存。</li></ol><p>缺点:</p><p><strong>无法处理循环引用</strong>：如果两个或多个对象相互引用形成环状结构，则即使这些对象实际上已经不可达，它们的引用计数也不会变为0，导致内存泄漏。为了克服这个问题，一些语言引入了弱引用（weak references）或专门的循环检测机制。</p><p><strong>多线程环境下的复杂性</strong>：在多线程环境下，对引用计数的修改需要同步操作，以防止竞态条件（race condition），这也增加了实现的复杂性和运行时的开销</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>可达性分析的基本思想是<strong>从一组被称为“根节点”（root set）的对象开始，遍历所有可以通过这些根节点直接或间接引用到的对象，并将它们标记为存活</strong>。未被标记的对象则被认为是不可达的，可以被安全地回收。</p><blockquote><p>在命令行中输入 <code>jps</code> 可以列出所有由当前用户启动的 Java 进程的基本信息</p><p><code>-q</code>：仅输出 JVM 的进程 ID，不输出类名、jar 名等信息</p><p><code>-l</code>：输出主类的完整包名；如果进程执行的是 jar 文件，则输出 jar 文件的完整路径</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:[live,]format=b,file=&lt;filename&gt;.hprof &lt;pid&gt;</span><br></pre></td></tr></table></figure><ul><li><code>live</code>：如果指定了这个选项，则只转储存活的对象；如果不指定，则转储所有对象。</li><li><code>format=b</code>：表示输出格式为二进制，默认就是二进制格式，所以通常省略不写。</li><li><code>&lt;filename&gt;.hprof</code>：指定生成的堆转储文件的名字。</li><li><code>&lt;pid&gt;</code>：目标Java进程的进程ID。</li></ul><p>引用</p><p><img data-src="https://s2.loli.net/2025/03/20/BMyrksQT5S6xlqf.png" alt="image-20250320220503285"></p><p>强引用 软引用 弱引用</p><p>软引用:垃圾回收时且内存不足时会被回收掉</p><p>虚引用  引用队列</p><p>终结器引用</p><ul><li><strong>强引用</strong>：日常编程中最常用的引用类型，几乎所有对象都是通过强引用创建的。</li><li><strong>软引用</strong>：适用于缓存场景，当内存不足时，允许GC回收缓存数据。</li><li><strong>弱引用</strong>：适合于需要自动清理的资源管理场景，例如监听器或回调函数列表中的对象。</li><li><strong>虚引用</strong>：主要用于了解对象何时被垃圾回收，常用于做一些清理工作，比如清除本地内存、关闭文件等</li></ul><h4 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h4><p><strong>标记-清除</strong></p><ul><li>这是最基本的垃圾回收算法，分为两个阶段：标记和清除。在标记阶段，GC从根集合（GC Roots）开始遍历所有可达对象，并标记它们为存活对象；在清除阶段，未被标记的对象即被视为垃圾对象并被回收</li><li>优点是实现简单，适用于任何对象的内存管理；<strong>缺点是会产生内存碎片</strong>，因为<strong>删除了不可达对象后留下的空闲内存可能是不连续的</strong>，这可能导致后续大对象分配失败。</li></ul><p><strong>复制（Copying）算法</strong>：</p><ul><li>复制算法将堆内存划分为两部分，每次只使用其中一部分。当这部分内存用完时，GC会暂停应用，将存活对象复制到另一部分内存中，并清空原内存区域</li><li>此算法避免了内存碎片问题，但代价是只能使用一半的内存空间，且对于存活率较高的对象效率较低。</li></ul><p>复制算法将可用内存分为两部分，通常称为From Space和To Space。</p><p>程序只使用其中一部分（From Space），当这部分内存满后，GC会遍历From Space中的所有对象，将存活的对象复制到To Space，并且更新这些对象的引用指向新的位置。</p><p>清理完From Space后，它变为可用空间，而To Space则成为下次分配新对象的空间</p><p>这个过程有效地避免了内存碎片化的问题，因为每次清理后的内存区域都是连续的</p><p><strong>标记-整理（Mark-Compact）算法</strong>：</p><ul><li>标记-整理算法结合了标记-清除和复制的优点，在标记阶段与标记-清除类似，但在清除阶段，它会将存活的对象移动到内存的一端，然后清理掉端边界以外的空间</li><li>它解决了内存碎片问题，但需要移动存活对象，增加了回收的开销。</li></ul><p>标记整理算法首先执行标记阶段，这与标记清除算法相同，即通<strong>过可达性分析找到所有存活的对象并进行标记</strong>。</p><p>接下来是整理阶段，在这个阶段，<strong>所有的存活对象会被移动到内存的一端，这样可以确保所有的空闲空间都在另一端</strong>，形成一个连续的块。</p><p>最后一步是<strong>对剩余的未被标记的部分进行清理，释放出连续的内存块</strong></p><p><strong>分代收集（Generational Collection）算法</strong>：</p><ul><li>分代收集是一种基于对象生命周期特征优化的策略，将堆内存划分为年轻代（Young Generation）和老年代（Old Generation）。年轻代通常采用复制算法，而老年代则采用标记-清除或标记-整理算法</li><li>这种方法利用了大多数对象“朝生夕死”的特点，提高了垃圾回收的效率。</li></ul><p><strong>1. 堆内存分区</strong></p><p>在分代垃圾回收中，堆内存通常被划分为三个主要区域：</p><ul><li><strong>年轻代（Young Generation）</strong>：<ul><li>主要用于存放新创建的对象。</li><li>进一步细分为一个 Eden 区和两个 Survivor 区（From 和 To）。</li></ul></li><li><strong>老年代（Old Generation）</strong>：<ul><li>存放的是经过多次垃圾回收后仍然存活的对象，这些对象被认为具有较长的生命期。</li></ul></li><li><strong>永久代/元空间（Permanent Generation/Metaspace）</strong>：<ul><li>在 Java 8 之前称为永久代，之后改为元空间，主要用于存储类的元数据、方法描述等信息，并不属于堆的一部分。</li></ul></li></ul><p><strong>2. 分代垃圾回收过程</strong></p><p><strong>年轻代垃圾回收（Minor GC）</strong></p><ul><li><strong>Eden 区与 Survivor 区</strong>：当一个新的对象被创建时，它首先被分配到 Eden 区。如果 Eden 区满了，就会触发一次 Minor GC。</li><li><strong>复制算法</strong>：Minor GC 使用这种算法来清理垃圾对象。在这个过程中，存活的对象会被复制到其中一个 Survivor 区（假设为 From），同时清除 Eden 区。</li><li><strong>Survivor 区交换</strong>：下一次 Minor GC 发生时，Eden 区和当前的 From Survivor 区中的存活对象会被复制到另一个 Survivor 区（To）。然后这两个角色会互换（即原来的 From 变成 To，反之亦然）。</li><li><strong>晋升至老年代</strong>：当某个对象经历了若干次 Minor GC 后仍然存活（默认情况下是 15 次），它将被移动到老年代。</li></ul><p><strong>老年代垃圾回收（Major GC / Full GC）</strong></p><ul><li><strong>Full GC</strong>：当老年代也满时，将会触发 Full GC，这会同时清理年轻代和老年代。由于老年代中的对象通常是长期存活的，所以 Full GC 的频率远低于 Minor GC，但其执行成本更高。</li><li><strong>标记-清除或标记-整理算法</strong>：对于老年代，可能会使用这两种算法之一。标记-清除算法简单地标识并删除不再使用的对象，但会导致内存碎片化；标记-整理算法则会在清理的同时压缩内存，减少碎片。</li></ul><p>一些常用的 JVM 参数，用于调整分代垃圾回收行为：</p><ul><li><strong>年轻代相关参数</strong>：<ul><li><code>-Xmn&lt;size&gt;</code>：设置年轻代大小。</li><li><code>-XX:SurvivorRatio=&lt;ratio&gt;</code>：设置 Eden 区与 Survivor 区的比例（默认为 8:1）。</li><li><code>-XX:MaxTenuringThreshold=&lt;n&gt;</code>：设置对象晋升到老年代的最大年龄（默认为 15）。</li></ul></li><li><strong>老年代相关参数</strong>：<ul><li><code>-Xms&lt;size&gt;</code>：设置堆内存初始大小。</li><li><code>-Xmx&lt;size&gt;</code>：设置堆内存最大大小。</li></ul></li><li><strong>垃圾回收器选择</strong>：<ul><li><code>-XX:+UseSerialGC</code>：启用 Serial 收集器。</li><li><code>-XX:+UseParallelGC</code>：启用 Parallel 收集器。</li><li><code>-XX:+UseConcMarkSweepGC</code>：启用 CMS 收集器。</li><li><code>-XX:+UseG1GC</code>：启用 G1 收集器。</li><li><code>-XX:+UseZGC</code>：启用 ZGC 收集器。</li><li><code>-XX:+UseShenandoahGC</code>：启用 Shenandoah 收集器</li></ul></li></ul><p><strong>(1) 基本 GC 日志</strong></p><ul><li><code>-XX:+PrintGCDetails</code>：打印详细的垃圾回收日志。</li><li><code>-XX:+PrintGC</code> 或 <code>-verbose:gc</code>：打印简单的垃圾回收日志（仅显示每次 GC 的时间和类型）。</li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintGCDetails -XX:+PrintGC MyApplication</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: <span class="number">1024</span>K-&gt;<span class="number">512</span>K(<span class="number">2048</span>K)] <span class="number">1024</span>K-&gt;<span class="number">768</span>K(<span class="number">6144</span>K), <span class="number">0.0023456</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br></pre></td></tr></table></figure><p><strong>(2) 打印时间戳</strong></p><ul><li><code>-XX:+PrintGCTimeStamps</code>：在每条 GC 日志前添加时间戳（从 JVM 启动开始的时间）。</li><li><code>-XX:+PrintGCDateStamps</code>：在每条 GC 日志前添加实际日期和时间。</li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps MyApplication</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">2023</span>-<span class="number">03</span>-<span class="number">29</span>T<span class="number">12</span>:<span class="number">00</span>:<span class="number">00</span>.<span class="number">000</span>+<span class="number">0000</span>: <span class="number">1</span>.<span class="number">234</span>:<span class="meta"> [GC (Allocation Failure) ...]</span></span><br></pre></td></tr></table></figure><p><strong>(3) 将 GC 日志写入文件</strong></p><ul><li><code>-Xloggc:&lt;file&gt;</code>：将 GC 日志写入指定文件。</li><li>结合其他参数可以生成更详细的日志文件。</li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintGCDetails -Xloggc:gc.log MyApplication</span><br></pre></td></tr></table></figure><p><strong>2. 调整堆内存大小</strong></p><ul><li><code>-Xms&lt;size&gt;</code>：设置 JVM 堆内存的初始大小。例如 <code>-Xms512m</code> 表示初始堆大小为 512MB。</li><li><code>-Xmx&lt;size&gt;</code>：设置 JVM 堆内存的最大大小。例如 <code>-Xmx2g</code> 表示最大堆大小为 2GB。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms512m -Xmx2g MyApplication</span><br></pre></td></tr></table></figure><p><strong>3. 调整年轻代和老年代比例</strong></p><ul><li><code>-XX:NewRatio=&lt;ratio&gt;</code>：设置老年代与年轻代的比例。例如 <code>-XX:NewRatio=3</code> 表示老年代与年轻代的比例为 3:1。</li><li><code>-XX:SurvivorRatio=&lt;ratio&gt;</code>：设置 Eden 区与 Survivor 区的比例。例如 <code>-XX:SurvivorRatio=8</code> 表示 Eden 区与每个 Survivor 区的比例为 8:1。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:NewRatio=3 -XX:SurvivorRatio=8 MyApplication</span><br></pre></td></tr></table></figure><p><strong>4. 设置元空间大小</strong></p><ul><li><code>-XX:MetaspaceSize=&lt;size&gt;</code>：设置元空间的初始大小。</li><li><code>-XX:MaxMetaspaceSize=&lt;size&gt;</code>：设置元空间的最大大小。</li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m MyApplication</span><br></pre></td></tr></table></figure><p><strong>5. 设置线程栈大小</strong></p><ul><li><code>-Xss&lt;size&gt;</code>：设置每个线程的栈大小。例如 <code>-Xss512k</code> 表示每个线程的栈大小为 512KB。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss512k MyApplication</span><br></pre></td></tr></table></figure><p><strong>6. 启用特定垃圾回收器</strong></p><ul><li><code>-XX:+UseSerialGC</code>：启用 Serial 收集器（单线程）。</li><li><code>-XX:+UseParallelGC</code>：启用 Parallel 收集器（多线程，关注吞吐量）。</li><li><code>-XX:+UseConcMarkSweepGC</code>：启用 CMS 收集器（低延迟，适合 Web 应用）。</li><li><code>-XX:+UseG1GC</code>：启用 G1 收集器（适合大内存应用）。</li><li><code>-XX:+UseZGC</code>：启用 ZGC 收集器（超低延迟，适合大内存）。</li><li><code>-XX:+UseShenandoahGC</code>：启用 Shenandoah 收集器（超低延迟）。</li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UseG1GC MyApplication</span><br></pre></td></tr></table></figure><p><strong>7. 设置 GC 暂停时间目标</strong></p><ul><li><code>-XX:MaxGCPauseMillis=&lt;time&gt;</code>：设置 GC 的最大暂停时间目标（单位为毫秒）。只对 G1 和 ZGC 有效。</li><li><code>-XX:GCTimeRatio=&lt;ratio&gt;</code>：设置 GC 时间与应用程序运行时间的比例。例如 <code>-XX:GCTimeRatio=19</code> 表示 GC 时间占总时间的 1/20。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UseG1GC -XX:MaxGCPauseMillis=200 MyApplication</span><br></pre></td></tr></table></figure><p><strong>8. 监控 JVM 性能</strong></p><ul><li><code>-XX:+HeapDumpOnOutOfMemoryError</code>：当发生 OutOfMemoryError 时自动生成堆转储文件。</li><li><code>-XX:HeapDumpPath=&lt;path&gt;</code>：指定堆转储文件的路径。</li><li><code>-XX:+PrintCommandLineFlags</code>：打印 JVM 启动时的所有命令行参数。</li><li><code>-XX:+PrintFlagsFinal</code>：打印所有 JVM 参数及其最终值。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./heapdump.hprof MyApplication</span><br></pre></td></tr></table></figure><p><strong>9. 其他常用参数</strong></p><ul><li><code>-D&lt;property&gt;=&lt;value&gt;</code>：设置系统属性。例如 <code>-Dfile.encoding=UTF-8</code>。</li><li><code>-server</code>：启用服务器模式（默认情况下大多数 JVM 都会自动启用此模式）。</li><li><code>-XX:+DisableExplicitGC</code>：禁用通过 <code>System.gc()</code> 显式触发的垃圾回收。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dfile.encoding=UTF-8 -server -XX:+DisableExplicitGC MyApplication</span><br></pre></td></tr></table></figure><h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><p><strong>1. Serial 收集器</strong></p><ul><li><strong>工作模式</strong>：单线程运行，适用于单核处理器或客户端应用。</li><li><strong>应用场景</strong>：适合内存较小的应用程序，特别是那些对响应时间要求不高且资源有限的环境。</li><li><strong>优点</strong>：实现简单，对于小型应用程序非常有效。</li><li><strong>缺点</strong>：由于是单线程执行，在进行垃圾回收时会暂停所有其他的工作线程（Stop-The-World, STW），这会导致较长时间的停顿。</li></ul><p>启用参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC</span><br></pre></td></tr></table></figure><p><strong>2. Parallel 收集器（也称为 Throughput Collector）</strong></p><ul><li><strong>工作模式</strong>：多线程并行执行，适用于多核处理器环境下的服务器端应用。</li><li><strong>关注点</strong>：提高吞吐量，即减少垃圾回收时间占总运行时间的比例。</li><li><strong>年轻代</strong>：使用标记-复制算法。</li><li><strong>老年代</strong>：使用标记-整理算法。</li><li><strong>优点</strong>：通过并行处理提高了垃圾回收效率，减少了总的停顿时间。</li><li><strong>缺点</strong>：仍然会有较长的停顿时间，特别是在老年代垃圾回收期间。</li></ul><p>启用参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br></pre></td></tr></table></figure><p>为了优化老年代的收集性能，可以加上 <code>-XX:+UseParallelOldGC</code> 来启用老年代的并行压缩。</p><p><strong>3. CMS（Concurrent Mark Sweep）收集器</strong></p><ul><li><p><strong>工作模式</strong>：专注于减少停顿时间，尽可能地与应用程序并发执行大部分垃圾回收工作。</p></li><li><p>主要阶段</p><p>：</p><ul><li>初始标记（Initial Mark）</li><li>并发标记（Concurrent Mark）</li><li>再标记（Remark）</li><li>并发清除（Concurrent Sweep）</li></ul></li><li><p><strong>优点</strong>：尽量减少了应用程序的停顿时间。</p></li><li><p><strong>缺点</strong>：虽然减少了停顿时间，但增加了总体的CPU占用率；无法压缩内存，可能导致内存碎片化问题；在某些情况下可能会导致“Concurrent Mode Failure”。</p></li></ul><p>启用参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC</span><br></pre></td></tr></table></figure><p><strong>4. G1（Garbage First）收集器</strong></p><ul><li><p><strong>设计理念</strong>：旨在提供可预测的停顿时间和高吞吐量。G1 将堆划分为多个区域（Region），优先回收垃圾最多的区域。</p></li><li><p>主要特性</p><p>：</p><ul><li>可以设置最大停顿时间目标。</li><li>支持大堆内存管理，并能有效避免内存碎片。</li><li>在进行垃圾回收时，尝试同时清理年轻代和老年代。</li></ul></li><li><p><strong>优点</strong>：相比 CMS，G1 提供了更好的停顿时间控制，并减少了内存碎片的问题。</p></li><li><p><strong>缺点</strong>：配置相对复杂，可能需要更多的调优才能达到最佳效果。</p></li></ul><p>启用参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure><h3 id="CAS与原子类"><a href="#CAS与原子类" class="headerlink" title="CAS与原子类"></a>CAS与原子类</h3><p>CAS（Compare-And-Swap，比较并交换）是一种重要的原子操作机制，广泛应用于多线程并发控制中。它<strong>允许在不使用锁的情况下实现对共享数据的同步访问</strong>，从而<strong>避免了传统锁机制可能带来的性能瓶颈和死锁问题</strong>。CAS操作包含三个参数：内存位置V、预期原值A和新值B。只有当内存位置V的值等于预期原值A时，才会将内存位置V的值更新为新值B，并返回操作是否成功的布尔值；否则，不做任何操作</p><p>在 Java 中，<code>java.util.concurrent.atomic</code> 包提供了基于 CAS 的原子类，例如 <code>AtomicInteger</code>、<code>AtomicLong</code> 等。这些类内部使用了 <code>Unsafe</code> 类提供的底层 CAS 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger value = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>); <span class="comment">// 使用 AtomicInteger 实现 CAS</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加计数器的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> current, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            current = value.get(); <span class="comment">// 获取当前值</span></span><br><span class="line">            next = current + <span class="number">1</span>;    <span class="comment">// 计算下一个值</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (!value.compareAndSet(current, next)); <span class="comment">// 尝试 CAS 更新</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前计数器的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CASCounter counter = <span class="keyword">new</span> CASCounter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多个线程并发增加计数器</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                counter.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                counter.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待线程完成</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最终计数器的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Final counter value: &quot;</span> + counter.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h5><p>乐观锁（Optimistic Locking）和悲观锁（Pessimistic Locking）是两种处理并发控制的策略，它们在如何管理数据冲突方面采取了不同的方法。</p><p>乐观锁则假设不会发生并发冲突，因此不会主动加锁。它允许所有事务同时读取并尝试修改数据，但在提交更改前检查是否有其他事务已经修改了相同的数据。如果有，则拒绝此次修改或根据具体业务逻辑进行重试或其他处理。</p><p>悲观锁假设会发生并发冲突，因此在操作数据时会直接加锁，防止其他事务对该数据进行修改直到当前事务完成。</p><p><strong>使用悲观锁</strong>的方式可能是这样的：在处理订单时首先锁定库存记录，然后检查库存是否足够，若足够则扣减库存并提交事务释放锁；否则回滚事务并告知用户库存不足。</p><p><strong>使用乐观锁</strong>的方式则是：在开始处理订单时不加锁，而是记录下当前库存记录的版本号或时间戳。在准备扣减库存时再次检查版本号或时间戳是否未变，若未变则扣减库存并更新版本号/时间戳；若有变化则表明期间有其他订单已修改了库存，此时可以选择重试或通知用户稍后再试。</p><h5 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h5><ol><li>CAS 操作</li></ol><p>CAS（Compare-And-Swap）是实现原子操作的核心机制。它是一个低级别的、硬件提供的原子指令，通常用于无锁算法中。一个典型的 CAS 操作包含三个参数：</p><ul><li><strong>内存位置 V</strong>：要更新的数据在内存中的地址。</li><li><strong>预期值 A</strong>：期望在内存位置 V 处找到的值。</li><li><strong>新值 B</strong>：如果内存位置 V 的当前值等于预期值 A，则将该位置的值更新为新值 B。</li></ul><p>CAS 操作会检查内存位置 V 的当前值是否与预期值 A 相等。如果相等，则将内存位置 V 更新为新值 B，并返回成功；如果不相等，则不进行任何修改，并返回失败。这个过程是原子性的，意味着在同一时刻只能有一个线程成功执行 CAS 操作。</p><blockquote><p>传统的 <code>AtomicLong</code> (以及AtomicInteger等)使用 CAS（Compare-And-Swap）操作来保证线程安全，但在高并发情况下，多个线程同时竞争同一个值时，CAS 操作可能会频繁失败并重试，导致性能下降。</p><p><code>LongAdder</code> 的设计目标是解决这个问题。它通过<strong>分段锁</strong>的思想将数据分散到多个变量中，减少了线程间的竞争，从而提高了性能。最终结果可以通过这些变量汇总得到。</p></blockquote><ol><li>Java 内存模型 (JMM)</li></ol><p>Java 内存模型定义了多线程环境下变量的可见性和顺序性规则。为了保证线程间共享变量的一致性，Java 提供了 <code>volatile</code> 关键字和同步块 (<code>synchronized</code>) 来确保变量的可见性。原子类内部使用了类似的技术来确保线程间的可见性，即使它们自身并不总是需要显式的同步块。</p><ol><li>Unsafe 类</li></ol><p>Java 的原子类内部通常使用 <code>sun.misc.Unsafe</code> 类提供的本地方法来直接调用底层的 CAS 操作。虽然 <code>Unsafe</code> 类并不是官方推荐的 API，但它被广泛应用于高性能并发库中，如 <code>java.util.concurrent</code> 包内的实现。通过 <code>Unsafe</code>，开发者可以绕过 Java 的安全检查直接与操作系统交互，这使得它可以非常高效地执行 CAS 操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInt = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原子递增</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Initial value: &quot;</span> + atomicInt.get());</span><br><span class="line">        atomicInt.incrementAndGet(); <span class="comment">// 自增1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After increment: &quot;</span> + atomicInt.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原子更新</span></span><br><span class="line">        atomicInt.updateAndGet(x -&gt; x * <span class="number">2</span>); <span class="comment">// 使用函数式更新</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After update: &quot;</span> + atomicInt.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h3><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁的设计初衷是为了<strong>消除无竞争情况下的同步原语，进一步提高程序的运行性能</strong>。当一个线程访问同步块并获取锁时,<strong>会在对象头中记录当前线程的ID，表示该线程占有了这个对象的锁。</strong></p><p>当大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得时，使用偏向锁可以减少不必要的同步操作。</p><p>特性：当没有其他线程尝试获取同一个锁时，持有偏向锁的线程不需要进行同步操作。</p><p>如果有其他线程尝试获取偏向锁，则会发生偏向锁撤销，锁可能会升级为轻量级锁。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>Java 轻量级锁是 JVM 提供的一种优化机制，旨在<strong>减少多线程环境下获取锁的开销</strong>。它主要通过使用 CAS（Compare-And-Swap）操作来避免传统锁带来的性能损耗，<strong>适用于线程竞争较少的情况</strong>。轻量级锁是 Java 锁机制的一部分，它可以动态升级为重量级锁以应对更高的竞争情况。</p><ul><li>在线程交替执行同步块且存在轻微的竞争时，轻量级锁能够通过CAS（Compare-and-Swap）操作来避免线程阻塞和上下文切换。</li><li>特性<ul><li>每个线程都有自己的栈帧，其中包含用于存储锁的记录空间（Lock Record）。当线程试图获取轻量级锁时，会将对象头中的Mark Word复制到该线程的锁记录中，并尝试通过CAS操作将对象头指向该线程的锁记录。</li><li>若<strong>多个线程同时请求轻量级锁且自旋一定次数后仍未成功获取锁，则锁将膨胀为重量级锁</strong>。</li></ul></li></ul><h4 id="轻量级锁的工作原理"><a href="#轻量级锁的工作原理" class="headerlink" title="轻量级锁的工作原理"></a>轻量级锁的工作原理</h4><ol><li><strong>加锁过程</strong><ul><li>当一个线程尝试获取锁时，如果对象没有被锁定（锁标志位为“01”），JVM 会在当前线程的栈帧中创建一个称为 Lock Record 的空间，并<strong>将对象头中的 Mark Word 复制到这个 Lock Record 中</strong>。</li><li>然后，线程会尝试用 CAS 操作<strong>将对象头中的 Mark Word 更新为指向该线程 Lock Record 的指针</strong>。如果成功，则该线程获得了锁。</li><li>如果 CAS 操作失败，意味着另一个线程已经持有了锁，这时当前线程会自旋（忙等）一段时间，尝试重新获取锁。</li></ul></li><li><strong>解锁过程</strong><ul><li>当线程退出同步块时，会使用 CAS 操作尝试将对象头中的 Mark Word 恢复为其原始值（即从 Lock Record 中拷贝回来的 Displaced Mark Word）。</li><li>如果 CAS 操作成功，则表示没有其他线程尝试获取该锁，锁被成功释放。</li><li>如果 CAS 操作失败，说明有其他线程尝试获取过该锁，此时轻量级锁将会膨胀为重量级锁。</li></ul></li><li><strong>锁的升级</strong><ul><li>轻量级锁在遇到高竞争（即多个线程频繁尝试获取同一把锁）的情况下，可能会膨胀为重量级锁。这是因为持续的自旋等待会消耗大量的 CPU 资源。</li><li>一旦锁升级为重量级锁，后续试图获取锁的线程将进入阻塞状态，直到锁被释放。</li></ul></li><li><strong>适用场景</strong><ul><li>轻量级锁适用于线程竞争不激烈、锁占用时间较短的情况。在这种情况下，轻量级锁能够通过 CAS 操作和自旋来避免线程的阻塞和上下文切换，从而提高程序的并发性能。</li><li>对于锁竞争较为激烈的场景，建议使用 ReentrantLock 或者其他的高级同步机制，因为这些机制提供了更灵活的锁管理和更好的性能表现。</li></ul></li></ol><h4 id="重量锁"><a href="#重量锁" class="headerlink" title="重量锁"></a>重量锁</h4><p>重量级锁通过操作系统提供的互斥量（mutex）来实现线程间的同步，这种锁会让线程调用者进入阻塞状态，并被操作系统挂起。</p><p>在高竞争环境下，即多个线程频繁争夺同一资源时，重量级锁能够确保数据的一致性和完整性。</p><p>特性</p><ul><li>锁住的线程会被挂起直到锁被释放，此时其他等待的线程才有可能获取锁。</li><li>由于<strong>涉及用户态到内核态的切换以及线程的挂起和唤醒，重量级锁的开销较大</strong>。</li></ul><h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h4><p>锁膨胀（Lock Escalation）在Java中通常指的是synchronized关键字背后的锁机制随着竞争条件的变化而动态升级的过程。具体来说，在Java虚拟机（JVM）中，锁的状态可以经历从无锁状态到偏向锁、轻量级锁，最后到重量级锁的转变过程。这个过程称为锁膨胀或锁升级，并且它是一个单向的过程，即锁只能从低级别向高级别升级，不能降级。</p><p>锁膨胀的具体过程：</p><ol><li><strong>无锁状态</strong>：当对象刚创建时，没有线程尝试获取该对象上的锁，此时处于无锁状态。</li><li><strong>偏向锁状态</strong>：当第一个线程尝试获取对象上的锁时，JVM会将锁设置为偏向锁，并记录下持有偏向锁的线程ID。如果之后还是同一个线程访问，则不需要再次进行加锁操作，直接进入同步块执行代码。偏向锁的目标是减少无实际竞争情况下的锁获取成本。</li><li><strong>轻量级锁状态</strong>：如果有第二个线程尝试获取已经被偏向锁持有的对象的锁时，偏向锁会升级为轻量级锁。轻量级锁使用CAS（Compare and Swap）操作来尝试获取锁，以减少锁的竞争和系统的开销。轻量级锁适用于多个线程交替执行同步块的情况。</li><li><strong>重量级锁状态</strong>：当多个线程长时间竞争同一个对象的锁时，轻量级锁会升级为重量级锁。重量级锁采用操作系统的互斥量（Mutex）来实现，确保线程的安全性。在这种状态下，JVM会创建一个等待队列，将等待获取锁的线程挂起在队列中。重量级锁会导致较大的性能开销，因为它涉及到用户态与内核态之间的切换。</li></ol><p>锁膨胀的设计目的是为了优化多线程环境下的性能。通过这种方式，JVM可以根据不同的并发场景自动调整锁的状态，从而减少不必要的性能损耗。例如，在几乎没有竞争的情况下，偏向锁可以提供很好的性能；而在有少量竞争的情况下，轻量级锁可以通过自旋避免阻塞，提高效率；只有在高竞争的情况下，才会升级为重量级锁。这种机制使得synchronized在大多数情况下都能够高效运行。</p><h4 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h4><ol><li>减少上锁时间</li><li>减少锁的颗粒度  使用concurrentHashMap</li><li>锁粗化 多次循环进入同步块不如在同步块内进行循环</li><li>锁消除</li><li>读写分离</li></ol><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><p><strong>1. 继承 <code>Thread</code> 类</strong></p><p><strong>(1) 基本原理</strong></p><p>通过继承 <code>Thread</code> 类并重写 <code>run()</code> 方法，调用 <code>start()</code> 方法启动线程。</p><p><strong>(2) 示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread running: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread thread1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        MyThread thread2 = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">        thread1.start(); <span class="comment">// 启动线程</span></span><br><span class="line">        thread2.start(); <span class="comment">// 启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 优点</strong></p><ul><li>简单直观，易于理解。</li></ul><p><strong>(4) 缺点</strong></p><ul><li><p>Java 不支持多重继承，如果一个类已经继承了其他类，则无法再继承 <code>Thread</code>。</p><p><strong>2. 实现 <code>Runnable</code> 接口</strong></p></li></ul><p><strong>(1) 基本原理</strong></p><p>通过实现 <code>Runnable</code> 接口并实现 <code>run()</code> 方法，将 <code>Runnable</code> 对象传递给 <code>Thread</code> 构造器来启动线程。</p><p><strong>(2) 示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Runnable running: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line"></span><br><span class="line">        thread1.start(); <span class="comment">// 启动线程</span></span><br><span class="line">        thread2.start(); <span class="comment">// 启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 优点</strong></p><ul><li>更灵活：可以避免因为继承 <code>Thread</code> 而导致的多重继承问题。</li><li>适合资源共享（多个线程共享同一个 <code>Runnable</code> 实例）。</li></ul><p><strong>(4) 缺点</strong></p><ul><li>需要显式地将 <code>Runnable</code> 对象传递给 <code>Thread</code>。</li></ul><p><strong>3. 使用 <code>Callable</code> 和 <code>FutureTask</code></strong></p><p><strong>(1) 基本原理</strong></p><p><code>Callable</code> 接口类似于 <code>Runnable</code>，但<strong>它可以返回结果，并且可以抛出异常。<code>FutureTask</code> 是一个包装类，</strong>用于管理 <code>Callable</code> 的执行结果。</p><p><strong>(2) 示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Callable running: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>; <span class="comment">// 返回计算结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask1 = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyCallable());</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask2 = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyCallable());</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(futureTask1);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(futureTask2);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取线程执行结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Result from thread1: &quot;</span> + futureTask1.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;Result from thread2: &quot;</span> + futureTask2.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 优点</strong></p><ul><li>可以返回结果。</li><li>可以捕获线程中的异常。</li><li>适合需要获取线程执行结果的场景。</li></ul><p><strong>(4) 缺点</strong></p><ul><li>相比 <code>Runnable</code>，代码稍微复杂一些。</li></ul><p><strong>4. 使用线程池（推荐）</strong></p><p><strong>(1) 基本原理</strong></p><p>Java 提供了 <code>ExecutorService</code> 接口和 <code>Executors</code> 工厂类，用于管理和复用线程，避免频繁创建和销毁线程带来的开销。</p><p><strong>(2) 示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing task: &quot;</span> + name + <span class="string">&quot; in thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>); <span class="comment">// 创建固定大小的线程池</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            executor.submit(<span class="keyword">new</span> Task(<span class="string">&quot;Task-&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executor.shutdown(); <span class="comment">// 关闭线程池</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 优点</strong></p><ul><li>高效：线程池可以复用线程，减少线程创建和销毁的开销。</li><li>灵活：可以设置线程池大小、任务队列等。</li><li>易于管理：提供更高级的任务调度和生命周期管理功能。</li></ul><p><strong>(4) 缺点</strong></p><ul><li>初学者可能觉得使用线程池的 API 比较复杂。</li></ul><p><strong>5. 使用 Lambda 表达式（简化代码）</strong></p><p>从 Java 8 开始，可以使用 Lambda 表达式进一步简化线程的创建和使用。</p><p><strong>(1) 示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式实现 Runnable</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">            System.out.println(<span class="string">&quot;Lambda thread running: &quot;</span> + Thread.currentThread().getName())</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式提交任务到线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">        executor.submit(() -&gt; </span><br><span class="line">            System.out.println(<span class="string">&quot;Lambda task running: &quot;</span> + Thread.currentThread().getName())</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) 优点</strong></p><ul><li>简洁：减少了样板代码。</li><li>易读：代码更加紧凑。</li></ul><p><strong>6. 总结与选择建议</strong></p><div class="table-container"><table><thead><tr><th>方法</th><th>适用场景</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>继承 <code>Thread</code> 类</td><td>简单任务，快速验证</td><td>简单直观</td><td>不能多重继承</td></tr><tr><td>实现 <code>Runnable</code> 接口</td><td>多线程共享资源</td><td>灵活，避免多重继承限制</td><td>需要显式传递 <code>Runnable</code></td></tr><tr><td>使用 <code>Callable</code> 和 <code>FutureTask</code></td><td>需要返回结果或处理异常的任务</td><td>支持返回值和异常处理</td><td>代码稍微复杂</td></tr><tr><td>使用线程池</td><td>长时间运行的任务，或者需要高效管理线程的场景</td><td>高效，易于管理</td><td>API 较复杂</td></tr><tr><td>使用 Lambda 表达式</td><td>简化代码，尤其是在线程池中</td><td>代码简洁</td><td>依赖 Java 8+</td></tr></tbody></table></div><p><img data-src="https://s2.loli.net/2025/03/30/CYqToSF1d9ax7lA.png" alt="image-20250330162459693"></p><h4 id="Syncronized优化原理"><a href="#Syncronized优化原理" class="headerlink" title="Syncronized优化原理"></a>Syncronized优化原理</h4><p><code>synchronized</code> 的底层实现依赖于 JVM 提供的<strong>监视器锁（Monitor）\</strong>机制，而监视器锁最终映射到操作系统提供的*<em>互斥锁（Mutex Lock）*</em>。具体来说，<code>synchronized</code> 的工作原理分为以下几个阶段：</p><p><strong>(1) Monitor（监视器）</strong></p><ul><li>每个 Java 对象都有一个与之关联的监视器（Monitor），也称为“内置锁”或“监视器锁”。</li><li>监视器的作用是确保同一时刻只有一个线程能够持有该锁并执行同步代码。</li></ul><p><strong>(2) 对象头中的 Mark Word</strong></p><ul><li>在 HotSpot 虚拟机中，每个 Java 对象都有一个对象头（Object Header），其中包含一个 <code>Mark Word</code>。</li><li><code>Mark Word</code> 用来存储对象的元信息，例如哈希码、GC 分代年龄、锁状态等。</li><li>当线程尝试获取锁时，<code>Mark Word</code> 的内容会动态变化，表示锁的状态（无锁、偏向锁、轻量级锁、重量级锁）。</li></ul><p><strong>(3) 锁的升级机制</strong></p><p>为了优化性能，<code>synchronized</code> 实现了锁的升级机制，从低开销的锁逐步升级到高开销的锁。锁的升级过程如下：</p><ol><li><strong>无锁状态</strong>：<ul><li>初始状态下，对象没有被任何线程锁定。</li></ul></li><li><strong>偏向锁（Biased Locking）</strong>：<ul><li>如果某个线程多次进入同步代码块，JVM 会将锁偏向于该线程。</li><li>偏向锁通过在 <code>Mark Word</code> 中记录线程 ID 来实现，避免每次加锁和解锁都需要 CAS（Compare-And-Swap）操作。</li><li>偏向锁适用于单线程访问同步代码块的场景。</li></ul></li><li><strong>轻量级锁（Lightweight Locking）</strong>：<ul><li>当有多个线程竞争同一个锁时，偏向锁会升级为轻量级锁。</li><li>轻量级锁使用自旋的方式尝试获取锁，减少线程上下文切换的开销。</li><li>如果自旋成功，则直接获取锁；如果自旋失败，则升级为重量级锁。</li></ul></li><li><strong>重量级锁（Heavyweight Locking）</strong>：<ul><li>当竞争激烈时，轻量级锁会升级为重量级锁。</li><li>重量级锁依赖于操作系统的互斥锁（Mutex Lock），会导致线程阻塞和唤醒，开销较大。</li></ul></li></ol><p><strong>(4) 锁的释放</strong></p><ul><li>当线程退出同步代码块时，会释放锁。</li><li>JVM 会根据锁的状态（偏向锁、轻量级锁、重量级锁）进行相应的处理，恢复对象头的 <code>Mark Word</code> 状态。</li></ul><div class="table-container"><table><thead><tr><th>特性</th><th><code>synchronized</code></th><th><code>ReentrantLock</code></th></tr></thead><tbody><tr><td><strong>实现方式</strong></td><td>JVM 内置关键字</td><td>显式锁，API 实现</td></tr><tr><td><strong>锁优化</strong></td><td>支持偏向锁、轻量级锁</td><td>不支持</td></tr><tr><td><strong>公平性</strong></td><td>非公平锁</td><td>支持公平锁</td></tr><tr><td><strong>可中断性</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>超时机制</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>条件变量</strong></td><td>不支持</td><td>支持（通过 <code>Condition</code>）</td></tr></tbody></table></div><p><img data-src="https://s2.loli.net/2025/03/30/8PW4irnVQOo1U7M.png" alt="image-20250330171150577"></p><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p><code>ReentrantLock</code> 是 Java 提供的一种可重入的互斥锁，它位于 <code>java.util.concurrent.locks</code> 包中，是 <code>Lock</code> 接口的一个实现类。相比于 <code>synchronized</code> 关键字，<code>ReentrantLock</code> 提供了更灵活、更强大的锁机制，适用于复杂的并发场景。</p><p>可重入锁（Reentrant Lock） 指的是一个线程可以多次获取同一个锁而不被自己阻塞。这意味着如果一个线程已经持有了某个锁，并尝试再次获取该锁，则该操作会成功，而不是导致死锁。每次获取锁时，锁内部的计数器会增加；每次释放锁时，计数器会减少；只有当计数器归零时，锁才会真正被释放，允许其他线程获取。</p><h5 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行一些操作</span></span><br><span class="line">            secondMethod();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">secondMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行更多操作</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h5><p>“可打断”（Interruptible）指的是线程在<strong>等待某种资源或处于阻塞状态时,是否能够响应中断请求并进行相应的处理</strong>.当一个线程处于不可打断的状态下（如通过某些同步机制等待获取锁）,它将不会响应中断信号；而在可打断状态下,线程可以捕获到中断请求,并根据应用逻辑决定如何处理这个中断.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptibleLockExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is trying to acquire the lock.&quot;</span>);</span><br><span class="line">            <span class="comment">// 尝试获取锁，但是可以响应中断</span></span><br><span class="line">            lock.lockInterruptibly();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; has acquired the lock.&quot;</span>);</span><br><span class="line">                <span class="comment">// 模拟任务处理</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; was interrupted while waiting for the lock.&quot;</span>);</span><br><span class="line">            <span class="comment">// 处理中断，通常这里需要做一些清理工作</span></span><br><span class="line">            Thread.currentThread().interrupt(); <span class="comment">// 重新设置中断标志</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        InterruptibleLockExample example = <span class="keyword">new</span> InterruptibleLockExample();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                example.performTask();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Worker-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 让 t1 先开始尝试获取锁</span></span><br><span class="line">                example.performTask();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Worker-2&quot;</span>);</span><br><span class="line"></span><br><span class="line">       t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 主线程等待一段时间后中断 t2</span></span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="尝试获取锁"><a href="#尝试获取锁" class="headerlink" title="尝试获取锁"></a>尝试获取锁</h5><ul><li><code>boolean tryLock()</code><ul><li>尝试获取锁。如果锁可用，则立即获取并返回 <code>true</code>；否则返回 <code>false</code>。</li></ul></li><li><code>boolean tryLock(long timeout, TimeUnit unit)</code><ul><li>尝试在指定时间内获取锁。如果在超时前获取到锁，则返回 <code>true</code>；否则返回 <code>false</code>。</li></ul></li></ul><h5 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h5><p><code>ReentrantLock</code> <strong>默认是非公平锁</strong>。也就是说，当多个线程竞争锁时，默认情况下新来的线程可能会直接插队获取锁，而不需要严格按照线程等待的顺序（FIFO 队列）来分配锁。</p><p><strong>公平锁与非公平锁的区别</strong></p><ol><li><strong>公平锁（Fair Lock）</strong><ul><li>公平锁会按照线程请求锁的顺序（即 FIFO 队列）来分配锁。</li><li>这种方式可以避免线程饥饿问题，但可能会导致性能下降，因为线程切换的开销较高。</li></ul></li><li><strong>非公平锁（Non-Fair Lock）</strong><ul><li>非公平锁允许插队，即新来的线程可以直接尝试获取锁，而不需要排队。</li><li>这种方式减少了线程上下文切换的开销，提高了吞吐量，但在高并发场景下可能导致某些线程长时间无法获取锁（饥饿问题）。</li></ul></li></ol><h5 id="与条件变量"><a href="#与条件变量" class="headerlink" title="与条件变量"></a>与条件变量</h5><p>在并发编程中，条件变量是一种用于线程间协调的机制。它允许一个或多个线程等待某个条件变为真，而不是忙等（busy-waiting）。在Java中，<code>Condition</code> 接口由 <code>ReentrantLock</code> 类提供支持，<strong>每个 <code>ReentrantLock</code> 可以创建多个 <code>Condition</code> 实例，从而实现更加灵活的线程控制</strong>。</p><p><code>Condition</code> 接口的主要方法</p><ul><li><strong>await()</strong>：使当前线程等待，并释放锁。直到其他线程调用 <code>signal()</code> 或 <code>signalAll()</code> 方法唤醒它。</li><li><strong>signal()</strong>：唤醒一个等待该条件的线程。如果有多个线程在等待，则选择其中的一个。</li><li><strong>signalAll()</strong>：唤醒所有等待该条件的线程。</li><li><strong>awaitUninterruptibly()</strong>：类似于 <code>await()</code>，但是不会响应中断。</li><li><strong>awaitNanos(long nanosTimeout)</strong>、<strong>awaitUntil(Date deadline)</strong>：带超时的等待方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] buffer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProducerConsumerExample</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buffer = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == buffer.length) &#123; <span class="comment">// Buffer is full</span></span><br><span class="line">                notFull.await(); <span class="comment">// Wait until buffer is not full</span></span><br><span class="line">            &#125;</span><br><span class="line">            buffer[count] = value;</span><br><span class="line">            count++;</span><br><span class="line">            notEmpty.signal(); <span class="comment">// Signal that buffer is not empty now</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123; <span class="comment">// Buffer is empty</span></span><br><span class="line">                notEmpty.await(); <span class="comment">// Wait until buffer is not empty</span></span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">int</span> value = buffer[count];</span><br><span class="line">            notFull.signal(); <span class="comment">// Signal that buffer is not full now</span></span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumerExample example = <span class="keyword">new</span> ProducerConsumerExample(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        Runnable producerTask = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    example.produce(i);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Produced: &quot;</span> + i);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable consumerTask = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> value = example.consume();</span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumed: &quot;</span> + value);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(producerTask).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumerTask).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h4><p><code>volatile</code> 是 Java 中的一个关键字，用于修饰变量，它提供了一种<strong>比锁更轻量级的同步机制</strong>。尽管 <code>volatile</code> 并不能替代 synchronized 关键字所提供的所有功能，但在某些特定场景下，它可以有效地保证线程间的可见性和有序性。</p><p><strong>工作原理</strong></p><ol><li><strong>可见性</strong>：<strong>当一个线程对一个 <code>volatile</code> 变量进行写操作时，会将该变量立即刷新到主内存中</strong>。而当其他线程读取这个 <code>volatile</code> 变量时，它们会被强制从主内存中重新读取这个变量的最新值，而不是使用自己工作内存中的缓存副本。这就确保了所有线程都能看到最新的变量值。</li><li><strong>禁止指令重排序优化</strong>：Java 编译器和处理器可以对指令进行重排序以提高执行效率。然而，这种重排序可能会导致多线程环境下的程序出现意料之外的行为。<code>volatile</code> 变量可以防止编译器对涉及该变量的操作进行指令重排序，从而保持代码的预期执行顺序。</li></ol><p>虽然 <code>volatile</code> 和原子类（如 <code>AtomicInteger</code>）都提供了线程安全的操作，但它们之间存在一些关键差异：</p><ul><li><strong>原子性</strong>：<code>volatile</code> 只能保证变量的可见性和有序性，不能保证复合操作（比如增加、减少）的原子性。而原子类通过使用 CAS（比较并交换）等硬件级别的原子操作来保证操作的原子性。</li><li><strong>性能</strong>：由于 <code>volatile</code> 不需要像锁那样复杂的开销，因此在只涉及简单状态更新的情况下，它的性能通常优于基于锁的解决方案。但是，在需要进行复杂的状态转换或需要保证原子性的场景下，原子类可能是更好的选择。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlagExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread is waiting for the flag to be set.&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                <span class="comment">// 等待直到flag被设置为true</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Flag has been set, thread is proceeding.&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程暂停一段时间</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置标志位</span></span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Flag has been set by main thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>volatile</code> 适用于以下场景：</p><ul><li>变量的写入不依赖于其当前值。</li><li>变量不需要与其他状态变量共同参与不变约束。</li><li>对变量的访问都是原子操作（例如，简单的布尔标志）。</li></ul><h4 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> coreSize; <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeoutUnit;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> coreSize, <span class="keyword">long</span> timeout, TimeUnit timeoutUnit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">        <span class="keyword">this</span>.timeoutUnit = timeoutUnit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">            <span class="keyword">if</span>(workers.size()&lt;coreSize) &#123;</span><br><span class="line">                Worker worker = <span class="keyword">new</span> Worker(task);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                taskQueue.put(task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//1) task不为空</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.task != <span class="keyword">null</span> ||(task = taskQueue.take()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">                workers.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockingQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition notEmptyWaitSet = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition emptyWaitSet = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                notEmptyWaitSet.await();</span><br><span class="line">            &#125;</span><br><span class="line">            T t = queue.removeFirst();</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.addLast(t);</span><br><span class="line">            notEmptyWaitSet.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">           <span class="keyword">while</span>(queue.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   nanos = notEmptyWaitSet.awaitNanos(nanos);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           T t = queue.removeFirst();</span><br><span class="line">              emptyWaitSet.signal();</span><br><span class="line">              <span class="keyword">return</span> t;</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用JDK提供的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 核心线程数</span></span><br><span class="line">        <span class="keyword">int</span> corePoolSize = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 最大线程数</span></span><br><span class="line">        <span class="keyword">int</span> maximumPoolSize = <span class="number">4</span>;</span><br><span class="line">        <span class="comment">// 空闲线程存活时间</span></span><br><span class="line">        <span class="keyword">long</span> keepAliveTime = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 时间单位</span></span><br><span class="line">        TimeUnit unit = TimeUnit.SECONDS;</span><br><span class="line">        <span class="comment">// 任务队列</span></span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 线程工厂</span></span><br><span class="line">        ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br><span class="line">        <span class="comment">// 拒绝策略</span></span><br><span class="line">        RejectedExecutionHandler handler = <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            corePoolSize,</span><br><span class="line">            maximumPoolSize,</span><br><span class="line">            keepAliveTime,</span><br><span class="line">            unit,</span><br><span class="line">            workQueue,</span><br><span class="line">            threadFactory,</span><br><span class="line">            handler</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> taskId = i;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; is running on thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务执行</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">               <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(), <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           Future&lt;Integer&gt; submit = threadPoolExecutor.submit(<span class="keyword">new</span> MyCallable());</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               System.out.println(submit.get());</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/30/Y9PDFgfRLC8Bdp6.png" alt="image-20250330221744556"></p><ol><li><strong>corePoolSize</strong>：<ul><li>核心线程数，即线程池中始终保持的最小线程数量。</li><li>即使这些线程处于空闲状态，也不会被销毁（除非设置了 <code>allowCoreThreadTimeOut</code>）。</li></ul></li><li><strong>maximumPoolSize</strong>：<ul><li>线程池允许的最大线程数。</li><li>当任务队列已满且当前线程数小于 <code>maximumPoolSize</code> 时，线程池会创建新线程来处理任务。</li></ul></li><li><strong>keepAliveTime</strong>：<ul><li>空闲线程的存活时间。</li><li>如果线程数超过 <code>corePoolSize</code>，多余的空闲线程会在空闲一段时间后被回收。</li></ul></li><li><strong>unit</strong>：<ul><li><code>keepAliveTime</code> 的时间单位，例如 <code>TimeUnit.SECONDS</code>。</li></ul></li><li><strong>workQueue</strong>：<ul><li>任务队列，用于保存等待执行的任务。</li><li>常见实现包括：<ul><li><code>ArrayBlockingQueue</code>：有界队列。</li><li><code>LinkedBlockingQueue</code>：无界队列。</li><li><code>SynchronousQueue</code>：不存储任务，直接交给线程执行。</li></ul></li></ul></li><li><strong>threadFactory</strong>：<ul><li>创建线程的工厂，用于自定义线程的名称、优先级等属性。</li><li>默认使用 <code>Executors.defaultThreadFactory()</code>。</li></ul></li><li><strong>handler</strong>：<ul><li>拒绝策略，当线程池无法处理新任务时（例如线程池已满且任务队列已满），会调用此策略。</li><li>常见实现包括：<ul><li><code>AbortPolicy</code>：抛出 <code>RejectedExecutionException</code> 异常。</li><li><code>CallerRunsPolicy</code>：由调用线程（提交任务的线程）执行该任务。</li><li><code>DiscardPolicy</code>：直接丢弃任务。</li><li><code>DiscardOldestPolicy</code>：丢弃队列中最旧的任务，然后尝试重新提交新任务。</li></ul></li></ul></li></ol><p><strong>3. 线程池的工作原理</strong></p><ol><li><strong>任务提交</strong>：<ul><li>当一个任务被提交到线程池时，线程池会根据当前线程数和任务队列的状态决定如何处理任务。</li></ul></li><li><strong>任务分配逻辑</strong>：<ul><li>如果当前线程数小于 <code>corePoolSize</code>，即使有空闲线程，也会创建新线程来执行任务。</li><li>如果当前线程数等于或大于 <code>corePoolSize</code>，任务会被放入任务队列中等待。</li><li>如果任务队列已满且当前线程数小于 <code>maximumPoolSize</code>，线程池会创建新线程来执行任务。</li><li>如果任务队列已满且当前线程数等于 <code>maximumPoolSize</code>，则触发拒绝策略。</li></ul></li><li><strong>线程回收</strong>：<ul><li>如果线程数超过 <code>corePoolSize</code>，多余的空闲线程会在空闲一段时间（<code>keepAliveTime</code>）后被回收</li></ul></li></ol><h5 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h5><ol><li>创建固定大小的线程池 - <code>newFixedThreadPool</code></li></ol><p>该方法返回一个固定大小的线程池，适用于需要限制并发线程数的场景。</p><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadPoolExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小为3的线程池</span></span><br><span class="line">        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> taskId = i;</span><br><span class="line">            fixedThreadPool.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; is running on thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        fixedThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>线程池中的线程数量是固定的。</li><li>如果所有线程都在忙，新的任务将等待直到有空闲线程可用。</li></ul><ol><li>创建单线程化的线程池 - <code>newSingleThreadExecutor</code></li></ol><p>该方法返回一个只有一个工作线程的线程池，适用于需要保证顺序执行任务的场景。</p><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadExecutorExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个单线程化的线程池</span></span><br><span class="line">        ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> taskId = i;</span><br><span class="line">            singleThreadExecutor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; is running on thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        singleThreadExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>所有提交的任务按照提交顺序依次执行。</li><li>即使发生故障，也会重新创建一个线程来替代原来的线程继续处理后续任务。</li></ul><ol><li>创建一个会根据需要创建新线程的线程池 - <code>newCachedThreadPool</code></li></ol><p>该方法返回一个可根据需要创建新线程的线程池，适用于执行大量短期异步任务的场景。</p><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPoolExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个缓存线程池</span></span><br><span class="line">        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> taskId = i;</span><br><span class="line">            cachedThreadPool.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; is running on thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        cachedThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>线程池可以根据需要创建新线程，并在空闲60秒后回收未使用的线程。</li><li>适合执行大量短期异步任务的应用程序。</li></ul><ol><li>创建支持定时及周期性任务执行的线程池 - <code>newScheduledThreadPool</code></li></ol><p>该方法返回一个支持定时和周期性任务执行的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个支持定时及周期性任务执行的线程池</span></span><br><span class="line">        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定时执行任务，延迟2秒后执行</span></span><br><span class="line">        scheduledThreadPool.schedule(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;This task is run after a delay of 2 seconds&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 周期性执行任务，初始延迟2秒后开始执行，之后每隔3秒执行一次</span></span><br><span class="line">        scheduledThreadPool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;This task is run periodically every 3 seconds&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记得关闭线程池</span></span><br><span class="line">        <span class="comment">// scheduledThreadPool.shutdown(); 在实际应用中，可能需要在适当的时候调用shutdown()来关闭线程池</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>支持延迟执行任务或周期性执行任务。</li><li><code>schedule()</code> 方法用于一次性延迟执行任务。</li><li><code>scheduleAtFixedRate()</code> 方法用于周期性执行任务。</li></ul><ol><li>使用自定义线程工厂</li></ol><p>你可以通过提供自定义的 <code>ThreadFactory</code> 来定制线程的创建过程，比如设置线程名称、优先级等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomThreadFactoryExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadFactory customThreadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">&quot;CustomThread-&quot;</span> + System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>, customThreadFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> taskId = i;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; is running on thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义线程工厂允许更灵活地控制线程的创建过程。</p><p><img data-src="https://s2.loli.net/2025/03/30/Uqb7n83iNwsRuoB.png" alt="image-20250330223813273"></p><p><strong>线程池关闭方法</strong></p><ol><li><code>shutdown()</code></li></ol><ul><li><strong>描述</strong>：该方法不会立即强制关闭线程池，而是<strong>首先停止接收新的任务，并尝试完成已经提交的任务</strong>。</li><li>行为<ul><li>已经提交到线程池中的任务将继续执行直至完成。</li><li>此方法调用后，如果尝试向线程池提交新任务，则会根据线程池的拒绝策略处理（通常是抛出 <code>RejectedExecutionException</code>）。</li></ul></li></ul><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> taskId = i;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; is running on thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Shutting down the executor...&quot;</span>);</span><br><span class="line">        executor.shutdown(); <span class="comment">// 发出关闭信号</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有任务完成</span></span><br><span class="line">        <span class="keyword">if</span> (!executor.awaitTermination(<span class="number">60</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Some tasks are still running&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;All tasks finished.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>shutdownNow()</code></li></ol><ul><li><strong>描述</strong>：尝试<strong>立即停止所有正在执行的任务，并暂停处理等待的任务</strong>。</li><li>行为<ul><li>它试图终止所有正在执行的任务，并返回一个等待执行的任务列表。</li><li>并不能保证能够立即停止正在执行的任务，因为任务可能无法响应中断。</li></ul></li></ul><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownNowExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> taskId = i;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; is running on thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; was interrupted.&quot;</span>);</span><br><span class="line">                    Thread.currentThread().interrupt(); <span class="comment">// 重新设置中断状态</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Attempting to shutdown the executor now...&quot;</span>);</span><br><span class="line">        List&lt;Runnable&gt; notExecutedTasks = executor.shutdownNow(); <span class="comment">// 尝试立即关闭</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Number of tasks that will not be executed: &quot;</span> + notExecutedTasks.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>awaitTermination(long timeout, TimeUnit unit)</code></li></ol><ul><li><strong>描述</strong>：阻塞当前线程直到线程池中的所有任务都已完成执行，或者超时发生，或者当前线程被中断。</li><li>行为<ul><li>通常与 <code>shutdown()</code> 方法一起使用，以确保所有任务都在程序退出之前完成。</li><li>返回值为 <code>true</code> 表示所有任务都已经完成；返回 <code>false</code> 则表示由于超时而未完成。</li></ul></li></ul><p>可以通过调用 <code>isShutdown()</code> 方法来检查线程池是否已经被标记为关闭。此外，<code>isTerminated()</code> 可用于判断线程池是否已经完全终止（即所有任务都已完成）</p><h4 id="线程安全集合类"><a href="#线程安全集合类" class="headerlink" title="线程安全集合类"></a>线程安全集合类</h4><p>线程安全的集合类是用于在多线程环境中安全地存储和操作数据的工具。这些集合类通过<strong>内部的同步机制</strong>或<strong>无锁算法（如 CAS）</strong>来保证线程安全。</p><p><img data-src="https://s2.loli.net/2025/03/30/cBvlUxGDnWa84Yp.png" alt="image-20250330225400344"></p><h5 id="Vector-和-Hashtable"><a href="#Vector-和-Hashtable" class="headerlink" title="Vector 和 Hashtable"></a><code>Vector</code> 和 <code>Hashtable</code></h5><p>这两个类是早期 Java 提供的线程安全集合类，但现在已被更高效的替代品取代。</p><p><strong><code>Vector</code></strong></p><ul><li>线程安全的动态数组，类似于 <code>ArrayList</code>，但所有操作都通过 <code>synchronized</code> 加锁。</li><li>性能较低，推荐使用 <code>CopyOnWriteArrayList</code> 或 <code>Collections.synchronizedList()</code> 替代。</li></ul><p><strong><code>Hashtable</code></strong></p><ul><li>线程安全的哈希表，类似于 <code>HashMap</code>，但所有操作都通过 <code>synchronized</code> 加锁。</li><li>推荐使用 <code>ConcurrentHashMap</code> 替代。</li></ul><h5 id="同步包装类（Collections-synchronizedXxx-方法）"><a href="#同步包装类（Collections-synchronizedXxx-方法）" class="headerlink" title="同步包装类（Collections.synchronizedXxx() 方法）"></a>同步包装类（<code>Collections.synchronizedXxx()</code> 方法）</h5><p>Java 的 <code>Collections</code> 类提供了一组静态方法，可以将普通的非线程安全集合包装成线程安全的集合。</p><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedCollectionsExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个线程安全的 ArrayList</span></span><br><span class="line">        List&lt;String&gt; synchronizedList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个线程安全的 HashMap</span></span><br><span class="line">        Map&lt;String, String&gt; synchronizedMap = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用时仍需手动加锁以保证复合操作的线程安全</span></span><br><span class="line">        <span class="keyword">synchronized</span> (synchronizedList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!synchronizedList.isEmpty()) &#123;</span><br><span class="line">                synchronizedList.remove(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点</p><ul><li>内部通过 <code>synchronized</code> 关键字实现同步。</li><li>简单易用，但性能较差，因为所有操作都需要竞争同一把锁。</li><li>复合操作（如迭代、条件检查等）需要外部手动加锁。</li></ul><h5 id="Concurrent-系列集合"><a href="#Concurrent-系列集合" class="headerlink" title="Concurrent 系列集合"></a><code>Concurrent</code> 系列集合</h5><p><code>java.util.concurrent</code> 包中提供了多个高性能的线程安全集合类，它们基于分段锁（Segment Lock）或其他无锁算法（如 CAS），性能优于传统的同步集合。</p><p><strong>常用类</strong></p><ul><li><strong><code>ConcurrentHashMap</code></strong>：<ul><li>线程安全的 <code>Map</code> 实现。</li><li>支持高并发访问，性能优于 <code>Hashtable</code>。</li><li>内部通过分段锁或 CAS 操作实现线程安全。</li></ul></li><li><strong><code>ConcurrentSkipListMap</code></strong>：<ul><li>线程安全的有序 <code>Map</code> 实现。</li><li>基于跳表（Skip List）实现。</li></ul></li><li><strong><code>ConcurrentSkipListSet</code></strong>：<ul><li>线程安全的有序 <code>Set</code> 实现。</li></ul></li><li><strong><code>ConcurrentLinkedQueue</code></strong>：<ul><li>线程安全的无界非阻塞队列。</li><li>基于链表实现，支持高并发。</li></ul></li><li><strong><code>ConcurrentLinkedDeque</code></strong>：<ul><li>线程安全的双端队列。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMapExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        map.put(<span class="string">&quot;A&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;B&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;A&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原子操作</span></span><br><span class="line">        map.computeIfAbsent(<span class="string">&quot;C&quot;</span>, key -&gt; <span class="number">3</span>); <span class="comment">// 如果不存在则添加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点</p><ul><li>高性能，支持高并发。</li><li>提供了丰富的原子操作（如 <code>computeIfAbsent</code>、<code>merge</code> 等）。</li><li>适用于高并发场景。</li></ul><h5 id="阻塞队列（Blocking-Queue）"><a href="#阻塞队列（Blocking-Queue）" class="headerlink" title="阻塞队列（Blocking Queue）"></a>阻塞队列（Blocking Queue）</h5><p>阻塞队列是线程安全的队列，当队列为空或满时，会阻塞线程直到满足条件。</p><p><strong>常用类</strong></p><ul><li><strong><code>ArrayBlockingQueue</code></strong>：<ul><li>有界阻塞队列，基于数组实现。</li><li>需要指定容量。</li></ul></li><li><strong><code>LinkedBlockingQueue</code></strong>：<ul><li>无界或有界阻塞队列，基于链表实现。</li><li>默认情况下是无界的（容量为 <code>Integer.MAX_VALUE</code>）。</li></ul></li><li><strong><code>PriorityBlockingQueue</code></strong>：<ul><li>线程安全的优先级队列。</li><li>元素按优先级排序。</li></ul></li><li><strong><code>SynchronousQueue</code></strong>：<ul><li>不存储元素的阻塞队列。</li><li>每次插入操作必须等待一个对应的移除操作。</li></ul></li><li><strong><code>DelayQueue</code></strong>：<ul><li>用于延迟处理元素的阻塞队列。</li><li>元素只有在延迟时间到期后才能被取出。</li></ul></li></ul><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        Thread producer = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                queue.put(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                queue.put(<span class="string">&quot;C&quot;</span>); <span class="comment">// 队列满时阻塞</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        Thread consumer = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(queue.take());</span><br><span class="line">                System.out.println(queue.take());</span><br><span class="line">                System.out.println(queue.take()); <span class="comment">// 队列空时阻塞</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        producer.join();</span><br><span class="line">        consumer.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong></p><ul><li>适用于生产者-消费者模型。</li><li>提供了阻塞操作（如 <code>put</code> 和 <code>take</code>）。</li><li>可以控制队列的容量。</li></ul><h5 id="CopyOnWrite-系列集合"><a href="#CopyOnWrite-系列集合" class="headerlink" title="CopyOnWrite 系列集合"></a><code>CopyOnWrite</code> 系列集合</h5><p><code>CopyOnWrite</code> 系列集合适用于读多写少的场景，其核心思想是：每次修改时复制一份新的数据副本，从而避免读写冲突。</p><p><strong>常用类</strong></p><ul><li><strong><code>CopyOnWriteArrayList</code></strong>：<ul><li>线程安全的 <code>List</code> 实现。</li><li>适用于读操作远多于写操作的场景。</li></ul></li><li><strong><code>CopyOnWriteArraySet</code></strong>：<ul><li>基于 <code>CopyOnWriteArrayList</code> 实现的线程安全 <code>Set</code>。</li></ul></li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayListExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历（无需额外加锁）</span></span><br><span class="line">        <span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点</p><ul><li>修改操作（如 <code>add</code>、<code>remove</code>）会创建数据副本，因此写操作成本较高。</li><li>读操作不需要加锁，性能高。</li><li>不适合频繁写入的场景。</li></ul><div class="table-container"><table><thead><tr><th>集合类型</th><th>场景</th><th>特点</th></tr></thead><tbody><tr><td><code>Collections.synchronizedXxx()</code></td><td>简单线程安全需求</td><td>所有操作加锁，性能较低</td></tr><tr><td><code>Vector</code> / <code>Hashtable</code></td><td>兼容旧代码</td><td>过时，不推荐</td></tr><tr><td><code>CopyOnWriteArrayList</code></td><td>读多写少</td><td>写操作成本高，读操作无需加锁</td></tr><tr><td><code>ConcurrentHashMap</code></td><td>高并发场景</td><td>高性能，支持原子操作</td></tr><tr><td>阻塞队列（如 <code>ArrayBlockingQueue</code>）</td><td>生产者-消费者模型</td><td>提供阻塞操作，支持容量控制</td></tr></tbody></table></div><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h4 id="HashMap并发死链问题"><a href="#HashMap并发死链问题" class="headerlink" title="HashMap并发死链问题"></a>HashMap并发死链问题</h4><p><code>HashMap</code> 的底层实现是一个数组（桶）和链表/红黑树的结合。当发生哈希冲突时，多个键值对会被存储在同一个桶中，形成链表或红黑树。在多线程环境下，如果多个线程同时对 <code>HashMap</code> 进行写操作（如扩容或插入），可能会破坏链表的结构，导致链表形成环状结构（即死链）。</p><p><strong>具体原因：</strong></p><ul><li>扩容时的并发问题<ul><li>当 <code>HashMap</code> 的容量不足时，会触发扩容操作（<code>resize()</code> 方法），将旧数组中的元素重新分配到新数组中。</li><li>在多线程环境下，多个线程可能同时执行扩容操作，导致链表节点被错误地连接，形成环形链表。</li></ul></li><li>链表插入时的并发问题<ul><li>多个线程同时插入元素时，可能会导致链表节点的指针被错误地修改，从而形成环形链表。</li></ul></li></ul><p>一旦链表形成了环形结构，后续的读操作（如 <code>get()</code>）会在遍历链表时陷入无限循环。</p><p>为了避免 <code>HashMap</code> 的并发死链问题，可以采取以下几种解决方案：</p><p><strong>(1) 使用线程安全的集合类</strong></p><ul><li>使用ConcurrentHashMap替代HashMap<ul><li><code>ConcurrentHashMap</code> 是专门为多线程环境设计的线程安全集合类。</li><li>它通过分段锁（Segment Lock）或 CAS 操作来保证线程安全，避免了死链问题。</li></ul></li></ul><p><strong>(2) 手动加锁</strong></p><ul><li>如果必须使用 <code>HashMap</code>，可以通过 <code>synchronized</code> 或显式锁（如 <code>ReentrantLock</code>）来保护对其的修改操作。</li></ul><p><strong>(3) 使用 <code>Collections.synchronizedMap()</code> 包装</strong></p><ul><li>将 <code>HashMap</code> 包装成线程安全的集合。</li></ul><h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><h2 id="Maven✨"><a href="#Maven✨" class="headerlink" title="Maven✨"></a>Maven✨</h2><p><a href="https://maven.apache.org/guides/getting-started/index.html">Maven Getting Started Guide – Maven</a></p><p><a href="https://www.runoob.com/maven/maven-tutorial.html">Maven 教程 | 菜鸟教程</a></p><p><a href="https://www.bilibili.com/video/BV1Ah411S7ZE/?spm_id_from=333.337.search-card.all.click&amp;vd_source=177ef88aa6608bc3652c72d71b0aa098">黑马程序员Maven全套教程，maven项目管理从基础到高级，Java项目开发必会管理工具maven_哔哩哔哩_bilibili</a></p><blockquote><p>项目中源码目录,资源文件夹目录等都是maven设置的</p></blockquote><p>Maven 提倡使用一个共同的标准目录结构，Maven 使用约定优于配置的原则，大家尽可能的遵守这样的目录结构。如下所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">目录</th><th style="text-align:left">目的</th></tr></thead><tbody><tr><td style="text-align:left">${basedir}</td><td style="text-align:left">存放pom.xml和所有的子目录</td></tr><tr><td style="text-align:left">${basedir}/src/main/java</td><td style="text-align:left">项目的java源代码</td></tr><tr><td style="text-align:left">${basedir}/src/main/resources</td><td style="text-align:left">项目的资源，比如说property文件，springmvc.xml</td></tr><tr><td style="text-align:left">${basedir}/src/test/java</td><td style="text-align:left">项目的测试类，比如说Junit代码</td></tr><tr><td style="text-align:left">${basedir}/src/test/resources</td><td style="text-align:left">测试用的资源</td></tr><tr><td style="text-align:left">${basedir}/src/main/webapp/WEB-INF</td><td style="text-align:left">web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面</td></tr><tr><td style="text-align:left">${basedir}/target</td><td style="text-align:left">打包输出目录</td></tr><tr><td style="text-align:left">${basedir}/target/classes</td><td style="text-align:left">编译输出目录</td></tr><tr><td style="text-align:left">${basedir}/target/test-classes</td><td style="text-align:left">测试编译输出目录</td></tr><tr><td style="text-align:left">Test.java</td><td style="text-align:left">Maven只会自动运行符合该命名规则的测试类</td></tr><tr><td style="text-align:left">~/.m2/repository</td><td style="text-align:left">Maven默认的本地仓库目录位置</td></tr></tbody></table></div><p>POM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。</p><p>执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。</p><p>POM 中可以指定以下配置：</p><ul><li>项目依赖</li><li>插件</li><li>执行目标</li><li>项目构建 profile</li><li>项目版本</li><li>项目开发者列表</li><li>相关邮件列表信息</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span> = <span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span> = <span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span> = <span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 模型版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.project-group<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所有 POM 文件都需要 project 元素和三个必需字段：groupId，artifactId，version。</p><div class="table-container"><table><thead><tr><th style="text-align:left">节点</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">project</td><td style="text-align:left">工程的根标签。</td></tr><tr><td style="text-align:left">modelVersion</td><td style="text-align:left">模型版本需要设置为 4.0。</td></tr><tr><td style="text-align:left">groupId</td><td style="text-align:left">这是工程组的标识。它在一个组织或者项目中通常是唯一的。例如，一个银行组织 com.companyname.project-group 拥有所有的和银行相关的项目。</td></tr><tr><td style="text-align:left">artifactId</td><td style="text-align:left">这是工程的标识。它通常是工程的名称。例如，消费者银行。groupId 和 artifactId 一起定义了 artifact 在仓库中的位置。</td></tr><tr><td style="text-align:left">version</td><td style="text-align:left">这是工程的版本号。在 artifact 的仓库中，它用来区分不同的版本。例如：<code>com.company.bank:consumer-banking:1.0 com.company.bank:consumer-banking:1.1</code></td></tr></tbody></table></div><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="其他常用元素"><a href="#其他常用元素" class="headerlink" title="其他常用元素"></a>其他常用元素</h3><p><strong>properties</strong>: 定义项目中的一些属性变量:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>repositories: 定义项目的依赖库:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>dependencyManagement</strong>: 用于管理依赖的版本，特别是在多模块项目中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>profiles: 用于定义不同的构建配置，可以根据不同的环境进行构建：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>development<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">environment</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>production<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">environment</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><p>继承: 通过parent元素，一个POM文件可以继承另一个POM文件的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent-project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>聚合: 通过modules元素，一个POM文件可以管理多个子模块：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>module1<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>module2<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>个典型的 Maven 构建（build）生命周期是由以下几个阶段的序列组成的：</p><p><img data-src="https://www.runoob.com/wp-content/uploads/2018/09/maven-package-build-phase.png" alt="img"></p><div class="table-container"><table><thead><tr><th style="text-align:left">阶段</th><th style="text-align:left">处理</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">验证 validate</td><td style="text-align:left">验证项目</td><td style="text-align:left">验证项目是否正确且所有必须信息是可用的</td></tr><tr><td style="text-align:left">编译 compile</td><td style="text-align:left">执行编译</td><td style="text-align:left">源代码编译在此阶段完成</td></tr><tr><td style="text-align:left">测试 Test</td><td style="text-align:left">测试</td><td style="text-align:left">使用适当的单元测试框架（例如JUnit）运行测试。</td></tr><tr><td style="text-align:left">包装 package</td><td style="text-align:left">打包</td><td style="text-align:left">将编译后的代码打包成可分发的格式，例如 JAR 或 WAR</td></tr><tr><td style="text-align:left">检查 verify</td><td style="text-align:left">检查</td><td style="text-align:left">对集成测试的结果进行检查，以保证质量达标</td></tr><tr><td style="text-align:left">安装 install</td><td style="text-align:left">安装</td><td style="text-align:left">安装打包的项目到本地仓库，以供其他项目使用</td></tr><tr><td style="text-align:left">部署 deploy</td><td style="text-align:left">部署</td><td style="text-align:left">拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程</td></tr></tbody></table></div><p>为了完成 default 生命周期，这些阶段（包括其他未在上面罗列的生命周期阶段）将被按顺序地执行。</p><p>Maven 有以下三个标准的生命周期：</p><p><strong>1、Clean 生命周期：</strong></p><ul><li><strong>clean</strong>：删除目标目录中的编译输出文件。这通常是在构建之前执行的，以确保项目从一个干净的状态开始。</li></ul><p><strong>2、Default 生命周期（也称为 Build 生命周期）：</strong></p><ul><li><strong>validate</strong>：验证项目的正确性，例如检查项目的版本是否正确。</li><li><strong>compile</strong>：编译项目的源代码。</li><li><strong>test</strong>：运行项目的单元测试。</li><li><strong>package</strong>：将编译后的代码打包成可分发的格式，例如 JAR 或 WAR。</li><li><strong>verify</strong>：对项目进行额外的检查以确保质量。</li><li><strong>install</strong>：将项目的构建结果安装到本地 Maven 仓库中，以供其他项目使用。</li><li><strong>deploy</strong>：将项目的构建结果复制到远程仓库，以供其他开发人员或团队使用。</li></ul><p><strong>3、Site 生命周期：</strong></p><ul><li><strong>site</strong>：生成项目文档和站点信息。</li><li><strong>deploy-site</strong>：将生成的站点信息发布到远程服务器，以便共享项目文档。</li></ul><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>在 Maven 的术语中，仓库是一个位置（place）。</p><p>Maven 仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。</p><p>在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称之为构件。</p><p>Maven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。</p><p>Maven 仓库有三种类型：</p><ul><li>本地（local）</li><li>中央（central）</li><li>远程（remote）</li></ul><p>Maven 的本地仓库，<strong>在安装 Maven 后并不会创建，它是在第一次执行 maven 命令的时候才被创建</strong>。</p><p>运行 Maven 的时候，Maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。</p><blockquote><p>默认情况下，不管Linux还是 Windows，每个用户在自己的用户目录下都有一个路径名为 .m2/repository/ 的仓库目录。</p></blockquote><p>Maven 本地仓库默认被创建在 %USER_HOME% 目录下。要修改默认位置，在 %M2_HOME%\conf 目录中的 Maven 的 settings.xml 文件中定义另一个路径。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span>   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>   <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0    http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span>      <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>C:/MyLocalRepository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span> <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当运行 Maven 命令，Maven 将下载依赖的文件到你指定的路径中。</p><p>Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。</p><p>中央仓库包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。</p><p>中央仓库的关键概念：</p><ul><li>这个仓库由 Maven 社区管理。</li><li>不需要配置。</li><li>需要通过网络才能访问。</li></ul><p>如果 Maven 在中央仓库中也找不到依赖的文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。</p><p>举例说明，使用下面的 pom.xml，<strong>Maven 将从远程仓库中下载该 pom.xml 中声明的所依赖的（在中央仓库中获取不到的）文件</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.projectgroup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.common-lib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>common-lib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--自定义远程仓库--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>companyname.lib1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://download.companyname.org/maven2/lib1<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>companyname.lib2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://download.companyname.org/maven2/lib2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库：</p><ul><li><strong>步骤 1</strong> － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li><li><strong>步骤 2</strong> － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。</li><li><strong>步骤 3</strong> － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li><li><strong>步骤 4</strong> － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</li></ul><p>Maven 仓库默认在国外， 国内使用难免很慢，我们可以更换为阿里云的仓库。</p><p><strong>修改 maven 根目录下的 conf 文件夹中的 settings.xml 文件</strong>，在 mirrors 节点上，添加内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果想使用其它代理仓库，可在 <strong><repositories></repositories></strong> 节点中加入对应的仓库使用地址。以使用 spring 代理仓为例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/spring<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在你的 pom.xml 文件 <strong><denpendencies></denpendencies></strong> 节点中加入你要引用的文件信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>[GROUP_ID]<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>[ARTIFACT_ID]<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>[VERSION]<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><strong><code>mvn clean</code></strong><ul><li>清理项目，删除 <code>target</code> 目录（该目录包含了编译和打包过程中生成的所有文件）。</li></ul></li><li><strong><code>mvn compile</code></strong><ul><li>编译项目的源代码。默认情况下，会查找 <code>src/main/java</code> 目录下的所有 <code>.java</code> 文件，并将编译后的 <code>.class</code> 文件输出到 <code>target/classes</code> 目录中。</li></ul></li><li><strong><code>mvn test</code></strong><ul><li>使用合适的单元测试框架（如 JUnit 或 TestNG）运行项目的测试代码。默认情况下，测试代码位于 <code>src/test/java</code> 目录下。</li></ul></li><li><strong><code>mvn package</code></strong><ul><li>将编译好的字节码打包成可分发的格式，例如 JAR 或 WAR 文件。这个命令首先执行 <code>compile</code> 和 <code>test</code>，然后将项目打包并存放在 <code>target</code> 目录中。</li></ul></li><li><strong><code>mvn install</code></strong><ul><li>安装打包好的构件到本地仓库（通常是用户主目录下的 <code>.m2/repository</code>），以便它可以被其他项目作为依赖使用。此命令还会执行 <code>package</code> 的所有步骤。</li></ul></li><li><strong><code>mvn deploy</code></strong><ul><li>在集成或发布阶段使用，用于将最终包复制到远程仓库，使得其他开发者或项目可以共享这个构件。</li></ul></li><li><strong><code>mvn site</code></strong><ul><li>生成关于项目的站点文档，包括测试覆盖率报告、依赖列表等信息。</li></ul></li><li><strong><code>mvn clean install</code></strong><ul><li>组合命令，先清理项目 (<code>clean</code>) 然后安装 (<code>install</code>) 到本地仓库。这是非常常见的组合，用于确保在干净环境下重新构建整个项目。</li></ul></li><li><strong><code>mvn dependency:tree</code></strong><ul><li>显示项目依赖树，有助于分析依赖冲突或了解项目依赖关系。</li></ul></li><li><strong><code>mvn archetype:generate</code></strong><ul><li>生成一个新的 Maven 项目结构，通过交互式的方式选择项目模板</li></ul></li></ol><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="MySQL✨"><a href="#MySQL✨" class="headerlink" title="MySQL✨"></a>MySQL✨</h2><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>一组操作的集合,不可分割的一个工作单位. 事务会把所有操作作为一个整体向系统提交或撤销操作,即这些操作要么同时成功,要么同时失败.</p><p>事务四大特性</p><ul><li><strong>原子性（Atomicity）</strong>：事务中的所有操作要么全部完成，要么全部不执行。</li><li><strong>一致性（Consistency）</strong>：事务应该将数据库从一种一致状态转换为另一种一致状态。</li><li><strong>隔离性（Isolation）</strong>：并发事务之间相互隔离，不会互相干扰。</li><li><strong>持久性（Durability）</strong>：一旦事务提交，所做的更改将是永久性的，即使系统发生故障也不会丢失。</li></ul><p><img data-src="https://s2.loli.net/2025/03/29/qaAURO3uTdrxlEY.png" alt="image-20250329225640854"></p><h5 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h5><p>多个事务并发进行的问题</p><h6 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h6><p>一个事务读到另外一个事务还没有提交的数据</p><h6 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h6><p>一个事务先后读取同一条记录,但两次读取的数据不同,称之为不可重复读</p><h6 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h6><p>一个事务按照条件查询数据时,没有对应的数据行,但是在插入数据时,又发现这行数据已经存在</p><h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><p>MySQL 支持四种标准的事务隔离级别：</p><ol><li><strong>读未提交（Read Uncommitted）</strong>:最低级别的隔离，允许脏读、不可重复读和幻读。</li><li><strong>读已提交（Read Committed）</strong>:防止脏读，但允许不可重复读和幻读。</li><li><strong>可重复读（Repeatable Read）</strong>:默认级别，防止脏读和不可重复读，但允许幻读。</li><li><strong>串行化（Serializable）</strong>:最高级别的隔离，完全防止脏读、不可重复读和幻读，但会降低并发性能。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">-- 或者</span><br><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br></pre></td></tr></table></figure><p><strong>1. 默认情况下：事务需要显式提交</strong></p><ul><li>在 <code>START TRANSACTION</code> 开始一个事务后，所有对数据库的修改操作（如 <code>UPDATE</code>、<code>INSERT</code> 等）都只会暂时存在于事务的上下文中，而不会直接写入数据库。</li><li>这些更改对其他事务是不可见的（根据隔离级别），直到你显式调用 <code>COMMIT</code> 提交事务。</li><li>如果你调用 <code>ROLLBACK</code>，则所有的更改会被撤销，数据库恢复到事务开始前的状态。</li></ul><p><strong>2. 如果未提交且会话结束</strong></p><ul><li><p>如果你在事务中执行了更新语句，但没有显式调用COMMITROLLBACK</p><p>，然后会话意外终止（例如客户端断开连接），MySQL 的行为如下：</p><ul><li><strong>InnoDB 存储引擎</strong>（支持事务）：事务会被自动回滚，所有未提交的更改都会被撤销。</li><li><strong>MyISAM 存储引擎</strong>（不支持事务）：由于 MyISAM 不支持事务，所有操作会立即生效，无法回滚。</li></ul></li></ul><p><strong>3. autocommit 模式的影响</strong></p><ul><li>MySQL 默认开启了 <strong>autocommit 模式</strong>（<code>autocommit=1</code>）。在这种模式下，每条单独的 SQL 语句都会被视为一个独立的事务，并在执行后自动提交。</li><li>当你使用 <code>START TRANSACTION</code> 或 <code>BEGIN</code> 时，会临时禁用 autocommit 模式，直到事务结束（通过 <code>COMMIT</code> 或 <code>ROLLBACK</code>）。</li><li>如果你没有显式提交事务，而会话结束时 autocommit 模式重新启用，InnoDB 会自动回滚未提交的事务。</li></ul><p><img data-src="https://s2.loli.net/2025/03/26/F7Ebo35RH6XIQft.png" alt="image-20250326191732721"></p><h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><p><img data-src="https://s2.loli.net/2025/03/26/LjCFSxblAyBGEhd.png" alt="image-20250326192221989"></p><p><strong>1. InnoDB</strong></p><ul><li><p><strong>默认存储引擎</strong>：从 MySQL 5.5 开始成为默认存储引擎。</p></li><li><p>特性</p><ul><li><strong>事务支持</strong>：完全支持 ACID（原子性、一致性、隔离性、持久性）属性，适合需要高可靠性和数据一致性的应用。</li><li><strong>行级锁定</strong>：提供高效的并发处理能力，减少了锁冲突的可能性。</li></ul><blockquote><p>行级锁定是指在对数据进行操作时，只锁定受影响的具体行而不是整个表。这意味着在同一张表中，不同事务可以同时对不同的行进行读写操作。</p></blockquote><ul><li><strong>外键支持</strong>：唯一支持外键约束的存储引擎，有助于维护数据完整性和引用完整性。</li><li><strong>崩溃恢复</strong>：通过 redo 和 undo 日志实现快速崩溃恢复。</li><li><strong>聚簇索引</strong>：每个表都使用主键作为聚簇索引，提高了查询效率。</li></ul></li></ul><p><strong>2. MyISAM</strong></p><ul><li><strong>早期默认存储引擎</strong>：在 MySQL 5.5 之前是默认的存储引擎。</li><li>特性<ul><li><strong>不支持事务</strong>：适用于对事务要求不高、以读操作为主的场景。</li><li><strong>表级锁定</strong>：整个表被锁定进行写入操作，可能导致高并发下的性能瓶颈。</li><li><strong>全文索引</strong>：MyISAM 支持全文搜索，这在某些文本检索应用中非常有用。</li><li><strong>压缩表</strong>：可以创建只读压缩表，节省存储空间。</li><li><strong>简单高效</strong>：对于简单的查询操作，MyISAM 提供了较高的性能。</li></ul></li></ul><p><strong>3. Memory (Heap)</strong></p><ul><li><strong>内存中的表</strong>：数据存放在内存中，因此访问速度非常快。</li><li>特性<ul><li><strong>临时性</strong>：重启服务器后数据丢失，适用于缓存数据或临时计算。</li><li><strong>表级锁定</strong>：由于是内存操作，锁定粒度较粗并不会显著影响性能。</li><li><strong>哈希索引</strong>：默认使用哈希索引，对于精确匹配查询特别有效。</li><li><strong>不支持事务</strong>：与 MyISAM 类似，Memory 引擎也不支持事务。</li></ul></li></ul><p><img data-src="https://s2.loli.net/2025/03/29/TolUSndakcOP3ti.png" alt="image-20250329230207046"></p><p><img data-src="https://s2.loli.net/2025/03/29/zI1SvEeYGsfFkpy.png" alt="image-20250329230247585"></p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p><img data-src="https://s2.loli.net/2025/03/29/TmRpyswKoazBdO3.png" alt="image-20250329230936523"></p><ul><li><strong>定义</strong>：索引是一种特殊的数据结构，用于加速数据库表中数据的检索速度。</li><li><strong>目的</strong>：减少查询时需要扫描的数据量，从而提高查询性能。</li><li><p><strong>代价</strong>：虽然索引可以加快查询速度，但它们也会占用额外的存储空间，并且在进行插入、更新和删除操作时会增加一些开销。</p><p><strong>B-Tree 索引</strong></p></li><li><p><strong>适用范围</strong>：这是 MySQL 中最常用的索引类型，默认情况下，<code>CREATE INDEX</code> 创建的就是 B-Tree 索引。</p></li><li><p>特点</p><ul><li>支持全键值、键值范围和键前缀查找（如 <code>LIKE &#39;abc%&#39;</code>）。</li><li>能够有效地支持等值查询和范围查询（例如 <code>&gt;</code>、<code>&lt;</code>、<code>BETWEEN</code>、<code>IN</code> 等）。</li><li>适用于大多数类型的比较操作（包括 <code>=</code>、<code>&lt;&gt;</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>）。</li></ul></li></ul><p><strong>(1) 阶数（Order）</strong></p><ul><li>B 树的阶数 t是一个定义其结构的重要参数。每个节点最多可以有 2t−1个键值，并且至少包含 t−1个键值（除了根节点外）。每个内部节点最多有 2t个子节点。</li><li><p>这种设计确保了树的高度保持较低，从而减少了查找所需的时间。<strong>(2) 节点类型</strong></p></li><li><p><strong>内部节点</strong>：除了叶子节点之外的所有节点。它们存储键值和指向子节点的指针。</p></li><li><strong>叶子节点</strong>：位于树的最底层，直接存储数据或指向数据的指针。</li></ul><p><strong>2. B+ 树（B+Tree）</strong></p><p><strong>定义</strong></p><ul><li>B+ 树是 B 树的一种变体，特别优化了范围查询性能。与 B 树不同的是，B+ 树的所有数据都存储在叶子节点中，而内部节点仅用于导航目的。</li></ul><p><strong>特点</strong></p><ul><li><strong>所有数据都在叶子节点</strong>：这意味着所有的实际数据记录都存储在叶子节点上，而不是分散在整棵树中。这样做的好处是可以将更多的键值放入内部节点，从而进一步降低树的高度。</li><li><strong>叶子节点链表</strong>：B+ 树的叶子节点通过双向链表连接在一起，这极大地提高了范围查询的效率，因为一旦定位到起始位置，就可以沿着链表顺序访问后续的数据。</li><li><strong>更高的分支因子</strong>：由于内部节点不存储数据，因此可以容纳更多的子节点指针，这有助于进一步减少树的高度，提高查找效率。</li></ul><p><strong>3. B 树 vs. B+ 树</strong></p><div class="table-container"><table><thead><tr><th>特性</th><th>B 树</th><th>B+ 树</th></tr></thead><tbody><tr><td><strong>数据存储位置</strong></td><td>内部节点和叶子节点都可以存储数据</td><td><strong>仅叶子节点存储数据</strong>，内部节点仅用于导航</td></tr><tr><td><strong>叶子节点连接</strong></td><td>不具备叶子节点间的直接连接</td><td><strong>叶子节点之间通过链表相连</strong>，便于范围查询</td></tr><tr><td><strong>树的高度</strong></td><td>较高，因为内部节点也需要存储数据</td><td>更低，因为<strong>内部节点可以存储更多键值</strong>，减少了树的高度</td></tr><tr><td><strong>适用场景</strong></td><td>适合于大多数基本查询操作</td><td>特别<strong>适合于范围查询</strong>和排序操作</td></tr></tbody></table></div><p><img data-src="https://s2.loli.net/2025/03/29/dIRX1Fx5kQ2gPra.png" alt="image-20250329231556772"></p><div class="table-container"><table><thead><tr><th><strong>特性</strong></th><th><strong>B树</strong></th><th><strong>B+树</strong></th></tr></thead><tbody><tr><td><strong>数据存储</strong></td><td><strong>数据（key-value）存储在所有节点（叶子+内部）</strong></td><td><strong>数据仅存储在叶子节点</strong>，内部节点只存 key</td></tr><tr><td><strong>指针</strong></td><td><strong>内部节点的指针指向子节点</strong></td><td><strong>叶子节点间有额外的顺序指针（双向链表）</strong></td></tr><tr><td><strong>搜索</strong></td><td><strong>可以在非叶子节点找到数据</strong>，搜索可能提前结束</td><td><strong>必须走到叶子节点才能找到数据</strong>，查询路径固定</td></tr><tr><td><strong>范围查询</strong></td><td><strong>范围查询效率较低</strong>，需回溯</td><td><strong>范围查询效率高</strong>（叶子节点是链表，顺序扫描快）</td></tr><tr><td><strong>磁盘I/O</strong></td><td><strong>较多随机I/O</strong></td><td><strong>较少随机I/O，访问更快</strong></td></tr><tr><td><strong>树的高度</strong></td><td><strong>相对较高</strong></td><td><strong>相对较低</strong>（因为内部节点更小，能容纳更多 key）</td></tr></tbody></table></div><p><img data-src="https://s2.loli.net/2025/03/30/7TQF6gL1Cro5w2R.png" alt="image-20250330000450278"></p><p><img data-src="https://s2.loli.net/2025/03/29/H6AyOzY18MKCcPJ.png" alt="image-20250329231337759"></p><p><img data-src="https://s2.loli.net/2025/03/30/MXwuylP5fqpNBz4.png" alt="image-20250330000930507"></p><div class="table-container"><table><thead><tr><th>特性</th><th>聚集索引</th><th>二级索引</th></tr></thead><tbody><tr><td><strong>物理存储</strong></td><td>数据按索引键顺序存储</td><td>数据存储位置与索引无关，索引中包含指向数据行的指针</td></tr><tr><td><strong>数量限制</strong></td><td>每个表只能有一个</td><td>可以有多个</td></tr><tr><td><strong>查询效率</strong></td><td>对于按索引键排序的查询非常高效</td><td>需要两次查找（先找索引，再找数据行），但适用于多种查询条件</td></tr><tr><td><strong>更新开销</strong></td><td>更新可能导致大量数据重排，开销较大</td><td>更新仅需修改索引结构，开销相对较小</td></tr></tbody></table></div><h4 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h4><p><strong>1. 使用 <code>EXPLAIN</code> 分析查询性能</strong></p><p>🔹 <code>EXPLAIN</code> 可以 <strong>分析 SQL 查询的执行计划</strong>，查看 <strong>索引使用情况</strong>、<strong>扫描方式</strong> 和 <strong>查询优化器的决策</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>;</span><br></pre></td></tr></table></figure><p>🚀 <strong>关键字段解读</strong>：</p><div class="table-container"><table><thead><tr><th><strong>字段</strong></th><th><strong>作用</strong></th><th><strong>优化建议</strong></th></tr></thead><tbody><tr><td><code>id</code></td><td>查询的执行顺序</td><td>ID 越大，优先执行</td></tr><tr><td><code>select_type</code></td><td>查询类型</td><td><code>SIMPLE</code> 是最优</td></tr><tr><td><code>table</code></td><td>查询的表</td><td>确保表索引优化</td></tr><tr><td><code>type</code></td><td>访问类型</td><td><code>ALL</code>(全表扫描) 最差，<code>index</code>、<code>ref</code>、<code>range</code>、<code>const</code> 最优</td></tr><tr><td><code>possible_keys</code></td><td>可能使用的索引</td><td>如果 <code>NULL</code>，说明没有合适的索引</td></tr><tr><td><code>key</code></td><td>实际使用的索引</td><td>确保索引合理</td></tr><tr><td><code>rows</code></td><td>需要扫描的行数</td><td>越少越好</td></tr><tr><td><code>Extra</code></td><td>额外信息</td><td><strong>避免 <code>Using filesort</code> 和 <code>Using temporary</code></strong></td></tr></tbody></table></div><p>🔹 <strong>优化示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email <span class="operator">=</span> <span class="string">&#x27;test@example.com&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/30/jpQ7nwHN8rg34Jq.png" alt="image-20250330111354571"></p><p><strong>2. 使用 <code>SHOW PROFILE</code> 进行 SQL 运行时间分析</strong></p><p>🔹 <code>SHOW PROFILE</code> 详细分析 SQL <strong>在各个阶段的执行时间</strong>，如 <strong>解析、优化、执行、发送数据</strong>。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlCopyEditSET profiling = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email = <span class="string">&#x27;test@example.com&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> PROFILES;</span><br></pre></td></tr></table></figure><p>🔹 <strong>查看 SQL 具体耗时</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> PROFILE <span class="keyword">FOR</span> QUERY <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>🚀 <strong>优化方向</strong></p><ul><li><strong>如果 <code>sending data</code> 耗时长</strong> ➝ 可能需要优化索引或减少返回数据量。</li><li><strong>如果 <code>query optimization</code> 耗时长</strong> ➝ SQL 逻辑复杂，可以考虑优化子查询或 JOIN。</li></ul><p><img data-src="https://s2.loli.net/2025/03/30/KcSBGzw6C1W5Iho.png" alt="image-20250330112810495"></p><p><strong>3. 使用 <code>SHOW STATUS</code> 获取数据库运行状态</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Threads%&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br></pre></td></tr></table></figure><p>🚀 <strong>关键指标</strong></p><div class="table-container"><table><thead><tr><th><strong>指标</strong></th><th><strong>作用</strong></th><th><strong>优化建议</strong></th></tr></thead><tbody><tr><td><code>Threads_running</code></td><td>当前正在执行的查询数</td><td><strong>避免长时间运行的查询</strong></td></tr><tr><td><code>Threads_connected</code></td><td>当前连接数</td><td><strong>优化连接池配置</strong></td></tr><tr><td><code>Slow_queries</code></td><td>慢查询数量</td><td><strong>检查慢查询日志</strong></td></tr><tr><td><code>Handler_read_rnd_next</code></td><td>全表扫描次数</td><td><strong>应减少</strong>（索引优化）</td></tr></tbody></table></div><p><strong>4. 慢查询日志分析</strong></p><p>🔹 <strong>开启慢查询日志</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> long_query_time <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 记录执行时间 &gt;1秒的查询</span></span><br></pre></td></tr></table></figure><p>🔹 <strong>查看慢查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mysql.slow_log <span class="keyword">ORDER</span> <span class="keyword">BY</span> start_time <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>🚀 <strong>优化方法</strong></p><ul><li><strong>使用索引，减少 <code>ALL</code> 扫描</strong></li><li><strong>优化 <code>JOIN</code>，避免 <code>Using temporary</code></strong></li><li><strong>避免 <code>ORDER BY</code> + <code>LIMIT</code> 造成的 <code>filesort</code></strong></li></ul><p><strong>5. 索引优化</strong></p><p><strong>（1）使用合适的索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_users_name <span class="keyword">ON</span> users(name);</span><br></pre></td></tr></table></figure><ul><li><p><strong>单列索引</strong>：适用于<strong>单个查询字段</strong></p></li><li><p><strong>复合索引</strong>：适用于 <strong><code>WHERE col1 AND col2</code></strong></p></li><li><p><strong>前缀索引</strong>：适用于<strong>长字符串字段</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_users_email <span class="keyword">ON</span> users(email(<span class="number">10</span>));</span><br></pre></td></tr></table></figure></li></ul><p><strong>（2）避免索引失效</strong></p><p>🔹 <strong>索引会失效的情况</strong></p><div class="table-container"><table><thead><tr><th><strong>错误写法</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td><code>WHERE name LIKE &#39;%abc&#39;</code></td><td><code>%</code> 开头索引失效</td></tr><tr><td><code>WHERE DATE(create_time) = &#39;2024-03-30&#39;</code></td><td><strong>函数</strong> 使索引失效</td></tr><tr><td><code>WHERE id + 1 = 10</code></td><td><strong>计算操作</strong> 使索引失效</td></tr></tbody></table></div><p>🔹 <strong>优化索引查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方式 1：避免前导 %</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式 2：索引时间范围查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> create_time <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-03-30&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-03-31&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>6. SQL 语句优化</strong></p><p><strong>（1）避免 <code>SELECT \*</code></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>🔹 <strong>减少不必要的数据传输，提高查询效率</strong></p><p><strong>（2）避免 <code>OR</code>，改为 <code>UNION ALL</code></strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sqlCopyEdit<span class="comment">-- ❌ 索引失效</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="type">name</span> = <span class="string">&#x27;Alice&#x27;</span> <span class="keyword">OR</span> age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ✅ 改成 UNION ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="type">name</span> = <span class="string">&#x27;Alice&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age = <span class="number">25</span>;</span><br></pre></td></tr></table></figure><p>🔹 <strong><code>OR</code> 可能导致索引失效，而 <code>UNION ALL</code> 可提高性能</strong></p><p><strong>（3）避免 <code>NOT IN</code>，改用 <code>NOT EXISTS</code></strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sqlCopyEdit<span class="comment">-- ❌ NOT IN 可能导致全表扫描</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> orders);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ✅ 使用 NOT EXISTS</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users u <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> orders o <span class="keyword">WHERE</span> u.id = o.user_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>🔹 <strong><code>NOT EXISTS</code> 在大数据量下查询效率更高</strong></p><div class="table-container"><table><thead><tr><th><strong>优化点</strong></th><th><strong>方法</strong></th></tr></thead><tbody><tr><td><strong>SQL 分析</strong></td><td><code>EXPLAIN</code>、<code>SHOW PROFILE</code></td></tr><tr><td><strong>索引优化</strong></td><td><code>CREATE INDEX</code>，避免索引失效</td></tr><tr><td><strong>慢查询优化</strong></td><td><code>SHOW SLOW LOGS</code>，减少 <code>SELECT *</code></td></tr><tr><td><strong>SQL 语句优化</strong></td><td><strong>避免 <code>OR</code>，使用 <code>EXISTS</code></strong></td></tr><tr><td><strong>缓存优化</strong></td><td><strong>使用 Redis</strong>，调整 <code>query_cache_size</code></td></tr><tr><td><strong>服务器配置优化</strong></td><td><strong>优化 <code>innodb_buffer_pool_size</code>、<code>max_connections</code></strong></td></tr></tbody></table></div><p><strong>1. 最左前缀法则</strong></p><p><strong>定义</strong></p><ul><li><p><strong>最左前缀法则</strong>指的是，在使用组合索引时，查询条件必须从索引的最左边开始匹配。只有满足这个规则，MySQL 才能利用该索引来加速查询。</p></li><li><p>例如，如果你在一个表上创建了一个组合索引</p></li></ul>  <figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">col1</span>, col2, col3)</span><br></pre></td></tr></table></figure><p>  ，那么以下查询可以有效利用该索引：</p><p>  sql</p><p>  深色版本</p>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> col1 = <span class="string">&#x27;value&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> col1 = <span class="string">&#x27;value&#x27;</span> <span class="keyword">AND</span> col2 = <span class="string">&#x27;value&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> col1 = <span class="string">&#x27;value&#x27;</span> <span class="keyword">AND</span> col2 = <span class="string">&#x27;value&#x27;</span> <span class="keyword">AND</span> col3 = <span class="string">&#x27;value&#x27;</span>;</span><br></pre></td></tr></table></figure><p>  但是，如果查询条件不包含col1或者跳过了col1，则无法完全利用该索引：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不能利用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> col2 <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> col3 <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>原理</strong></p><ul><li>组合索引实际上是对多个列进行排序后构建的索引结构。MySQL 在查找数据时，会首先根据索引中最左边的列进行过滤，然后再依次考虑后面的列。</li><li>因此，为了最大化索引的利用率，查询条件应该尽可能地从最左边的列开始，并且保持连续</li></ul><p>模糊查询,如果是头部进行模糊,索引不会失效.</p><p>在索引上进行运算,索引会失效.</p><p><strong>1. <code>LIKE</code> 以 <code>%</code> 开头</strong></p><p>❌ <strong>错误示例</strong>（索引失效，全表扫描）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%Alice&#x27;</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>原因</strong>：</p><ul><li><code>LIKE &#39;%XXX&#39;</code> <strong>前面有通配符</strong>，MySQL <strong>无法利用 B+ 树索引</strong>，只能<strong>全表扫描</strong>。</li></ul><p>✅ <strong>正确优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;Alice%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>优化点</strong>：</p><ul><li><p><strong><code>Alice%</code> 结尾带 <code>%</code>，索引仍然有效</strong>。</p></li><li><p>若要支持前缀匹配，可 <strong>使用全文索引（FULLTEXT）</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlCopyEdit<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users <span class="keyword">ADD</span> FULLTEXT(name);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(name) AGAINST(<span class="string">&#x27;Alice&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul><p><strong>2. <code>OR</code> 可能导致索引失效</strong></p><p>❌ <strong>错误示例</strong>（索引失效）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">25</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>原因</strong>：</p><ul><li><strong><code>name</code> 和 <code>age</code> 上都有索引</strong>，但 <code>OR</code> 让 MySQL <strong>无法同时使用多个索引</strong>，会导致全表扫描。</li></ul><p>✅ <strong>正确优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方式 1：使用 UNION（若 name 和 age 都有索引）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">25</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>优化点</strong>：</p><ul><li><code>UNION ALL</code> <strong>分两次查询，分别使用索引</strong>，<strong>避免全表扫描</strong>。</li></ul><p><strong>3. <code>NOT IN</code> 可能导致索引失效</strong></p><p>❌ <strong>错误示例</strong>（索引失效）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>📌 <strong>原因</strong>：</p><ul><li><code>NOT IN</code> 可能触发全表扫描，因为 MySQL 需要 <strong>检查每一行是否符合条件</strong>。</li></ul><p>✅ <strong>正确优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方式 1：改用 NOT EXISTS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users u <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> orders o <span class="keyword">WHERE</span> u.id <span class="operator">=</span> o.user_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>📌 <strong>优化点</strong>：</p><ul><li><strong><code>NOT EXISTS</code> 性能更优</strong>，可有效利用索引。</li></ul><p><strong>4. 对索引列进行计算</strong></p><p>❌ <strong>错误示例</strong>（索引失效）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>原因</strong>：</p><ul><li><code>id + 1 = 10</code> <strong>对索引字段进行了计算</strong>，导致 MySQL <strong>无法使用索引</strong>。</li></ul><p>✅ <strong>正确优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">9</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>优化点</strong>：</p><ul><li><strong>尽量避免索引列上的计算</strong>。</li></ul><p><strong>5. 对索引列使用函数</strong></p><p>❌ <strong>错误示例</strong>（索引失效）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(phone, <span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;138&#x27;</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>原因</strong>：</p><ul><li><code>LEFT(phone, 3)</code> <strong>对 <code>phone</code> 列进行了函数操作</strong>，导致索引失效。</li></ul><p>✅ <strong>正确优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> phone <span class="keyword">LIKE</span> <span class="string">&#x27;138%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>优化点</strong>：</p><ul><li><strong>避免对索引列使用函数</strong>，可以使用 <code>LIKE &#39;XXX%&#39;</code>。</li></ul><p><strong>6. 数据类型不匹配</strong></p><p>❌ <strong>错误示例</strong>（索引失效）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> phone <span class="operator">=</span> <span class="number">13812345678</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>原因</strong>：</p><ul><li><code>phone</code> 列是 <strong><code>VARCHAR(11)</code> 类型</strong>，但查询时传入的是 <strong>数值</strong>（<code>INT</code>）。</li><li>MySQL <strong>会进行隐式类型转换</strong>，导致索引失效。</li></ul><p>✅ <strong>正确优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> phone <span class="operator">=</span> <span class="string">&#x27;13812345678&#x27;</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>优化点</strong>：</p><ul><li><strong>保证查询参数类型与索引列类型一致</strong>。</li></ul><p><strong>7. 范围查询 (<code>&gt;</code>、<code>&lt;</code>、<code>BETWEEN</code>) 导致索引失效</strong></p><p>❌ <strong>错误示例</strong>（索引失效部分字段）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">30</span> <span class="keyword">AND</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>原因</strong>：</p><ul><li><strong><code>age &gt; 30</code> 是范围查询</strong>，<strong>索引可能只用到 <code>age</code>，导致 <code>name</code> 不能被索引优化</strong>。</li></ul><p>✅ <strong>正确优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span> <span class="keyword">AND</span> age <span class="operator">&gt;</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>优化点</strong>：</p><ul><li><strong>调整查询字段顺序，让等值查询 (<code>=</code>) 在前</strong>，<strong>让 MySQL 更容易使用索引</strong>。</li></ul><p><strong>8. <code>ORDER BY</code> + <code>LIMIT</code> 可能导致索引失效</strong></p><p>❌ <strong>错误示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> age LIMIT <span class="number">10000</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>原因</strong>：</p><ul><li>当 <code>LIMIT</code> 偏移量过大时，MySQL <strong>仍然会扫描大量数据</strong>，导致性能下降。</li></ul><p>✅ <strong>正确优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方式 1：使用覆盖索引</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> age LIMIT <span class="number">10000</span>, <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式 2：使用子查询优化</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&gt;=</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> age LIMIT <span class="number">10000</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> age LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>优化点</strong>：</p><ul><li><strong>尽量减少 <code>LIMIT</code> 偏移量</strong>，可用 <strong>子查询</strong> 或 <strong>覆盖索引</strong> 提高效率。</li></ul><p><strong>索引失效的常见原因总结</strong></p><div class="table-container"><table><thead><tr><th>失效原因</th><th>解决方案</th></tr></thead><tbody><tr><td><code>LIKE &#39;%XXX&#39;</code></td><td>改为 <code>LIKE &#39;XXX%&#39;</code>，或使用 <code>FULLTEXT</code> 索引</td></tr><tr><td><code>OR</code></td><td>使用 <code>UNION ALL</code></td></tr><tr><td><code>NOT IN</code></td><td>使用 <code>NOT EXISTS</code></td></tr><tr><td>索引列计算</td><td>直接在 <code>WHERE</code> 子句中使用索引列</td></tr><tr><td>索引列使用函数</td><td>避免 <code>LEFT(phone, 3)</code>，改用 <code>LIKE &#39;XXX%&#39;</code></td></tr><tr><td>数据类型不匹配</td><td>查询参数类型与索引列类型一致</td></tr><tr><td>范围查询 (<code>&gt;</code>, <code>&lt;</code>, <code>BETWEEN</code>)</td><td>让等值查询 (<code>=</code>) 在前</td></tr><tr><td><code>ORDER BY</code> + <code>LIMIT</code></td><td>使用覆盖索引或子查询优化</td></tr></tbody></table></div><p>在某些情况下，可以通过 <code>FORCE INDEX</code> 强制 MySQL 使用特定的索引，避免优化器选择全表扫描。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees FORCE INDEX (idx_department)</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;Sales&#x27;</span> <span class="keyword">OR</span> salary <span class="operator">&gt;</span> <span class="number">5000</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：强制使用索引需要谨慎，因为优化器通常会选择最优的执行计划。如果强制使用不合适的索引，可能会适得其反</li></ul><p><strong>覆盖索引</strong></p><p>如果查询的所有列都包含在一个索引中，可以通过创建覆盖索引来避免回表操作，从而提高查询效率。</p><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p>假设查询如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department, salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;Sales&#x27;</span> <span class="keyword">OR</span> salary <span class="operator">&gt;</span> <span class="number">5000</span>;</span><br></pre></td></tr></table></figure><p>可以创建以下覆盖索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_dept_salary <span class="keyword">ON</span> employees(department, salary);</span><br></pre></td></tr></table></figure><p>由于查询所需的所有列都在索引中，MySQL 可以直接通过索引返回结果，无需访问数据表(不需要回标)。</p><p><strong>前缀索引</strong></p><ul><li><strong>前缀索引</strong>是指对列中值的前 N 个字符或字节创建索引，而不是对整个列值进行索引。</li><li>这种方法特别适用于 <code>VARCHAR</code>、<code>TEXT</code> 和 <code>BLOB</code> 类型的列，这些列通常包含较长的数据。</li></ul><p>前缀索引（Prefix Index）是 MySQL 中一种特殊的索引类型，它允许你为列的值的前缀创建索引，而不是整个列的值。这种索引对于那些存储较长字符串的列特别有用，因为它可以显著减少索引的大小，同时仍然提供良好的查询性能</p><p>假设有一个博客系统，其中的文章标题可能很长，并且我们希望根据标题的部分内容进行搜索：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> articles (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    title <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    content TEXT,</span><br><span class="line">    INDEX idx_title (title(<span class="number">50</span>))  <span class="comment">-- 对标题的前50个字符创建索引</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>对于存储长文本数据的列，除了前缀索引外，还可以考虑使用<strong>全文索引</strong>（Full-Text Index）。全文索引专门用于支持复杂的文本搜索功能，如自然语言查询和布尔查询。</p><p><strong>(1) 适用场景</strong></p><ul><li><strong>前缀索引</strong>：适合于简单的前缀匹配查询（如 <code>LIKE &#39;prefix%&#39;</code>）。</li><li><strong>全文索引</strong>：适合于复杂的文本搜索需求（如 <code>MATCH ... AGAINST</code>）。</li></ul><p><strong>(2) 性能对比</strong></p><ul><li>前缀索引更适合于快速定位具有特定前缀的记录，但在处理复杂的文本搜索时不如全文索引高效。</li><li>全文索引虽然功能强大，但构建和维护成本较高，尤其是在数据量较大的情况下。</li></ul><p><img data-src="https://s2.loli.net/2025/03/30/86OFTKqeLhJwMxY.png" alt="image-20250330133609570"></p><p><img data-src="https://s2.loli.net/2025/03/30/xTDM5wFYCa4g1rU.png" alt="image-20250330134534828"></p><p><img data-src="https://s2.loli.net/2025/03/30/VrLeJvdSgTYf79C.png" alt="image-20250330134512802"></p><h3 id="视图-存储过程-触发器"><a href="#视图-存储过程-触发器" class="headerlink" title="视图/存储过程/触发器"></a>视图/存储过程/触发器</h3><h4 id="视图-Views"><a href="#视图-Views" class="headerlink" title="视图 (Views)"></a>视图 (Views)</h4><p><strong>视图</strong>是基于SQL语句的结果集的可视化的表。视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实表中的字段</p><ul><li><strong>虚拟表</strong>：视图并不在数据库中以存储的数据值集形式存在；行和列数据来自于定义视图的查询所引用的基本表，并且是在访问视图时动态生成的。</li><li><strong>简化复杂查询</strong>：可以将复杂的查询封装进视图中，使用户可以通过简单的查询来访问这些数据。</li><li><strong>安全性</strong>：通过视图限制对基础表的访问，从而提高安全性。例如，<strong>只允许用户通过视图查看特定的列或行</strong>。</li><li><strong>更新限制</strong>：并非所有视图都可以被更新。对于包含聚合函数、DISTINCT关键字、GROUP BY、HAVING等的视图，通常不能直接进行更新操作。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><h3 id="存储过程-Stored-Procedures"><a href="#存储过程-Stored-Procedures" class="headerlink" title="存储过程 (Stored Procedures)"></a>存储过程 (Stored Procedures)</h3><p>定义</p><ul><li><strong>存储过程</strong>是一组为了完成特定功能的SQL语句集，经过编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。</li></ul><p>特点与重点</p><ul><li><strong>性能优化</strong>：由于存储过程在创建时就已经进行了编译，因此在执行时速度更快。</li><li><strong>模块化编程</strong>：可以将复杂的业务逻辑封装到存储过程中，提高代码的重用性和可维护性。</li><li><strong>减少网络流量</strong>：通过将一系列操作封装在一个存储过程中，可以减少客户端与服务器之间的通信量。</li><li><strong>安全控制</strong>：可以为存储过程设置权限，从而控制谁可以执行哪些操作。</li></ul><p>创建示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> procedure_name()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- SQL statements here</span></span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h3 id="触发器-Triggers"><a href="#触发器-Triggers" class="headerlink" title="触发器 (Triggers)"></a>触发器 (Triggers)</h3><p>定义</p><ul><li><strong>触发器</strong>是一种特殊的存储过程，它不能被显式地调用，而是当一个与其关联的操作发生的时候自动触发执行。这些操作包括<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>等。</li></ul><p>特点与重点</p><ul><li><strong>自动执行</strong>：无需人工干预即可自动执行，用于确保某些规则或流程的一致性。</li><li><strong>事务支持</strong>：触发器会参与到同一个事务中，这意味着如果触发器中的操作失败，则整个事务都会回滚。</li><li><strong>事件驱动</strong>：可以根据表上的插入、更新或删除操作来触发相应的逻辑。</li><li><strong>注意性能影响</strong>：虽然触发器提供了强大的功能，但不恰当地使用可能会导致性能问题，尤其是在高并发环境下。</li></ul><p>创建示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">BEFORE<span class="operator">/</span>AFTER <span class="keyword">INSERT</span><span class="operator">/</span>UPDATE<span class="operator">/</span><span class="keyword">DELETE</span> <span class="keyword">ON</span> table_name</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- Trigger logic here</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>视图</strong>主要用于简化查询、增强安全性和提供抽象层。</li><li><strong>存储过程</strong>则侧重于执行效率、模块化编程和减少网络负载。</li><li><strong>触发器</strong>适用于需要在数据库层面自动响应特定事件的情况，如保持数据一致性或记录审计信息。</li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁（Locking）是确保数据一致性和事务隔离级别的核心机制。通过锁定数据库中的资源，可以防止多个用户或进程同时对相同的数据进行修改而导致的数据不一致性问题。</p><p><strong>全局锁</strong> </p><p>全局读锁允许在锁定期间进行读操作，但阻止写操作。全局读锁通常用于备份操作或其他需要读取整个数据库的场景。通常使用 <code>FLUSH TABLES WITH READ LOCK</code> 语句来获取全局读锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br><span class="line">mysqldump db <span class="operator">&gt;</span> xx.sql;</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><p><strong>表级锁</strong>:锁定整个表，适用于高并发写入较少的场景。</p><p>表锁</p><p><code>LOCK TABLES</code> 语句用于在事务或会话中显式地锁定一张或多张表。锁定的表会根据需要加共享锁或排它锁，直到 <code>UNLOCK TABLES</code> 被调用。</p><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES table_name READ;  <span class="comment">-- 给表加共享锁</span></span><br><span class="line">LOCK TABLES table_name WRITE;  <span class="comment">-- 给表加排它锁</span></span><br></pre></td></tr></table></figure><p><code>UNLOCK TABLES</code> 用于释放之前使用 <code>LOCK TABLES</code> 锁定的所有表。此命令会解除锁定，允许其他事务访问这些表。</p><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure><p><strong>共享锁（S Lock 读锁）</strong></p><p>共享锁允许多个事务同时读取表中的数据，但阻止写操作。也就是说，多个事务可以同时持有共享锁并执行读取操作，但不能修改表中的数据。</p><ul><li><strong>共享锁的特点</strong>：<ul><li>允许多个事务并发读取同一个表的数据。</li><li>其他事务无法修改表中的数据，但可以进行读取操作。</li></ul></li></ul><p><strong>排它锁（X Lock 写锁）</strong></p><p>排它锁是一种更强的锁类型，当一个事务对某一表加了排它锁时，其他事务既不能读取也不能修改这个表中的数据。</p><ul><li><strong>排它锁的特点</strong>：<ul><li>只有持有排它锁的事务可以对表进行修改。</li><li>其他事务无法读取或修改这个表。</li></ul></li></ul><p>元数据锁</p><p>用于保护数据库元数据的一种锁机制。元数据指的是描述数据库结构的信息，比如表、索引、列、外键等数据库对象的定义。元数据锁的主要作用是<strong>防止在某些操作（如修改表结构）期间，其他操作对相同数据库对象的访问或修改</strong>，以保证元数据的一致性和完整性。</p><p><img data-src="https://s2.loli.net/2025/03/30/gA2pIsEbMSnZ3vc.png" alt="image-20250330141448484"></p><p>意向锁</p><p>意向锁是一种<strong>表级锁</strong>，它的作用并不是直接控制对数据的访问，而是<strong>表明某个事务希望对表中的某些行加锁</strong>，从而避免在加行级锁时与其他事务产生冲突。</p><p>当一个事务打算<strong>在某个表中对某些行加行级锁时，必须首先获取意向锁（IS 或 IX）来表明它的意图</strong>。这些意向锁会被 <strong>自动加上</strong>，因此，事务无需手动显式地设置意向锁。</p><ul><li><strong>意向共享锁（Intention Shared Lock, IS 锁）</strong>：<ul><li>表示事务打算在某些行上加共享锁（S 锁）。</li><li>其他事务仍然可以对该表加意向共享锁或意向排他锁，但不能加排他锁（X 锁）。</li></ul></li><li><strong>意向排他锁（Intention Exclusive Lock, IX 锁）</strong>：<ul><li>表示事务打算在某些行上加排他锁（X 锁）。</li><li>其他事务不能对该表加任何类型的锁（包括共享锁和排他锁），但可以加意向排他锁。</li></ul></li></ul><div class="table-container"><table><thead><tr><th>当前锁 \ 请求锁</th><th>IS 锁</th><th>IX 锁</th><th>S 锁</th><th>X 锁</th></tr></thead><tbody><tr><td><strong>IS 锁</strong></td><td>兼容</td><td>兼容</td><td>兼容</td><td>不兼容</td></tr><tr><td><strong>IX 锁</strong></td><td>兼容</td><td>兼容</td><td>不兼容</td><td>不兼容</td></tr><tr><td><strong>S 锁</strong></td><td>兼容</td><td>不兼容</td><td>兼容</td><td>不兼容</td></tr><tr><td><strong>X 锁</strong></td><td>不兼容</td><td>不兼容</td><td>不兼容</td><td>不兼容</td></tr></tbody></table></div><p><strong>1. 使用 <code>SELECT ... FOR UPDATE</code> 触发意向排它锁（IX）</strong></p><p><code>SELECT ... FOR UPDATE</code> 语句会在查询的行上加上 <strong>排它锁（X）</strong>，同时在表级别加上 <strong>意向排它锁（IX）</strong>，表示这个事务打算对该表中的一些行加排它锁。这样做是为了避免多个事务在同一表上进行行级锁时产生冲突。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 开始一个事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 对表中的某行数据加排它锁，并在表上加意向排它锁（IX）</span><br><span class="line">SELECT * FROM your_table WHERE id = 1 FOR UPDATE;</span><br></pre></td></tr></table></figure><p><strong>2. 使用 <code>SELECT ... LOCK IN SHARE MODE</code> 触发意向共享锁（IS）</strong></p><p><code>SELECT ... LOCK IN SHARE MODE</code> 语句会在查询的行上加上 <strong>共享锁（S）</strong>，同时在表级别加上 <strong>意向共享锁（IS）</strong>，表示这个事务打算对该表中的一些行加共享锁。意向锁表明了事务打算进行共享锁操作，而不直接锁定整个表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 开始一个事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 对表中的某行数据加共享锁，并在表上加意向共享锁（IS）</span><br><span class="line">SELECT * FROM your_table WHERE id = 1 LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure><p><strong>行级锁</strong>:锁定特定的行，适用于高并发写入较多的场景，能提供更高的并发性能。</p><p><strong>记录锁（Record Locks）</strong></p><ul><li><strong>定义</strong>：记录锁是对索引记录加的锁。即使表没有定义索引，MySQL也会使用隐藏的主键索引来执行记录锁。</li></ul><p><img data-src="https://s2.loli.net/2025/03/30/dILW1GOJw7h5UAu.png" alt="image-20250330143657554"></p><p><img data-src="https://s2.loli.net/2025/03/30/3B4fXRhOl1Zqgoe.png" alt="image-20250330143737180"></p><p><img data-src="https://s2.loli.net/2025/03/30/P2bx8Qfzch4Wgsq.png" alt="image-20250330151445124"></p><p><strong>间隙锁（Gap Locks）</strong></p><p>用于锁定索引记录之间的间隙，或者锁定第一个索引记录之前或最后一个索引记录之后的空间。间隙锁主要用于防止其他事务在这个间隙中插入新的记录，从而避免幻读问题（Phantom Reads）。它通常在可重复读（Repeatable Read）隔离级别下工作</p><ul><li><strong>定义</strong>：间隙锁锁定的是索引记录之间的间隙，或者锁定第一个索引记录之前或最后一个索引记录之后的空间。主要用于防止幻读现象。</li><li><strong>适用范围</strong>：仅在可重复读（Repeatable Read）隔离级别下有效。</li></ul><p><strong>Next-Key Locks</strong></p><ul><li><strong>定义</strong>：Next-Key Locks 是记录锁与间隙锁的组合，锁定的是索引记录本身以及它之前的间隙。这种锁机制有效地解决了幻读问题</li></ul><p><img data-src="https://s2.loli.net/2025/03/30/G7SjImNUFL8g1un.png" alt="image-20250330151930245"></p><p><img data-src="https://s2.loli.net/2025/03/30/FajEoXNZCSVrk3H.png" alt="image-20250330152702028"></p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><h4 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h4><p><strong>(1) 定义</strong></p><ul><li><strong>错误日志</strong>记录了 MySQL 服务器启动、运行或停止过程中遇到的问题，包括启动失败、崩溃以及一些警告信息。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variable like &#x27;%log_error%&#x27;</span><br></pre></td></tr></table></figure><p><strong>(2) 配置</strong></p><ul><li><p>默认情况下，错误日志通常位于数据目录下，文件名为 <code>hostname.err</code>(windows)。</p></li><li><p>可以通过修改配置文件my.cnf或my.ini来指定错误日志的位置和是否启用：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log_error=/path/<span class="keyword">to</span>/<span class="keyword">error</span>.<span class="built_in">log</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>2. 二进制日志（Binary Log）</strong></p><p><strong>(1) 定义</strong></p><ul><li><strong>二进制日志</strong>记录了所有更改数据库内容的事件（如 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 等），主要用于数据恢复和主从复制。</li></ul><p><strong>(2) 配置</strong></p><ul><li><p>启用二进制日志：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">log-bin</span>=/path/to/bin-log</span><br></pre></td></tr></table></figure></li><li><p>可以设置过期时间自动清理旧的日志文件：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">expire_logs_days</span>=<span class="number">7</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variable like &#x27;%log_bin%&#x27;</span><br></pre></td></tr></table></figure></li></ul><p><img data-src="https://s2.loli.net/2025/03/30/wAtkHS1Z5zXsBpy.png" alt="image-20250330153408013"></p><p><img data-src="https://s2.loli.net/2025/03/30/idITAkyWSDp6m5M.png" alt="image-20250330153726345"></p><p><img data-src="https://s2.loli.net/2025/03/30/CRmDU9XvnuzKfbj.png" alt="image-20250330154122177"></p><p><strong>查询日志（General Query Log）</strong></p><p><strong>(1) 定义</strong></p><ul><li><strong>查询日志</strong>记录了所有客户端连接和执行的所有 SQL 语句，这对于调试和审计非常有用。</li></ul><p><strong>(2) 配置</strong></p><ul><li><p>可以通过以下方式启用查询日志：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;</span><br></pre></td></tr></table></figure><p>或者在配置文件中设置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">general_log</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">general_log_file</span>=/path/to/query.log</span><br></pre></td></tr></table></figure></li></ul><p><strong>(3) 使用场景</strong></p><ul><li>调试：当需要了解应用程序如何与数据库交互时，查询日志是一个很好的工具。</li><li>性能分析：虽然查询日志对性能有一定影响，但它可以用来识别慢查询或频繁执行的查询。</li></ul><p><strong>3. 慢查询日志（Slow Query Log）</strong></p><p><strong>(1) 定义</strong></p><ul><li><strong>慢查询日志</strong>记录了执行时间超过指定阈值的查询，有助于识别性能瓶颈。</li></ul><p><strong>(2) 配置</strong></p><ul><li><p>启用慢查询日志：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;</span><br></pre></td></tr></table></figure><p>设置慢查询的时间阈值（单位为秒）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> long_query_time <span class="operator">=</span> <span class="number">2</span>; <span class="comment">-- 记录执行时间超过2秒的查询</span></span><br></pre></td></tr></table></figure><p>在配置文件中也可以进行相应的设置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">slow_query_log_file</span>=/path/to/slow-query.log</span><br><span class="line"><span class="attr">long_query_time</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>(3) 使用场景</strong></p><ul><li>性能优化：通过分析慢查询日志，可以找到执行效率低下的查询并进行优化。</li><li>监控：持续监控慢查询日志可以帮助及时发现性能问题。</li></ul><p><img data-src="https://s2.loli.net/2025/03/30/afxo4iHyzStjgPR.png" alt="image-20250330155227205"></p><h3 id="Join连接"><a href="#Join连接" class="headerlink" title="Join连接"></a>Join连接</h3><p>join连接两个表</p><ul><li><strong>INNER JOIN</strong>：仅返回两个表中满足连接条件的记录。</li><li><strong>LEFT JOIN</strong>（或LEFT OUTER JOIN）：返回左表中的所有记录，以及右表中满足连接条件的记录。若右表无匹配记录则填充NULL。</li><li><strong>RIGHT JOIN</strong>（或RIGHT OUTER JOIN）：返回右表中的所有记录，以及左表中满足连接条件的记录。若左表无匹配记录则填充NULL。</li><li><strong>FULL JOIN</strong>（或FULL OUTER JOIN）：返回两个表中的所有记录，任何表中无匹配记录的部分用NULL填充。（注意：MySQL不直接支持此语法）</li><li><strong>CROSS JOIN</strong>：产生两个表的笛卡尔积。</li><li><strong>SELF JOIN</strong>：一个表与自身的连接，适用于查询具有层次结构的数据。</li></ul><p><code>%</code> 可以匹配任意长度的字符串（包括空字符串），而 <code>_</code> 总是代表一个单一字符.在SQL中，默认情况下并没有一个预设的转义字符用于 <code>LIKE</code> 查询中的通配符（如 <code>%</code> 和 <code>_</code>）转义。这意味着，如果你需要转义这些特殊字符，你必须明确指定一个转义字符，并通过 <code>ESCAPE</code> 关键字来定义它。</p><p>尽管没有默认的转义字符，但你可以选择一个不会出现在目标字符串中的字符作为转义字符。常用的转义字符包括反斜杠 <code>\</code> 或者感叹号 <code>!</code> 等。下面是如何使用 <code>ESCAPE</code> 来定义转义字符的例子：</p><p>如果想查找包含实际百分比符号 <code>%</code> 的记录，可以这样做：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">LIKE</span> <span class="string">&#x27;%\%%&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;\&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>\%</code> 表示实际的百分号字符 <code>%</code> 而不是通配符。</li><li><code>ESCAPE &#39;\&#39;</code> 告诉数据库 <code>\</code> 是转义字符。</li></ul><h2 id="PostgresSQL"><a href="#PostgresSQL" class="headerlink" title="PostgresSQL"></a>PostgresSQL</h2><p><a href="https://www.postgresql.org/">PostgreSQL: The world’s most advanced open source database</a></p><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p><a href="https://www.mongodb.com/docs/guides/">Start with Guides - Start with Guides</a></p><h1 id="持久层框架"><a href="#持久层框架" class="headerlink" title="持久层框架"></a>持久层框架</h1><h2 id="Mybatis✨"><a href="#Mybatis✨" class="headerlink" title="Mybatis✨"></a>Mybatis✨</h2><p><a href="https://mybatis.org/mybatis-3/zh_CN/index.html">MyBatis 3 | 简介 – mybatis</a></p><p><a href="https://www.bilibili.com/video/BV1VP4y1c7j7/">【尚硅谷】MyBatis零基础入门教程（细致全面，快速上手mybatis）_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1JP4y1Z73S/">MyBatis视频零基础入门到进阶，MyBatis全套视频教程源码级深入详解_哔哩哔哩_bilibili</a></p><p>持久层框架,简化JDBC开发,负责数据库的读写.</p><p>JDBC问题:硬编码 操作繁琐</p><h3 id="查询单表数据整体流程"><a href="#查询单表数据整体流程" class="headerlink" title="查询单表数据整体流程"></a>查询单表数据整体流程</h3><ol><li>创建表,插入数据</li><li>创建模块,导入maven</li><li>编写mybatis核心配置文件(替换连接信息,解决硬编码)</li><li>编写sql映射文件(统一管理sql语句)</li><li>编码: 定义POJO类  加载核心配置文件,获取sqlsessionfactory对象,执行sql语句</li></ol><h3 id="使用Mapper代理开发"><a href="#使用Mapper代理开发" class="headerlink" title="使用Mapper代理开发"></a>使用Mapper代理开发</h3><blockquote><p>创建mapper类,该类名称与命名空间相同,方法申明与mapper映射xml文件相同</p></blockquote><p>既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  Blog blog = (Blog) session.selectOne(<span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>诚然，这种方式能够正常工作，对使用旧版本 MyBatis 的用户来说也比较熟悉。但现在有了一种更简洁的方式——<strong>使用和指定语句的参数和返回值相匹配的接口（比如 BlogMapper.class），现在你的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换。</strong></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">  Blog blog = mapper.selectBlog(<span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/09/S12tudvJjEeoXTp.png" alt="image-20250309134454871"></p><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p>这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/config.properties&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dev_user&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;F2Fa3!33TYyg&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;multipleResultSetsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useColumnLabel&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PARTIAL&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingUnknownColumnBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;WARNING&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SIMPLE&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultStatementTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;25&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultFetchSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;safeRowBoundsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;localCacheScope&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SESSION&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;jdbcTypeForNull&quot;</span> <span class="attr">value</span>=<span class="string">&quot;OTHER&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadTriggerMethods&quot;</span> <span class="attr">value</span>=<span class="string">&quot;equals,clone,hashCode,toString&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="TypeAliases"><a href="#TypeAliases" class="headerlink" title="TypeAliases"></a>TypeAliases</h3><p>类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">  &lt;typeAlias <span class="built_in">alias</span>=<span class="string">&quot;Author&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;domain.blog.Author&quot;</span>/&gt;</span><br><span class="line">  &lt;typeAlias <span class="built_in">alias</span>=<span class="string">&quot;Blog&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;domain.blog.Blog&quot;</span>/&gt;</span><br><span class="line">  &lt;typeAlias <span class="built_in">alias</span>=<span class="string">&quot;Comment&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;domain.blog.Comment&quot;</span>/&gt;</span><br><span class="line">  &lt;typeAlias <span class="built_in">alias</span>=<span class="string">&quot;Post&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;domain.blog.Post&quot;</span>/&gt;</span><br><span class="line">  &lt;typeAlias <span class="built_in">alias</span>=<span class="string">&quot;Section&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;domain.blog.Section&quot;</span>/&gt;</span><br><span class="line">  &lt;typeAlias <span class="built_in">alias</span>=<span class="string">&quot;Tag&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;domain.blog.Tag&quot;</span>/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure><p>当这样配置时，<code>Blog</code> 可以用在任何使用 <code>domain.blog.Blog</code> 的地方。</p><p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;domain.blog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每一个在包 <code>domain.blog</code> 中的 Java Bean,<strong>在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名</strong>。 比如 <code>domain.blog.Author</code> 的别名为 <code>author</code>；若有注解，则别名为其注解值。见下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;author&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="typehandlers"><a href="#typehandlers" class="headerlink" title="typehandlers"></a>typehandlers</h3><p>MyBatis 在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。</p><h3 id="插件（plugins）"><a href="#插件（plugins）" class="headerlink" title="插件（plugins）"></a>插件（plugins）</h3><p>MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p><ul><li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li><li>ParameterHandler (getParameterObject, setParameters)</li><li>ResultSetHandler (handleResultSets, handleOutputParameters)</li><li>StatementHandler (prepare, parameterize, batch, update, query)</li></ul><p>这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 发行包中的源代码。 如果你想做的不仅仅是监控方法的调用，那么你最好相当了解要重写的方法的行为。 因为在试图修改或重写已有方法的行为时，很可能会破坏 MyBatis 的核心模块。 这些都是更底层的类和方法，所以使用插件的时候要特别当心。</p><p>通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExamplePlugin.java</span></span><br><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(</span><br><span class="line">  <span class="keyword">type</span>= Executor.class,</span><br><span class="line">  method = <span class="string">&quot;update&quot;</span>,</span><br><span class="line">  args = &#123;MappedStatement.class,<span class="built_in">Object</span>.class&#125;)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePlugin</span> <span class="title">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">Object</span> intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">    <span class="comment">// implement pre processing if need</span></span><br><span class="line">    <span class="built_in">Object</span> returnObject = invocation.proceed();</span><br><span class="line">    <span class="comment">// implement post processing if need</span></span><br><span class="line">    <span class="keyword">return</span> returnObject;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">setProperties</span>(<span class="params">Properties properties</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.properties = properties;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- mybatis-config.xml --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;org.mybatis.example.ExamplePlugin&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someProperty&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>上面的插件将会拦截在 Executor 实例中所有的 “update” 方法调用， 这里的 Executor 是负责执行底层映射语句的内部对象。</p><h3 id="xml映射器"><a href="#xml映射器" class="headerlink" title="xml映射器"></a>xml映射器</h3><p>MyBatis 的真正强大在于它的语句映射，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 致力于减少使用成本，让用户能更专注于 SQL 代码。</p><p>SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：</p><ul><li><code>cache</code> – 该命名空间的缓存配置。</li><li><code>cache-ref</code> – 引用其它命名空间的缓存配置。</li><li><code>resultMap</code> – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。</li><li><del><code>parameterMap</code> – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。文档中不会介绍此元素。</del></li><li><code>sql</code> – 可被其它语句引用的可重用语句块。</li><li><code>insert</code> – 映射插入语句。</li><li><code>update</code> – 映射更新语句。</li><li><code>delete</code> – 映射删除语句。</li><li><code>select</code> – 映射查询语句。</li></ul><p>常用属性</p><div class="table-container"><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>id</code></td><td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td><code>parameterType</code></td><td>将会传入这条语句的参数的类全限定名或别名。<strong>这个属性是可选的，因为 MyBatis 可以根据语句中实际传入的参数计算出应该使用的类型处理器</strong>（TypeHandler），默认值为未设置（unset）。</td></tr><tr><td><del>parameterMap</del></td><td><del>用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。</del></td></tr><tr><td><code>resultType</code></td><td>期望从这条语句中返回结果的类全限定名或别名。 注意，<strong>如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型</strong>。 resultType 和 resultMap 之间只能同时使用一个。</td></tr><tr><td><code>resultMap</code></td><td><strong>对外部 resultMap 的命名引用</strong>。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。</td></tr></tbody></table></div><p> 特殊字符处理,转义或CDATA区  </p><p>参数占位符:#{} ${}    </p><h3 id="参数映射"><a href="#参数映射" class="headerlink" title="参数映射"></a>参数映射</h3><p>​     鉴于参数类型（parameterType）会被自动设置为 <code>int</code>，这个参数可以随意命名。原始类型或简单数据类型（比如 <code>Integer</code> 和 <code>String</code>）因为没有其它属性，会用它们的值来作为参数。</p><p><img data-src="https://s2.loli.net/2025/03/10/u1fMijOcWHJGRTF.png" alt="image-20250310172440304"></p><p><img data-src="https://s2.loli.net/2025/03/10/ckaRKM5JnPW9FEB.png" alt="image-20250310182221930"></p><p><strong>不需要使用 <code>@Param</code> 的情况</strong></p><ol><li><p><strong>单个参数</strong>：如果你的 Mapper 方法只接受一个参数，那么你不需要使用 <code>@Param</code> 注解。MyBatis 会自动将这个参数映射到 SQL 语句中的占位符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">selectUserByUserName</span><span class="params">(String username)</span></span>;</span><br></pre></td></tr></table></figure><p>在对应的 XML 映射文件中可以直接引用该参数：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserByUserName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM users WHERE username = #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Java Bean 参数</strong>：如果你直接传递一个 Java Bean 对象作为参数，MyBatis 可以通过 OGNL 表达式访问 Bean 的属性，因此也不需要使用 <code>@Param</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">selectUserByCondition</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p>在 XML 文件中可以通过点符号访问属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM users WHERE username = #&#123;username&#125; AND age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>需要使用 <code>@Param</code> 的情况</strong></p><ol><li><p><strong>多个简单类型参数</strong>：如果 Mapper 方法接受多个简单类型的参数（如 <code>int</code>, <code>String</code> 等），你需要使用 <code>@Param</code> 来为每个参数指定一个名称，以便在 SQL 语句中引用它们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">selectUsersByAgeAndUsername</span><span class="params">(<span class="meta">@Param(&quot;age&quot;)</span> <span class="keyword">int</span> age, <span class="meta">@Param(&quot;username&quot;)</span> String username)</span></span>;</span><br></pre></td></tr></table></figure><p>在 XML 文件中可以这样引用这些参数：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id=<span class="string">&quot;selectUsersByAgeAndUsername&quot;</span> resultType=<span class="string">&quot;User&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age = #&#123;age&#125; <span class="keyword">AND</span> username = #&#123;username&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>为了提高代码可读性</strong>：即使只有一个参数，有时候为了增加代码的可读性和明确性，也可以选择使用 <code>@Param</code> 注解来命名参数。</p></li><li><p><strong>Map 类型参数</strong>：当使用 Map 传递参数时，通常也需要指定键名来访问值。在这种情况下，虽然不强制要求使用 <code>@Param</code>，但你可以通过 Map 的键来访问值。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; selectUsersByConditions(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; params);</span><br></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id=<span class="string">&quot;selectUsersByConditions&quot;</span> resultType=<span class="string">&quot;User&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age = #&#123;age&#125; <span class="keyword">AND</span> username = #&#123;username&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong></p><ul><li>如果是单个参数或者传递的是 Java Bean，则通常不需要使用 <code>@Param</code>。</li><li>当方法有多个简单类型参数时，必须使用 <code>@Param</code> 来为每个参数指定名称，以便在 SQL 语句中引用。</li><li>使用 <code>@Param</code> 还有助于提高代码的可读性和维护性，尤其是在参数较多或逻辑较为复杂的情况下。</li></ul><blockquote><p>Java Bean 是一种符合特定规范的 Java 类，主要用于封装数据。它是 Java 中的一种标准，旨在使对象更容易被复用和管理，尤其是在可视化开发工具中。一个典型的 Java Bean 通常具有以下特征：</p><p><strong>特征</strong></p><ol><li><strong>私有属性</strong>：类中的成员变量应该是私有的（<code>private</code>），这意味着它们不能直接从类外部访问。</li><li><strong>无参构造器</strong>：必须提供一个公共的无参构造函数（默认构造器），以便能够实例化对象而不需要传递任何参数。这是为了确保可以通过反射机制创建对象实例，比如在框架内部（如Spring, MyBatis）。</li><li><strong>getter 和 setter 方法</strong>：对于每个私有属性，应该提供公共的 getter（获取值）和 setter（设置值）方法。这允许外部代码安全地访问和修改这些属性的值。</li><li><strong>可序列化</strong>（可选）：如果需要在网络上传输对象或者保存到文件中，那么这个类应该实现 <code>Serializable</code> 接口。</li></ol></blockquote><p><img data-src="https://s2.loli.net/2025/03/10/odIl2cm87SBxpk3.png" alt="image-20250310110128114"></p><h3 id="结果映射"><a href="#结果映射" class="headerlink" title="结果映射"></a>结果映射</h3><p>返回结果如果包含多个值,可以使用map.</p><p>如果使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为领域模型。MyBatis 对两者都提供了支持。看看下面这个 JavaBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.someapp.model;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String hashedPassword;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> username;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.username = username;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getHashedPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hashedPassword;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHashedPassword</span><span class="params">(String hashedPassword)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hashedPassword = hashedPassword;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于 JavaBean 的规范，上面这个类有 3 个属性：id，username 和 hashedPassword。这些属性会对应到 select 语句中的列名。</p><p>这样的一个 JavaBean 可以被映射到 <code>ResultSet</code>，就像映射到 <code>HashMap</code> 一样简单。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.someapp.model.User&quot;</span>&gt;</span></span><br><span class="line">  select id, username, hashedPassword</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类型别名是你的好帮手。使用它们，你就可以不用输入类的全限定名了。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml 中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.someapp.model.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;User&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- SQL 映射 XML 中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  select id, username, hashedPassword</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这些情况下，<strong>MyBatis 会在幕后自动创建一个 <code>ResultMap</code>，再根据属性名来映射列到 JavaBean 的属性上</strong>。如果列名和属性名不能匹配上，可以在 SELECT 语句中设置列别名（这是一个基本的 SQL 特性）来完成匹配。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    user_id             as &quot;id&quot;,</span><br><span class="line">    user_name           as &quot;userName&quot;,</span><br><span class="line">    hashed_password     as &quot;hashedPassword&quot;</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在学习了上面的知识后，你会发现上面的例子没有一个需要显式配置 <code>ResultMap</code>，这就是 <code>ResultMap</code> 的优秀之处——你完全可以不用显式地配置它们。 虽然上面的例子不用显式配置 <code>ResultMap</code>。 但为了讲解，我们来看看如果在刚刚的示例中，显式使用外部的 <code>resultMap</code> 会怎样，这也是解决列名不匹配的另外一种方式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;hashed_password&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在引用它的语句中设置 <code>resultMap</code> 属性就行了（注意我们去掉了 <code>resultType</code> 属性）。比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span></span><br><span class="line">  select user_id, user_name, hashed_password</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>sql元素可以用来定义可重用的 SQL 代码片段，以便在其它语句中使用。 参数可以静态地（在加载的时候）确定下来，并且可以在不同的 include 元素中定义不同的参数值。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;userColumns&quot;</span>&gt;</span> $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个 SQL 片段可以在其它语句中使用，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;userColumns&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;alias&quot;</span> <span class="attr">value</span>=<span class="string">&quot;t1&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>,</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;userColumns&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;alias&quot;</span> <span class="attr">value</span>=<span class="string">&quot;t2&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  from some_table t1</span><br><span class="line">    cross join some_table t2</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以在 include 元素的 refid 属性或内部语句中使用属性值，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;sometable&quot;</span>&gt;</span></span><br><span class="line">  $&#123;prefix&#125;Table</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;someinclude&quot;</span>&gt;</span></span><br><span class="line">  from</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;$&#123;include_target&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    field1, field2, field3</span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;someinclude&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Some&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;include_target&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sometable&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在INSERT和UPDATE时,可以获取自增的字段值.设置useGeneratedKeys和<code>keyProperty</code></p><div class="table-container"><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>useGeneratedKeys</code></td><td>（仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。</td></tr><tr><td><code>keyProperty</code></td><td>（仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（<code>unset</code>）。如果生成列不止一个，可以用逗号分隔多个属性名称。</td></tr></tbody></table></div><ul><li><strong><code>&lt;insert&gt;</code></strong>：用于插入新记录，返回受影响的行数或通过配置获取自增主键。</li><li><strong><code>&lt;update&gt;</code></strong>：用于更新现有记录，返回受影响的行数。</li><li><strong><code>&lt;delete&gt;</code></strong>：用于删除记录，返回受影响的行数。</li></ul><h3 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h3><ul><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li></ul><p><img data-src="https://s2.loli.net/2025/03/10/NjzLtSgZ9UKIQWC.png" alt="image-20250310114956563"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。</p><p>用于动态更新语句的类似解决方案叫做 <em>set</em>。<em>set</em> 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span></span><br><span class="line">  update Author</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个例子中，<em>set</em> 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。</p><p>或者，你可以通过使用<em>trim</em>元素来达到同样的效果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，我们覆盖了后缀值设置，并且自定义了前缀值</p><blockquote><p>可以使用mybatisx插件提升开发效率</p></blockquote><p><strong>相关视频</strong></p><ol><li><a href="https://www.bilibili.com/video/BV1MT4y1k7wZ/">黑马mybatis教程全套视频教程，2天Mybatis框架从入门到精通_哔哩哔哩_bilibili</a></li><li><a href="https://www.bilibili.com/video/BV1G5411H7F8">快速上手mybatis</a></li><li><a href="https://www.bilibili.com/video/BV1VP4y1c7j7">MyBatis零基础入门教程</a></li></ol><h3 id="mybatis-plus"><a href="#mybatis-plus" class="headerlink" title="mybatis-plus"></a>mybatis-plus</h3><p>MyBatis-Plus 是一个 MyBatis 的增强工具，旨在简化开发、减少工作量。它不仅<strong>封装了 CRUD 操作，还提供了代码生成器、分页插件</strong>等实用功能。</p><p>MyBatis-Plus 提供了 <code>QueryWrapper</code> 和 <code>UpdateWrapper</code> 两个主要的条件构造器，用于进行复杂查询和更新操作。</p><p><strong>QueryWrapper</strong></p><p><code>QueryWrapper</code> 用于查询条件的构造，支持链式调用。</p><ul><li><strong>等值查询</strong>：<code>eq(&quot;name&quot;, &quot;Tom&quot;)</code></li><li><strong>范围查询</strong>：<code>between(&quot;age&quot;, 18, 30)</code></li><li><strong>模糊查询</strong>：<code>like(&quot;name&quot;, &quot;Tom&quot;)</code></li><li><strong>排序</strong>：<code>orderByAsc(&quot;age&quot;)</code>，<code>orderByDesc(&quot;age&quot;)</code></li><li><strong>分组查询</strong>：<code>groupBy(&quot;age&quot;)</code></li><li><strong>限制查询数量</strong>：<code>last(&quot;limit 10&quot;)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEditQueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">queryWrapper.eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tom&quot;</span>).gt(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line">List&lt;User&gt; users = userService.list(queryWrapper);</span><br></pre></td></tr></table></figure><p><strong>UpdateWrapper</strong></p><p><code>UpdateWrapper</code> 用于更新操作，支持条件和修改字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEditUpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> UpdateWrapper&lt;&gt;();</span><br><span class="line">updateWrapper.eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tom&quot;</span>).set(<span class="string">&quot;age&quot;</span>, <span class="number">30</span>);</span><br><span class="line">userService.update(<span class="keyword">null</span>, updateWrapper);</span><br></pre></td></tr></table></figure><p><strong>分页操作</strong></p><p><strong>分页查询</strong></p><p>MyBatis-Plus 提供了 <code>Page</code> 类用于分页查询。</p><ul><li><p><strong><code>page(Page&lt;T&gt; page)</code></strong>: 分页查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEditPage&lt;User&gt; page = <span class="keyword">new</span> Page&lt;&gt;(<span class="number">1</span>, <span class="number">10</span>);  <span class="comment">// 页码和每页条数</span></span><br><span class="line">Page&lt;User&gt; userPage = userService.page(page);</span><br></pre></td></tr></table></figure></li><li><p><strong><code>page(Page&lt;T&gt; page, QueryWrapper&lt;T&gt; queryWrapper)</code></strong>: 带条件的分页查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEditQueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">queryWrapper.eq(<span class="string">&quot;age&quot;</span>, <span class="number">25</span>);</span><br><span class="line">Page&lt;User&gt; userPage = userService.page(page, queryWrapper);</span><br></pre></td></tr></table></figure></li></ul><p>链式调用是一种非常方便的查询方式，它允许开发者通过流式 API 构建复杂的查询条件</p><div class="table-container"><table><thead><tr><th>类型</th><th>示例方法</th><th>功能描述</th></tr></thead><tbody><tr><td><strong>查询</strong></td><td><code>query()</code>, <code>lambdaQuery()</code></td><td>构建查询条件并获取结果</td></tr><tr><td><strong>更新</strong></td><td><code>update()</code>, <code>lambdaUpdate()</code></td><td>构建更新条件并执行更新</td></tr><tr><td><strong>删除</strong></td><td><code>remove()</code>, <code>lambdaRemove()</code></td><td>构建删除条件并执行删除</td></tr><tr><td><strong>条件组合</strong></td><td><code>and()</code>, <code>or()</code>, <code>nested()</code></td><td>支持复杂条件组合</td></tr><tr><td><strong>排序与分组</strong></td><td><code>orderByAsc()</code>, <code>orderByDesc()</code>, <code>groupBy()</code></td><td>支持排序、分组等操作</td></tr></tbody></table></div><h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><p><a href="https://www.geeksforgeeks.org/hibernate-native-sql/?ref=next_article_top">Hibernate - Native SQL - GeeksforGeeks</a></p><p><a href="https://docs.jboss.org/hibernate/orm/6.5/quickstart/html_single/#hibernate-gsg-tutorial-annotations-entity">Getting Started with Hibernate</a></p><p><strong>maven依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.orm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.6.10.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置</strong></p><p>配置文件hibernate.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Database connection settings</span></span><br><span class="line"><span class="meta">hibernate.connection.url</span>=<span class="string">jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1</span></span><br><span class="line"><span class="meta">hibernate.connection.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="meta">hibernate.connection.password</span>=<span class="string"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Echo all executed SQL to console</span></span><br><span class="line"><span class="meta">hibernate.show_sql</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">hibernate.format_sql</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">hibernate.highlight_sql</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Automatically export the schema</span></span><br><span class="line"><span class="meta">hibernate.hbm2ddl.auto</span>=<span class="string">create</span></span><br></pre></td></tr></table></figure><p><strong>创建注解实体类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>   </span><br><span class="line"><span class="meta">@Table(name = &quot;Events&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Id</span>   </span><br><span class="line"><span class="meta">@GeneratedValue</span>   </span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@Column(name = &quot;eventDate&quot;)</span>   </span><br><span class="line"><span class="keyword">private</span> LocalDateTime date;</span><br><span class="line">    <span class="comment">//实体其他字段默认被认为是持久的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用sessionFactory</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// A SessionFactory is set up once for an application!</span></span><br><span class="line">    <span class="keyword">final</span> StandardServiceRegistry registry =</span><br><span class="line">            <span class="keyword">new</span> StandardServiceRegistryBuilder()</span><br><span class="line">                    .build();     </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sessionFactory =</span><br><span class="line">                <span class="keyword">new</span> MetadataSources(registry)             </span><br><span class="line">                        .addAnnotatedClass(Event.class)   </span><br><span class="line">                        .buildMetadata()                  </span><br><span class="line">                        .buildSessionFactory();           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// The registry would be destroyed by the SessionFactory, but we</span></span><br><span class="line">        <span class="comment">// had trouble building the SessionFactory so destroy it manually.</span></span><br><span class="line">        StandardServiceRegistryBuilder.destroy(registry);</span><br><span class="line">    &#125;</span><br><span class="line">    sessionFactory.inTransaction(session -&gt; &#123;   </span><br><span class="line">    session.persist(<span class="keyword">new</span> Event(<span class="string">&quot;Our very first event!&quot;</span>, now()));   </span><br><span class="line">    session.persist(<span class="keyword">new</span> Event(<span class="string">&quot;A follow up event&quot;</span>, now()));</span><br><span class="line">&#125;);</span><br><span class="line">    sessionFactory.inTransaction(session -&gt; &#123;</span><br><span class="line">    session.createSelectionQuery(<span class="string">&quot;from Event&quot;</span>, Event.class)   </span><br><span class="line">            .getResultList()   </span><br><span class="line">            .forEach(event -&gt; out.println(<span class="string">&quot;Event (&quot;</span> + event.getDate() + <span class="string">&quot;) : &quot;</span> + event.getTitle()));</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是native hibernate APIs</p><p>此外还可以使用JPA标准APIs</p><blockquote><p>5.x版本的hibernate使用cfg和hbm提供映射,但新版本已经不用了.</p></blockquote><p>&gt;</p><blockquote><p>JPA全称为Java Persistence API（Java持久层API），它是Sun公司在JavaEE 5中提出的Java持久化规范。它为Java开发人员提供了一种对象/关联映射工具，来管理Java应用中的关系数据，JPA吸取了目前Java持久化技术的优点，旨在规范、简化Java对象的持久化工作。很多ORM框架都是实现了JPA的规范，如：Hibernate、EclipseLink。</p><p>需要注意的是JPA统一了Java应用程序访问ORM框架的规范</p><p><strong>JPA为我们提供了以下规范：</strong></p><ol><li>ORM映射元数据：JPA支持XML和注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中</li><li>JPA 的API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发人员不用再写SQL了</li><li>JPQL查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。</li></ol></blockquote><h2 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h2><blockquote><p>Spring Data是Spring 社区的一个子项目，主要用于简化数据（关系型&amp;非关系型）访问，其主要目标是使得数据库的访问变得方便快捷。</p><p>Spring Data JPA是在实现了JPA规范的基础上封装的一套 JPA 应用框架，虽然ORM框架都实现了JPA规范，但是在不同的ORM框架之间切换仍然需要编写不同的代码，而使用Spring Data JPA能够方便大家在不同的ORM框架之间进行切换而不需要更改代码。</p></blockquote><p><a href="https://docs.spring.io/spring-data/jpa/reference/repositories/core-concepts.html">Core concepts :: Spring Data JPA</a></p><p>Spring Data JPA往往搭配Spring以及SpringBoot使用.</p><p><strong>使用注解创建POJO类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getters and setters omitted for brevity</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>声明仓库接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">save</span><span class="params">(Person person)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Optional&lt;Person&gt; <span class="title">findById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用仓库</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(name);</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>增加自定义的CRUD方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findByName</span><span class="params">(String name)</span></span>; <span class="comment">// 根据名字查找用户</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照相关规范生成相应JPQL查询.</p><p>基本原则</p><ol><li><strong>实体属性作为基础</strong>：查询方法通常基于实体类中的属性名称构建。例如，如果你有一个 <code>User</code> 实体，并且这个实体有一个 <code>name</code> 属性，你可以创建一个以 <code>findByName</code> 开头的方法来查找具有特定名称的所有用户。</li><li><strong>关键词用于指定操作</strong>：在方法名中使用特定的关键字可以指定你想要执行的操作类型（如查找、计数等）以及查询条件（如等于、包含等）。</li></ol><p>对于更复杂的查询需求，如果方法名约定不能满足要求，可以使用 <code>@Query</code> 注解直接定义JPQL或原生SQL查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Query(&quot;select u from User u where u.emailAddress = ?1&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(String emailAddress)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用原生SQL：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(value = &quot;SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?1&quot;, nativeQuery = true)</span></span><br><span class="line"><span class="function">User <span class="title">findByEmailAddress</span><span class="params">(String emailAddress)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="消息组件"><a href="#消息组件" class="headerlink" title="消息组件"></a>消息组件</h1><h2 id="Redis✨"><a href="#Redis✨" class="headerlink" title="Redis✨"></a>Redis✨</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>Redis 的主要特性</strong></p><ul><li><strong>高性能</strong>：所有数据都存储在内存中，读写速度非常快。</li><li><strong>持久化</strong>：支持 RDB 和 AOF 两种方式将内存中的数据保存到硬盘上，以防止数据丢失。</li><li><strong>复制功能</strong>：支持主从复制，可以提高系统的可用性和扩展性。</li><li><strong>事务支持</strong>：通过 MULTI, EXEC, DISCARD 和 WATCH 等命令实现简单的事务管理。</li><li><strong>发布订阅模式</strong>：支持 Pub/Sub 消息传递模式。</li><li><strong>Lua 脚本支持</strong>：允许用户执行自定义逻辑，保证原子性。</li><li><strong>键过期时间</strong>：可以为每个键设置生存时间，过期后自动删除。</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Redis 主要支持以下几种数据类型：</p><ul><li><strong>string（字符串）:</strong> 基本的数据存储单元，可以存储字符串、整数或者浮点数。</li><li><strong>hash（哈希）:</strong>一个键值对集合，可以存储多个字段。</li><li><strong>list（列表）:</strong>一个简单的列表，可以存储一系列的字符串元素。</li><li><strong>set（集合）:</strong>一个无序集合，可以存储不重复的字符串元素。</li><li><strong>zset(sorted set：有序集合):</strong> 类似于集合，但是每个元素都有一个分数（score）与之关联。</li><li><strong>位图（Bitmaps）：</strong>基于字符串类型，可以对每个位进行操作。</li><li><strong>超日志（HyperLogLogs）：</strong>用于基数统计，可以估算集合中的唯一元素数量。</li><li><strong>地理空间（Geospatial）：</strong>用于存储地理位置信息。</li><li><strong>发布/订阅（Pub/Sub）：</strong>一种消息通信模式，允许客户端订阅消息通道，并接收发布到该通道的消息。</li><li><strong>流（Streams）：</strong>用于消息队列和日志存储，支持消息的持久化和时间排序。</li><li><strong>模块（Modules）：</strong>Redis 支持动态加载模块，可以扩展 Redis 的功能。</li></ul><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>基本编码方式是RAW,基于简单动态字符串实现. 存储上限512MB.</p><p>如果存储的SDS长度小于44字节,则会采用EMBSTR,此时object head与SDSS是连续空间.</p><p>如果是整数值,并且在LONG_MAX之内,采用INT编码.不需要SDS部分,ptr直接指向整数.</p><p><img data-src="https://s2.loli.net/2025/03/26/sjPGpMUlIBCfXrg.png" alt="image-20250326102935636"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object encoding key <span class="comment"># 查询编码方式</span></span><br></pre></td></tr></table></figure><h4 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h4><p>从首、尾操作元素的列表</p><p><img data-src="https://s2.loli.net/2025/03/26/ALHs6CkcYGnB8me.png" alt="image-20250326103337835"></p><p><img data-src="https://s2.loli.net/2025/03/26/4JMB7i9FwZpSLVW.png" alt="image-20250326104058671"></p><h4 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h4><p>单列集合,不保证有序性,保证元素唯一,求交集、并集和差集.</p><p>set采用HT编码(Dict),key用来存储元素,value统一为null.</p><p>当存储的所有数据为整数,并且元素数量不超过set-max-intset-entries时,Set会采用IntSet编码,节省内存.</p><p><img data-src="https://s2.loli.net/2025/03/26/sKmpPezAdXafgn4.png" alt="image-20250326105453513"></p><h4 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h4><p>每个元素指定一个score值</p><p><img data-src="https://s2.loli.net/2025/03/26/UhEFYszHKGQjTBt.png" alt="image-20250326111021533"></p><p><img data-src="https://s2.loli.net/2025/03/26/8d5MsA1VqQovZXc.png" alt="image-20250326111516132"></p><p><img data-src="https://s2.loli.net/2025/03/26/n8DoQbwTMVa5FZY.png" alt="image-20250326112849287"></p><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p><img data-src="https://s2.loli.net/2025/03/26/4BPamIhnFEviQWy.png" alt="image-20250326113333031"></p><p><img data-src="https://s2.loli.net/2025/03/26/D25tMOAiSJjCx1n.png" alt="image-20250326113448318"></p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指客户端请求的数据在缓冲中和数据库中都不存在,这样缓存永远不会起作用,这些请求直接访问数据库.</p><h4 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h4><p>对于查询结果为空的数据，也可以将其缓存起来（通常设置较短的过期时间），这样当同样的请求再次到来时，可以直接从缓存中获取结果而不需要访问数据库。</p><p><img data-src="https://s2.loli.net/2025/03/25/Xij1Npoe8xrqcS3.png" alt="image-20250325171102410"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试从缓存获取数据</span></span><br><span class="line">    Object value = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果缓存未命中，则尝试从数据库获取</span></span><br><span class="line">    value = db.query(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 对于不存在的数据也进行缓存，但设置较短的过期时间</span></span><br><span class="line">        cache.put(key, <span class="string">&quot;NULL&quot;</span>, SHORT_EXPIRE_TIME);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点:实现简单,维护方便</p><p>缺点:额外的内存消耗,可能造成短期的不一致</p><h4 id="布隆过滤"><a href="#布隆过滤" class="headerlink" title="布隆过滤"></a>布隆过滤</h4><p>使用布隆过滤器可以在内存中高效地判断一个元素是否在一个集合中。它通过多个哈希函数将元素映射到位数组中的几个点，设置这些点为1。查询时，只要有一个对应的位不是1，就可以确定该元素不在集合中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例伪代码</span></span><br><span class="line">BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(), expectedInsertions);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载所有可能存在的key到布隆过滤器中</span></span><br><span class="line"><span class="keyword">for</span> (String key : allPossibleKeys) &#123;</span><br><span class="line">    bloomFilter.put(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mightContain</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bloomFilter.mightContain(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/25/axN3ZGnYCrV2dt1.png" alt="image-20250325173115631"></p><p>在实际应用中，你可以在查询之前先用布隆过滤器检查是否存在该键，只有当布隆过滤器认为该键可能存在时，才去数据库查询并更新缓存。</p><ul><li><strong>优点</strong>：节省空间且查询速度快。</li><li><strong>缺点</strong>：有一定的误判率，即可能存在某些元素实际上不在集合中却被认为存在的假阳性情况，但对于缓存穿透问题来说，这通常是可接受的。</li></ul><p>其他方法</p><p> <strong>接口限流与用户行为分析</strong></p><p><strong>合理的缓存策略设计</strong></p><p><img data-src="https://s2.loli.net/2025/03/25/Aaehzxr8njmpCbq.png" alt="image-20250325175340534"></p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指在某个时间段内，<strong>大量的缓存数据同时过期失效，导致大量请求直接打到后端数据库或其他数据源上</strong>，造成服务器负载急剧增加，甚至可能导致系统崩溃的现象。这种情况通常发生在缓存层突然不可用或者缓存策略设计不合理时。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li><strong>设置不同的缓存过期时间</strong></li></ol><p>随机化过期时间,为避免大量缓存同时过期，可以在设定缓存的有效期时加入一定的随机性。例如，原本所有缓存的有效期都是1小时，现在可以设置成1小时±5分钟，这样可以分散缓存失效的时间点。</p><ol><li><strong>双缓存机制</strong></li></ol><p>实现两个级别的缓存，一级缓存用于快速响应请求，二级缓存则在一级缓存失效时提供支持。当一级缓存中的数据过期后，仍然可以从二级缓存中获取数据，从而减轻对数据库的压力。</p><p><strong>其他</strong></p><p>利用Redis集群提高服务可用性</p><p>给缓存业务添加降级限流策略</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>缓存击穿</strong>是指一个非常热门的key，在缓存失效的瞬间，大量的请求同时访问这个key，由于此时缓存中没有该数据（已经过期或被删除），这些请求会直接打到数据库上，导致数据库压力骤增。这种情况类似于“击穿”了缓存层，直接冲击后端存储。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>1,  互斥锁</p><p>使用互斥锁可以在缓存失效时只允许一个线程去查询数据库并更新缓存，其他线程等待该线程完成后再从缓存中读取数据。这种方法能有效避免大量线程同时访问数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    String lockKey = <span class="string">&quot;lock:&quot;</span> + key;</span><br><span class="line">    Object value = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// 缓存未命中</span></span><br><span class="line">        <span class="keyword">synchronized</span>(lockKey.intern()) &#123; <span class="comment">// 使用字符串内部池作为锁对象</span></span><br><span class="line">            value = cache.get(key); <span class="comment">// 再次检查缓存，防止其他线程已经填充了缓存</span></span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                value = db.query(key); <span class="comment">// 查询数据库</span></span><br><span class="line">                cache.put(key, value); <span class="comment">// 更新缓存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/25/I2n1hxzA8XteQP5.png" alt="image-20250325205849705"></p><p>利用<code>setnx</code>实现互斥逻辑.</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> solvePassthrough(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 查询缓存是否存在</span></span><br><span class="line">    <span class="keyword">String</span> s = redisTemplate.opsForValue().<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">    <span class="keyword">if</span>(s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//存在直接返回</span></span><br><span class="line">        <span class="keyword">return</span> s ;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 不存在 s==null,表示不存在</span></span><br><span class="line">        <span class="comment">// 2. 缓存不存在，尝试拿锁</span></span><br><span class="line">        Boolean b = tryLock(<span class="built_in">key</span>);</span><br><span class="line">        <span class="keyword">if</span>(b) &#123;</span><br><span class="line">            <span class="comment">//3. 拿到锁，查询数据库</span></span><br><span class="line">            <span class="comment">//&quot;select * from table where key = &quot; + key;</span></span><br><span class="line">            <span class="keyword">String</span> result = <span class="string">&quot;result&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 数据库查询 没找到数据</span></span><br><span class="line">                <span class="comment">// 设置空缓存对象 避免缓存穿透</span></span><br><span class="line">                redisTemplate.opsForValue().<span class="built_in">set</span>(<span class="built_in">key</span>, <span class="string">&quot;&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">                unlock(<span class="built_in">key</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//4. 查询数据库后，将数据放入缓存</span></span><br><span class="line">            redisTemplate.opsForValue().<span class="built_in">set</span>(<span class="built_in">key</span>, result, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="comment">//5. 释放锁</span></span><br><span class="line">            unlock(<span class="built_in">key</span>);</span><br><span class="line">            <span class="comment">// 返回结果</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//4. 没有拿到锁,等待重试</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> solvePassthrough(<span class="built_in">key</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock(<span class="built_in">key</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Boolean tryLock(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    Boolean b = redisTemplate.opsForValue().setIfAbsent(<span class="built_in">key</span>, <span class="string">&quot;1&quot;</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> unlock(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    redisTemplate.delete(<span class="built_in">key</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.逻辑过期</p><p>对于一些极其重要的热点数据，可以考虑将其缓存设置为永不过期。但是这种方式需要配合后台异步任务定期刷新缓存中的数据，以确保数据的时效性。</p><p><img data-src="https://s2.loli.net/2025/03/25/2FKGxVs6pUu5d3g.png" alt="image-20250325205936982"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们有一个后台任务定期执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshHotData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String hotKey = <span class="string">&quot;hot_data&quot;</span>;</span><br><span class="line">    Object newValue = db.query(hotKey); <span class="comment">// 从数据库获取最新数据</span></span><br><span class="line">    cache.put(hotKey, newValue); <span class="comment">// 更新缓存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在业务逻辑中获取数据时，直接从缓存读取即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getHotData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(<span class="string">&quot;hot_data&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以增加过期时间,在业务层进行判断,如果实际已经过期(此时Redis中仍有数据,因为没有超过TTL). 则创建线程更新数据并写入缓存(加锁),原本线程返回过期数据.</p></blockquote><p><img data-src="https://s2.loli.net/2025/03/25/KnfBu1UqX9DrAEW.png" alt="image-20250325182959630"></p><h3 id="内存持久化"><a href="#内存持久化" class="headerlink" title="内存持久化"></a>内存持久化</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>Redis <strong>SAVE</strong> 命令用于创建当前数据库的备份</p><p>创建 redis 备份文件也可以使用命令 <strong>BGSAVE</strong>，该命令在后台执行。</p><p>basave会fork主进程得到子进程,子进程共享主进程的内存数据,完成fork后读取内存数据写入RDB文件.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">################################ SNAPSHOTTING </span><br><span class="line">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="line">#</span><br><span class="line">#   It is also possible to remove all the previously configured save</span><br><span class="line">#   points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save &quot;&quot;</span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">rdbcompression yes</span><br><span class="line"># The filename where to dump the DB</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"># The working directory.</span><br><span class="line">#</span><br><span class="line"># The DB will be written inside this directory, with the filename specified</span><br><span class="line"># above using the &#x27;dbfilename&#x27; configuration directive.</span><br><span class="line">#</span><br><span class="line"># The Append Only File will also be created inside this directory.</span><br><span class="line">#</span><br><span class="line"># Note that you must specify a directory here, not a file name.</span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/25/UYWLnOzjM3FitKD.png" alt="image-20250325220031131"></p><p><img data-src="https://s2.loli.net/2025/03/25/vSzoKf3ibdCDQw2.png" alt="image-20250325220501005"></p><p><img data-src="https://s2.loli.net/2025/03/25/ObYogUBk1F5Xi3C.png" alt="image-20250325220624058"></p><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>APPEND ONLY  MODE</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span> APPEND ONLY MODE <span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">#</span></span><br><span class="line"><span class="comment"># still running correctly.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># AOF and RDB persistence can be enabled at the same time without problems.</span></span><br><span class="line"><span class="comment"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span></span><br><span class="line"><span class="comment"># with the better durability guarantees.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Please check http://redis.io/topics/persistence for more information.</span></span><br><span class="line"></span><br><span class="line">appendonly <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The name of the append only file (default: &quot;appendonly.aof&quot;)</span></span><br><span class="line"></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"><span class="comment"># The default is &quot;everysec&quot;, as that&#x27;s usually the right compromise between</span></span><br><span class="line"><span class="comment"># speed and data safety. It&#x27;s up to you to understand if you can relax this to</span></span><br><span class="line"><span class="comment"># &quot;no&quot; that will let the operating system flush the output buffer when</span></span><br><span class="line"><span class="comment"># it wants, for better performances (but if you can live with the idea of</span></span><br><span class="line"><span class="comment"># some data loss consider the default persistence mode that&#x27;s snapshotting),</span></span><br><span class="line"><span class="comment"># or on the contrary, use &quot;always&quot; that&#x27;s very slow but a bit safer than</span></span><br><span class="line"><span class="comment"># everysec.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># More details please check the following article:</span></span><br><span class="line"><span class="comment"># http://antirez.com/post/redis-persistence-demystified.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If unsure, use &quot;everysec&quot;.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># appendfsync no</span></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/25/eVhk1jS2WB9H7Za.png" alt="image-20250325221116370"></p><p>使用<code>bgrewriteaof</code>节省AOF文件,因为记录的AOF命令可能多余(比如后面的更新了前面的值)</p><p><img data-src="https://s2.loli.net/2025/03/25/KvqyuzAp4XeFJE8.png" alt="image-20250325222257850"></p><p><img data-src="https://s2.loli.net/2025/03/25/hL2vHmQEdOAuocX.png" alt="image-20250325222328632"></p><h3 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h3><p>Redis 提供了一种简单的事务机制，它<strong>允许用户将多个命令打包成一个事务进行执行</strong>。与传统数据库中的事务不同<strong>，Redis 的事务并不支持回滚（rollback）操作</strong>。</p><p>Redis 事务的关键命令</p><ul><li><strong>MULTI</strong>：标记一个事务块的开始。一旦调用了 <code>MULTI</code> 命令，客户端会进入事务模式，在这种模式下所有的后续命令都会被放入队列中等待执行，而不是立即执行。</li><li><strong>EXEC</strong>：执行所有在 <code>MULTI</code> 和 <code>EXEC</code> 之间的命令。当调用 <code>EXEC</code> 时，Redis 会顺序地执行事务队列中的每个命令，并返回每个命令的结果。</li><li><strong>DISCARD</strong>：取消事务，放弃执行事务队列中的所有命令并退出事务模式。</li><li><p><strong>WATCH</strong>：用于监控一个或多个键，如果这些键在事务执行之前被其他客户端修改了，则事务会被中断，<code>EXEC</code> 返回 <code>nil</code> 表示事务未成功执行。这为 Redis 提供了一种乐观锁机制。</p></li><li><p><strong>原子性</strong>：虽然 Redis 的事务保证了命令序列要么全部执行，要么一个都不执行，但是 Redis 并不支持回滚功能。这意味着如果有任何命令执行失败，其余命令仍将继续执行。</p></li><li><strong>乐观锁</strong>：通过 <code>WATCH</code> 命令实现的乐观锁机制可以在一定程度上解决并发修改的问题。例如，在对某个键进行修改前先 <code>WATCH</code> 它，然后执行一系列的操作，最后通过 <code>EXEC</code> 提交事务。如果在这期间有其他客户端修改了该键，则当前事务将被中断，<code>EXEC</code> 将返回 <code>nil</code>。</li></ul><blockquote><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p><p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WATCH mykey</span><br><span class="line">... <span class="comment"># 其他客户端可能在此期间修改了 mykey</span></span><br><span class="line">MULTI</span><br><span class="line">SET mykey newValue</span><br><span class="line">EXEC <span class="comment"># 如果 mykey 在 WATCH 后被修改过，EXEC 将返回 nil</span></span><br></pre></td></tr></table></figure><h2 id="RabbitMQ✨"><a href="#RabbitMQ✨" class="headerlink" title="RabbitMQ✨"></a>RabbitMQ✨</h2><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><ol><li><strong>Topic（主题）</strong></li></ol><ul><li>Kafka 中的 Topic 类似于数据库中的表，用于对消息进行分类。每个消息都会被发布到一个特定的 Topic 下。</li></ul><ol><li><strong>Partition（分区）</strong></li></ol><ul><li>每个 Topic 可以被划分为多个 Partition，Partition 是 Kafka 中数据的基本存储单元。每个 Partition 内部的消息是有序的。</li></ul><ol><li><strong>Producer（生产者）</strong></li></ol><ul><li>Producer 是向 Kafka 中发布消息的客户端应用程序。它将消息发送到指定的 Topic。<a href="https://kafka.apachecn.org/1/?utm_source=chatgpt.com">kafka.apachecn.org+1support.huaweicloud.com+1</a></li></ul><ol><li><strong>Consumer（消费者）</strong></li></ol><ul><li>Consumer 是从 Kafka 中订阅并消费消息的客户端应用程序。它从指定的 Topic 中读取消息。</li></ul><ol><li><strong>Consumer Group（消费者组）</strong></li></ol><ul><li>Consumer Group 是一组 Consumer 的集合，Kafka 会将一个 Topic 的消息分发给 Consumer Group 中的各个 Consumer，每个消息只会被 Consumer Group 中的一个 Consumer 消费。<a href="https://www.cnblogs.com/zjdxr-up/p/15000181.html?utm_source=chatgpt.com">博客园</a></li></ul><ol><li><strong>Broker（代理）</strong></li></ol><ul><li>Broker 是 Kafka 集群中的一个节点，负责接收、存储和转发消息。一个 Kafka 集群由多个 Broker 组成。<a href="https://www.cnblogs.com/zjdxr-up/p/15000181.html?utm_source=chatgpt.com">博客园</a></li></ul><ol><li><strong>Cluster（集群）</strong></li></ol><ul><li>Kafka 集群由多个 Broker 组成，提供高可用性和水平扩展能力。每个 Broker 都可以处理消息的读写请求。<a href="https://blog.csdn.net/weixin_37693463/article/details/144621118?utm_source=chatgpt.com">CSDN+1CSDN+1</a></li></ul><ol><li><strong>Zookeeper</strong></li></ol><ul><li>Zookeeper 是 Kafka 的协调服务，用于管理和协调 Kafka 集群中的 Broker 元数据。Kafka 2.8.0 以后，Kafka 引入了 KRaft 模式，逐步减少对 Zookeeper 的依赖。</li></ul><ol><li><strong>Offset（偏移量）</strong></li></ol><ul><li>Offset 是 Kafka 中每条消息在 Partition 中的唯一标识符。Consumer 通过 Offset 来追踪已消费的消息。</li></ul><ol><li><strong>Replication（副本）</strong></li></ol><ul><li>Kafka 支持对 Topic 的 Partition 进行副本复制，以提高数据的可靠性和容错能力。每个 Partition 可以有多个副本，其中一个副本为 Leader，其他为 Follower。</li></ul><ol><li><strong>Retention（消息保留）</strong></li></ol><ul><li>Kafka 允许设置消息的保留策略，可以根据时间（如 7 天）或空间（如 1 GB）来控制消息的保留期限。超过保留期限的消息会被删除。</li></ul><ol><li><strong>Consumer Lag（消费者滞后）</strong></li></ol><ul><li>Consumer Lag 是指 Consumer 当前消费的 Offset 与 Partition 中最新消息的 Offset 之间的差距。较大的 Consumer Lag 可能意味着 Consumer 的消费速度跟不上生产者的生产速度。</li></ul><h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><h1 id="网络编程框架"><a href="#网络编程框架" class="headerlink" title="网络编程框架"></a>网络编程框架</h1><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p>Netty 是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能协议服务器和客户端。它简化了网络编程的复杂性，使得开发者能够专注于业务逻辑而非底层细节。以下是 Netty 的一些重要概念、经典例子以及在使用时需要注意的地方。</p><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><ol><li><strong>Channel</strong>：表示一个打开的连接，可以是TCP/IP连接、UDP连接等。每个Channel都关联了一个ChannelPipeline，用于处理入站和出站事件。</li><li><strong>EventLoop</strong>：负责处理Channel上的I/O操作。每个EventLoop通常绑定到单个线程上，并且管理多个Channel实例。</li><li><strong>ChannelHandler</strong>：实现对Channel中数据的处理逻辑。它可以是入站处理器（如解码器）或出站处理器（如编码器）。ChannelHandler可以通过ChannelPipeline链式地组织起来。</li><li><strong>ChannelPipeline</strong>：为每个Channel提供一个ChannelHandler实例的链表结构，用于处理通道中的事件流。你可以根据需要添加、删除或替换这些处理器。</li><li><strong>Bootstrap 和 ServerBootstrap</strong>：分别用于配置客户端和服务端的启动参数。它们提供了简单的方法来设置各种属性，比如通道类型、事件循环组等。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> EchoServer(<span class="number">8080</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(group)</span><br><span class="line">             .channel(NioServerSocketChannel.class)</span><br><span class="line">             .localAddress(<span class="keyword">new</span> InetSocketAddress(port))</span><br><span class="line">             .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> EchoServerHandler());</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture f = b.bind().sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;Server started and listening on &quot;</span> + f.channel().localAddress());</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully().sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ByteBuf in = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;Server received: &quot;</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class="line">        ctx.write(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring家族✨"><a href="#Spring家族✨" class="headerlink" title="Spring家族✨"></a>Spring家族✨</h1><p>Spring提供依赖注入(DI),控制反转(IOC),面向切面编程等,为Java开发提供便利.而SpringMVC提供了比纯Servlet更好的开发体验.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.MyServlets;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: proanimer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 2025/3/10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By proanimer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Servlet实现web请求响应</span></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: workspace</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span>: org.example.MyServlets</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span>: MyServlet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: proanimer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/3/10 20:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(name = &quot;MyServlet&quot;, urlPatterns = &quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>(PrintWriter out = resp.getWriter()) &#123;</span><br><span class="line">            out.println(<span class="string">&quot;&lt;html&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;head&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;title&gt;MyServlet&lt;/title&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;/head&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;body&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;h1&gt;MyServlet&lt;/h1&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;/body&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">       doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><p><a href="https://spring.io/quickstart">Spring | Quickstart</a></p><p><a href="https://www.cainiaojc.com/spring/spring-tutorial.html">Spring 教程 - Spring教程 - 菜鸟教程</a></p><h3 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h3><blockquote><p>依赖注入（DI）是 IoC 的一种特殊形式，其中对象仅通过构造函数参数、工厂方法参数或在对象实例构建或从工厂方法返回后设置的属性来定义其依赖（即它们与之一起工作的其他对象）。IoC 容器在创建 bean 时注入这些依赖。这个过程本质上是 bean 本身通过直接构建类或如Service Locator pattern等机制控制其依赖的实例化或位置的反向（因此得名，控制反转）。</p></blockquote><p>Spring 框架支持多种配置方式，包括<strong>基于 XML 的配置</strong>、<strong>基于注解的配置</strong>以及<strong>基于 Java 配置类</strong>的配置。</p><blockquote><p>spring6.x版本官方文档已经不再详细说xml配置,主流是java配置类.</p></blockquote><ul><li><strong>XML 配置</strong>：适用于传统的 Spring 应用程序，提供了对 Spring 容器的详细控制。</li><li><strong>注解配置</strong>：减少了 XML 配置的需求，使得代码更加简洁，但可能不如 XML 配置那样直观地看到整个应用程序的结构。</li><li><strong>Java 配置类</strong>：提供了一种类型安全的方式来配置 Spring 应用程序，尤其适合新的项目或微服务架构。</li></ul><p><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 包是 Spring 框架 IoC 容器的基石。 <code>BeanFactory</code> 接口提供了一种高级配置机制，能够管理任何类型的对象。 <code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口。</p><blockquote><p>Spring容器就是<code>ApplicationContext</code>，它是一个接口，有很多实现类，比如<code>ClassPathXmlApplicationContext</code>，表示它会自动从classpath中查找指定的XML配置文件。</p></blockquote><p><code>BeanFactory</code> 接口提供了一种高级配置机制，能够管理任何类型的对象，它是SpringIoC容器标准化超接口！</p><p><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口。它扩展了以下功能：</p><ul><li>更容易与 Spring 的 AOP 功能集成</li><li>消息资源处理（用于国际化）</li><li>特定于应用程序给予此接口实现，例如Web 应用程序的 <code>WebApplicationContext</code></li></ul><p>简而言之， <code>BeanFactory</code> 提供了配置框架和基本功能，而 <code>ApplicationContext</code> 添加了更多特定于企业的功能。 <code>ApplicationContext</code> 是 <code>BeanFactory</code> 的完整超集</p><p><strong>ApplicationContext容器实现类</strong>：</p><div class="table-container"><table><thead><tr><th>类型名</th><th>简介</th></tr></thead><tbody><tr><td><strong>ClassPathXmlApplicationContext</strong></td><td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>FileSystemXmlApplicationContext</td><td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td><strong>AnnotationConfigApplicationContext</strong></td><td>通过读取Java配置类创建 IOC 容器对象</td></tr><tr><td>WebApplicationContext</td><td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</td></tr></tbody></table></div><p>IoC 容器的基本职责包括：</p><ul><li>实例化 Bean。</li><li>设置 Bean 的属性值和生命周期回调。</li><li>管理 Bean 之间的依赖关系。</li><li>控制 Bean 的作用域（如 singleton, prototype 等）。</li></ul><p>Spring 提供了两种类型的 IoC 容器：</p><ul><li><strong>BeanFactory</strong>：提供了基础的功能来管理和操作 Bean，适合资源受限的环境。</li><li><strong>ApplicationContext</strong>：扩展了 <code>BeanFactory</code>，增加了事件发布、国际化支持、AOP 集成等功能，适用于大多数应用场合。</li></ul><p>通常情况下，开发者更倾向于使用 <code>ApplicationContext</code>，因为它提供了更多的功能和便利性。</p><p><strong>2. ApplicationContext 的实现类</strong></p><p>Spring 提供了几种 <code>ApplicationContext</code> 的实现类，每种都有其特定的应用场景：</p><ul><li><strong>ClassPathXmlApplicationContext</strong>：从类路径下的 XML 文件加载 Bean 定义。</li><li><strong>FileSystemXmlApplicationContext</strong>：从文件系统中指定位置的 XML 文件加载 Bean 定义。</li><li><strong>AnnotationConfigApplicationContext</strong>：用于基于 Java 注解的配置，不依赖于 XML 文件。</li><li><strong>WebApplicationContext</strong>：专为 Web 应用设计，支持 Servlet 上下文，并且可以方便地集成到 Web 应用程序中。</li></ul><p><strong>3. Bean 定义</strong></p><p>在 Spring 中，Bean 定义是描述如何创建一个 Bean 的元数据。可以通过以下方式定义 Bean：</p><ul><li><strong>XML 配置文件</strong>：传统方式，通过 XML 文件定义 Bean 及其依赖关系。</li><li><strong>注解</strong>：例如 <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code> 等，配合 <code>@Autowired</code> 或构造函数注入。</li><li><strong>Java 配置类</strong>：使用 <code>@Configuration</code> 和 <code>@Bean</code> 注解定义 Bean。</li></ul><h4 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;value1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;anotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.AnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;constructor-arg&gt;</code> 标签用于在 XML 配置文件中定义构造函数注入所需的参数。通过该标签，你可以指定将哪些值或 Bean 注入到目标类的构造函数中。<code>&lt;constructor-arg&gt;</code> 支持多个属性来帮助精确地匹配和注入依赖，主要包括 <code>name</code>, <code>value</code>, <code>index</code>, 和 <code>type</code> 等属性。下面详细介绍这些属性的意义：</p><ol><li><code>name</code></li></ol><ul><li><p><strong>用途</strong>：指定构造函数参数的名字。</p></li><li><p><strong>适用场景</strong>：当目标类的构造函数使用命名参数时，可以通过 <code>name</code> 属性明确指定要注入哪个参数。不过需要注意的是，Spring 在早期版本中并不直接支持按名称注入构造参数，而是根据类型和顺序（索引）进行匹配。从 Spring 3.0 开始，如果使用 CGLIB 来增强字节码，则可以支持基于名称的构造函数注入。</p></li><li><p>示例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleClass&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;paramName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;someValue&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ol><li><code>value</code></li></ol><ul><li><p><strong>用途</strong>：直接为基本数据类型或 String 类型的构造函数参数提供值。</p></li><li><p><strong>适用场景</strong>：适用于需要传递简单类型的值作为构造函数参数的情况。</p></li><li><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleClass&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hello, World!&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里”Hello, World!”将被作为第一个参数传递给ExampleClass的构造函数。</p></li></ul><ol><li><code>index</code></li></ol><ul><li><p><strong>用途</strong>：指定构造函数参数的位置索引，以确定向哪个参数注入值。</p></li><li><p><strong>适用场景</strong>：当你有多个构造函数参数并且想要精确控制哪个参数接收哪个值时非常有用。</p></li><li><p><strong>注意事项</strong>：索引是从 0 开始的。</p></li><li><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleClass&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;First Argument&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;anotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ol><li><code>type</code></li></ol><ul><li><p><strong>用途</strong>：指定构造函数参数的数据类型，帮助 Spring 容器更准确地选择合适的构造函数（特别是在存在重载构造函数的情况下）。</p></li><li><p><strong>适用场景</strong>：当你有多个同名但不同类型的构造函数参数时，或者你需要确保特定类型的值被注入时使用。</p></li><li><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleClass&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;String Argument&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>Java配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyRepository <span class="title">myRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyRepositoryImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用构造函数注入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyServiceImpl(myRepository());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ClientService&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>利用工厂类的静态方法</p><h4 id="实例工厂方法"><a href="#实例工厂方法" class="headerlink" title="实例工厂方法"></a>实例工厂方法</h4><p>利用工厂的实例方法</p><p>首先定义工厂 Bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ServiceFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>然后，使用这个工厂 Bean 的方法来创建目标 Bean。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;serviceFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createClientServiceInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这里假设 <code>ServiceFactory</code> 类中有一个名为 <code>createClientServiceInstance</code> 的方法，用于创建并返回一个新的 <code>ClientService</code> 实例。</p><p><strong>注解方式创建工厂Bean</strong></p><p>用工厂模式创建Bean需要实现<code>FactoryBean</code>接口。我们观察下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneIdFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">ZoneId</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    String zone = <span class="string">&quot;Z&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ZoneId <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(zone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个Bean实现了<code>FactoryBean</code>接口后，Spring会先实例化这个工厂，然后调用<code>getObject()</code>创建真正的Bean。<code>getObjectType()</code>可以指定创建的Bean的类型，因为指定类型不一定与实际类型一致，可以是接口或抽象类。</p><p>因此，如果定义了一个<code>FactoryBean</code>，要注意Spring创建的Bean实际上是这个<code>FactoryBean</code>的<code>getObject()</code>方法返回的Bean。为了和普通Bean区分，我们通常都以<code>XxxFactoryBean</code>命名。</p><p><strong>由于可以用<code>@Bean</code>方法创建第三方Bean，本质上<code>@Bean</code>方法就是工厂方法，所以，<code>FactoryBean</code>已经用得越来越少了</strong>。</p><h4 id="实例化后设置属性"><a href="#实例化后设置属性" class="headerlink" title="实例化后设置属性"></a>实例化后设置属性</h4><p>这是最常见的 Bean 实例化方式之一，在 Bean 被实例化之后，通过 setter 方法设置其属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;property1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;property2&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;anotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.AnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>ExampleBean</code> 有两个属性 <code>property1</code> 和 <code>property2</code>，它们分别通过 <code>set</code> 方法被赋值</p><h4 id="注解Annotation配置"><a href="#注解Annotation配置" class="headerlink" title="注解Annotation配置"></a>注解Annotation配置</h4><p>使用XML配置的优点是所有的Bean都能一目了然地列出来，并通过配置注入能直观地看到每个Bean的依赖。它的缺点是写起来非常繁琐，每增加一个组件，就必须把新的Bean配置到XML中。</p><p>可以使用Annotation配置，可以完全不需要XML，让Spring自动扫描Bean并组装它们。</p><p><code>@Component</code>注解就相当于定义了一个Bean，它有一个可选的名称，默认是<code>mailService</code>，即小写开头的类名。</p><h4 id="使用Java配置类"><a href="#使用Java配置类" class="headerlink" title="使用Java配置类"></a>使用Java配置类</h4><h4 id="Bean的声明周期管理"><a href="#Bean的声明周期管理" class="headerlink" title="Bean的声明周期管理"></a>Bean的声明周期管理</h4><p><strong>Bean 生命周期的基本流程</strong></p><p>一个典型的 Spring Bean 生命周期包括以下几个步骤：</p><ol><li><strong>实例化</strong>：根据配置元数据（如 XML 配置、Java 注解或 Java 配置类），Spring 容器首先实例化 Bean。</li><li><strong>设置属性值</strong>：将 Bean 实例化后，Spring 会为该 Bean 设置属性值和其他依赖注入。</li><li><strong>初始化前</strong>：如果实现了 <code>Aware</code> 系列接口（例如 <code>BeanNameAware</code>, <code>BeanFactoryAware</code>, <code>ApplicationContextAware</code>），则调用这些接口的方法，让 Bean 能够感知其环境信息。</li><li><strong>BeanPostProcessor 前处理</strong>：如果存在实现了 <code>BeanPostProcessor</code> 接口的 Bean，则调用其 <code>postProcessBeforeInitialization</code> 方法。这是对所有 Bean 都适用的一个扩展点。</li><li><strong>初始化</strong>：<ul><li>如果 Bean 实现了 <code>InitializingBean</code> 接口，则调用 <code>afterPropertiesSet()</code> 方法。</li><li>如果指定了 <code>&lt;bean&gt;</code> 元素的 <code>init-method</code> 属性或使用了 <code>@PostConstruct</code> 注解，则调用指定的初始化方法。</li></ul></li><li><strong>BeanPostProcessor 后处理</strong>：接着再次调用实现了 <code>BeanPostProcessor</code> 接口的 <code>postProcessAfterInitialization</code> 方法。</li><li><strong>使用阶段</strong>：此时 Bean 已经准备好并可以被应用程序使用了。</li><li><strong>销毁阶段</strong>：<ul><li>当容器关闭时，如果 Bean 实现了 <code>DisposableBean</code> 接口，则调用 <code>destroy()</code> 方法。</li><li>如果指定了 <code>&lt;bean&gt;</code> 元素的 <code>destroy-method</code> 属性或使用了 <code>@PreDestroy</code> 注解，则调用指定的销毁方法。</li></ul></li></ol><p><strong>2. 控制 Bean 生命周期的关键接口和注解</strong></p><ul><li><strong><code>Aware</code> 系列接口</strong>：用于让 Bean 感知到容器的一些信息。<ul><li><code>BeanNameAware</code>: 获取 Bean 的名称。</li><li><code>BeanFactoryAware</code>: 获取 BeanFactory。</li><li><code>ApplicationContextAware</code>: 获取 ApplicationContext。</li></ul></li><li><strong><code>BeanPostProcessor</code> 接口</strong>：提供两个方法用于前后处理 Bean 初始化逻辑。<ul><li><code>postProcessBeforeInitialization(Object bean, String beanName)</code> 在初始化之前调用。</li><li><code>postProcessAfterInitialization(Object bean, String beanName)</code> 在初始化之后调用。</li></ul></li><li><strong><code>InitializingBean</code> 接口</strong>：提供 <code>afterPropertiesSet()</code> 方法，在所有属性设置完成后执行自定义初始化逻辑。</li><li><strong><code>DisposableBean</code> 掀口</strong>：提供 <code>destroy()</code> 方法，在容器关闭时执行清理工作。</li><li><strong>注解支持</strong>：<ul><li><code>@PostConstruct</code>：标注在方法上，表示这是一个初始化方法。</li><li><code>@PreDestroy</code>：标注在方法上，表示这是一个销毁方法。</li></ul></li></ul><p>在 Spring 框架中，Bean 的作用域（Scope）决定了 Bean 实例的作用范围和生命周期。Spring 提供了多种内置的作用域类型，每种类型适用于不同的场景。理解这些作用域可以帮助你更好地控制 Bean 的行为，确保它们在应用程序中的正确使用。</p><blockquote><ol><li><strong>实例化（Instantiation）</strong>：<ul><li>Spring容器根据Bean定义的信息创建Bean的实例。</li></ul></li><li><strong>属性赋值（Populate）</strong>：<ul><li>Spring容器将配置文件中的属性值或者依赖注入到Bean实例中。这一步通常通过setter方法完成，也可以通过构造函数注入。</li></ul></li><li><strong>设置其他属性</strong>：<ul><li>如果Bean实现了<code>BeanNameAware</code>接口，Spring会调用<code>setBeanName(String name)</code>方法，传入Bean的名字。</li><li>如果Bean实现了<code>BeanFactoryAware</code>接口，Spring会调用<code>setBeanFactory(BeanFactory beanFactory)</code>方法，传入BeanFactory的实例。</li><li>如果Bean实现了<code>ApplicationContextAware</code>接口，Spring会调用<code>setApplicationContext(ApplicationContext applicationContext)</code>方法，传入ApplicationContext的实例。</li></ul></li><li><strong>初始化前处理（Initialization Before Processing）</strong>：<ul><li>如果有实现<code>BeanPostProcessor</code>接口的后处理器，它们的<code>postProcessBeforeInitialization(Object bean, String beanName)</code>方法会被调用。</li></ul></li><li><strong>初始化（Initialization）</strong>：<ul><li>如果Bean实现了<code>InitializingBean</code>接口，Spring会调用其<code>afterPropertiesSet()</code>方法。</li><li>如果在XML配置中指定了<code>init-method</code>属性，那么对应的自定义初始化方法也会被调用。</li><li>也可以使用<code>@PostConstruct</code>注解来指定初始化方法。</li></ul></li><li><strong>初始化后处理（Initialization After Processing）</strong>：<ul><li>如果有实现<code>BeanPostProcessor</code>接口的后处理器，它们的<code>postProcessAfterInitialization(Object bean, String beanName)</code>方法会被调用。</li></ul></li><li><strong>使用Bean</strong>：<ul><li>此时Bean已经完全初始化，可以正常使用了。</li></ul></li><li><strong>销毁前处理（Destruction Before Processing）</strong>：<ul><li>当容器关闭时，如果Bean实现了<code>DisposableBean</code>接口，Spring会调用其<code>destroy()</code>方法。</li><li>如果在XML配置中指定了<code>destroy-method</code>属性，那么对应的自定义销毁方法也会被调用。</li><li>同样可以使用<code>@PreDestroy</code>注解来指定销毁方法。</li></ul></li></ol></blockquote><p><strong>1. 常见的 Bean 作用域</strong></p><p><strong>(1) Singleton（单例）</strong></p><ul><li><strong>默认作用域</strong>：如果未指定作用域，默认为 <code>singleton</code>。</li><li><strong>行为</strong>：Spring 容器在整个应用上下文中只会创建一个该类型的 Bean 实例，并且所有对该 Bean 的请求都会返回这个唯一的实例。</li><li><strong>适用场景</strong>：大多数情况下，特别是对于无状态的服务类，如服务层、数据访问层等。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleClass&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>或通过注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) Prototype（原型）</strong></p><ul><li><strong>行为</strong>：每次对 Bean 的请求都会创建一个新的实例。</li><li><strong>适用场景</strong>：当需要每次获取到的是一个新的对象实例时使用，例如命令对象、Web 控制器等。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleClass&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>或通过注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外还有Request,Session和Application等作用域.</p><h4 id="选择性实例化Bean"><a href="#选择性实例化Bean" class="headerlink" title="选择性实例化Bean"></a>选择性实例化Bean</h4><p>选择性实例化 Bean 是指根据某些条件动态决定是否创建某个 Bean 实例。Spring 提供了多种机制来实现这种功能，例如使用注解、配置文件或编程方式</p><p><strong>使用 <code>@Conditional</code> 注解</strong></p><p><code>@Conditional</code> 是 Spring 中的一个核心注解，用于根据特定条件决定是否加载某个 Bean。</p><p><strong>(1) 工作原理</strong></p><ul><li><code>@Conditional</code> 接受一个实现了 <code>Condition</code> 接口的类作为参数。</li><li>在运行时，Spring 会调用 <code>Condition</code> 的 <code>matches()</code> 方法，如果返回 <code>true</code>，则加载该 Bean；否则跳过。</li></ul><p><strong>(2) 示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Condition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ConditionContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义条件类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查系统属性 &quot;my.condition&quot; 是否为 true</span></span><br><span class="line">        <span class="keyword">return</span> Boolean.parseBoolean(System.getProperty(<span class="string">&quot;my.condition&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置类</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Conditional;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Conditional(MyCondition.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyBean <span class="title">myBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不加载 MyBean</span></span><br><span class="line">java -jar app.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载 MyBean</span></span><br><span class="line">java -Dmy.condition=<span class="literal">true</span> -jar app.jar</span><br></pre></td></tr></table></figure><p><code>@Profile</code> 是 Spring 中的一种更简单的条件加载机制，它根据当前激活的环境（profile）来决定是否加载某个 Bean。</p><p><strong>(1) 工作原理</strong></p><ul><li>每个 <code>@Profile</code> 注解可以指定一个或多个 profile 名称。</li><li>只有当这些 profile 被激活时，对应的 Bean 才会被加载。</li></ul><p><strong>(2) 示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfileConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyBean <span class="title">devBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBean(<span class="string">&quot;Development Environment&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;prod&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyBean <span class="title">prodBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBean(<span class="string">&quot;Production Environment&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 测试</strong></p><p>启动程序时，可以通过指定激活的 profile 来加载不同的 Bean：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 激活开发环境</span></span><br><span class="line">java -Dspring.profiles.active=dev -jar app.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活生产环境</span></span><br><span class="line">java -Dspring.profiles.active=prod -jar app.jar</span><br></pre></td></tr></table></figure><p><strong>使用 FactoryBean 动态创建 Bean</strong></p><p><code>FactoryBean</code> 是 Spring 提供的一种接口，用于动态创建 Bean 实例。</p><p><strong>(1) 工作原理</strong></p><ul><li>实现 <code>FactoryBean</code> 接口，并重写 <code>getObject()</code> 方法。</li><li>在运行时，Spring 会调用 <code>getObject()</code> 方法来获取实际的 Bean 实例。</li></ul><p><strong>(2) 示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactory</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">MyBean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBeanFactory</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.enabled = enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyBean <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!enabled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Bean creation is disabled!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyBean.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryBeanConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyBeanFactory <span class="title">myBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBeanFactory(Boolean.getBoolean(<span class="string">&quot;factory.bean.enabled&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>版本</th><th>Bean 自动覆盖行为</th></tr></thead><tbody><tr><td><strong>Spring Boot 2.0</strong></td><td>允许用户定义相同类型的 Bean，Spring Boot 预置 Bean 被跳过。</td></tr><tr><td><strong>Spring Boot 2.1+</strong></td><td>Spring Boot 检测到多个相同类型 Bean 时，可能会有警告。</td></tr><tr><td><strong>Spring Boot 2.4+</strong></td><td><strong>默认不允许手动定义的 Bean 覆盖自动配置的 Bean</strong>（可通过 <code>spring.main.allow-bean-definition-overriding=true</code> 启用）。</td></tr><tr><td><strong>Spring Boot 3.0+</strong></td><td>仍然默认不允许覆盖 Bean，除非手动启用 <code>allow-bean-definition-overriding</code>。</td></tr></tbody></table></div><h3 id="如何实现依赖注入"><a href="#如何实现依赖注入" class="headerlink" title="如何实现依赖注入"></a>如何实现依赖注入</h3><p>依赖注入是 IoC 的一种实现方式，允许对象定义其依赖关系而不必自行创建或查找依赖的对象。Spring 支持三种依赖注入类型：</p><ul><li><strong>构造器注入</strong>：通过构造函数参数注入依赖。</li><li><strong>Setter 方法注入</strong>：通过 setter 方法注入依赖。</li><li><strong>字段注入</strong>：直接在字段上使用 <code>@Autowired</code> 注解进行注入。</li></ul><p>当 Spring 应用启动时，IoC 容器会根据 <code>@Autowired</code> 注解的信息去寻找相应的 Bean 并将其注入到目标对象中。以下是几种常见的注入方式：</p><ol><li><strong>构造函数注入</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyService myService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 自 Spring 4.3 起可以省略，如果只有一个构造函数的话</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceUser</span><span class="params">(MyService myService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myService = myService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个例子中，Spring 将会查找类型为 <code>MyService</code> 的 Bean，并将其注入到 <code>ServiceUser</code> 类的构造函数中。</li></ul><ol><li><strong>字段注入</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceUser</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyService myService; <span class="comment">// 直接注入 MyService 实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字段注入是最简单的形式，但它可能会导致难以进行单元测试，因为它绕过了类的构造函数。</li></ul><ol><li><strong>Setter 方法注入</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyService</span><span class="params">(MyService myService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myService = myService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Setter 方法注入适合于那些可选依赖或希望在运行时更改依赖的情况</li></ul><p><strong>Bean 查找规则</strong></p><p>Spring 容器按照以下顺序尝试解析依赖：</p><ol><li><strong>类型匹配</strong>：首先<strong>基于参数类型</strong>查找匹配的 Bean。</li><li><strong>名称匹配</strong>：如果<strong>有多个相同类型的 Bean 存在，则根据参数名作为 Bean 名称进行匹配</strong>。</li><li><strong>限定符（Qualifiers）</strong>：当存在多个相同类型的 Bean 且名称也不足以区分时，可以使用 <code>@Qualifier</code> 注解指定确切的 Bean 名称</li></ol><p>如果你希望给 Bean 指定一个不同于方法名的名称，可以通过 <code>@Bean</code> 注解的 <code>name</code> 属性来实现或者 <code>@Qualifier</code>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(name = &quot;zoneZ&quot;)</span></span><br><span class="line"><span class="function">ZoneId <span class="title">createZoneOfZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(name = &quot;zoneUTC8&quot;)</span></span><br><span class="line"><span class="function">ZoneId <span class="title">createZoneOfUTC8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;UTC+08:00&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Autowired</code> 标记的构造函数、字段或方法会被 Spring 容器扫描，并尝试找到匹配的 Bean 来注入。如果找到多个匹配的 Bean，则可能需要通过 <code>@Qualifier</code> 注解来指定具体的 Bean。</p><p>Spring 提供了多种注解用于实现依赖注入。以下是常用的注入注解及其用途：</p><p><strong>1. 核心注入注解</strong></p><p><strong>(1) <code>@Autowired</code></strong></p><ul><li><strong>作用</strong>：自动注入依赖对象。</li><li>位置:<ul><li>构造器</li><li>方法（如 setter 方法）</li><li>字段</li><li>参数</li></ul></li><li>特点<ul><li><strong>默认按类型（byType）</strong>进行匹配。</li><li>如果有多个相同类型的 Bean，则会抛出异常，需要结合 <code>@Qualifier</code> 使用。 注解用在构造器,setter,属性上和方法参数上</li></ul></li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 自动注入 UserRepository</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) <code>@Qualifier</code></strong></p><ul><li><strong>作用</strong>：当存在多个相同类型的 Bean 时，指定要注入的具体 Bean。</li><li><strong>配合</strong>：通常与 <code>@Autowired</code> 配合使用。</li><li><strong>特点</strong>：<strong>通过名称（byName）</strong>来限定注入的 Bean。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userRepositoryV1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryV1</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;userRepositoryV2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryV2</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;userRepositoryV1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 注入 UserRepositoryV1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) <code>@Primary</code></strong></p><ul><li><strong>作用</strong>：<strong>标记一个 Bean 为首选 Bean，当有多个相同类型的 Bean 时优先注入该 Bean</strong>。</li><li><strong>特点</strong>：无需显式使用 <code>@Qualifier</code>，简化配置。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryV1</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryV2</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 自动注入 UserRepositoryV1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(4) <code>@Resource</code></strong></p><ul><li><strong>作用</strong>：JSR-250 规范提供的注解，用于注入依赖。</li><li>特点<ul><li><strong>默认按名称（byName）</strong>进行匹配。</li><li><strong>如果未找到匹配的名称，则按类型（byType）匹配</strong>。</li></ul></li><li><strong>区别</strong>：<code>@Resource</code> 是 Java 的标准注解，而 <code>@Autowired</code> 是 Spring 的注解。(推荐Resource而不是Autowired)  注解用在属性上和setter上.</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userRepository&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;userRepository&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 按名称注入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(5) <code>@Inject</code></strong></p><ul><li><strong>作用</strong>：JSR-330 规范提供的注解，功能类似于 <code>@Autowired</code>。</li><li>特点:<ul><li>默认按类型（byType）进行匹配。</li><li>需要引入 <code>javax.inject</code> 包。</li></ul></li><li><strong>区别</strong>：<code>@Inject</code> 是 Java 的标准注解，而 <code>@Autowired</code> 是 Spring 的注解。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 自动注入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 高级注入注解</strong></p><p><strong>(6) <code>@Value</code></strong></p><ul><li><strong>作用</strong>：注入简单的值（如字符串、数字）、系统属性或配置文件中的值。</li><li><strong>特点</strong>：支持占位符 <code>$&#123;&#125;</code> 和 SpEL 表达式 <code>#&#123;&#125;</code>。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appName; <span class="comment">// 注入配置文件中的 app.name</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;2 + 3&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum; <span class="comment">// 注入表达式的计算结果 (2 + 3 = 5)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(7) <code>@ConfigurationProperties</code></strong></p><ul><li><strong>作用</strong>：批量注入配置文件中的属性到一个 Java 对象中。</li><li><strong>特点</strong>：适合处理复杂的配置结构。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and Setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置文件 (<code>application.properties</code>)：</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">app.name</span>=<span class="string">MyApp</span></span><br><span class="line"><span class="meta">app.version</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure><p><strong>(8) <code>@Lookup</code></strong></p><ul><li><strong>作用</strong>：用于方法注入，每次调用方法时都会返回一个新的 Bean 实例。</li><li><strong>场景</strong>：适用于原型（Prototype）作用域的 Bean。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeBean</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> PrototypeBean <span class="title">getPrototypeBean</span><span class="params">()</span></span>; <span class="comment">// 每次调用返回新的实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 其他相关注解</strong></p><p><strong>(9) <code>@Required</code></strong></p><ul><li><strong>作用</strong>：标记某个 setter 方法必须注入值，否则抛出异常。</li><li><strong>注意</strong>：从 Spring 5 开始已被废弃，推荐使用构造器注入或 <code>@Autowired(required = true)</code>。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserRepository</span><span class="params">(UserRepository userRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(10) <code>@Lazy</code></strong></p><ul><li><strong>作用</strong>：延迟加载 Bean，只有在第一次使用时才会被创建。</li><li><strong>特点</strong>：可以减少启动时间，适用于不常用的功能。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyBean</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LazyBean lazyBean; <span class="comment">// 延迟加载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 总结</strong></p><div class="table-container"><table><thead><tr><th>注解</th><th>功能描述</th><th>特点</th></tr></thead><tbody><tr><td><code>@Autowired</code></td><td>自动注入依赖，按类型匹配</td><td>默认按类型，支持配合 <code>@Qualifier</code> 使用</td></tr><tr><td><code>@Qualifier</code></td><td>指定要注入的 Bean 名称</td><td>按名称匹配</td></tr><tr><td><code>@Primary</code></td><td>标记首选 Bean</td><td>简化多 Bean 场景下的注入</td></tr><tr><td><code>@Resource</code></td><td>按名称或类型注入</td><td>JSR-250 标准注解</td></tr><tr><td><code>@Inject</code></td><td>按类型注入</td><td>JSR-330 标准注解</td></tr><tr><td><code>@Value</code></td><td>注入简单值或配置文件中的值</td><td>支持占位符和 SpEL</td></tr><tr><td><code>@ConfigurationProperties</code></td><td>批量注入配置文件中的属性</td><td>适合复杂配置</td></tr><tr><td><code>@Lookup</code></td><td>方法注入，每次返回新实例</td><td>适用于原型作用域</td></tr><tr><td><code>@Required</code></td><td>强制要求注入</td><td>已废弃，推荐使用其他方式</td></tr><tr><td><code>@Lazy</code></td><td>延迟加载 Bean</td><td>减少启动时间</td></tr></tbody></table></div><h3 id="AOP的底层原理"><a href="#AOP的底层原理" class="headerlink" title="AOP的底层原理"></a>AOP的底层原理</h3><p>如何把切面织入到核心逻辑中？这正是AOP需要解决的问题。换句话说，如果客户端获得了<code>BookService</code>的引用，当调用<code>bookService.createBook()</code>时，如何对调用方法进行拦截，并在拦截前后进行安全检查、日志、事务等处理，就相当于完成了所有业务功能。</p><p>在Java平台上，对于AOP的织入，有3种方式：</p><ol><li>编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ就扩展了Java编译器，使用关键字aspect来实现织入；</li><li>类加载器：在目标类被装载到JVM时，通过一个特殊的类加载器，对目标类的字节码重新“增强”；</li><li>运行期：目标对象和切面都是普通Java类，通过JVM的动态代理功能或者第三方库实现运行期动态织入。</li></ol><p>最简单的方式是第三种，Spring的AOP实现就是基于JVM的动态代理。由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过<a href="https://github.com/cglib/cglib">CGLIB</a>或者<a href="https://www.javassist.org/">Javassist</a>这些第三方库实现。</p><p> AOP 的几个核心概念：</p><h4 id="AOP七大术语"><a href="#AOP七大术语" class="headerlink" title="AOP七大术语"></a>AOP七大术语</h4><ul><li><strong>切面（Aspect）</strong>：一个模块化的关注点，例如日志记录、事务管理等。</li><li><strong>连接点（Join Point）</strong>：程序执行过程中的某个特定点，例如方法调用或异常抛出。</li><li><strong>通知（Advice）</strong>：在连接点执行的动作，分为前置通知、后置通知、环绕通知等。</li><li><strong>切入点（Pointcut）</strong>：定义哪些连接点会被通知。</li><li><strong>目标对象（Target Object）</strong>：被代理的对象。</li><li><strong>代理对象（Proxy Object）</strong>：由 AOP 框架创建的包装目标对象的对象。</li><li><strong>织入（Weaving）</strong>：织入是将切面与业务逻辑代码结合起来的过程。这个过程可以在编译时、类加载时或运行时完成</li></ul><p>如果<strong>目标对象实现了接口，Spring 默认使用 JDK 动态代理</strong>。JDK 动态代理<strong>通过反射机制创建代理对象，并拦截方法调用</strong>。</p><p>如果目标对象没有实现接口，Spring 使用 CGLIB 动态代理。<strong>CGLIB 通过继承目标类并重写其方法来创建代理对象</strong>。</p><ul><li>CGLIB 是一个基于字节码生成的库，它通过 ASM 库操作字节码生成子类。</li><li>子类会覆盖父类的方法，并在方法调用前后插入自定义逻辑。</li></ul><p>Spring AOP 封装了动态代理的细节，开发者只需关注切面和通知的定义。</p><p><strong>(1) 定义切面和通知</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logging before method execution...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) 配置 Spring AOP</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> <span class="comment">// 启用 AOP 支持</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line"></span><br><span class="line">        Service service = context.getBean(Service.class);</span><br><span class="line">        service.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Spring AOP 的底层依赖于动态代理技术。</li><li>如果目标对象实现了接口，则使用 JDK 动态代理。</li><li>如果目标对象未实现接口，则使用 CGLIB 动态代理。</li></ul><p>面向切面编程（Aspect-Oriented Programming, AOP）是一种编程范式，它旨在<strong>通过将横切关注点从核心业务逻辑中分离出来，来提高代码的模块化程度。横切关注点指的是那些影响多个模块的功能，如日志记录、事务管理、安全性等</strong>。AOP的核心思想是将这些功能从业务逻辑中抽离出来，形成独立的模块——即所谓的“切面”.</p><p>代码复用性强</p><p>代码易维护</p><h4 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a>切点表达式</h4><p>切点表达式（Pointcut Expression）是Spring AOP中用于<strong>指定哪些连接点应当被通知（Advice）所影响的关键部分</strong>。它通过特定的语法来描述匹配条件，从而选择程序执行流程中的某些点作为切点。</p><p><code>execution</code>是最常用的切点指示器，用来匹配方法执行的连接点。</p><ul><li><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) <span class="keyword">throws</span>-pattern?)</span><br></pre></td></tr></table></figure></li><li><p>示例：</p><ul><li><code>execution(public * com.example.service.*.*(..))</code>：匹配<code>com.example.service</code>包下所有公共方法的执行。</li><li><code>execution(* com.example.service.UserServiceImpl.*(..))</code>：匹配<code>UserServiceImpl</code>类中所有方法的执行。</li></ul></li></ul><p><strong>访问控制权限符</strong>: 可选项,没写就是四个权限都包括.写public方法就表示只包括公开的方法.</p><p><strong>返回值类型</strong>: 必填项 *表示返回值类型任意</p><p><strong>全限定类名</strong>:可选项 两个点”..”代表当前包及子包下的所有类</p><p>省略时表示所有的类</p><p><strong>方法名</strong>: 必填项 *表示所有方法</p><p><strong>形式参数列表</strong>:必填项 ()表示没有参数的方法,(..)参数类型和个数随意的方法,(*)只有一个参数的方法</p><p><code>within</code>用来限定匹配特定类型内的连接点。</p><ul><li><p>语法格式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">within</span><span class="params">(type-pattern)</span></span></span><br></pre></td></tr></table></figure></li><li><p>示例：</p><ul><li><code>within(com.example.service.*)</code>：匹配<code>com.example.service</code>包内所有类的方法。</li><li><code>within(com.example.service..*)</code>：匹配<code>com.example.service</code>包及其子包内所有类的方法。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">logDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交叉业务</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.sekyoro.tutorAOP.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;log&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.sekyoro.tutorAOP.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;transaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通知类型</p><ol><li><p><strong>@Before</strong> - 前置通知，在目标方法执行之前执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(* com.example.service..*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在目标方法执行前执行的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@After (或 @AfterReturning)</strong> - 后置通知，在目标方法成功执行之后执行（即使方法抛出异常，也会执行）。</p><ul><li>如果你只关心方法正常返回的情况，可以使用 <code>@AfterReturning</code>，它可以访问到返回值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(pointcut = &quot;execution(* com.example.service..*(..))&quot;, returning = &quot;result&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningAdvice</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在目标方法执行后执行的逻辑，并且可以访问返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@AfterThrowing</strong> - 异常通知，在目标方法抛出异常后执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(pointcut = &quot;execution(* com.example.service..*(..))&quot;, throwing = &quot;error&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowingAdvice</span><span class="params">(Exception error)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在目标方法抛出异常后执行的逻辑，并且可以访问异常对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Around</strong> - 环绕通知，可以在目标方法执行前后自定义行为，甚至控制是否执行目标方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(* com.example.service..*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 在目标方法执行前的逻辑</span></span><br><span class="line">    Object proceed = joinPoint.proceed(); <span class="comment">// 执行目标方法</span></span><br><span class="line">    <span class="comment">// 在目标方法执行后的逻辑</span></span><br><span class="line">    <span class="keyword">return</span> proceed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@After</strong> - 最终通知，在任何情况下（无论方法正常返回还是抛出异常）都会执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After(&quot;execution(* com.example.service..*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无论目标方法正常返回还是抛出异常都会执行的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>@Order</code> 注解是 Spring 框架提供的一个用于定义组件加载顺序的注解。它可以在类、方法或接口上使用，主要用于控制 Bean 的加载顺序、切面的执行顺序以及组件的处理顺序 </p><p>定义和作用</p><p><code>@Order</code> 注解可以指定一个整数值作为参数，该值表示加载顺序，数值越小优先级越高。这意味着拥有较小 <code>@Order</code> 值的 Bean 将被优先加载 </p><p>需要注意的是，<strong>这个注解并不影响 Bean 的实例化顺序，而是决定了 Bean 在集合中的排序或者是在自动装配时的顺序</strong>。</p><p>使用场景</p><ol><li><p>多个拦截器的执行顺序</p><p>在 Spring MVC 中，如果有多个拦截器，可以使用@Order来确保它们按照特定顺序执行</p></li><li><p>切面的执行顺序</p><p>在 AOP 编程中，如果存在多个切面，可以通过@Order确定它们执行的顺序</p></li><li><p>事件监听器的执行顺序：当有多个事件监听器监听同一事件时，可以使用@Order来定义它们的执行顺序</p></li><li><p>定时任务的执行顺序：在 Spring 中，如果有多个定时任务，可以使用@Order来指定它们的执行顺序</p></li></ol><p><strong>通用切点</strong></p><p>用切点指的是可以被多个通知（Advice）或者多个切面（Aspect）所共享的切点定义。通过将切点逻辑集中到一个地方来定义，可以在不同的通知或切面中复用这个切点表达式，从而减少重复代码并提高维护性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">logDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义通用切点表达式</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.sekyoro.tutorAOP.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交叉业务</span></span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;log&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;transaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonPointcuts</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个名为 allServiceMethods 的公共切点，</span></span><br><span class="line"><span class="comment">     * 该切点匹配 com.example.service 包及其子包下所有服务类中的任意方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.service..*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allServiceMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 空方法体，因为 Pointcut 注解已经定义了切点逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 假设我们已经有了上面定义的 CommonPointcuts 类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(pointcut = &quot;com.example.CommonPointcuts.allServiceMethods()&quot;, returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logServiceAccess</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;完成了服务方法调用，结果是: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何管理事务"><a href="#如何管理事务" class="headerlink" title="如何管理事务"></a>如何管理事务</h3><p>事务是一组数据库操作的逻辑单元，这些操作要么全部成功执行（提交），要么全部不执行（回滚）。事务通常用于保证数据在并发访问或异常情况下的完整性和一致性。</p><p>事务的核心特性可以用 ACID 来概括：</p><ul><li><strong>原子性（Atomicity）</strong>：事务中的所有操作要么全部完成，要么全部不完成，不允许部分执行。例如，转账操作中扣款和存款必须同时成功。</li><li><strong>一致性（Consistency）</strong>：事务执行前后，数据库必须从一个一致状态转换到另一个一致状态。例如，转账后账户余额总和不变。</li><li><strong>隔离性（Isolation）</strong>：多个事务并发执行时，一个事务的执行不应影响其他事务。通常通过隔离级别来控制。</li><li><strong>持久性（Durability）</strong>：一旦事务提交，其结果必须永久保存在数据库中，即使系统崩溃也能恢复。</li></ul><p><strong>开始事务（Begin Transaction）</strong>：标记事务的起点。</p><p><strong>提交（Commit）</strong>：确认所有操作成功，将结果持久化。</p><p><strong>回滚（Rollback）</strong>：如果发生错误或异常，撤销所有操作，恢复到事务开始前的状态。</p><h4 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h4><ul><li><p>编程式</p></li><li><p>声明式</p></li></ul><p>​    -  基于注解</p><p>​        -  基于xml</p><p>Spring声明式事务管理是<strong>通过面向切面编程（AOP）机制实现</strong>的。当Spring容器启动时，如果发现有<code>@EnableTransactionManagement</code>注解存在，那么会拦截所有Bean的创建过程，扫描是否有<code>@Transactional</code>注解的存在。如果有，Spring会通过AOP的方式给Bean生成代理对象，代理对象中会增加一个拦截器，该拦截器会在方法执行之前启动事务，在方法执行完毕之后提交或回滚事务</p><h4 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h4><p><strong>（1）传播行为（Propagation）</strong></p><p><code>propagation</code> 属性决定<strong>当前事务方法执行时，是否新建事务或加入已有事务</strong>。</p><div class="table-container"><table><thead><tr><th>传播行为</th><th>说明</th></tr></thead><tbody><tr><td><code>REQUIRED</code>（默认）</td><td>如果有事务，则加入；否则创建新事务。</td></tr><tr><td><code>REQUIRES_NEW</code></td><td>无论是否已有事务，都创建新事务，暂停旧事务。</td></tr><tr><td><code>SUPPORTS</code></td><td>如果有事务，则加入；如果没有，则以非事务方式运行。</td></tr><tr><td><code>NOT_SUPPORTED</code></td><td>始终以非事务方式运行，若有事务则挂起。</td></tr><tr><td><code>MANDATORY</code></td><td>必须在已有事务中运行，否则抛异常。</td></tr><tr><td><code>NEVER</code></td><td>不能在事务中运行，否则抛异常。</td></tr><tr><td><code>NESTED</code></td><td>在当前事务中嵌套一个子事务，子事务可以单独回滚。</td></tr></tbody></table></div><p>🔹 <strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该方法无论是否存在事务，都会新建一个事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）隔离级别（Isolation）</strong></p><p><code>isolation</code> 属性决定多个事务并发时，数据的可见性。通常数据库提供以下隔离级别：</p><div class="table-container"><table><thead><tr><th>隔离级别</th><th>说明</th><th>可能问题</th></tr></thead><tbody><tr><td><code>DEFAULT</code></td><td>使用数据库默认隔离级别</td><td>-</td></tr><tr><td><code>READ_UNCOMMITTED</code></td><td>允许读取未提交数据</td><td>脏读、不可重复读、幻读</td></tr><tr><td><code>READ_COMMITTED</code></td><td>只能读取已提交数据</td><td>可能出现不可重复读、幻读</td></tr><tr><td><code>REPEATABLE_READ</code></td><td>事务内多次查询，结果一致</td><td>可能出现幻读</td></tr><tr><td><code>SERIALIZABLE</code></td><td>串行化访问数据，最高隔离级别</td><td>性能开销大</td></tr></tbody></table></div><p>🔹 <strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(isolation = Isolation.REPEATABLE_READ)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 事务中多次查询结果保持一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>只读事务（Read-Only）</strong></p><p><code>readOnly = true</code> 表示事务仅用于查询，不允许数据修改，数据库可能进行优化。<strong>适用于 <code>SELECT</code> 语句，提高性能</strong>。</p><p>🔹 <strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAllUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userRepository.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：某些数据库（如 MySQL）会对 <code>readOnly=true</code> 进行优化，但仍需手动确保没有写操作。</p><p><strong>回滚规则（Rollback Rules）</strong></p><p><code>rollbackFor</code> 和 <code>noRollbackFor</code> 控制事务回滚条件：</p><ul><li><code>rollbackFor = Exception.class</code>：遇到指定异常回滚（默认只回滚 <code>RuntimeException</code>）。</li><li><code>noRollbackFor = CustomException.class</code>：遇到指定异常不回滚。</li></ul><p>🔹 <strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTransaction</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 遇到任何 Exception（包括 Checked Exception）都会回滚</span></span><br><span class="line">&#125;</span><br><span class="line">javaCopyEdit<span class="meta">@Transactional(noRollbackFor = IllegalArgumentException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processWithoutRollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遇到 IllegalArgumentException 不回滚</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>超时（Timeout）</strong></p><p><code>timeout</code> 指定事务的最大执行时间（秒），超时后事务会回滚。默认值 <code>-1</code>（无限制）。</p><p>🔹 <strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEdit<span class="meta">@Transactional(timeout = 5)</span> <span class="comment">// 事务最多执行 5 秒，否则回滚</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">slowTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 事务执行超过 5 秒，会自动回滚</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超时时间记录的是直到最后一条DML语句执行完成的时间.</p><p>Spring 的事务管理通过动态代理实现，默认使用 <strong>JDK 动态代理</strong> 或 <strong>CGLIB 代理</strong> 来为目标对象创建一个代理对象。事务拦截器会在代理对象上调用方法时生效，从而开启或管理事务。</p><p><strong>关键点：</strong></p><ul><li>当你在目标对象内部直接调用另一个方法时，调用并不会经过代理对象，而是直接在目标对象本身上执行。</li><li>因此，事务拦截器无法介入，事务也就不会生效</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自调用 methodB</span></span><br><span class="line">        methodB(); <span class="comment">// 不会触发事务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数据库操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ol><li><code>methodA()</code> 调用了 <code>methodB()</code>。</li><li>由于 <code>methodB()</code> 是目标对象内部的方法调用，调用不会经过代理对象，因此事务拦截器不会对 <code>methodB()</code> 生效。</li></ol><p>为了确保事务在自调用时也能生效，可以采取以下几种解决方法：</p><p><strong>(1) 使用 AOP 代理对象显式调用</strong></p><p>通过获取当前类的代理对象来调用目标方法，从而确保事务拦截器生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取代理对象</span></span><br><span class="line">        MyService proxy = applicationContext.getBean(MyService.class);</span><br><span class="line">        proxy.methodB(); <span class="comment">// 通过代理对象调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数据库操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) 使用 <code>AopContext.currentProxy()</code></strong></p><p>通过 <code>AopContext.currentProxy()</code> 获取当前代理对象，并调用目标方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前代理对象</span></span><br><span class="line">        MyService proxy = (MyService) AopContext.currentProxy();</span><br><span class="line">        proxy.methodB(); <span class="comment">// 通过代理对象调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数据库操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 使用 <code>AopContext.currentProxy()</code> 时，需要在 Spring 配置中启用暴露代理对象的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy(exposeProxy = true)</span></span><br></pre></td></tr></table></figure><p><strong>(3) 将方法拆分到不同的类中</strong></p><p>将需要事务管理的方法拆分到另一个服务类中，这样可以通过代理对象调用该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AnotherService anotherService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        anotherService.methodB(); <span class="comment">// 调用另一个类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数据库操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式利用了不同类之间的调用，确保事务管理能够正常工作。</p><div class="table-container"><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>自调用（不推荐）</strong></td><td>简单直接</td><td>事务不生效</td></tr><tr><td><strong>通过 <code>ApplicationContext</code> 获取代理对象</strong></td><td>灵活，适用于复杂的场景</td><td>需要注入 <code>ApplicationContext</code>，稍显冗长</td></tr><tr><td><strong>使用 <code>AopContext.currentProxy()</code></strong></td><td>简洁，避免额外的依赖</td><td>需要启用 <code>exposeProxy</code> 配置</td></tr><tr><td><strong>拆分到不同的类中</strong></td><td>符合单一职责原则，结构清晰</td><td>可能增加类的数量</td></tr></tbody></table></div><h3 id="如何处理循环依赖"><a href="#如何处理循环依赖" class="headerlink" title="如何处理循环依赖"></a>如何处理循环依赖</h3><p>在 Spring 中，<strong>循环依赖</strong>是指两个或多个 Bean 在初始化过程中相互依赖。例如：</p><ul><li><strong>Bean A</strong> 依赖于 <strong>Bean B</strong>；</li><li><strong>Bean B</strong> 又依赖于 <strong>Bean A</strong>。</li></ul><p>Spring 容器通过一些机制来处理循环依赖问题，但并不是所有类型的循环依赖都能被解决</p><p>循环依赖可以分为以下几种情况：</p><p><strong>(1) 构造函数注入的循环依赖</strong></p><p>当两个 Bean 使用构造函数注入时，如果它们之间存在循环依赖，则 Spring 无法解决这种循环依赖，会抛出 <code>BeanCurrentlyInCreationException</code> 异常。</p><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BeanB beanB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanA</span><span class="params">(BeanB beanB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanB = beanB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BeanA beanA;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanB</span><span class="params">(BeanA beanA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanA = beanA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，Spring 无法创建任何一个 Bean，因为它们互相依赖且都需要完全初始化后才能使用</p><p><strong>(2) Setter 方法或字段注入的循环依赖</strong></p><p>当两个 Bean 使用 setter 方法或字段注入时，Spring 可以解决这种循环依赖。</p><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanB beanB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanA beanA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 能够通过提前暴露未完全初始化的 Bean 来解决这种循环依赖。</p><p><strong>Spring 处理循环依赖的机制</strong></p><p>Spring 容器通过三级缓存（singleton caches）和提前暴露未完全初始化的 Bean 来解决循环依赖问题。</p><p><strong>(1) 单例 Bean 的三级缓存</strong></p><p>Spring 容器维护了三个缓存来管理单例 Bean 的生命周期：</p><ol><li>一级缓存（singletonObjects）<ul><li>存储已经完全初始化完成的 Bean。</li><li>当 Bean 完全初始化后，会从二级缓存移动到一级缓存。</li></ul></li><li>二级缓存（earlySingletonObjects）<ul><li>存储未完全初始化但已经被提前暴露的 Bean。</li><li>当一个 Bean 正在初始化但还未完成时，Spring 会将其放入二级缓存中，以便其他 Bean 可以引用它。</li></ul></li><li>三级缓存（singletonFactories）<ul><li>存储 Bean 的工厂对象（ObjectFactory），用于动态生成未完全初始化的 Bean。</li><li>当需要提前暴露一个 Bean 时，Spring 会先将其工厂对象放入三级缓存。</li></ul></li></ol><p><strong>(2) 提前暴露未完全初始化的 Bean</strong></p><p>当 Spring 发现一个 Bean 正在初始化且有其他 Bean 需要引用它时，Spring 会提前暴露该 Bean 的实例（即使它还未完全初始化）。这通过以下步骤实现：</p><ol><li>创建 Bean 实例（调用构造函数）。</li><li>将 Bean 实例的工厂对象放入三级缓存。</li><li>如果需要提前暴露，将工厂对象生成的 Bean 放入二级缓存。</li><li>其他 Bean 可以从二级缓存中获取该未完全初始化的 Bean。</li><li>当 Bean 完全初始化后，将其移入一级缓存。</li></ol><p>这种方式适用于基于 setter 方法或字段注入的循环依赖。</p><p><strong>3. 为什么构造函数注入的循环依赖无法解决？</strong></p><p>构造函数注入要求 Bean 必须在完全初始化后才能被使用。因此，当两个 Bean 通过构造函数相互依赖时，Spring 无法满足它们的初始化顺序要求。以下是具体原因：</p><ol><li><strong>Bean A</strong> 需要 <strong>Bean B</strong> 的完全初始化实例。</li><li><strong>Bean B</strong> 需要 <strong>Bean A</strong> 的完全初始化实例。</li><li>由于两者都处于“正在初始化”状态，Spring 无法完成任意一方的初始化。</li></ol><p>一个 Bean 被认为是<strong>完全初始化</strong>的，当它已经通过了所有的初始化步骤，并且可以安全地用于应用程序中。这些步骤通常包括：</p><ul><li><strong>实例化</strong>：创建 Bean 的实例。</li><li><strong>属性填充</strong>：为 Bean 的属性设置值或注入依赖（通过构造函数、setter 方法或字段注入）。</li><li><strong>Aware 接口回调</strong>：如果 Bean 实现了特定的 <code>Aware</code> 接口（如 <code>BeanNameAware</code>, <code>BeanFactoryAware</code>, <code>ApplicationContextAware</code> 等），Spring 会调用相应的方法，让 Bean 能够访问到容器的相关信息。</li><li><strong>初始化方法调用</strong>：如果有定义初始化方法（通过 <code>@PostConstruct</code> 注解或 <code>&lt;bean&gt;</code> 元素中的 <code>init-method</code> 属性），Spring 会在该阶段调用这些方法。</li></ul><p>​    一旦所有这些步骤都完成了，这个 Bean 就被认为是完全初始化的，并被放入 Spring 容器的一级缓存（singletonObjects）中，供其他组件使用。</p><p>一个 Bean 被认为是<strong>未完全初始化</strong>的，是指它正处于初始化过程中的某个中间状态。例如，在某些情况下，Bean 已经被实例化并注入了一些依赖，但尚未完成所有的初始化步骤（比如还没有调用初始化方法）。这种状态下，Bean 还不能完全满足其契约要求，因此可能不适合直接使用。</p><p>​    在处理循环依赖时，Spring 使用一种称为“提前暴露”的机制来解决 Setter 或字段注入引起的循环依赖问题。具体来说，当 Spring 正在初始化一个 Bean A 时，如果发现另一个 Bean B 需要引用 Bean A，而此时 Bean A 尚未完全初始化，Spring 会将 Bean A 提前暴露出来，尽管它还未经过全部的初始化步骤。这种提前暴露的 Bean 只完成了实例化和部分依赖注入，但尚未执行 Aware 接口回调、初始化方法等后续步骤。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><strong>静态代理</strong></p><p>对于安全检查、日志、事务等代码，它们会重复出现在每个业务方法中。使用OOP，我们很难将这些四处分散的代码模块化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityCheckBookService</span> <span class="keyword">implements</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BookService target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecurityCheckBookService</span><span class="params">(BookService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        target.createBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        target.updateBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        target.deleteBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">securityCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>动态代理</strong></p><p>在内存中动态生成字节码代理类</p><p>JDK动态代理技术:只能代理接口.这是Java标准库提供的一种代理方式，要求被代理的目标对象必须实现了接口。Spring会在目标对象实现了接口时默认使用这种代理方式。JDK动态代理主要通过<code>java.lang.reflect.Proxy</code>类来创建代理对象，并通过<code>InvocationHandler</code>接口来处理代理对象的方法调用。</p><p>CGLIB:当目标对象没有实现任何接口时，Spring会使用CGLIB（Code Generation Library）来为该类创建子类，并覆盖其方法以实现代理。CGLIB通过继承的方式进行代理，因此不能对final类或final方法进行代理。与JDK动态代理相比，CGLIB代理不需要目标对象实现接口，但是性能上可能会稍逊一筹。</p><blockquote><p>从Spring 4.0开始，默认情况下即使目标对象实现了多个接口，Spring也会尝试使用CGLIB代理，除非特别配置了只使用JDK动态代理</p></blockquote><p>JDK动态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adding user: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态代理处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target; <span class="comment">// 被代理的目标对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 在方法调用前执行逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Before method: &quot;</span> + method.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目标对象的方法</span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在方法调用后执行逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After method: &quot;</span> + method.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicProxyExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建目标对象</span></span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        UserService proxyInstance = (UserService) Proxy.newProxyInstance(</span><br><span class="line">                userService.getClass().getClassLoader(),</span><br><span class="line">                userService.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> MyInvocationHandler(userService)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用代理对象的方法</span></span><br><span class="line">        proxyInstance.addUser(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CGLIB动态代理</strong></p><p>CGLIB（Code Generation Library）是一个强大的、高性能的代码生成库，它允许在运行时扩展Java类和实现接口。CGLIB动态代理主要通过继承的方式来实现代理对象，而不是像JDK动态代理那样基于接口。以下是关于CGLIB动态代理的关键点：</p><p><strong>工作原理</strong></p><ul><li>CGLIB通过字节码技术为代理对象创建一个子类，并在子类中重写父类中的非final方法。</li><li>在调用这些重写的方法时，会先经过用户自定义的拦截器（<code>MethodInterceptor</code>），然后可以选择性地调用父类的方法。</li></ul><p><strong>使用场景</strong></p><ul><li>当目标对象没有实现任何接口时，可以使用CGLIB来创建代理对象。</li><li>对于那些需要对现有类进行功能增强，而不想修改原始类的情况下，CGLIB也是一个不错的选择。</li></ul><p><strong>与JDK动态代理的区别</strong></p><ul><li><strong>依赖</strong>：JDK动态代理要求被代理类必须实现至少一个接口；CGLIB则不需要，它可以代理普通的类。</li><li><strong>性能</strong>：CGLIB代理的执行速度通常比JDK动态代理快，因为它直接生成了目标类的子类，而JDK动态代理是基于反射机制的。</li><li><strong>限制</strong>：CGLIB不能代理final类或final方法，因为子类无法覆盖它们</li></ul><h2 id="springmvc"><a href="#springmvc" class="headerlink" title="springmvc"></a>springmvc</h2><blockquote><p>拦截器</p><p>过滤器</p></blockquote><p><a href="https://springdoc.cn/spring-mvc-tutorial/">Spring MVC 教程 - spring 中文网</a></p><p>Spring 框架中处理模型（Model）- 视图（View）- 控制器（Controller）或 MVC 模式的一个模块。它结合了 MVC 模式的所有优点和 Spring 的便利性。</p><p>Spring 使用其 <code>DispatcherServlet</code> 前控制器模式实现 MVC。</p><p>简而言之，<code>DispatcherServlet</code> 是将请求路由到预定目的地的主要控制器。Model 只是应用的数据，而视图则由各种模板引擎来表示。</p><p>包含spring的依赖同时使用servlet等实现MVC架构的Web开发.</p><p>servlet如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>springmvc的示例代码如下.</p><p>要通过 Java 配置类启用 Spring MVC 支持，只需添加 <code>@EnableWebMvc</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">      registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      InternalResourceViewResolver bean = <span class="keyword">new</span> InternalResourceViewResolver();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//bean.setViewClass(JstlView.class); in older version</span></span><br><span class="line">      bean.setPrefix(<span class="string">&quot;/WEB-INF/view/&quot;</span>);</span><br><span class="line">      bean.setSuffix(<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将设置 MVC 项目所需的基本支持，如注册处理器、映射器、类型转换器、验证支持、消息转换器和异常处理。本例中注册了一个 <code>ViewResolver</code> Bean，它从 <code>/WEB-INF/view</code> 目录返回 <code>.jsp</code> 视图。可以注册视图控制器（ViewController），使用 <code>ViewControllerRegistry</code> 在 URL 和视图名称之间创建直接映射。这样，两者之间就不需要任何 Controller 了。</p><p>如果想自定义扫描 Controller 类，可以使用 <code>@ComponentScan</code> 注解，并指定包含 Controller 的包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123; &quot;com.baeldung.web.controller&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了引导应用加载该配置，还需要一个 Initializer 类：</p><blockquote><p>在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。 Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainWebAppInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(<span class="keyword">final</span> ServletContext sc)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        AnnotationConfigWebApplicationContext root = </span><br><span class="line">          <span class="keyword">new</span> AnnotationConfigWebApplicationContext();</span><br><span class="line">        </span><br><span class="line">        root.scan(<span class="string">&quot;com.baeldung&quot;</span>);</span><br><span class="line">        sc.addListener(<span class="keyword">new</span> ContextLoaderListener(root));</span><br><span class="line"></span><br><span class="line">        ServletRegistration.Dynamic appServlet = </span><br><span class="line">          sc.addServlet(<span class="string">&quot;mvc&quot;</span>, <span class="keyword">new</span> DispatcherServlet(<span class="keyword">new</span> GenericWebApplicationContext()));</span><br><span class="line">        appServlet.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        appServlet.addMapping(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="comment">// 返回应用级别的配置类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[]&#123;RootConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="comment">// 返回与 DispatcherServlet 相关的配置类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[]&#123;WebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="comment">// 设置 DispatcherServlet 的 URL 映射</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个基本的 Controller 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sample&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showForm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;sample&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的 JSP 资源是 <code>sample.jsp</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is the body of the sample view<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基于 <code>JSP</code> 的视图文件位于项目的 <code>/WEB-INF</code> 文件夹下，因此只有 Spring 才能访问它们，而不能直接通过 URL 访问。</p><p>也可以使用纯 XML 配置来代替上述 Java 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.baeldung.web.controller&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span>    </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/view/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;index&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果想使用纯 XML 配置，还需要添加一个 <code>web.xml</code> 文件来引导应用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/dispatcher-config.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h2><p><a href="https://springdoc.cn/spring-boot/">Spring Boot 中文文档</a></p><p><a href="https://spring.io/">Spring | Home</a></p><p>Spring Boot 是对 Spring 平台的补充，它能让你轻松上手并创建独立的生产级应用。Spring Boot 的目的不是取代 Spring，而是让使用 Spring 变得更快、更简单。</p><p><strong>pring Boot Starter</strong></p><p>Spring Boot 提供了便捷的 Starter 依赖，这是一种依赖描述符，可以为特定功能引入所有必要的技术。</p><p>这样做的好处是，不再需要为每个依赖项指定版本，而是让 Starter 管理依赖。</p><p>最快捷的入门方法是在 <code>pom.xml</code> 中添加 <code>spring-boot-starter-parent</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样就能解决依赖管理问题。</p><p><strong>Spring Boot 入口点</strong></p><p>使用 Spring Boot 构建的每个应用都需定义 main 入口点。</p><p>这通常是一个 Java 类，带有 main 方法，并用 <code>@SpringBootApplication</code> 进行注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解添加了以下其他注解：</p><ul><li><code>@Configuration</code> 将类标记为 bean 定义的来源。</li><li><code>@EnableAutoConfiguration</code> 会告诉框架根据 classpath 上的依赖自动添加 Bean。</li><li><code>@ComponentScan</code> 会扫描与 Application 类相同包或其子包中的其他配置和 Bean。</li></ul><p>有了 Spring Boot，就可以使用 Thymeleaf 或 JSP 设置前端，而无需使用定义的 <code>ViewResolver</code>。在 <code>pom.xml</code> 中添加 <code>spring-boot-starter-thymeleaf</code> 依赖后，Thymeleaf 就会启用，无需额外配置。</p><h4 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h4><p>这是Spring Boot默认的配置文件，它采用<a href="https://yaml.org/">YAML</a>格式而不是<code>.properties</code>格式，文件名必须是<code>application.yml</code>而不是其他名称。</p><p>YAML格式比<code>key=value</code>格式的<code>.properties</code>文件更易读。比较一下两者的写法：</p><p>使用<code>.properties</code>格式：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">$&#123;APP_NAME:unnamed&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:hsqldb:file:testdb</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">org.hsqldb.jdbc.JDBCDriver</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.datasource.hikari.auto-commit</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.connection-timeout</span>=<span class="string">3000</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.validation-timeout</span>=<span class="string">3000</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.max-lifetime</span>=<span class="string">60000</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.maximum-pool-size</span>=<span class="string">20</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.minimum-idle</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure><p>使用YAML格式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">$&#123;APP_NAME:unnamed&#125;</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:hsqldb:file:testdb</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">sa</span></span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.hsqldb.jdbc.JDBCDriver</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">auto-commit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">connection-timeout:</span> <span class="number">3000</span></span><br><span class="line">      <span class="attr">validation-timeout:</span> <span class="number">3000</span></span><br><span class="line">      <span class="attr">max-lifetime:</span> <span class="number">60000</span></span><br><span class="line">      <span class="attr">maximum-pool-size:</span> <span class="number">20</span></span><br><span class="line">      <span class="attr">minimum-idle:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可见，YAML是一种层级格式，它和<code>.properties</code>很容易互相转换，它的优点是去掉了大量重复的前缀，并且更加易读。</p><h3 id="使用环境变量"><a href="#使用环境变量" class="headerlink" title="使用环境变量"></a>使用环境变量</h3><p>在配置文件中，我们经常使用如下的格式对某个key进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">$&#123;DB_HOST:localhost&#125;</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">$&#123;DB_USER:root&#125;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;DB_PASSWORD:password&#125;</span></span><br></pre></td></tr></table></figure><p>这种<code>$&#123;DB_HOST:localhost&#125;</code>意思是，首先从环境变量查找<code>DB_HOST</code>，如果环境变量定义了，那么使用环境变量的值，否则，使用默认值<code>localhost</code>。</p><p>这使得我们在开发和部署时更加方便，因为开发时无需设定任何环境变量，直接使用默认值即本地数据库，而实际线上运行的时候，只需要传入环境变量即可</p><h3 id="logback-spring-xml"><a href="#logback-spring-xml" class="headerlink" title="logback-spring.xml"></a>logback-spring.xml</h3><p>这是Spring Boot的logback配置文件名称（也可以使用<code>logback.xml</code>），一个标准的写法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;APP_LOG&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">file</span>&gt;</span>app.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxIndex</span>&gt;</span>1<span class="tag">&lt;/<span class="name">maxIndex</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>app.log.%i<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxFileSize</span>&gt;</span>1MB<span class="tag">&lt;/<span class="name">MaxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;APP_LOG&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它主要通过<code>&lt;include resource=&quot;...&quot; /&gt;</code>引入了Spring Boot的一个缺省配置，这样我们就可以引用类似<code>$&#123;CONSOLE_LOG_PATTERN&#125;</code>这样的变量。上述配置定义了一个控制台输出和文件输出，可根据需要修改。</p><p><code>static</code>是静态文件目录，<code>templates</code>是模板文件目录，注意它们不再存放在<code>src/main/webapp</code>下，而是直接放到<code>src/main/resources</code>这个classpath目录，因为在Spring Boot中已经不需要专门的webapp目录了。</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><h4 id="传入参数"><a href="#传入参数" class="headerlink" title="传入参数"></a>传入参数</h4><p>在 Spring MVC 中，如果你不明确地为控制器方法的参数添加注解，Spring 会根据参数类型以及请求的上下文来自动处理这些参数。以下是默认行为的一些关键点：</p><p><strong>默认行为概述</strong></p><ol><li><strong>基本类型和简单对象（如 <code>String</code>, <code>Integer</code> 等）</strong>：<ul><li>如果没有使用任何注解，默认情况下 Spring 尝试从 URL 路径变量、请求参数或请求体中匹配数据。</li><li>特别是对于 RESTful 风格的 API，如果方法参数名与路径变量名相同，则可以自动绑定到路径变量上。</li></ul></li><li><strong>复杂对象（POJO 类）</strong>：<ul><li>对于复杂对象，Spring 会尝试将请求参数（通常是表单数据或者查询参数）自动绑定到对象的属性上。这类似于使用了 <code>@ModelAttribute</code> 注解的效果。</li><li>若要通过请求体传递 JSON 或 XML 数据并将其转换为对象，必须使用 <code>@RequestBody</code> 注解，否则 Spring 不知道如何解析请求体中的数据。</li></ul></li></ol><ul><li>使用 <code>@RequestParam</code> 当：<ul><li>处理GET请求的查询参数</li><li>处理表单提交(application/x-www-form-urlencoded)</li><li>需要获取少量简单参数</li></ul></li><li>使用 <code>@RequestBody</code> 当：<ul><li>处理JSON/XML等结构化数据</li><li>需要接收复杂对象</li><li>构建RESTful API时</li></ul></li></ul><p><strong><code>@RequestBody</code> 适用场景</strong>:</p><ul><li>RESTful API设计</li><li>前端发送JSON/XML数据</li><li>复杂嵌套对象结构</li><li>需要完整对象替换更新的操作</li></ul><p><strong><code>@ModelAttribute</code> 适用场景</strong>:</p><ul><li>传统表单提交</li><li>多步骤表单处理</li><li>需要部分更新对象的场景</li><li>需要从URL参数绑定的情况</li></ul><h4 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h4><p>使用<code>@Validated</code>和<code>@Valid</code>用于验证对象,帮助开发者确保传入的数据满足预定义的约束条件.</p><p><code>@Valid</code> 注解是 Java Bean Validation API（JSR 303/JSR 380）的一部分，通常用于触发<strong>对类实例或方法参数</strong>的验证。当你在一个方法参数、方法返回值或者字段上标记了 <code>@Valid</code>，Spring 会尝试根据该对象上的验证注解（如 <code>@NotNull</code>, <code>@Size</code> 等）来验证数据的有效性。如果验证失败，则抛出 <code>MethodArgumentNotValidException</code> 或者 <code>ConstraintViolationException</code> 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDTO</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;Name cannot be null&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">createUser</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserDTO userDTO)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理用户创建逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="string">&quot;User created successfully&quot;</span>, HttpStatus.CREATED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnCreate</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnUpdate</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDTO</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull(groups = OnCreate.class, message = &quot;Name is required on create&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(groups = OnUpdate.class, message = &quot;ID is required on update&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在服务层使用 <code>@Validated</code> 来指定验证组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Validated(OnCreate.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createUser</span><span class="params">(<span class="meta">@Valid</span> UserDTO userDTO)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建用户的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Validated(OnUpdate.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(<span class="meta">@Valid</span> UserDTO userDTO)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 更新用户的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>createUser</code> 方法只会验证那些标记了 <code>OnCreate</code> 分组的约束条件，而 <code>updateUser</code> 方法则只会验证那些标记了 <code>OnUpdate</code> 分组的约束条件。</p><h4 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h4><p><code>HttpSession</code> 是 Java Servlet 技术中用于在服务器端存储特定于用户的会话信息的重要机制。它允许<strong>开发者在多个请求之间保持用户的状态，这对于需要跟踪用户活动（如登录状态、购物车内容等）</strong>的 Web 应用程序来说是非常重要的。</p><p>如何在 Controller 方法中使用 HttpSession</p><p><strong>直接声明 HttpSession 参数</strong></p><p>Spring Boot 会自动将当前请求的 <code>HttpSession</code> 注入到控制器方法中。你只需要在方法参数列表中声明 <code>HttpSession</code> 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/session&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/set&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setSessionAttribute</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存储数据到会话中</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;JohnDoe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Session attribute &#x27;username&#x27; has been set.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/get&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSessionAttribute</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从会话中获取数据</span></span><br><span class="line">        String username = (String) session.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Username from session: &quot;</span> + username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/invalidate&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">invalidateSession</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 销毁会话</span></span><br><span class="line">        session.invalidate();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Session has been invalidated.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) <strong>测试流程</strong></p><ul><li>访问 <code>/session/set</code>：设置会话属性 <code>username</code>。</li><li>访问 <code>/session/get</code>：从会话中获取 <code>username</code>。</li><li>访问 <code>/session/invalidate</code>：销毁会话。</li></ul><p><strong>3. HttpSession 的常用方法</strong></p><p>以下是一些常用的 <code>HttpSession</code> 方法：</p><div class="table-container"><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>setAttribute(String name, Object value)</code></td><td>将指定的属性存储到会话中。</td></tr><tr><td><code>getAttribute(String name)</code></td><td>根据属性名称从会话中获取值。如果属性不存在，则返回 <code>null</code>。</td></tr><tr><td><code>removeAttribute(String name)</code></td><td>从会话中移除指定的属性。</td></tr><tr><td><code>invalidate()</code></td><td>使当前会话失效，并清除所有会话数据。</td></tr><tr><td><code>setMaxInactiveInterval(int interval)</code></td><td>设置会话的最大不活动时间（以秒为单位）。</td></tr><tr><td><code>getId()</code></td><td>获取当前会话的唯一标识符（Session ID）。</td></tr></tbody></table></div><p><strong>4. 使用场景</strong></p><p>(1) <strong>用户登录状态管理</strong></p><p>通过 <code>HttpSession</code>，可以存储用户的登录状态或用户信息，避免每次请求都需要重新验证身份。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String username, String password, HttpSession session)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(username) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(password)) &#123;</span><br><span class="line">        session.setAttribute(<span class="string">&quot;user&quot;</span>, username); <span class="comment">// 存储登录信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Login successful!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Invalid credentials!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/dashboard&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">dashboard</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">    String user = (String) session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Please login first!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Welcome to the dashboard, &quot;</span> + user + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/logout&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">logout</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">    session.invalidate(); <span class="comment">// 销毁会话</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Logged out successfully!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) <strong>购物车功能</strong></p><p>在电商系统中，可以使用 <code>HttpSession</code> 来存储用户的购物车数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/addToCart&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addToCart</span><span class="params">(String item, HttpSession session)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; cart = (List&lt;String&gt;) session.getAttribute(<span class="string">&quot;cart&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (cart == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cart = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    cart.add(item);</span><br><span class="line">    session.setAttribute(<span class="string">&quot;cart&quot;</span>, cart);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Item added to cart!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/viewCart&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">viewCart</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; cart = (List&lt;String&gt;) session.getAttribute(<span class="string">&quot;cart&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (cart == <span class="keyword">null</span> || cart.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Your cart is empty!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Cart items: &quot;</span> + String.join(<span class="string">&quot;, &quot;</span>, cart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 注意事项</strong></p><p>(1) <strong>会话超时</strong></p><p>默认情况下，<code>HttpSession</code> 的超时时间为 30 分钟（由服务器配置决定）。你可以通过以下方式修改超时时间：</p><ul><li><p>在<code>application.properties</code>中设置properties</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.servlet.session.timeout</span>=<span class="number">15</span>m</span><br></pre></td></tr></table></figure><p>或者在代码中动态设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.setMaxInactiveInterval(<span class="number">900</span>); <span class="comment">// 超时时间为 15 分钟（900 秒）</span></span><br></pre></td></tr></table></figure></li></ul><p>(2) <strong>内存消耗</strong></p><p>每个会话都会占用服务器的内存资源。如果会话数量过多，可能会导致性能问题。因此，尽量只存储必要的数据，并及时清理不再需要的会话。</p><p>(3) <strong>分布式环境</strong></p><p>在分布式环境中（如微服务架构），<code>HttpSession</code> 默认是存储在单个服务器上的。如果用户请求被负载均衡器分发到不同的服务器，可能导致会话丢失。解决方法包括：</p><ul><li>使用粘性会话（Sticky Session）。</li><li>使用外部化的会话存储（如 Redis）。</li></ul><p><strong>6. 替代方案</strong></p><p>在某些场景下，<code>HttpSession</code> 可能不是最佳选择。以下是一些替代方案：</p><p>(1) <strong>JWT（JSON Web Token）</strong></p><p>对于无状态的 RESTful API，可以使用 JWT 来代替 <code>HttpSession</code>。JWT 将用户信息存储在客户端（通常是 HTTP 请求头中），服务器无需维护会话状态。</p><p>(2) <strong>Spring Security</strong></p><p>Spring Security 提供了更强大的会话管理和认证机制，建议在需要复杂权限控制的场景下使用。</p><p>(3) <strong>数据库存储</strong></p><p>如果会话数据需要长期保存，可以考虑将数据存储在数据库中，而不是依赖 <code>HttpSession</code>。</p><p><code>HttpSession</code> 的核心实现原理可以总结为以下几点：</p><ol><li><strong>会话ID</strong>：唯一标识每个用户的会话。</li><li><strong>客户端与服务器的关联</strong>：通过 Cookie 或 URL 重写传递会话ID。</li><li><strong>服务器端存储</strong>：将以会话ID为键的会话数据存储在服务器端。</li><li><strong>超时机制</strong>：定期清理长时间未使用的会话。</li><li><strong>线程安全</strong>：注意并发访问会话数据时的线程安全问题。</li></ol><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p><code>@RestController</code> 是一个复合注解，它结合了 <code>@Controller</code> 和 <code>@ResponseBody</code>。</p><ul><li><code>@Controller</code>：声明该类是一个控制器。</li><li><code>@ResponseBody</code>：表示方法的返回值会直接写入 HTTP 响应体中，而不是解析为视图名称</li></ul><p><code>@ResponseBody</code> 注解的作用是将方法的返回值直接写入 HTTP 响应体中，而不是解析为视图名称。<strong>如果返回值是一个对象，Spring 会自动将其序列化为 JSON 或 XML 格式</strong>（默认是 JSON），然后将序列化后的结果作为响应内容返回给客户端。</p><p>如果使用的是 <code>@ResponseBody</code> 注解，则所有方法默认都会将返回值作为响应体的一部分，并根据返回值的类型推断 <code>Content-Type</code>。</p><p><strong>默认推断规则</strong></p><ul><li><strong>String 类型</strong>：默认返回 <code>text/plain</code>。</li><li><strong>POJO 类型</strong>：默认返回 <code>application/json</code>。</li><li><strong>其他类型</strong>：可能需要手动指定 <code>produces</code> 或使用 <code>ResponseEntity</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回纯文本</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/text&quot;, produces = &quot;text/plain&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;This is plain text.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 JSON 数据</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/json&quot;, produces = &quot;application/json&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getJson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        data.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;JohnDoe&quot;</span>);</span><br><span class="line">        data.put(<span class="string">&quot;age&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 HTML 内容</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/html&quot;, produces = &quot;text/html&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHtml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;h1&gt;This is an HTML response&lt;/h1&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>produces</code> 属性用于指定返回内容的 <code>Content-Type</code>。</li><li>如果省略 <code>produces</code>，Spring 会根据返回值类型自动推断 <code>Content-Type</code>。</li></ul><div class="table-container"><table><thead><tr><th>方法</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong><code>@ResponseBody</code> + <code>produces</code></strong></td><td>易于使用，支持自动推断 <code>Content-Type</code>。</td><td>API 开发（JSON、文本等）。</td></tr><tr><td><strong><code>ResponseEntity</code></strong></td><td>提供对状态码、头部信息和内容的完全控制。</td><td>需要动态生成响应的场景。</td></tr><tr><td><strong><code>@RestController</code> 默认行为</strong></td><td>自动推断 <code>Content-Type</code>，无需额外配置。</td><td>简单的 RESTful API 开发。</td></tr><tr><td><strong><code>HttpServletResponse</code></strong></td><td>完全手动控制响应内容和头部信息。</td><td>需要低级别的控制（如自定义格式）。</td></tr><tr><td><strong>视图解析器</strong></td><td>结合模板引擎（如 Thymeleaf、JSP）返回完整的 HTML 页面。</td><td>动态网页开发。</td></tr></tbody></table></div><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>在 Spring MVC 或 Spring Boot 应用程序中，拦截器（Interceptor）是一种用于<strong>在请求处理的不同阶段执行代码的机制。它们允许你在请求到达控制器之前或响应返回客户端之前对请求和响应进行预处理或后处理</strong>。拦截器非常适合用于日志记录、性能监控、安全检查、登录认证等场景。</p><p><strong>1. 拦截器的工作原理</strong></p><p>拦截器基于 Java 的 Servlet 规范实现，通过实现 <code>HandlerInterceptor</code> 接口或者继承 <code>HandlerInterceptorAdapter</code> 类来定义自己的拦截逻辑。Spring MVC 提供了三个主要的方法来控制请求的生命周期：</p><ul><li><strong><code>preHandle()</code></strong>：在处理器方法（Controller 方法）执行之前被调用。如果此方法返回 <code>false</code>，则请求将不再继续执行，可以用来做权限验证等。</li><li><strong><code>postHandle()</code></strong>：在处理器方法执行之后但在视图渲染之前被调用。可以在此方法中修改模型数据或视图名称。</li><li><strong><code>afterCompletion()</code></strong>：在整个请求完成之后被调用，通常用于资源清理工作。</li></ul><p><strong>2. 创建一个简单的拦截器</strong></p><p>首先，你需要创建一个类实现 <code>HandlerInterceptor</code> 接口，并重写上述提到的方法之一或全部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 在请求处理之前进行调用（Controller方法调用之前）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Pre-handle&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 如果返回false，则请求不会继续到下一个拦截器或处理器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 请求处理之后，视图渲染之前执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Post-handle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 在整个请求结束之后被调用，也就是在视图渲染完成之后，通常用于资源清理工作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After completion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 注册拦截器</strong></p><p>创建好拦截器后，需要将其注册到 Spring MVC 的配置中。可以通过实现 <code>WebMvcConfigurer</code> 接口并覆盖 <code>addInterceptors</code> 方法来注册自定义的拦截器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyInterceptor myInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(myInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>)  <span class="comment">// 指定拦截的路径模式</span></span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/register&quot;</span>); <span class="comment">// 排除某些路径不被拦截</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 使用场景示例</strong></p><p>(1) <strong>日志记录</strong></p><p>可以在 <code>preHandle</code> 和 <code>afterCompletion</code> 方法中添加日志记录功能，以追踪每个请求的开始和结束时间。</p><p>(2) <strong>权限验证</strong></p><p>在 <code>preHandle</code> 方法中根据用户的身份信息决定是否允许访问目标资源。</p><p>(3) <strong>性能监控</strong></p><p>计算从 <code>preHandle</code> 到 <code>afterCompletion</code> 之间的时间差，以此来衡量请求处理的耗时情况。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><h3 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h3><p>一般都是用mybatis,mybatis-plus.</p><p>MyBatis 的使用流程可以总结为以下几个步骤：</p><ol><li>引入依赖。</li><li>配置 MyBatis（XML 或 Spring Boot）。</li><li>创建实体类。</li><li>定义 Mapper 接口（注解或 XML）。</li><li>使用 MyBatis 执行 SQL。</li></ol><p><strong>1. 引入依赖</strong></p><p>在项目中引入 MyBatis 和数据库驱动相关的依赖。如果你使用的是 Maven 项目，可以在 <code>pom.xml</code> 中添加以下依赖：</p><p>xml</p><p>深色版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- MyBatis 核心依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 数据库驱动（以 MySQL 为例） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 如果使用 Spring Boot，可以引入 MyBatis-Spring-Boot-Starter --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2. 配置 MyBatis</strong></p><p>(1) <strong>XML 配置方式</strong></p><p>创建一个 <code>mybatis-config.xml</code> 文件，用于配置 MyBatis 的全局设置，例如数据源、事务管理器等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 全局设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 下划线转驼峰 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 数据源配置（可选，通常由 Spring 管理） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mydb&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 映射文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/example/mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(2) <strong>Spring Boot 配置方式</strong></p><p>如果使用 Spring Boot，可以直接在 <code>application.properties</code> 或 <code>application.yml</code> 中配置 MyBatis 和数据库连接信息。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mydb</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">password</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># MyBatis 配置</span></span><br><span class="line"><span class="meta">mybatis.mapper-locations</span>=<span class="string">classpath:mapper/*.xml</span></span><br><span class="line"><span class="meta">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p><strong>3. 创建实体类</strong></p><p>定义与数据库表对应的实体类（也称为 POJO 类）。例如，假设有一张 <code>user</code> 表：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters 和 Setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 创建 Mapper 接口</strong></p><p>定义一个接口，用于声明 SQL 操作方法。MyBatis 会通过动态代理机制实现该接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM user WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;INSERT INTO user(username, email) VALUES(#&#123;username&#125;, #&#123;email&#125;)&quot;)</span></span><br><span class="line">    <span class="meta">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;UPDATE user SET username = #&#123;username&#125;, email = #&#123;email&#125; WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;DELETE FROM user WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM user&quot;)</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAllUsers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 编写 SQL 映射文件（可选）</strong></p><p>如果你不想使用注解，也可以将 SQL 写在 XML 文件中。例如，创建一个 <code>UserMapper.xml</code> 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        INSERT INTO user(username, email) VALUES(#&#123;username&#125;, #&#123;email&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span>&gt;</span></span><br><span class="line">        UPDATE user SET username = #&#123;username&#125;, email = #&#123;email&#125; WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span>&gt;</span></span><br><span class="line">        DELETE FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>6. 使用 MyBatis 执行 SQL</strong></p><p>(1) <strong>非 Spring 环境</strong></p><p>手动创建 <code>SqlSessionFactory</code> 并获取 <code>SqlSession</code> 来执行 SQL。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.<span class="keyword">session</span>.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.<span class="keyword">session</span>.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.<span class="keyword">session</span>.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> MyBatisExample &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) throws <span class="keyword">Exception</span> &#123;</span><br><span class="line">        // 加载 MyBatis 配置文件</span><br><span class="line">        String resource = &quot;mybatis-config.xml&quot;;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="built_in">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">        // 获取 SqlSession</span><br><span class="line">        try (SqlSession <span class="keyword">session</span> = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">            UserMapper mapper = <span class="keyword">session</span>.getMapper(UserMapper.<span class="keyword">class</span>);</span><br><span class="line">            <span class="keyword">User</span> <span class="keyword">user</span> = mapper.getUserById(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">user</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) <strong>Spring 或 Spring Boot 环境</strong></p><p>在 Spring 或 Spring Boot 中，直接注入 <code>Mapper</code> 接口即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.getUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="springcloud"><a href="#springcloud" class="headerlink" title="springcloud"></a>springcloud</h2><h1 id="常用库"><a href="#常用库" class="headerlink" title="常用库"></a>常用库</h1><h2 id="lombok✨"><a href="#lombok✨" class="headerlink" title="lombok✨"></a>lombok✨</h2><ol><li><strong>@Getter 和 @Setter</strong></li></ol><ul><li>自动生成所有字段的 getter 和 setter 方法。</li><li>可以指定在类级别上使用，这样会为所有非静态字段生成 getter 和 setter 方法；也可以单独用于某个字段。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span> <span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>@ToString</strong></li></ol><ul><li>自动生成 <code>toString()</code> 方法，默认包含所有字段。</li><li>可以通过 <code>exclude</code> 参数排除某些字段，或者通过 <code>callSuper</code> 参数控制是否调用父类的 <code>toString()</code> 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ToString(exclude = &quot;password&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>@EqualsAndHashCode</strong></li></ol><ul><li>自动生成 <code>equals(Object other)</code> 和 <code>hashCode()</code> 方法。</li><li>类似于 <code>@ToString</code>，可以通过 <code>exclude</code> 排除特定字段，或通过 <code>callSuper</code> 控制是否考虑父类字段。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.EqualsAndHashCode;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EqualsAndHashCode(exclude = &quot;timestamp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timestamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>@NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor</strong></li></ol><ul><li>自动生成构造函数：<ul><li><code>@NoArgsConstructor</code>: 无参构造函数。</li><li><code>@RequiredArgsConstructor</code>: 使用所有 <code>final</code> 或 <code>@NonNull</code> 注解标注的字段作为参数的构造函数。</li><li><code>@AllArgsConstructor</code>: 包含所有字段的构造函数。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor(staticName = &quot;of&quot;)</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>@Data</strong></li></ol><ul><li>组合了 <code>@Getter</code>, <code>@Setter</code>, <code>@ToString</code>, <code>@EqualsAndHashCode</code>, 和 <code>@RequiredArgsConstructor</code> 的功能。</li><li>非常适合用于简单的数据持有类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>@Builder</strong></li></ol><ul><li>提供了一个流畅的构建器 API，非常适合创建不可变对象或复杂对象的实例化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">User user = User.builder().username(<span class="string">&quot;Alice&quot;</span>).email(<span class="string">&quot;alice@example.com&quot;</span>).build();</span><br></pre></td></tr></table></figure><ol><li><strong>@Slf4j</strong></li></ol><ul><li>自动生成一个 SLF4J Logger 实例，简化日志记录。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;User &#123;&#125; is logging in.&quot;</span>, username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>@Cleanup</strong></li></ol><ul><li>自动管理资源，确保在方法退出时关闭资源（如文件流、数据库连接等）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Cleanup;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="meta">@Cleanup</span> InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;path/to/file&quot;</span>);</span><br><span class="line">    <span class="comment">// 处理输入流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>@SneakyThrows</strong></li></ol><ul><li>简化异常处理，允许直接抛出受检异常而不必显式声明它们。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.SneakyThrows;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;path/to/file&quot;</span>);</span><br><span class="line">    <span class="comment">// 处理文件读取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>@Value</strong></li></ol><ul><li>创建不可变类（所有字段默认是私有的，并且带有 <code>final</code> 关键字），同时提供 <code>@Data</code> 的大部分功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Value;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hutool✨"><a href="#hutool✨" class="headerlink" title="hutool✨"></a>hutool✨</h2><h2 id="slf4j✨"><a href="#slf4j✨" class="headerlink" title="slf4j✨"></a>slf4j✨</h2><p><a href="https://logback.qos.ch/apidocs/index.html">Overview (Logback-Parent 1.5.15 API)</a></p><p>SLF4J为各种日志框架（例如 java.util.logging、logback、log4j）提供了一个简单的门面或抽象，允许用户在部署时插入所需的日志框架。</p><h2 id="logback"><a href="#logback" class="headerlink" title="logback"></a>logback</h2><p><a href="https://logback.qos.ch/">Logback Home</a></p><p>Logback 旨在作为流行的 log4j 项目的继任者，从 log4j 1.x 停止的地方继续发展。</p><p>Logback 的架构相当通用，以便在不同情况下应用。目前，logback 分为三个模块，分别是 logback-core、logback-classic 和 logback-access。</p><p>logback -core模块为其他两个模块奠定了基础。logback-classic模块可以看作是 log4j 1.x 的改进版本。此外，logback-classic模块原生实现了 SLF4J API，因此您可以轻松地在logaback和其他日志框架（如 log4j 1.x 或 java.util.logging（JUL））之间切换。</p><h2 id="log4j"><a href="#log4j" class="headerlink" title="log4j"></a>log4j</h2><p><a href="https://logging.apache.org/log4j/2.12.x/">Log4j – Apache Log4j 2 - Apache Log4j 2</a></p><p>Apache Log4j 2 是 Log4j 的升级版本，在性能上对前一代 Log4j 1.x 进行了显著提升，并提供了许多 Logback 中的改进，同时修复了 Logback 架构中的一些固有缺陷。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一般可以使用slf4j-api接口加上logback-classic(或者slf4j-simple)实现.</p><h1 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h1><ol><li><strong>类（Class）命名</strong></li></ol><ul><li><strong>规则</strong>：使用<strong>大写驼峰式（UpperCamelCase）</strong>，首字母大写，每个单词首字母大写。</li><li><strong>特点</strong>：通常是名词或名词短语，表示一个实体或概念。</li><li>示例<ul><li>User</li><li>OrderService</li><li>HttpRequestHandler</li></ul></li><li>注意<ul><li>接口命名与类类似，但通常反映其功能或角色，例如 Runnable、Serializable。</li><li>抽象类可以以 Abstract 开头，例如 AbstractFactory。</li></ul></li></ul><ol><li><strong>接口（Interface）命名</strong></li></ol><ul><li><strong>规则</strong>：同样使用<strong>大写驼峰式</strong>，通常是形容词或表示能力的名词。</li><li><strong>特点</strong>：突出功能或契约。</li><li>示例<ul><li>Comparable</li><li>Iterable</li><li>UserService</li></ul></li><li><strong>注意</strong>：避免使用 I 前缀（如 IUserService），这是 C# 的习惯，Java 中不推荐。</li></ul><ol><li><strong>方法（Method）命名</strong></li></ol><ul><li><strong>规则</strong>：使用<strong>小写驼峰式（lowerCamelCase）</strong>，首字母小写，后续单词首字母大写。</li><li><strong>特点</strong>：通常是动词或动词短语，表示行为或操作。</li><li>示例<ul><li>getName</li><li>calculateTotalPrice</li><li>isValid</li></ul></li><li>约定<ul><li>Getter 方法以 get 开头（返回布尔值时用 is），例如 getAge、isActive。</li><li>Setter 方法以 set 开头，例如 setName。</li><li>操作方法通常以动词开头，例如 saveUser、deleteRecord。</li></ul></li></ul><ol><li><strong>变量（Variable）命名</strong></li></ol><ul><li><strong>规则</strong>：使用<strong>小写驼峰式</strong>。</li><li><strong>特点</strong>：简洁、有意义，反映变量的作用。</li><li>示例<ul><li>userName</li><li>orderList</li><li>totalAmount</li></ul></li><li>约定<ul><li>局部变量：短而明确，例如 i（循环计数器）、temp。</li><li>成员变量（字段）：避免无意义的缩写，例如 firstName 而不是 fName。</li><li>布尔变量：通常以 is、has 等开头，例如 isFinished、hasPermission。</li></ul></li></ul><ol><li><strong>常量（Constant）命名</strong></li></ol><ul><li><strong>规则</strong>：全部<strong>大写</strong>，单词间用下划线 _ 分隔。</li><li><strong>特点</strong>：用于 static final 修饰的常量。</li><li>示例<ul><li>MAX_VALUE</li><li>DEFAULT_TIMEOUT</li><li>PI</li></ul></li><li><strong>注意</strong>：通常定义在类或接口中，表示不可变的值。</li></ul><ol><li><strong>包（Package）命名</strong></li></ol><ul><li><strong>规则</strong>：全部<strong>小写</strong>，使用点号 . 分隔，通常基于域名倒写。</li><li><strong>特点</strong>：层次清晰，避免关键字。</li><li>示例<ul><li>com.example.util</li><li>org.springframework.context</li></ul></li><li>约定<ul><li>避免使用连字符或下划线。</li><li>通常以公司或组织域名开头，避免命名冲突。</li></ul></li></ul><ol><li><strong>枚举（Enum）命名</strong></li></ol><ul><li><p><strong>规则</strong>：类名使用<strong>大写驼峰式</strong>，枚举值使用<strong>全大写</strong>（类似常量）。</p></li><li><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Status</span> </span>&#123;   </span><br><span class="line">    ACTIVE,    INACTIVE,    PENDING &#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><strong>异常（Exception）命名</strong></li></ol><ul><li><strong>规则</strong>：使用<strong>大写驼峰式</strong>，以 Exception 或 Error 结尾。</li><li>示例<ul><li>FileNotFoundException</li><li>NullPointerException</li><li>CustomValidationError</li></ul></li></ul><ol><li><strong>注解（Annotation）命名</strong></li></ol><ul><li><strong>规则</strong>：使用<strong>大写驼峰式</strong>，通常反映用途。</li><li>示例<ul><li>@Autowired</li><li>@RestController</li><li>@MyCustomAnnotation</li></ul></li></ul><ol><li><strong>测试类和方法命名</strong></li></ol><ul><li><p>规则</p><ul><li>测试类以 Test 结尾，命名反映被测试的类，例如 UserServiceTest。</li><li>测试方法以 test 开头，描述测试行为，使用小写驼峰式。</li></ul></li><li><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Test</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSaveUser</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="comment">// 测试代码    &#125; </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><strong>其他约定</strong></li></ol><ul><li><p><strong>避免缩写</strong>：除非是广为人知的缩写（如 URL、HTTP），否则使用完整单词，例如 userIdentifier 而不是 userId。</p></li><li><p><strong>语义清晰</strong>：命名应反映用途，避免过于泛泛的名称，如 data、process。</p></li><li><p>单复数</p><p>：</p><ul><li>集合使用复数，例如 users、orderList。</li><li>单个对象使用单数，例如 user、order。</li></ul></li></ul><ol><li><strong>Spring 中的特殊命名</strong></li></ol><ul><li>Bean 名称<ul><li>默认是类名首字母小写，例如 UserServiceImpl 的 Bean 名是 userServiceImpl。</li><li>可通过注解指定，例如 @Service(“customName”)。</li></ul></li><li>接口与实现类<ul><li>接口：UserService。</li><li>实现类：UserServiceImpl（以 Impl 结尾是常见约定）。</li></ul></li></ul><ol><li><strong>POJO (Plain Old Java Object)</strong></li></ol><ul><li><strong>含义</strong>：普通的 Java 对象，指不依赖特定框架、不继承特定类或实现特定接口的简单 Java 类。</li><li>特点<ul><li>只包含属性（字段）、getter/setter 方法，可能有简单的业务逻辑。</li><li>不受外部框架约束，例如不继承 Servlet 或实现 Serializable（除非业务需要）。</li></ul></li><li><strong>用途</strong>：作为基础数据载体，广泛用于各种场景</li></ul><ol><li><strong>VO (Value Object)</strong></li></ol><ul><li><strong>含义</strong>：值对象，通常用于表示不可变的数据结构，强调值的语义。</li><li>特点<ul><li>通常是不可变的（Immutable），创建后属性不可修改。</li><li>常用于传递数据，关注数据的完整性和一致性。</li><li>在某些场景下，也被用作视图对象（View Object），表示展示层的数据。</li></ul></li><li><strong>用途</strong>：在业务逻辑中传递数据，或在前端展示时封装数据。</li></ul><ol><li><strong>PO (Persistent Object)</strong></li></ol><ul><li><strong>含义</strong>：持久化对象，表示与数据库表直接映射的对象，通常用于 ORM（对象关系映射）框架（如 Hibernate、MyBatis）。</li><li>特点<ul><li>属性与数据库表的字段一一对应。</li><li>通常包含主键（如 id）和其他表字段。</li><li>可能有注解（如 @Entity、@Table）来映射数据库。</li></ul></li><li><strong>用途</strong>：用于数据持久化层，与数据库交互</li></ul><ol><li><strong>DAO (Data Access Object)</strong></li></ol><ul><li><p><strong>含义</strong>：数据访问对象，负责封装数据库操作的逻辑。</p></li><li><p>特点</p><p>：</p><ul><li>提供 CRUD（增删改查）方法，与数据库交互。</li><li>屏蔽底层数据访问细节（如 JDBC、ORM 的具体实现）。</li><li>通常与 PO 配合使用。</li></ul></li><li><p><strong>用途</strong>：隔离业务逻辑与数据访问逻辑。</p></li></ul><ol><li><strong>DTO (Data Transfer Object)</strong></li></ol><ul><li><p><strong>含义</strong>：数据传输对象，用于在不同层（如服务层与表现层）或系统之间传递数据。</p></li><li><p>特点</p><p>：</p><ul><li>不直接映射数据库表，属性根据传输需求设计。</li><li>通常是简单的数据容器，不含复杂业务逻辑。</li><li>常用于减少网络传输中的数据冗余或适配前端需求。</li></ul></li><li><p><strong>用途</strong>：跨层或跨系统的数据交换。</p></li></ul><ol><li><strong>BO (Business Object)</strong></li></ol><ul><li><strong>含义</strong>：业务对象，封装业务逻辑或表示业务实体的对象。</li><li>特点<ul><li>包含业务数据和相关操作方法。</li><li>通常聚合多个 PO 或 DTO，表示更高层次的业务概念。</li></ul></li><li><strong>用途</strong>：在业务逻辑层处理复杂的业务规则。</li></ul><p><strong>对比总结</strong></p><div class="table-container"><table><thead><tr><th>术语</th><th>全称</th><th>主要用途</th><th>与数据库关系</th><th>是否含业务逻辑</th></tr></thead><tbody><tr><td>POJO</td><td>Plain Old Java Object</td><td>通用简单对象</td><td>无特定关系</td><td>可能有简单逻辑</td></tr><tr><td>VO</td><td>Value Object</td><td>数据传递或视图展示</td><td>无直接关系</td><td>通常无</td></tr><tr><td>PO</td><td>Persistent Object</td><td>数据库表映射</td><td>直接映射</td><td>通常无</td></tr><tr><td>DAO</td><td>Data Access Object</td><td>数据访问逻辑</td><td>与数据库交互</td><td>数据操作逻辑</td></tr><tr><td>DTO</td><td>Data Transfer Object</td><td>层间或系统间数据传输</td><td>无直接关系</td><td>通常无</td></tr><tr><td>BO</td><td>Business Object</td><td>业务逻辑处理</td><td>间接（聚合 PO/DTO）</td><td>包含业务逻辑</td></tr></tbody></table></div><p><strong>典型使用场景</strong></p><p>在一个 Spring 项目中，这些对象可能这样协作：</p><ol><li><strong>PO</strong>：UserPO 用于与数据库表 users 映射，由 ORM（如 JPA）管理。</li><li><strong>DAO</strong>：UserDAO 提供对 UserPO 的增删改查操作。</li><li><strong>DTO</strong>：UserDTO 从 UserPO 转换而来，传递给服务层或前端。</li><li><strong>BO</strong>：OrderBO 聚合多个 UserDTO 和订单信息，执行业务计算。</li><li><strong>VO</strong>：UserVO 用于返回给前端的不可变视图数据。</li><li><strong>POJO</strong>：任何简单的 Java 类都可以是 POJO，可能用作上述某种对象的基类。</li></ol><p>数据库连接池</p><div class="table-container"><table><thead><tr><th>特性</th><th>DriverManagerDataSource</th><th>HikariCP</th></tr></thead><tbody><tr><td><strong>连接池支持</strong></td><td>无，每次创建新连接</td><td>有，高效连接池管理</td></tr><tr><td><strong>性能</strong></td><td>低，适合低并发</td><td>高，优化了并发和资源复用</td></tr><tr><td><strong>使用场景</strong></td><td>开发、测试、小型应用</td><td>生产环境、高并发应用</td></tr><tr><td><strong>配置复杂度</strong></td><td>简单，仅基本连接信息</td><td>支持丰富配置（如池大小、超时等）</td></tr><tr><td><strong>依赖</strong></td><td>Spring 自带，无需额外库</td><td>需引入 HikariCP 依赖</td></tr><tr><td><strong>Spring Boot 默认</strong></td><td>否</td><td>是（2.x 和 3.x 默认使用）</td></tr><tr><td><strong>连接管理</strong></td><td>每次获取连接都新建，关闭即销毁</td><td>池化管理，连接复用</td></tr></tbody></table></div><p>HikariCP 是 Spring Boot 默认连接池，性能极高，但无内置监控。</p><p>Druid 提供强大监控功能（如 SQL 执行时间、连接状态），适合需要实时分析连接池状态的场景。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习很潮很流行的Java以及相关框架.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux网络编程入门</title>
    <link href="https://www.sekyoro.top/2025/02/27/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <id>https://www.sekyoro.top/2025/02/27/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</id>
    <published>2025-02-27T07:01:15.000Z</published>
    <updated>2025-05-02T06:03:41.435Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>c++在网络编程中特别普及,特别是Linux服务器编程. 相关书籍也有很多,这里简单介绍一下(结合AI总结).<br><span id="more"></span></p><h2 id="重要的数据结构"><a href="#重要的数据结构" class="headerlink" title="重要的数据结构"></a>重要的数据结构</h2><h3 id="套接字地址"><a href="#套接字地址" class="headerlink" title="套接字地址"></a>套接字地址</h3><blockquote><p><strong>PF_INET</strong>：指的是协议族（Protocol Family），强调的是协议相关的概念。</p><p><strong>AF_INET</strong>：指的是地址族（Address Family），关注的是地址格式。</p><p>虽然在许多实现中 <code>PF_INET</code> 和 <code>AF_INET</code> 可以互换使用，但理论上它们代表不同的概念。为了保持代码的清晰性和一致性，推荐的做法是在创建套接字时使用 <code>AF_INET</code> 来指代地址族，而保留 <code>PF_INET</code> 用于协议族相关的上下文。不过，由于历史原因和广泛接受的习惯，这种区别在实践中往往被忽略。</p></blockquote><p>在进行网络编程时，<code>sockaddr_in</code>、<code>sockaddr</code> 和 <code>addrinfo</code> 是三个不同的数据结构，它们各自有不同的用途和特点。</p><p><strong>sockaddr</strong></p><ul><li><p><strong>定义</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family; <span class="comment">// 地址族（如AF_INET, AF_INET6）</span></span><br><span class="line">    <span class="keyword">char</span>        sa_data[<span class="number">14</span>]; <span class="comment">// 地址信息，具体格式取决于地址族</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>用途</strong>：</p><ul><li>这是一个<strong>通用的套接字地址结构体</strong>，用于表示任何类型的套接字地址。它不特定于任何一种协议或地址家族。</li><li>它通常作为函数参数传递，以便支持多种不同类型的地址族（例如IPv4、IPv6等）。</li></ul></li><li><p><strong>局限性</strong>：</p><ul><li>因为它的<code>sa_data</code>字段是固定大小的字符数组，所以在处理复杂或长度不定的地址信息时不够灵活。</li></ul></li></ul><p><strong>sockaddr_in</strong></p><ul><li><p><strong>定义</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>    sin_family; <span class="comment">// 地址族，必须设置为AF_INET</span></span><br><span class="line">    <span class="keyword">in_port_t</span>      sin_port;   <span class="comment">// 端口号（使用htons()转换为网络字节序）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">// IPv4地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  sin_zero[<span class="number">8</span>]; <span class="comment">// 填充0以使结构体大小与sockaddr相同</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span> s_addr; <span class="comment">// 32位IPv4地址（网络字节序）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>用途</strong>：</p><ul><li><strong>专门用于IPv4地址的套接字地址结构体</strong>。</li><li>提供了明确的字段来存储端口号和IP地址，使得处理IPv4地址更加直观和方便。</li></ul></li><li><p><strong>优点</strong>：</p><ul><li>相较于<code>sockaddr</code>，它提供了更具体的字段，便于操作IPv4地址和端口信息。</li></ul></li></ul><p><strong>sockaddr_in6</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sin6_);</span><br><span class="line">    <span class="keyword">in_port_t</span> sin6_port;<span class="comment">/* Transport layer port # */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_flowinfo;<span class="comment">/* IPv6 flow information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span><span class="comment">/* IPv6 address */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_scope_id;<span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p><strong>addrinfo</strong></p><ul><li><p><strong>定义</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>              ai_flags;     <span class="comment">// AI_PASSIVE, AI_CANONNAME, etc.</span></span><br><span class="line">    <span class="keyword">int</span>              ai_family;    <span class="comment">// AF_INET, AF_INET6, AF_UNSPEC</span></span><br><span class="line">    <span class="keyword">int</span>              ai_socktype;  <span class="comment">// SOCK_STREAM, SOCK_DGRAM</span></span><br><span class="line">    <span class="keyword">int</span>              ai_protocol;  <span class="comment">// 使用的协议</span></span><br><span class="line">    <span class="keyword">socklen_t</span>        ai_addrlen;   <span class="comment">// 地址长度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span>      <span class="comment">// 地址信息</span></span><br><span class="line">    <span class="keyword">char</span>            *ai_canonname; <span class="comment">// 主机规范名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span>      <span class="comment">// 下一个addrinfo结构指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/02/27/azvYs7B46VeOAfb.png" alt="image-20250227150905975"></p></li><li><p><strong>用途</strong>：</p><ul><li><code>addrinfo</code> 结构体由 <code>getaddrinfo()</code> 函数返回，旨在<strong>提供一个统一的方式来处理不同类型的地址信息（包括IPv4和IPv6），并简化了主机名和服务名解析的过程</strong>。</li><li>它可以包含多个结果（通过<code>ai_next</code>链表连接），允许应用程序选择最适合其需求的结果。</li></ul></li><li><p><strong>优点</strong>：</p><ul><li>支持现代互联网中常见的IPv4和IPv6地址。</li><li>能够处理复杂的配置需求，如指定被动监听（AI_PASSIVE）、获取规范主机名等。</li><li>更加灵活和强大，适合需要跨平台兼容性和灵活性的应用程序。</li></ul></li></ul><p><strong>sockaddr_storage</strong></p><p><code>sockaddr_storage</code> 是一个在 <code>&lt;netinet/in.h&gt;</code> 或 <code>&lt;sys/socket.h&gt;</code> 头文件中定义的数据结构，旨在提供一个足够大的缓冲区来存储任何类型的套接字地址（包括 IPv4、IPv6 等）。它解决了由于不同协议族的地址结构大小不一致所带来的问题，例如 <code>sockaddr_in</code> 和 <code>sockaddr_in6</code> 分别用于 IPv4 和 IPv6 地址，它们有不同的大小。</p><p><strong>定义与用途</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> ss_family; <span class="comment">// 地址族</span></span><br><span class="line">    <span class="comment">// 其余字段未指定，实现定义以确保足够的空间和对齐</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>ss_family</strong>：这是唯一标准化的字段，表示地址族（如 <code>AF_INET</code> 对应 IPv4，<code>AF_INET6</code> 对应 IPv6）。</li><li><strong>其他字段</strong>：这些字段的具体定义依赖于实现，主要是为了确保 <code>sockaddr_storage</code> 能够容纳所有可能的套接字地址类型，并且保持正确的内存对齐。这意味着它的大小至少要能容纳最大的套接字地址结构（比如 <code>sockaddr_in6</code>）。</li></ul><p><strong>主要特点</strong></p><ol><li><strong>统一性</strong>：通过使用 <code>sockaddr_storage</code>,可以编写更加通用的代码，避免直接处理特定于协议的地址结构（如 <code>sockaddr_in</code> 或 <code>sockaddr_in6</code>），从而提高代码的可移植性和灵活性。</li><li><strong>大小保证</strong>：<code>sockaddr_storage</code> 的大小被设计为足以容纳系统支持的所有套接字地址结构，这使得它可以安全地转换为任何特定的套接字地址类型。</li><li><strong>对齐要求</strong>：除了大小之外，<code>sockaddr_storage</code> 还满足了所有套接字地址结构的对齐要求，这对于高效访问数据至关重要。</li></ol><p><strong>总结</strong></p><ul><li><strong><code>sockaddr</code></strong>：是一个通用的套接字地址结构体，适用于所有地址族。由于其设计较为通用，实际应用中常被特定于某种地址族的结构体替代，如<code>sockaddr_in</code>。</li><li><strong><code>sockaddr_in</code></strong>：专用于IPv4地址，提供了对IPv4地址和端口的具体支持，易于理解和使用。</li><li><strong><code>addrinfo</code></strong>：提供了一个更高级别的抽象，能够处理IPv4和IPv6地址，并且支持更多的选项和灵活性。它是推荐的方式来进行现代网络编程中的地址解析和套接字创建，特别是当你需要同时支持IPv4和IPv6时。</li></ul><p><strong>socketpair</strong></p><p><code>socketpair</code> 是一个用于创建一对互联的套接字描述符的系统调用，它允许在同一主机上的两个进程之间进行双向通信。通常，这些套接字被用于父子进程间的通信，但它们也可以用于任何需要双向（全双工）通信通道的场景</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> sv[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<ul><li><code>domain</code>：指定协议族，通常是 <code>AF_UNIX</code> 或 <code>AF_LOCAL</code>（本地通信），但在某些实现中也可能支持其他域如 <code>AF_INET</code>。</li><li><code>type</code>：指定套接字类型，常见的有 <code>SOCK_STREAM</code>（提供有序、可靠、双向的连接）和 <code>SOCK_DGRAM</code>（数据报套接字）。</li><li><code>protocol</code>：指定使用的协议，通常为 <code>0</code>，表示使用默认协议。</li><li><code>sv</code>：指向一个包含两个整数元素的数组，这两个整数将作为返回的套接字描述符。</li></ul></li><li><strong>返回值</strong>：<ul><li>成功时，返回 <code>0</code> 并在 <code>sv</code> 数组中填充两个有效的套接字描述符。</li><li>失败时，返回 <code>-1</code> 并设置 <code>errno</code>。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sv[<span class="number">2</span>]; <span class="comment">// 存储两个套接字描述符</span></span><br><span class="line">    <span class="keyword">char</span> buffer[MSG_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一对套接字</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">socketpair</span>(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sv) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socketpair&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">close</span>(sv[<span class="number">0</span>]); <span class="comment">// 关闭不需要的套接字端</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *msg = <span class="string">&quot;Hello from child process!&quot;</span>;</span><br><span class="line">        <span class="built_in">write</span>(sv[<span class="number">1</span>], msg, <span class="built_in">strlen</span>(msg) + <span class="number">1</span>); <span class="comment">// 发送消息给父进程</span></span><br><span class="line">        <span class="built_in">close</span>(sv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">close</span>(sv[<span class="number">1</span>]); <span class="comment">// 关闭不需要的套接字端</span></span><br><span class="line">        <span class="keyword">ssize_t</span> bytes_read = <span class="built_in">read</span>(sv[<span class="number">0</span>], buffer, MSG_SIZE); <span class="comment">// 从子进程接收消息</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Received message from child: %s\n&quot;</span>, buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(sv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>); <span class="comment">// 等待子进程结束</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="地址二进制与点分十进制转换"><a href="#地址二进制与点分十进制转换" class="headerlink" title="地址二进制与点分十进制转换"></a>地址二进制与点分十进制转换</h3><p>在网络编程中，有时需要将点分十进制表示的IPv4地址（如<code>&quot;192.168.1.1&quot;</code>）转换成32位无符号整数形式以便于处理或计算。在C语言中，可以使用以下函数来实现这种转换：</p><ul><li><strong><code>inet_addr</code></strong>: 这是一个简单的函数，用于将点分十进制格式的IPv4地址转换为网络字节序的32位长整型值。然而，<strong>它不支持IPv6，并且如果输入无效，则返回<code>INADDR_NONE</code></strong></li><li><strong><code>inet_aton</code></strong>: 此函数不仅将点分十进制的IPv4地址转换为二进制形式，还会检查输入的有效性。它接受一个指向<code>in_addr</code>结构的指针作为第二个参数，并在此结构中填充相应的数值。<strong>如果转换成功，返回非零值；否则返回0</strong></li><li><strong><code>inet_pton</code></strong>: 这是一个更为现代和推荐使用的函数，支持IPv4和IPv6地址的转换。对于IPv4，它的第二个参数是一个指向<code>struct in_addr</code>类型的指针，对于IPv6，则是指向<code>struct in6_addr</code>类型的指针<strong>。如果转换成功，返回1</strong>；如果输入格式不正确，则返回0；如果遇到系统错误，则返回-1。</li></ul><div class="table-container"><table><thead><tr><th>特性</th><th><code>inet_addr</code></th><th><code>inet_aton</code></th></tr></thead><tbody><tr><td><strong>输入格式</strong></td><td>点分十进制字符串</td><td>点分十进制字符串</td></tr><tr><td><strong>输出格式</strong></td><td>返回 <code>in_addr_t</code>（32 位整数）</td><td>填充 <code>struct in_addr</code> 结构体</td></tr><tr><td><strong>错误处理</strong></td><td>错误时返回 <code>INADDR_NONE</code></td><td>错误时返回 <code>0</code></td></tr><tr><td><strong>线程安全性</strong></td><td>安全</td><td>安全</td></tr><tr><td><strong>推荐程度</strong></td><td>不推荐（已过时）</td><td>推荐</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>函数名</th><th>输入格式</th><th>输出格式</th><th>支持的地址类型</th><th>线程安全性</th></tr></thead><tbody><tr><td><code>inet_pton</code></td><td>字符串</td><td>二进制</td><td>IPv4 和 IPv6</td><td>安全</td></tr><tr><td><code>inet_aton</code></td><td>字符串</td><td>二进制</td><td>仅 IPv4</td><td>安全</td></tr><tr><td><code>inet_ntop</code></td><td>二进制</td><td>字符串</td><td>IPv4 和 IPv6</td><td>安全</td></tr><tr><td><code>inet_ntoa</code></td><td>二进制</td><td>字符串</td><td>仅 IPv4</td><td>不安全</td></tr></tbody></table></div><h3 id="端口字节序转换"><a href="#端口字节序转换" class="headerlink" title="端口字节序转换"></a>端口字节序转换</h3><p>在网络编程中，处理不同系统间的数据传输时，经常需要将数据在主机字节序（Host Byte Order）和网络字节序（Network Byte Order）之间进行转换。这是因为不同的计算机架构可能使用不同的字节序来存储多字节数据类型，如整数。为了确保数据在网络上传输的一致性，通常采用大端字节序（Big Endian），也被称作网络字节序</p><p>针对这种需求，有几组常用的函数用于在主机字节序和网络字节序之间进行转换：</p><ol><li><strong><code>htonl</code> 和 <code>htons</code></strong>：这两个函数分别用于将32位整型（<code>long</code>）和16位整型（<code>short</code>）从主机字节序转换为网络字节序。<ul><li><code>htonl(uint32_t hostlong)</code>: Host to Network Long</li><li><code>htons(uint16_t hostshort)</code>: Host to Network Short</li></ul></li><li><strong><code>ntohl</code> 和 <code>ntohs</code></strong>：与上述相反，这两个函数用于将32位和16位整型从网络字节序转换为主机字节序。<ul><li><code>ntohl(uint32_t netlong)</code>: Network to Host Long</li><li><code>ntohs(uint16_t netshort)</code>: Network to Host Short</li></ul></li></ol><p>为了保证网络通信的兼容性，通常采用大端字节序（Big Endian），也称为网络字节序，来表示跨网络传输的数据。</p><p><strong>需要转换为网络字节序的数据类型</strong></p><ol><li><strong>端口号</strong>：端口号通常是16位的整数，在发送之前应该从主机字节序转换为网络字节序。</li><li><strong>IP地址</strong>：虽然IP地址通常以字符串形式表示（例如“192.168.0.1”），但在某些情况下，你可能会处理32位整型的IPv4地址或128位的IPv6地址。对于这些情况，如果需要直接操作整型值，则应确保它们是网络字节序。</li><li><strong>序列号、确认号等TCP头部字段</strong>：这些字段都是32位的整数，用于TCP协议中的状态跟踪和数据流控制，因此也需要转换为网络字节序。</li><li><strong>其他自定义协议中的多字节字段</strong>：如果你设计了一个自定义的应用层协议，并且该协议包含多字节整数字段（如长度指示符、版本号等），那么这些字段也应该按照网络字节序进行编码。</li></ol><h3 id="设置套接字等选项"><a href="#设置套接字等选项" class="headerlink" title="设置套接字等选项"></a>设置套接字等选项</h3><p><code>setsockopt</code> 是一个用于设置套接字选项的函数，它允许开发者对套接字的行为进行精细控制。通过 <code>setsockopt</code>，可以调整套接字的各种属性，例如<strong>地址复用</strong>、<strong>接收/发送缓冲区大小</strong>、超时时间等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure><ol><li><strong><code>sockfd</code></strong>:<ul><li>套接字描述符。</li><li>指定要设置选项的目标套接字。</li></ul></li><li><strong><code>level</code></strong>:<ul><li>选项所属的协议层。</li><li>常见值包括：<ul><li><code>SOL_SOCKET</code>: 套接字通用选项（如地址复用、广播等）。</li><li><code>IPPROTO_TCP</code>: TCP 协议相关选项。</li><li><code>IPPROTO_IP</code>: IP 协议相关选项。</li><li><code>IPPROTO_IPV6</code>: IPv6 相关选项。</li></ul></li></ul></li><li><strong><code>optname</code></strong>:<ul><li>具体的选项名称。</li><li>根据 <code>level</code> 的不同，可以选择不同的选项。</li></ul></li><li><strong><code>optval</code></strong>:<ul><li>指向选项值的指针。</li><li>选项值的具体类型和格式取决于 <code>optname</code>。</li></ul></li><li><strong><code>optlen</code></strong>:<ul><li><code>optval</code> 缓冲区的大小（以字节为单位）</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in"><span class="keyword">sizeof</span></span>(opt));</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong></p><ol><li><strong><code>SO_REUSEADDR</code></strong></li></ol><ul><li><strong>作用</strong>: 允许绑定到已被占用的地址和端口。</li><li><strong>场景</strong>: 通常用于避免因端口被占用而导致服务器无法启动的问题。</li></ul><p><strong>2. <code>SO_REUSEPORT</code></strong></p><ul><li><strong>作用</strong>: 允许多个进程或线程绑定到同一个端口。</li><li><strong>场景</strong>: 适用于多线程或多进程服务器模型。</li><li><strong>注意</strong>: 需要与 <code>SO_REUSEADDR</code> 配合使用</li></ul><p><strong>3. <code>SO_RCVBUF</code> 和 <code>SO_SNDBUF</code></strong></p><ul><li><p>作用</p><p>:</p><ul><li><code>SO_RCVBUF</code>: 设置接收缓冲区大小。</li><li><code>SO_SNDBUF</code>: 设置发送缓冲区大小。</li></ul></li></ul><p><strong>4. <code>SO_BROADCAST</code></strong></p><ul><li><strong>作用</strong>: 启用广播功能。</li><li><strong>场景</strong>: 用于 UDP 广播通信</li></ul><p><strong>5. <code>SO_KEEPALIVE</code></strong></p><ul><li><strong>作用</strong>: 启用 TCP 的保活机制。</li><li><strong>场景</strong>: 检测长时间空闲的连接是否仍然有效。</li></ul><p><strong>6. <code>SO_LINGER</code></strong></p><ul><li><strong>作用</strong>: 控制关闭套接字时的行为。</li><li><strong>场景</strong>: 当需要确保所有数据在关闭前被发送时。</li></ul><p><strong>7. <code>TCP_NODELAY</code></strong></p><ul><li><strong>作用</strong>: 禁用 Nagle 算法，减少小数据包的延迟。</li><li><strong>场景</strong>: 对于实时性要求较高的应用（如在线游戏、实时聊天）。</li></ul><h3 id="设置文件描述符选项"><a href="#设置文件描述符选项" class="headerlink" title="设置文件描述符选项"></a>设置文件描述符选项</h3><p>函数原型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>fd</code></strong>：目标文件描述符。</p></li><li><p><code>cmd</code></p><p>：指定要执行的操作类型，常见的命令包括：</p><ul><li><strong><code>F_GETFL</code></strong>：获取文件描述符的状态标志。</li><li><strong><code>F_SETFL</code></strong>：设置文件描述符的状态标志。</li><li><strong><code>F_GETFD</code></strong>：获取文件描述符的文件描述符标志。</li><li><strong><code>F_SETFD</code></strong>：设置文件描述符的文件描述符标志。</li><li><strong><code>F_DUPFD</code></strong>：复制文件描述符。</li><li><strong><code>F_DUPFD_CLOEXEC</code></strong>：复制文件描述符并设置 <code>FD_CLOEXEC</code> 标志。</li></ul></li><li><p><strong><code>arg</code></strong>：可选参数，具体取决于 <code>cmd</code> 的值。例如，在使用 <code>F_SETFL</code> 时，<code>arg</code> 是新的状态标志</p></li></ul><p>在网络编程中，将套接字设置为非阻塞模式是一种常见的优化手段。非阻塞模式允许在尝试读取或写入数据时立即返回，而不会阻塞进程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件描述符设置为非阻塞模式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_nonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flags = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>); <span class="comment">// 获取当前文件描述符的标志</span></span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl F_GETFL failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 O_NONBLOCK 标志</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl F_SETFL failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在非阻塞模式下：</p><ul><li>如果没有数据可读，<code>read()</code> 或 <code>recv()</code> 会立即返回 <code>-1</code>，并设置 <code>errno</code> 为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</li><li>如果无法立即写入数据，<code>write()</code> 或 <code>send()</code> 也会返回 <code>-1</code>，并设置 <code>errno</code> 为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</li></ul><p>文件状态标志可以通过 <code>fcntl(fd, F_GETFL)</code> 获取当前设置，并通过 <code>fcntl(fd, F_SETFL, flags)</code> 修改。</p><ul><li><strong><code>O_RDONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code></strong>：打开文件的模式（只读、只写、读写），通常在打开文件时确定，不能通过 <code>F_SETFL</code> 修改。</li><li><strong><code>O_APPEND</code></strong>：每次写入时将数据追加到文件末尾。</li><li><strong><code>O_NONBLOCK</code></strong>：设置非阻塞模式。对于文件或设备，这意味着尝试的操作（如读取或写入）如果无法立即完成，则会立即返回而不是阻塞等待。在网络编程中，这通常用于套接字以实现异步I/O。</li><li><strong><code>O_ASYNC</code></strong>：当I/O可用时发送信号（通常是 <code>SIGIO</code>）给进程。此功能允许进程异步地处理I/O事件。</li><li><strong><code>O_DSYNC</code> 和 <code>O_SYNC</code></strong>：要求同步写入。<code>O_DSYNC</code> 确保数据同步写入磁盘，而 <code>O_SYNC</code> 还包括文件元数据的同步写入。</li></ul><blockquote><p>在 TCP 套接字中，<code>read()</code> 和 <code>recv()</code> 都无法保证一次调用就能读取完整的数据包。可能需要循环读取，直到接收到完整的数据。</p><p>如果套接字是非阻塞模式，且没有数据可读，<code>read()</code> 会立即返回 <code>-1</code>，并设置 <code>errno</code> 为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</p><ul><li>如果套接字是阻塞模式，且没有数据可读，<code>read()</code> 会阻塞，直到有数据到达或发生错误。</li><li><code>read()</code> 不区分消息边界（特别是在 TCP 套接字中）。它只是简单地从流中读取尽可能多的数据。</li></ul><p><strong>非阻塞模式</strong></p><ul><li>在非阻塞模式下，如果没有数据可读，<code>read()</code> 和 <code>recv()</code> 都会立即返回 <code>-1</code>，并设置 <code>errno</code> 为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</li><li>在这种情况下，通常需要结合事件通知机制（如 <code>select()</code>、<code>poll()</code> 或 <code>epoll()</code>）来监听可读事件。</li></ul><p><strong>错误处理</strong></p><ul><li>处理 <code>EINTR</code>（信号中断）：如果 <code>read()</code> 或 <code>recv()</code> 返回 <code>-1</code> 并且 <code>errno</code> 为 <code>EINTR</code>，通常需要重试。</li><li>处理 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>：说明当前没有更多数据可读，等待下次事件通知即可。</li></ul></blockquote><h2 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h2><p>信号是操作系统向进程发送的一种异步通知机制，用于告知进程某个事件已经发生。信号可以被视为一种软件中断，它会打断进程的正常执行流程。</p><h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><p><strong><code>signal()</code> 函数</strong></p><p>这是最基本的信号处理函数，用于设置对指定信号的处理方式。然而，它不如 <code>sigaction</code> 灵活和可靠。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>signum</code>：要捕获或忽略的信号编号。</li><li><code>handler</code>：信号处理函数指针，或者 <code>SIG_DFL</code>（默认处理）、<code>SIG_IGN</code>（忽略）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_sigint</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught signal %d\n&quot;</span>, sig);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置 SIGINT (Ctrl+C) 的处理程序</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGINT, handle_sigint) == SIG_ERR) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Unable to set handler for SIGINT\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Process running...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linux 定义了许多标准信号，例如：</p><ul><li><code>SIGINT</code>（2）：由用户按下 <code>Ctrl+C</code> 触发，通常用于终止进程。</li><li><code>SIGTERM</code>（15）：请求终止进程的信号。</li><li><code>SIGKILL</code>（9）：强制终止进程的信号，无法被捕获或忽略。</li><li><code>SIGSEGV</code>（11）：段错误（访问非法内存地址）。</li><li><code>SIGCHLD</code>（17）：子进程状态改变时发送给父进程的信号。</li><li><code>SIGUSR1</code> 和 <code>SIGUSR2</code>：用户自定义信号。</li></ul><p>信号可以通过以下几种方式触发：</p><p><strong>(1) 用户输入</strong></p><ul><li>按下 <code>Ctrl+C</code> 会向当前前台进程发送 <code>SIGINT</code> 信号。</li><li>按下 <code>Ctrl+\</code> 会向当前前台进程发送 <code>SIGQUIT</code> 信号。</li></ul><p><strong>(2) 系统调用</strong></p><p>通过系统调用 <code>kill</code> 或 <code>raise</code> 可以向进程发送信号：</p><ul><li><code>kill(pid_t pid, int sig)</code>：向指定进程 ID 的进程发送信号。</li><li><code>raise(int sig)</code>：向当前进程自身发送信号。</li></ul><p><strong>(3) 硬件异常</strong></p><p>当进程访问非法内存地址时，操作系统会发送 <code>SIGSEGV</code> 信号；当进行非法指令操作时，可能会发送 <code>SIGILL</code> 信号。</p><p><strong>(4) 软件触发</strong></p><p>通过调用 <code>alarm</code> 函数可以设置定时器，超时时会向进程发送 <code>SIGALRM</code> 信号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received signal: %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGALRM, handler); <span class="comment">// 注册信号处理函数</span></span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">3</span>); <span class="comment">// 设置 3 秒后发送 SIGALRM 信号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Waiting for the alarm signal...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">pause</span>(); <span class="comment">// 挂起进程，等待信号</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h3><p><code>sigaction</code> 是 POSIX 标准定义的一种机制，用于定义进程对特定信号的响应行为。它提供了一种比 <code>signal()</code> 更加灵活和强大的方式来处理信号。<code>sigaction</code> 结构体用于指定如何处理信号、信号处理程序的属性以及信号掩码等信息。</p><p><code>sigaction</code> 提供了比 <code>signal()</code> 更加精细和强大的信号处理功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li><code>signum</code>：信号编号。</li><li><code>act</code>：指向包含新动作的 <code>struct sigaction</code> 结构体的指针。</li><li><code>oldact</code>：如果非空，则保存旧的动作。</li></ul></li></ul><p><strong><code>struct sigaction</code> 结构体</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span>     (*sa_handler)(<span class="keyword">int</span>);             <span class="comment">// 信号处理函数</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *); <span class="comment">// 用于带有附加信息的信号处理函数</span></span><br><span class="line">    <span class="keyword">sigset_t</span>   sa_mask;                       <span class="comment">// 在执行信号处理器期间需要阻塞的信号集合</span></span><br><span class="line">    <span class="keyword">int</span>        sa_flags;                      <span class="comment">// 控制信号处理的行为标志</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span>     (*sa_restorer)(<span class="keyword">void</span>);           <span class="comment">// 已废弃，不应使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>sigaction</code> 结构体用于指定如何处理信号、信号处理程序的属性以及信号掩码等信息。</p><p><strong>字段说明</strong></p><ul><li><strong><code>sa_handler</code></strong>：<ul><li>这是一个指向信号处理函数的指针，或者可以设置为 <code>SIG_DFL</code>（默认信号处理）或 <code>SIG_IGN</code>（忽略信号）。</li></ul></li><li><strong><code>sa_sigaction</code></strong>：<ul><li>当 <code>sa_flags</code> 中设置了 <code>SA_SIGINFO</code> 标志时，此字段将作为信号处理函数使用。与 <code>sa_handler</code> 不同，<code>sa_sigaction</code> 可以接收更多信息，包括一个指向 <code>siginfo_t</code> 结构的指针（包含有关信号的详细信息）和一个指向处理器上下文的指针（通常不使用）。</li></ul></li><li><strong><code>sa_mask</code></strong>：<ul><li>定义了一个信号集，在调用信号处理程序之前，这些信号会被加入到当前的信号屏蔽字中。这意味着在执行信号处理程序期间，这些信号会被暂时阻塞。</li></ul></li><li><strong><code>sa_flags</code></strong>：<ul><li>控制信号处理的行为。常见的标志包括：<ul><li><strong><code>SA_RESTART</code></strong>：如果信号中断了某个系统调用，则自动重启该系统调用（而不是返回错误）。</li><li><strong><code>SA_NOCLDSTOP</code></strong>：仅对 <code>SIGCHLD</code> 信号有效，如果设置了此标志，则子进程停止或恢复时不会发送 <code>SIGCHLD</code> 信号给父进程。</li><li><strong><code>SA_NOCLDWAIT</code></strong>：仅对 <code>SIGCHLD</code> 信号有效，阻止创建僵尸进程。</li><li><strong><code>SA_SIGINFO</code></strong>：指示使用 <code>sa_sigaction</code> 字段中的信号处理函数，而非 <code>sa_handler</code>。这允许访问扩展的信号信息。</li></ul></li></ul></li><li><strong><code>sa_restorer</code></strong>：<ul><li>这个字段已废弃，不应该被使用。</li></ul></li></ul><p><strong>使用示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">siginfo_t</span> *info, <span class="keyword">void</span> *context)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught signal %d\n&quot;</span>, signum);</span><br><span class="line">    <span class="comment">// 打印更多关于信号的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Signal code: %d\n&quot;</span>, info-&gt;si_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化结构体</span></span><br><span class="line">    act.sa_sigaction = handler;</span><br><span class="line">    act.sa_flags = SA_SIGINFO; <span class="comment">// 使用带有额外参数的信号处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充信号掩码，这里我们不限制任何额外的信号</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 SIGINT 的信号处理程序</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigaction</span>(SIGINT, &amp;act, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Waiting for SIGINT (Ctrl+C)...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起进程，等待信号</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pause</span>(); <span class="comment">// 等待信号</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h2><p><code>stat</code> 函数是 Unix 和类 Unix 操作系统（如 Linux）中的一个系统调用，用于获取文件或文件系统对象的相关信息。它通过填充一个 <code>struct stat</code> 结构体来提供文件的元数据，包括文件大小、权限、创建时间等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<ul><li><code>pathname</code>：要查询的文件或目录的路径。</li><li><code>statbuf</code>：指向一个 <code>struct stat</code> 结构体的指针，该结构体将被用来存储文件的状态信息。</li></ul></li><li><strong>返回值</strong>：<ul><li>成功时返回 <code>0</code>。</li><li>失败时返回 <code>-1</code> 并设置 <code>errno</code> 来指示错误类型。</li></ul></li></ul><p>除了 <code>stat</code>，还有其他几个类似的函数可以用于不同的场景：</p><ul><li><p><strong><code>fstat</code></strong>：与 <code>stat</code> 类似，但它接受一个文件描述符而不是路径名作为第一个参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *statbuf)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>lstat</code></strong>：与 <code>stat</code> 类似，但如果目标是一个符号链接（symlink），它会返回符号链接本身的信息，而不是它指向的目标文件的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p><code>struct stat</code> 包含了大量的关于文件的信息。以下是一些常用的字段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="keyword">dev_t</span>     st_dev;         <span class="comment">// 文件所在设备的标识符</span></span><br><span class="line">    <span class="keyword">ino_t</span>     st_ino;         <span class="comment">// inode 编号</span></span><br><span class="line">    <span class="keyword">mode_t</span>    st_mode;        <span class="comment">// 文件类型和访问权限</span></span><br><span class="line">    <span class="keyword">nlink_t</span>   st_nlink;       <span class="comment">// 硬链接数量</span></span><br><span class="line">    <span class="keyword">uid_t</span>     st_uid;         <span class="comment">// 文件所有者的用户 ID</span></span><br><span class="line">    <span class="keyword">gid_t</span>     st_gid;         <span class="comment">// 文件所有者的组 ID</span></span><br><span class="line">    <span class="keyword">dev_t</span>     st_rdev;        <span class="comment">// 如果文件是一个设备文件，则为其设备编号</span></span><br><span class="line">    <span class="keyword">off_t</span>     st_size;        <span class="comment">// 文件大小（字节数）</span></span><br><span class="line">    <span class="keyword">blksize_t</span> st_blksize;     <span class="comment">// 文件系统的 I/O 块大小</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span>  st_blocks;      <span class="comment">// 分配给文件的块数</span></span><br><span class="line">    <span class="keyword">time_t</span>    st_atime;       <span class="comment">// 最后访问时间</span></span><br><span class="line">    <span class="keyword">time_t</span>    st_mtime;       <span class="comment">// 最后修改时间</span></span><br><span class="line">    <span class="keyword">time_t</span>    st_ctime;       <span class="comment">// 最后状态改变时间（在 Unix 中通常为元数据更改时间）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>struct stat</code> 的 <code>st_mode</code> 字段中，文件类型和权限信息被编码在一起。可以通过位操作提取这些信息：</p><ul><li><strong>文件类型</strong>：<ul><li><code>S_IFMT</code>：文件类型的掩码。</li><li><code>S_IFDIR</code>：目录。</li><li><code>S_IFCHR</code>：字符设备。</li><li><code>S_IFBLK</code>：块设备。</li><li><code>S_IFREG</code>：普通文件。</li><li><code>S_IFIFO</code>：命名管道（FIFO）。</li><li><code>S_IFLNK</code>：符号链接。</li><li><code>S_IFSOCK</code>：套接字。</li></ul></li><li><strong>权限</strong>：<ul><li><code>S_IRUSR</code>, <code>S_IWUSR</code>, <code>S_IXUSR</code>：用户（拥有者）的读、写、执行权限。</li><li><code>S_IRGRP</code>, <code>S_IWGRP</code>, <code>S_IXGRP</code>：组的读、写、执行权限。</li><li><code>S_IROTH</code>, <code>S_IWOTH</code>, <code>S_IXOTH</code>：其他人的读、写、执行权限。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((sb.st_mode &amp; S_IFMT) == S_IFREG &amp;&amp; (sb.st_mode &amp; S_IRUSR)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a regular file with read permission for the owner.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p><code>mmap</code> 是 Unix 和类 Unix 系统（如 Linux）中的一个系统调用，用于<strong>将文件或设备的内存映射到进程的地址空间</strong>。这种机制允许程序以类似于访问内存的方式访问文件内容，从而简化了文件操作，并且可以提高性能，特别是在处理大文件时。</p><ul><li><strong>文件映射</strong>：将文件的内容映射到进程的虚拟内存中，使得可以通过指针直接访问文件的数据，而不需要通过常规的文件 I/O 操作（如 <code>read</code> 和 <code>write</code>）。</li><li><strong>共享内存</strong>：允许多个进程共享同一块内存区域，实现高效的进程间通信（IPC）。</li><li><strong>匿名映射</strong>：创建不与任何文件关联的内存映射，适用于需要动态分配大块内存的情况</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<ul><li><code>addr</code>：建议的映射起始地址（通常设为 <code>NULL</code>，让系统选择合适的地址）。</li><li><code>length</code>：映射区域的大小（字节数）。</li><li>prot：指定映射区域的保护标志（如可读、可写、可执行等）。<ul><li><code>PROT_READ</code>：映射区域可读。</li><li><code>PROT_WRITE</code>：映射区域可写。</li><li><code>PROT_EXEC</code>：映射区域可执行。</li></ul></li><li>flags：控制映射区域的行为。<ul><li><code>MAP_SHARED</code>：映射区域会被多个进程共享，修改会反映到文件中。</li><li><code>MAP_PRIVATE</code>：创建私有副本，修改不会影响原文件。</li><li><code>MAP_ANONYMOUS</code>：映射匿名内存（不与文件关联）。</li></ul></li><li><code>fd</code>：要映射的文件描述符（对于匿名映射，应设置为 <code>-1</code>）。</li><li><code>offset</code>：从文件开头开始的偏移量（必须是页面大小的倍数）。</li></ul></li><li><p><strong>返回值</strong>：</p><ul><li>成功时返回指向映射区域的指针。</li><li>失败时返回 <code>MAP_FAILED</code>（通常定义为 <code>(void *) -1</code>），并设置 <code>errno</code>。</li></ul></li><li><p><strong><code>munmap</code></strong>：解除内存映射。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>msync</code></strong>：同步内存映射区域到文件或设备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="解析传入参数"><a href="#解析传入参数" class="headerlink" title="解析传入参数"></a>解析传入参数</h2><p>Linux中<code>getopt</code> 是一个用于解析命令行选项的标准 C 库函数。它使得程序能够处理以短格式（如 <code>-a</code>, <code>-b value</code>）提供的命令行参数。<code>getopt</code> 函数及其扩展版本 <code>getopt_long</code> 为开发者提供了便捷的方式来解析和处理命令行选项。</p><h4 id="get-opt函数"><a href="#get-opt函数" class="headerlink" title="get_opt函数"></a>get_opt函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[], <span class="keyword">const</span> <span class="keyword">char</span> *optstring)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>参数</strong>：</p><ul><li><code>argc</code> 和 <code>argv</code>：分别是从 <code>main</code> 函数传递过来的参数计数和参数数组。</li><li><code>optstring</code>：包含程序所支持的选项字符组成的字符串。如果某个选项需要参数，则在该选项字符后加上冒号（<code>:</code>），表示该选项需要一个值。</li></ul></li><li><p><strong>返回值</strong>：</p><ul><li>成功时，返回下一个选项字符。</li><li>当所有选项都已处理完毕，返回 <code>-1</code>。</li><li>如果遇到无效选项或缺少必需的参数，返回 <code>?</code> 并设置 <code>optopt</code> 变量为无效选项字符。</li></ul></li><li><p><strong>全局变量</strong>：</p><ul><li><code>optind</code>：指向下一个要处理的 <code>argv</code> 元素的索引。</li><li><code>optarg</code>：<strong>指向当前选项的参数</strong>（如果有）。</li><li><code>opterr</code>：控制 <code>getopt</code> 是否打印错误消息，默认为 1（开启）。</li><li><code>optopt</code>：存储无效选项字符或缺失参数的选项字符。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt;</span><br><span class="line">    <span class="keyword">while</span> ((opt = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;ab:c&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Option -a\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Option -b with value %s\n&quot;</span>, optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Option -c\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (optopt == <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Option -b requires an argument.\n&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Unknown option character `\\x%x&#x27;.\n&quot;</span>, optopt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理非选项参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = optind; index &lt; argc; index++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Non-option argument: %s\n&quot;</span>, argv[index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="getopt-long-函数"><a href="#getopt-long-函数" class="headerlink" title="getopt_long 函数"></a><code>getopt_long</code> 函数</h4><p>对于支持长格式选项（如 <code>--option</code>, <code>--option=value</code>）的应用程序，可以使用 <code>getopt_long</code> 函数。</p><h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a><strong>函数原型</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt_long</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[], <span class="keyword">const</span> <span class="keyword">char</span> *shortopts, <span class="keyword">const</span> struct option *longopts, <span class="keyword">int</span> *longindex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>参数</strong>：</p><ul><li><p><code>shortopts</code>：与 <code>getopt</code> 相同，定义短格式选项。</p></li><li><p>longopts指向描述长格式选项的struct option</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">option</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;    <span class="comment">// 长格式选项名</span></span><br><span class="line">    <span class="keyword">int</span>         has_arg; <span class="comment">// 是否需要参数，可能值：no_argument, required_argument, optional_argument</span></span><br><span class="line">    <span class="keyword">int</span>        *flag;    <span class="comment">// 若不为 NULL，函数将此指针指向的变量设为 val；若为 NULL，函数返回 val</span></span><br><span class="line">    <span class="keyword">int</span>         val;     <span class="comment">// 返回给 `getopt_long` 的值或设置到 `flag` 指向的变量中</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>longindex</code>：如果非 <code>NULL</code>，则指向一个变量，该变量接收匹配的长选项在 <code>longopts</code> 数组中的索引。</p></li></ul></li><li><p><strong>返回值</strong>：</p><ul><li>成功时，返回匹配选项的字符（对于短选项）或 <code>val</code> 字段的值（对于长选项）。</li><li>当所有选项都已处理完毕，返回 <code>-1</code>。</li><li>对于无效选项或缺少必需的参数，返回 <code>?</code>。</li></ul></li><li><p><strong><code>getopt</code></strong>：适用于处理短格式选项的简单场景。通过指定一个选项字符串来定义允许的选项及是否需要参数。</p></li><li><strong><code>getopt_long</code></strong>：扩展了 <code>getopt</code>，支持长格式选项，并允许更灵活地配置每个选项的行为（是否需要参数、如何处理等）。</li></ul><h2 id="分散-聚集IO"><a href="#分散-聚集IO" class="headerlink" title="分散/聚集IO"></a>分散/聚集IO</h2><p>分散/聚集 I/O（Scatter/Gather I/O）是一种<strong>允许在单次系统调用中处理多个数据缓冲区的技术</strong>。它特别适用于需要处理多个不连续的数据块的应用场景，如网络通信、数据库操作等。通过分散/聚集 I/O，可以减少系统调用的次数，提高性能和效率。</p><h4 id="分散-I-O（Scatter-I-O）"><a href="#分散-I-O（Scatter-I-O）" class="headerlink" title="分散 I/O（Scatter I/O）"></a>分散 I/O（Scatter I/O）</h4><p>分散读取（Scatter Read）指的是从一个输入源（例如文件或套接字）读取数据，并将这些数据分散到多个缓冲区中。这种技术通常用于接收长度未知的数据流，并将其分割成多个部分存储在不同的缓冲区中。</p><h4 id="聚集-I-O（Gather-I-O）"><a href="#聚集-I-O（Gather-I-O）" class="headerlink" title="聚集 I/O（Gather I/O）"></a>聚集 I/O（Gather I/O）</h4><p>聚集写入（Gather Write）则是指将多个缓冲区中的数据收集起来，然后一次性写入到输出目标（例如文件或套接字）。这种方法可以简化编程模型，并且通过减少系统调用的数量来提高性能。</p><p>在 Unix 和类 Unix 系统（如 Linux）中，分散/聚集 I/O 主要通过 <code>readv</code> 和 <code>writev</code> 系统调用来实现。</p><p><strong><code>readv</code> 和 <code>writev</code> 函数</strong></p><ul><li><strong><code>readv</code></strong>：从文件描述符读取数据并分散到多个缓冲区。</li><li><strong><code>writev</code></strong>：从多个缓冲区收集数据并写入到文件描述符。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>  *iov_base;    <span class="comment">// 指向缓冲区的指针</span></span><br><span class="line">    <span class="keyword">size_t</span> iov_len;     <span class="comment">// 缓冲区长度（字节数）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;example.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf1[<span class="number">6</span>]; <span class="comment">// 存储 &quot;Hello,&quot;</span></span><br><span class="line">    <span class="keyword">char</span> buf2[<span class="number">8</span>]; <span class="comment">// 存储 &quot; World!\n&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[2];</span></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = buf1;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="built_in"><span class="keyword">sizeof</span></span>(buf1);</span><br><span class="line">    iov[<span class="number">1</span>].iov_base = buf2;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="built_in"><span class="keyword">sizeof</span></span>(buf2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> read_bytes = <span class="built_in">readv</span>(fd, iov, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (read_bytes == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;readv&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf1[<span class="built_in"><span class="keyword">sizeof</span></span>(buf1)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 确保 buf1 是以 null 结尾的字符串</span></span><br><span class="line">    buf2[<span class="built_in"><span class="keyword">sizeof</span></span>(buf2)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 确保 buf2 是以 null 结尾的字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read %zd bytes: &#x27;%s&#x27; and &#x27;%s&#x27;\n&quot;</span>, read_bytes, buf1, buf2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP流程"><a href="#TCP流程" class="headerlink" title="TCP流程"></a>TCP流程</h2><p><strong>TCP Server</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_fd, new_socket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="keyword">int</span> addrlen = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *response = <span class="string">&quot;Hello from server&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定地址和端口</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(server_fd, (struct sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Bind failed&quot;</span>);</span><br><span class="line">        close(server_fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听连接</span></span><br><span class="line">    <span class="keyword">if</span> (listen(server_fd, <span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Listen failed&quot;</span>);</span><br><span class="line">        close(server_fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Server is listening on port %d...\n&quot;</span>, PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受客户端连接</span></span><br><span class="line">    <span class="keyword">if</span> ((new_socket = accept(server_fd, (struct sockaddr *)&amp;address, (<span class="keyword">socklen_t</span> *)&amp;addrlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Accept failed&quot;</span>);</span><br><span class="line">        close(server_fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取客户端数据</span></span><br><span class="line">    <span class="keyword">int</span> valread = read(new_socket, buffer, BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Client: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送响应</span></span><br><span class="line">    send(new_socket, response, <span class="built_in">strlen</span>(response), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Response sent to client.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(new_socket);</span><br><span class="line">    close(server_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TCP Client</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *message = <span class="string">&quot;Hello from client&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 IP 地址转换为二进制形式</span></span><br><span class="line">    <span class="keyword">if</span> (inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Invalid address/ Address not supported&quot;</span>);</span><br><span class="line">        close(sock);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Connection failed&quot;</span>);</span><br><span class="line">        close(sock);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    send(sock, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message sent to server.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收响应</span></span><br><span class="line">    <span class="keyword">int</span> valread = read(sock, buffer, BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Server: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *message = <span class="string">&quot;Hello from client&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 IP 地址转换为二进制形式</span></span><br><span class="line">    <span class="keyword">if</span> (inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Invalid address/ Address not supported&quot;</span>);</span><br><span class="line">        close(sock);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Connection failed&quot;</span>);</span><br><span class="line">        close(sock);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    send(sock, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message sent to server.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收响应</span></span><br><span class="line">    <span class="keyword">int</span> valread = read(sock, buffer, BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Server: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UDP流程"><a href="#UDP流程" class="headerlink" title="UDP流程"></a>UDP流程</h2><p><strong>UDP Server</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PORT = <span class="number">8080</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd;</span><br><span class="line">  <span class="keyword">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">  sockaddr_in servaddr, cliaddr;</span><br><span class="line">  <span class="keyword">socklen_t</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *response = <span class="string">&quot;Hello from server&quot;</span>;</span><br><span class="line">  <span class="comment">// 创建套接字 SOCK_DGRAM</span></span><br><span class="line">  <span class="keyword">if</span> ((sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">  <span class="built_in">memset</span>(&amp;cliaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定地址和端口</span></span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bind</span>(sockfd, (<span class="keyword">const</span> struct sockaddr *)&amp;servaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;Bind failed&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Server is listening on port %d...\n&quot;</span>, PORT);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 服务端绑定套接字后 直接开始读了</span></span><br><span class="line">  <span class="comment">// 接收客户端数据</span></span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">recvfrom</span>(sockfd, (<span class="keyword">char</span> *)buffer, BUFFER_SIZE, <span class="number">0</span>,</span><br><span class="line">                   (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">  buffer[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Client: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送响应</span></span><br><span class="line">  <span class="built_in">sendto</span>(sockfd, (<span class="keyword">const</span> <span class="keyword">char</span> *)response, <span class="built_in">strlen</span>(response), <span class="number">0</span>,</span><br><span class="line">         (<span class="keyword">const</span> struct sockaddr *)&amp;cliaddr, len);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Response sent to client.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(sockfd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UDP Client</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd;</span><br><span class="line">  <span class="keyword">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *message = <span class="string">&quot;Hello from client&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建套接字</span></span><br><span class="line">  <span class="keyword">if</span> ((sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置服务器地址</span></span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">  servaddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 IP 地址转换为二进制形式</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;servaddr.sin_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;Invalid address/ Address not supported&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建套接字 后直接发送消息 需要连接的地址,不需要connect</span></span><br><span class="line">  <span class="comment">// 发送消息</span></span><br><span class="line">  <span class="built_in">sendto</span>(sockfd, (<span class="keyword">const</span> <span class="keyword">char</span> *)message, <span class="built_in">strlen</span>(message), <span class="number">0</span>,</span><br><span class="line">         (<span class="keyword">const</span> struct sockaddr *)&amp;servaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Message sent to server.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收响应</span></span><br><span class="line">  <span class="keyword">socklen_t</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr);</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">recvfrom</span>(sockfd, (<span class="keyword">char</span> *)buffer, BUFFER_SIZE, <span class="number">0</span>,</span><br><span class="line">                   (struct sockaddr *)&amp;servaddr, &amp;len);</span><br><span class="line">  buffer[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Server: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(sockfd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步IO机制"><a href="#异步IO机制" class="headerlink" title="异步IO机制"></a>异步IO机制</h2><p><img data-src="https://pic1.zhimg.com/v2-25903c3b11d19c9bbbc2f414665a435e_1440w.jpg" alt="img"></p><p><a href="https://arthurchiao.art/blog/intro-to-io-uring-zh/#24-三种工作模式">[译] Linux 异步 I/O 框架 io_uring：基本原理、程序示例与性能压测（2020）</a></p><p><a href="https://www.cnblogs.com/schips/p/12575933.html">Linux 网络编程的5种IO模型：异步IO模型 - schips - 博客园</a></p><p><a href="https://zhuanlan.zhihu.com/p/577599879">一篇文章彻底搞懂linux的异步IO - 知乎</a></p><h3 id="POSIX异步IO"><a href="#POSIX异步IO" class="headerlink" title="POSIX异步IO"></a>POSIX异步IO</h3><p>POSIX异步I/O提供了一种机制，允许应用程序在执行I/O操作时不会被阻塞，这意味着程序可以在I/O操作完成的同时继续执行其他任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* Asynchronous I/O control block.  */</span><br><span class="line">struct aiocb</span><br><span class="line">&#123;</span><br><span class="line">  int aio_fildes;/* File descriptor.  */</span><br><span class="line">  int aio_lio_opcode;/* Operation to be performed.  */</span><br><span class="line">  int aio_reqprio;/* Request priority offset.  */</span><br><span class="line">  volatile void *aio_buf;/* Location of buffer.  */</span><br><span class="line">  size_t aio_nbytes;/* Length of transfer.  */</span><br><span class="line">  struct sigevent aio_sigevent;/* Signal number and value.  */</span><br><span class="line"></span><br><span class="line">  /* Internal members.  */</span><br><span class="line">  struct aiocb *__next_prio;</span><br><span class="line">  int __abs_prio;</span><br><span class="line">  int __policy;</span><br><span class="line">  int __error_code;</span><br><span class="line">  __ssize_t __return_value;</span><br><span class="line"></span><br><span class="line">#ifndef __USE_FILE_OFFSET64</span><br><span class="line">  __off_t aio_offset;/* File offset.  */</span><br><span class="line">  char __pad[sizeof (__off64_t) - sizeof (__off_t)];</span><br><span class="line">#else</span><br><span class="line">  __off64_t aio_offset;/* File offset.  */</span><br><span class="line">#endif</span><br><span class="line">  char __glibc_reserved[32];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>struct aiocb</code></strong>：这是异步I/O控制块，包含了关于异步I/O操作的所有信息。包括但不限于<strong>文件描述符、缓冲区地址、请求的状态</strong>等。</p><p>通知方式有<strong>不通知</strong>,<strong>信号通知</strong>,在新线程中<strong>调用指定函数</strong>等</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">__sigval_t</span> sigev_value;</span><br><span class="line">    <span class="keyword">int</span> sigev_signo;</span><br><span class="line">    <span class="keyword">int</span> sigev_notify;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line"><span class="keyword">int</span> _pad[__SIGEV_PAD_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* When SIGEV_SIGNAL and SIGEV_THREAD_ID set, LWP ID of the</span></span><br><span class="line"><span class="comment">   thread to receive the signal.  */</span></span><br><span class="line"><span class="keyword">__pid_t</span> _tid;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*_function) (<span class="keyword">__sigval_t</span>);<span class="comment">/* Function to start.  */</span></span><br><span class="line">    <span class="keyword">pthread_attr_t</span> *_attribute;<span class="comment">/* Thread attributes.  */</span></span><br><span class="line">  &#125; _sigev_thread;</span><br><span class="line">      &#125; _sigev_un;</span><br><span class="line">  &#125; <span class="keyword">sigevent_t</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>sigev_notify</code></strong>：指定通知的方式。常见的选项包括：</p><ul><li><code>SIGEV_NONE</code>：不发送任何通知。</li><li><code>SIGEV_SIGNAL</code>：当异步事件发生时，向进程发送指定的信号。</li><li><code>SIGEV_THREAD</code>：当异步事件发生时，在新线程中调用指定的函数。</li><li><code>SIGEV_THREAD_ID</code>：特定于Linux的一个扩展，允许向特定线程发送信号。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  SIGEV_SIGNAL = <span class="number">0</span>,<span class="comment">/* Notify via signal.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SIGEV_SIGNALSIGEV_SIGNAL</span></span><br><span class="line">  SIGEV_NONE,<span class="comment">/* Other notification: meaningless.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SIGEV_NONESIGEV_NONE</span></span><br><span class="line">  SIGEV_THREAD,<span class="comment">/* Deliver via thread creation.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SIGEV_THREADSIGEV_THREAD</span></span><br><span class="line"></span><br><span class="line">  SIGEV_THREAD_ID = <span class="number">4</span><span class="comment">/* Send signal to specific thread.</span></span><br><span class="line"><span class="comment">   This is a Linux extension.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGEV_THREAD_IDSIGEV_THREAD_ID</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong><code>sigev_signo</code></strong>：如果选择了 <code>SIGEV_SIGNAL</code> 作为通知方式，则此字段应设置为希望发送的信号编号（例如 <code>SIGIO</code>）。</p></li><li><p><strong><code>sigev_value</code></strong>：这是一个联合体，可用于将数据传递给信号处理器或回调函数。这可以是任意数据，通常用于标识哪个异步I/O操作触发了通知。</p></li><li><p><strong><code>sigev_notify_function</code></strong>：当选择 <code>SIGEV_THREAD</code> 作为通知方式时，此字段应指向一个函数，该函数将在新线程中被调用来处理事件。</p></li><li><p><strong><code>sigev_notify_attributes</code></strong>：如果选择了 <code>SIGEV_THREAD</code> 作为通知方式，可以通过此字段提供线程属性对象，以定制创建的新线程的特性。</p></li></ul><ol><li><strong><code>aio_read()</code></strong><ul><li>发起一个异步读操作。它接受一个指向 <code>aiocb</code> 结构的指针作为参数，并返回一个整数值。如果成功，则返回0；如果失败，则返回-1，并设置相应的错误码。</li></ul></li><li><strong><code>aio_write()</code></strong><ul><li>发起一个异步写操作。与 <code>aio_read()</code> 类似，它也接受一个指向 <code>aiocb</code> 结构的指针，并根据是否成功返回0或-1。</li></ul></li><li><strong><code>aio_error()</code></strong><ul><li>检查指定的异步I/O操作的状态。如果操作还在进行中，它将返回 <code>EINPROGRESS</code>；如果操作已经完成，但发生了错误，它会返回相应的错误码；如果操作成功完成，它会返回0。</li></ul></li><li><strong><code>aio_return()</code></strong><ul><li>获取已完成的异步I/O操作的返回状态。只有当 <code>aio_error()</code> 对特定的 <code>aiocb</code> 结构返回除了 <code>EINPROGRESS</code> 之外的值时，调用 <code>aio_return()</code> 才有意义。</li></ul></li><li><strong><code>aio_cancel()</code></strong><ul><li>尝试取消一个或多个尚未完成的异步I/O请求。可以针对特定的 <code>aiocb</code> 取消，也可以尝试取消某个文件描述符上的所有异步I/O请求。</li></ul></li><li><strong><code>aio_suspend()</code></strong><ul><li>挂起调用进程或线程，直到指定的一个或多个异步I/O请求完成或者发生超时（如果提供了超时参数）。这对于等待一组异步I/O操作完成特别有用。</li></ul></li><li><strong><code>lio_listio()</code></strong><ul><li>同时发起一系列的读写操作。这可以是一个列表的读操作、写操作或是两者的组合。此函数支持两种模式：同步和异步。在异步模式下，即使I/O操作未完成，该函数也会立即返回。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libaio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="keyword">int</span> MAX_LSIT = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">siginfo_t</span> *si, <span class="keyword">void</span> *unused)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Async I/O completed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> <span class="title">cb</span>;</span></span><br><span class="line">  <span class="keyword">int</span> fd, ret, counter;</span><br><span class="line">  fd = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;open file error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">  <span class="comment">// 设置信号处理</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">  sa.sa_flags = SA_SIGINFO;</span><br><span class="line">  sa.sa_sigaction = handler;</span><br><span class="line">  <span class="built_in">sigemptyset</span>(&amp;sa.sa_mask);</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGUSR1, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置异步I/O控制块</span></span><br><span class="line">  cb.aio_fildes = fd;</span><br><span class="line">  cb.aio_lio_opcode = LIO_READ;</span><br><span class="line">  cb.aio_buf = buf;</span><br><span class="line">  cb.aio_nbytes = BUFFER_SIZE;</span><br><span class="line">  cb.aio_offset = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//   设置通知方式</span></span><br><span class="line">  cb.aio_sigevent.sigev_notify = SIGEV_SIGNAL;</span><br><span class="line">  <span class="comment">//   当使用信号通知,设置信号值等参数</span></span><br><span class="line">  cb.aio_sigevent.sigev_signo = SIGUSR1;</span><br><span class="line">  <span class="comment">//   如果使用在SIGEV_THREAD 作为通知方式时，此字段应指向一个函数</span></span><br><span class="line"><span class="comment">//   cb.aio_sigevent.sigev_notify_function = NULL;</span></span><br><span class="line">  <span class="comment">// 传递字符串</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">aio_read</span>(&amp;cb) == <span class="number">-1</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;aio_read error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;aio_read&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> couter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">aio_error</span>(&amp;cb) == EINPROGRESS) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第%d次\n&quot;</span>,++couter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> bytesRead = <span class="built_in">aio_return</span>(&amp;cb);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Read %d bytes\n&quot;</span>, bytesRead);</span><br><span class="line">  std::cout &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> <span class="title">my_aiocb</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配缓冲区</span></span><br><span class="line">    <span class="keyword">size_t</span> buffer_size = <span class="number">4096</span>; <span class="comment">// 假设缓冲区大小为 4KB</span></span><br><span class="line">    <span class="keyword">char</span> *buffer = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(buffer_size);</span><br><span class="line">    <span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="string">&#x27;A&#x27;</span>, buffer_size); <span class="comment">// 初始化缓冲区内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 aiocb 结构体</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;my_aiocb, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct aiocb));</span><br><span class="line">    my_aiocb.aio_fildes = fd;              <span class="comment">// 文件描述符</span></span><br><span class="line">    my_aiocb.aio_buf = buffer;             <span class="comment">// 缓冲区指针</span></span><br><span class="line">    my_aiocb.aio_nbytes = buffer_size;     <span class="comment">// 写入的字节数</span></span><br><span class="line">    my_aiocb.aio_offset = <span class="number">0</span>;               <span class="comment">// 写入的偏移量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起异步写操作</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">aio_write</span>(&amp;my_aiocb) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;aio_write&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(buffer); <span class="comment">// 释放缓冲区</span></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Asynchronous write operation initiated.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待异步操作完成</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">while</span> ((err = <span class="built_in">aio_error</span>(&amp;my_aiocb)) == EINPROGRESS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Write operation still in progress...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// 等待一段时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查异步操作的状态</span></span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> bytes_written = <span class="built_in">aio_return</span>(&amp;my_aiocb);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Asynchronous write completed successfully. Bytes written: %zd\n&quot;</span>, bytes_written);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Asynchronous write failed with error: %s\n&quot;</span>, <span class="built_in">strerror</span>(err));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放缓冲区</span></span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述aio其实是<strong>用户层使用线程模拟的异步io</strong>，缺点是占用线程资源而且受可用线程的数量限制。Linux2.6版本后有了libaio，这完全是内核级别的异步IO，IO请求完全由底层自由调度</p><h3 id="Linux原生AIO"><a href="#Linux原生AIO" class="headerlink" title="Linux原生AIO"></a>Linux原生AIO</h3><blockquote><p>Linux Native AIO 是 Linux 支持的原生 AIO，为什么要加原生这个词呢？因为Linux存在很多第三方的异步 IO 库，如 libeio 和 glibc AIO。所以为了加以区别，Linux 的内核提供的异步 IO 就称为原生异步 IO。很多第三方的异步 IO 库都不是真正的异步 IO，而是使用多线程来模拟异步 IO，如 libeio 就是使用多线程来模拟异步 IO 的。</p></blockquote><p>一般来说，使用 Linux 原生 AIO 需要 3 个步骤：</p><ul><li>1) 调用 io_setup 函数创建一个一般 IO 上下文。</li><li>2) 调用 io_submit 函数向内核提交一个异步 IO 操作。</li><li>3) 调用 io_getevents 函数获取异步 IO 操作结果。</li></ul><blockquote><p>可以通过libaio库调用原生系统调用</p></blockquote><ol><li><strong><code>io_setup()</code></strong><ul><li>初始化一个AIO上下文，返回一个上下文标识符供后续操作使用。</li></ul></li><li><strong><code>io_submit()</code></strong><ul><li>提交一个或多个异步I/O请求到指定的AIO上下文中。</li></ul></li><li><strong><code>io_getevents()</code></strong><ul><li>获取已完成的异步I/O操作的结果。可以通过此函数查询已提交的I/O请求的状态。</li></ul></li><li><strong><code>io_destroy()</code></strong><ul><li>销毁一个AIO上下文，释放相关资源。</li></ul></li><li><strong><code>struct iocb</code></strong><ul><li>这个结构用于描述单个I/O操作的信息，包括操作类型（读、写等）、文件描述符、缓冲区地址及大小等。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iocb</span> &#123;</span></span><br><span class="line"><span class="built_in">PADDEDptr</span>(<span class="keyword">void</span> *data, __pad1);<span class="comment">/* Return in the io completion event */</span></span><br><span class="line"><span class="comment">/* key: For use in identifying io requests */</span></span><br><span class="line"><span class="comment">/* aio_rw_flags: RWF_* flags (such as RWF_NOWAIT) */</span></span><br><span class="line"><span class="built_in">PADDED</span>(<span class="keyword">unsigned</span> key, aio_rw_flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span>aio_lio_opcode;</span><br><span class="line"><span class="keyword">short</span>aio_reqprio;</span><br><span class="line"><span class="keyword">int</span>aio_fildes;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_iocb_common</span><span class="title">c</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_iocb_vector</span><span class="title">v</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_iocb_poll</span><span class="title">poll</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_iocb_sockaddr</span><span class="title">saddr</span>;</span></span><br><span class="line">&#125; u;</span><br><span class="line">&#125;; <span class="comment">//描述一个异步 I/O 请求</span></span><br></pre></td></tr></table></figure><ul><li><code>data</code>：用户可以设置一个指针，用于在回调或完成事件中标识这个请求。</li><li><code>aio_lio_opcode</code>：指定操作类型，例如读取 (<code>IO_CMD_PREAD</code>) 或写入 (<code>IO_CMD_PWRITE</code>)。</li><li><code>aio_fildes</code>：目标文件的文件描述符。</li><li><code>u.c</code>：包含具体操作的参数（如缓冲区地址、偏移量、字节数等）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_event</span> &#123;</span></span><br><span class="line"><span class="built_in">PADDEDptr</span>(<span class="keyword">void</span> *data, __pad1);</span><br><span class="line"><span class="built_in">PADDEDptr</span>(struct iocb *obj,  __pad2);</span><br><span class="line"><span class="built_in">PADDEDul</span>(res,  __pad3);</span><br><span class="line"><span class="built_in">PADDEDul</span>(res2, __pad4);</span><br><span class="line">&#125;; <span class="comment">//描述一个已完成的异步 I/O 操作的结果</span></span><br></pre></td></tr></table></figure><ul><li><code>data</code> 和 <code>obj</code>：用于匹配完成事件和原始请求。</li><li><code>res</code>：表示操作的结果。如果大于等于 0，则表示成功完成的字节数；如果小于 0，则表示发生错误，其值为负的错误码（如 <code>-EIO</code>）。</li><li><code>res2</code>：通常不使用，但在某些情况下可能包含额外的信息。</li></ul><p><strong><code>`io_context_t</code></strong></p><ul><li><p><strong>作用</strong>：表示一个异步 I/O 上下文，用于管理一组异步 I/O 请求。</p></li><li><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">io_context</span> *<span class="title">io_context_t</span>;</span></span><br></pre></td></tr></table></figure></li><li><p>说明</p><ul><li>一个 <code>io_context_t</code> 可以管理多个异步 I/O 请求。</li></ul></li></ul><p>注意添加链接库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libaio-dev </span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(linux_aio</span><br><span class="line">    PRIVATE</span><br><span class="line">    -laio</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libaio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">io_context_t</span> ctx;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iocb</span> <span class="title">cb</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iocb</span> *<span class="title">cbs</span>[1];</span></span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">char</span> buf[] = <span class="string">&quot;Hello,world&quot;</span>;</span><br><span class="line">  fd = <span class="built_in">open</span>(<span class="string">&quot;test1.txt&quot;</span>, O_RDWR | O_CREAT | O_DIRECT, <span class="number">0644</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;open:&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;ctx, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">io_context_t</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//   io事件的初始化</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">io_setup</span>(<span class="number">1</span>, &amp;ctx) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;io_setup:&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交io事件</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;cb, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct iocb));</span><br><span class="line">  cb.aio_fildes = fd;</span><br><span class="line">  cb.aio_lio_opcode = IO_CMD_PWRITE;</span><br><span class="line">  <span class="keyword">char</span> msg[] = <span class="string">&quot;aio query&quot;</span>;</span><br><span class="line">  cb.data = msg;</span><br><span class="line">  cb.u.c.buf = buf;</span><br><span class="line">  cb.u.c.nbytes = <span class="built_in">strlen</span>(buf);</span><br><span class="line">  cb.u.c.offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  cbs[<span class="number">0</span>] = &amp;cb;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">io_submit</span>(ctx, <span class="number">1</span>, cbs) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;io_submit:&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">io_event</span> <span class="title">events</span>[1];</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">io_getevents</span>(ctx, <span class="number">1</span>, <span class="number">1</span>, events, <span class="literal">nullptr</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;io_getevents:&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (events[<span class="number">0</span>].res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;io_getevents:&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;aio getevents:&quot;</span> &lt;&lt; (<span class="keyword">char</span> *)events[<span class="number">0</span>].data &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;aio getevents:&quot;</span> &lt;&lt; events[<span class="number">0</span>].res &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;aio getevents:&quot;</span> &lt;&lt; events[<span class="number">0</span>].res2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">io_destroy</span>(ctx);</span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意,如果使用<code>O_DIRECT</code>标志打开有限制.<code>O_DIRECT</code> 是一种特殊的文件打开模式，它绕过操作系统的页缓存，直接与磁盘设备交互。</p><p><strong>(1) 缓冲区对齐</strong></p><ul><li><strong>地址对齐</strong>：缓冲区的起始地址必须是对齐的，通常是硬件块大小的倍数（通常是 512 字节或 4KB）。</li><li><strong>大小对齐</strong>：缓冲区的大小也必须是硬件块大小的倍数。</li><li><strong>偏移量对齐</strong>：文件读写的偏移量也必须是对齐的。</li></ul><p>如果不满足这些对齐要求，<code>open()</code> 或 <code>read()</code>/<code>write()</code> 调用可能会失败。</p><p><strong>(2) 文件系统支持</strong></p><ul><li>并非所有文件系统都支持 <code>O_DIRECT</code>。例如，某些网络文件系统（如 NFS）可能不支持直接 I/O。</li></ul><p><strong>(3) 性能权衡</strong></p><ul><li>直接 I/O 绕过了页缓存，因此对于小文件或频繁的小 I/O 操作，性能可能不如普通缓存 I/O。</li></ul><p><strong>关键修改点</strong></p><p><strong>(1) 使用 <code>posix_memalign()</code> 分配对齐内存</strong></p><p>posix_memalign()</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">if</span> (posix_memali<span class="meta">gn(</span><span class="variable">&amp;buffer</span>, 4096, BUFFER_SIZE)) &#123;</span><br><span class="line">    perror(<span class="string">&quot;posix_memalign&quot;</span>);</span><br><span class="line">    <span class="meta">return</span> 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二个参数指定对齐边界（这里是 4KB）。</li><li>第三个参数指定分配的大小。</li></ul><blockquote><p><code>posix_memalign</code> 是一个 POSIX 标准的函数，用于分配对齐的内存。它允许用户指定内存块的起始地址对齐边界.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">posix_memalign</span><span class="params">(<span class="keyword">void</span> **memptr, <span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><ul><li><code>memptr</code><ul><li>输出参数，指向一个指针变量。</li><li>如果分配成功，<code>*memptr</code> 将存储分配的内存块的地址。</li></ul></li><li><code>alignment</code><ul><li>内存块的对齐边界，以字节为单位。</li><li>必须是 2 的幂次方，并且至少为 <code>sizeof(void *)</code>（通常是 8 字节或更大）。</li></ul></li><li><code>size</code><ul><li>要分配的内存大小，以字节为单位。</li></ul></li></ul></blockquote><p><strong>(2) 添加 <code>O_DIRECT</code> 标志</strong></p><ul><li><p>在open()中添加<code>O_DIRECT</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC | O_DIRECT, <span class="number">0644</span>);</span><br></pre></td></tr></table></figure></li></ul><p><strong>(3) 确保缓冲区大小和偏移量对齐</strong></p><ul><li>缓冲区大小设置为 4KB（<code>BUFFER_SIZE</code>）。</li><li>文件偏移量设置为 0（默认对齐）</li></ul><p><a href="https://www.quora.com/Why-does-O_DIRECT-require-I-O-to-be-512-byte-aligned">Why does O_DIRECT require I/O to be 512-byte aligned? - Quora</a></p><p>要求缓存大小和对齐都需要512及其倍数字节.</p><p>libaio的缺点是，(1)想要使用该种方式的文件必须支持以O_DIRECT标志打开，然而并不是所有的文件系统都支持。如果你没有使用O_DIRECT打开文件，它可能仍然“工作”，但它可能不是异步完成的，而是变为了阻塞的。</p><p>(2)仍然可能被阻塞。即使应用层主观上，希望系统层采用异步 IO，但是客观上，有时候还是可能会被阻塞。</p><p>(3) 拷贝开销大。每个 IO 提交需要拷贝 64+8 字节，每个 IO 完成需要拷贝 32 字节，总共 104 字节的拷贝。这个拷贝开销是否可以承受，和单次 IO 大小有关：如果需要发送的 IO 本身就很大，相较之下，这点消耗可以忽略，而在大量小 IO 的场景下，这样的拷贝影响比较大。<img data-src="https://pic4.zhimg.com/v2-c886c75a94b559d44aecfc17b97d898d_1440w.jpg" alt="img"></p><h3 id="io-uring"><a href="#io-uring" class="headerlink" title="io_uring"></a>io_uring</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/389978597">存储大师班 | Linux IO 模式之 io_uring - 知乎</a></li><li><a href="https://blog.csdn.net/crazymakercircle/article/details/129190222">（图解+史上最全）_iouring-CSDN博客</a></li><li><a href="https://cuterwrite.top/p/efficient-liburing/">高性能异步 I/O 框架：io_uring</a></li></ul><p><code>io_uring</code> 是 Linux 内核5.1版本引入的一种高性能异步I/O框架。与传统的 POSIX AIO 相比，<code>io_uring</code> 提供了更高效的零拷贝I/O操作，减少了上下文切换和系统调用开销。</p><blockquote><p>io_uring 围绕高效进行设计，其设计了一对共享的 ring buffer 用于应用和内核之间的通信，通过该设计实现了如下的三个好处：</p><p>（1）避免在提交和完成事件中存在内存拷贝；</p><p>（2）避免了 libaio 中在提交和完成任务的时候系统调用过程；</p><p>（3）该队列采用了无锁的访问模式，通过内存屏障减少了竞争；</p><p>在共享的 ring buffer 设计中，针对提交队列（SQ），应用是 IO 提交的生产者（producer），内核是消费者（consumer）；反过来，针对完成队列（CQ），内核是完成事件的生产者，应用是消费者。</p><p>另外，io_uring 还存在如下的优势：</p><p>（1）提交和完成不需要经过系统调用，而且减少了对用户态线程的阻塞；该部分的支持主要通过共享的 ring buffer 和设置 polling 模式来实现。</p><p>（2）支持 Block 层的 polling 模式</p><p>（3）支持 buffered IO，充分利用缓存，减少数据碰盘产生的系统延迟；</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install liburing-dev</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(io_uring</span><br><span class="line">    -luring</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>liburing 是一个基于 io_uring 接口的用户空间库，它是 Linux 内核开发者 Axboe 于 2019 年发布的一个开源项目。io_uring 是一种新的 Linux 异步 I/O 接口，<strong>它通过使用一对环形缓冲区（ring buffer）来实现用户空间和内核空间之间的通信，从而避免了传统异步 I/O 接口（如 AIO）所需的系统调用、信号、回调等机制。</strong>这样，用户空间可以直接向内核提交 I/O 请求，并从内核获取 I/O 结果，而无需等待或切换上下文。这大大提高了异步 I/O 操作的效率和性能。</p></blockquote><p><img data-src="https://cloud.cuterwrite.fun/blog/20230802172119.webp" alt="20230802172119"></p><p>每个 io_uring 实例都有两个环形队列(称为 ring)，在内核和应用程序之间共享：</p><ol><li>提交队列：submission queue( SQ )</li><li>完成队列：completion queue( CQ )</li></ol><p>这两个队列：</p><ol><li>都是单生产者、单消费者的队列，size 为 2 的幂次方。</li><li>提供无锁接口，内部使用内存屏障来进行同步。</li></ol><p>请求时：</p><ol><li>应用创建 SQ Entries (SQE)，更新 SQ tail</li><li>内核消费 SQE，更新 SQ head</li></ol><p>完成后：</p><ol><li>内核为完成的一个或多个请求创建 CQ Entries (CQE)，更新 CQ tail</li><li>应用消费 CQE，更新 CQ head</li><li>完成事件可能以任意顺序到达，到总是与特定的 SQE 相关联的</li><li>消费 CQE 过程无需切换内核态</li></ol><p>这样做的好处在于：</p><ol><li>原本需要多次系统调用，现在变成批处理一次提交</li><li>此外，io_uring 使异步 I/O 的使用场景也不再仅限于数据库应用， 普通的非数据库应用也能用</li></ol><p>io_uring 的三种工作模式：</p><ol><li>中断驱动模式 (interrupt-driven)<ul><li>默认模式, 可通过 io_uring_enter()提交 I/O 请求，然后直接检查 CQ 状态判断是否完成。</li></ul></li><li>轮询模式 (polling)<ul><li>Busy waiting for I/O completion，而不是通过异步 IRQ(Interrupt Request)来接收通知</li><li>这种模式需要文件系统和块设备支持轮询功能。相比中断驱动模式，这种方式延迟更低，但是 CPU 占用率可能会更高。</li><li>目前，只有指定了 O_DIRECT 标志打开的文件描述符才能使用这种模式。当一个读或写请求提交给轮询上下文之后，应用必须调用 io_uring_enter()来轮询 CQ 队列，判断请求是否完成。</li><li>对于一个 io_uring 实例来说，不支持混合使用轮询和非轮询模式。</li></ul></li><li>内核轮询模式 (kernel polling)<ul><li>这种模式会创建一个内核线程来执行 SQ 的轮询工作。</li><li>使用这种模式的 io_uring 实例，应用无需切到内核态就能触发 I/O 操作。通过 SQ 来提交 SQE，以及监控 CQ 的完成状态，应用无需任何系统调用，就能提交和收割 I/O。</li><li>如果内核线程的空闲事件超过了用户的配置值，它会通知应用，然后进入 idle 状态。这种情况下，应用必须调用 io_uring_enter()来唤醒内核线程。如果 I/O 一直很繁忙，内核线程是不会 sleep 的。</li></ul></li></ol><p>（1）io_uring_setup：初始化一个新的 io_uring 上下文，内核通过一块和用户共享的内存区域进行消息的传递。</p><p>（2）io_uring_enter：提交任务以及收割任务。</p><p>（3）io_uring_register：注册用户态和内核态的共享 buffer。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;liburing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;liburing/io_uring.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">4096</span>;</span><br><span class="line">  <span class="comment">// 初始化io_uring实例</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line">  <span class="keyword">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">io_uring_queue_init</span>(<span class="number">8</span>, &amp;ring, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;io_uring_queue_init&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fd = <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="built_in">io_uring_queue_exit</span>(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(buffer, <span class="string">&#x27;A&#x27;</span>, BUFFER_SIZE); <span class="comment">// 填充缓冲区为字符 &#x27;A&#x27;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> <span class="built_in">io_uring_get_sqe</span>(&amp;ring);</span><br><span class="line">  <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;io_uring_get_sqe&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">io_uring_queue_exit</span>(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 准备写入请求</span></span><br><span class="line">  <span class="built_in">io_uring_prep_write</span>(sqe, fd, buffer, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">  sqe-&gt;user_data = <span class="number">1</span>; <span class="comment">// 设置用户数据</span></span><br><span class="line">  <span class="comment">// 提交请求</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">io_uring_submit</span>(&amp;ring) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;io_uring_submit&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">io_uring_queue_exit</span>(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Asynchronous write operation initiated.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">io_uring_wait_cqe</span>(&amp;ring, &amp;cqe) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;io_uring_wait_cqe&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">io_uring_queue_exit</span>(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error: %s\n&quot;</span>, <span class="built_in">strerror</span>(-cqe-&gt;res));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Write completed successfully.\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">io_uring_cqe_seen</span>(&amp;ring, cqe); <span class="comment">// 标记完成事件为已处理</span></span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line">  <span class="built_in">io_uring_queue_exit</span>(&amp;ring); <span class="comment">// 清理io_uring实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 每一个io_uring实例，都会被分配一个fd，该过程是通过io_uring_setup()系统调用实现的。</p><p>io_uring_setup()调用会根据用户提供的参数，分配一块共享内存。</p><p>这块共享内存中，包含了一个SQ（提交队列）、一个CQ（完成队列）和一个SQE（提交实体）数组。</p><p>其中，SQ和CQ是两个环形队列，队列中的元素是SQE在SQE数组中的偏移量，使用这种方式可以使得提交实体能够被随机访问，提高灵活性。</p><p>io_uring_setup()调用返回的fd，该内存可以通过mmap()的方式映射到用户态</p><p>用户从CQ的头部获取SEQ，将想要执行的操作（如文件的读写）初始化到其中，并添加到SQ队列的尾部，然后使用io_uring_enter()系统调用来进行提交队列的处理。</p><p>用户态和内核态共享 提交队列（submission queue）和 完成队列（completion queue），这两条队列通过mmap共享，高效且安全。</p><p>提交队列（SQ）给内核源源不断的布置任务，然后从另外一条队列完成队列（CQ）获取结果；</p><p>内核则按需进行 epoll()，并在一个线程池中执行就绪的任务。</p><p>用户态支持Polling模式，不会发生中断，也就没有系统调用，通过轮询即可消费事件；</p><p>内核态也支持Polling模式，同样不会发生上下文切换。</p><p>可以看出关键的设计在于，内核通过一块和用户共享的内存区域进行消息的传递，可以绕过Linux 的 syscall 机制。</p><p>内核会从SQ中依次取出对应的io request 提交实体，并根据io request 提交实体中定义的动作来执行对应的操作。由于用户只操作SQ尾部，而内核只操作头部，因此两者对于共享队列的访问并不会产生冲突，节省了锁的开销。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sq</span> <span class="title">sq</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cq</span> <span class="title">cq</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> flags;</span><br><span class="line"><span class="keyword">int</span> ring_fd; <span class="comment">// id</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> features;</span><br><span class="line"><span class="keyword">unsigned</span> pad[<span class="number">3</span>];</span><br><span class="line">&#125;; <span class="comment">// io_uring结构</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sq</span> &#123;</span> <span class="comment">// 提交队列</span></span><br><span class="line"><span class="keyword">unsigned</span> *khead;</span><br><span class="line"><span class="keyword">unsigned</span> *ktail;</span><br><span class="line"><span class="keyword">unsigned</span> *kring_mask;</span><br><span class="line"><span class="keyword">unsigned</span> *kring_entries;</span><br><span class="line"><span class="keyword">unsigned</span> *kflags;</span><br><span class="line"><span class="keyword">unsigned</span> *kdropped;</span><br><span class="line"><span class="keyword">unsigned</span> *array;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqes</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> sqe_head;</span><br><span class="line"><span class="keyword">unsigned</span> sqe_tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> ring_sz;</span><br><span class="line"><span class="keyword">void</span> *ring_ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> pad[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> &#123;</span> <span class="comment">// 提交队列entry</span></span><br><span class="line">__u8opcode;<span class="comment">/* type of operation for this sqe */</span></span><br><span class="line">__u8flags;<span class="comment">/* IOSQE_ flags */</span></span><br><span class="line">__u16ioprio;<span class="comment">/* ioprio for the request */</span></span><br><span class="line">__s32fd;<span class="comment">/* file descriptor to do IO on */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">__u64off;<span class="comment">/* offset into file */</span></span><br><span class="line">__u64addr2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">__u64addr;<span class="comment">/* pointer to buffer or iovecs */</span></span><br><span class="line">__u64splice_off_in;</span><br><span class="line">&#125;;</span><br><span class="line">__u32len;<span class="comment">/* buffer size or number of iovecs */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="keyword">__kernel_rwf_t</span>rw_flags;</span><br><span class="line">__u32fsync_flags;</span><br><span class="line">__u16poll_events;<span class="comment">/* compatibility */</span></span><br><span class="line">__u32poll32_events;<span class="comment">/* word-reversed for BE */</span></span><br><span class="line">__u32sync_range_flags;</span><br><span class="line">__u32msg_flags;</span><br><span class="line">__u32timeout_flags;</span><br><span class="line">__u32accept_flags;</span><br><span class="line">__u32cancel_flags;</span><br><span class="line">__u32open_flags;</span><br><span class="line">__u32statx_flags;</span><br><span class="line">__u32fadvise_advice;</span><br><span class="line">__u32splice_flags;</span><br><span class="line">__u32rename_flags;</span><br><span class="line">__u32unlink_flags;</span><br><span class="line">__u32hardlink_flags;</span><br><span class="line">&#125;;</span><br><span class="line">__u64user_data;<span class="comment">/* data to be passed back at completion time */</span></span><br><span class="line"><span class="comment">/* pack this to avoid bogus arm OABI complaints */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="comment">/* index into fixed buffers, if used */</span></span><br><span class="line">__u16buf_index;</span><br><span class="line"><span class="comment">/* for grouped buffer selection */</span></span><br><span class="line">__u16buf_group;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"><span class="comment">/* personality to use, if used */</span></span><br><span class="line">__u16personality;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">__s32splice_fd_in;</span><br><span class="line">__u32file_index;</span><br><span class="line">&#125;;</span><br><span class="line">__u64__pad2[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Epoll事件的Channel类"><a href="#Epoll事件的Channel类" class="headerlink" title="Epoll事件的Channel类"></a>Epoll事件的Channel类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">uint32_t</span> u32;</span><br><span class="line">  <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> events;<span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;<span class="comment">/* User data variable */</span></span><br><span class="line">&#125; __EPOLL_PACKED;</span><br></pre></td></tr></table></figure><p>epoll时间和数据如上,events为要监听的事件,比如EPOLLIN,EPOLLLT等.</p><p>绪状态。<code>enum EPOLL_EVENTS</code> 定义了一系列的标志位，用于指定感兴趣的事件类型或报告发生的事件。下面是一些常用的 <code>EPOLL_EVENTS</code> 常量及其用途：</p><ul><li><strong><code>EPOLLIN (0x001)</code></strong>：表示对应的文件描述符可以读取（即有数据可读）。</li><li><strong><code>EPOLLOUT (0x004)</code></strong>：表示对应的文件描述符可以写入（即准备好接受数据写入）。</li><li><strong><code>EPOLLPRI (0x002)</code></strong>：表示对应文件描述符有紧急数据可读（带外数据）。这在处理 TCP 紧急指针时有用。</li><li><strong><code>EPOLLERR (0x008)</code></strong>：表示对应的文件描述符发生了错误。这个事件总是会被监控，无需显式地将其加入到感兴趣的事件集合中。</li><li><strong><code>EPOLLHUP (0x010)</code></strong>：表示对应的文件描述符被挂起（即连接被关闭）。与 <code>EPOLLERR</code> 类似，此事件也会自动被监控。</li><li><strong><code>EPOLLRDHUP (0x2000)</code></strong>：自 Linux 2.6.17 起可用，表示对端关闭了连接或者关闭了写入一半的连接。这对于检测对等方关闭连接特别有用。</li></ul><p>此外，还有一些不太常用但同样重要的事件：</p><ul><li><strong><code>EPOLLET (1u &lt;&lt; 31)</code></strong>：设置边缘触发模式。默认情况下，<code>epoll</code> 使用水平触发模式；当启用边缘触发模式后，只有在文件描述符的状态发生变化时才会触发事件通知，而不是每次轮询都可能返回就绪状态。</li><li><strong><code>EPOLLONESHOT (1u &lt;&lt; 30)</code></strong>：一旦被指定的文件描述符上的事件发生并被处理后，相应的文件描述符将不再处于监听状态。要再次监听该文件描述符上的事件，需要重新添加到 <code>epoll</code> 实例中。</li><li><strong><code>EPOLLEXCLUSIVE (1u &lt;&lt; 28)</code></strong>：从 Linux 内核 4.5 开始支持，允许多个 <code>epoll</code> 实例独立地监听同一个文件描述符。这样可以避免多个进程同时收到相同的事件通知，从而减少竞争条件。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EPOLL_EVENTS</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    EPOLLIN = <span class="number">0x001</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLIN EPOLLIN</span></span><br><span class="line">    EPOLLPRI = <span class="number">0x002</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLPRI EPOLLPRI</span></span><br><span class="line">    EPOLLOUT = <span class="number">0x004</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLOUT EPOLLOUT</span></span><br><span class="line">    EPOLLRDNORM = <span class="number">0x040</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLRDNORM EPOLLRDNORM</span></span><br><span class="line">    EPOLLRDBAND = <span class="number">0x080</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLRDBAND EPOLLRDBAND</span></span><br><span class="line">    EPOLLWRNORM = <span class="number">0x100</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLWRNORM EPOLLWRNORM</span></span><br><span class="line">    EPOLLWRBAND = <span class="number">0x200</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLWRBAND EPOLLWRBAND</span></span><br><span class="line">    EPOLLMSG = <span class="number">0x400</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLMSG EPOLLMSG</span></span><br><span class="line">    EPOLLERR = <span class="number">0x008</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLERR EPOLLERR</span></span><br><span class="line">    EPOLLHUP = <span class="number">0x010</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLHUP EPOLLHUP</span></span><br><span class="line">    EPOLLRDHUP = <span class="number">0x2000</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLRDHUP EPOLLRDHUP</span></span><br><span class="line">    EPOLLEXCLUSIVE = <span class="number">1u</span> &lt;&lt; <span class="number">28</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLEXCLUSIVE EPOLLEXCLUSIVE</span></span><br><span class="line">    EPOLLWAKEUP = <span class="number">1u</span> &lt;&lt; <span class="number">29</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLWAKEUP EPOLLWAKEUP</span></span><br><span class="line">    EPOLLONESHOT = <span class="number">1u</span> &lt;&lt; <span class="number">30</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLONESHOT EPOLLONESHOT</span></span><br><span class="line">    EPOLLET = <span class="number">1u</span> &lt;&lt; <span class="number">31</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLET EPOLLET</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>既然可以传一个void*指针,那么可以设计一个Channel类,这个类可以包含监听的fd以及对应的事件等信息. 同时可以设计回调方法,对于server_fd,回调方法可以为接收客户端fd,客户端channel回调方法为读取数据.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Channel</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Epoll *ep;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">uint32_t</span> events;</span><br><span class="line">    <span class="keyword">uint32_t</span> revents;</span><br><span class="line">    <span class="keyword">bool</span> inEpoll;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>显然每个文件描述符会被分发到一个<code>Epoll</code>类，用一个<code>ep</code>指针来指向。类中还有这个<code>Channel</code>负责的文件描述符。另外是两个事件变量，<code>events</code>表示希望监听这个文件描述符的哪些事件，因为不同事件的处理方式不一样。<code>revents</code>表示在<code>epoll</code>返回该<code>Channel</code>时文件描述符正在发生的事件。<code>inEpoll</code>表示当前<code>Channel</code>是否已经在<code>epoll</code>红黑树中，为了注册<code>Channel</code>的时候方便区分使用<code>EPOLL_CTL_ADD</code>还是<code>EPOLL_CTL_MOD</code>。</p></blockquote><h2 id="服务器与事件驱动核心类"><a href="#服务器与事件驱动核心类" class="headerlink" title="服务器与事件驱动核心类"></a>服务器与事件驱动核心类</h2><p><a href="https://github.com/yuesong-feng/30dayMakeCppServer/blob/main/day06-服务器与事件驱动核心类登场.md">30dayMakeCppServer/day06-服务器与事件驱动核心类登场.md at main · yuesong-feng/30dayMakeCppServer</a></p><blockquote><p>目前从新建socket、接受客户端连接到处理客户端事件，整个程序结构是顺序化、流程化的，我们甚至可以使用一个单一的流程图来表示整个程序。而流程化程序设计的缺点之一是不够抽象，<strong>当我们的服务器结构越来越庞大、功能越来越复杂、模块越来越多，这种顺序程序设计的思想显然是不能满足需求的。</strong></p><p>对于服务器开发，我们需要用到更抽象的设计模式。从代码中我们可以看到，不管是接受客户端连接还是处理客户端事件，都是围绕epoll来编程，可以说epoll是整个程序的核心，服务器做的事情就是监听epoll上的事件，然后对不同事件类型进行不同的处理。这种以事件为核心的模式又叫事件驱动，事实上几乎所有的现代服务器都是事件驱动的。和传统的请求驱动模型有很大不同，事件的捕获、通信、处理和持久保留是解决方案的核心结构。libevent就是一个著名的C语言事件驱动库。</p></blockquote><p><img data-src="https://s2.loli.net/2025/04/26/Z5JHSabqlVtiUCG.png" alt="image-20250426144343174"></p><h3 id="Acceptor类"><a href="#Acceptor类" class="headerlink" title="Acceptor类"></a>Acceptor类</h3><p>当server socket监听到事件时,需要做的就是通过accept函数创建新连接,这需要server的socket. </p><blockquote><p>对于每一个事件，不管提供什么样的服务，首先需要做的事都是调用<code>accept()</code>函数接受这个TCP连接，然后将socket文件描述符添加到epoll。当这个IO口有事件发生的时候，再对此TCP连接提供相应的服务。</p></blockquote><p>Acceptor可以设置回调函数.在Server中设置Acceptor回调函数为接收客户端连接并将fd加入epoll中,并设置相关回调函数.</p><p>Acceptor设置回调函数就是为channel设置回调</p><p><code>Acceptor</code>类最主要的三个特点：</p><ul><li>类存在于事件驱动<code>EventLoop</code>类中，也就是Reactor模式的main-Reactor</li><li>类中的socket fd就是服务器监听的socket fd，每一个Acceptor对应一个socket fd</li><li>这个类也通过一个独有的<code>Channel</code>负责分发到epoll，该Channel的事件处理函数<code>handleEvent()</code>会调用Acceptor中的接受连接函数来新建一个TCP连接</li></ul><h3 id="Connection连接类"><a href="#Connection连接类" class="headerlink" title="Connection连接类"></a>Connection连接类</h3><p>对于TCP协议，三次握手新建连接后，这个连接将会一直存在，直到我们四次挥手断开连接。因此，我们也可以把TCP连接抽象成一个<code>Connection</code>类，这个类也有以下几个特点：</p><ul><li>类存在于事件驱动<code>EventLoop</code>类中，也就是Reactor模式的main-Reactor</li><li>类中的socket fd就是客户端的socket fd，每一个Connection对应一个socket fd</li><li>每一个类的实例通过一个独有的<code>Channel</code>负责分发到epoll，该Channel的事件处理函数<code>handleEvent()</code>会调用Connection中的事件处理函数来响应客户端请求</li></ul><p>可以看到，<code>Connection</code>类和<code>Acceptor</code>类是平行关系、十分相似，他们都直接由<code>Server</code>管理，由一个<code>Channel</code>分发到epoll，通过回调函数处理相应事件。唯一的不同在于，<code>Acceptor</code>类的处理事件函数（也就是新建连接功能）被放到了<code>Server</code>类中，而<code>Connection</code>类则没有必要这么做，处理事件的逻辑应该由<code>Connection</code>类本身来完成。</p><h3 id="Buffer类"><a href="#Buffer类" class="headerlink" title="Buffer类"></a>Buffer类</h3><p>之前的读数据部分,都是读取之后立即写入.但是在ET模式下,当errno=EAGAIN才表示没有数据可读取,这时将之间读取的数据进行写入.<br>可以封装一个buffer类,每次读取数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string buffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">data</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> buffer.<span class="built_in">c_str</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">size_t</span> size)</span> </span>&#123; buffer.<span class="built_in">append</span>(data, size); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">const</span> std::string &amp;buf, <span class="keyword">size_t</span> size)</span> </span>&#123; buffer.<span class="built_in">append</span>(buf); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; buffer.<span class="built_in">clear</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123; buffer.<span class="built_in">resize</span>(size); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="增加线程池"><a href="#增加线程池" class="headerlink" title="增加线程池"></a>增加线程池</h3><blockquote><p>观察当前的服务器架构，不难发现我们的Reactor模型少了最关键、最重要的一个模块：线程池。当发现socket fd有事件时，我们应该分发给一个工作线程，由这个工作线程处理fd上面的事件。而当前我们的代码是单线程模式，所有fd上的事件都由主线程（也就是EventLoop线程）处理，这是大错特错的，试想如果每一个事件相应需要1秒时间，那么当1000个事件同时到来，EventLoop线程将会至少花费1000秒来传输数据，还有函数调用等其他开销，服务器将直接宕机。</p></blockquote><p>线程池需要一个任务队列,工作线程,以及线程同步机制.</p><p>任务队列是一个生产者-消费者队列,通过mutex,condition_variable进行线程同步与通信. 工作线程不断地从队列中取出任务并执行.</p><p>这个线程池只是为了满足我们的需要构建出的最简单的线程池，存在很多问题。比如，<strong>由于任务队列的添加、取出都存在拷贝操作，线程池不会有太好的性能</strong>，只能用来学习，正确做法是<strong>使用右值移动、完美转发等阻止拷贝</strong>。另外线程池只能接受<code>std::function&lt;void()&gt;</code>类型的参数，所以函数参数需要事先使用<code>std::bind()</code>，并且<strong>无法得到返回值</strong>。</p><p>对于<code>Acceptor</code>，接受连接的处理时间较短、报文数据极小，并且一般不会有特别多的新连接在同一时间到达，所以<code>Acceptor</code>没有必要采用epoll ET模式，也没有必要用线程池。由于不会成为性能瓶颈，为了简单最好使用阻塞式socket，故今天的源代码中做了以下改变：</p><ol><li>Acceptor socket fd（服务器监听socket）使用阻塞式</li><li>Acceptor使用LT模式，建立好连接后处理事件fd读写用ET模式</li><li>Acceptor建立连接不使用线程池，建立好连接后处理事件用线程池</li></ol><h3 id="多线程Reactor模式"><a href="#多线程Reactor模式" class="headerlink" title="多线程Reactor模式"></a>多线程Reactor模式</h3><p><img data-src="https://s2.loli.net/2025/04/27/7iDBW3cvdCEsyao.png" alt="image-20250427174511232"></p><h3 id="主从Reactor多线程模式"><a href="#主从Reactor多线程模式" class="headerlink" title="主从Reactor多线程模式"></a>主从Reactor多线程模式</h3><p><img data-src="https://s2.loli.net/2025/04/27/IcbnHVp9faBzWmP.png" alt="image-20250427225106232"></p><h3 id="增加多平台支持"><a href="#增加多平台支持" class="headerlink" title="增加多平台支持"></a>增加多平台支持</h3><p>BSD系列操作系统提供了<code>kqueue</code>. <code>kqueue</code> 是一种高性能的事件通知接口，主要用于 BSD 系列操作系统（如 FreeBSD、macOS 和 OpenBSD）中。它提供了一种机制来高效地监视多个文件描述符上的 I/O 事件（例如可读、可写等），以及异步 I/O 操作的状态变化。</p><ul><li><strong>kqueue</strong>：核心对象，用于注册感兴趣的事件，并从内核获取事件通知。</li><li><p><strong>kevent</strong>：表示一个事件或事件类型。可以用来指定你感兴趣的事件（如文件描述符变为可读），也可以用来报告已发生的事件。</p><p>主要用途</p></li></ul><p><strong>(1) 监视文件描述符</strong></p><ul><li>可以监视文件描述符上的各种事件，比如：<ul><li>文件描述符是否可读 (<code>EVFILT_READ</code>)</li><li>文件描述符是否可写 (<code>EVFILT_WRITE</code>)</li><li>文件元数据改变 (<code>EVFILT_VNODE</code>)</li><li>进程信号 (<code>EVFILT_PROC</code>)</li></ul></li></ul><p><strong>(2) 异步 I/O 通知</strong></p><ul><li>支持异步 I/O 操作的通知机制，允许应用程序在非阻塞模式下更高效地管理大量并发连接。</li></ul><p><strong>(3) 高效的事件分发</strong></p><ul><li>对比传统的轮询方式（如 <code>select()</code> 和 <code>poll()</code>），<code>kqueue</code> 提供了更高的性能和更好的扩展性，特别是在处理大量的文件描述符时。</li></ul><p><strong>(1) 创建 kqueue</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> kq = kqueue();</span><br><span class="line"><span class="keyword">if</span> (kq == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;kqueue&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) 设置 kevent</strong></p><p>定义感兴趣的事件，并将其添加到 <code>kqueue</code> 中。例如，监视一个套接字是否可读：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kevent</span> <span class="title">change</span>;</span></span><br><span class="line">EV_SET(&amp;change, sockfd, EVFILT_READ, EV_ADD, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kevent(kq, &amp;change, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;kevent register&quot;</span>);</span><br><span class="line">    close(kq);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 等待事件发生</strong></p><p>调用 <code>kevent()</code> 来等待事件的发生并处理它们：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kevent</span> <span class="title">event</span>;</span></span><br><span class="line"><span class="keyword">int</span> nev = kevent(kq, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;event, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (nev == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;kevent wait&quot;</span>);</span><br><span class="line">    close(kq);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nev &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.filter == EVFILT_READ) &#123;</span><br><span class="line">        <span class="comment">// 处理可读事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决Connection生命周期问题"><a href="#解决Connection生命周期问题" class="headerlink" title="解决Connection生命周期问题"></a>解决Connection生命周期问题</h3><p>当在处理connection连接关闭时,会在回调中移除connnection,这样会调用对应析构函数,但此时仍然在connection的channel的<code>handleEvent</code>方法中.</p><blockquote><p>在当前状态下，在创建<code>TcpConnection</code>会将其加入到<code>connectionsMap_</code>使其引用计数变成了<code>1</code>，之后当<code>TcpConnection</code>处理<code>HandleEvent</code>受到关闭信号时，会直接调用<code>HandleClose</code>，这时会将<code>TcpConnection</code>从<code>connectionsMaps_</code>释放，引用计数变成<code>0</code>，直接销毁，但是<code>HandleEvent</code>并没有处理结束，从而导致了内存泄漏。</p></blockquote><p>增加的两点处理: 在处理事件之前,增加connection的引用计数,这样即使在connectionMap中移除连接,也不会直接释放内存. 此外在每次轮询epoll并处理完事件之后,统一执行一系列回调方法,这样就保证在channel的方法之外进行处理. 在handclose时向eventloop的toDoList中添加一个后处理方法,方法中可以将fd从epoll中移除</p><p>除了解决上面析构的生命周期、内存问题,此外如果mainReactor正要加入connection,而此时相同的eventloop中另一个连接要断开. 由于此时线程不同,存在不同线程读写问题,std::map不安全. 可以考虑在增删时加锁,或者将移除操作放在mainReactor的eventloop的toDoList中,相当于将移除connectionMap操作放在了最后.  如果处理的线程与mainReactor相同(主线程),就可以直接移除.</p><p>另外存在一个问题,由于移除连接交给了mainReacotr(避免connectionMap线程冲突操作),当有多个连接关闭任务放在mainReacotor的toDoList时,如果其阻塞在epoll_wait就会对性能造成影响,因此可以使用<code>eventfd</code>进行事件通知,类似一个文件描述符,可以加入epoll中并进行读写操作,这可以实现异步唤醒. 每当有Connection进行关闭时,由mainReactor执行,将回调加入toDoList后同时向mainReactor的对应eventfd写入,此时主线程(监听serverfd的EventLoop)就会执行eventfd的channel设置的都操作进行唤醒,然后执行toDoList.</p><h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><p><a href="https://zhuanlan.zhihu.com/p/611847234">网络I/O库总结（libevent,libuv,libev,libeio） - 知乎</a></p><ul><li><a href="https://github.com/libuv/libuv">libuv/libuv: Cross-platform asynchronous I/O</a><a href="https://github.com/enki/libev">enki/libev: Full-featured high-performance event loop loosely modelled after libevent</a></li><li><a href="https://github.com/libevent/libevent">libevent/libevent: Event notification library</a></li><li><a href="https://think-async.com/Asio/">Asio C++ Library</a></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="在windows上的异步I-O机制"><a href="#在windows上的异步I-O机制" class="headerlink" title="在windows上的异步I/O机制"></a>在windows上的异步I/O机制</h3><p>异步 I/O（Asynchronous I/O）是一种高效的机制，用于处理文件、网络套接字等设备的输入输出操作.Windows 提供了多种实现异步 I/O 的方式，包括 <strong>Overlapped I/O</strong> 和 <strong>I/O Completion Ports (IOCP)</strong>。</p><h4 id="Overlapped-I-O"><a href="#Overlapped-I-O" class="headerlink" title="Overlapped I/O"></a><strong>Overlapped I/O</strong></h4><p><strong>概述</strong></p><p>Overlapped I/O 是 Windows 提供的一种异步 I/O 机制，它通过使用 <code>OVERLAPPED</code> 结构体来标记一个 I/O 操作是否为异步。这种机制适用于文件操作和套接字通信。</p><ul><li>如果一个文件句柄或套接字是以重叠（Overlapped）模式打开的，则可以对其进行异步操作。</li><li>异步操作完成后，可以通过以下方式通知应用程序：<ul><li>使用事件对象（Event Object）。</li><li>调用回调函数（Completion Routine）。</li><li>使用 I/O 完成端口（IOCP）。</li></ul></li></ul><p><strong>关键函数</strong></p><ul><li><strong><code>ReadFile</code> / <code>WriteFile</code></strong>：用于读写文件或套接字。</li><li><strong><code>GetOverlappedResult</code></strong>：检查异步操作的状态。</li><li><strong><code>CancelIoEx</code></strong>：取消挂起的异步 I/O 操作。</li></ul><p><strong>示例代码</strong></p><p>以下是一个使用 Overlapped I/O 进行异步文件读取的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AsyncFileRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hFile = CreateFile(</span><br><span class="line">        <span class="string">&quot;example.txt&quot;</span>,                  <span class="comment">// 文件名</span></span><br><span class="line">        GENERIC_READ,                   <span class="comment">// 打开文件用于读取</span></span><br><span class="line">        <span class="number">0</span>,                              <span class="comment">// 不共享</span></span><br><span class="line">        <span class="literal">NULL</span>,                           <span class="comment">// 默认安全属性</span></span><br><span class="line">        OPEN_EXISTING,                  <span class="comment">// 打开已存在的文件</span></span><br><span class="line">        FILE_FLAG_OVERLAPPED,           <span class="comment">// 启用 Overlapped I/O</span></span><br><span class="line">        <span class="literal">NULL</span>                            <span class="comment">// 无模板文件</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to open file. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    OVERLAPPED overlapped = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    overlapped.hEvent = CreateEvent(<span class="literal">NULL</span>, TRUE, FALSE, <span class="literal">NULL</span>); <span class="comment">// 创建事件对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ReadFile(hFile, buffer, <span class="keyword">sizeof</span>(buffer), <span class="literal">NULL</span>, &amp;overlapped)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (GetLastError() != ERROR_IO_PENDING) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ReadFile failed. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">            CloseHandle(hFile);</span><br><span class="line">            CloseHandle(overlapped.hEvent);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待异步操作完成</span></span><br><span class="line">    WaitForSingleObject(overlapped.hEvent, INFINITE);</span><br><span class="line"></span><br><span class="line">    DWORD bytesRead;</span><br><span class="line">    <span class="keyword">if</span> (GetOverlappedResult(hFile, &amp;overlapped, &amp;bytesRead, FALSE)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read %d bytes: %.*s\n&quot;</span>, bytesRead, bytesRead, buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;GetOverlappedResult failed. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CloseHandle(hFile);</span><br><span class="line">    CloseHandle(overlapped.hEvent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AsyncFileRead();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Overlapped I/O 是 Windows 中最基础的异步 I/O 实现方式之一。它通过 <code>OVERLAPPED</code> 结构体来标记一个 I/O 操作是否为异步。</li><li>当使用重叠模式打开文件或套接字时，可以发起异步操作，并且在操作完成前继续执行其他代码。</li></ul><p><strong>关键函数</strong></p><ul><li><strong><code>CreateFile</code></strong>：创建或打开文件时指定 <code>FILE_FLAG_OVERLAPPED</code> 标志以启用重叠模式。</li><li><strong><code>ReadFile</code> / <code>WriteFile</code></strong>：用于读取或写入数据。对于异步操作，最后一个参数应指向一个有效的 <code>OVERLAPPED</code> 结构体。</li><li><strong><code>GetOverlappedResult</code></strong>：获取异步操作的结果。</li><li><strong><code>WaitForSingleObject</code> 或 <code>WaitForMultipleObjects</code></strong>：等待异步操作完成。</li></ul><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>在 Windows 中，回调函数通常通过 <code>ReadFileEx</code> 或 <code>WriteFileEx</code> 函数注册，而不是直接使用 <code>ReadFile</code> 或 <code>WriteFile</code>。</p><p>回调函数的原型必须符合以下格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID CALLBACK <span class="title">CompletionRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwErrorCode,       <span class="comment">// 错误码</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwNumberOfBytesTransfered, <span class="comment">// 转移的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPOVERLAPPED lpOverlapped        <span class="comment">// OVERLAPPED 结构体指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>ReadFileEx</code> 和 <code>WriteFileEx</code> 注册回调函数</strong></p><ul><li><code>ReadFileEx</code> 和 <code>WriteFileEx</code> 是专门用于异步 I/O 并支持回调函数的 API。</li><li>它们需要一个有效的 <code>OVERLAPPED</code> 结构体，并且文件句柄必须以重叠模式打开（即带有 <code>FILE_FLAG_OVERLAPPED</code> 标志）。</li><li><p>异步操作完成后，操作系统会调用指定的回调函数。</p></li><li><p>回调函数是一种轻量级的异步 I/O 处理方式，通过 <code>ReadFileEx</code> 和 <code>WriteFileEx</code> 函数注册回调函数，在操作完成后自动调用。</p></li><li>这种方式要求线程进入可提醒等待状态（Alertable Wait State），例如使用 <code>SleepEx</code> 函数。</li></ul><p><strong>关键函数</strong></p><ul><li><strong><code>ReadFileEx</code> / <code>WriteFileEx</code></strong>：用于启动异步 I/O 操作并注册回调函数。</li><li><strong><code>SleepEx</code></strong>：使当前线程进入可提醒等待状态，以便能够接收异步通知。</li></ul><p><strong>3. 示例代码</strong></p><p>以下是一个使用回调函数处理异步文件读取的完整示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数定义</span></span><br><span class="line"><span class="function">VOID CALLBACK <span class="title">FileIOCompletionRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwErrorCode,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwNumberOfBytesTransfered,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPOVERLAPPED lpOverlapped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dwErrorCode == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Asynchronous read completed successfully.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Number of bytes read: %d\n&quot;</span>, dwNumberOfBytesTransfered);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Asynchronous read failed with error code: %d\n&quot;</span>, dwErrorCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AsyncFileReadWithCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hFile = CreateFile(</span><br><span class="line">        <span class="string">&quot;example.txt&quot;</span>,                  <span class="comment">// 文件名</span></span><br><span class="line">        GENERIC_READ,                   <span class="comment">// 打开文件用于读取</span></span><br><span class="line">        <span class="number">0</span>,                              <span class="comment">// 不共享</span></span><br><span class="line">        <span class="literal">NULL</span>,                           <span class="comment">// 默认安全属性</span></span><br><span class="line">        OPEN_EXISTING,                  <span class="comment">// 打开已存在的文件</span></span><br><span class="line">        FILE_FLAG_OVERLAPPED,           <span class="comment">// 启用 Overlapped I/O</span></span><br><span class="line">        <span class="literal">NULL</span>                            <span class="comment">// 无模板文件</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to open file. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    OVERLAPPED overlapped = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动异步读取操作</span></span><br><span class="line">    BOOL result = ReadFileEx(</span><br><span class="line">        hFile,                          <span class="comment">// 文件句柄</span></span><br><span class="line">        buffer,                         <span class="comment">// 缓冲区</span></span><br><span class="line">        <span class="keyword">sizeof</span>(buffer),                 <span class="comment">// 要读取的字节数</span></span><br><span class="line">        &amp;overlapped,                    <span class="comment">// OVERLAPPED 结构体</span></span><br><span class="line">        FileIOCompletionRoutine         <span class="comment">// 回调函数</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ReadFileEx failed. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        CloseHandle(hFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待异步操作完成</span></span><br><span class="line">    SleepEx(INFINITE, TRUE); <span class="comment">// 进入可提醒等待状态，使回调函数得以执行</span></span><br><span class="line"></span><br><span class="line">    CloseHandle(hFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AsyncFileReadWithCallback();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="I-O-Completion-Ports-IOCP"><a href="#I-O-Completion-Ports-IOCP" class="headerlink" title="I/O Completion Ports (IOCP)"></a>I/O Completion Ports (IOCP)</h4><p><strong>概述</strong></p><p>I/O Completion Ports（简称 IOCP）是 Windows 提供的一种高性能的异步 I/O 机制，特别适合于需要处理大量并发连接的服务器程序。IOCP 的核心思想是<strong>将多个 I/O 操作绑定到一个完成端口,并由一个线程池来处理完成的通知</strong>。</p><ul><li>IOCP 的优点：<ul><li>高效地管理多个并发 I/O 操作。</li><li>自动负载均衡，多个工作线程可以高效协作。</li><li>支持大规模并发连接。</li></ul></li></ul><p><strong>关键函数</strong></p><ul><li><strong><code>CreateIoCompletionPort</code></strong>：创建或关联一个完成端口。</li><li><strong><code>PostQueuedCompletionStatus</code></strong>：向完成端口队列提交自定义的完成包。</li><li><strong><code>GetQueuedCompletionStatus</code></strong>：从完成端口队列中获取完成通知。</li></ul><p><strong>示例代码</strong></p><p>以下是一个简单的 IOCP 示例，展示如何使用 IOCP 处理异步文件读取：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    OVERLAPPED overlapped;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">&#125; IO_CONTEXT;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThread</span><span class="params">(LPVOID lpParam)</span> </span>&#123;</span><br><span class="line">    HANDLE hCompletionPort = (HANDLE)lpParam;</span><br><span class="line">    DWORD bytesTransferred;</span><br><span class="line">    ULONG_PTR completionKey;</span><br><span class="line">    LPOVERLAPPED pOverlapped;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        BOOL result = GetQueuedCompletionStatus(</span><br><span class="line">            hCompletionPort, &amp;bytesTransferred, &amp;completionKey, &amp;pOverlapped, INFINITE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!result || bytesTransferred == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Operation failed or completed.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IO_CONTEXT *context = (IO_CONTEXT *)pOverlapped;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read %d bytes: %.*s\n&quot;</span>, bytesTransferred, bytesTransferred, context-&gt;buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AsyncFileReadWithIOCP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hFile = CreateFile(</span><br><span class="line">        <span class="string">&quot;example.txt&quot;</span>,</span><br><span class="line">        GENERIC_READ,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        OPEN_EXISTING,</span><br><span class="line">        FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to open file. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HANDLE hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hCompletionPort) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to create completion port. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        CloseHandle(hFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CreateIoCompletionPort(hFile, hCompletionPort, (ULONG_PTR)hFile, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    HANDLE hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, WorkerThread, hCompletionPort, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hThread) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to create worker thread. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        CloseHandle(hFile);</span><br><span class="line">        CloseHandle(hCompletionPort);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IO_CONTEXT context = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    context.overlapped.Offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ReadFile(hFile, context.buffer, <span class="keyword">sizeof</span>(context.buffer), <span class="literal">NULL</span>, &amp;context.overlapped)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (GetLastError() != ERROR_IO_PENDING) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ReadFile failed. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">            CloseHandle(hFile);</span><br><span class="line">            CloseHandle(hCompletionPort);</span><br><span class="line">            CloseHandle(hThread);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hFile);</span><br><span class="line">    CloseHandle(hCompletionPort);</span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AsyncFileReadWithIOCP();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键函数</strong></p><ul><li><strong><code>CreateIoCompletionPort</code></strong>：创建一个新的完成端口或将其与现有句柄关联。</li><li><strong><code>PostQueuedCompletionStatus</code></strong>：手动向完成端口队列中添加状态信息。</li><li><strong><code>GetQueuedCompletionStatus</code></strong>：从完成端口队列中检索下一个已完成的操作的状态。</li></ul><p><strong>3. 对比 Overlapped I/O 和 IOCP</strong></p><div class="table-container"><table><thead><tr><th>特性</th><th>Overlapped I/O</th><th>IOCP</th></tr></thead><tbody><tr><td><strong>适用场景</strong></td><td>小规模异步操作</td><td>大规模并发 I/O 操作</td></tr><tr><td><strong>性能</strong></td><td>较低</td><td>更高</td></tr><tr><td><strong>复杂度</strong></td><td>较低</td><td>较高</td></tr><tr><td><strong>线程管理</strong></td><td>需要手动管理线程</td><td>自动管理线程池</td></tr><tr><td><strong>扩展性</strong></td><td>有限</td><td>非常强</td></tr></tbody></table></div><p><strong>4. 总结</strong></p><ul><li><strong>Overlapped I/O</strong>：适合小型应用或需要简单异步 I/O 的场景，易于实现但扩展性较差。</li><li><p><strong>IOCP</strong>：适合高性能服务器程序，支持大规模并发连接，具有更高的效率和扩展性，但实现起来更复杂。</p></li><li><p><strong>简单场景</strong>：如果您的应用只需要简单的异步 I/O 操作，Overlapped I/O 可能是最容易实现的选择。</p></li><li><strong>高并发场景</strong>：如果您正在开发一个需要处理大量并发连接的应用程序（如 Web 服务器），那么 IOCP 是最佳选择，因为它提供了更好的性能和扩展性。</li><li><strong>轻量级需求</strong>：如果希望避免复杂的线程管理并且对性能的要求不是极高，可以考虑使用回调函数的方式。</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;c++在网络编程中特别普及,特别是Linux服务器编程. 相关书籍也有很多,这里简单介绍一下(结合AI总结).&lt;br&gt;</summary>
    
    
    
    
    <category term="c++" scheme="https://www.sekyoro.top/tags/c/"/>
    
    <category term="Linux网络编程" scheme="https://www.sekyoro.top/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>learn opengl(3)</title>
    <link href="https://www.sekyoro.top/2025/01/26/learn-opengl-3/"/>
    <id>https://www.sekyoro.top/2025/01/26/learn-opengl-3/</id>
    <published>2025-01-26T13:44:23.000Z</published>
    <updated>2025-02-07T14:05:44.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>高级光照<br><span id="more"></span></p><h2 id="Blinn-Phong光照模型"><a href="#Blinn-Phong光照模型" class="headerlink" title="Blinn-Phong光照模型"></a>Blinn-Phong光照模型</h2><p>之前使用的光照模型是普通Phong模型,在计算镜面光时通过反射光向量和观察向量的夹角确定镜面光强度. 当角度大于90°时取0. 但这样可能会噪声在90°边缘出现明显断层.</p><p><img data-src="https://learnopengl-cn.github.io/img/05/01/advanced_lighting_phong_limit.png" alt="img"></p><p>当物体的反光度非常小时，它产生的镜面高光半径足以让这些相反方向的光线对亮度产生足够大的影响。在这种情况下就不能忽略它们对镜面光分量的贡献了. 也就是说,当pow()中的幂律比较小的时候,当反射光与观察向量夹角比较小的时候镜面光就非常强,在夹角接近90°时就接近0了,会出现这种尖锐的断层.</p><p>James F. Blinn在风氏着色模型上加以拓展，引入了Blinn-Phong着色模型。Blinn-Phong模型与风氏模型非常相似，但是它对镜面光模型的处理上有一些不同，让我们能够解决之前提到的问题。Blinn-Phong模型不再依赖于反射向量，而是采用了所谓的半程向量(Halfway Vector)，即光线与视线夹角一半方向上的一个单位向量。当半程向量与法线向量越接近时，镜面光分量就越大。</p><p>当视线正好与（现在不需要的）反射向量对齐时，半程向量就会与法线完美契合。所以当观察者视线越接近于原本反射光线的方向时，镜面高光就会越强。</p><p>现在，不论观察者向哪个方向看，半程向量与表面法线之间的夹角都不会超过90度（除非光源在表面以下）。它产生的效果会与风氏光照有些许不同，但是大部分情况下看起来会更自然一点，特别是低高光的区域。Blinn-Phong着色模型正是早期固定渲染管线时代时OpenGL所采用的光照模型。</p><p>获取半程向量的方法很简单，只需要将光线的方向向量和观察向量加到一起，并将结果正规化(Normalize)就可以了,镜面光分量的实际计算只不过是对表面法线和半程向量进行一次约束点乘(Clamped Dot Product)，让点乘结果不为负，从而获取它们之间夹角的余弦值，之后我们对这个值取反光度次方：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> lightDir   = <span class="built_in">normalize</span>(lightPos - FragPos);</span><br><span class="line"><span class="type">vec3</span> viewDir    = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line"><span class="type">vec3</span> halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);</span><br><span class="line"><span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), shininess);</span><br><span class="line"><span class="type">vec3</span> specular = lightColor * spec;</span><br></pre></td></tr></table></figure><p>Blinn-Phong与风氏模型唯一的区别就是，Blinn-Phong测量的是法线与半程向量之间的夹角，而风氏模型测量的是观察方向与反射向量间的夹角。除此之外，风氏模型与Blinn-Phong模型也有一些细微的差别：半程向量与表面法线的夹角通常会小于观察与反射向量的夹角。所以，如果你想获得和风氏着色类似的效果，就必须在使用Blinn-Phong模型时将镜面反光度设置更高一点。通常我们会选择风氏着色时反光度分量的2到4倍。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(blinn)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">vec3</span> halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">        spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), <span class="number">16.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">        spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">8.0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Gamma矫正"><a href="#Gamma矫正" class="headerlink" title="Gamma矫正"></a>Gamma矫正</h2><p>一旦我们计算出场景的最终像素颜色，我们便需要在显示器上显示它们。在数字成像的早期，大多数显示器都是阴极射线管（CRT）显示器。这些显示器具有一个物理特性，即输入电压加倍并不会导致亮度加倍。输入电压加倍会导致亮度等于大约 2.2 的指数关系，这被称为显示器的gamma。巧合的是，这也与人测量亮度的方法非常接近，因为亮度也是以类似的（倒数）功率关系显示的。</p><p>因为人眼更习惯看暗色的变化,相同的变化在亮色中对于人眼来说不那么明显(非线性的增长)，所以显示器（至今仍）使用功率关系来显示输出颜色，以便将原始的物理亮度颜色映射到顶部刻度中的非线性亮度颜色</p><p>这种显示器非线性映射确实为我们眼睛提供了更令人满意的亮度结果，但在渲染图形时存在一个问题：我们在应用程序中配置的所有颜色和亮度选项都是基于我们从显示器上感知到的，因此所有选项实际上都是非线性亮度/颜色选项</p><p><img data-src="https://learnopengl.com/img/advanced-lighting/gamma_correction_gamma_curves.png" alt="Gamme curves"></p><p>点线表示线性空间中的颜色/光值，实线表示显示器显示的颜色空间。如果我们在线性空间中加倍一个颜色，其结果确实是值的两倍。例如，取一个光的颜色向量（0.5，0.0，0.0），它代表半暗红色光。如果我们在线性空间中加倍这种光，它就会变成（1.0，0.0，0.0），如图所示。然而，原始颜色在显示器上显示为（0.218，0.0，0.0），如图所示。问题从这里开始出现：一旦我们在线性空间中加倍深红色光，它在显示器上的亮度实际上会超过 4.5 倍</p><p>我们一直假设我们在线性空间中工作，<strong>但实际上我们一直在监视器的输出空间中工作，所以我们配置的所有颜色和光照变量都不是物理上正确的，而只是在我们的显示器上看起来（某种程度上）正确</strong>。因此，我们通常将光照值设置得比应有的要亮得多（因为显示器会使其变暗），这导致大多数线性空间计算都是不正确的。请注意，显示器（CRT）和线性图表都是从同一位置开始和结束的；是显示过程中变暗的中间值。因为颜色是根据显示器的输出配置的，所以在线性空间中的所有中间（照明）计算在物理上都是不正确的。随着更先进的照明算法的实施，这一点变得更加明显</p><p>Gamma校正(Gamma Correction)的思路是在最终的颜色输出上应用监视器Gamma的倒数。回头看前面的Gamma曲线图，你会有一个短划线，它是监视器Gamma曲线的翻转曲线。我们在颜色显示到监视器的时候把每个颜色输出都加上这个翻转的Gamma曲线，这样应用了监视器Gamma以后最终的颜色将会变为线性的。我们所得到的中间色调就会更亮，所以虽然监视器使它们变暗，但是我们又将其平衡回来了。</p><p>场景应用伽玛校正有两种方法：</p><ul><li>通过使用 OpenGL 内置的 sRGB 帧缓冲区支持。</li><li>通过在片段着色器中自行进行gamma校正。</li></ul><p>第一个选项可能是最简单的，但也给了你更少的控制。通过启用 GL_FRAMEBUFFER_SRGB，你告诉 OpenGL 每个后续的绘制命令应该在将颜色存储在颜色缓冲区之前，首先对颜色进行伽玛校正（从 sRGB 颜色空间）。sRGB 是一种颜色空间，大致对应于 2.2 的伽玛值，并且是大多数设备的标准。启用 GL_FRAMEBUFFER_SRGB 后，OpenGL 会在每次片段着色器运行后自动对所有后续帧缓冲区执行伽玛校正，包括默认帧缓冲区</p><p>开启GL_FRAMEBUFFER_SRGB简单的调用glEnable就行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_FRAMEBUFFER_SRGB);</span><br></pre></td></tr></table></figure><p>从现在起，您的渲染图像将进行伽玛校正,这是通过硬件完成的。在使用这种方法（以及另一种方法）时，您应该记住的是，伽玛校正（同样）将颜色从线性空间转换为非线性空间，因此您只应在最后和最终步骤进行伽玛校正非常重要。如果您在最终输出之前对颜色进行伽玛校正，所有后续对这些颜色的操作都将基于错误值。例如，如果您使用多个帧缓冲区，您可能希望中间结果在帧缓冲区之间保持在线性空间中，并且只有最后一个帧缓冲区在发送到显示器之前应用伽玛校正。</p><p>第二种方法需要做更多的工作，但同时也让我们完全控制伽玛操作。我们在每个相关片段着色器运行结束时应用伽玛校正，以确保最终颜色在发送到显示器之前得到伽玛校正：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do super fancy lighting in linear space</span></span><br><span class="line">    [...]</span><br><span class="line">    <span class="comment">// apply gamma correction</span></span><br><span class="line">    <span class="type">float</span> gamma = <span class="number">2.2</span>;</span><br><span class="line">    FragColor.rgb = <span class="built_in">pow</span>(fragColor.rgb, <span class="type">vec3</span>(<span class="number">1.0</span>/gamma));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法的问题在于，为了保持一致性，你必须对每个对最终输出有贡献的片段着色器应用伽玛校正。如果你有十几个用于多个对象的片段着色器，你必须将这些伽玛校正代码添加到每个着色器中。一个更简单的解决方案是在你的渲染循环中引入一个后处理阶段，并在后处理的四边形上作为最后一步应用伽玛校正，你只需做一次。</p><h3 id="sRGB纹理"><a href="#sRGB纹理" class="headerlink" title="sRGB纹理"></a>sRGB纹理</h3><p>一些纹理创作者基于屏幕/monitor修改颜色,这种颜色就是在非线性空间sRGB下被gamma2.2修改过的,如果对这些纹理进行gamma矫正就可能会导致过亮. 所以必须确保纹理的颜色空间和最终需要的颜色空间一致.</p><p>个解决方案是重校，或把这些sRGB纹理在进行任何颜色值的计算前变回线性空间。我们可以这样做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> gamma = <span class="number">2.2</span>;</span><br><span class="line">vec3 diffuseColor = <span class="built_in">pow</span>(<span class="built_in">texture</span>(diffuse, texCoords).rgb, <span class="built_in">vec3</span>(gamma));</span><br></pre></td></tr></table></figure><p>为每个sRGB空间的纹理做这件事非常烦人。幸好，OpenGL给我们提供了另一个方案来解决我们的麻烦，这就是GL_SRGB和GL_SRGB_ALPHA内部纹理格式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_SRGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, image);</span><br></pre></td></tr></table></figure><p>如果还打算在你的纹理中引入alpha元素，必究必须将纹理的内部格式指定为GL_SRGB_ALPHA。</p><p><strong>因为不是所有纹理都是在sRGB空间中的所以当你把纹理指定为sRGB纹理时要格外小心。</strong>比如diffuse纹理，这种为物体上色的纹理几乎都是在sRGB空间中的。<strong>而为了获取光照参数的纹理，像specular贴图和法线贴图几乎都在线性空间中，所以如果你把它们也配置为sRGB纹理的话，光照就坏掉了</strong>。指定sRGB纹理时要当心。</p><p>将diffuse纹理定义为sRGB纹理之后，你将获得你所期望的视觉输出，但这次每个物体都会只进行一次gamma校正</p><h3 id="衰减"><a href="#衰减" class="headerlink" title="衰减"></a>衰减</h3><p>在使用了gamma校正之后，另一个不同之处是光照衰减(Attenuation)。真实的物理世界中，光照的衰减和光源的距离的平方成反比。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> attenuation = <span class="number">1.0</span> / (distance * distance);</span><br></pre></td></tr></table></figure><p>然而，当我们使用这个衰减公式的时候，衰减效果总是过于强烈，光只能照亮一小圈，看起来并不真实。出于这个原因，我们使用在基本光照教程中所讨论的那种衰减方程，它给了我们更大的控制权，此外我们还可以使用双曲线函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> attenuation = <span class="number">1.0</span> / distance;</span><br></pre></td></tr></table></figure><p>双曲线比使用二次函数变体在不用gamma校正的时候看起来更真实，不过但我们开启gamma校正以后线性衰减看起来太弱了，符合物理的二次函数突然出现了更好的效果</p><p>这种差异产生的原因是，光的衰减方程改变了亮度值，而且屏幕上显示出来的也不是线性空间，在监视器上效果最好的衰减方程，并不是符合物理的。想想平方衰减方程，如果我们使用这个方程，而且不进行gamma校正，显示在监视器上的衰减方程实际上将变成(1.0/distance2)2.2(1.0/distance2)2.2。若不进行gamma校正，将产生更强烈的衰减。这也解释了为什么双曲线不用gamma校正时看起来更真实，因为它实际变成了(1.0/distance)2.2=1.0/distance2.2(1.0/distance)2.2=1.0/distance2.2。这和物理公式是很相似的。双曲线比使用二次函数变体在不用gamma校正的时候看起来更真实，不过但我们开启gamma校正以后线性衰减看起来太弱了，符合物理的二次函数突然出现了更好的效果。</p><blockquote><p>在基础光照教程中讨论的更高级的那个衰减方程在有gamma校正的场景中也仍然有用，因为它可以让我们对衰减拥有更多准确的控制权（不过，在进行gamma校正的场景中当然需要不同的参数）。</p></blockquote><p>总而言之<strong>，gamma校正使你可以在线性空间中进行操作。因为线性空间更符合物理世界，大多数物理公式现在都可以获得较好效果，比如真实的光的衰减。你的光照越真实，使用gamma校正获得漂亮的效果就越容易。这也正是为什么当引进gamma校正时，建议只去调整光照参数(使用线性)的原因</strong></p><h2 id="阴影映射"><a href="#阴影映射" class="headerlink" title="阴影映射"></a>阴影映射</h2><p>阴影是由于遮挡导致的光的缺失。当光源的光线因为被其他物体遮挡而没有照射到物体上时，该物体处于阴影中。<strong>阴影为有光照的场景增添了极大的真实感，并使观众更容易观察物体之间的空间关系</strong>。它们为我们场景和物体提供了更深的立体感。</p><p>大多数视频游戏使用的一种既有效又易于实现的技术是阴影映射。阴影映射不难理解，对性能的影响不大，并且很容易扩展到更高级的算法(如全向阴影映射和级联阴影映射)</p><p>阴影映射背后的思想非常简单：我们从光源的角度渲染场景，从光源的角度看到的一切都是被照亮的，而我们看不到的一切都必须处于阴影中。想象一个地板部分和光源之间有一个大箱子的情况。由于光源在朝这个方向看时会看到这个箱子而不是地板部分，所以那个特定的地板部分应该处于阴影中</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;高级光照&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>入门vscode插件开发</title>
    <link href="https://www.sekyoro.top/2025/01/20/%E5%85%A5%E9%97%A8vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>https://www.sekyoro.top/2025/01/20/%E5%85%A5%E9%97%A8vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</id>
    <published>2025-01-19T16:16:29.000Z</published>
    <updated>2025-02-07T14:05:39.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在插件开发上,有Chorme浏览器插件,有开发工具插件. 在开发工具插件中,有visual studio,jetbrains以及vscode,其中vscode插件开发也是非常流行.这里简单入门介绍一下.<br><span id="more"></span></p><h2 id="安装脚手架"><a href="#安装脚手架" class="headerlink" title="安装脚手架"></a>安装脚手架</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx --package yo --package generator-code -- yo code</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>yeoman是创建应用的脚手架,generator-code是vscode项目生成器. 有了这两者开发vscode插件就非常方便了.</p><h2 id="重要文件"><a href="#重要文件" class="headerlink" title="重要文件"></a>重要文件</h2><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p><a href="https://code.visualstudio.com/api/references/extension-manifest">Extension Manifest | Visual Studio Code Extension API</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;mini-news&quot;</span>,</span><br><span class="line">  <span class="string">&quot;displayName&quot;</span>: <span class="string">&quot;mini-news&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.0.1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;engines&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;vscode&quot;</span>: <span class="string">&quot;^1.96.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;categories&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;Other&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;activationEvents&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./extension.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;contributes&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;commands&quot;</span>: [&#123;</span><br><span class="line">      <span class="string">&quot;command&quot;</span>: <span class="string">&quot;mini-news.hihi&quot;</span>,</span><br><span class="line">      <span class="string">&quot;title&quot;</span>: <span class="string">&quot;mini-news:info&quot;</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;lint&quot;</span>: <span class="string">&quot;eslint .&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pretest&quot;</span>: <span class="string">&quot;npm run lint&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;vscode-test&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;@types/vscode&quot;</span>: <span class="string">&quot;^1.96.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@types/mocha&quot;</span>: <span class="string">&quot;^10.0.10&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@types/node&quot;</span>: <span class="string">&quot;20.x&quot;</span>,</span><br><span class="line">    <span class="string">&quot;eslint&quot;</span>: <span class="string">&quot;^9.16.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@vscode/test-cli&quot;</span>: <span class="string">&quot;^0.0.10&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@vscode/test-electron&quot;</span>: <span class="string">&quot;^2.4.1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于插件的配置,重要的属性比如<code>name</code>,<code>displayname</code>,<code>publisher</code>等,目前版本(&gt;1.74.0)<code>activationEvents</code>不需要额外配置,此外还有<code>contributions</code>用于配置扩展功能<a href="https://code.visualstudio.com/api/references/contribution-points">Contribution Points | Visual Studio Code Extension API</a></p><p>contribution包括commands,menus,configuration,keybinds等等</p><h3 id="extension-js"><a href="#extension-js" class="headerlink" title="extension.js"></a>extension.js</h3><p>扩展入口文件,暴露<code>activate</code>和<code>deactivate</code>.<code>activate</code> 在您注册的激活事件发生时执行。 <code>deactivate</code> 在您的扩展被停用之前给您一个清理的机会。对于许多扩展，可能不需要显式清理，并且可以删除 <code>deactivate</code> 方法。然而，如果扩展需要在 VS Code 关闭或扩展被禁用或卸载时执行操作使用<code>deactivate</code>.</p><p>通过<code>context.subscriptions.push</code>添加功能,通过vscode.xx.registerxx注册功能并在contribution中指定.</p><h2 id="小案例"><a href="#小案例" class="headerlink" title="小案例"></a>小案例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> vscode <span class="keyword">from</span> <span class="string">&#x27;vscode&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义注释内容</span></span><br><span class="line"><span class="keyword">const</span> COMMENT = <span class="string">&#x27;// This is a comment added by the extension\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">activate</span>(<span class="params">context: vscode.ExtensionContext</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注册命令</span></span><br><span class="line">    <span class="keyword">const</span> disposable = vscode.commands.registerCommand(<span class="string">&#x27;extension.toggleComment&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> editor = vscode.window.activeTextEditor;</span><br><span class="line">        <span class="keyword">if</span> (!editor) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 没有活动的编辑器</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">document</span> = editor.document;</span><br><span class="line">        <span class="keyword">const</span> firstLine = <span class="built_in">document</span>.lineAt(<span class="number">0</span>); <span class="comment">// 获取第一行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查第一行是否已经是注释</span></span><br><span class="line">        <span class="keyword">if</span> (firstLine.text === COMMENT.trim()) &#123;</span><br><span class="line">            <span class="comment">// 如果是注释，则删除</span></span><br><span class="line">            editor.edit(<span class="function"><span class="params">editBuilder</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> range = <span class="keyword">new</span> vscode.Range(firstLine.range.start, firstLine.range.end);</span><br><span class="line">                editBuilder.delete(range);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是注释，则添加</span></span><br><span class="line">            editor.edit(<span class="function"><span class="params">editBuilder</span> =&gt;</span> &#123;</span><br><span class="line">                editBuilder.insert(firstLine.range.start, COMMENT);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    context.subscriptions.push(disposable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deactivate</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;contributes&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;commands&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;extension.toggleComment&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Toggle Comment&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;keybindings&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;extension.toggleComment&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;ctrl+alt+c&quot;</span>, <span class="comment">// 自定义快捷键</span></span><br><span class="line">                <span class="attr">&quot;mac&quot;</span>: <span class="string">&quot;cmd+alt+c&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;when&quot;</span>: <span class="string">&quot;editorTextFocus&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ol><li><a href="https://www.cnblogs.com/liuxianan/p/vscode-plugin-hello-world.html">VSCode插件开发全攻略（二）HelloWord - 我是小茗同学 - 博客园</a></li><li><a href="https://code.visualstudio.com/api/get-started/your-first-extension">Your First Extension | Visual Studio Code Extension API</a></li><li><a href="https://github.com/microsoft/vscode-extension-samples/tree/main">microsoft/vscode-extension-samples: Sample code illustrating the VS Code extension API.</a></li><li><a href="https://www.cnblogs.com/liuxianan/p/vscode-plugin-common-api.html">VSCode插件开发全攻略（九）常用API总结 - 我是小茗同学 - 博客园</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在插件开发上,有Chorme浏览器插件,有开发工具插件. 在开发工具插件中,有visual studio,jetbrains以及vscode,其中vscode插件开发也是非常流行.这里简单入门介绍一下.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>使用Lua给neovim写插件</title>
    <link href="https://www.sekyoro.top/2025/01/18/%E7%BB%99neovim%E5%86%99%E6%8F%92%E4%BB%B6/"/>
    <id>https://www.sekyoro.top/2025/01/18/%E7%BB%99neovim%E5%86%99%E6%8F%92%E4%BB%B6/</id>
    <published>2025-01-18T09:32:40.000Z</published>
    <updated>2025-02-07T14:05:47.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近在使用neovim和LazyVim配置写代码,感觉很不错. 得益于neovim简单的功能和强大的第三方生态,可以很简单的写出一个插件. 这里根据官方文档搭配lazyvim等资料写一个简单插件.<br><span id="more"></span></p><h2 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h2><p>lua语法本身并不复杂,参考教程</p><ul><li><a href="https://learnxinyminutes.com/lua/">Learn Lua in Y Minutes</a></li><li><a href="http://lua-users.org/">lua-users.org</a></li><li><a href="https://www.runoob.com/lua/lua-tutorial.html">Lua 教程 | 菜鸟教程</a></li><li><a href="https://w3schools.tech/tutorial/lua/index">Welcome to Lua: Your First Step into Programming - Lua Tutorial - W3schools</a></li><li><a href="https://www.lua.org/pil/contents.html#contents">Programming in Lua (first edition)</a></li></ul><p>相关项目</p><ul><li><a href="https://github.com/uhub/awesome-lua">uhub/awesome-lua: A curated list of awesome Lua frameworks, libraries and software.</a></li><li><a href="https://amd-nick.github.io/awesome-lua/">All In One Simple List | awesome lua</a></li><li><a href="https://love2d.org/">LÖVE - Free 2D Game Engine</a> 2D游戏引擎</li></ul><h4 id="表与模块"><a href="#表与模块" class="headerlink" title="表与模块"></a>表与模块</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">l1 = &#123;a=<span class="number">2</span>,b=<span class="number">4</span>&#125;</span><br><span class="line">l2 = &#123;a=<span class="number">2</span>,b=<span class="number">4</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(l1,&#123;<span class="built_in">__add</span>=<span class="function"><span class="keyword">function</span><span class="params">(f1,f2)</span></span> </span><br><span class="line">        sum = &#123;&#125;</span><br><span class="line">        sum.a = f1.a + f2.a</span><br><span class="line">        sum.b = f1.b + f2.b</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">        &#125;)</span><br><span class="line"><span class="comment">-- Values of __index,add, .. are called metamethods.</span></span><br><span class="line"><span class="comment">-- Full list. Here a is a table with the metamethod.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- __add(a, b)                     for a + b</span></span><br><span class="line"><span class="comment">-- __sub(a, b)                     for a - b</span></span><br><span class="line"><span class="comment">-- __mul(a, b)                     for a * b</span></span><br><span class="line"><span class="comment">-- __div(a, b)                     for a / b</span></span><br><span class="line"><span class="comment">-- __mod(a, b)                     for a % b</span></span><br><span class="line"><span class="comment">-- __pow(a, b)                     for a ^ b</span></span><br><span class="line"><span class="comment">-- __unm(a)                        for -a</span></span><br><span class="line"><span class="comment">-- __concat(a, b)                  for a .. b</span></span><br><span class="line"><span class="comment">-- __len(a)                        for #a</span></span><br><span class="line"><span class="comment">-- __eq(a, b)                      for a == b</span></span><br><span class="line"><span class="comment">-- __lt(a, b)                      for a &lt; b</span></span><br><span class="line"><span class="comment">-- __le(a, b)                      for a &lt;= b</span></span><br><span class="line"><span class="comment">-- __index(a, b)  &lt;fn or a table&gt;  for a.b</span></span><br><span class="line"><span class="comment">-- __newindex(a, b, c)             for a.b = c</span></span><br><span class="line"><span class="comment">-- __call(a, ...)                  for a(...)</span></span><br><span class="line"><span class="keyword">local</span> Dog = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog:new</span><span class="params">()</span></span></span><br><span class="line">    newObj = &#123;name=<span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setmetatable</span>(newObj,<span class="built_in">self</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog:makeSound</span><span class="params">()</span></span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;I say &#x27;</span> .. <span class="built_in">self</span>.sound)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">LoudDog = Dog:new()                          </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoudDog:makeSound</span><span class="params">()</span></span></span><br><span class="line">  s = <span class="built_in">self</span>.sound .. <span class="string">&#x27; &#x27;</span>                      </span><br><span class="line">  <span class="built_in">print</span>(s .. s .. s)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Suppose the file mod.lua looks like this:</span></span><br><span class="line"><span class="keyword">local</span> M = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">sayMyName</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Hrunkner&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.sayHello</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Why hello there&#x27;</span>)</span><br><span class="line">  sayMyName()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> M</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Another file can use mod.lua&#x27;s functionality:</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">mod</span> = <span class="built_in">require</span>(<span class="string">&#x27;mod&#x27;</span>)</span><br><span class="line"><span class="comment">-- require&#x27;s return values are cached so a file is</span></span><br><span class="line"><span class="comment">-- run at most once, even when require&#x27;d many times.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Suppose mod2.lua contains &quot;print(&#x27;Hi!&#x27;)&quot;.</span></span><br><span class="line"><span class="keyword">local</span> a = <span class="built_in">require</span>(<span class="string">&#x27;mod2&#x27;</span>)  <span class="comment">-- Prints Hi!</span></span><br><span class="line"><span class="keyword">local</span> b = <span class="built_in">require</span>(<span class="string">&#x27;mod2&#x27;</span>)  <span class="comment">-- Doesn&#x27;t print; a=b.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- dofile is like require without caching:</span></span><br><span class="line"><span class="built_in">dofile</span>(<span class="string">&#x27;mod2.lua&#x27;</span>)  <span class="comment">--&gt; Hi!</span></span><br><span class="line"><span class="built_in">dofile</span>(<span class="string">&#x27;mod2.lua&#x27;</span>)  <span class="comment">--&gt; Hi! (runs it again)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- loadfile loads a lua file but doesn&#x27;t run it yet.</span></span><br><span class="line">f = <span class="built_in">loadfile</span>(<span class="string">&#x27;mod2.lua&#x27;</span>)  <span class="comment">-- Call f() to run it.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- load is loadfile for strings.</span></span><br><span class="line"><span class="comment">-- (loadstring is deprecated, use load instead)</span></span><br><span class="line">g = <span class="built_in">loadstring</span>(<span class="string">&#x27;print(343)&#x27;</span>)  <span class="comment">-- Returns a function.</span></span><br><span class="line">g()  <span class="comment">-- Prints out 343; nothing printed before now.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h4><p>重要的库: io,string.os,table,math</p><div class="table-container"><table><thead><tr><th>库</th><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>string</td><td>string.upper(s)</td><td>Converts s to uppercase</td></tr><tr><td></td><td>string.lower(s)</td><td>Converts s to lowercase</td></tr><tr><td></td><td>string.len(s)</td><td>Returns the length of s</td></tr><tr><td>math</td><td>math.max(x, …)</td><td>Returns the maximum value among its arguments</td></tr><tr><td></td><td>math.min(x, …)</td><td>Returns the minimum value among its arguments</td></tr><tr><td></td><td>math.random([m [, n]])</td><td>Generates a random number</td></tr><tr><td>table</td><td>table.insert(t, [pos,] value)</td><td>Inserts value into t at position pos</td></tr><tr><td></td><td>table.remove(t [, pos])</td><td>Removes from t the element at position pos</td></tr><tr><td></td><td>table.sort(t [, comp])</td><td>Sorts table elements in a given order</td></tr></tbody></table></div><h4 id="require"><a href="#require" class="headerlink" title="require"></a>require</h4><p>在 Lua 中，<code>require</code> 函数用于加载和初始化模块。它会按照一定的顺序搜索指定的模块，并根据配置从不同的目录中加载模块文件。具体来说，<code>require</code> 的查找路径由 <code>package.path</code> 和 <code>package.cpath</code> 两个变量定义。</p><p> <code>package.path</code></p><ul><li><p><strong>用途</strong>：用于指定 Lua 模块（<code>.lua</code> 文件）的搜索路径。</p></li><li><p><strong>默认值</strong>：在不同平台和 Lua 版本上，默认值可能有所不同，但通常类似于以下格式：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package.path = &#x27;<span class="string">./</span>?<span class="string">.lua</span>;&#x27; <span class="string">..</span> -- 当前目录下的 <span class="string">.lua</span> 文件</span><br><span class="line">               &#x27;<span class="string">./</span>?<span class="string">/init.lua</span>;&#x27; <span class="string">..</span> -- 当前目录下的子目录中的 init.lua 文件</span><br><span class="line">               &#x27;<span class="string">/usr/local/share/lua/5.4/</span>?<span class="string">.lua</span>;&#x27; <span class="string">..</span></span><br><span class="line">               &#x27;<span class="string">/usr/local/share/lua/5.4/</span>?<span class="string">/init.lua</span>;&#x27; <span class="string">..</span></span><br><span class="line">               &#x27;<span class="string">/usr/local/lib/lua/5.4/</span>?<span class="string">.lua</span>;&#x27; <span class="string">..</span></span><br><span class="line">               &#x27;<span class="string">/usr/local/lib/lua/5.4/</span>?<span class="string">/init.lua</span>;&#x27; <span class="string">..</span></span><br><span class="line">               &#x27;<span class="string">./lua/</span>?<span class="string">.lua</span>;&#x27; <span class="string">..</span></span><br><span class="line">               &#x27;<span class="string">./lua/</span>?<span class="string">/init.lua</span>&#x27;</span><br></pre></td></tr></table></figure></li><li><p><strong>模式说明</strong>：</p><ul><li><code>?</code> 是一个占位符，代表模块名。</li><li><code>?/init.lua</code> 表示如果模块名是目录，则尝试加载该目录下的 <code>init.lua</code> 文件。</li></ul></li></ul><ol><li><code>package.cpath</code></li></ol><ul><li><p><strong>用途</strong>：用于指定 C 模块（即使用 C 或 C++ 编写的模块，通常是 <code>.so</code> 或 <code>.dll</code> 文件）的搜索路径。</p></li><li><p><strong>默认值</strong>：同样地，这取决于平台和 Lua 版本，但一般包括如下路径：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package.cpath = &#x27;<span class="string">./</span>?<span class="string">.so</span>;&#x27; <span class="string">..</span> -- 当前目录下的共享库文件</span><br><span class="line">              &#x27;<span class="string">./</span>?<span class="string">.dll</span>;&#x27; <span class="string">..</span> -- Windows 上的动态链接库文件</span><br><span class="line">              &#x27;<span class="string">./loadall.so</span>;&#x27; <span class="string">..</span> -- 加载所有符号的共享库</span><br><span class="line">              &#x27;<span class="string">/usr/local/lib/lua/5.4/</span>?<span class="string">.so</span>;&#x27; <span class="string">..</span></span><br><span class="line">              &#x27;<span class="string">/usr/local/lib/lua/5.4/loadall.so</span>;&#x27;</span><br></pre></td></tr></table></figure></li><li><p><strong>模式说明</strong>：</p><ul><li><code>?</code> 同样作为模块名的占位符。</li><li>其他部分指定了操作系统特定的库文件扩展名。</li></ul></li></ul><ol><li><code>package.preload</code></li></ol><p>除了上述路径外，<code>require</code> 还会在 <code>package.preload</code> 表中查找是否已经预加载了相应的模块。如果找到了匹配项，则直接返回对应的函数而不进行文件系统搜索</p><h2 id="Neovim的基本功能"><a href="#Neovim的基本功能" class="headerlink" title="Neovim的基本功能"></a>Neovim的基本功能</h2><h3 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h3><p><img data-src="https://s2.loli.net/2025/01/18/bfXs3tq7xK8vAWL.png" alt="image-20250118174705262" style="zoom:50%;" /></p><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><p>Nvim 支持使用 init.vim 或 init.lua 作为配置文件，但不能同时使用这两个文件。 该文件应放在config目录中、<br>对于 Linux、BSD 或 macOS，该目录通常为 ~/.config/nvim，而对于<br>/AppData/Local/nvim/（Windows）。 请注意，可以在 init.vim 中使用 Lua<br>中使用 Lua，在 init.lua 中使用 Vimscript。 如果想在启动时自动运行任何其他 Lua 脚本，那么<br>只需将其放入运行时路径中的 plugin/。</p><h3 id="nvim中的lua"><a href="#nvim中的lua" class="headerlink" title="nvim中的lua"></a>nvim中的lua</h3><p><a href="https://neovim.io/doc/user/lua-guide.html">Lua-guide - Neovim docs</a></p><h4 id="vim-g"><a href="#vim-g" class="headerlink" title="vim.g"></a>vim.g</h4><p><code>vim.g</code> 是一个 Lua 表，它提供了对全局变量的访问。通过 <code>vim.g</code>，你可以设置或读取任何定义在全局命名空间中的变量。这对于配置插件或共享状态信息非常有用，因为全局变量可以在整个会话期间保持不变，并且可以在不同的脚本之间传递数据。</p><h4 id="vim-cmd"><a href="#vim-cmd" class="headerlink" title="vim.cmd"></a>vim.cmd</h4><p>执行vimscript</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vim.cmd(<span class="string">&#x27;echo 42&#x27;</span>)</span><br><span class="line">vim.cmd(<span class="string">[[</span></span><br><span class="line"><span class="string">  augroup My_group</span></span><br><span class="line"><span class="string">    autocmd!</span></span><br><span class="line"><span class="string">    autocmd FileType c setlocal cindent</span></span><br><span class="line"><span class="string">  augroup END</span></span><br><span class="line"><span class="string">]]</span>)</span><br><span class="line"><span class="comment">-- Ex command :echo &quot;foo&quot;</span></span><br><span class="line"><span class="comment">-- Note string literals need to be double quoted.</span></span><br><span class="line">vim.cmd(<span class="string">&#x27;echo &quot;foo&quot;&#x27;</span>)</span><br><span class="line">vim.cmd &#123; cmd = <span class="string">&#x27;echo&#x27;</span>, args = &#123; <span class="string">&#x27;&quot;foo&quot;&#x27;</span> &#125; &#125;</span><br><span class="line">vim.cmd.echo(&#123; args = &#123; <span class="string">&#x27;&quot;foo&quot;&#x27;</span> &#125; &#125;)</span><br><span class="line">vim.cmd.echo(<span class="string">&#x27;&quot;foo&quot;&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="vim-opt"><a href="#vim-opt" class="headerlink" title="vim.opt"></a>vim.opt</h4><p><code>vim.opt</code> 是另一个 Lua 表，但它专注于编辑器的选项配置。它允许用户以一种结构化的方式设置和查询 Vim/Neovim 的各种行为参数。与传统的 <code>:set</code> 命令相比，<code>vim.opt</code> 提供了一个更加直观和易于维护的方式来管理和调整编辑器的行为.可以指定选项的作用范围，比如 <code>vim.o</code> 对于全局选项，<code>vim.bo</code> 对于缓冲区特定选项，<code>vim.wo</code> 对于窗口特定选项</p><blockquote><p>一个特殊的接口 vim.opt，可以方便地与 Lua 中的列表和映射样式选项进行交互：它允许以 Lua 表格的形式访问它们，并提供面向对象的方法来添加和删除条目</p></blockquote><p>In Lua using <code>vim.o</code>:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim.o.wildignore = <span class="string">&#x27;*.o,*.a,__pycache__&#x27;</span></span><br></pre></td></tr></table></figure><p>In Lua using <code>vim.opt</code>:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim.opt.wildignore = &#123; <span class="string">&#x27;*.o&#x27;</span>, <span class="string">&#x27;*.a&#x27;</span>, <span class="string">&#x27;__pycache__&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="vim-api"><a href="#vim-api" class="headerlink" title="vim.api"></a>vim.api</h4><p><a href="https://neovim.io/doc/user/lua.html#vim.api">vim.api</a></p><p>vim.api.{func}(<code>&#123;...&#125;</code>)<br>调用带有参数 {…} 的 Nvim API 函数 {func}。 示例：调用 “nvim_get_current_line()” API 函数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">tostring</span>(vim.api.nvim_get_current_line()))</span><br></pre></td></tr></table></figure><h4 id="vim-fn"><a href="#vim-fn" class="headerlink" title="vim.fn"></a>vim.fn</h4><p><code>vim.fn</code> 是一个特别设计用来桥接 Vimscript 和 Lua 的接口。它使得开发者能够在 Lua 脚本中调用所有可用的 Vim 内置函数。</p><ul><li>执行系统命令并捕获输出：<code>local output = vim.fn.system(&#39;uname -a&#39;)</code></li><li>获取当前文件名：<code>local filename = vim.fn.expand(&#39;%&#39;)</code></li><li>访问环境变量：<code>local path = vim.fn.getenv(&#39;PATH&#39;)</code></li></ul><p>Neovim会默认从某个目录中加载<code>init.lua</code>,路径如下</p><div class="table-container"><table><thead><tr><th>OS</th><th>PATH</th></tr></thead><tbody><tr><td>Linux, MacOS</td><td><code>$XDG_CONFIG_HOME/nvim</code>, <code>~/.config/nvim</code></td></tr><tr><td>Windows (cmd)</td><td><code>%localappdata%\nvim\</code></td></tr><tr><td>Windows (powershell)</td><td><code>$env:LOCALAPPDATA\nvim\</code></td></tr></tbody></table></div><h4 id="vim-system"><a href="#vim-system" class="headerlink" title="vim.system"></a>vim.system</h4><p>vim.system({cmd}, {opts}, {on_exit})<br> 运行系统命令，如果 {cmd} 无法运行，则抛出错误信息。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> on_exit = <span class="function"><span class="keyword">function</span><span class="params">(obj)</span></span></span><br><span class="line">      <span class="built_in">print</span>(obj.code)</span><br><span class="line">      <span class="built_in">print</span>(obj.signal)</span><br><span class="line">      <span class="built_in">print</span>(obj.<span class="built_in">stdout</span>)</span><br><span class="line">      <span class="built_in">print</span>(obj.<span class="built_in">stderr</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Runs asynchronously:</span></span><br><span class="line">    vim.system(&#123;<span class="string">&#x27;echo&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>&#125;, &#123; text = <span class="literal">true</span> &#125;, on_exit)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Runs synchronously:</span></span><br><span class="line">    <span class="keyword">local</span> obj = vim.system(&#123;<span class="string">&#x27;echo&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>&#125;, &#123; text = <span class="literal">true</span> &#125;):wait()</span><br><span class="line">    <span class="comment">-- &#123; code = 0, signal = 0, stdout = &#x27;hello&#x27;, stderr = &#x27;&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h4 id="vim-uv-vim-loop"><a href="#vim-uv-vim-loop" class="headerlink" title="vim.uv vim.loop"></a>vim.uv vim.loop</h4><p>vim.uv暴露 Nvim 用于网络、文件系统和进程管理的 libUV 库的 “luv” Lua 绑定.</p><p><code>vim.uv</code> 是 Neovim 提供的一个接口，它封装了 libuv 库的功能。libuv 是一个用于异步 I/O 的多平台支持库，最初为 Node.js 开发，但因其高效性和跨平台特性而被广泛采用。通过 <code>vim.uv</code>，Neovim 用户和插件开发者可以直接访问底层的文件系统、网络和其他系统操作功能，从而实现更复杂的应用逻辑或优化性能关键部分</p><h4 id="vim-env"><a href="#vim-env" class="headerlink" title="vim.env"></a>vim.env</h4><p>编辑器会话中定义的环境变量</p><h4 id="vim-schedule"><a href="#vim-schedule" class="headerlink" title="vim.schedule"></a>vim.schedule</h4><p>通过事件循环执行函数,避免阻塞</p><h4 id="vim-lsp"><a href="#vim-lsp" class="headerlink" title="vim.lsp"></a>vim.lsp</h4><p>Nvim 支持语言服务器协议 （LSP），这意味着它充当 LSP 服务器的客户端，并包含一个 Lua 框架 <code>vim.lsp</code> 用于构建增强的 LSP 工具</p><h4 id="vim-tbl-deep-extend"><a href="#vim-tbl-deep-extend" class="headerlink" title="vim.tbl_deep_extend"></a>vim.tbl_deep_extend</h4><p>Neovim 提供的一个用于深度合并 Lua 表的函数。它允许你将一个或多个表的内容递归地合并到目标表中，而不会简单地覆盖原有的键值对。这对于配置管理、插件开发以及其他需要合并多层级数据结构的场景非常有用</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim.tbl<span class="constructor">_deep_extend(<span class="params">strategy</span>, <span class="params">target</span>, <span class="params">source1</span>, <span class="params">source2</span>, <span class="operator">...</span>)</span></span><br></pre></td></tr></table></figure><ul><li><p>strategy</p><p>：指定合并策略，可以是以下之一：</p><ul><li><code>&quot;force&quot;</code>：强制覆盖目标表中的现有键值。</li><li><code>&quot;keep&quot;</code>：保留目标表中的现有键值，不被源表覆盖。</li><li><code>&quot;error&quot;</code>：如果遇到冲突（即同一个键存在于目标和源表中），则抛出错误。</li></ul></li><li><p><strong>target</strong>：目标表，即将要接收合并结果的表。</p></li><li><p><strong>source1, source2, …</strong>：一个或多个源表，它们的内容将被合并到目标表中。</p></li></ul><h2 id="kickstart"><a href="#kickstart" class="headerlink" title="kickstart"></a>kickstart</h2><p>kickstart是配置nvim很好的一个参考.  <strong>要点</strong>:勤用<code>:help</code>,<code>:help lua-guide</code>,可以查阅neovim提供的lua函数</p><h4 id="配置全局变量与选项-vim-g-amp-amp-vim-opt"><a href="#配置全局变量与选项-vim-g-amp-amp-vim-opt" class="headerlink" title="配置全局变量与选项(vim.g&amp;&amp;vim.opt)"></a>配置全局变量与选项(vim.g&amp;&amp;vim.opt)</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Set &lt;space&gt; as the leader key</span></span><br><span class="line"><span class="comment">-- See `:help mapleader`</span></span><br><span class="line"><span class="comment">--  <span class="doctag">NOTE:</span> Must happen before plugins are loaded (otherwise wrong leader will be used)</span></span><br><span class="line">vim.g.mapleader = <span class="string">&#x27; &#x27;</span></span><br><span class="line">vim.g.maplocalleader = <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Set to true if you have a Nerd Font installed and selected in the terminal</span></span><br><span class="line">vim.g.have_nerd_font = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- [[ Setting options ]]</span></span><br><span class="line"><span class="comment">-- See `:help vim.opt`</span></span><br><span class="line"><span class="comment">-- <span class="doctag">NOTE:</span> You can change these options as you wish!</span></span><br><span class="line"><span class="comment">--  For more options, you can see `:help option-list`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Make line numbers default</span></span><br><span class="line">vim.opt.number = <span class="literal">true</span></span><br><span class="line"><span class="comment">-- You can also add relative line numbers, to help with jumping.</span></span><br><span class="line"><span class="comment">--  Experiment for yourself to see if you like it!</span></span><br><span class="line"><span class="comment">-- vim.opt.relativenumber = true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Enable mouse mode, can be useful for resizing splits for example!</span></span><br><span class="line">vim.opt.mouse = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Don&#x27;t show the mode, since it&#x27;s already in the status line</span></span><br><span class="line">vim.opt.showmode = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/01/18/1Awh4k7BIx63Cq2.png" alt="image-20250118233131109" style="zoom:50%;" /></p><h4 id="快捷键-keymap"><a href="#快捷键-keymap" class="headerlink" title="快捷键(keymap)"></a>快捷键(keymap)</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- [[ Basic Keymaps ]]</span></span><br><span class="line"><span class="comment">--  See `:help vim.keymap.set()`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Clear highlights on search when pressing &lt;Esc&gt; in normal mode</span></span><br><span class="line"><span class="comment">--  See `:help hlsearch`</span></span><br><span class="line">vim.keymap.set(<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;&lt;Esc&gt;&#x27;</span>, <span class="string">&#x27;&lt;cmd&gt;nohlsearch&lt;CR&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Diagnostic keymaps</span></span><br><span class="line">vim.keymap.set(<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;&lt;leader&gt;q&#x27;</span>, vim.diagnostic.setloclist, &#123; desc = <span class="string">&#x27;Open diagnostic [Q]uickfix list&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Exit terminal mode in the builtin terminal with a shortcut that is a bit easier</span></span><br><span class="line"><span class="comment">-- for people to discover. Otherwise, you normally need to press &lt;C-\&gt;&lt;C-n&gt;, which</span></span><br><span class="line"><span class="comment">-- is not what someone will guess without a bit more experience.</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- <span class="doctag">NOTE:</span> This won&#x27;t work in all terminal emulators/tmux/etc. Try your own mapping</span></span><br><span class="line"><span class="comment">-- or just use &lt;C-\&gt;&lt;C-n&gt; to exit terminal mode</span></span><br><span class="line">vim.keymap.set(<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;&lt;Esc&gt;&lt;Esc&gt;&#x27;</span>, <span class="string">&#x27;&lt;C-\\&gt;&lt;C-n&gt;&#x27;</span>, &#123; desc = <span class="string">&#x27;Exit terminal mode&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- TIP: Disable arrow keys in normal mode</span></span><br><span class="line"><span class="comment">-- vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;left&gt;&#x27;, &#x27;&lt;cmd&gt;echo &quot;Use h to move!!&quot;&lt;CR&gt;&#x27;)</span></span><br><span class="line"><span class="comment">-- vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;right&gt;&#x27;, &#x27;&lt;cmd&gt;echo &quot;Use l to move!!&quot;&lt;CR&gt;&#x27;)</span></span><br><span class="line"><span class="comment">-- vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;up&gt;&#x27;, &#x27;&lt;cmd&gt;echo &quot;Use k to move!!&quot;&lt;CR&gt;&#x27;)</span></span><br><span class="line"><span class="comment">-- vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;down&gt;&#x27;, &#x27;&lt;cmd&gt;echo &quot;Use j to move!!&quot;&lt;CR&gt;&#x27;)</span></span><br></pre></td></tr></table></figure><h4 id="指令执行-autocmd"><a href="#指令执行-autocmd" class="headerlink" title="指令执行(autocmd)"></a>指令执行(autocmd)</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- [[ Basic Autocommands ]]</span></span><br><span class="line"><span class="comment">--  See `:help lua-guide-autocommands`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Highlight when yanking (copying) text</span></span><br><span class="line"><span class="comment">--  Try it with `yap` in normal mode</span></span><br><span class="line"><span class="comment">--  See `:help vim.highlight.on_yank()`</span></span><br><span class="line">vim.api.nvim_create_autocmd(<span class="string">&#x27;TextYankPost&#x27;</span>, &#123;</span><br><span class="line">  desc = <span class="string">&#x27;Highlight when yanking (copying) text&#x27;</span>,</span><br><span class="line">  group = vim.api.nvim_create_augroup(<span class="string">&#x27;kickstart-highlight-yank&#x27;</span>, &#123; clear = <span class="literal">true</span> &#125;),</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    vim.highlight.on_yank()</span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vim.api.nvim_create_autocmd(&#123;<span class="string">&quot;BufEnter&quot;</span>, <span class="string">&quot;BufWinEnter&quot;</span>&#125;, &#123;</span><br><span class="line">  pattern = &#123;<span class="string">&quot;*.c&quot;</span>, <span class="string">&quot;*.h&quot;</span>&#125;,</span><br><span class="line">  command = <span class="string">&quot;echo &#x27;Entering a C or C++ file&#x27;&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Same autocommand written with a Lua function instead</span></span><br><span class="line">vim.api.nvim_create_autocmd(&#123;<span class="string">&quot;BufEnter&quot;</span>, <span class="string">&quot;BufWinEnter&quot;</span>&#125;, &#123;</span><br><span class="line">  pattern = &#123;<span class="string">&quot;*.c&quot;</span>, <span class="string">&quot;*.h&quot;</span>&#125;,</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">print</span>(<span class="string">&quot;Entering a C or C++ file&quot;</span>) <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- User event triggered by MyPlugin</span></span><br><span class="line">vim.api.nvim_create_autocmd(<span class="string">&quot;User&quot;</span>, &#123;</span><br><span class="line">  pattern = <span class="string">&quot;MyPlugin&quot;</span>,</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">print</span>(<span class="string">&quot;My Plugin Works!&quot;</span>) <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>自动命令是 Vim 命令或 Lua 函数，每当触发一个或多个事件触发时自动执行的 Vim 命令或 Lua 函数。<br>读取或写入文件，或创建窗口时自动执行。 可以通过Lua使用Nvim API 访问。</p><h4 id="安装包管理器"><a href="#安装包管理器" class="headerlink" title="安装包管理器"></a>安装包管理器</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- [[ Install `lazy.nvim` plugin manager ]]</span></span><br><span class="line"><span class="comment">--    See `:help lazy.nvim.txt` or https://github.com/folke/lazy.nvim for more info</span></span><br><span class="line"><span class="keyword">local</span> lazypath = vim.fn.stdpath <span class="string">&#x27;data&#x27;</span> .. <span class="string">&#x27;/lazy/lazy.nvim&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> (vim.uv <span class="keyword">or</span> vim.loop).fs_stat(lazypath) <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">local</span> lazyrepo = <span class="string">&#x27;https://github.com/folke/lazy.nvim.git&#x27;</span></span><br><span class="line">  <span class="keyword">local</span> out = vim.fn.system &#123; <span class="string">&#x27;git&#x27;</span>, <span class="string">&#x27;clone&#x27;</span>, <span class="string">&#x27;--filter=blob:none&#x27;</span>, <span class="string">&#x27;--branch=stable&#x27;</span>, lazyrepo, lazypath &#125;</span><br><span class="line">  <span class="keyword">if</span> vim.v.shell_error ~= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">error</span>(<span class="string">&#x27;Error cloning lazy.nvim:\n&#x27;</span> .. out)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span> <span class="comment">---@diagnostic disable-next-line: undefined-field</span></span><br><span class="line">vim.opt.rtp:prepend(lazypath)</span><br></pre></td></tr></table></figure><p><code>vim.fn.stdpath</code> 用于获取标准路径的绝对路径。它可以帮助你轻松找到配置文件、数据文件或缓存文件所在的目录，这对于编写可移植的脚本和插件非常有用。</p><p><strong>kind</strong>：指定要查询的标准路径类型，可以是以下字符串之一：</p><ul><li><code>&quot;config&quot;</code>：配置文件的位置。通常对应于 <code>$XDG_CONFIG_HOME/nvim</code> 或 <code>$HOME/.config/nvim</code>。</li><li><code>&quot;data&quot;</code>：用户特定的数据文件位置。通常对应于 <code>$XDG_DATA_HOME/nvim</code> 或 <code>$HOME/.local/share/nvim</code>。</li><li><code>&quot;cache&quot;</code>：缓存文件的位置。通常对应于 <code>$XDG_CACHE_HOME/nvim</code> 或 <code>$HOME/.cache/nvim</code>。</li><li><code>&quot;state&quot;</code>：状态文件的位置（如 swap 文件、undo 文件等）。通常与 <code>data</code> 目录相同，但在某些情况下可能会有所不同</li></ul><p>v:shell_error最后一条 shell 命令的结果。  非零时，表示最后一条shell 命令出错。 当为零时，表示没有问题。只有当 shell 向 Vim 返回错误代码时才会起作用。当命令无法执行时，通常使用 -1。 执行。  只读。</p><p>Vim/Neovim 使用 <code>rtp</code> 来定位各种类型的文件，如：</p><ul><li>插件 (<code>plugin/*.vim</code>)</li><li>脚本 (<code>autoload/*.vim</code>, <code>ftplugin/*.vim</code>)</li><li>语法定义 (<code>syntax/*.vim</code>)</li><li>颜色方案 (<code>colors/*.vim</code>)</li><li>文档 (<code>doc/*.txt</code>)</li><li><p>其他配置文件</p></li><li><p><strong>加载顺序</strong>：当有多个相同名称的文件存在于不同的目录中时，会按照 <code>rtp</code> 中列出的顺序依次查找并加载第一个找到的文件。这意味着较早出现在 <code>rtp</code> 中的目录具有更高的优先级。</p></li></ul><p>配置插件管理</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- [[ Configure and install plugins ]]</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">--  To check the current status of your plugins, run</span></span><br><span class="line"><span class="comment">--    :Lazy</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">--  You can press `?` in this menu for help. Use `:q` to close the window</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">--  To update plugins you can run</span></span><br><span class="line"><span class="comment">--    :Lazy update</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- <span class="doctag">NOTE:</span> Here is where you install your plugins.</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;lazy&#x27;</span>).setup(&#123;</span><br><span class="line">  <span class="comment">-- <span class="doctag">NOTE:</span> Plugins can be added with a link (or for a github repo: &#x27;owner/repo&#x27; link).</span></span><br><span class="line">  <span class="string">&#x27;tpope/vim-sleuth&#x27;</span>, <span class="comment">-- Detect tabstop and shiftwidth automatically</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">-- <span class="doctag">NOTE:</span> Plugins can also be added by using a table,</span></span><br><span class="line">  <span class="comment">-- with the first argument being the link and the following</span></span><br><span class="line">  <span class="comment">-- keys can be used to configure plugin behavior/loading/etc.</span></span><br><span class="line">  <span class="comment">--</span></span><br><span class="line">  <span class="comment">-- Use `opts = &#123;&#125;` to force a plugin to be loaded.</span></span><br><span class="line">  <span class="comment">--</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Here is a more advanced example where we pass configuration</span></span><br><span class="line">  <span class="comment">-- options to `gitsigns.nvim`. This is equivalent to the following Lua:</span></span><br><span class="line">  <span class="comment">--    require(&#x27;gitsigns&#x27;).setup(&#123; ... &#125;)</span></span><br><span class="line">  <span class="comment">--</span></span><br><span class="line">  <span class="comment">-- See `:help gitsigns` to understand what the configuration keys do</span></span><br><span class="line">  &#123; <span class="comment">-- Adds git related signs to the gutter, as well as utilities for managing changes</span></span><br><span class="line">    <span class="string">&#x27;lewis6991/gitsigns.nvim&#x27;</span>,</span><br><span class="line">    opts = &#123;</span><br><span class="line">      signs = &#123;</span><br><span class="line">        add = &#123; text = <span class="string">&#x27;+&#x27;</span> &#125;,</span><br><span class="line">        change = &#123; text = <span class="string">&#x27;~&#x27;</span> &#125;,</span><br><span class="line">        delete = &#123; text = <span class="string">&#x27;_&#x27;</span> &#125;,</span><br><span class="line">        topdelete = &#123; text = <span class="string">&#x27;‾&#x27;</span> &#125;,</span><br><span class="line">        changedelete = &#123; text = <span class="string">&#x27;~&#x27;</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- <span class="doctag">NOTE:</span> Plugins can also be configured to run Lua code when they are loaded.</span></span><br><span class="line">  <span class="comment">--</span></span><br><span class="line">  <span class="comment">-- This is often very useful to both group configuration, as well as handle</span></span><br><span class="line">  <span class="comment">-- lazy loading plugins that don&#x27;t need to be loaded immediately at startup.</span></span><br><span class="line">  <span class="comment">--</span></span><br><span class="line">  <span class="comment">-- For example, in the following configuration, we use:</span></span><br><span class="line">  <span class="comment">--  event = &#x27;VimEnter&#x27;</span></span><br><span class="line">  <span class="comment">--</span></span><br><span class="line">  <span class="comment">-- which loads which-key before all the UI elements are loaded. Events can be</span></span><br><span class="line">  <span class="comment">-- normal autocommands events (`:help autocmd-events`).</span></span><br><span class="line">  <span class="comment">--</span></span><br><span class="line">  <span class="comment">-- Then, because we use the `opts` key (recommended), the configuration runs</span></span><br><span class="line">  <span class="comment">-- after the plugin has been loaded as `require(MODULE).setup(opts)`.</span></span><br><span class="line"></span><br><span class="line">  &#123; <span class="comment">-- Useful plugin to show you pending keybinds.</span></span><br><span class="line">    <span class="string">&#x27;folke/which-key.nvim&#x27;</span>,</span><br><span class="line">    event = <span class="string">&#x27;VimEnter&#x27;</span>, <span class="comment">-- Sets the loading event to &#x27;VimEnter&#x27;</span></span><br><span class="line">    opts = &#123;</span><br><span class="line">      <span class="comment">-- delay between pressing a key and opening which-key (milliseconds)</span></span><br><span class="line">      <span class="comment">-- this setting is independent of vim.opt.timeoutlen</span></span><br><span class="line">      delay = <span class="number">0</span>,</span><br><span class="line">      icons = &#123;</span><br><span class="line">        <span class="comment">-- set icon mappings to true if you have a Nerd Font</span></span><br><span class="line">        mappings = vim.g.have_nerd_font,</span><br><span class="line">        <span class="comment">-- If you are using a Nerd Font: set icons.keys to an empty table which will use the</span></span><br><span class="line">        <span class="comment">-- default which-key.nvim defined Nerd Font icons, otherwise define a string table</span></span><br><span class="line">        keys = vim.g.have_nerd_font <span class="keyword">and</span> &#123;&#125; <span class="keyword">or</span> &#123;</span><br><span class="line">          Up = <span class="string">&#x27;&lt;Up&gt; &#x27;</span>,</span><br><span class="line">          Down = <span class="string">&#x27;&lt;Down&gt; &#x27;</span>,</span><br><span class="line">          Left = <span class="string">&#x27;&lt;Left&gt; &#x27;</span>,</span><br><span class="line">          Right = <span class="string">&#x27;&lt;Right&gt; &#x27;</span>,</span><br><span class="line">          C = <span class="string">&#x27;&lt;C-…&gt; &#x27;</span>,</span><br><span class="line">          M = <span class="string">&#x27;&lt;M-…&gt; &#x27;</span>,</span><br><span class="line">          D = <span class="string">&#x27;&lt;D-…&gt; &#x27;</span>,</span><br><span class="line">          S = <span class="string">&#x27;&lt;S-…&gt; &#x27;</span>,</span><br><span class="line">          CR = <span class="string">&#x27;&lt;CR&gt; &#x27;</span>,</span><br><span class="line">          Esc = <span class="string">&#x27;&lt;Esc&gt; &#x27;</span>,</span><br><span class="line">          ScrollWheelDown = <span class="string">&#x27;&lt;ScrollWheelDown&gt; &#x27;</span>,</span><br><span class="line">          ScrollWheelUp = <span class="string">&#x27;&lt;ScrollWheelUp&gt; &#x27;</span>,</span><br><span class="line">          NL = <span class="string">&#x27;&lt;NL&gt; &#x27;</span>,</span><br><span class="line">          BS = <span class="string">&#x27;&lt;BS&gt; &#x27;</span>,</span><br><span class="line">          Space = <span class="string">&#x27;&lt;Space&gt; &#x27;</span>,</span><br><span class="line">          Tab = <span class="string">&#x27;&lt;Tab&gt; &#x27;</span>,</span><br><span class="line">          F1 = <span class="string">&#x27;&lt;F1&gt;&#x27;</span>,</span><br><span class="line">          F2 = <span class="string">&#x27;&lt;F2&gt;&#x27;</span>,</span><br><span class="line">          F3 = <span class="string">&#x27;&lt;F3&gt;&#x27;</span>,</span><br><span class="line">          F4 = <span class="string">&#x27;&lt;F4&gt;&#x27;</span>,</span><br><span class="line">          F5 = <span class="string">&#x27;&lt;F5&gt;&#x27;</span>,</span><br><span class="line">          F6 = <span class="string">&#x27;&lt;F6&gt;&#x27;</span>,</span><br><span class="line">          F7 = <span class="string">&#x27;&lt;F7&gt;&#x27;</span>,</span><br><span class="line">          F8 = <span class="string">&#x27;&lt;F8&gt;&#x27;</span>,</span><br><span class="line">          F9 = <span class="string">&#x27;&lt;F9&gt;&#x27;</span>,</span><br><span class="line">          F10 = <span class="string">&#x27;&lt;F10&gt;&#x27;</span>,</span><br><span class="line">          F11 = <span class="string">&#x27;&lt;F11&gt;&#x27;</span>,</span><br><span class="line">          F12 = <span class="string">&#x27;&lt;F12&gt;&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">-- Document existing key chains</span></span><br><span class="line">      spec = &#123;</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;leader&gt;c&#x27;</span>, group = <span class="string">&#x27;[C]ode&#x27;</span>, mode = &#123; <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;x&#x27;</span> &#125; &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;leader&gt;d&#x27;</span>, group = <span class="string">&#x27;[D]ocument&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;leader&gt;r&#x27;</span>, group = <span class="string">&#x27;[R]ename&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;leader&gt;s&#x27;</span>, group = <span class="string">&#x27;[S]earch&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;leader&gt;w&#x27;</span>, group = <span class="string">&#x27;[W]orkspace&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;leader&gt;t&#x27;</span>, group = <span class="string">&#x27;[T]oggle&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;leader&gt;h&#x27;</span>, group = <span class="string">&#x27;Git [H]unk&#x27;</span>, mode = &#123; <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;v&#x27;</span> &#125; &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">    </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="NvChad"><a href="#NvChad" class="headerlink" title="NvChad"></a>NvChad</h2><p>比kickstart更复杂一点,但也很容易上手. 其配置也是类似,首先包括全局变量、设置选项以及环境变量</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> opt = vim.opt</span><br><span class="line"><span class="keyword">local</span> o = vim.o</span><br><span class="line"><span class="keyword">local</span> g = vim.g</span><br><span class="line"></span><br><span class="line"><span class="comment">-------------------------------------- options ------------------------------------------</span></span><br><span class="line">o.laststatus = <span class="number">3</span></span><br><span class="line">o.showmode = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">o.clipboard = <span class="string">&quot;unnamedplus&quot;</span></span><br><span class="line">o.cursorline = <span class="literal">true</span></span><br><span class="line">o.cursorlineopt = <span class="string">&quot;number&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Indenting</span></span><br><span class="line">o.expandtab = <span class="literal">true</span></span><br><span class="line">o.shiftwidth = <span class="number">2</span></span><br><span class="line">o.smartindent = <span class="literal">true</span></span><br><span class="line">o.tabstop = <span class="number">2</span></span><br><span class="line">o.softtabstop = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">opt.fillchars = &#123; eob = <span class="string">&quot; &quot;</span> &#125;</span><br><span class="line">o.ignorecase = <span class="literal">true</span></span><br><span class="line">o.smartcase = <span class="literal">true</span></span><br><span class="line">o.mouse = <span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Numbers</span></span><br><span class="line">o.number = <span class="literal">true</span></span><br><span class="line">o.numberwidth = <span class="number">2</span></span><br><span class="line">o.ruler = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- disable nvim intro</span></span><br><span class="line">opt.shortmess:append <span class="string">&quot;sI&quot;</span></span><br><span class="line"></span><br><span class="line">o.signcolumn = <span class="string">&quot;yes&quot;</span></span><br><span class="line">o.splitbelow = <span class="literal">true</span></span><br><span class="line">o.splitright = <span class="literal">true</span></span><br><span class="line">o.timeoutlen = <span class="number">400</span></span><br><span class="line">o.undofile = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- interval for writing swap file to disk, also used by gitsigns</span></span><br><span class="line">o.updatetime = <span class="number">250</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- go to previous/next line with h,l,left arrow and right arrow</span></span><br><span class="line"><span class="comment">-- when cursor reaches end/beginning of line</span></span><br><span class="line">opt.whichwrap:append <span class="string">&quot;&lt;&gt;[]hl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- disable some default providers</span></span><br><span class="line">g.loaded_node_provider = <span class="number">0</span></span><br><span class="line">g.loaded_python3_provider = <span class="number">0</span></span><br><span class="line">g.loaded_perl_provider = <span class="number">0</span></span><br><span class="line">g.loaded_ruby_provider = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- add binaries installed by mason.nvim to path</span></span><br><span class="line"><span class="keyword">local</span> is_windows = vim.fn.has <span class="string">&quot;win32&quot;</span> ~= <span class="number">0</span></span><br><span class="line"><span class="keyword">local</span> sep = is_windows <span class="keyword">and</span> <span class="string">&quot;\\&quot;</span> <span class="keyword">or</span> <span class="string">&quot;/&quot;</span></span><br><span class="line"><span class="keyword">local</span> delim = is_windows <span class="keyword">and</span> <span class="string">&quot;;&quot;</span> <span class="keyword">or</span> <span class="string">&quot;:&quot;</span></span><br><span class="line">vim.env.PATH = <span class="built_in">table</span>.<span class="built_in">concat</span>(&#123; vim.fn.stdpath <span class="string">&quot;data&quot;</span>, <span class="string">&quot;mason&quot;</span>, <span class="string">&quot;bin&quot;</span> &#125;, sep) .. delim .. vim.env.PATH</span><br></pre></td></tr></table></figure><p>快捷键</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> map = vim.keymap.set</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;&lt;C-b&gt;&quot;</span>, <span class="string">&quot;&lt;ESC&gt;^i&quot;</span>, &#123; desc = <span class="string">&quot;move beginning of line&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;&lt;C-e&gt;&quot;</span>, <span class="string">&quot;&lt;End&gt;&quot;</span>, &#123; desc = <span class="string">&quot;move end of line&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;&lt;C-h&gt;&quot;</span>, <span class="string">&quot;&lt;Left&gt;&quot;</span>, &#123; desc = <span class="string">&quot;move left&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;&lt;C-l&gt;&quot;</span>, <span class="string">&quot;&lt;Right&gt;&quot;</span>, &#123; desc = <span class="string">&quot;move right&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;&lt;C-j&gt;&quot;</span>, <span class="string">&quot;&lt;Down&gt;&quot;</span>, &#123; desc = <span class="string">&quot;move down&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;&lt;C-k&gt;&quot;</span>, <span class="string">&quot;&lt;Up&gt;&quot;</span>, &#123; desc = <span class="string">&quot;move up&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-h&gt;&quot;</span>, <span class="string">&quot;&lt;C-w&gt;h&quot;</span>, &#123; desc = <span class="string">&quot;switch window left&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-l&gt;&quot;</span>, <span class="string">&quot;&lt;C-w&gt;l&quot;</span>, &#123; desc = <span class="string">&quot;switch window right&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-j&gt;&quot;</span>, <span class="string">&quot;&lt;C-w&gt;j&quot;</span>, &#123; desc = <span class="string">&quot;switch window down&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-k&gt;&quot;</span>, <span class="string">&quot;&lt;C-w&gt;k&quot;</span>, &#123; desc = <span class="string">&quot;switch window up&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;Esc&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;noh&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;general clear highlights&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-s&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;w&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;general save file&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-c&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;%y+&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;general copy whole file&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;n&quot;</span>, <span class="string">&quot;&lt;cmd&gt;set nu!&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;toggle line number&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;rn&quot;</span>, <span class="string">&quot;&lt;cmd&gt;set rnu!&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;toggle relative number&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;ch&quot;</span>, <span class="string">&quot;&lt;cmd&gt;NvCheatsheet&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;toggle nvcheatsheet&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;fm&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&quot;conform&quot;</span>).<span class="built_in">format</span> &#123; lsp_fallback = <span class="literal">true</span> &#125;</span><br><span class="line"><span class="keyword">end</span>, &#123; desc = <span class="string">&quot;general format file&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- global lsp mappings</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;ds&quot;</span>, vim.diagnostic.setloclist, &#123; desc = <span class="string">&quot;LSP diagnostic loclist&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- tabufline</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;b&quot;</span>, <span class="string">&quot;&lt;cmd&gt;enew&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;buffer new&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;tab&gt;&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&quot;nvchad.tabufline&quot;</span>).<span class="built_in">next</span>()</span><br><span class="line"><span class="keyword">end</span>, &#123; desc = <span class="string">&quot;buffer goto next&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;S-tab&gt;&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&quot;nvchad.tabufline&quot;</span>).prev()</span><br><span class="line"><span class="keyword">end</span>, &#123; desc = <span class="string">&quot;buffer goto prev&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;x&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&quot;nvchad.tabufline&quot;</span>).close_buffer()</span><br><span class="line"><span class="keyword">end</span>, &#123; desc = <span class="string">&quot;buffer close&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Comment</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;/&quot;</span>, <span class="string">&quot;gcc&quot;</span>, &#123; desc = <span class="string">&quot;toggle comment&quot;</span>, remap = <span class="literal">true</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;v&quot;</span>, <span class="string">&quot;&lt;leader&gt;/&quot;</span>, <span class="string">&quot;gc&quot;</span>, &#123; desc = <span class="string">&quot;toggle comment&quot;</span>, remap = <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- nvimtree</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-n&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;NvimTreeToggle&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;nvimtree toggle window&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;e&quot;</span>, <span class="string">&quot;&lt;cmd&gt;NvimTreeFocus&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;nvimtree focus window&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- telescope</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;fw&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope live_grep&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope live grep&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;fb&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope buffers&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope find buffers&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;fh&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope help_tags&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope help page&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;ma&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope marks&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope find marks&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;fo&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope oldfiles&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope find oldfiles&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;fz&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope current_buffer_fuzzy_find&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope find in current buffer&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;cm&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope git_commits&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope git commits&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;gt&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope git_status&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope git status&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;pt&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope terms&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope pick hidden term&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;th&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&quot;nvchad.themes&quot;</span>).<span class="built_in">open</span>()</span><br><span class="line"><span class="keyword">end</span>, &#123; desc = <span class="string">&quot;telescope nvchad themes&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;ff&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope find_files&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope find files&quot;</span> &#125;)</span><br><span class="line">map(</span><br><span class="line">  <span class="string">&quot;n&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&lt;leader&gt;fa&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&lt;cmd&gt;Telescope find_files follow=true no_ignore=true hidden=true&lt;CR&gt;&quot;</span>,</span><br><span class="line">  &#123; desc = <span class="string">&quot;telescope find all files&quot;</span> &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- terminal</span></span><br><span class="line">map(<span class="string">&quot;t&quot;</span>, <span class="string">&quot;&lt;C-x&gt;&quot;</span>, <span class="string">&quot;&lt;C-\\&gt;&lt;C-N&gt;&quot;</span>, &#123; desc = <span class="string">&quot;terminal escape terminal mode&quot;</span> &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>autocmd</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> autocmd = vim.api.nvim_create_autocmd</span><br><span class="line"></span><br><span class="line"><span class="comment">-- user event that loads after UIEnter + only if file buf is there</span></span><br><span class="line">autocmd(&#123; <span class="string">&quot;UIEnter&quot;</span>, <span class="string">&quot;BufReadPost&quot;</span>, <span class="string">&quot;BufNewFile&quot;</span> &#125;, &#123;</span><br><span class="line">  group = vim.api.nvim_create_augroup(<span class="string">&quot;NvFilePost&quot;</span>, &#123; clear = <span class="literal">true</span> &#125;),</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">(args)</span></span></span><br><span class="line">    <span class="keyword">local</span> file = vim.api.nvim_buf_get_name(args.buf)</span><br><span class="line">    <span class="keyword">local</span> buftype = vim.api.nvim_get_option_value(<span class="string">&quot;buftype&quot;</span>, &#123; buf = args.buf &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> vim.g.ui_entered <span class="keyword">and</span> args.event == <span class="string">&quot;UIEnter&quot;</span> <span class="keyword">then</span></span><br><span class="line">      vim.g.ui_entered = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> file ~= <span class="string">&quot;&quot;</span> <span class="keyword">and</span> buftype ~= <span class="string">&quot;nofile&quot;</span> <span class="keyword">and</span> vim.g.ui_entered <span class="keyword">then</span></span><br><span class="line">      vim.api.nvim_exec_autocmds(<span class="string">&quot;User&quot;</span>, &#123; pattern = <span class="string">&quot;FilePost&quot;</span>, modeline = <span class="literal">false</span> &#125;)</span><br><span class="line">      vim.api.nvim_del_augroup_by_name <span class="string">&quot;NvFilePost&quot;</span></span><br><span class="line"></span><br><span class="line">      vim.schedule(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        vim.api.nvim_exec_autocmds(<span class="string">&quot;FileType&quot;</span>, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> vim.g.editorconfig <span class="keyword">then</span></span><br><span class="line">          <span class="built_in">require</span>(<span class="string">&quot;editorconfig&quot;</span>).<span class="built_in">config</span>(args.buf)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="LazyVim"><a href="#LazyVim" class="headerlink" title="LazyVim"></a>LazyVim</h2><p>neovim的插件编写<a href="https://miguelcrespo.co/posts/how-to-write-a-neovim-plugin-in-lua">How to write a neovim plugin in lua</a>与使用lazyvim不同但有相似点</p><ul><li><a href="https://dev.to/iamgoncaloalves/how-i-developed-my-first-neovim-plugin-a-step-by-step-guide-1lcb#:~:text=Make changes to your plugin code. Save the,changes by running %3AHelloWorld or using the keymapping.">How I Developed My First Neovim Plugin: A Step-by-Step Guide - DEV Community</a></li><li><a href="https://dev.to/vonheikemen/lazynvim-plugin-configuration-3opi">Lazy.nvim: plugin configuration - DEV Community</a></li><li><a href="https://www.reddit.com/r/neovim/comments/z0ihuf/are_there_any_good_starter_templates_for_writing/"> r/neovim —- Are there any good starter templates for writing Neovim plugins? : r/neovim</a></li><li><a href="https://github.com/LazyVim/LazyVim/discussions/1129">LazyVim local development · LazyVim/LazyVim · Discussion #1129</a></li><li><a href="https://github.com/LazyVim/LazyVim/discussions/2202">Loading local plugins · LazyVim/LazyVim · Discussion #2202</a></li><li><a href="https://miguelcrespo.co/posts/how-to-write-a-neovim-plugin-in-lua">How to write a neovim plugin in lua</a></li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── LICENSE</span><br><span class="line">├── plugin</span><br><span class="line">│  └── plugin-<span class="keyword">file</span>.<span class="keyword">lua</span></span><br><span class="line">├── <span class="keyword">lua</span></span><br><span class="line">│  └── main-<span class="keyword">file</span>.<span class="keyword">lua</span></span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure><p>plugin和 lua 文件夹是特例，其含义如下：</p><ul><li>plugin 文件夹 该文件夹中的所有文件将在 Neovim 启动时立即执行，如果想设置keymap或autocmd而不管用户是否需要该插件</li><li>lua 文件夹 在大多数情况下，lua 文件夹是您的插件代码所在的文件夹，只有在用户明确需要您的插件时才会执行这些代码，例如 require(‘scratch-buffer’)</li></ul><h4 id="插件代码该放哪"><a href="#插件代码该放哪" class="headerlink" title="插件代码该放哪"></a>插件代码该放哪</h4><p>对于普通neovim插件,可以放在lua文件夹下,通过neovim加载配置路径中的<code>init.lua</code>通过<code>require</code>加载</p><p>而在lazyvim中,添加spec.</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;lazy&quot;</span>).setup(&#123;</span><br><span class="line">  spec = &#123;</span><br><span class="line">    <span class="comment">-- add lazyvim and import its plugins</span></span><br><span class="line">    &#123; <span class="string">&quot;lazyvim/lazyvim&quot;</span>, import = <span class="string">&quot;lazyvim.plugins&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;coderunner&quot;</span>, dir = <span class="string">&quot;~/appdata/local/nvim/lua/plugins/coderunner&quot;</span>, dev = <span class="literal">true</span> &#125;,</span><br><span class="line">    <span class="comment">-- import/override with your plugins</span></span><br><span class="line">    &#123; import = <span class="string">&quot;plugins&quot;</span> &#125;,</span><br><span class="line">    &#123; import = <span class="string">&quot;lazyvim.plugins.extras.linting.eslint&quot;</span> &#125;,</span><br><span class="line">    &#123; import = <span class="string">&quot;lazyvim.plugins.extras.formatting.prettier&quot;</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  defaults = &#123;</span><br><span class="line">    <span class="comment">-- by default, only lazyvim plugins will be lazy-loaded. your custom plugins will load during startup.</span></span><br><span class="line">    <span class="comment">-- if you know what you&#x27;re doing, you can set this to `true` to have all your custom plugins lazy-loaded by default.</span></span><br><span class="line">    lazy = <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">-- it&#x27;s recommended to leave version=false for now, since a lot the plugin that support versioning,</span></span><br><span class="line">    <span class="comment">-- have outdated releases, which may break your neovim install.</span></span><br><span class="line">    version = <span class="literal">false</span>, <span class="comment">-- always use the latest git commit</span></span><br><span class="line">    <span class="comment">-- version = &quot;*&quot;, -- try installing the latest stable version for plugins that support semver</span></span><br><span class="line">  &#125;,</span><br><span class="line">  install = &#123; colorscheme = &#123; <span class="string">&quot;tokyonight&quot;</span>, <span class="string">&quot;habamax&quot;</span> &#125; &#125;,</span><br><span class="line">  checker = &#123;</span><br><span class="line">    enabled = <span class="literal">true</span>, <span class="comment">-- check for plugin updates periodically</span></span><br><span class="line">    notify = <span class="literal">false</span>, <span class="comment">-- notify on update</span></span><br><span class="line">  &#125;, <span class="comment">-- automatically check for plugin updates</span></span><br><span class="line">  performance = &#123;</span><br><span class="line">    rtp = &#123;</span><br><span class="line">      <span class="comment">-- disable some rtp plugins</span></span><br><span class="line">      disabled_plugins = &#123;</span><br><span class="line">        <span class="string">&quot;gzip&quot;</span>,</span><br><span class="line">        <span class="comment">-- &quot;matchit&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;matchparen&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;netrwplugin&quot;,</span></span><br><span class="line">        <span class="string">&quot;tarplugin&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tohtml&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tutor&quot;</span>,</span><br><span class="line">        <span class="string">&quot;zipplugin&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>重新启动 Neovim 或运行 :Lazy sync 来加载插件.有了这种设置，您就可以轻松迭代您的插件： 1.  更改插件代码。  2.  保存文件。  3.  在 Neovim 中运行 :Lazy reload plugin-name 重新加载插件。  4.  运行 :HelloWorld 或使用关键映射测试更改。   此工作流程可实现快速开发和测试，而无需不断重启 Neovim 或手动获取文件。</p><p>可以直接使用的nvim配置,lazyvim会自动加载预定义的autocmd,keymaps和options.<a href="https://lazy.folke.io/spec">🔌 Plugin Spec | lazy.nvim</a></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">~/.config/nvim</span><br><span class="line">├── <span class="keyword">lua</span></span><br><span class="line">│   ├── config</span><br><span class="line">│   │   ├── autocmds.<span class="keyword">lua</span></span><br><span class="line">│   │   ├── keymaps.<span class="keyword">lua</span></span><br><span class="line">│   │   ├── lazy.<span class="keyword">lua</span></span><br><span class="line">│   │   └── <span class="keyword">options</span>.<span class="keyword">lua</span></span><br><span class="line">│   └── plugins</span><br><span class="line">│       ├── spec1.<span class="keyword">lua</span></span><br><span class="line">│       ├── **</span><br><span class="line">│       └── spec2.<span class="keyword">lua</span></span><br><span class="line">└── init.<span class="keyword">lua</span></span><br></pre></td></tr></table></figure><p>写本地插件时直接在plugins目录中即可. 添加插件时可用的选项</p><p>Defaults merging rules:</p><ul><li>cmd：命令列表将使用您的自定义命令进行扩展</li><li>event：事件列表将使用您的自定义事件进行扩展</li><li>FT：文件类型列表将扩展为自定义文件类型</li><li>keys：键盘映射列表将使用您的自定义键盘映射进行扩展</li><li>opts：自定义 opts 将与默认 opts 合并</li><li>dependencies：依赖项列表将使用您的自定义依赖项进行扩展</li><li><strong>任何其他属性都将覆盖默认值</strong></li></ul><p>对于 <code>ft</code> ， <code>event</code> ， <code>keys</code> ， <code>cmd</code> 和 <code>opts</code> 您还可以指定一个 <code>values</code> 函数，该函数可以更改默认值，或返回要使用的新值.除此之外,还有init,config函数. Lua 插件遵循一个常见的约定，它们有一个名为 <code>setup</code> 的函数暴露的 Lua 模块。所以当使用 <code>opts</code> 时，是在告诉 lazy.nvim 该插件遵循该约定。因此，lazy.nvim 会将那个 <code>opts</code> 属性传递给插件的 <code>setup</code> 函数。</p><p>使用lazyvim写插件的debug方式<a href="https://lazy.folke.io/usage">🚀 Usage | lazy.nvim</a></p><h3 id="小案例-插件重载器"><a href="#小案例-插件重载器" class="headerlink" title="小案例 插件重载器"></a>小案例 插件重载器</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- init.lua</span></span><br><span class="line"><span class="keyword">local</span> utils = <span class="built_in">require</span>(<span class="string">&quot;utils&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> M = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showPlugins</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">local</span> plugins = <span class="built_in">require</span>(<span class="string">&quot;lazy&quot;</span>).plugins()</span><br><span class="line">utils.createwin(plugins)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.setup</span><span class="params">(opts)</span></span></span><br><span class="line">vim.api.nvim_create_user_command(<span class="string">&quot;Reload&quot;</span>, showPlugins, &#123;</span><br><span class="line">desc = <span class="string">&quot;Reload plugins&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> M</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- utils.lua</span></span><br><span class="line"><span class="keyword">local</span> M = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.createwin</span><span class="params">(items)</span></span></span><br><span class="line"><span class="keyword">local</span> width = <span class="number">40</span></span><br><span class="line"><span class="keyword">local</span> height = #items + <span class="number">2</span></span><br><span class="line"><span class="keyword">local</span> row = <span class="built_in">math</span>.<span class="built_in">floor</span>(vim.o.<span class="built_in">lines</span> / <span class="number">2</span>) - <span class="built_in">math</span>.<span class="built_in">floor</span>(height / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">local</span> col = <span class="built_in">math</span>.<span class="built_in">floor</span>(vim.o.columns / <span class="number">2</span>) - <span class="built_in">math</span>.<span class="built_in">floor</span>(width / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">local</span> bufnr = vim.api.nvim_create_buf(<span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">vim.api.nvim_set_option_value(<span class="string">&quot;bufhidden&quot;</span>, <span class="string">&quot;wipe&quot;</span>, &#123; buf = bufnr &#125;)</span><br><span class="line"><span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="built_in">ipairs</span>(items) <span class="keyword">do</span></span><br><span class="line">vim.api.nvim_buf_set_lines(bufnr, i - <span class="number">1</span>, i, <span class="literal">false</span>, &#123; item.name &#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">vim.api.nvim_set_option_value(<span class="string">&quot;modifiable&quot;</span>, <span class="literal">false</span>, &#123; buf = bufnr &#125;)</span><br><span class="line">vim.api.nvim_set_option_value(<span class="string">&quot;readonly&quot;</span>, <span class="literal">true</span>, &#123; buf = bufnr &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> win_id = vim.api.nvim_open_win(bufnr, <span class="literal">true</span>, &#123;</span><br><span class="line">relative = <span class="string">&quot;editor&quot;</span>,</span><br><span class="line">width = width,</span><br><span class="line">height = height,</span><br><span class="line">row = row,</span><br><span class="line">col = col,</span><br><span class="line">style = <span class="string">&quot;minimal&quot;</span>,</span><br><span class="line">border = <span class="string">&quot;rounded&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">vim.api.nvim_set_option_value(<span class="string">&quot;winhl&quot;</span>, <span class="string">&quot;Normal:Normal,FloatBorder:FloatBorder&quot;</span>, &#123; win = win_id &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> current_line = <span class="number">1</span></span><br><span class="line"><span class="keyword">local</span> ns_id = vim.api.nvim_create_namespace(<span class="string">&quot;highlight_current_line&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">highlight_and_move_cursor</span><span class="params">()</span></span></span><br><span class="line">vim.api.nvim_buf_clear_namespace(bufnr, ns_id, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> current_line &gt;= <span class="number">1</span> <span class="keyword">and</span> current_line &lt;= #items <span class="keyword">then</span></span><br><span class="line">vim.api.nvim_buf_add_highlight(bufnr, ns_id, <span class="string">&quot;Visual&quot;</span>, current_line - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">vim.api.nvim_win_set_cursor(win_id, &#123; current_line, <span class="number">0</span> &#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">highlight_and_move_cursor()</span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">handle_keys</span><span class="params">(key)</span></span></span><br><span class="line"><span class="keyword">if</span> key == <span class="string">&quot;k&quot;</span> <span class="keyword">or</span> key == <span class="string">&quot;&lt;Up&gt;&quot;</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">if</span> current_line &gt; <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">current_line = current_line - <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">elseif</span> key == <span class="string">&quot;j&quot;</span> <span class="keyword">or</span> key == <span class="string">&quot;&lt;Down&gt;&quot;</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">if</span> current_line &lt; #items <span class="keyword">then</span></span><br><span class="line">current_line = current_line + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">elseif</span> key == <span class="string">&quot;CR&quot;</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">local</span> plugin_name = items[current_line].name</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;reload plugin:&quot;</span>, plugin_name)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;lazy.core.loader&quot;</span>).reload(plugin_name)</span><br><span class="line"><span class="comment">-- 关闭窗口</span></span><br><span class="line">vim.api.nvim_win_close(win_id, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">highlight_and_move_cursor()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">vim.api.nvim_create_autocmd(&#123; <span class="string">&quot;CursorMoved&quot;</span> &#125;, &#123;</span><br><span class="line">buffer = bufnr,</span><br><span class="line">desc = <span class="string">&quot;highlight the line which cursor is on&quot;</span>,</span><br><span class="line">callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">local</span> cur_line = vim.api.nvim_win_get_cursor(win_id)[<span class="number">1</span>]</span><br><span class="line">vim.api.nvim_buf_add_highlight(bufnr, ns_id, <span class="string">&quot;Visual&quot;</span>, cur_line - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">current_line = cur_line</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 辅助函数用于设置按键映射</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">set_keymap</span><span class="params">(key, action)</span></span></span><br><span class="line">vim.keymap.set(<span class="string">&quot;n&quot;</span>, key, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">handle_keys(action)</span><br><span class="line"><span class="keyword">end</span>, &#123;</span><br><span class="line">buffer = bufnr,</span><br><span class="line">noremap = <span class="literal">true</span>,</span><br><span class="line">silent = <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 设置按键映射</span></span><br><span class="line">set_keymap(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;k&quot;</span>)</span><br><span class="line">set_keymap(<span class="string">&quot;j&quot;</span>, <span class="string">&quot;j&quot;</span>)</span><br><span class="line">set_keymap(<span class="string">&quot;&lt;Up&gt;&quot;</span>, <span class="string">&quot;Up&quot;</span>)</span><br><span class="line">set_keymap(<span class="string">&quot;&lt;Down&gt;&quot;</span>, <span class="string">&quot;Down&quot;</span>)</span><br><span class="line">set_keymap(<span class="string">&quot;&lt;CR&gt;&quot;</span>, <span class="string">&quot;CR&quot;</span>)</span><br><span class="line"><span class="comment">-- 允许用户通过 q 键关闭窗口，仅限于当前缓冲区</span></span><br><span class="line">vim.keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;&lt;Cmd&gt;close&lt;CR&gt;&quot;</span>, &#123; buffer = bufnr, noremap = <span class="literal">true</span>, silent = <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> M</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在使用neovim和LazyVim配置写代码,感觉很不错. 得益于neovim简单的功能和强大的第三方生态,可以很简单的写出一个插件. 这里根据官方文档搭配lazyvim等资料写一个简单插件.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>协同感知算法(四):大模型、多模态以及新趋势</title>
    <link href="https://www.sekyoro.top/2025/01/10/%E5%8D%8F%E5%90%8C%E6%84%9F%E7%9F%A5%E7%AE%97%E6%B3%95-%E5%9B%9B-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E3%80%81%E5%A4%9A%E6%A8%A1%E6%80%81%E4%BB%A5%E5%8F%8A%E6%96%B0%E8%B6%8B%E5%8A%BF/"/>
    <id>https://www.sekyoro.top/2025/01/10/%E5%8D%8F%E5%90%8C%E6%84%9F%E7%9F%A5%E7%AE%97%E6%B3%95-%E5%9B%9B-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E3%80%81%E5%A4%9A%E6%A8%A1%E6%80%81%E4%BB%A5%E5%8F%8A%E6%96%B0%E8%B6%8B%E5%8A%BF/</id>
    <published>2025-01-10T15:08:12.000Z</published>
    <updated>2025-06-06T07:29:34.474Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这半年要论AI哪些方向最火,那关键词必然包括多模态,AI Agent,RAG等等(事实上已经火了一轮开始冷饭热炒了),一些做之前基础大模型的公司基本开始转向做应用甚至其他方向了. 这里整理一些关于AI Agents的知识和相关基础框架,并结合多智能体协同感知看看有哪些能做的结合.<br><span id="more"></span></p><h2 id="视觉语言模型"><a href="#视觉语言模型" class="headerlink" title="视觉语言模型"></a>视觉语言模型</h2><p>引用lilianweng的博客,视觉语言模型可以粗略分为四类:<br>1.将图像转换为可以与标记嵌入联合训练的嵌入特征(将图像转为可以与语言编码的特征一起训练的特征)<br>2.学习作为冻结、预训练语言模型前缀的良好图像嵌入(训练图像特征作为冻结的预训练语言模型的输入前缀)<br>3.使用专门设计的交叉注意力机制将视觉信息融合到语言模型的层中(使用交叉注意力融合视觉信息到大模型中)<br>4.无需训练即可结合视觉和语言模型</p><h3 id="同时训练图像和文本"><a href="#同时训练图像和文本" class="headerlink" title="同时训练图像和文本"></a>同时训练图像和文本</h3><p>VisualBERT将文本输入和图像区域同时输入 BERT，使其能够<strong>通过自注意力机制发现图像和文本之间的内部对齐</strong>。<br>在训练时同时输入图像和文本,mask相关文本并加上图像的相关信息,任务是预测遮挡的信息同时提供两个标题区分哪个与图像相关.<br><img data-src="https://s2.loli.net/2025/01/11/rF7sJIdcoWnBZhv.png" alt="image-20250111165850291"><br>与 BERT 中的文本嵌入类似，VisualBERT 中的每个视觉嵌入也总结了三种类型的嵌入，即<strong>分词特征</strong>、<strong>分割嵌入</strong>和<strong>位置嵌入</strong>，具体来说：</p><ol><li><p>一种通过卷积神经网络计算出的图像边界区域的视觉特征向量</p></li><li><p>一个表示嵌入是否用于视觉而非文本的段嵌入</p></li><li><p>一种用于对齐边界区域顺序的位置嵌入</p></li></ol><p>SimVLM是一种简单的前缀语言模型，其中前缀序列的处理方式类似于 BERT 的双向注意力，但主要的文本输入序列只有因果注意力类似于 GPT。图像被编码为前缀标记，以便模型可以完全消耗视觉信息，然后以自回归方式生成相关文本。<br>SimVLM 将图像分割成更小的块，形成一个平铺的 1D 块序列。他们使用由 ResNet 的前 3 个块组成的卷积阶段来提取上下文化的块，这种设置被发现比简单的线性投影效果更好。<br>  这种方法的学习目标更像是通过视觉信息前缀,通过transformer结构进行自回归学习,这也是它与前者较大的差距.  因此通过图像编码器编码图像特征然后通过掩码语言建模(Masked Language Modeling)(类似完形填空)或自回归学习训练原本的大语言模型使其拥有视觉能力.</p><h3 id="学习图像嵌入"><a href="#学习图像嵌入" class="headerlink" title="学习图像嵌入"></a>学习图像嵌入</h3><p>如果不想在适应处理视觉信号时更改语言模型参数,那么可以学习一个与语言模型兼容的图像嵌入空间。<br>受前缀或提示调整的启发，Frozen和 ClipCap<strong>仅在训练期间更新视觉模块的参数</strong>，以生成可以与预训练的冻结语言模型一起工作的图像嵌入。两者都使用对齐的图像标题数据集进行训练，以根据图像和先前的文本标记生成下一个文本标记。通过冻结 LM 参数，保留了强大的语言能力。此外，尽管这种设置是在有限的图像标题数据上训练的，但它们在测试时也可以依赖语言模型的知识库。<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/Frozen-arch.png" alt="img"></p><p>从框架图看来就是只是用了一个视觉编码器将得到的embedding与预训练固定参数的text encoder和大模型同时训练更新视觉编码器<br>ClipCap 依靠 CLIP 进行视觉编码，但它需要由光映射网络处理，以便将图像嵌入向量转换为与预训练 LM 相同的语义空间。该网络将 CLIP 嵌入向量映射到一系列嵌入向量中，每个向量与 GPT2 中的单词嵌入具有相同的维度。增加前缀大小有助于提高性能。CLIP 视觉编码器和 LM 在训练期间都会被冻结，并且只学习映射网络。<br>ClipCap学习的是一个映射网络,它同时利用了预训练的CLIP和大模型<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/ClipCap-arch.png" alt="img"></p><h3 id="交叉注意力混合视觉和文本信息"><a href="#交叉注意力混合视觉和文本信息" class="headerlink" title="交叉注意力混合视觉和文本信息"></a>交叉注意力混合视觉和文本信息</h3><p><strong>VisualGPT</strong>采用self-resurrecting的编码器-解码器注意力机制,用少量的域内图像文本数据快速适应预训练的LM<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/VisualGPT.png" alt="img" style="zoom:67%;" /><br>设I为视觉编码器的输入,H为LM解码器的隐藏状态. 引入激活单元通过两个互补门来控制预训练语言信息和视觉组件之间混合.</p><script type="math/tex; mode=display">\begin{array}{c}B^{\text {vs }} \otimes \operatorname{EncDecattn}(H, I)+B^{\text {in }} \otimes H \\\text { where } B^{\text {vs }}[i, j]=\sigma(H[i, j])[\sigma(H[i, j])>\tau] \\B^{\text {ban }}[i, j]=(1-\sigma(H[i, j])] \neq[1-\sigma(H[i, j])>\tau]\end{array}</script><p>每层decoder通过门控制单元混合不同的输入.<br><strong>VC-GPT</strong> 将预训练的视觉转换器(CLIP-ViT)作为视觉编码器和预训练的 LM 作为语言解码器相结合。CLIP-ViT 将一系列图像块作为输入和输出，并输出每个块的表示。为避免灾难性的遗忘，<strong>VC-GPT 不是将视觉信息直接注入 GPT2，而是在视觉编码器和语言解码器的输出之上引入了额外的交叉注意力层</strong>。然后， <em>一个自集成</em> 模块线性组合单模型语言解码器 logits h^G^和跨模型视觉语言融合模块 logitsh^fuse^ 自集成模块对于性能很重要<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/VC-GPT.png" alt="img"><br>MERLOT接受了 600 万个 YouTube 视频的训练，并转录了语音 （YT-Temporal-180M），以学习空间（帧级）和时间（视频级）目标，并在微调时在 VQA 和视觉推理任务上表现出强大的表现。每个视频被拆分为多个片段,每个片段从中间的图像帧和关联的单词。图像由学习的图像编码器编码，单词使用学习的嵌入进行编码。然后，两者在一个联合的vision-language transformer中一起编码。<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/MERLOT.png" alt="img"></p><ol><li>遮罩语言建模(MLM)，因为在视频中有许多重复的关键字或填充词。</li><li>对比帧-标题匹配使用联合视觉-语言转换器中的纯语言部分。每个帧 I~t~和 caption w~t~ 的匹配表示形式被视为正面示例，而负面示例来自小批量中的所有其他帧-标题对。</li><li>时间重新排序学习时间推理:打乱随机i帧,并将段级位置嵌入替换为随机且唯一的位置嵌入。随机位置嵌入被学习,允许模型以正确排序的帧为条件取消这些 “’shuffled’” 帧。</li></ol><p>Flamingo （ Alayrac et al. 2022） 是一种视觉语言模型，它接受与图像/视频交错的文本并输出自由格式的文本。Flamingo 通过基于 transformer 的映射器连接预训练的 LM 和预训练的视觉编码器（即 CLIP 图像编码器）。为了更有效地整合视觉信号，Flamingo 采用基于 Perceiver 的架构，从大量视觉输入特征中生成数百个标记，然后使用与 LM 层交错的交叉注意力层将视觉信息融合到语言解码过程中。训练目标是自回归的 NLL 损失。Perceiver 重采样器从图像/视频输入的视觉编码器接收时空特征，以生成固定大小的视觉标记。冻结的 LM 配备了新初始化的交叉注意力层，这些层在预训练的 LM 层之间交错。因此LM 可以生成以上述视觉标记为条件的文本。</p><p>与 ClipCap 类似，两个预训练模型在训练期间都会被冻结，因此 Flamingo 仅经过训练才能将现有的强大语言和视觉模型和谐地连接在一起。ClipCap 和 Flamingo 的主要区别在于，前者将图像嵌入视为 LM 的简单前缀，而后者使用门控交叉注意力密集层来融合图像信息。此外，Flamingo 包含的训练数据比 ClipCap 多得多。<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/Flamingo.png" alt="img"><br>为了轻松处理带有交错图像的文本，Flamingo 中的遮罩设计为文本标记仅交叉关注与最后一个前图像对应的视觉标记，从而大大减少了某个文本标记可以看到的视觉标记的数量。他们发现这比允许文本标记直接处理所有前面的图像效果更好。文本仍然可以处理所有以前的图像，因为文本编码器中存在因果自我注意依赖关系。此设计可以处理上下文中任意数量的图像。从互联网上抓取了 4300 万个网页，名为 MultiModal MassiveWeb （M3W) 数据集，其中包含带有交错图像的文本。此外，Flamingo 还在配对的图像/文本和视频/文本数据集上进行了训练，包括 ALIGN、LTIP 和 VTP。</p><p>CoCa捕捉到了对比学习和图像到标题生成的优点。它是一个联合训练的模型，在 CLIP 风格的表示上具有对比损失，在图像描述上具有生成损失，在各种多模态评估任务上实现了 SoTA 零样本转移。<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/CoCa-arch.png" alt="img" style="zoom: 67%;" /><br>CoCa 是从头开始预训练的,使用 Web 规模的替代文本数据 ALIGN 和注释图像，将所有标签视为 JTB-3B 中的文本<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/CoCa.png" alt="img"></p><h3 id="无训练方法"><a href="#无训练方法" class="headerlink" title="无训练方法"></a>无训练方法</h3><p>可以通过将预训练的语言和视觉模型拼接在一起来解决视觉语言任务,而无需训练任何其他参数。</p><p>MAGiC 根据名为 magic score 的基于 CLIP 的分数进行引导解码，以对下一个标记进行采样，而无需微调。鼓励生成的文本与给定图像相关，同时仍与先前生成的文本保持一致.与其他无监督方法相比，MAGiC 具有不错的性能，但与有监督方法仍然存在很大差距. MAGiC核心就是更改了采样方式,第t步采样的token会通过基于CLIP的分数计算与图像编码相似的值.</p><p><img data-src="https://s2.loli.net/2025/01/12/Knk9qHblQgwALuv.png" alt="image-20250112122938693"></p><p>​    对于基于知识的 VQA 任务，PICa首先将图像转换为标题或标签，然后使用少数镜头示例提示 GPT3 提供答案。图像标题或标记由某些现有模型（例如 VinVL）或 Azure 标记 API 提取。GPT3 被认为是一个非结构化的隐式知识库. </p><p>​    苏格拉底模型是一个框架,通过语言(提示)将不同模态的多个预训练模型组合成一个模型，而无需进一步训练。在这里，语言被认为是不同模型可以交换信息的中间表示。关键思想是使用多模型多模态提示，其中非语言模型的输出入到语言提示中，然后用于 LM 进行推理. SM 可以生成图像字幕，首先使用 VLM 对不同的地点类别、对象类别、图像类型和人数进行零拍摄预测;然后将 VLM 填充的语言提示输入到因果 LM 中以生成候选字幕。Socratic 方法在图像字幕方面与 ClipCap 的性能仍然存在差距，但考虑到它不涉及任何培训，因此相当不错。 简单来说就是将不同模态模型,比如vision-language model,language model,audio-language model结合在一起,通过一种相对固定的prompt template通信,SM 可以生成图像字幕，首先使用 VLM 对不同的地点类别、对象类别、图像类型和人数进行零拍摄预测;然后将 VLM 填充的语言提示输入到因果 LM 中以生成候选字幕</p><p><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/SM-caption-example.png" alt="img"></p><h2 id="大模型驱动的Agents"><a href="#大模型驱动的Agents" class="headerlink" title="大模型驱动的Agents"></a>大模型驱动的Agents</h2><p>​    多个大模型之间协作增强输出并设计一些类似模仿一个系统中负责不同功能的组件组成Agent. 目前许多大模型公司在做应用时都是往这个方向发展.在 LLM 驱动的自主代理系统中，LLM 充当代理的大脑，并辅以几个关键组件：</p><p>​    <strong>规划</strong>:子目标和分解：智能体将大型任务分解为较小的、可管理的子目标，从而能够高效处理复杂任务。反思和完善：智能体可以对过去的行为进行自我批评和自我反省，从错误中吸取教训并为未来的步骤进行改进，从而提高最终结果的质量。(任务分解和完善行为)</p><p>​     <strong>记忆</strong>: 短期记忆：所有的上下文学习（参见提示工程）都是利用模型的短期记忆来学习的。长期记忆：这为代理提供了在较长时间内保留和调用（无限）信息的能力，通常是通过利用外部向量存储和快速检索。</p><p>   <strong>工具使用</strong>:智能体学习调用外部 API 以获取模型权重中缺少的额外信息（通常在预训练后很难更改），包括当前信息、代码执行能力、对专有信息源的访问等</p><p><img data-src="https://lilianweng.github.io/posts/2023-06-23-agent/agent-overview.png" alt="img"></p><h3 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h3><h4 id="任务分解"><a href="#任务分解" class="headerlink" title="任务分解"></a>任务分解</h4><p>Chain of Thoughts已成为提高模型在复杂任务上性能的标准提示技术。该模型被指示 “逐步思考”，以利用更多的测试时计算将困难的任务分解为更小、更简单的步骤。CoT 将大任务转化为多个可管理的任务，并阐明对模型思维过程的解释<br>Tree of Thoughts通过在每一步探索多种推理可能性来扩展 CoT。它首先<strong>将问题分解为多个思考步骤，每个步骤生成多个思考，从而创建一个树状结构。</strong>搜索过程可以是 BFS（广度优先搜索）或 DFS（深度优先搜索），每个状态都由分类器（通过提示）或多数投票进行评估。<br>任务分解可以通过以下方式完成：（1） 由 LLM 使用简单的提示，如 <code>&quot;Steps for XYZ.\n1.&quot;</code> ， <code>&quot;What are the subgoals for achieving XYZ?&quot;</code> ， （2） 通过使用特定于任务的指令;例如 <code>&quot;Write a story outline.&quot;</code> 用于写小说，或 （3）人工输入<br>另一种非常不同的方法 LLM+P （ Liu et al. 2023） 涉及依靠外部经典规划师进行长期规划。这种方法利用规划域定义语言 （PDDL） 作为中间接口来描述规划问题。在这个过程中， LLM （1） 将问题翻译成 “问题 PDDL”，然后 （2） 请求经典规划师基于现有的 “领域 PDDL” 生成 PDDL 计划，最后 （3） 将 PDDL 计划翻译回自然语言。从本质上讲，规划步骤外包给外部工具，假设特定领域的 PDDL 和合适的规划器可用，这在某些机器人设置中很常见，但在许多其他领域中并不常见</p><h4 id="自我反思"><a href="#自我反思" class="headerlink" title="自我反思"></a>自我反思</h4><p>自我反省允许自主智能体通过改进过去的行动决策和纠正以前的错误来迭代改进。它在不可避免地需要试错的实际任务中起着至关重要的作用。<br>    ReAct通过将动作空间扩展为特定于任务的离散动作和语言空间的组合，将推理和行动整合到 LLM 中。前者使 LLM 能够与环境交互（例如使用维基百科搜索 API），而后者则提示 LLM 以自然语言生成推理轨迹。<br>    Reflexion 是一个框架，用于为智能体提供动态记忆和自我反思能力，以提高推理技能。Reflexion具有标准的 RL 设置，其中奖励模型提供简单的二进制奖励，操作空间遵循ReAct中的设置，其中特定于任务的操作空间通过语言进行扩充，以支持复杂的推理步骤。在每个操作a~t~之后，智能体会计算启发式 h~t~,并且可以根据自我反思结果选择性地决定重置环境以开始新的试用。<br><img data-src="https://lilianweng.github.io/posts/2023-06-23-agent/reflexion.png" alt="img"><br>    启发式函数确定轨迹何时效率低下或包含幻觉，何时应停止。低效的规划是指花费太长时间而没有成功的轨迹。幻觉被定义为遇到一系列连续的相同动作，这些动作导致在环境中进行相同的观察。<br>    自我反思是通过向 LLM 展示两张照片的例子来创建的，每个例子都是一对（失败的轨迹，指导计划中未来变化的理想反思）。然后将反射添加到 agent 的工作内存中，最多三个，用作查询 LLM 的上下文。<br><strong>Chain of Hindsight</strong>鼓励模型通过明确呈现一系列过去的输出来改进自己的输出，每个输出都带有反馈注释.CoH 的理念是在上下文中呈现连续改进的产出的历史，并训练模型顺应趋势以产生更好的产出。算法蒸馏将相同的想法应用于强化学习任务中的跨集轨迹，其中算法被封装在一个长期受历史条件限制的策略中。考虑到代理与环境交互多次，并且每次代理都会变得更好，AD 会将此学习历史记录连接起来，并将其馈送到模型中。</p><h3 id="记忆模块"><a href="#记忆模块" class="headerlink" title="记忆模块"></a>记忆模块</h3><p>三种类型的记忆</p><ol><li>感官记忆：这是记忆的最早阶段，提供在原始刺激结束后保留感官信息（视觉、听觉等）印象的能力。感官记忆通常最多只持续几秒钟。子类别包括图标记忆（视觉）、回声记忆（听觉）和触觉记忆（触觉</li><li>短期记忆 （STM） 或工作记忆：它存储我们目前知道的和执行复杂认知任务（如学习和推理）所需的信息。短期记忆被认为具有大约 7 项的容量 （Miller 1956） 并持续 20-30 秒。</li><li>长期记忆 （LTM）：长期记忆可以存储信息非常长的时间，从几天到几十年不等，具有基本上无限的存储容量。LTM 有两种亚型：<br> 显性 / 陈述性记忆：这是对事实和事件的记忆，指的是那些可以被有意识地回忆起来的记忆，包括情景记忆（事件和经历）和语义记忆（事实和概念）<br> 内隐/程序记忆：这种类型的记忆是无意识的，涉及自动执行的技能和例程，例如骑自行车或在键盘上打字。<br> 感官记忆作为原始输入（包括文本、图像或其他模态）的学习嵌入表示;<br> 短期记忆作为上下文学习。它简短而有限，因为它受 Transformer 的有限上下文窗口长度的限制。<br> 长期内存作为代理在查询时可以处理的外部向量存储，可通过快速检索访问。<h4 id="最大内积搜索"><a href="#最大内积搜索" class="headerlink" title="最大内积搜索"></a>最大内积搜索</h4>​    外部存储器可以缓解有限注意力持续时间的限制。标准做法是将信息的嵌入表示保存到可以支持快速最大内积搜索 （MIPS） 的向量存储数据库中。为了优化检索速度，常见的选择是近似最近邻 （ANN） 算法，以返回大约 k 个前 k 个最近邻，以牺牲一点准确性损失来换取巨大的加速<br>​    LSH（Locality-Sensitive Hashing）：它引入了一个哈希函数，<strong>以便将相似的输入项以高概率映射到相同的存储桶</strong>，其中存储桶的数量远小于输入的数量<br>​    ANNOY （Approximate Nearest Neighbors Oh Yeah）：核心数据结构是随机投影树，这是一组二叉树，其中每个非叶节点代表一个将输入空间分成两半的超平面，每个叶子存储一个数据点。树是独立且随机构建的，因此在某种程度上，它模仿了哈希函数。ANNOY 搜索发生在所有树中，以迭代搜索最接近查询的一半，然后聚合结果。这个想法与 KD 树非常相关，但更具可扩展性。<br>​    HNSW（分层可导航小世界）：它的灵感来自小世界网络的思想，其中大多数节点可以在少量步骤内被任何其他节点到达;例如社交网络的“六度分离”功能。HNSW 构建了这些小世界图的分层，其中底层包含实际数据点。中间的图层创建快捷方式以加快搜索速度。在执行搜索时，HNSW 从顶层的随机节点开始，并导航到目标。当它无法更靠近时，它会向下移动到下一层，直到到达底层。上层的每次移动都可能覆盖数据空间中的很长一段距离，而下层的每一次移动都会提高搜索质量。<br><strong>FAISS</strong>（meta相似性搜索）：它的运行基于以下假设：在高维空间中，节点之间的距离遵循高斯分布，因此应该存在数据点的聚类。<strong>FAISS 通过将向量空间划分为多个聚类，然后在聚类内优化量化来应用向量量化。Search 首先查找具有粗略量化的候选集群，然后进一步查找具有更精细量化的每个集群。</strong></li></ol><h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><p>工具的使用是人类的一个显著特征。我们创造、修改和利用外部物体来做超出我们身体和认知极限的事情。为 LLMs 配备外部工具可以显着扩展模型功能。<br>HuggingGPT 是一个以 ChatGPT 作为任务规划器的框架，根据模型描述选择 HuggingFace 平台中可用的模型，并根据执行结果总结响应. 系统调用包括任务规划,模型选择,任务执行,生成响应.<br>API-Bank 是评估工具增强 LLMs 性能的基准。它包含 53 个常用的 API 工具、一个完整的工具增强 LLM 工作流程，以及 264 个带注释的对话，涉及 568 个 API 调用。API 的选择非常多样化，包括搜索引擎、计算器、日历查询、智能家居控制、日程管理、健康数据管理、帐户身份验证工作流程等。因为 API 数量众多，所以 LLM 首先要有 API 搜索引擎，找到合适的 API 进行调用，然后用相应的文档进行调用。</p><h2 id="协同感知中的LLM"><a href="#协同感知中的LLM" class="headerlink" title="协同感知中的LLM"></a>协同感知中的LLM</h2><p>最近有一系列的工作使用LLM与协同感知、自动驾驶结合(也有使用VLM的,方法类似).这里简单介绍一些相关工作.</p><h3 id="V2V-LLM-Vehicle-to-Vehicle-Cooperative-Autonomous-Driving-with-Multi-Modal-Large-Language-Models"><a href="#V2V-LLM-Vehicle-to-Vehicle-Cooperative-Autonomous-Driving-with-Multi-Modal-Large-Language-Models" class="headerlink" title="V2V-LLM: Vehicle-to-Vehicle Cooperative Autonomous Driving with  Multi-Modal Large Language Models"></a>V2V-LLM: Vehicle-to-Vehicle Cooperative Autonomous Driving with  Multi-Modal Large Language Models</h3><p>当前的自动驾驶车辆主要依靠其单独的传感器来了解周围的场景并规划未来的轨迹，当传感器发生故障或被遮挡时可能是不可靠的。为了解决这个问题，通过车辆到车辆( Vehicle-to-Vehicle，V2V )通信的协作感知方法已经被提出，但<strong>它们往往侧重于检测和跟踪。这些方法如何有助于整体的协作规划性能仍未得到充分的研究</strong>。</p><p>受最近使用大语言模型( Large Language Models，LLMs )构建自动驾驶系统的进展的启发,提出了一种新的问题设置,将LLM集成到协作自动驾驶中，并提出了车对车问答( Vehicle-to- Vehicle Question-Answering，V2V-QA )数据集和基准测试集.</p><p>还提出了基线方法Vehicle-to-Vehicle Large Language Model ( V2V-LLM )，它使用一个LLM来融合来自多个连接的自动驾驶车辆( CAV )的感知信息，并回答与驾驶相关的问题：grounding,notable objected identification, and planning.</p><p>实验结果表明,提出的V2VLLM可以作为一个有前途的统一模型架构来执行协作自动驾驶中的各种任务，并且优于使用不同融合方法的其他基线方法。工作也开创了一个新的研究方向，可以提高未来自动驾驶系统的安全性。</p><p>无人驾驶车辆在日常运行中的感知和规划系统严格依赖于其本地的LiDAR传感器和相机来探测附近的显著目标并进行规划.<strong>当传感器被附近的大型物体遮挡时，这种方法可能会遇到安全问题</strong>。在这种情况下，自动驾驶车辆无法准确地检测到所有附近的显著目标，使得后续的轨迹规划结果不可靠。</p><p><img data-src="https://s2.loli.net/2025/03/01/b3Rwruo2Nqjl9Qc.png" alt="image-20250301190916782"></p><p>为了解决这个安全问题，最近的研究提出了通过车车通信( V2V )通信的协作感知算法。在协同驾驶场景中，多个邻近行驶的智能网联汽车( Connected Autonomous Vehicles，CAVs )通过V2V通信共享彼此的感知信息。然后将接收到的来自多个CAV的感知数据进行融合，以产生更好的整体检测结果。</p><p>所有CAV与LLM共享各自的感知信息。任何CAV都可以以自然语言的形式向LLM提问，以获取对驾驶安全有用的信息。</p><p>为了研究这个问题，首先创建了车辆到车辆问答( V2V-QA )数据集，该数据集基于V2V4Real的自动驾驶协作感知数据集。</p><p>车-车大语言模型( V2V-LLM )用于协同自动驾驶.每个CAV提取自己的感知特征，并与V2V-LLM共享。V2V-LLM融合场景级特征图和对象级特征向量，然后进行视觉和语言理解，为V2V-QA中输入的驾驶相关问题提供答案。</p><p>还将V2V - LLM与其他基线方法对应的不同特征融合方法：不融合、早期融合和中间融合进行了比较。结果表明，V2V - LLM在较重要的目标识别和规划任务中取得了最好的性能，在grounding任务中取得了次优的性能，</p><p><img data-src="https://s2.loli.net/2025/03/01/JaKvA2B4yOdxcSP.png" alt="image-20250301204106243"></p><p>对于V2V4Real数据集的每一帧，创建了5种不同类型的问答对，包括3种类型的背景问题，1种类型的显著对象识别问题和1种类型的规划问题。这些QAs是针对协同驾驶场景设计的。为了生成这些问答对的实例，使用V2V4Real 的ground-truth边界框注释、每个CAV的ground - truth轨迹和个体检测结果作为源信息。然后根据前述实体和文本模板之间的几何关系使用不同的手动设计的规则来生成的问答对</p><p>作者设计了几种不同类型的问答对作为数据集,这个数据集也是多模态数据集.</p><p><strong>Q1</strong> Grounding at a reference location</p><p>在这种类型的问题中，要求LLM来识别是否存在一个对象占据了特定的查询2D位置。如果是，则期望LLM提供物体的中心位置。否则，LLM应该表示在参考位置处没有任何信息。为了生成这类问答对的实例，我们使用背景-真值框的中心位置和每个CAV的单个检测结果框作为问题中的查询位置。这样，我们可以更专注于评估各个模型对潜在的假阳性和假阴性检测结果的协同接地能力。</p><p><strong>Q2</strong> Grounding behind a reference object at a location</p><p>当一个CAV的视场被一个邻近的大物体遮挡时，该CAV可能希望根据所有CAV的融合感知信息，请求中心化的LLM来判断遮挡大物体后面是否存在物体。如果是这样的话，LLM预计将返回对象的位置，询问CAV可能需要更多的防御性驾驶或调整其规划。否则，LLM应该表明参照对象背后没有任何东西。为了生成这类问答对的实例，使用每个检测结果框的中心位置作为这些问题中的查询位置。根据询问的CAV与参考物体的相对位姿画出一个扇形区域，并在该区域中选择距离最近的真实物体作为答案。</p><p><strong>Q3</strong> Grounding behind a reference object in a direction</p><p>进一步在语言和空间理解能力上对LLM提出了挑战，将Q2的参考2D位置替换为参考方向关键字。为了生成这类QA对的实例，首先在一个CAV的6个方向中各得到一个最接近的检测结果框作为参考对象。然后在Q2中遵循相同的数据生成方法，在相应的扇形区域中得到最接近的ground-truth box作为答案。</p><p><strong>Q4</strong> Notable object identification</p><p>前述的真值任务可以看作自动驾驶管道中的中间任务。自动驾驶车辆更关键的能力包括识别规划的未来轨迹附近的显著目标和调整未来规划以避免潜在的碰撞。在显著性物体识别问题中，从地面-真值轨迹中提取了6个未来3秒的路标点作为问题中的参考未来路标点。然后，在参考未来轨迹的10米范围内最多得到3个最近的地面真实物体作为答案。</p><p><strong>Q5</strong> 规划</p><p>与上述QA类型相比，规划是自动驾驶系统最重要的输出，因为自动驾驶汽车的最终目标是安全地通过复杂的环境，避免未来的任何潜在碰撞。为了生成规划QAs，我们从每个CAV的真实未来轨迹中提取6个均匀分布在未来3秒内的未来航路点作为答案。由于一些原因，V2V - QA的规划任务也比其他基于NuScenes的LLM驱动的相关工作更具有挑战性。首先，我们在协同驾驶场景中支持多辆CAV。LLM模型需要提供不同的答案，这取决于哪个CAV要求其建议的未来轨迹，而先前的工作只需要生成单个自动驾驶车辆的规划结果。其次，V2V-QA是基于V2V4Real的，它包括城市和高速公路两种驾驶场景。在这两种不同的环境中，车辆的运动模式有很大的不同。相反，基于Nu Scenes的LLM驾驶研究只需要考虑城市驾驶场景。</p><p><img data-src="https://s2.loli.net/2025/03/01/6Rit5JYmheqW82P.png" alt="image-20250301212424018"></p><h3 id="AGENTSCODRIVER-Large-Language-Model-Empowered-Collaborative-Driving-with-Lifelong-Learning"><a href="#AGENTSCODRIVER-Large-Language-Model-Empowered-Collaborative-Driving-with-Lifelong-Learning" class="headerlink" title="AGENTSCODRIVER: Large Language Model  Empowered Collaborative Driving with Lifelong  Learning"></a>AGENTSCODRIVER: Large Language Model  Empowered Collaborative Driving with Lifelong  Learning</h3><p>智能网联汽车和无人驾驶近来发展迅速。然而，目前的自动驾驶系统主要基于数据驱动的方法，<strong>在可解释性、泛化性和持续学习能力方面表现出明显的不足。此外，单车自动驾驶系统缺乏与其他车辆协作和协商的能力，这对驾驶安全和效率至关重要</strong>。为了有效地解决这些问题，利用大型语言模型( LLMs )开发了一个新的框架，称为AGENTSCODRIVER，以使多车辆能够进行协同驾驶。</p><p>AGENTSCODRIVER由5个模块组成：<strong>观察模块、推理引擎、认知记忆模块、强化反射模块和通信模块</strong>。它可以通过与驾驶环境的不断交互，随时间推移积累知识、教训和经验，从而使实现终身学习成为可能。此外，通过利用通信模块，不同智能体可以交换信息，实现复杂驾驶环境下的协商与协作。进行了大量的实验，并显示了AGENTSCODRIVER相对于现有方法的优越性。</p><p><img data-src="https://s2.loli.net/2025/03/01/U5HNZpuxPMXJIzd.png" alt="image-20250301212736505"></p><p>AGENTSCODRIVER的体系结构由5个模块组成：观测模块、推理引擎、存储模块、增强反射模块和通信模块。推理引擎、通信模块和增强反射模块利用LLMs生成消息和最终决策</p><p><strong>Observation Module</strong></p><p>为了使智能体能够进行协作，CAV感知其周围环境并提取必要的信息用于下游的高阶任务推理是很重要的，因此为智能体开发了一个观测模块来编码其周围的场景，并提取其有用的高层信息，如车道数和周围车辆的位置和速度。然后将这些观察结果输入到智能体的推理引擎中进行分析并做出决策。它们也被用来从记忆模块中回忆相关的记忆</p><p><strong>Reasoning Engine</strong></p><p>推理是人类最基本、最重要的能力之一，对于人类做出日常的、复杂的决策具有重要的意义。传统的数据驱动方法直接利用感知信息(例如,目标检测结果和语义分割结果)进行最终的驾驶决策(例如,左转或右转,加速和减速)，缺乏可解释性，无法处理复杂场景和长尾情况。受人类推理能力的启发，我们提出了一个CAV智能体的推理引擎，它由三个步骤组成：1 )提示生成，2 )推理过程，3 )运动规划。</p><p><strong>Memory Module</strong></p><p>记忆对于一个人来说是非常重要的。当一个人驾驶汽车时，他或她会使用常识，例如遵守交通规则和回忆过去的经验来做出决定。为了将这种能力灌输给智能体，我们提出了智能体的记忆模块，该模块由三部分组成：常识记忆、经验记忆和结构化文本存储的反思记忆。常识性记忆包含了驾驶的常识性知识，如交通规则等。经验记忆包含过去的驾驶场景和相应的决策。反射记忆包含反射模块的反馈。智能体可以从存储模块中检索相关的内存，使其可用于决策。</p><p><strong>Reinforcement Reflection</strong></p><p>一个人要想成为某一领域的专家，就必须从过去的经历中学习，这意味着他必须有能力反思自己过去的错误，并分析其背后的原因。对于智能体来说，拥有这样的反思能力对于保持正确的操作和安全驾驶也是至关重要的。基于这些观察，提出了强化反射，它有两个模块：一个评估器和一个反射器。评价者(记为E )像评判者一样对agent的输出进行打分，反射者(记为R )可以对agent的行为进行反思，并生成分析结果来改进agent的行为。</p><p><img data-src="https://s2.loli.net/2025/03/01/K8GL6CWQgoEzJXl.png" alt="image-20250301214528445"></p><p><strong>Communication Module</strong></p><p>协作Agent之间的有效通信是至关重要的。通过相互之间的通信，将扩大智能体的观测范围。分别考虑两个智能体的观测值o1和o2，如果两个智能体相互交换观测信息，则两个智能体的观测值将扩展到o1∪o2。此外，沟通对于代理人之间相互协商并做出更好的决策也是至关重要的。例如，考虑一个智能体正在驾驶一辆汽车，并且想要超越前车。如果智能体与前车进行通信，则前车的智能体学习到后方车辆的意图，进而可以做出更好的决策，避免潜在的碰撞。</p><h3 id="Towards-Interactive-and-Learnable-Cooperative-Driving-Automation-a-Large-Language-Model-Driven-Decision-Making-Framework"><a href="#Towards-Interactive-and-Learnable-Cooperative-Driving-Automation-a-Large-Language-Model-Driven-Decision-Making-Framework" class="headerlink" title="Towards Interactive and Learnable Cooperative Driving Automation: a Large Language Model-Driven Decision-Making Framework"></a>Towards Interactive and Learnable Cooperative Driving Automation: a Large Language Model-Driven Decision-Making Framework</h3><p>目前，智能网联汽车( Connected Autonomous Vehicles，CAVs )已经开始在世界各地进行开放道路测试，但其在复杂场景下的安全和效率表现仍不尽如人意。协同驾驶利用CAV的连通能力实现大于其部分之和的协同作用，使其成为提高复杂场景下CAV性能的一种有前途的方法。然而，缺乏交互和持续学习能力限制了当前的协同驾驶到单场景应用和特定的协同驾驶自动化( Cooperative Driving Automation，CDA )。</p><p>为了应对这些挑战，本文提出了一种可交互和学习的LLM驱动的协同驾驶框架CoDrivingLLM，以实现全场景和全CDA。</p><p><img data-src="https://s2.loli.net/2025/03/01/1IqhDjUavQlOLou.png" alt="image-20250301215707384"></p><p>首先，由于大语言模型( Large Language Models，LLMs )不擅长处理数学计算，<strong>引入环境模块，基于语义决策更新车辆位置，从而避免直接LLM控制车辆位置可能带来的误差</strong>。其次，基于SAE J3216标准定义的CDA的四个层次，提出了基于思维链( Chain-of- Thought，COT )的推理模块，包括<strong>状态感知、意图共享、协商和决策</strong>，增强了LLMs在多步推理任务中的稳定性。</p><p>然后，在推理过程中，通过冲突协调者来管理集中的冲突解决。最后，通过引入记忆模块和使用提取增强生成，赋予CAVs从过去经验中学习的能力。</p><p><img data-src="https://s2.loli.net/2025/03/01/GZoEUBPHJ4lnSMR.png" alt="image-20250301215538196"></p><p><img data-src="https://s2.loli.net/2025/03/01/7N1apvPSXFcDfOo.png" alt="image-20250301221105318"></p><h3 id="Is-Intermediate-Fusion-All-You-Need-for-UAV-based-Collaborative-Perception"><a href="#Is-Intermediate-Fusion-All-You-Need-for-UAV-based-Collaborative-Perception" class="headerlink" title="Is Intermediate Fusion All You Need for UAV-based Collaborative  Perception?"></a>Is Intermediate Fusion All You Need for UAV-based Collaborative  Perception?</h3><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>协同感知通过Agent间通信增强环境感知，被认为是智能交通系统的一个有前途的解决方案。然而，现有的无人机协同方法<strong>忽略了无人机视角的独特特性，导致了大量的通信开销</strong>。为了解决这个问题，我们提出了一种新的<strong>基于后中间层融合的通信高效的协作感知框架</strong>，称为LIF。</p><p>其核心思想是<strong>交换信息量大且紧凑的检测结果，并将融合阶段转移到特征表示层面</strong>。特别地，<strong>利用视觉引导的位置嵌入( VPE )</strong>和<strong>基于框的虚拟增强特征( Bo BEV )来有效地整合来自不同代理的互补信息</strong>。此外，我们创新性地引入了一种<strong>不确定性驱动的通信机制，使用不确定性评估来选择高质量和可靠的共享区域</strong>。</p><p><img data-src="https://s2.loli.net/2025/05/19/LUCgmobRie6r4YA.png" alt="image-20250519201823979"></p><h3 id="TASK-ORIENTEDCOMMUNICATIONFORVEHICLE-TO-INFRASTRUCTURE-COOPERATIVEPERCEPTION"><a href="#TASK-ORIENTEDCOMMUNICATIONFORVEHICLE-TO-INFRASTRUCTURE-COOPERATIVEPERCEPTION" class="headerlink" title="TASK-ORIENTEDCOMMUNICATIONFORVEHICLE-TO-INFRASTRUCTURE COOPERATIVEPERCEPTION"></a>TASK-ORIENTEDCOMMUNICATIONFORVEHICLE-TO-INFRASTRUCTURE COOPERATIVEPERCEPTION</h3><p>车辆与基础设施的通信( V2I )协作感知在自动驾驶场景中起着至关重要的作用。尽管其具有提高感知精度和鲁棒性的潜力，但大量的原始传感器数据不可避免地导致了较高的通信开销。为了缓解这个问题，我们提出了一种面向任务的V2I协作感知通信框架TOCOM - V2I，它<strong>通过只传输与任务相关的信息而不是原始数据流来感知周围环境，从而减少带宽消耗</strong>。</p><p>我们的贡献有三。首先，我们提出了基于空间关系和感知先验的空间感知特征选择模块来过滤掉不相关的信息。其次，我们引入了分层熵模型来利用特征内的冗余，以实现高效的压缩和传输。最后，我们利用一个缩放的点积注意力架构来融合车辆端和基础设施端特征，以提高感知性能</p><p>空间感知特征选择模块旨在从基础设施侧特征FI中识别出对车辆来说既具有感知意义又是必要的特征F ~ I。在目标检测的背景下，FI中包含目标的区域比背景区域更具有任务相关性。在协作过程中，这些物体可以通过恢复车辆视野中被遮挡或丢失的物体来帮助提高感知质量。此外，距离车辆越近的物体越容易被车辆自身检测到。虽然从基础设施的角度来看，这些对象在感知上很重要，但没有必要传输这些特征。</p><p><img data-src="https://s2.loli.net/2025/05/19/CjKxWzUFnSImG6Q.png" alt="image-20250519202216047"></p><h2 id="时延问题"><a href="#时延问题" class="headerlink" title="时延问题"></a>时延问题</h2><p>引入时间信息的编码</p><p>V2VNet</p><p><img data-src="https://s2.loli.net/2025/05/26/WYh3nLOkHo4DcbA.png" alt="image-20250526111749407"></p><p><img data-src="https://s2.loli.net/2025/05/26/zsyQwZC9VNhJruf.png" alt="image-20250526114903582"></p><p>V2X-ViT</p><p><img data-src="https://s2.loli.net/2025/05/28/YD1qVd5jlihTAuF.png" alt="image-20250528213454183"></p><p>增加时间编码</p><h3 id="Latency-Aware-Collaborative-Perception"><a href="#Latency-Aware-Collaborative-Perception" class="headerlink" title="Latency-Aware Collaborative Perception"></a>Latency-Aware Collaborative Perception</h3><p><img data-src="https://s2.loli.net/2025/05/26/zBJ1wDiRO6rTdqA.png" alt="image-20250526225952639"></p><p><img data-src="https://s2.loli.net/2025/05/27/Q2tnd7KxNgJH4Cl.png" alt="image-20250527102534252"></p><p><img data-src="https://s2.loli.net/2025/05/27/KPhjznkL9WQs2cX.png" alt="image-20250527180538143"></p><p><img data-src="https://s2.loli.net/2025/05/27/d8WJcQ3hzrxtF6g.png" alt="image-20250527200936722"></p><h3 id="Co-MTP-A-Cooperative-Trajectory-Prediction-Framework-with-Multi-Temporal-Fusion-for-Autonomous-Driving"><a href="#Co-MTP-A-Cooperative-Trajectory-Prediction-Framework-with-Multi-Temporal-Fusion-for-Autonomous-Driving" class="headerlink" title="Co-MTP: A Cooperative Trajectory Prediction Framework  with Multi-Temporal Fusion for Autonomous Driving"></a>Co-MTP: A Cooperative Trajectory Prediction Framework  with Multi-Temporal Fusion for Autonomous Driving</h3><p>​    车联网技术( V2X )已成为扩展感知范围、看穿遮挡物的理想范式。现有的研究主要集中在单帧协作感知，然而，<strong>如何利用V2X捕获帧与帧之间的时间线索，以促进预测任务甚至规划任务的进行，仍然缺乏研究</strong>。在本文中，介绍了Co - MTP，一种面向自动驾驶的多时态融合的通用协同轨迹预测框架，它利用V2X系统充分捕获历史和未来域中智能体之间的相互作用，从而有利于规划。</p><p>​    在历史域中，V2X可以对单车感知中不完整的历史轨迹进行补充，我们设计了一个异构的图变换来学习来自多个智能体的历史特征的融合，并捕获历史交互。此外，预测的目的是支持未来的规划。</p><p>​    </p><h3 id="Asynchrony-Robust-Collaborative-Perception-via-Bird’s-Eye-View-Flow"><a href="#Asynchrony-Robust-Collaborative-Perception-via-Bird’s-Eye-View-Flow" class="headerlink" title="Asynchrony-Robust Collaborative Perception via Bird’s Eye View Flow"></a>Asynchrony-Robust Collaborative Perception via Bird’s Eye View Flow</h3><p>作为一个新兴的领域，协作感知的研究有许多挑战需要解决，例如高质量的数据集，模型不可知和任务不可知的表述以及对错误的鲁棒性和对抗性攻击。然而绝大多数现有工作并没有认真考虑智能体之间实际通信的严酷现实，如拥塞、计算量大、中断和缺乏校准等。这些因素引入了延迟或失调，严重影响了Agent之间信息交换的可靠性和质量。一些先前的工作已经涉及到了通信延迟的问题。例如，<strong>V2VNet和V2XViT 将延迟时间作为特征补偿的输入</strong>。然而，它们只考虑了单一帧，没有利用历史帧，对于高速场景( 20m / s以上)或高延迟场景( 0.3 s以上)是不充分的。同时，<strong>SyncNet使用历史特征来预测完整的特征</strong></p><p>V2VNet利用卷积神经网络，通过将时间信息和相对位姿作为输入，学习如何补偿通信延迟；<strong>V2X-ViT设计了一个时延感知的位置编码模块来学习时延带来的影响，但是这些方法没有考虑历史时序信息进行补偿</strong>。SyncNet利用历史多帧信息，通过Conv - LSTM对当前时刻进行补偿，但其对整个特征图的补偿导致特征通道存在噪声，基于RNN的框架无法处理时间上的不规则输入。</p><p><img data-src="https://s2.loli.net/2025/05/26/KyiUGwp4s8xnMYR.png" alt="image-20250526144303233"></p><h3 id="Flow-Based-Feature-Fusion-for-Vehicle-Infrastructure-Cooperative-3D-Object-Detection"><a href="#Flow-Based-Feature-Fusion-for-Vehicle-Infrastructure-Cooperative-3D-Object-Detection" class="headerlink" title="Flow-Based Feature Fusion for Vehicle-Infrastructure Cooperative 3D Object Detection"></a>Flow-Based Feature Fusion for Vehicle-Infrastructure Cooperative 3D Object Detection</h3><p>特征流生成。采用特征流作为预测函数来描述未来基础设施特征随时间的变化。给定当前点云帧Pi ( ti )和基础设施特征提取器Fi ( · )，定义ti之后未来时刻t的特征流为</p><script type="math/tex; mode=display">\widetilde{F}_{i}(t)\ =F_{i}(P_{i}(t))_{,}\,t\ge\,t_{i}</script><h3 id="Vehicle-Infrastructure-Cooperative-3D-Object-Detection-via-Feature-Flow-Prediction"><a href="#Vehicle-Infrastructure-Cooperative-3D-Object-Detection-via-Feature-Flow-Prediction" class="headerlink" title="Vehicle-Infrastructure Cooperative 3D Object Detection via Feature Flow Prediction"></a>Vehicle-Infrastructure Cooperative 3D Object Detection via Feature Flow Prediction</h3><p><img data-src="https://s2.loli.net/2025/05/26/zyYZQMXmxW2EvST.png" alt="image-20250526221403766"></p><h3 id="V2XPnP-Vehicle-to-Everything-Spatio-Temporal-Fusion-for-Multi-Agent-Perception-and-Prediction"><a href="#V2XPnP-Vehicle-to-Everything-Spatio-Temporal-Fusion-for-Multi-Agent-Perception-and-Prediction" class="headerlink" title="V2XPnP: Vehicle-to-Everything Spatio-Temporal Fusion for Multi-Agent Perception and Prediction"></a>V2XPnP: Vehicle-to-Everything Spatio-Temporal Fusion for Multi-Agent Perception and Prediction</h3><p>车联网( V2X )技术提供了一个有前途的范例，以减轻单车辆系统中受限可观测性的限制。先前的工作主要集中在单帧合作感知，它<strong>融合了不同空间位置的智能体信息，但忽略了时间线索和时间任务</strong>(例如,时间知觉和预测)。</p><p>本文针对V2X场景下的时空融合问题，设计了一步式和多步式通信策略(何时传输)，并考察了其与早、晚、中3种融合策略(传输什么?)的融合情况，提供了11种融合模型(如何融合)的综合基准。进一步地，我们提出了V2XPnP，一种新颖的用于端到端感知和预测的一步通信中间层融合框架。我们的框架采用了基于Transformer的统一架构，有效地建模了跨多个代理、帧和高清地图的复杂时空关系。</p><p>自动驾驶系统需要准确感知周围道路用户并预测其未来轨迹，以确保安全和交互式驾驶。尽管最近在感知和预测方面取得了进展，但单车系统仍然面临有限的感知范围和遮挡问题，影响了驾驶性能和道路安全。因此，车联网( V2X )技术已经成为一种很有前途的范式,它使连接和自动化的车辆( CAVs )和基础设施能够共享互补信息并缓解遮挡，从而支持整体环境理解</p><p>尽管有它们的潜力，现有的工作集中在逐帧协作检测，它聚合了来自不同空间位置的代理的信息。然而，这些工作<strong>忽略了连续帧之间的时间线索，这对于定位以前可见但目前未被发现的对象</strong>和预测对象未来的轨迹很重要</p><h3 id="CoDynTrust-Robust-Asynchronous-Collaborative-Perception-via-Dynamic-Feature-Trust-Modulus"><a href="#CoDynTrust-Robust-Asynchronous-Collaborative-Perception-via-Dynamic-Feature-Trust-Modulus" class="headerlink" title="CoDynTrust: Robust Asynchronous Collaborative Perception via  Dynamic Feature Trust Modulus"></a>CoDynTrust: Robust Asynchronous Collaborative Perception via  Dynamic Feature Trust Modulus</h3><p>协同感知通过融合多个智能体的信息，可以扩展感知范围，从而提高感知性能。<strong>然而，在现实环境中，由于通信延迟、时钟失调或采样配置差异引起的时间异步会导致信息不匹配。</strong></p><p><strong>如果处理不当，那么协同性能就会参差不齐，更严重的可能会发生安全事故。为了应对这一挑战，我们提出了CoDynTrust，一种不确定性编码的异步融合感知框架，对时间不同步导致的信息不匹配具有鲁棒性。</strong></p><p>CoDynTrust通过对即兴和认知不确定性建模，选择性地抑制或保留单车辆特征，为每个感兴趣区域生成动态特征信任模( DFTM )，从而缓解信息不匹配问题。然后，我们设计了一个多尺度融合模块来处理DFTM处理后的多尺度特征图。</p><p>然后，我们设计了一个多尺度融合模块来处理DFTM处理后的多尺度特征图。与现有的考虑异步协同感知的工作相比，CoDynTrust在时间异步场景中对抗各种低质量信息，并允许不确定性传播到下游任务，如规划和控制。</p><h3 id="Leveraging-Temporal-Contexts-to-Enhance-Vehicle-Infrastructure-Cooperative-Perception"><a href="#Leveraging-Temporal-Contexts-to-Enhance-Vehicle-Infrastructure-Cooperative-Perception" class="headerlink" title="Leveraging Temporal Contexts to Enhance Vehicle-Infrastructure  Cooperative Perception"></a>Leveraging Temporal Contexts to Enhance Vehicle-Infrastructure  Cooperative Perception</h3><p>安装在高架位置的基础设施传感器提供了更广泛的感知范围，并遇到更少的遮挡。通过V2X通信整合基础设施和自车数据，称为车-基础设施合作，在增强感知能力和解决单车自动驾驶中遇到的转角情况方面显示出相当大的优势。</p><p>​    然而,协作感知仍然面临着许多挑战，包括有限的通信带宽和实际通信中断。在本文中，提出了一种新的协同3D目标检测框架CTCE。该框架<strong>以时间上下文增强的方式传输查询，有效地平衡了传输效率和性能</strong>，以适应现实世界的通信条件。此外，我们还提出了一个时间引导的融合模块来进一步提高性能。</p><p>路侧时间增强和车侧时空融合共同构成了多层次的时间上下文融合机制，充分利用时间信息提升性能。</p><p><img data-src="https://s2.loli.net/2025/05/19/eptucRAXdNPwk7D.png" alt="image-20250519202400933"></p><h3 id="Multi-Agent-Collaborative-Perception-via-Motion-Aware-Robust-Communication-Network"><a href="#Multi-Agent-Collaborative-Perception-via-Motion-Aware-Robust-Communication-Network" class="headerlink" title="Multi-Agent Collaborative Perception via Motion-Aware Robust Communication Network"></a>Multi-Agent Collaborative Perception via Motion-Aware Robust Communication Network</h3><p><img data-src="https://s2.loli.net/2025/05/28/JtHQVc1n2v86UXC.png" alt="image-20250528105139615"></p><p><img data-src="https://s2.loli.net/2025/05/28/3UwDiBq8ZRs94Pp.png" alt="image-20250528111736833"></p><p><img data-src="https://s2.loli.net/2025/05/28/UHwDobJxyz32LhW.png" alt="image-20250528111849168"></p><p><img data-src="https://s2.loli.net/2025/05/28/q6HJklWt9fOSIZc.png" alt="image-20250528111903710"></p><p>将feature flow和lstm更新特征的想法结合</p><p>motivation: 多智能体的特征融合是提升协作感知性能的一个关键,过去的一些工作忽略的传输延迟导致时间上的特征不对齐，我们利用历史帧数据,考虑motion状态不断更新. 一个空间上不同位置的注意力和改造后的lstm,结合时序预测. flow generator,in-frame decoding</p><p><strong>STAM</strong> (Spatio-Temporal Aggregation Module)</p><p>transformer+lstm+feature flow+时序预测+帧内位置编码</p><p>每一帧保存一个q,k,v(融合后的)</p><p>相关工作 v2vnet v2x-vit lantancy-aware bevflow </p><h2 id="利用query与晚期检测结果、置信度降低带宽"><a href="#利用query与晚期检测结果、置信度降低带宽" class="headerlink" title="利用query与晚期检测结果、置信度降低带宽"></a>利用query与晚期检测结果、置信度降低带宽</h2><h3 id="CoSDH-Communication-Efficient-Collaborative-Perception-via-Supply-Demand-Awareness-and-Intermediate-Late-Hybridization"><a href="#CoSDH-Communication-Efficient-Collaborative-Perception-via-Supply-Demand-Awareness-and-Intermediate-Late-Hybridization" class="headerlink" title="CoSDH: Communication-Efficient Collaborative Perception via Supply-Demand Awareness and Intermediate-Late Hybridization"></a>CoSDH: Communication-Efficient Collaborative Perception via Supply-Demand Awareness and Intermediate-Late Hybridization</h3><p>​    多智能体协同感知通过利用多个智能体的信息来增强感知能力，被认为是解决自动驾驶中单车感知能力弱问题的根本解决方案。然而，现有的协同感知方法面临着通信效率和感知精度之间的两难问题。</p><p>​    为了解决这个问题，我们提出了一种新颖的基于供需感知和中晚期混合的高效通信协作感知框架，称为CoSDH。该框架通过对Agent之间的供需关系进行建模，细化了协作区域的选择，在保持准确性的同时减少了不必要的通信成本。</p><p>​    此外创新性地引入了中-晚期混合协作模式，其中晚期协作弥补了低通信带宽下协作感知中的性能下降。</p><p><img data-src="https://s2.loli.net/2025/05/28/heA1tbXIiVDYr8o.png" alt="image-20250528141211346"></p><p>首先在PointPillar编码点云时,对于agent i,考虑使用每个支柱中的点云数量来表示点云密度，并将其映射到范围[ 0、1 ]. 然后选择点云密度低于阈值ε a的区域来获得agent i的需求掩码，Di = Ai &lt; εa∈{ 0，1 }^H×W^</p><p>同时使用detection header得到空间置信度图,利用一个供给阈值ε c得到供给掩码S ( l ) i = Ci &gt; εc∈{ 0，1 } ^H×W^.  至此得到supply和demand两个空间mask. 通过调整阈值，我们可以动态地调整用于协作感知的带宽，以适应不断变化的通信条件。</p><p>在协作过程中，agent~j~基于其供应掩码S~j~和agent~i~的需求掩码D~i~生成一个二元供需选择掩码M~j→i~ = D~i~⊙S~j~∈{ 0,1 }^H×W^，并对其进行采样，将其与多尺度BEV特征{ F(l) ~j~ } ~l=1,2,..,L~进行逐元相乘,得到稀疏特征{ Z(l)~j→i~ }~l=1,2,..,L~</p><h3 id="CoopDETR-A-Unified-Cooperative-Perception-Framework-for-3D-Detection-via-Object-Query"><a href="#CoopDETR-A-Unified-Cooperative-Perception-Framework-for-3D-Detection-via-Object-Query" class="headerlink" title="CoopDETR: A Unified Cooperative Perception Framework for 3D Detection via Object Query"></a>CoopDETR: A Unified Cooperative Perception Framework for 3D Detection via Object Query</h3><p><img data-src="https://s2.loli.net/2025/05/28/C3TP5RLomvNcBp2.png" alt="image-20250528151426743"></p><h3 id="How2Com"><a href="#How2Com" class="headerlink" title="How2Com"></a>How2Com</h3><p>​    多智能体协同感知作为一种新兴的驾驶场景应用，最近受到了广泛关注。尽管在先前的努力中取得了进展，但由于感知过程中的各种困境，包括<strong>通信冗余</strong>、<strong>传输延迟</strong>和协作异构性，挑战仍然存在。</p><p>​    为了解决这些问题，提出了How2comm，一种在感知性能和通信带宽之间寻求平衡的协作感知框架。我们的新颖性体现在三个方面。</p><p>首先，设计了一种互信息感知的通信机制，以最大限度地保持合作者共享的信息特征。采用空间通道滤波进行有效的特征稀疏化，以实现高效通信。</p><p>其次，我们提出了一种流导向的延迟补偿策略来预测合作者的未来特征，并消除由于时间不同步导致的特征错位。</p><p>​    最后，引入一个语用协作转换器来整合智能体之间的整体空间语义和时间上下文线索。我们的框架在真实世界和模拟场景中的多个基于LiDAR的协同探测数据集上进行了全面的评估</p><p>​    减少通信开销的主要模式被总结为<strong>特征压缩和空间滤波</strong>。前者假设智能体无差别地共享所有的空间区域，这极大地浪费了带宽。后者过度依赖置信图来突出易受骗的位置，没有考虑空间上的整体信息。此外，这些方法总是会造成传输的有价值信息的损失。</p><p>​    不可避免的传输延迟会导致快速移动物体在绿色圆内的位置错位，从而对后续的协作性能造成潜在的危害。虽然一些延迟感知策略被提出来解决这个问题，但它们要么<strong>受到性能瓶颈的影响</strong>，要么<strong>引入大量的计算开销</strong>，从而导致次优的解决方案。</p><p>​    各Agent之间激光雷达配置差异(例如,不同的LiDAR密度、分布、反射率和噪声干扰)可能导致特征空间内的协作异构. 从这两个感知区域融合有价值的空间语义，有助于全面和务实的感知。然而,先前的大多数方法通过个体/位置信息融合来整合合作者共享的特征以增强自我表征，<strong>其协作过程可能是脆弱的，因为没有从整体上考虑来自异构智能体的不同感知区域的优势。而且，当前的单帧感知范式面临着三维点云稀疏性和定位误差的挑战</strong>，增加了构建鲁棒的多智能体感知系统的难度。</p><p><img data-src="https://s2.loli.net/2025/05/28/L4zjETsIZkaouq3.png" alt="image-20250528161421934"></p><h4 id="Inspiration"><a href="#Inspiration" class="headerlink" title="Inspiration"></a>Inspiration</h4><ol><li>对于减少通信量,</li></ol><p>exclusive map,common map. decouple?</p><p>supply demand object query, confidence map,entropy?</p><ol><li>对于融合</li></ol><p>考虑时延</p><p>解决时延问题,引入feature flow思想,利用多层LSTM. </p><p>feature flow, flow generator,设计损失减少差异</p><p>使用范围编码考虑空间.</p><p>为了更好地关注/聚合历史数据,我们在lstm结构基础上进行了改进,引入注意力机制,关注.多层的query  exclusive common query </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://lilianweng.github.io/posts/2023-06-23-agent/">LLM Powered Autonomous Agents | Lil’Log</a></li><li><a href="https://lilianweng.github.io/posts/2022-06-09-vlm/">Generalized Visual Language Models | Lil’Log</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;这半年要论AI哪些方向最火,那关键词必然包括多模态,AI Agent,RAG等等(事实上已经火了一轮开始冷饭热炒了),一些做之前基础大模型的公司基本开始转向做应用甚至其他方向了. 这里整理一些关于AI Agents的知识和相关基础框架,并结合多智能体协同感知看看有哪些能做的结合.&lt;br&gt;</summary>
    
    
    
    
    <category term="collaborative perception" scheme="https://www.sekyoro.top/tags/collaborative-perception/"/>
    
  </entry>
  
  <entry>
    <title>学习桌面开发先进经验,从WPF看起</title>
    <link href="https://www.sekyoro.top/2025/01/10/%E5%AD%A6%E4%B9%A0%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E5%85%88%E8%BF%9B%E7%BB%8F%E9%AA%8C%EF%BC%8C%E4%BB%8EWPF%E7%9C%8B%E8%B5%B7/"/>
    <id>https://www.sekyoro.top/2025/01/10/%E5%AD%A6%E4%B9%A0%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E5%85%88%E8%BF%9B%E7%BB%8F%E9%AA%8C%EF%BC%8C%E4%BB%8EWPF%E7%9C%8B%E8%B5%B7/</id>
    <published>2025-01-10T11:48:31.000Z</published>
    <updated>2025-02-07T14:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在桌面开发上,我已经尝试过许多框架和组合,比如Qt/PyQt,Electron,Flutter,Winform. 如今跨平台风气正盛,包括MAUI,Flutter以及Kotlin MultiPlatform(KMP)等等都风头正盛. 但我的理解是作为个人开发,很多时候并不需要写跨平台的桌面应用,不如写原生的.</p><p> 目前我的理解是:</p><ol><li>需要仔细思考产品跨平台的必要性,跨平台并不是free launch. </li><li>C++的桌面程序框架也有很多,但许多人因为语言问题放弃了,着实可惜.由于c++的高性能和gl图形库诞生许多简单的GUI,比如<a href="https://github.com/TimoSalomaki/awesome-dear-imgui">awesome-dear-imgui</a>和<a href="https://www.raylib.com/">raylib</a></li><li>Qt框架不只是GUI,拿他跟其他UI库比较不公平.它提供了包括网络库在内的功能,而这本身就是C++相比其他现代语言在标准库和生态的差距. 此外Qt还有结合JS的QML,QWebEngine一堆技术.</li><li>使用Web技术开发桌面应用的开发体验仍然有待提升,目前React Native发展正盛,也是得益于前端的蓬勃生态.</li><li>c++、Rust编写程序有相对更高的性能,可以写成库供其他语言的UI应用调用.  </li><li>微软目前还是在基于XAML的桌面应用开发上发力,MAUI和WinUI3是微软主推的,在win11以及将来都是windows桌面开发重点,Avalonia也很不错</li><li><a href="https://www.lazarus-ide.org/">Lazarus</a>可以用于C++桌面应用的快速开发,此外还有C++ builder社区版<a href="https://blog.ismisv.com/2019/05/try-cpp-builder-ce/">试用C++ Builder社区版 </a></li><li>Flutter,KMP(包括jetpack compose)以及SwiftUI的写法类似(移动端应用写法),不同与xaml也不是同于new对象. 它们都是从移动端技术向跨平台应用发展折射到桌面开发的,一些技术栈和思想和做Qt、Winform的人可能不太相同(Web技术也是).</li></ol><p>这里我从WPF入手学一点基础,由此可以向WinUI3,Uno,MAUI以及Avalonia桌面应用开发发展(后三者是跨平台框架).</p><span id="more"></span><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>对于桌面应用框架,我有几点个人的偏好和思考.</p><ol><li>虽然说对于有经验的程序员并不会因为编程语言问题而不去学习某个框架,毕竟桌面应用是一个domain的知识,这独立于保存语言.但实际这依然会对应用的生态影响,比如Dart语言使用人数相对较少,势必会对第三方库的生态造成影响,使得许多用户不敢深度使用,大企业就更别说了. 相比来说,React Native和Electron就完全可以借用web技术和生态,用户增长趋势稳定</li><li>UI的写法虽然各个框架不同,但完全都能理解并且不会对编写程序有过多影响。目前UI的写法有类似<strong>QtWidgets和Winforms直接new对象</strong>,相对更原始,但控制性还挺高. 还有Flutter,Jetpack Compose,<a href="https://www.jetbrains.com/kotlin-multiplatform/">Kotlin Multiplatform and Compose Multiplatform</a>这种是通过代码但是是<strong>嵌套声明式</strong>的写法,还有微软超爱的<strong>XAML写法和Qt Qml声明式</strong>写法,此外有web开发的大手,通过嵌入浏览器内核的<strong>html,css写法</strong>. 这些写法各有优劣,理性看待便是.</li><li>在渲染性能上,除了electron之外,其他框架大多数时候都没有什么太大的性能问题.而且electron只是使用web技术做桌面应用的一个例子罢了,此外还有<a href="https://tauri.app/">Tauri 2.0 | Tauri</a>,<a href="https://github.com/chromiumembedded/cef">chromiumembedded/cef: Chromium Embedded Framework (CEF). </a>,<a href="https://sciter.com/">sciter – Multiplatform HTML/CSS/JavaScript UI Engine for Desktop and Mobile Application</a>,<a href="https://pywebview.flowrl.com/">pywebview</a>等等此外在跨平台图形绘制上,有像Flutter通过统一的绘制引擎保证一致性的,有在不同操作系统上使用不同绘制库实现的.</li><li>跨平台框架是个伪问题,或者说这个问题不是从解决实际问题出发的。许多时候都要认真思考一下跨平台应用的开发成本</li><li>鉴于许多桌面应用其实基本主流用户都在windows上,而windows原生应用,比如微软的技术就有非常多桌面框架(Winforms,WPF,UWP,WinUI),但许多开发者都担心微软又会立马抛弃,目前MAUI,Blazor,WinUI3这些技术是微软主推的,此外社区也有<a href="https://platform.uno/">Uno</a>和<a href="https://docs.avaloniaui.net/zh-Hans/docs/basics/user-interface/introduction-to-xaml">Avalonia </a>跨平台技术. 这也导致微软没有构建起良好的社区氛围,大公司的<a href="https://tech.creaders.net/2012/07/04/1166968.html">官僚气息</a>、决策的朝令夕改使得开发者并不好受。希望目前微软能在技术上稳定下来<a href="https://dotnet.microsoft.com/en-us/learn">Learning center | .NET</a>,构建好技术文档和社区资源吸引开发者.</li></ol><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ol><li><a href="https://github.com/sudhakar3697/awesome-electron-alternatives">sudhakar3697/awesome-electron-alternatives: A curated list of awesome Electron alternatives.</a></li><li><a href="https://github.com/robloo/PublicDocs/blob/master/XAMLFrameworkComparison.md">PublicDocs/XAMLFrameworkComparison.md at master · robloo/PublicDocs</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在桌面开发上,我已经尝试过许多框架和组合,比如Qt/PyQt,Electron,Flutter,Winform. 如今跨平台风气正盛,包括MAUI,Flutter以及Kotlin MultiPlatform(KMP)等等都风头正盛. 但我的理解是作为个人开发,很多时候并不需要写跨平台的桌面应用,不如写原生的.&lt;/p&gt;
&lt;p&gt; 目前我的理解是:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要仔细思考产品跨平台的必要性,跨平台并不是free launch. &lt;/li&gt;
&lt;li&gt;C++的桌面程序框架也有很多,但许多人因为语言问题放弃了,着实可惜.由于c++的高性能和gl图形库诞生许多简单的GUI,比如&lt;a href=&quot;https://github.com/TimoSalomaki/awesome-dear-imgui&quot;&gt;awesome-dear-imgui&lt;/a&gt;和&lt;a href=&quot;https://www.raylib.com/&quot;&gt;raylib&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Qt框架不只是GUI,拿他跟其他UI库比较不公平.它提供了包括网络库在内的功能,而这本身就是C++相比其他现代语言在标准库和生态的差距. 此外Qt还有结合JS的QML,QWebEngine一堆技术.&lt;/li&gt;
&lt;li&gt;使用Web技术开发桌面应用的开发体验仍然有待提升,目前React Native发展正盛,也是得益于前端的蓬勃生态.&lt;/li&gt;
&lt;li&gt;c++、Rust编写程序有相对更高的性能,可以写成库供其他语言的UI应用调用.  &lt;/li&gt;
&lt;li&gt;微软目前还是在基于XAML的桌面应用开发上发力,MAUI和WinUI3是微软主推的,在win11以及将来都是windows桌面开发重点,Avalonia也很不错&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.lazarus-ide.org/&quot;&gt;Lazarus&lt;/a&gt;可以用于C++桌面应用的快速开发,此外还有C++ builder社区版&lt;a href=&quot;https://blog.ismisv.com/2019/05/try-cpp-builder-ce/&quot;&gt;试用C++ Builder社区版 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Flutter,KMP(包括jetpack compose)以及SwiftUI的写法类似(移动端应用写法),不同与xaml也不是同于new对象. 它们都是从移动端技术向跨平台应用发展折射到桌面开发的,一些技术栈和思想和做Qt、Winform的人可能不太相同(Web技术也是).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里我从WPF入手学一点基础,由此可以向WinUI3,Uno,MAUI以及Avalonia桌面应用开发发展(后三者是跨平台框架).&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>前端运行时、打包与构建简单介绍</title>
    <link href="https://www.sekyoro.top/2025/01/09/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E4%B8%8E%E6%89%93%E5%8C%85%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.sekyoro.top/2025/01/09/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E4%B8%8E%E6%89%93%E5%8C%85%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</id>
    <published>2025-01-09T07:49:05.000Z</published>
    <updated>2025-01-09T14:57:52.654Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>对比前两年,今年前端的工具进展相比可能确实慢了一些. 但还是有许多新的工具以及一些常用工具的新版本. 这里简单介绍一些在开发中关于js一些工具使用.</p><span id="more"></span><h2 id="JS三大运行时"><a href="#JS三大运行时" class="headerlink" title="JS三大运行时"></a>JS三大运行时</h2><p>js可以操作浏览器DOM以及浏览器提供的Web API等,这些都是在强大的浏览器下的功能. 除此之外还有最常用的node和较新的bun,Deno.</p><p>Deno和Bun的优点在于速度和对一些新特性,比如对typescript的支持更快.</p><p>此外Bun还致力于打造整个开发生态而不只是一个运行时。</p><h3 id="Deno"><a href="#Deno" class="headerlink" title="Deno"></a>Deno</h3><p>最近deno迎来2.0</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greet(<span class="string">&quot;world&quot;</span>));</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deno main.ts</span><br></pre></td></tr></table></figure><h3 id="Bun"><a href="#Bun" class="headerlink" title="Bun"></a>Bun</h3><p>最近bun迎来1.1. 它提供一整套js和ts的开发工具,使用Bun作为运行时</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bun run index.tsx </span><br></pre></td></tr></table></figure><h2 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h2><p>npm,yarn以及pnpm都是常用的包管理器,除此之外,还有bun install以及包管理器的管理器corepack. bun install是bun提供的包管理器,而Corepack是node官方做的包括npm,yarn,pnpm的管理器,目前新版的node是自带corepack并且应该是未来的新使用方式</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">corepack <span class="built_in">enable</span></span><br><span class="line">corepack use yarn@latest</span><br></pre></td></tr></table></figure><p>同时会在<code>package.json</code>中写入对应<code>`packageManager</code>字段</p><h2 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h2><p>打包工具(Bundler)主要目的是<code>compiles small pieces of code into something larger and more complex</code>,包括js,css以及图像等静态文件.</p><blockquote><p>打包工具的主要目标是将 JavaScript、CSS 等文件打包在一起，打包后的文件可以在浏览器、Node.js 等环境中使用。当 Bundler 处理 Web 应用时，它会构建一个依赖关系图，其中包含应用需要的各个模块，然后将所有模块打包成一个或多个 bundle</p></blockquote><h3 id="esbuild"><a href="#esbuild" class="headerlink" title="esbuild"></a>esbuild</h3><p><img data-src="https://s2.loli.net/2025/01/09/Rf7M9ecZYbOSyTC.png" alt="image-20250109201151034"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-exact --save-dev esbuild</span><br><span class="line">.\node_modules\.bin\esbuild --version</span><br><span class="line">.\node_modules\.bin\esbuild app.jsx --bundle --outfile=out.js <span class="comment"># 命令行</span></span><br></pre></td></tr></table></figure><p>esbuild优势是速度快,本身支持js,css,ts,jsx</p><p>通过配置文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;esbuild app.jsx --bundle --outfile=out.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为浏览器js打包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esbuild app.jsx --bundle --minify --sourcemap --target=chrome58,firefox57,safari11,edge16</span><br></pre></td></tr></table></figure><p>默认情况下，打包器为浏览器输出代码，因此不需要额外的配置即可开始。对于开发构建，使用——sourcemap来启用源映射，而对于生产构建，使用——minify来启用最小化。</p><h3 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev parcel</span><br></pre></td></tr></table></figure><p>类似esbuild,但功能更多,比如同时支持commonjs和ES模块的输出.</p><h3 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h3><p>rollup是将小的代码片段编译成更大、更复杂的代码，例如库或应用程序。它使用 JavaScript 的 ES6 版本中包含的新标准化代码模块格式。</p><p><strong>它适合ES模块编写的js打包</strong></p><p>Vite目前使用的打包工具,但马上将被换为RollDown. rollup突出一个使用简洁方便</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rollup index.js -o bundle.js -f cjs</span><br></pre></td></tr></table></figure><p>此外也可以配置文件<code>rollup.config.mjs</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// rollup.config.mjs</span><br><span class="line">// ---cut-start---</span><br><span class="line">/** @type &#123;import(&#x27;rollup&#x27;).RollupOptions&#125; */</span><br><span class="line">// ---cut-end---</span><br><span class="line">export default &#123;</span><br><span class="line">input: &#x27;src/main.js&#x27;,</span><br><span class="line">output: &#123;</span><br><span class="line">file: &#x27;bundle.js&#x27;,</span><br><span class="line">format: &#x27;cjs&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rollup -c</span><br></pre></td></tr></table></figure><h3 id="RollDown"><a href="#RollDown" class="headerlink" title="RollDown"></a>RollDown</h3><p><a href="https://rolldown.rs/guide/">Introduction | Rolldown</a></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -D rolldown</span><br><span class="line">.<span class="regexp">/node_modules/</span>.bin<span class="regexp">/rolldown src/m</span>ain.js --<span class="keyword">file</span> bundle.js</span><br></pre></td></tr></table></figure><p>看起来跟esbuild,rollup没有很大差异.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;my-rolldown-project&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;rolldown src/main.js --file bundle.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;rolldown&quot;</span>: <span class="string">&quot;^1.0.0-beta.1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;my-rolldown-project&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;rolldown -c&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;rolldown&quot;</span>: <span class="string">&quot;^1.0.0-beta.1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Rspack"><a href="#Rspack" class="headerlink" title="Rspack"></a>Rspack</h3><p>更新的工具,包含RsBuild,Rspress等生态.</p><h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h2><p>相对来说构建工具的包含概念更大,让更类似于一个项目启动器,可以负责整个项目开发各个阶段的整合,一些具体的处理可能需要使用一些打包、混淆压缩以及热更新.</p><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>webpack有自带的许多loader<a href="https://www.webpackjs.com/concepts/loaders/">loader</a>以及插件<a href="https://www.webpackjs.com/concepts/plugins/">plugin </a>,功能强大,但配置相对复杂.目前使用Vite更多.</p><p><code>webpack.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;main.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用loader,loader 用于对模块的源代码进行转换。loader 可以使你在 <code>import</code> 或 “load(加载)” 模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的得力方式。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript 或将内联图像转换为 data URL。loader 甚至允许直接在 JavaScript 模块中 <code>import</code> CSS 文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev css-loader ts-loade</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, use: <span class="string">&#x27;css-loader&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>, use: <span class="string">&#x27;ts-loader&#x27;</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h3><p>Vite开箱即用,支持许多预设</p><p>插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm add -D @vitejs/plugin-legacy</span><br><span class="line"><span class="keyword">import</span> legacy <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-legacy&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    legacy(&#123;</span><br><span class="line">      <span class="attr">targets</span>: [<span class="string">&#x27;defaults&#x27;</span>, <span class="string">&#x27;not IE 11&#x27;</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Rsbuild"><a href="#Rsbuild" class="headerlink" title="Rsbuild"></a>Rsbuild</h3><p><img data-src="https://assets.rspack.dev/rsbuild/assets/rsbuild-1-0-build-tools.png" alt="img"></p><p>可以将 Rsbuild 理解为一个现代化的 Create React App 或 Vue CLI，它与这些工具的主要区别在于：</p><ul><li>底层的打包工具由 Webpack 替换为 Rspack，提供 5 ~ 10 倍的构建性能。</li><li>与前端 UI 框架解耦，并通过 <a href="https://rsbuild.dev/zh/plugins/list/index">插件</a> 来支持所有 UI 框架，包括 React、Vue、Svelte、Solid 等。</li><li>提供更好的扩展性，你可以通过 <a href="https://rsbuild.dev/zh/config/index">配置</a>、 <a href="https://rsbuild.dev/zh/plugins/dev/index">插件 API</a> 和 <a href="https://rsbuild.dev/zh/api/start/index">JavaScript API</a> 来灵活地扩展 Rsbuild。</li></ul><h3 id="Farm"><a href="#Farm" class="headerlink" title="Farm"></a>Farm</h3><p>引用官方的话,Farm类似Webpack和Vite但更快. farm <code>resolve, load, transform</code> 所有 <code>asset(js/jsx/ts/tsx、css/sass/less、html、静态资源、json 等)</code>，并将它们打包成一系列<code>可部署文件</code>。 Farm 是一个速度极快的构建工具，可帮助您构建更快的 <code>web/nodejs</code> 应用程序。</p><h2 id="转码器"><a href="#转码器" class="headerlink" title="转码器"></a>转码器</h2><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>babel用于ES2015+以上的ECMAScripit在较低版本的浏览器上兼容,此外也支持jsx和es模块转换</p><p>babel配置文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;targets&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;edge&quot;</span>: <span class="string">&quot;17&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;firefox&quot;</span>: <span class="string">&quot;60&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;chrome&quot;</span>: <span class="string">&quot;67&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;safari&quot;</span>: <span class="string">&quot;11.1&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;useBuiltIns&quot;</span>: <span class="string">&quot;usage&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;corejs&quot;</span>: <span class="string">&quot;3.6.5&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SWC"><a href="#SWC" class="headerlink" title="SWC"></a>SWC</h3><p>Vite中所使用的代码转换器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pnpm add -D @swc/cli @swc/core</span><br><span class="line">npx swc ./file.js</span><br></pre></td></tr></table></figure><p>转译工具和构建工具的使用都不复杂,swc也支持配置支持浏览器,转换模块,压缩. 配置<code>.swcrc</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;$schema&quot;: &quot;https://swc.nodejs.cn/schema.json&quot;,</span><br><span class="line">  &quot;module&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;commonjs&quot;,</span><br><span class="line"> </span><br><span class="line">    // These are defaults.</span><br><span class="line">    &quot;strict&quot;: false,</span><br><span class="line">    &quot;strictMode&quot;: true,</span><br><span class="line">    &quot;lazy&quot;: false,</span><br><span class="line">    &quot;noInterop&quot;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Oxc"><a href="#Oxc" class="headerlink" title="Oxc"></a>Oxc</h3><p>与Rolldown类似,属于Vue,Vite生态圈. 它本身是一个提供了许多工具的总成,包括lint,parser,transformer和resolver</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">oxlint -c</span> </span><br></pre></td></tr></table></figure><p>此外值得一提的是考虑使用<a href="https://biomejs.dev/guides/getting-started/">Biome</a>作为prettier的替代工具,因为前者速度更快.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;对比前两年,今年前端的工具进展相比可能确实慢了一些. 但还是有许多新的工具以及一些常用工具的新版本. 这里简单介绍一些在开发中关于js一些工具使用.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>

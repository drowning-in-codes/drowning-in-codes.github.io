<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sekyoro的博客小屋</title>
  
  
  <link href="https://www.sekyoro.top/atom.xml" rel="self"/>
  
  <link href="https://www.sekyoro.top/"/>
  <updated>2024-11-04T14:31:40.336Z</updated>
  <id>https://www.sekyoro.top/</id>
  
  <author>
    <name>Sekyoro</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文生图相关模型最新进展小结</title>
    <link href="https://www.sekyoro.top/2024/11/03/%E6%96%87%E7%94%9F%E5%9B%BE%E7%9B%B8%E5%85%B3%E6%A8%A1%E5%9E%8B%E6%9C%80%E6%96%B0%E8%BF%9B%E5%B1%95%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.sekyoro.top/2024/11/03/%E6%96%87%E7%94%9F%E5%9B%BE%E7%9B%B8%E5%85%B3%E6%A8%A1%E5%9E%8B%E6%9C%80%E6%96%B0%E8%BF%9B%E5%B1%95%E5%B0%8F%E7%BB%93/</id>
    <published>2024-11-03T11:47:36.000Z</published>
    <updated>2024-11-04T14:31:40.336Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在较早的VAE和GAN时代,通过图形生成模型,可能出现的模式坍塌(个人理解就是生成图像多样性不足),在之后的diffusion时代(包括现在),有了多模态的加入,通过文本、深度图以及骨骼图(e.g.ControlNet)控制图像生成有了更高的自由度和创造性.此外有了类似LoRA,IP-Adapter等等技术提供了更好的微调方式用于在更新模型权重保持良好的风格迁移(比如原本模型训练集中没有的人物,在微调时增加新人物训练能有良好表现)或人物一致性(不同的角色不至于长得一样)</p><p>而在最近有了更多在一些较大模型(stable diffusionv3,novelai,sdxl等)上微调的模型,它们更加专注于某种画风。此外本文尝试总结目前文生图、艺术图片等生成式AI应用,最后从图片展望生成式视频创作。相对于论文、原理，这里更注重模型与应用。</p><span id="more"></span><p>之前我介绍过生成式模型与相关技术,这里不作过多介绍。</p><h2 id="模型与技术的进展"><a href="#模型与技术的进展" class="headerlink" title="模型与技术的进展"></a>模型与技术的进展</h2><p>首先,我们需要一个较大的模型,这个模型在较大的数据集上经过充分训练,已经有了相应的”知识”.作为普通用户一般不去训练这样的模型,直接下载即可<a href="https://huggingface.co/models?pipeline_tag=text-to-image&amp;sort=downloads">Models - Hugging Face</a>. 这类模型的技术从较早的VAE,flow-based,GAN到目前处于统治地位的diffusion. 可以说目前依然是diffusion的天下,基于diffusion的常用模型包括stability(或者说compvis,stability公司争议很大)下的stable diffusion,目前到了SDXL和v3.5,<a href="https://novelai.net/">NovelAI - The AI Storyteller</a>下的<a href="https://docs.novelai.net/image/models.html#novelai-diffusion-anime-v3">NovelAI Diffusion Anime V3</a>(之前<a href="https://rentry.org/sdg_FAQ">泄露过novelai早期模型</a>),但novelai本身并没有开源模型,此外还有midjourney等,但这些大都需要付费而且定制化不高大概率也不能<a href="https://zh.wikipedia.org/zh-hans/NSFW">NSFW</a>.</p><p>所以,从目前看来开源的底模(也就是上面所说的diffusion较大的模型)看起来只有stability下的对用户友好了,因为开源,社区也很给力,有了很多相关工具.</p><p>目前来看<a href="https://huggingface.co/models?pipeline_tag=text-to-image&amp;sort=downloads">Models - Hugging Face</a>,<a href="https://civitai.com/">Civitai: The Home of Open-Source Generative AI</a>以及<a href="https://rentry.co/stablediffusion">Stable Diffusion Rentries + Simple Installation Tutorial!</a>是较好的模型下载和学习资源. </p><p>此外也有<a href="https://www.reddit.com/r/StableDiffusion/wiki/index/">Reddit</a>社区,x上的相关社区以及一些相关discord作为被动看看新闻和高手们在干什么.</p><p>在两三年前,用的比较多的是stable diffusionv1.5(目前被runway删了,但网上还是有很多备份),后来有了sdxl,sdv3以及现在的sdv3.5</p><p><img data-src="https://s2.loli.net/2024/11/04/5WEsn1PwASLDbce.png" alt="image-20241104213845495"></p><p>而目前最新的就是3.5版本和sdxl,往往我们都需要这些底模. 至于这些底模有什么大差别,我认为主要还是在数据集和模型参数量上,当然如果模型太大,本地可能也不好运行.所以还是量力而行.</p><p>在这些底模基础上,通过微调技术,衍生出了一大堆社区的模型.最早的微调模型基本都是基于sd1.5或早期泄露的nai</p><ul><li><a href="https://civitai.com/models/66/anything-v3">Anything V3 - fp16 | Stable Diffusion Checkpoint | Civitai</a></li><li><a href="https://huggingface.co/gsdf/Counterfeit-V2.0">gsdf/Counterfeit-V2.0 · Hugging Face</a></li><li><a href="https://huggingface.co/hakurei/waifu-diffusion-v1-4">hakurei/waifu-diffusion-v1-4 · Hugging Face</a></li><li><a href="https://civitai.com/models/4201/realistic-vision-v13">Realistic Vision V6.0 B1 - V5.1 Hyper (VAE) | Stable Diffusion Checkpoint | Civitai</a></li></ul><p>可以看到还是专注生成人物的居多</p><p>这里挑选几个目前最火的,大多基于SDXL,除了Flux之外都是社区基于Stable diffusion的开源模型.</p><h3 id="Animagine3"><a href="#Animagine3" class="headerlink" title="Animagine3"></a>Animagine3</h3><p><a href="https://huggingface.co/cagliostrolab/animagine-xl-3.0">cagliostrolab/animagine-xl-3.0 · Hugging Face</a></p><p>基于SDXL</p><h3 id="Pony"><a href="#Pony" class="headerlink" title="Pony"></a>Pony</h3><p><a href="https://civitai.com/models/257749?modelVersionId=290640">Pony Diffusion V6 XL - V6 (start with this one) | Stable Diffusion Checkpoint | Civitai</a></p><p><a href="https://civitai.com/models/288584?modelVersionId=324619">AutismMix SDXL - AutismMix_pony | Stable Diffusion Checkpoint | Civitai</a></p><h3 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h3><p><a href="https://github.com/black-forest-labs/flux">black-forest-labs/flux: Official inference repo for FLUX.1 models</a></p><p>Stability出走人员新开的公司Black Forest Lab下的开源模型<a href="https://blackforestlabs.io/flux-1/">FLUX.1 - BlackForestLabs</a></p><h3 id="illustrious"><a href="#illustrious" class="headerlink" title="illustrious"></a>illustrious</h3><p><a href="https://civitai.com/models/795765/illustrious-xl">Illustrious-XL - v0.1 | Illustrious Checkpoint | Civitai</a></p><h4 id="Noob"><a href="#Noob" class="headerlink" title="Noob"></a>Noob</h4><p><a href="https://civitai.com/models/833294/noobai-xl-nai-xl">NoobAI-XL (NAI-XL) - Epsilon-pred 1.0-Version | Stable Diffusion XL Checkpoint | Civitai</a></p><p>一些评价<a href="https://tieba.baidu.com/p/9224285639#151086745100l">了解下大家都在用什么版本-百度贴吧</a></p><blockquote><p>对于普通爱好者<br>sd1.5仅有的用处是controlnet的inpaint扩图换衣，缺点是手脚画不好<br>pony是sdxl早期的威力加强版，主打涩图，社区分享r18/r18g最广泛，最优模型是tponynai3/wai等<br>sdxl近一个月推出illustrious力争无限接近nai3，比pony省略角色lora姿势lora画风lora可以单tag直接呼出省略调权步骤色彩污染等，最优模型是tillu3/wai/noobai等<br>flux是画三次元专精，因为模型是拿三维深度图训练的，缺点是显存占用极高</p></blockquote><p>可以常逛civita看看那些些不错的图片使用的什么模型.</p><h2 id="本地使用工具的进展"><a href="#本地使用工具的进展" class="headerlink" title="本地使用工具的进展"></a>本地使用工具的进展</h2><p>目前经常看见的几个本地使用UI工具.</p><ul><li><a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui">Automatic1111 WebUI</a>: (<a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui#installation-and-running">Install Guide</a>|<a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Features">Features Guide</a>) - Most feature-packed browser interface.✨✨✨✨✨</li><li><a href="https://github.com/lllyasviel/Fooocus">lllyasviel/Fooocus: Focus on prompting and generating</a></li><li><a href="https://github.com/lllyasviel/stable-diffusion-webui-forge">lllyasviel/stable-diffusion-webui-forge</a>✨✨✨✨</li><li><a href="https://github.com/comfyanonymous/ComfyUI">ComfyUI</a>: (<a href="https://github.com/comfyanonymous/ComfyUI?tab=readme-ov-file#installing">Installation</a>) - API and back-end with a graph/nodes interface.✨✨✨✨</li><li><a href="https://github.com/mcmonkeyprojects/SwarmUI">SwarmUI</a>: (<a href="https://github.com/mcmonkeyprojects/SwarmUI?tab=readme-ov-file#installing-on-windows">Installation</a>) - Super easy to install but still powerful UI, wraps and extends <a href="https://github.com/comfyanonymous/ComfyUI">ComfyUI</a>.</li></ul><p>此外还有<a href="https://github.com/invoke-ai/InvokeAI">invoke-ai/InvokeAI</a></p><h3 id="LoRA训练"><a href="#LoRA训练" class="headerlink" title="LoRA训练"></a>LoRA训练</h3><p>LoRA本身是一种微调方式,技术上修改了模型权重更新的方式,使得迁移更好. 可以下载一些脚本方便训练</p><ul><li><a href="https://github.com/Nerogar/OneTrainer">Nerogar/OneTrainer: OneTrainer is a one-stop solution for all your stable diffusion training needs.</a></li><li><a href="https://github.com/derrian-distro/LoRA_Easy_Training_Scripts">derrian-distro/LoRA_Easy_Training_Scripts: A UI made in Pyside6 to make training LoRA/LoCon and other LoRA type models in sd-scripts easy</a></li><li><a href="https://github.com/kohya-ss/sd-scripts">kohya-ss/sd-scripts</a></li><li><a href="https://github.com/bmaltais/kohya_ss">bmaltais/kohya_ss</a></li></ul><h2 id="现有应用"><a href="#现有应用" class="headerlink" title="现有应用"></a>现有应用</h2><p>目前文生图的应用虽然多,但是在商业上其实挺失败的(这也许收到了开源的影响),况且如果只是图片,也许还不够,如果结合视频、音频,那么对于辅助内容创作,面向目前广大视频博主还是很不错的.</p><p>如果只谈文生图或者图生图应用,目前大致有三种方向,第一种通过AI生成图片节省成本甚至通过AI噱头赚取更多关注度.具体来说,类似上面视频博主方案,只不过是图文博主,发短文搭配图片,发文章搭配图片,我也看见了有些学术会议的介绍图也使用了AI生成图. 这种方法商业上也是通过快速拿到还不错的搭配的图片吸引用户引流. 还有一些卖家,比如卖衣服的,不花请模特的钱,直接通过AI生成而且目前也能做到一个人物只换衣服面貌身材类似,相当于有了一个看起来很真实的人物的多种换衣图. 此外一些游戏开发者生成AI像素图,三视图等快速获得了游戏素材,比如之前的幻兽帕鲁. 上面这些方式都是通过AI辅助原本就有相关技能并以此赚钱的. 第二种更偏向兴趣,比如<a href="https://anifusion.ai/">Anifusion - AI Manga Generator</a>使用了画风更偏向漫画的模型搭配画图工作流,让画漫画更方便,但是专业的漫画家可能就不会去用了.</p><p>总的来说,目前商业应用前景依然不明朗,但是在一些小赛道还是不错的,其实不止AI图片,乃至AI相关的比如LLM也仍然面临这类问题.</p><h2 id="从图片到视频的展望"><a href="#从图片到视频的展望" class="headerlink" title="从图片到视频的展望"></a>从图片到视频的展望</h2><p>有了图片还是不够,如果有连续的、能体现更多故事的图片更好,那就是视频了. stability公司早已发布了<a href="https://stability.ai/stable-video">Stable Video</a>模型,runway也有了<a href="https://runwayml.com/research/gen-2">Runway Research | Gen-2: Generate novel videos with text, images or video clips</a>,OpenAI的Sora也是上了国内的大众热搜,鬼畜视频常客<a href="https://www.heygen.com/">HeyGen - AI Video Generator</a>和<a href="https://www.genmo.ai/">Genmo | Open Video Generation</a>.  但是目前仍然存在一些问题,一个是许多只允许用于调用而且还收费,通常免费生成的视频也就按秒算,由于视频生成难度更高,训练要求更高,相关开源社区发展不够. 另外目前技术也有进步空间,连贯性和人物一致性还需要进步,往往也缺少一些基本逻辑. 比如人物多手多腿,突然窜出一个莫名其妙的生物,脸部变形等等.</p><p>当然,到最后依然可能面临着商业化的问题. 但是考虑到目前互联网上有许多视频博主,他们应该是一个好的目标对象,结合AI生成的文字、音频、图片以及视频开发一个内容创作平台看起来还是有前景的.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://arxiv.org/abs/1906.00446">1906.00446] Generating Diverse High-Fidelity Images with VQ-VAE-2</a></li><li><a href="https://rentry.org/lora_train">LoRA Training Guide</a></li><li><a href="https://www.reddit.com/r/StableDiffusion/wiki/index/">r/StableDiffusion</a></li><li><a href="https://www.reddit.com/r/StableDiffusion/wiki/index/"><a href="https://huggingface.co/models?pipeline_tag=text-to-image&amp;sort=downloads">Models - Hugging Face</a></a></li><li><a href="https://stable-diffusion-book.vercel.app/">StableDiffusionBook - StableDiffusionBook</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在较早的VAE和GAN时代,通过图形生成模型,可能出现的模式坍塌(个人理解就是生成图像多样性不足),在之后的diffusion时代(包括现在),有了多模态的加入,通过文本、深度图以及骨骼图(e.g.ControlNet)控制图像生成有了更高的自由度和创造性.此外有了类似LoRA,IP-Adapter等等技术提供了更好的微调方式用于在更新模型权重保持良好的风格迁移(比如原本模型训练集中没有的人物,在微调时增加新人物训练能有良好表现)或人物一致性(不同的角色不至于长得一样)&lt;/p&gt;
&lt;p&gt;而在最近有了更多在一些较大模型(stable diffusionv3,novelai,sdxl等)上微调的模型,它们更加专注于某种画风。此外本文尝试总结目前文生图、艺术图片等生成式AI应用,最后从图片展望生成式视频创作。相对于论文、原理，这里更注重模型与应用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="deep learning" scheme="https://www.sekyoro.top/tags/deep-learning/"/>
    
    <category term="generative AI" scheme="https://www.sekyoro.top/tags/generative-AI/"/>
    
  </entry>
  
  <entry>
    <title>c++17中的新东西</title>
    <link href="https://www.sekyoro.top/2024/10/21/c-17%E4%B8%AD%E7%9A%84%E6%96%B0%E4%B8%9C%E8%A5%BF/"/>
    <id>https://www.sekyoro.top/2024/10/21/c-17%E4%B8%AD%E7%9A%84%E6%96%B0%E4%B8%9C%E8%A5%BF/</id>
    <published>2024-10-21T14:14:30.000Z</published>
    <updated>2024-11-02T13:30:38.436Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>c++的几个重点版本,c++11,c++17,c++20都是有必要去了解的. c++11是现代c++的基石,c++20有了更现代的东西,而c++17承前启后,多了许多现代c++常用但又常忽略的东西,这里简单介绍一些.<br><span id="more"></span></p><h2 id="std-string-view"><a href="#std-string-view" class="headerlink" title="std::string_view"></a>std::string_view</h2><p>std::string_view让我们像处理字符串一样处理字符序列，而不需要为它们分配内存空间。也就是说，std::string_view类型的对象只是引用一个外部的字符序列，而不需要持有它们。因此，一个字符串视图对象可以被看作字符串序列的引用</p><p>使用字符串视图的开销很小，速度却很快（以值传递一个string_view的开销总是很小）。然而，它也有一些潜在的危险，就和原生指针一样，<strong>在使用string_view时也必须由程序员自己来保证引用的字符串序列是有效的</strong></p><p>和 std::string相比，std::string_view对象有以下特点：</p><ul><li>底层的字符序列是只读的。没有操作可以修改底层的字符。你只能赋予一个新值、交换值、把视图缩小为字符序列的子序列。</li><li>字符序列不保证有空字符(‘\0’)终止。因此，字符串视图并不是一个空字符终止的字节流 </li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;c++的几个重点版本,c++11,c++17,c++20都是有必要去了解的. c++11是现代c++的基石,c++20有了更现代的东西,而c++17承前启后,多了许多现代c++常用但又常忽略的东西,这里简单介绍一些.&lt;br&gt;</summary>
    
    
    
    
    <category term="c++17" scheme="https://www.sekyoro.top/tags/c-17/"/>
    
  </entry>
  
  <entry>
    <title>现代C++中的异常处理</title>
    <link href="https://www.sekyoro.top/2024/10/16/%E7%8E%B0%E4%BB%A3C-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://www.sekyoro.top/2024/10/16/%E7%8E%B0%E4%BB%A3C-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2024-10-16T11:38:41.000Z</published>
    <updated>2024-10-16T16:01:26.284Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>处理异常和错误是现代编程中的重要一环,许多框架中都有一些API会返回错误以供处理. 在现代c++中,也有专门用于处理的方法<br><span id="more"></span></p><h2 id="old-style"><a href="#old-style" class="headerlink" title="old-style"></a>old-style</h2><p>程序错误通常分为两类：</p><ul><li>编程错误导致的逻辑错误。 例如，“索引超出范围”错误。</li><li>超出程序员控制的运行时错误。 例如，“网络服务不可用”错误。</li></ul><p>在 C 样式的编程和 COM 中，错误报告的管理方式是返回一个表示错误代码或特定函数的状态代码的值，或者设置一个全局变量，调用方可以在每次执行函数调用后选择性地检索该变量来查看是否报告了错误。</p><p>在c语言中使用errno来表示错误,当出现错误时,errno会被修改为对应错误代码,通过strerror转为对应错误信息.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;clocale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  errno = ENODATA;</span><br><span class="line">  <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;en_US.utf8&quot;</span>);</span><br><span class="line">  std::<span class="built_in">puts</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">  FILE *fp;</span><br><span class="line"></span><br><span class="line">  fp = <span class="built_in">fopen</span>(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Value of errno: %d\n&quot;</span>, errno);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error opening file: %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;Error printed by perror&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>常见的 <code>errno</code> 值</strong></p><ul><li><code>EPERM</code>：操作不允许</li><li><code>ENOENT</code>：没有这样的文件或目录</li><li><code>ESRCH</code>：没有这样的进程</li><li><code>EINTR</code>：中断的系统调用</li><li><code>EIO</code>：输入/输出错误</li></ul><p><strong>c++中的std::errc</strong></p><p>如果要自己创建业务上的错误码,可以考虑<code>enum</code>或者<code>enum class</code>,有更好的语义.c++标准库中有<code>std::errc</code>这个枚举类,起到错误码的作用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_STD_BEGIN</span><br><span class="line">_EXPORT_STD <span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">errc</span> &#123;</span> <span class="comment">// names for generic error codes</span></span><br><span class="line">    address_family_not_supported                       = <span class="number">102</span>, <span class="comment">// EAFNOSUPPORT</span></span><br><span class="line">    address_in_use                                     = <span class="number">100</span>, <span class="comment">// EADDRINUSE</span></span><br><span class="line">    address_not_available                              = <span class="number">101</span>, <span class="comment">// EADDRNOTAVAIL</span></span><br><span class="line">    already_connected                                  = <span class="number">113</span>, <span class="comment">// EISCONN</span></span><br><span class="line">    argument_list_too_long                             = <span class="number">7</span>, <span class="comment">// E2BIG</span></span><br><span class="line">    argument_out_of_domain                             = <span class="number">33</span>, <span class="comment">// EDOM</span></span><br><span class="line">    bad_address                                        = <span class="number">14</span>, <span class="comment">// EFAULT</span></span><br><span class="line"> ...</span><br><span class="line">_STD_END</span><br></pre></td></tr></table></figure><p><strong>c++中的std::error_code</strong></p><p>此外标准库中还有<code>std::error_code</code>和<code>std::error_category</code>,这样相当于提供了分类,error_category有不同名字用以区分,继承error_category,实现name和message方法.</p><p><img data-src="https://breese.github.io/assets/customize/error_code.png" alt="error_code"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> error_code = std::<span class="built_in">make_error_code</span>(std::errc::invalid_argument);</span><br><span class="line">std::cout&lt;&lt;error_code.<span class="built_in">message</span>()&lt;&lt;std::endl;</span><br><span class="line">std::cout&lt;&lt;error_code.<span class="built_in">value</span>()&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure><p>新式 C++ 中优先使用异常的原因如下：</p><ul><li>异常会强制调用代码识别并处理错误状态。 未经处理的异常会停止程序执行。</li><li>异常跳转到调用堆栈中可以处理错误的位置。 中间函数可以让异常传播。 这些函数不必与其他层协调。</li><li>引发异常后，异常堆栈展开机制将根据妥善定义的规则销毁范围内的所有对象。</li><li>异常可以在检测错误的代码与处理错误的代码之间实现明确的分离</li></ul><p>在c++中目前常用<code>try</code>,<code>catch</code>处理异常</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">3</span>);</span><br><span class="line">&#125; <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> std::invalid_argument&amp; e) &#123;</span><br><span class="line">std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常来通常来自<code>std::exception</code>或标准库中定义的派生类,也可以自己派生<code>std::exception</code>异常类.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyException</span> :</span> <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">what</span> <span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;C++ Exception&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span>(MyException&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MyException caught&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span>(std::exception&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//其他的错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果无法找到当前异常的匹配处理程序（或省略号 <strong><code>catch</code></strong> 处理程序），则调用预定义的 <code>terminate</code> 运行时函数.<code>erminate</code> 的默认操作是调用 <code>abort</code>。 如果你希望 <code>terminate</code> 在退出应用程序之前调用程序中的某些其他函数，则用被调用函数的名称作为其单个自变量调用 <code>set_terminate</code> 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &lt;cerrno&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;clocale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (c &gt; std::numeric_limits&lt;<span class="keyword">char</span>&gt;::<span class="built_in">max</span>()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Invalid argument&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">term_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;terminate handler called\n&quot;</span>;</span><br><span class="line">  std::<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::<span class="built_in">set_terminate</span>(term_func);</span><br><span class="line">  <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;en_US.utf8&quot;</span>);</span><br><span class="line">  std::<span class="built_in">puts</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">  FILE* fp;</span><br><span class="line">  fp = <span class="built_in">fopen</span>(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Value of errno: %d\n&quot;</span>, errno);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error opening file: %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;Error printed by perror&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">3</span>);</span><br><span class="line">  &#125; <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> std::invalid_argument&amp; e) &#123;</span><br><span class="line">    std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-optional"><a href="#std-optional" class="headerlink" title="std::optional"></a>std::optional</h2><p>类模板 <code>std::optional</code> 管理一个<strong>可选</strong>﻿的所含值，即既可以存在也可以不存在的值。</p><p>一种常见的 <code>optional</code> 使用情况是作为可能失败的函数的返回值。与如 std::pair<T, bool> 等其他手段相比，<code>optional</code> 可以很好地处理构造开销高昂的对象，并更加可读，因为它明确表达了意图。<code>optional&lt;T&gt;</code> 的任何实例在任意给定时间点要么<em>含值</em>，要么<em>不含值</em>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// optional 可用作可能失败的工厂的返回类型</span></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">create</span><span class="params">(<span class="keyword">bool</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Godzilla&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 能用 std::nullopt 创建任何（空的）std::optional</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">create2</span><span class="params">(<span class="keyword">bool</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? std::optional&lt;std::string&gt;&#123;<span class="string">&quot;Godzilla&quot;</span>&#125; : std::nullopt;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;create(false) 返回 &quot;</span></span><br><span class="line">              &lt;&lt; <span class="built_in">create</span>(<span class="literal">false</span>).<span class="built_in">value_or</span>(<span class="string">&quot;empty&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 返回 optional 的工厂函数可用作 while 和 if 的条件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> str = <span class="built_in">create2</span>(<span class="literal">true</span>))</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create2(true) 返回 &quot;</span> &lt;&lt; *str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> oDouble = std::<span class="built_in">make_optional</span>(<span class="number">3.0</span>);</span><br><span class="line"><span class="keyword">auto</span> oComplex = make_optional&lt;complex&lt;<span class="keyword">double</span>&gt;&gt;(<span class="number">3.0</span>, <span class="number">4.0</span>);</span><br></pre></td></tr></table></figure><p><code>std::in_place</code> 、 <code>std::in_place_type</code> 和 <code>std::in_place_index</code> 是消歧义标签，能传递给std::optional 、std::variant和std::any的构造函数，以指示应该原位构造对象，以及（对于后二者）要构造的对象的类型。</p><p>对应的类型/类型模板 <code>std::in_place_t</code> 、 <code>std::in_place_type_t</code> 和 <code>std::in_place_index_t</code> 能用于构造函数的参数列表中，以匹配有意的标签</p><h2 id="std-variant"><a href="#std-variant" class="headerlink" title="std::variant"></a>std::variant</h2><p>类模板 <code>std::variant</code> 表示一个类型安全的联合体（以下称“变体”）.一个 <code>std::variant</code> 的实例在任意时刻要么保有它的可选类型之一的值，要么在错误情况下无值</p><ul><li>std::in_place_type - 用于指定你想在 variant 里改变或者设定哪个类型</li><li>std::in_place_index - 用于指定你想改变或者设定的索引。类型从0开始枚举。<br>在 invariant std::variant<int, float, std::string> 中 - int 的索引是0，float的索引是1，string的索引是2。索引和 variant::index 方法的返回值是一样的</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;variant&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::variant&lt;<span class="keyword">int</span>, <span class="keyword">float</span>&gt; v, w;</span><br><span class="line">    std::variant&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; myv&#123;std::in_place_index&lt;<span class="number">0</span>&gt;,<span class="number">1</span>,std::in_place_index&lt;<span class="number">1</span>&gt;,<span class="number">1.2f</span>&#125;;</span><br><span class="line">    v = <span class="number">42</span>; <span class="comment">// v 含 int</span></span><br><span class="line">    <span class="keyword">int</span> i = std::get&lt;<span class="keyword">int</span>&gt;(v);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="number">42</span> == i); <span class="comment">// 成功</span></span><br><span class="line">    w = std::get&lt;<span class="keyword">int</span>&gt;(v);</span><br><span class="line">    w = std::get&lt;<span class="number">0</span>&gt;(v); <span class="comment">// 与前一行效果相同</span></span><br><span class="line">    w = v; <span class="comment">// 与前一行效果相同</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//  std::get&lt;double&gt;(v); // 错误：[int, float] 中无 double</span></span><br><span class="line"><span class="comment">//  std::get&lt;3&gt;(v);      // 错误：有效索引值为 0 与 1</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::get&lt;<span class="keyword">float</span>&gt;(w); <span class="comment">// w 含 int 而非 float：会抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> std::bad_variant_access&amp; ex)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line"> </span><br><span class="line">    <span class="function">std::variant&lt;std::string&gt; <span class="title">x</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 转换构造函数在无歧义时起作用</span></span><br><span class="line">    x = <span class="string">&quot;def&quot;</span>; <span class="comment">// 转换赋值在无歧义时亦起作用</span></span><br><span class="line"> </span><br><span class="line">    <span class="function">std::variant&lt;std::string, <span class="keyword">void</span> <span class="keyword">const</span>*&gt; <span class="title">y</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 传递 char const* 时转换成 void const*</span></span><br><span class="line">    <span class="built_in">assert</span>(std::holds_alternative&lt;<span class="keyword">void</span> <span class="keyword">const</span>*&gt;(y)); <span class="comment">// 成功</span></span><br><span class="line">    y = <span class="string">&quot;xyz&quot;</span>s;</span><br><span class="line">    <span class="built_in">assert</span>(std::holds_alternative&lt;std::string&gt;(y)); <span class="comment">// 成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-expected"><a href="#std-expected" class="headerlink" title="std::expected"></a>std::expected</h2><p>在c++23中实现,类模板 <code>std::expected</code> 提供表示两个值之一的方式：它要么表示一个 <code>T</code> 类型的<em>预期</em> ﻿值，要么表示一个 <code>E</code> 类型的<em>非预期</em> ﻿值。<code>std::expected</code> 决不会无值。</p><p>1) 主模板。在自身的存储中包含预期值或非预期值。不会进行动态分配。<br>2) void 部分特化。表示一个 void 类型的预期值或在自身的存储中包含非预期值。不会进行动态分配。</p><p>如果程序以引用类型、函数类型,或 std::unexpected的特化实例化 <code>expected</code>,那么程序非良构.另外,<code>T</code> 必须不是std::in_place_t或std::unexpect_t</p><p>非预期值是类模板 <code>std::unexpected</code> 代表一个 std::expected 中存储的非预期值。特别地，std::expected 具有接受 <code>std::unexpected</code> 为唯一实参的构造函数，创建含有非预期值的expected 对象。</p><p>用非对象类型、数组类型、<code>std::unexpected</code> 的特化或有 cv 限定的类型实例化 <code>unexpected</code> 的程序非良构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">parse_num</span><span class="params">(std::string_view&amp; str)</span>-&gt;std::expected&lt;<span class="keyword">int</span>, std::string&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::unexpected&lt;std::string&gt;(<span class="string">&quot;empty string&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">size_t</span> pos;</span><br><span class="line">  <span class="keyword">int</span> i = std::<span class="built_in">stoi</span>(std::<span class="built_in">string</span>(str), &amp;pos);</span><br><span class="line">  str.<span class="built_in">remove_prefix</span>(pos);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.runoob.com/cplusplus/cpp-exceptions-handling.html">C++ 异常处理 | 菜鸟教程 (runoob.com)</a></li><li><a href="https://breese.github.io/2017/05/12/customizing-error-codes.html">Customizing Error Codes (breese.github.io)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;处理异常和错误是现代编程中的重要一环,许多框架中都有一些API会返回错误以供处理. 在现代c++中,也有专门用于处理的方法&lt;br&gt;</summary>
    
    
    
    
    <category term="c++" scheme="https://www.sekyoro.top/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>现代化的浏览器可重用元素:web component</title>
    <link href="https://www.sekyoro.top/2024/10/15/%E7%8E%B0%E4%BB%A3%E5%8C%96%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%AF%E9%87%8D%E7%94%A8%E5%85%83%E7%B4%A0-web-component/"/>
    <id>https://www.sekyoro.top/2024/10/15/%E7%8E%B0%E4%BB%A3%E5%8C%96%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%AF%E9%87%8D%E7%94%A8%E5%85%83%E7%B4%A0-web-component/</id>
    <published>2024-10-15T11:29:00.000Z</published>
    <updated>2024-10-15T14:55:36.024Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Web components 是用于创建独立组件的一组标准:自定义 HTML 元素，它们具有自己的属性和方法，封装好的 DOM 和样式。</p><span id="more"></span><p>当我们写html/css时,如何想要创建自己的html元素或者进行代码复用,这就需要通过使用web components或者react/vue这种前端库.</p><p>Web Components 旨在解决这些问题 — 它由三项主要技术组成，它们可以一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。</p><ul><li><strong>Custom element（自定义元素）</strong>：一组 JavaScript API，允许你定义 custom elements 及其行为，然后可以在你的用户界面中按照需要使用它们。</li><li><strong>Shadow DOM（影子 DOM）</strong>：一组 JavaScript API，用于将封装的“影子”DOM 树附加到元素（与主文档 DOM 分开呈现）并控制其关联的功能。通过这种方式，你可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。</li><li><strong>HTML template（HTML 模板）：</strong> template和slot元素使你可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。</li></ul><p>实现 web component 的基本方法通常如下所示：</p><ol><li>创建一个类或函数来指定 web 组件的功能，如果使用类，请使用 ECMAScript 2015 的类语法 </li><li>使用 CustomElementRegistry.define()方法注册的新自定义元素，并向其传递要定义的元素名称、指定元素功能的类、以及可选的其所继承自的元素。</li><li>如果需要的话，使用Element.attachShadow()方法将一个 shadow DOM 附加到自定义元素上。使用通常的 DOM 方法向 shadow DOM 中添加子元素、事件监听器等等。</li><li>如果需要的话，使用template和slot 定义一个 HTML 模板。再次使用常规 DOM 方法克隆模板并将其附加到你的 shadow DOM 中。</li><li>在页面任何你喜欢的位置使用自定义元素，就像使用常规 HTML 元素那样。</li></ol><h2 id="自定义元素"><a href="#自定义元素" class="headerlink" title="自定义元素"></a>自定义元素</h2><p>有两种类型的自定义元素：</p><ul><li><strong>自定义内置元素</strong>（Customized built-in element）继承自标准的 HTML 元素，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLImageElement"><code>HTMLImageElement</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLParagraphElement"><code>HTMLParagraphElement</code></a>。它们的实现定义了标准元素的行为。</li><li><strong>独立自定义元素</strong>（Autonomous custom element）继承自 HTML 元素基类 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement"><code>HTMLElement</code></a>。你必须从头开始实现它们的行为。</li></ul><p>自定义元素作为一个类来实现，该类可以扩展 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement"><code>HTMLElement</code></a>（在独立元素的情况下）或者你想要定制的接口（在自定义内置元素的情况下）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> <span class="keyword">extends</span> <span class="title">HTMLParagraphElement</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此处编写元素功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数中可以添加一些元素的状态、注册事件监听器等. 此外有一些特别的回调方法，一旦自定义元素被注册，当页面中的代码以特定方式与自定义元素交互时，浏览器将调用类的某些方法。通过提供这些方法的实现，规范称之为<em>生命周期回调</em>，你可以运行代码来响应这些事件。</p><ul><li><code>connectedCallback()</code>：每当元素添加到文档中时调用。规范建议开发人员尽可能在此回调中实现自定义元素的设定，而不是在构造函数中实现。</li><li><code>disconnectedCallback()</code>：每当元素从文档中移除时调用。</li><li><code>adoptedCallback()</code>：每当元素被移动到新文档中时调用。</li><li><code>attributeChangedCallback()</code>：在属性更改、添加、移除或替换时调用。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">connectedCallback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;自定义元素添加至页面。&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">disconnectedCallback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;自定义元素从页面中移除。&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">adoptedCallback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;自定义元素移动至新页面。&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">attributeChangedCallback</span>(<span class="params">name, oldValue, newValue</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`属性 <span class="subst">$&#123;name&#125;</span> 已变更。`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customElements.define(<span class="string">&quot;word-count&quot;</span>, WordCount);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">word-count</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/10/15/TaoEQKDzCR8bV1j.png" alt="image-20241015204756114"></p><h3 id="注册元素"><a href="#注册元素" class="headerlink" title="注册元素"></a>注册元素</h3><p>要使自定义元素在页面中可用，请调用<code>Window.customElements</code> 的 define() 方法。</p><p>元素的名称。必须以小写字母开头，包含一个连字符，并符合规范中有效名称的定义中列出的一些其他规则</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">customElements.define(<span class="string">&quot;word-count&quot;</span>, WordCount); <span class="regexp">//</span> 独立自定义元素 &lt;word-count&gt; &lt;/word-count&gt;</span><br><span class="line">customElements.define(<span class="string">&quot;word-count&quot;</span>, WordCount,&#123;extends:<span class="string">&quot;p&quot;</span>&#125;); <span class="regexp">//</span>自定义内置元素 命名了要扩展的内置元素 &lt;p is=<span class="string">&quot;word-count&quot;</span>&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="使用元素"><a href="#使用元素" class="headerlink" title="使用元素"></a>使用元素</h3><p>定义并注册元素之后,就可以直接在html中使用了.</p><p>要使用<strong>自定义内置元素</strong>，请使用内置元素，但将自定义名称作为is 属性的值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">is</span>=<span class="string">&quot;word-count&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用<strong>独立自定义元素</strong>,，就像使用内置的 HTML 元素一样，使用自定义名称即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">word-count</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 元素的内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">word-count</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="相应属性变化"><a href="#相应属性变化" class="headerlink" title="相应属性变化"></a>相应属性变化</h3><p>与内置元素一样，自定义元素可以使用 HTML 属性来配置元素的行为。为了有效地使用属性，元素必须能够响应属性值的变化。为此，自定义元素需要将以下成员添加到实现自定义元素的类中：</p><ul><li>一个名为 <code>observedAttributes</code> 的静态属性。这必须是一个包含元素需要变更通知的所有属性名称的数组。</li><li><code>attributeChangedCallback()</code> 生命周期回调的实</li></ul><p><code>attributeChangedCallback()</code> 回调在列在元素的 <code>observedAttributes</code> 属性中的属性被添加、修改、移除或替换时调用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class WordCount extends HTMLElement &#123;</span><br><span class="line">  static observedAttributes = [&quot;size&quot;];</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line">  connectedCallback() &#123;</span><br><span class="line">    console.log(&quot;自定义元素添加至页面。&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  disconnectedCallback() &#123;</span><br><span class="line">    console.log(&quot;自定义元素从页面中移除。&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  adoptedCallback() &#123;</span><br><span class="line">    console.log(&quot;自定义元素移动至新页面。&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  attributeChangedCallback(name, oldValue, newValue) &#123;</span><br><span class="line">    console.log(`属性 $&#123;name&#125; 已变更。从$&#123;oldValue&#125;变为$&#123;newValue&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customElements.define(&quot;word-count&quot;, WordCount);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        word-count &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">word-count</span> <span class="attr">size</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用Shadow-DOM"><a href="#使用Shadow-DOM" class="headerlink" title="使用Shadow DOM"></a>使用Shadow DOM</h2><p><em>影子</em>(shadow) DOM 允许将隐藏的DOM 树附加到常规 DOM 树中的元素上——这个影子 DOM 始于一个影子根，在其之下可以用与普通 DOM 相同的方式附加任何元素</p><p><img data-src="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_components/Using_shadow_DOM/shadowdom.svg" alt="显示文档、影子根和影子宿主交互的图示的 SVG 版本"></p><ul><li><strong>影子宿主（Shadow host）</strong>: 影子 DOM 附加到的常规 DOM 节点。</li><li><strong>影子树（Shadow tree）</strong>: 影子 DOM 内部的 DOM 树。</li><li><strong>影子边界（Shadow boundary）</strong>: 影子 DOM 终止，常规 DOM 开始的地方。</li><li><strong>影子根（Shadow root）</strong>: 影子树的根节点。</li></ul><p>使用<code>attachShadow</code>给一个元素挂在影子DOM,出于安全考虑，一些元素不能使用 shadow DOM（例如<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a">``</a>），以及许多其他的元素。下面是一个<strong>可以</strong>挂载 shadow root 的元素列表：</p><p><img data-src="https://s2.loli.net/2024/10/15/14mv6JB29iEafI8.png" alt="image-20241015212842605"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pEle = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#para&quot;</span>);</span><br><span class="line">pEle.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">&quot;open&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><p>影子 DOM 中元素对页面中的 JavaScript 来说基本上是隐藏的</p><p>当 <code>mode</code> 设置为 <code>&quot;open&quot;</code> 时，页面中的 JavaScript 可以通过影子宿主的shadowRoot属性访问影子 DOM 的内部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shadow = pEle.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">&quot;open&quot;</span> &#125;);</span><br><span class="line">shadow.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;这是一个自定义元素&quot;</span>));</span><br><span class="line"><span class="keyword">const</span> spans = shadow.querySelectorAll(<span class="string">&quot;span&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> span <span class="keyword">of</span> spans) &#123;</span><br><span class="line">    span.textContent = span.textContent.toLocaleLowerCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面的 CSS 不会影响影子 DOM 内的节点,有两种方法可以改变影子DOM树中的样式.</p><ul><li>编程式，通过构建一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CSSStyleSheet"><code>CSSStyleSheet</code></a> 对象并将其附加到影子根。</li><li>声明式，通过在一个 template元素的声明中添加一个style元素</li></ul><p>影子 DOM 树中定义的样式局限在该树内，所以就像页面样式就像不会影响影子 DOM 中的元素一样，影子 DOM 样式也不会影响页面中其它元素的样式。</p><p><strong>编程式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">customElements.define(<span class="string">&quot;word-count&quot;</span>, WordCount);</span><br><span class="line"><span class="keyword">const</span> pEle = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#para&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> shadow = pEle.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">&quot;open&quot;</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> sheet = <span class="keyword">new</span> CSSStyleSheet();</span><br><span class="line">sheet.replaceSync(<span class="string">&quot;span &#123;color: red;&#125;&quot;</span>);</span><br><span class="line">shadow.adoptedStyleSheets = [sheet];    </span><br><span class="line"><span class="keyword">const</span> span = <span class="built_in">document</span>.createElement(<span class="string">&quot;span&quot;</span>);</span><br><span class="line">span.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;这是一个span元素&quot;</span>));</span><br><span class="line">shadow.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;这是一个自定义元素&quot;</span>));</span><br><span class="line">shadow.appendChild(span);</span><br><span class="line"><span class="keyword">const</span> spans = shadow.querySelectorAll(<span class="string">&quot;span&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> span <span class="keyword">of</span> spans) &#123;</span><br><span class="line">  span.textContent = span.textContent.toLocaleLowerCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>声明式</strong></p><p>在template中声明样式和元素,通过获取这个元素content,加到shadow dom中.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;wc&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>I&#x27;m in the shadow DOM<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;host&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wc = <span class="built_in">document</span>.getElementById(<span class="string">&quot;wc&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> host = <span class="built_in">document</span>.getElementById(<span class="string">&quot;host&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> other_shadow = host.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">&quot;open&quot;</span> &#125;);</span><br><span class="line">other_shadow.appendChild(wc.content);</span><br></pre></td></tr></table></figure><p>使用哪种方式取决于你的应用程序和个人喜好。</p><p>创建一个 <code>CSSStyleSheet</code> 并通过 <code>adoptedStyleSheets</code> 将其赋给影子根允许你创建单一样式表并将其与多个 DOM 树共享。例如，一个组件库可以创建单个样式表，然后将其与该库的所有自定义元素共享。浏览器将仅解析该样式表。此外，你可以对样式表进行动态更改，并将更改传播到使用表的所有组件。</p><p>而当希望是声明式的、需要较少的样式并且不需要在不同组件之间共享样式的时候，附加 <code>&lt;style&gt;</code> 元素的方法则非常适合。</p><p>如果没有影子 DOM 提供的封装，自定义元素就无法使用。因为只需在某个页面上运行一些 JavaScript 或 CSS，就有可能无意间破坏自定义元素的行为或布局。</p><h2 id="模板与插槽"><a href="#模板与插槽" class="headerlink" title="模板与插槽"></a>模板与插槽</h2><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>template很方便,搭配web component效果更好. 使用声明式搭配模板的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyParagraph</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="keyword">let</span> template = <span class="built_in">document</span>.getElementById(<span class="string">&quot;my-paragraph&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> templateContent = template.content;</span><br><span class="line">        <span class="keyword">const</span> shadowRoot = <span class="built_in">this</span>.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">&quot;open&quot;</span> &#125;);</span><br><span class="line">        shadowRoot.appendChild(templateContent.cloneNode(<span class="literal">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">connectedCallback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;自定义元素添加至页面。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">customElements.define(<span class="string">&quot;my-paragraph&quot;</span>, MyParagraph);</span><br></pre></td></tr></table></figure><p>首先定义一个元素,shadowRoot就是独立的自定义元素,然后添加template的内容,在html中声明template并使用元素. 使用cloneNode拷贝使得能创建多个自定义元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;my-paragraph&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">          <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#666</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">          &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">my-paragraph</span>&gt;</span><span class="tag">&lt;/<span class="name">my-paragraph</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-paragraph</span>&gt;</span><span class="tag">&lt;/<span class="name">my-paragraph</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过元素上的属性设置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-paragraph</span> <span class="attr">margin</span>=<span class="string">&quot;10&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-paragraph</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;my-paragraph&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">          <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#666</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">          &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过挂载到独立的自定义元素,并将template的内容放在shadowroot下即可,当属性改变时改变对应html原生元素样式,还可以监听事件等.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyParagraph</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> observedAttributes = [<span class="string">&quot;margin&quot;</span>];</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="keyword">let</span> template = <span class="built_in">document</span>.getElementById(<span class="string">&quot;my-paragraph&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> templateContent = template.content;</span><br><span class="line">    <span class="built_in">this</span>._shadowRoot = <span class="built_in">this</span>.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">&quot;open&quot;</span> &#125;);</span><br><span class="line">    <span class="built_in">this</span>._shadowRoot.appendChild(templateContent.cloneNode(<span class="literal">true</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">connectedCallback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;自定义元素添加至页面。&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">attributeChangedCallback</span>(<span class="params">name, oldValue, newValue</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`属性 <span class="subst">$&#123;name&#125;</span> 已变更。从<span class="subst">$&#123;oldValue&#125;</span>变为<span class="subst">$&#123;newValue&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&quot;margin&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>._shadowRoot.querySelector(<span class="string">&quot;p&quot;</span>).style.margin = newValue+<span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">customElements.define(<span class="string">&quot;my-paragraph&quot;</span>, MyParagraph);</span><br></pre></td></tr></table></figure><h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><p>可以使用slot元素通过声明式的语法在每个元素实例中显示不同的文本。插槽由其 <code>name</code> 属性标识，并且允许在模板中定义占位符，当在标记中使用该元素时，该占位符可以填充所需的任何 HTML 标记片段。</p><p>在template中声明slot,它可以有一个name属性,在自定义元素中加入想添加的元素,可以设置其slot属性,其与name相匹配,如果slot的name和元素的slot属性均不声明则进行填充.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;my-paragraph&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="number">#666</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">padding</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;slot&gt;&lt;/slot&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-paragraph</span> <span class="attr">margin</span>=<span class="string">&quot;10&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-paragraph</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-paragraph</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">slot</span>=<span class="string">&quot;text&quot;</span>&gt;</span>Hi this is default<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-paragraph</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hello-world</span> <span class="attr">name</span>=<span class="string">&quot;Craig&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">shadowroot</span>=<span class="string">&quot;closed&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;msgtext&quot;</span> <span class="attr">class</span>=<span class="string">&quot;hw-text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">slot</span>=<span class="string">&quot;msgtext&quot;</span>&gt;</span>Hello Default!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>This text will become part of the component.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">hello-world</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这相当于给了一定的灵活度.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_components">Web Component - Web API | MDN (mozilla.org)</a></li><li><a href="https://zh.javascript.info/web-components">Web components (javascript.info)</a></li><li><a href="https://www.ruanyifeng.com/blog/2019/08/web_components.html">Web Components 入门实例教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></li><li><a href="https://github.com/mdn/web-components-examples/tree/main/word-count-web-component">web-components-examples/word-count-web-component at main · mdn/web-components-examples (github.com)</a></li><li><a href="https://kinsta.com/blog/web-components/">A Complete Introduction to Web Components in 2024 (kinsta.com)</a></li><li><a href="https://www.robinwieruch.de/web-components-tutorial/">Web Components Tutorial for Beginners [2019] (robinwieruch.de)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;Web components 是用于创建独立组件的一组标准:自定义 HTML 元素，它们具有自己的属性和方法，封装好的 DOM 和样式。&lt;/p&gt;</summary>
    
    
    
    
    <category term="web" scheme="https://www.sekyoro.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>也许需要知道的c++概念</title>
    <link href="https://www.sekyoro.top/2024/10/09/%E4%B9%9F%E8%AE%B8%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84c-%E6%A6%82%E5%BF%B5/"/>
    <id>https://www.sekyoro.top/2024/10/09/%E4%B9%9F%E8%AE%B8%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84c-%E6%A6%82%E5%BF%B5/</id>
    <published>2024-10-09T15:34:28.000Z</published>
    <updated>2024-10-22T10:36:51.317Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在学习c++的过程中时不时冒出一些概念和常用语,但是却苦于不得其解,这里整理一下.主要来源是cppreference.<br><span id="more"></span></p><h2 id="三-五-零原则"><a href="#三-五-零原则" class="headerlink" title="三/五/零原则"></a>三/五/零原则</h2><h3 id="三原则"><a href="#三原则" class="headerlink" title="三原则"></a>三原则</h3><p>如果某个类需要用户定义的<strong>析构函数</strong>、用户定义的<strong>复制构造函数</strong>或用户定义的<strong>复制赋值运算符</strong>，那么它几乎肯定需要全部三个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLockGuard</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> mutext_type = T;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyLockGuard</span><span class="params">(T t_mutex)</span> : _MyMutex(t_mutex) &#123;</span> _MyMutex.<span class="built_in">lock</span>(); &#125;</span><br><span class="line">  <span class="built_in">MyLockGuard</span>(T&amp; _Mtx, std::<span class="keyword">adopt_lock_t</span>) <span class="keyword">noexcept</span> : _MyMutex(_Mtx) &#123;&#125;</span><br><span class="line">  <span class="built_in">MyLockGuard</span>(<span class="keyword">const</span> MyLockGuard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  MyLockGuard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyLockGuard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">MyLockGuard</span>() <span class="keyword">noexcept</span> &#123; _MyMutex.<span class="built_in">unlock</span>(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  T&amp; _MyMutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="五复制"><a href="#五复制" class="headerlink" title="五复制"></a>五复制</h3><p>因为用户定义（包括 = default 或 = delete）的<strong>析构函数</strong>、<strong>复制构造函数</strong>或<strong>复制赋值运算符</strong>，会阻止隐式定义移动构造函数和移动赋值运算符，所以<strong>任何想要移动语义的类必须声明全部五个特殊成员函数</strong></p><p>与三原则不同的是，<strong>不提供移动构造函数和移动赋值运算符通常不是错误</strong>，但会损失性能。</p><h3 id="零原则"><a href="#零原则" class="headerlink" title="零原则"></a>零原则</h3><p>有自定义析构函数、复制/移动构造函数或复制/移动赋值运算符的类应该专门处理所有权（这遵循单一责任原则）。其他类都不应该拥有自定义的析构函数、复制/移动构造函数或复制/移动赋值运算符</p><p>当有意<strong>将某个基类用于多态用途时，可能需要将它的析构函数声明为 public 和 virtual</strong>。由于<strong>这会阻止生成隐式移动（并弃用隐式复制）</strong>，因此必须将各特殊成员函数定义为 = default</p><h2 id="类模板实参推导-CTAD"><a href="#类模板实参推导-CTAD" class="headerlink" title="类模板实参推导(CTAD)"></a>类模板实参推导(CTAD)</h2><p>为了实例化一个类模板，需要知晓每个模板实参，但并非每个模板实参都必须指定。在下列语境中，<strong>编译器会从初始化式的类型推导缺失的模板实参</strong>：</p><ul><li>任意指定变量及变量模板的初始化的声明，其声明的类型是类模板（可有 cv 限定）</li></ul><h2 id="具名返回值优化"><a href="#具名返回值优化" class="headerlink" title="具名返回值优化"></a>具名返回值优化</h2><h2 id="ADL"><a href="#ADL" class="headerlink" title="ADL"></a>ADL</h2><h2 id="未定义行为"><a href="#未定义行为" class="headerlink" title="未定义行为"></a>未定义行为</h2><p><a href="https://zh.cppreference.com/w/cpp/language/rule_of_three#.E4.BA.94.E4.B9.8B.E6.B3.95.E5.88.99">More</a></p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ol><li><a href="https://en.cppreference.com/w/">cppreference.com</a></li><li><a href="https://www.learncpp.com/">Learn C++ – Skill up with our free tutorials (learncpp.com)</a></li><li><a href="https://github.com/fffaraz/awesome-cpp?tab=readme-ov-file#networking">fffaraz/awesome-cpp: A curated list of awesome C++ (or C) frameworks, libraries, resources, and shiny things. Inspired by awesome-… stuff. (github.com)</a></li><li><a href="https://c.biancheng.net/index.html">C语言中文网：C语言程序设计门户网站(入门教程、编程软件) (biancheng.net)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在学习c++的过程中时不时冒出一些概念和常用语,但是却苦于不得其解,这里整理一下.主要来源是cppreference.&lt;br&gt;</summary>
    
    
    
    
    <category term="c++" scheme="https://www.sekyoro.top/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>现代c++并发深入</title>
    <link href="https://www.sekyoro.top/2024/10/05/%E7%8E%B0%E4%BB%A3c-%E5%B9%B6%E5%8F%91%E6%B7%B1%E5%85%A5/"/>
    <id>https://www.sekyoro.top/2024/10/05/%E7%8E%B0%E4%BB%A3c-%E5%B9%B6%E5%8F%91%E6%B7%B1%E5%85%A5/</id>
    <published>2024-10-05T03:09:17.000Z</published>
    <updated>2024-10-15T11:58:54.006Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>更加深入的探讨并发.<br><span id="more"></span></p><h2 id="std-thread"><a href="#std-thread" class="headerlink" title="std::thread"></a>std::thread</h2><p>多线程的构造,使用std::thread时我们需要注意哪些?</p><h3 id="可以接受哪些参数"><a href="#可以接受哪些参数" class="headerlink" title="可以接受哪些参数"></a>可以接受哪些参数</h3><p>std::thread接受一个<strong>可调用对象</strong>和其参数.</p><p><strong><em>可调用\</em> *(Callable)*</strong> 类型是可应用INVOKE和INVOKE操作(例如用于 std::function、std::bind和 std::thread::thread)的类型.</p><p>如果满足下列条件,那么类型 <code>T</code> 是<em>可调用</em> <em>(Callable)</em> 的：</p><p>给定</p><ul><li><code>T</code> 类型的对象 <code>f</code></li><li>适合的实参类型列表 <code>ArgTypes</code></li><li>适合的返回类型 <code>R</code></li></ul><p>那么下列表达式必须合法：</p><div class="table-container"><table><thead><tr><th style="text-align:center">表达式</th><th style="text-align:center">要求</th></tr></thead><tbody><tr><td style="text-align:center">INVOKE<R>(f, [std::declval<ArgTypes>()…)</td><td style="text-align:center">该表达式在不求值语境中良构</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task_2</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123; std::<span class="built_in">puts</span>(<span class="string">&quot;operator()()const\n&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;; <span class="comment">// 函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">task_run</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// 函数</span></span><br><span class="line">X x;</span><br><span class="line">std::thread t&#123;&amp;X::task_run,&amp;x,<span class="number">3</span>&#125;; <span class="comment">//成员指针必须和对象一起使用，这是唯一标准用法，成员指针不可以转换到函数指针单独使用，即使是非静态成员函数没有使用任何数据成员.</span></span><br><span class="line">std::thread t&#123; std::<span class="built_in">bind</span>(&amp;X::task_run, &amp;x ,<span class="number">3</span>) &#125;;</span><br><span class="line">std::thread t&#123;[]&#123;std::<span class="built_in">puts</span>(<span class="string">&quot;Hi!&quot;</span>)&#125;&#125;; <span class="comment">// lambda函数</span></span><br><span class="line">Task_2 task_2&#123;&#125;;</span><br><span class="line">  std::thread t&#123;task_2&#125;;                     <span class="comment">// 左值 左值引用</span></span><br><span class="line">  std::thread ta&#123;Task_2&#123;&#125;&#125;;                  <span class="comment">// 临时对象</span></span><br><span class="line">  std::thread ta1&#123;[] &#123; std::<span class="built_in">puts</span>(<span class="string">&quot;Hi&quot;</span>); &#125;&#125;;  <span class="comment">// 临时对象</span></span><br><span class="line">  std::thread ta2&#123;h&#125;;  <span class="comment">// 左值</span></span><br></pre></td></tr></table></figure><p>重要的构造函数如下(MSVC实现)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Fn</span>, <span class="title">class</span>... _<span class="title">Args</span>, <span class="title">enable_if_t</span>&lt;</span>!is_same_v&lt;_Remove_cvref_t&lt;_Fn&gt;, thread&gt;, <span class="keyword">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    _NODISCARD_CTOR_THREAD <span class="keyword">explicit</span> <span class="built_in">thread</span>(_Fn&amp;&amp; _Fx, _Args&amp;&amp;... _Ax) &#123;</span><br><span class="line">        _Start(_STD forward&lt;_Fn&gt;(_Fx), _STD forward&lt;_Args&gt;(_Ax)...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Fn</span>, <span class="title">class</span>... _<span class="title">Args</span>&gt;</span></span><br><span class="line">    <span class="keyword">void</span> _Start(_Fn&amp;&amp; _Fx, _Args&amp;&amp;... _Ax) &#123;</span><br><span class="line">        <span class="keyword">using</span> _Tuple                 = tuple&lt;<span class="keyword">decay_t</span>&lt;_Fn&gt;, <span class="keyword">decay_t</span>&lt;_Args&gt;...&gt;;</span><br><span class="line">        <span class="keyword">auto</span> _Decay_copied           = _STD make_unique&lt;_Tuple&gt;(_STD forward&lt;_Fn&gt;(_Fx), _STD forward&lt;_Args&gt;(_Ax)...); </span><br><span class="line">        <span class="keyword">constexpr</span> <span class="keyword">auto</span> _Invoker_proc = _Get_invoke&lt;_Tuple&gt;(make_index_sequence&lt;<span class="number">1</span> + <span class="keyword">sizeof</span>...(_Args)&gt;&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        _Thr._Hnd =</span><br><span class="line">            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(_CSTD _beginthreadex(<span class="literal">nullptr</span>, <span class="number">0</span>, _Invoker_proc, _Decay_copied.<span class="built_in">get</span>(), <span class="number">0</span>, &amp;_Thr._Id));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_Thr._Hnd) &#123; <span class="comment">// ownership transferred to the thread</span></span><br><span class="line">            (<span class="keyword">void</span>) _Decay_copied.<span class="built_in">release</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// failed to start thread</span></span><br><span class="line">            _Thr._Id = <span class="number">0</span>;</span><br><span class="line">            _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先根据传入的可调用对象和参数使用转发引用,并确保传入的可调用对象去掉const/volatile引用后不等于std::thread. 如果传入左值,则为左值引用,调用_Start时传入左引用,否则传入右值. forward内部根据传入的是左值还是右值转为对应的引用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_EXPORT_STD <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="function">_NODISCARD _MSVC_INTRINSIC <span class="keyword">constexpr</span> _Ty&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">remove_reference_t</span>&lt;_Ty&gt;&amp; _Arg)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_EXPORT_STD <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="function">_NODISCARD _MSVC_INTRINSIC <span class="keyword">constexpr</span> _Ty&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; _Arg)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(!is_lvalue_reference_v&lt;_Ty&gt;, <span class="string">&quot;bad forward call&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在_Start中使用tuple保存函数和参数类型,使用make_unique得到指向_tuple的指针,使用传入的左值或者右值,比如如果参数如果传递一个左值num(即使是引用),会使用拷贝构造,如果传入一个右值会调用对应移动构造,</p><p>这里需要介绍一些左值和右值,以及模板编程中<code>template&lt;T&gt; void( std::remove_reference_t&lt;T&gt;&amp;)</code>与<code>template&lt;T&gt; void( std::remove_reference_t&lt;T&gt;&amp;&amp;)</code></p><p><a href="https://zh.cppreference.com/w/cpp/language/value_category">值类别 - cppreference.com</a></p><p>变量的类型是右值引用,由它的名字构成的表达式仍是左值表达式</p><p>转换到左值引用类型的转型表达式以及转换到函数的右值引用类型的转型表达式是左值;而转换到对象的右值引用类型的类型转换表达式是亡值,也就是右值,通过static_cast<T&&>这种方式返回了右值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tuple</span>, <span class="title">size_t</span>... _<span class="title">Indices</span>&gt;</span></span><br><span class="line">_NODISCARD <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> _Get_invoke(index_sequence&lt;_Indices...&gt;) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;_Invoke&lt;_Tuple, _Indices...&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tuple</span>, <span class="title">size_t</span>... _<span class="title">Indices</span>&gt;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> __stdcall _Invoke(<span class="keyword">void</span>* _RawVals) <span class="keyword">noexcept</span> <span class="comment">/* terminates */</span> &#123;</span><br><span class="line">    <span class="comment">// adapt invoke of user&#x27;s callable object to _beginthreadex&#x27;s thread procedure</span></span><br><span class="line">    <span class="keyword">const</span> unique_ptr&lt;_Tuple&gt; _FnVals(<span class="keyword">static_cast</span>&lt;_Tuple*&gt;(_RawVals));</span><br><span class="line">    _Tuple&amp; _Tup = *_FnVals.<span class="built_in">get</span>(); <span class="comment">// avoid ADL, handle incomplete types</span></span><br><span class="line">    <span class="function">_STD <span class="title">invoke</span><span class="params">(_STD move(_STD get&lt;_Indices&gt;(_Tup))...)</span></span>;</span><br><span class="line">    _Cnd_do_broadcast_at_thread_exit(); <span class="comment">// TRANSITION, ABI</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_beginthreadex</code>是windows上创建多线程的API,传入一个函数指针(也就是_Invoke)和指向一个tuple(包含函数和参数)的指针,在<code>_Invoke</code>中, _STD invoke(_STD move(_STD get<_Indices>(_Tup))…);`相当于根据可调用对象及其参数进行了调用</p><h3 id="传递的参数"><a href="#传递的参数" class="headerlink" title="传递的参数"></a>传递的参数</h3><p>根据源码实现,传递的参数会在thread对象中创建新值.</p><p><code>auto _Decay_copied = _STD make_unique&lt;_Tuple&gt;(_STD forward&lt;_Fn&gt;(_Fx), _STD forward&lt;_Args&gt;(_Ax)...);</code>创建,而_Tuple中的类型就是左值,<code>using _Tuple = tuple&lt;decay_t&lt;_Fn&gt;, decay_t&lt;_Args&gt;...&gt;;</code>,所以创建时会调用拷贝或移动构造创建新的值,而在实际调用对应可调用对象时,又会使用右值<code>_STD invoke(_STD move(_STD get&lt;_Indices&gt;(_Tup))...);</code>,这意味着,即使函数参数是引用,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span></span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> num&#123;<span class="number">5</span>&#125;;</span><br><span class="line">std::<span class="built_in">jthread</span>(f,num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的num首先会在std::jthread中创建变量,auto _Decay<em>copied    = std::make_unique&lt;_Tuple</em>&gt;(std::forward\<Fn>(__Fn),std::forward\<Args>(args)…);</p><p>使用invoke调用,std::invoke(std::move(std::get&lt;_Indices&gt;(_Tup))…);调用函数时使用了<code>std::move</code>作为右值传递,所以有<code>const int&amp; n = std::move(_num)</code>,如果不加上const会发生运行编译错误,此外这样也支持了只能移动的对象.</p><p>如何使得传递引用呢,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span></span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> num&#123;<span class="number">5</span>&#125;;</span><br><span class="line">std::<span class="built_in">jthread</span>(f,std::<span class="built_in">ref</span>(num));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现中将类型先经过 <code>decay</code> 处理,如果要传递引用,则必须用类包装,使用 <code>std::ref</code> 函数会返回一个包装对象</p><p>使用可调用对象的方式是利用<code>_Invoke</code>,其参数是上面的<code>_Decay_copied</code>,将其转为unique_ptr,再通过智能指针转为_Tup&amp;,然后使用 <code>std::invoke</code> 进行调用</p><p>std::ref是一个对象,但是使用时隐式转为引用,所以在构造时直接拷贝赋值std::reference_wrapper\<T>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> num2&#123;<span class="number">3</span>&#125;;</span><br><span class="line">  <span class="keyword">auto</span> n2 = std::<span class="built_in">ref</span>(num2);</span><br><span class="line">  <span class="keyword">auto</span> ttc = n2;</span><br><span class="line">  std::cout &lt;&lt; ttc &lt;&lt; std::endl;</span><br><span class="line">  ttc += <span class="number">12</span>;</span><br><span class="line">std::cout &lt;&lt; n2 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h3 id="join与detach"><a href="#join与detach" class="headerlink" title="join与detach"></a>join与detach</h3><p>detach() 是线程分离,线程对象放弃了线程资源的所有权,此时thread根本没有关联任何线程.调用 join() 是：“阻塞当前线程直至 *this 所标识的线程结束其执行”,线程对象都没有线程,就不需要阻塞了.</p><h3 id="不能拷贝构造-赋值与转移所有权"><a href="#不能拷贝构造-赋值与转移所有权" class="headerlink" title="不能拷贝构造/赋值与转移所有权"></a>不能拷贝构造/赋值与转移所有权</h3><p>传入可调用对象以及参数,构造 <code>std::thread</code> 对象,启动线程,而线程对象拥有了线程的所有权,线程是一种系统资源,所以可称作“<em>线程资源</em>”.</p><p>std::thread 不可复制.两个 std::thread 对象不可表示一个线程,std::thread 对线程资源是独占所有权.而<strong>移动</strong>操作可以将一个 <code>std::thread</code> 对象的线程资源所有权转移给另一个 <code>std::thread</code> 对象.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::thread t&#123; [] &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t.joinable() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 线程对象 t 当前关联了活跃线程 打印 1</span></span><br><span class="line">    <span class="built_in">std</span>::thread t2&#123; <span class="built_in">std</span>::move(t) &#125;;    <span class="comment">// 将 t 的线程资源的所有权移交给 t2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t.joinable() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 线程对象 t 当前没有关联活跃线程 打印 0</span></span><br><span class="line">    <span class="comment">//t.join(); // Error! t 没有线程资源</span></span><br><span class="line">    t2.join();  <span class="comment">// t2 当前持有线程资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::thread t&#123; [] &#123;&#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::thread rt = <span class="built_in">f</span>();</span><br><span class="line">    rt.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>return t</code> <em>重载决议</em><a href="https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/02使用线程.html#footnote1">[1]</a>选择到了<strong>移动构造</strong>,将 <code>t</code> 线程资源的所有权转移给函数调用 <code>f()</code> 返回的临时 <code>std::thread</code> 对象中,然后这个临时对象再用来初始化 <code>rt</code> ,临时对象是右值表达式,这里一样选择到<strong>移动构造</strong>,将临时对象的线程资源所有权移交给 <code>rt</code>.此时 <code>rt</code> 具有线程资源的所有权,由它调用 <code>join()</code> 正常析构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void f(std::thread t)&#123;</span><br><span class="line">    t.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    std::thread t&#123; [] &#123;&#125; &#125;;</span><br><span class="line">    f(std::move(t));</span><br><span class="line">    f(std::thread&#123; [] &#123;&#125; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::move</code> 将 t 转换为了一个右值表达式,初始化函数<code>f</code> 形参 <code>t</code>,选择到了移动构造转移线程资源的所有权,在函数中调用 <code>t.join()</code> 后正常析构.<code>std::thread&#123; [] &#123;&#125; &#125;</code> 构造了一个临时对象,本身就是右值表达式,初始化函数<code>f</code> 形参 <code>t</code>,移动构造转移线程资源的所有权到 <code>t</code>,<code>t.join()</code> 后正常析构.</p><h3 id="std-this-thread"><a href="#std-this-thread" class="headerlink" title="std::this_thread"></a>std::this_thread</h3><p><img data-src="https://s2.loli.net/2024/10/09/z68akUwnbqjS9KH.png" alt="image-20241009225729722"></p><ul><li><p>get_id</p></li><li><p>sleep_for</p></li><li><p>yield</p></li><li><p>sleep_until</p></li></ul><h2 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h2><p><strong>当某个表达式的求值写入某个内存位置,而另一求值读或修改同一内存位置时</strong>,称这些表达式冲突<strong>.</strong>拥有两个冲突的求值的程序就有数据竞争,除非</p><ul><li>两个求值都在同一线程上,或者在同一信号处理函数中执行,或</li><li>两个冲突的求值都是原子操作（见 std::atomic）,或</li><li>一个冲突的求值发生早于 另一个（见 std::memory_order）</li></ul><p>如果出现数据竞争,那么程序的行为未定义.</p><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><blockquote><p>互斥量用于保护多线程下的共享数据的读写</p></blockquote><p>互斥量（Mutex）,又常被称为互斥锁、互斥体（或者直接被称作“锁”）,是一种用来保护临界区的特殊对象,其相当于实现了一个公共的“<strong>标志位</strong>”.它可以处于锁定（locked）状态,也可以处于解锁（unlocked）状态：</p><ol><li>如果互斥量是锁定的,通常说某个特定的线程正持有这个锁.</li><li>如果没有线程持有这个互斥量,那么这个互斥量就处于解锁状态.</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::mutex m&#123;&#125;;</span><br><span class="line">m.<span class="built_in">lock</span>();</span><br><span class="line"><span class="comment">// do something...</span></span><br><span class="line">m.<span class="built_in">unlock</span>()</span><br></pre></td></tr></table></figure><p>如果多个线程中,其中一个线程在执行互斥区操作,其他线程执行到了m.lock()时会阻塞直到m.unlock释放.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::mutex m&#123;&#125;;</span><br><span class="line">m.<span class="built_in">try_lock</span>();</span><br><span class="line"><span class="comment">// do something...</span></span><br><span class="line">m.<span class="built_in">unlock</span>()</span><br></pre></td></tr></table></figure><p>try_lock不会阻塞,而是会返回一个bool值,如果失败了就返回false,上锁成功返回true</p><h3 id="如何管理互斥量"><a href="#如何管理互斥量" class="headerlink" title="如何管理互斥量"></a>如何管理互斥量</h3><p>使用<code>std::lock_guard</code>与<code>std::scoped_lock</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLockGuard</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> mutext_type = T;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyLockGuard</span><span class="params">(T t_mutex)</span> : _MyMutex(t_mutex) &#123;</span> _MyMutex.<span class="built_in">lock</span>(); &#125;</span><br><span class="line">  <span class="built_in">MyLockGuard</span>(T&amp; _Mtx, std::<span class="keyword">adopt_lock_t</span>) <span class="keyword">noexcept</span> : _MyMutex(_Mtx) &#123;&#125;</span><br><span class="line">  <span class="built_in">MyLockGuard</span>(<span class="keyword">const</span> MyLockGuard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  MyLockGuard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyLockGuard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">MyLockGuard</span>() <span class="keyword">noexcept</span> &#123; _MyMutex.<span class="built_in">unlock</span>(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  T&amp; _MyMutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提供便利 RAII 风格机制的互斥包装器,它在作用域块的存在期间占有一或多个互斥体.不可复制、移动.当创建对象时,它尝试取得给定互斥体的所有权.当控制离开创建对象的作用域时,析构并释放互斥体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foor_guard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::lock_guard&lt;std::mutex&gt; lock&#123;m&#125;;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;foor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_list</span><span class="params">(<span class="keyword">int</span> n, std::list&lt;<span class="keyword">int</span>&gt;&amp; list)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">numbers</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">  std::<span class="built_in">iota</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> sum = std::<span class="built_in">accumulate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lc&#123;m&#125;;</span><br><span class="line">    list.<span class="built_in">push_back</span>(sum);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>scoped_lock</code> 类类似,它在作用域块的存在期间占有一或多个互斥体.</p><h3 id="互斥量保护数据的问题"><a href="#互斥量保护数据的问题" class="headerlink" title="互斥量保护数据的问题"></a>互斥量保护数据的问题</h3><p>当使用<code>lock_guard</code>时,如果将指针或者引用传递给外部值,这样就脱离mutex管理了.</p><p><em>简而言之：<strong>切勿将受保护数据的指针或引用传递到互斥量作用域之外</strong>,不然保护将<strong>形同虚设<a href="https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/03共享数据.html#保护共享数据">共享数据 | 现代C++并发编程教程 (mq-b.github.io)</a></strong></em></p><h3 id="互斥可能导致的死锁"><a href="#互斥可能导致的死锁" class="headerlink" title="互斥可能导致的死锁"></a>互斥可能导致的死锁</h3><p>当有多个互斥量时可能遇到死锁.避免死锁的一般建议是让两个互斥量以相同的顺序上锁,总在互斥量 B 之前锁住互斥量 A,就通常不会死锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::mutex m1,m2;</span><br><span class="line">std::<span class="keyword">size_t</span> n&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lc1&#123; m1 &#125;;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lc2&#123; m2 &#125;;</span><br><span class="line">    ++n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lc1&#123; m2 &#125;;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lc2&#123; m1 &#125;;</span><br><span class="line">    ++n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码就有可能死锁. 修改上锁顺序即可.</p><p>但是即使上锁顺序相同,也有可能导致死锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&#123;</span></span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">const</span> std::string&amp; str) :object&#123; str &#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string object;</span><br><span class="line">    std::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (&amp;lhs == &amp;rhs) <span class="keyword">return</span>;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock1&#123; lhs.m &#125;; </span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock2&#123; rhs.m &#125;; </span><br><span class="line">    <span class="built_in">swap</span>(lhs.object, rhs.object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X <span class="selector-tag">a</span>&#123;&quot;<span class="selector-tag">a</span>&quot;&#125;,<span class="selector-tag">b</span>&#123;&quot;<span class="selector-tag">b</span>&quot;&#125;;</span><br><span class="line">std::thread t&#123;[&amp;]&#123;<span class="built_in">swap</span>(a,b);&#125;&#125;;</span><br><span class="line">std::thread t2&#123;[&amp;]&#123;<span class="built_in">swap</span>(b,a);&#125;&#125;;</span><br></pre></td></tr></table></figure><p>解决方法是是使用<code>std::lock</code>,可以同时对多个互斥量上锁,如果已经上锁会抛出异常并unlock解锁这些互斥量,或者使用刚才的std::scoped_lock,提供与lock_guard同样的RAII包装.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Xa&amp; lhs, Xa&amp; rhs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (&amp;lhs == &amp;rhs) <span class="keyword">return</span>;</span><br><span class="line">  std::<span class="built_in">lock</span>(lhs.m, rhs.m);</span><br><span class="line">  std::lock_guard&lt;std::mutex&gt; lock1&#123;lhs.m,std::adopt_lock&#125;;</span><br><span class="line">  std::lock_guard&lt;std::mutex&gt; lock2&#123;rhs.m,std::adopt_lock&#125;;</span><br><span class="line">  <span class="built_in">swap</span>(lhs.object, rhs.object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Xa&amp; lhs, Xa&amp; rhs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (&amp;lhs == &amp;rhs) <span class="keyword">return</span>;</span><br><span class="line">  std::<span class="built_in">scoped_lock</span>(lhs.m, rhs.m);</span><br><span class="line">  <span class="built_in">swap</span>(lhs.object, rhs.object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>std::scoped_lock</code> 可以将所有 <code>std::lock</code> 替换掉,减少错误发生</p><h3 id="Tips-for-avoiding-dead-lock"><a href="#Tips-for-avoiding-dead-lock" class="headerlink" title="Tips for avoiding dead lock"></a>Tips for avoiding dead lock</h3><h4 id="避免嵌套锁"><a href="#避免嵌套锁" class="headerlink" title="避免嵌套锁"></a>避免嵌套锁</h4><p>线程获取一个锁时,就别再获取第二个锁.每个线程只持有一个锁,自然不会产生死锁.<strong>如果必须要获取多个锁,使用 <code>std::lock</code>或<code>std::scoped_lock</code></strong></p><h4 id="避免在持有锁时调用外部代码"><a href="#避免在持有锁时调用外部代码" class="headerlink" title="避免在持有锁时调用外部代码"></a>避免在持有锁时调用外部代码</h4><p>因为代码是外部提供的,所以没办法确定外部要做什么.外部程序可能做任何事情,包括获取锁.在持有锁的情况下,如果用外部代码要获取一个锁,就会违反第一个指导意见,并造成死锁（有时这是无法避免的）</p><h4 id="使用固定顺序获取锁"><a href="#使用固定顺序获取锁" class="headerlink" title="使用固定顺序获取锁"></a>使用固定顺序获取锁</h4><p>避免死锁</p><h3 id="std-unique-lock"><a href="#std-unique-lock" class="headerlink" title="std::unique_lock"></a>std::unique_lock</h3><p><code>unique_lock</code>更加灵活,它不能拷贝,内部有一个<code>_Owns</code>变量表明是否有锁的拥有权(或者说是否已经上锁),默认构造函数调用时owns为false并上锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_NODISCARD_CTOR_LOCK <span class="keyword">explicit</span> <span class="title">unique_lock</span><span class="params">(_Mutex&amp; _Mtx)</span></span></span><br><span class="line"><span class="function">       : _Pmtx(_STD addressof(_Mtx)), _Owns(false) &#123;</span> <span class="comment">// construct and lock</span></span><br><span class="line">       _Pmtx-&gt;<span class="built_in">lock</span>();</span><br><span class="line">       _Owns = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此外还有<code>std::defer_lock</code>和<code>std::adopt_lock</code>分别表示没有上锁(_Owns为false),构造函数中不会上锁和已经上锁(_Owns为true),,构造函数中不会 上锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_lock</span>(_Mutex&amp; _Mtx, <span class="keyword">defer_lock_t</span>) <span class="keyword">noexcept</span></span><br><span class="line">        : _Pmtx(_STD <span class="built_in">addressof</span>(_Mtx)), _Owns(<span class="literal">false</span>) &#123;&#125; <span class="comment">// construct but don&#x27;t lock</span></span><br><span class="line"><span class="built_in">lock_guard</span>(_Mutex&amp; _Mtx, <span class="keyword">adopt_lock_t</span>) <span class="keyword">noexcept</span> <span class="comment">// strengthened</span></span><br><span class="line">        : _MyMutex(_Mtx) &#123;&#125; <span class="comment">// construct but don&#x27;t lock</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>unique_lock</code>类中也有lock和unlock方法,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; <span class="comment">// lock the mutex</span></span><br><span class="line">        _Validate();</span><br><span class="line">        _Pmtx-&gt;<span class="built_in">lock</span>();</span><br><span class="line">        _Owns = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!_Pmtx || !_Owns) &#123;</span><br><span class="line">            _Throw_system_error(errc::operation_not_permitted);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _Pmtx-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">        _Owns = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简而言之：</p><ul><li>使用 <code>std::defer_lock</code> 构造函数不上锁,要求构造之后上锁</li><li>使用 <code>std::adopt_lock</code> 构造函数不上锁,要求在构造之前互斥量上锁</li><li>默认构造会上锁,要求构造函数之前和构造函数之后都不能再次上锁</li></ul><p>通常建议优先 <code>std::lock_guard</code>,当无法满足你的需求或者显得代码非常繁琐,那么可以考虑使用 <code>std::unique_lock</code></p><p>std::mutex是<strong>不能拷贝也不能移动的量</strong>,在unique_lock中保存了指向它的指针,而unique_lock是可以移动的,所以可以利用unique_lock转移互斥量(准确地说需要互斥量在这些作用域内存活并通过移动构造、赋值进行转移)</p><h3 id="保护共享数据初始化"><a href="#保护共享数据初始化" class="headerlink" title="保护共享数据初始化"></a>保护共享数据初始化</h3><p>一些数据在多线程环境下进行初始化时可能会导致多次初始化,也是数据竞争的行为. 可以采用其他方式进行保护.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">std::once_flag flag;</span><br><span class="line">std::shared_ptr&lt;Data&gt; data;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_resouce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  data.<span class="built_in">reset</span>(<span class="keyword">new</span> Data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::<span class="built_in">call_once</span>(flag,init_resouce);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::call_once</code>可以接收可调用对象,传入flag表明之及逆行一次初始化,使得线程安全. <strong>静态局部变量初始化在 C++11 是线程安全</strong></p><h3 id="读写锁保护不常更新的数据结构"><a href="#读写锁保护不常更新的数据结构" class="headerlink" title="读写锁保护不常更新的数据结构"></a>读写锁保护不常更新的数据结构</h3><p>有时多线程环境下,一个线程基本只用来写,其他线程用来读. 可以使用<code>std::shared_mutex</code>保证写线程独占权和读线程的访问权.</p><p><code>shared_mutex</code> 类是一个同步原语,可用于保护共享数据不被多个线程同时访问.与便于独占访问的其他互斥体类型不同,shared_mutex 拥有两个访问级别：</p><ul><li><p><em>共享</em> - 多个线程能共享同一互斥体的所有权.</p></li><li><p><em>独占</em> - 仅一个线程能占有互斥.</p></li></ul><p>若一个线程已获取<em>独占</em> ﻿锁（通过 lock、try_lock,则无其他线程能获取该锁（包括<em>共享</em>的）.</p><p>若一个线程已获取<em>共享</em> ﻿锁（通过 lock_shared、try_lock_shared）,则无其他线程能获取<em>独占</em> ﻿锁,但可以获取<em>共享</em> ﻿锁.</p><p>仅当任何线程均未获取<em>独占</em> ﻿锁时,<em>共享</em> ﻿锁能被多个线程获取.</p><p>在一个线程内,同一时刻只能获取一个锁（<em>共享</em>或<em>独占</em>）</p><p><code>std::shared_lock</code>主要是提供了lock_shared的作用,区分了共享锁和独占锁,如果有独占锁,多个线程不管使用共享锁还是独占锁都需要阻塞,反之如果全是共享锁则不会阻塞(因为全是读操作)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, std::string&gt; data_;</span><br><span class="line">std::shared_mutex mtx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::lock_guard lg&#123;mtx&#125;;</span><br><span class="line">  data_[<span class="string">&quot;fa&quot;</span>] = <span class="string">&quot;af&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::shared_lock sl&#123;mtx&#125;;</span><br><span class="line">  <span class="keyword">auto</span> it = data_.<span class="built_in">find</span>(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">  std::cout &lt;&lt; (it == data_.<span class="built_in">end</span>() ? it-&gt;second : <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/10/11/Jt2lAn7xmdCULoy.png" alt="image-20241011211429754"></p><h3 id="std-recursive-mutex"><a href="#std-recursive-mutex" class="headerlink" title="std::recursive_mutex"></a>std::recursive_mutex</h3><p>在同一线程多次lock一个普通mutex,是未定义行为. 如果在一个线程多次lock,另一个线程就一直无法拿到锁了. 使用std::recursive_mutex使得同一线程在lock和unlock次数一样的情况下才会真正释放锁.</p><p>它允许同一线程多次锁定同一个互斥量,而不会造成死锁.当同一线程多次对同一个 <code>std::recursive_mutex</code> 进行锁定时,<strong>只有在解锁与锁定次数相匹配时,互斥量才会真正释放</strong>.但它并不影响不同线程对同一个互斥量进行锁定的情况.不同线程对同一个互斥量进行锁定时,会按照互斥量的规则<strong>进行阻塞</strong></p><p>在使用迭代函数中使用锁时可以使用这个互斥量</p><p>通常不直接调用 <code>unlock()</code>,而是使用std::unique_lock与std::lock_guard管理排他性锁定.</p><p>调用<code>lock</code>时所有权层数+1,调用<code>unlock</code>时,如果所有权层数为1,解锁互斥量,否则-1.</p><h3 id="new、delete的线程安全性"><a href="#new、delete的线程安全性" class="headerlink" title="new、delete的线程安全性"></a>new、delete的线程安全性</h3><p>如果标准达到 <strong>C++11</strong>,要求下列<strong>函数</strong>是线程安全的：</p><ul><li><code>new</code>和 <code>delete</code> 运算符的<strong>库</strong>版本</li><li>全局 <code>new</code> 运算符和 <code>delete</code> 运算符的用户替换版本</li><li>std::calloc、std::malloc、std::realloc、std::aligned_alloc](C++17 起)、std::free</li></ul><p><strong>内存分配、释放操作是线程安全</strong>,构造和析构不涉及共享资源.而<strong>局部对象 <code>p</code> 对于每个线程来说是独立的</strong>.换句话说,每个线程都有其自己的 <code>p</code> 对象实例,因此它们不会共享同一个对象,自然没有数据竞争</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T* p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p = <span class="keyword">new</span> T&#123;&#125;; <span class="comment">// 存在数据竞争</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>p</code> 是全局对象(或者外部的,只要可被多个线程读写),<strong>多个线程同时对其进行访问和修改时,就可能会导致数据竞争和未定义行为.因此,确保全局对象的线程安全访问通常需要额外的同步措施,比如互斥量或原子操作</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&#123;</span></span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">int</span> v)&#123;</span><br><span class="line">        ::n += v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    X* p = <span class="keyword">new</span> X&#123; <span class="number">1</span> &#125;; <span class="comment">// 存在数据竞争</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++ 只保证了 <code>operator new</code>、<code>operator delete</code> 这两个方面的线程安全</p><p><code>new</code> 表达式线程安全要考虑三方面：<code>operator new</code>、构造函数、修改指针.</p><p><code>delete</code> 表达式线程安全考虑两方面：<code>operator delete</code>、析构函数</p><h3 id="线程存储期"><a href="#线程存储期" class="headerlink" title="线程存储期"></a>线程存储期</h3><p>线程存储期的对象在线程开始时分配,并在线程结束时释放. 使用<code>thread_local</code>声明变量,声明线程存储期的对象,每一个线程都有独立的 <code>thread_local</code> 对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> global_counter = <span class="number">0</span>; <span class="comment">// 静态存储期</span></span><br><span class="line"><span class="keyword">thread_local</span> <span class="keyword">int</span> thread_local_counter=<span class="number">0</span>; <span class="comment">// 线程存储期</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_counters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout&lt;&lt;<span class="string">&quot;global: &quot;</span>&lt;&lt;global_counters++&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout&lt;&lt;<span class="string">&quot;thread_local&quot;</span>&lt;&lt;thread_local_counter&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::thread&#123;print_counters&#125;.<span class="built_in">join</span>();</span><br><span class="line">  std::thread&#123;print_counters&#125;.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步操作"><a href="#同步操作" class="headerlink" title="同步操作"></a>同步操作</h2><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量有<code>std::condition_variable</code>和<code>std::condition_variable_any</code>,</p><p>std::condition_variable是与std::mutex 一起使用的同步原语,它能用于阻塞一个线程,或同时阻塞多个线程,直至另一线程修改共享变量（<em>条件</em>）并通知<code>std::condition_variable</code></p><p>条件变量用于同步,可以阻塞线程并使用<code>notify_one</code>让解除相关线程阻塞</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_for_flag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::unique_lock ul&#123;cv_mutex&#125;;</span><br><span class="line">  <span class="comment">// ul.unlock(); and block the thread</span></span><br><span class="line">  cv.<span class="built_in">wait</span>(ul, [] &#123; <span class="keyword">return</span> flag; &#125;);</span><br><span class="line">  <span class="comment">// when get notified,relive the thread and lock the mutex</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;arrived\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_flag_true</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard lg&#123;cv_mutex&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;set_flag_true\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::jthread t1&#123;wait_for_flag&#125;, t2&#123;wait_for_flag&#125;, t3&#123;set_flag_true&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外还有<code>std::condition_variable_any</code>,相对于只在 std::unique_lock上工作的 std::condition_variable,<code>condition_variable_any</code> 能在任何满足可基本锁定要求的锁上工作(只需要lock和unlock方法)</p><h3 id="future获得线程结果"><a href="#future获得线程结果" class="headerlink" title="future获得线程结果"></a>future获得线程结果</h3><p>如果要获得一个线程处理后的结果,可以通过使用condition_variable同步,cv.notify(),cv.wait(). 但是更好的方式是通过future获取返回值</p><p>类模板 <code>std::future</code> 提供访问异步操作结果的机制：</p><ul><li><p>（通过std::async,std::packaged_task或 std::promise创建的）异步操作能提供一个 <code>std::future</code> 对象给该异步操作的创建者.</p></li><li><p>然后,异步操作的创建者可以使用多个方法查询、等待或从 <code>std::future</code> 提取值.若异步操作尚未提供值,则这些方法可能阻塞.</p></li><li><p>当异步操作准备好发送结果给创建者时,它可以修改与创建者的 <code>std::future</code> 相链接的<em>共享状态</em></p></li></ul><p><code>std::thread</code> 没提供直接从线程获取返回值的机制.所以可以使用 std::async 函数模板,使用async与thread类似,默认按值赋值,内部将参数副本转换为右值. future的get和wait方法也是用于同步的,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; p)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>&amp; p )</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">std::<span class="built_in">async</span>(f, n);   <span class="comment">// OK! 可以通过编译,不过引用的并非是局部的n</span></span><br><span class="line">std::<span class="built_in">async</span>(f2, n);  <span class="comment">// Error! 无法通过编译</span></span><br></pre></td></tr></table></figure><p>async接受所有可调用对象(函数,类成员方法,仿函数类,lambda),与thread类似,其有不同的异步执行策略,std::launch::defered与std::launch::async</p><ol><li><code>std::launch::async</code> 在不同<strong>线程上</strong>执行异步任务.</li><li><code>std::launch::deferred</code> 惰性求值,<strong>不创建线程</strong>,等待 <code>future</code> 对象调用 <code>wait</code> 或 <code>get</code> 成员函数的时候执行任务.</li></ol><p>如果从 <code>std::async</code> 获得的 <code>std::future</code>没有被移动或绑定到引用,那么在完整表达式结尾, <code>std::future</code> 的<strong>析构函数将阻塞,直到到异步任务完成</strong>.因为临时对象的生存期就在这一行,而对象生存期结束就会调用调用析构函数.</p><p>被移动的 <code>std::future</code> 没有所有权,失去共享状态,不能调用 <code>get</code>、<code>wait</code> 成员函数. 此外还有<code>valid</code>检查 future 当前是否关联共享状态,即是否当前关联任务.还未关联,或者任务已经执行完（调用了 get()、set()）,都会返回 <strong><code>false</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> n)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp; p)</span> </span>&#123; std::cout &lt;&lt; &amp;p &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Y y;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> t1 = std::<span class="built_in">async</span>(X&#123;&#125;, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">auto</span> t2 = std::<span class="built_in">async</span>(&amp;Y::f,&amp;y,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">auto</span> t3 = std::<span class="built_in">async</span>([] &#123;&#125;);         </span><br><span class="line">    <span class="keyword">auto</span> t4 = std::<span class="built_in">async</span>(f, std::<span class="built_in">ref</span>(n));</span><br><span class="line">    std::cout &lt;&lt; &amp;n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的future使用<code>wait</code>同步等待处理,或者使用<code>get</code>获得结果.</p><h3 id="packaged-task"><a href="#packaged-task" class="headerlink" title="packaged_task"></a>packaged_task</h3><p>类模板 <code>std::packaged_task</code> 包装任何可调用目标（函数、lambda 表达式、bind 表达式或其他函数对象）,使得能异步调用它.其返回值或所抛异常被存储于能通过 std::future对象访问的共享状态中.</p><p>其重载了<code>()</code>操作符,所以本身也是一个可调用目标,可以传给一个线程. 如果不使用多线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> task_2&#123;std::packaged_task&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt;&#123;f&#125;&#125;;</span><br><span class="line">   <span class="keyword">auto</span> fut_2&#123;task_2.<span class="built_in">get_future</span>()&#125;;</span><br><span class="line">  <span class="built_in">task_2</span>(<span class="number">10</span>);</span><br><span class="line">  std::cout &lt;&lt; fut_2.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面任务并不会在线程中执行,所以并没有并发、异步. 所以需要结合多线程,但注意packaged_task不能拷贝,只能移动.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> task_2&#123;std::packaged_task&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt;&#123;foo&#125;&#125;;</span><br><span class="line"><span class="comment">// std::packaged_task&lt;int(int)&gt; task_2&#123;f&#125;;</span></span><br><span class="line"><span class="keyword">auto</span> fut_2&#123;task_2.<span class="built_in">get_future</span>()&#125;;</span><br><span class="line">std::thread <span class="keyword">fut_t</span>&#123;std::<span class="built_in">move</span>(task_2), <span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">// task_2(10);</span></span><br><span class="line"><span class="keyword">fut_t</span>.<span class="built_in">join</span>();</span><br><span class="line">std::cout &lt;&lt; fut_2.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><p><code>std::packaged_task</code> 也可以在线程中传递,在需要的时候获取返回值,而非将它自己作为可调用对象. 也就是说thread启动一个可调用对象,这个可调用对象中会调用这个packaged_task,可以通过future获得值.</p><h3 id="使用std-promise设置值"><a href="#使用std-promise设置值" class="headerlink" title="使用std::promise设置值"></a>使用std::promise设置值</h3><p>如果要设置一个值,可以传递reference_wrapper\<T>然后join线程即可获取值.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_val</span><span class="params">(<span class="keyword">int</span> &amp;n)</span> </span>&#123; n = <span class="number">20</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> tn&#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::jthread jd&#123;set_val, std::<span class="built_in">ref</span>(tn)&#125;;</span><br><span class="line">jd.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p>但是考虑到这样也许并不好,不仅必须传入通过传入引用、指针,控制颗粒度也不够.</p><p>类模板 <code>std::promise</code> 提供用以存储一个值或一个异常,之后通过 <code>std::promise</code> 对象所创建的<code>std::future</code>对象异步获得.注意 <code>std::promise</code> 只应当使用一次.</p><p>每个promise都与一个<em>共享状态</em> ﻿关联,其中含有一些状态信息和一个<em>结果</em>,它可能尚未求值、已求值为一个值（可能为 <code>void</code>）,或者求值为一个异常.promise可以对共享状态做三件事：</p><ul><li><em>使就绪</em>：promise存储结果或异常于共享状态.标记共享状态为就绪,并除阻在该共享状态所关联的未来体上等待的任何线程.</li><li><em>释放</em>：promise放弃其对共享状态的引用.若这是最后一个这种引用,则销毁共享状态.除非这是 std::async所创建的未就绪的共享状态,否则此操作不阻塞.</li><li><em>抛弃</em>：promise存储以 std::future_errc::broken_promise 为错误码的 std::future_error 类型的异常,令共享状态为<em>就绪</em>,然后<em>释放</em>它</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(std::promise&lt;<span class="keyword">int</span>&gt; obj,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">  obj.<span class="built_in">set_value</span>(num*num);</span><br><span class="line">&#125;</span><br><span class="line">std::promise&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="keyword">auto</span> fut = p.<span class="built_in">get_future</span>();</span><br><span class="line">std::jthread t&#123;f,std::<span class="built_in">move</span>(p),<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> result = p.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><p><code>std::promise</code> 只能移动,不可复制,所以需要使用<code>std::move</code>.</p><p>在主线程中通过与其关联的 future 对象的 <code>get()</code> 成员函数获取这个值,如果<code>promise</code>的值还没有被设置,那么将阻塞当前线程</p><p>除了返回一般值外还可以设置异常,但一个promise只能要么设置异常要么设置值,如果设置异常,则通过在promise所在函数中使用try与get进行捕获. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculate_square</span><span class="params">(std::promise&lt;<span class="keyword">int</span>&gt; promiseObj, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">100</span>ms);</span><br><span class="line">  <span class="keyword">if</span> (!num) &#123;</span><br><span class="line">    promiseObj.<span class="built_in">set_value</span>(num * num);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    promiseObj.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function">std::thread <span class="title">t1t</span><span class="params">(calculate_square, std::move(promise), num)</span></span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;等待线程执行...\n&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> result = fut_3.<span class="built_in">get</span>(); <span class="comment">// 获取结果或等待异常</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result is &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">  &#125; <span class="built_in"><span class="keyword">catch</span></span> (std::exception &amp;e) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;来自线程的异常&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  t1t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><h3 id="future的状态变化"><a href="#future的状态变化" class="headerlink" title="future的状态变化"></a>future的状态变化</h3><p>future保有共享状态,只能移动,调用 <code>get</code> 函数后,future对象会失去共享状态,<code>std::future</code> 所引用的共享状态不与另一异步返回对象共享</p><ul><li><strong>移动语义</strong>：因为<strong>移动操作标志着所有权的转移</strong>,意味着 <code>future</code> 不再拥有共享状态.<code>get</code> 和 <code>wait</code> 函数要求 <code>future</code> 对象拥有共享状态,否则会抛出异常.</li><li><strong>共享状态失效</strong>：调用 <code>get</code> 成员函数时,<code>future</code> 对象必须拥有共享状态,但调用完成后,它就会<strong>失去共享状态</strong>,不能再次调用 <code>get</code>.</li></ul><p><strong>future 是一次性的</strong>,它的结果只能被一个线程获取.<code>get()</code> 成员函数只能调用一次,当结果被某个线程获取后,<code>std::future</code> 就无法再用于其他线程.</p><h3 id="使用shared-future共享状态"><a href="#使用shared-future共享状态" class="headerlink" title="使用shared_future共享状态"></a>使用shared_future共享状态</h3><p>目前shared_xx学习到的有,shared_ptr,shared_mutex,shared_lock,现在又有了shared_future.  unique_ptr与unique_lock,future都表示独占所有权(只能移动),而shared_xx本身可以复制,并且可以共享.</p><p>主要用于在不同线程中共享一个任务/线程中的数据,它也通过wait和get获取数据.</p><p>通过future.share或直接通过future移动构造shared_future</p><p>具体使用通过传入shared_future的拷贝</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">task</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123; <span class="keyword">return</span> num*num;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(task,<span class="number">10</span>);</span><br><span class="line">std::shared_future&lt;<span class="keyword">int</span>&gt; fut_shared = fut.<span class="built_in">share</span>();</span><br><span class="line">std::jthread thread1&#123;[fut_shared]&#123;</span><br><span class="line">  <span class="keyword">int</span> result = fut_shared.<span class="built_in">get</span>();</span><br><span class="line">  <span class="keyword">return</span> result*<span class="number">2</span>;</span><br><span class="line">&#125;&#125;</span><br><span class="line">std::jthread thread2&#123;[fut_shared]&#123;</span><br><span class="line">  <span class="keyword">int</span> result = fut_shared.<span class="built_in">get</span>();</span><br><span class="line">  <span class="keyword">return</span> result*<span class="number">2</span>;</span><br><span class="line">&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按复制捕获 <code>std::shared_future</code> 对象,每个线程都有一个 shared_future 的副本,这样不会出现数据竞争问题.</p><h3 id="限时等待"><a href="#限时等待" class="headerlink" title="限时等待"></a>限时等待</h3><p>使用<code>wait_for</code>和<code>wait_until</code>进行限时等待,可以通过future或者条件变量等, 限时等待用于在while循环中等待,可以判断结果,与<code>std::future_status</code>,<code>std::cv_status</code></p><h2 id="Concurrency-in-C-20"><a href="#Concurrency-in-C-20" class="headerlink" title="Concurrency in C++20"></a>Concurrency in C++20</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>C++ 提供了两个信号量类型：<code>std::counting_semaphore</code> 与<code>std::binary_semaphore</code></p><p>信号量是更轻量的同步原语.</p><blockquote><p>mutex,条件变量都是同步原语.  但mutex常用于互斥解决数据竞争,而条件</p></blockquote><p>提供<code>release</code>和<code>acquire</code>两种方法,分别增加内部计数器并解除获得者以及减少内部计数器或阻塞到直至能如此</p><p>信号量常用于<em>发信/提醒</em>而非互斥,通过初始化该信号量为 0 从而阻塞尝试 acquire() 的接收者,直至提醒者通过调用 release(n) “发信”.在此方面可把信号量当作<strong>条件变量的替代品</strong>,<strong>通常它有更好的性能</strong></p><p>counting_semaphore能设置最大信号量值,binary_semaphore最大值就是1,相当于控制了同时访问者.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std::counting_semaphore&lt;<span class="number">3</span>&gt; semaphore&#123;<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_request</span><span class="params">(<span class="keyword">int</span> request_id)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;进入handle_request尝试获取信号量\n&quot;</span>;</span><br><span class="line">  semaphore.<span class="built_in">acquire</span>(); <span class="comment">// similar to cv.wait(lk)??</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;成功获取信号量\n&quot;</span>;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line"></span><br><span class="line">  std::random_device rd;</span><br><span class="line">  std::mt19937 gen&#123;<span class="built_in">rd</span>()&#125;;</span><br><span class="line">  std::uniform_int_distribution dis&#123;<span class="number">1</span>, <span class="number">10</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> process_time = <span class="built_in">dis</span>(gen);</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::seconds&#123;process_time&#125;);</span><br><span class="line">  std::cout &lt;&lt; std::format(<span class="string">&quot;请求 &#123;&#125; 已被处理\n&quot;</span>, request_id);</span><br><span class="line">  semaphore.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-latch"><a href="#std-latch" class="headerlink" title="std::latch"></a>std::latch</h3><p>信号量方便同步,与条件变量类似. 而latch与barrier是线程协调机制,阻塞已知大小的线程组直至该组中的所有线程到达该屏障.</p><p>允许任何数量的线程阻塞<strong>直至期待数量的线程到达</strong>. latch是单次使用的线程屏障,latch不能重复使用,它会等到需要的线程的数量.</p><p><code>latch</code> 类维护着一个 std::ptrdiff_t 类型的计数,且只能减少计数,无法增加计数.在创建对象的时候初始化计数器的值.线程可以阻塞,直到 latch 对象的计数减少到零.由于无法增加计数,这使得 <code>latch</code> 成为一种**单次使用的屏障</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::latch work_start&#123;<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;等待其他线程执行\n&quot;</span>;</span><br><span class="line">  work_start.<span class="built_in">wait</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;任务开始执行\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::jthread thread&#123;work&#125;;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">work_start.<span class="built_in">count_down</span>();</span><br></pre></td></tr></table></figure><p>count_down默认将值-1,直到为0时,wait解除阻塞. 此外也有<code>arrive_and_wait</code>相当于<code>count_down(n);wait();</code>,这样在可调用对象内部直接使用</p><h3 id="std-barrier"><a href="#std-barrier" class="headerlink" title="std::barrier"></a>std::barrier</h3><p>可复用的线程屏障,可以在阶段完成之后将计数重置为构造时传递的值.</p><blockquote><p>不同于 std::latch,屏障是可重用的：一旦到达的线程组被解除阻塞,即可重用同一屏障.与 std::latch 不同,会在线程解除阻塞前执行一个可能为空的可调用对象.</p></blockquote><p>barrier也有wait与arrive,它能够多次使用,也就是说如果创建10个线程,每个线程的可调用对象使用barrier值设置为3,那么就会有阻塞,因为9个线程结束,最后一个线程减少barrier设置的值,但依旧不为0. 如果是latch,当内部计数值为0时还调用count_down是未定义行为</p><p><code>arrive_and_wait()</code> 会在期待计数减少至 <code>0</code> 时调用我们构造 barrier 对象时传入的 lambda 表达式,并解除所有在阶段同步点上阻塞的线程.之后重置期待计数为构造中指定的值.屏障的一个阶段就完成了. 还有<code>arrive_and_drop</code>会将当前与最大的计数均-1.</p><p><code>std::barrier</code> 要求其函数对象类型必须是不抛出异常的. </p><h3 id="内存模型与原子操作"><a href="#内存模型与原子操作" class="headerlink" title="内存模型与原子操作"></a>内存模型与原子操作</h3><ul><li>内存模型定义了多线程程序中,读写操作如何在不同线程之间可见,以及这些操作在何种顺序下执行.内存模型确保程序的行为在并发环境下是可预测的.</li><li>原子操作即不可分割的操作.系统的所有线程,不可能观察到原子操作完成了一半</li></ul><h4 id="std-atomic"><a href="#std-atomic" class="headerlink" title="std::atomic"></a>std::atomic</h4><p>c++标准定义了原子类型,这些类型的操作都是原子的,语言定义中只有这些类型的操作是原子的,虽然也可以用互斥量来模拟原子操作.</p><p>每个 <code>std::atomic</code> 模板的实例化和全特化均定义一个原子类型.如果一个线程写入原子对象,同时另一线程从它读取,那么行为有良好定义(使用load和store),<code>std::atomic</code> 既不可复制也不可移动.</p><p>标准原子类型的实现通常包括一个 <code>is_lock_free()</code> 成员函数,允许用户查询特定原子类型的操作是否是通过直接的原子指令实现（返回 true）,还是通过锁来实现（返回 false）</p><p>也可以通过is_always_lock_free和一些宏来检查</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="keyword">int</span>&gt; aint = <span class="number">10</span>;</span><br><span class="line">aint.<span class="built_in">is_lock_free</span>(); <span class="comment">// 成员函数</span></span><br><span class="line">aint.is_always_lock_free; <span class="comment">//编译器常量 constexpr</span></span><br><span class="line">std::cout&lt;&lt;ATOMIC_INT_LOCK_FREE;</span><br></pre></td></tr></table></figure><p>always_lock_free意味着一定无锁,ATOMIC_INT_LOCK_FREE的值若为0则一定有锁,为1则有时无锁,为2则一定无锁.</p><p>在实际应用中,如果一个类型的原子操作总是无锁的,可以更放心地在性能关键的代码路径中使用它.</p><p>如果发现某些原子类型在目标平台上是有锁的,我们可以考虑以下优化策略：</p><ol><li><strong>使用不同的数据结构</strong>：有时可以通过改变数据结构来避免对原子操作的依赖.</li><li><strong>减少原子操作的频率</strong>：通过批处理等技术,减少对原子操作的调用次数.</li><li><strong>使用更高效的同步机制</strong>：在一些情况下,其它同步机制（如读写锁）可能比原子操作更高效.</li></ol><p>其实很多时候根本没这种性能的担忧,很多时候使用原子对象只是为了简单方便,比如 <code>std::atomic&lt;bool&gt;</code> 表示状态、<code>std::atomic&lt;int&gt;</code> 进行计数等.即使它们是用了锁,那也是封装好了的,起码用着方便,而不需要在代码中引入额外的互斥量来保护,更加简洁.这也是很正常的需求,各位不但要考虑程序的性能,同时也要考虑代码的简洁性、易用性.即使使用原子类型无法带来效率的提升,那也没有负提升.</p><p>常用的atomic特化有int,bool,flag,等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">atomic_char</span>   = atomic&lt;<span class="keyword">char</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">atomic_schar</span>  = atomic&lt;<span class="keyword">signed</span> <span class="keyword">char</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">atomic_uchar</span>  = atomic&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">atomic_short</span>  = atomic&lt;<span class="keyword">short</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">atomic_ushort</span> = atomic&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">atomic_int</span>    = atomic&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">atomic_uint</span>   = atomic&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">atomic_long</span>   = atomic&lt;<span class="keyword">long</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">atomic_ulong</span>  = atomic&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">atomic_llong</span>  = atomic&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">atomic_ullong</span> = atomic&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;;</span><br></pre></td></tr></table></figure><p>原子类型常用方法包括<code>load</code>,<code>store</code>,<code>exchange</code>等,不同特化也有不同方法. 可以为自定义类型创建atomic,需要满足可复制构造,可复制赋值以及可平凡复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">static_assert</span></span>(std::is_trivially_copyable&lt;trivial_type&gt;::value, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in"><span class="keyword">static_assert</span></span>(std::is_copy_constructible&lt;trivial_type&gt;::value, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in"><span class="keyword">static_assert</span></span>(std::is_move_constructible&lt;trivial_type&gt;::value, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in"><span class="keyword">static_assert</span></span>(std::is_copy_assignable&lt;trivial_type&gt;::value, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in"><span class="keyword">static_assert</span></span>(std::is_move_assignable&lt;trivial_type&gt;::value, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p>原子类型的操作函数有一个内存序参数,对原子对象的访问可以建立线程间同步,并按<code>std::memory_order</code>对非原子内存访问定序. 任何 <code>std::atomic</code>类型,初始化不是原子操作,其他方法是原子操作.与大多数赋值运算符不同,<strong>原子类型的赋值运算不返回到它的左侧参数的引用.它们会返回存储值的副本</strong></p><h4 id="std-atomic-flag"><a href="#std-atomic-flag" class="headerlink" title="std::atomic_flag"></a>std::atomic_flag</h4><p><code>std::atomic_flag</code> 是一种原子布尔类型.与所有std::atomic的特化不同,它保证是无锁的.与std::atomic\<bool> 不同,<code>std::atomic_flag</code> 不提供加载或存储操作.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::atomic_flag flag&#123;&#125;;</span><br><span class="line"><span class="keyword">bool</span> r = flag.<span class="built_in">test_and_set</span>();</span><br></pre></td></tr></table></figure><p>当标志对象已初始化,它只能做三件事情：<strong>销毁、清除、设置</strong>.这些操作对应的函数分别是：</p><ol><li><strong><code>clear()</code></strong> （清除）：将标志对象的状态原子地更改为清除（false）</li><li><strong><code>test_and_set</code></strong>（测试并设置）：将标志对象的状态原子地更改为设置（true）,并返回它先前保有的值.</li><li>销毁：对象的生命周期结束时,自动调用析构函数进行销毁操作.</li></ol><p>适合使用atomic_flag做一个自旋锁,也就是通过<code>while</code>忙等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">spinlock_mutex</span> &#123;</span></span><br><span class="line">    std::atomic_flag flag&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">spinlock_mutex</span>()<span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span><span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag.<span class="built_in">test_and_set</span>(std::memory_order_acquire));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span><span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        flag.<span class="built_in">clear</span>(std::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="std-atomic-1"><a href="#std-atomic-1" class="headerlink" title="std::atomic\"></a>std::atomic\<bool></h4><p>布尔原子类型,但比atomic_flag多load,store等方法,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="keyword">bool</span>&gt; b&#123;<span class="literal">true</span>&#125;;</span><br><span class="line">b.<span class="built_in">load</span>(<span class="literal">true</span>);</span><br><span class="line">b = <span class="literal">false</span>;<span class="comment">//表达式值为false</span></span><br><span class="line"><span class="keyword">auto</span> value = (b = <span class="literal">false</span>); </span><br></pre></td></tr></table></figure><p><code>exchange</code>以 desired 原子地替换底层值.操作为读-修改-写操作.根据 order 的值影响内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="keyword">bool</span>&gt; b&#123;<span class="literal">true</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> x = b.<span class="built_in">load</span>();</span><br><span class="line">b.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">x = b.<span class="built_in">exchange</span>(<span class="literal">false</span>); <span class="comment">// x-&gt;true</span></span><br></pre></td></tr></table></figure><p><code>compare_exchange_weak</code>和<code>compare_exchange_strong</code></p><p>原子地比较 <em>this 和 expected 的对象表示(C++20 前),值表示 (C++20 起).如果它们逐位相等,那么以 desired 替换前者（进行读修改写操作）.否则,将 </em>this 中的实际值加载进 expected（进行加载操作）.</p><p>也就是当前值与预期一致时,存储新值否则得到当前值存储在expected中</p><p><strong>compare_exchange_weak</strong>:尝试将原子对象的当前值与预期值进行比较,如果相等则将其更新为新值并返回 <code>true</code>；否则,将原子对象的值加载进 expected（进行加载操作）并返回 <code>false</code>.此操作可能会由于某些硬件的特性而出现<strong>假失败</strong>,需要在循环中重试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="keyword">bool</span>&gt; flag&#123; <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="keyword">bool</span> expected = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!flag.<span class="built_in">compare_exchange_weak</span>(expected, <span class="literal">true</span>));</span><br></pre></td></tr></table></figure><p><strong>compare_exchange_strong</strong>：类似于 <code>compare_exchange_weak</code>,<strong>但不会出现假失败,因此不需要重试</strong>.适用于需要确保操作成功的场合.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="keyword">bool</span>&gt; flag&#123; <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="keyword">bool</span> expected = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">try_set_flag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试将 flag 设置为 true,如果当前值为 false</span></span><br><span class="line">    <span class="keyword">if</span> (flag.<span class="built_in">compare_exchange_strong</span>(expected, <span class="literal">true</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;flag 为 false,设为 true.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;flag 为 true, expected 设为 true.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>compare_exchange_weak</code> 和 <code>compare_exchange_strong</code> 允许指定成功和失败情况下的内存序.这意味着你可以根据成功或失败的情况,为原子操作指定不同的内存序</p><h4 id="std-atmoc"><a href="#std-atmoc" class="headerlink" title="std::atmoc"></a>std::atmoc<T*></h4><p><code>std::atomic&lt;T*&gt;</code> 是一个原子指针类型,<code>T</code> 是指针所指向的对象类型.操作是针对 <code>T</code> 类型的指针进行的.虽然 <code>std::atomic&lt;T*&gt;</code> 不能被拷贝和移动,但它可以通过符合类型的指针进行构造和赋值.</p><p>除了常见的<code>load</code>,<code>store</code>,<code>exchange</code>等,还有<code>fetch_add</code>,<code>fetch_sub</code>等,确保多线程下的指针操作.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">Foo array[<span class="number">5</span>]&#123;&#125;;</span><br><span class="line">std::atomic&lt;Foo*&gt; p&#123; array &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p 加 2,并返回原始值</span></span><br><span class="line">Foo* x = p.<span class="built_in">fetch_add</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">assert</span>(x == array);</span><br><span class="line"><span class="built_in">assert</span>(p.<span class="built_in">load</span>() == &amp;array[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// p 减 1,并返回原始值</span></span><br><span class="line">x = (p -= <span class="number">1</span>);</span><br><span class="line"><span class="built_in">assert</span>(x == &amp;array[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">assert</span>(p.<span class="built_in">load</span>() == &amp;array[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数也允许内存序作为给定函数的参数</span></span><br><span class="line">p.<span class="built_in">fetch_add</span>(<span class="number">3</span>, std::memory_order_release);</span><br></pre></td></tr></table></figure><h4 id="std-atomic-2"><a href="#std-atomic-2" class="headerlink" title="std::atomic\"></a>std::atomic\<std::shared_ptr></h4><p>若多个执行线程不同步地同时访问<strong>同一</strong> <code>std::shared_ptr</code> 对象,且任何这些访问使用了 shared_ptr 的非 const 成员函数,则将出现数据竞争<strong>,</strong>除非通过 <code>std::atomic&lt;std::shared_ptr&gt;</code> 的实例进行所有访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;std::shared&gt; data&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i) &#123;</span><br><span class="line">        std::shared_ptr&lt;Data&gt; new_data = std::make_shared&lt;Data&gt;(i);</span><br><span class="line">        data.<span class="built_in">store</span>(new_data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> sp = data.<span class="built_in">load</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;读取线程值: &quot;</span> &lt;&lt; sp-&gt;<span class="built_in">get_value</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;没有读取到数据&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">10</span>ms);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后原子类型还提供了<code>wait</code>和<code>notify_xx</code>的方法,<code>wait</code>进行原子等待操作,如果值与this-&gt;load()值表示相同,则阻塞直到 <em>this 被 notify_one() 或 notify_all() 提醒,如果不同直接返回. <code>notif_xx</code>进行原子提醒操作,如果有线程被 </em>this 上的原子等待操作（即 wait()）阻塞,那么解除锁定这种线程；否则不做任何事</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;std::shared_ptr&lt;<span class="keyword">int</span>&gt;&gt; ptr = std::make_shared&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_for_wake_up</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::osyncstream&#123; std::cout &#125;</span><br><span class="line">        &lt;&lt; <span class="string">&quot;线程 &quot;</span></span><br><span class="line">        &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">        &lt;&lt; <span class="string">&quot; 阻塞,等待更新唤醒\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 ptr 变为其它值</span></span><br><span class="line">    ptr.<span class="built_in">wait</span>(ptr.<span class="built_in">load</span>());</span><br><span class="line"></span><br><span class="line">    std::osyncstream&#123; std::cout &#125;</span><br><span class="line">        &lt;&lt; <span class="string">&quot;线程 &quot;</span></span><br><span class="line">        &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">        &lt;&lt; <span class="string">&quot; 已被唤醒\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_up</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">5</span>s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新值并唤醒</span></span><br><span class="line">    ptr.<span class="built_in">store</span>(std::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>));</span><br><span class="line">    ptr.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="std-atomic-ref"><a href="#std-atomic-ref" class="headerlink" title="std::atomic_ref"></a>std::atomic_ref</h4><p><code>std::atomic_ref</code> 类模板对它引用的对象应用原子操作.在 <code>std::atomic_ref</code> 对象的生存期中,认为它引用的对象是原子对象.如果一个线程写入原子对象,同时另一线程从它读取,那么其行为有良好定义.另外,对原子对象的访问可以建立线程间同步,和按 std::memory_order 所指定定序非原子内存访问.</p><p>对象的生存期必须超出所有引用该对象的 <code>std::atomic_ref</code> 的生存期.任何 <code>std::atomic_ref</code> 实例所引用的对象仍存在时,必须只通过这些 <code>std::atomic_ref</code> 实例排他地访问该对象.<code>std::atomic_ref</code> 对象所引用对象的任何子对象均不可同时被任何其他 <code>std::atomic_ref</code> 对象引用.</p><p>通过 <code>std::atomic_ref</code> 应用到对象的原子操作,相对于通过任何其他引用同一对象的 <code>std::atomic_ref</code> 应用的操作来说都是原子的.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;std::shared_ptr&lt;<span class="keyword">int</span>&gt;&gt; ptr = std::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">std::atomic_ref&lt;<span class="keyword">int</span>&gt; ref&#123; *ptr.<span class="built_in">load</span>() &#125;;</span><br><span class="line">ref = <span class="number">100</span>; <span class="comment">// 原子地赋 100 给被引用的对象</span></span><br></pre></td></tr></table></figure><h4 id="std-memory-order"><a href="#std-memory-order" class="headerlink" title="std::memory_order"></a>std::memory_order</h4><p><code>std::memory_order</code> 指定内存访问,包括常规的非原子内存访问,如何围绕原子操作排序.在没有任何约束的多处理器系统上,多个线程同时读或写数个变量时,一个线程能观测到变量值更改的顺序不同于另一个线程写它们的顺序.实际上,更改的顺序甚至能在多个读取线程间相异.一些类似的效果还能在单处理器系统上出现,因为内存模型允许编译器进行变换.</p><p>库中所有原子操作的默认行为提供<em>序列一致定序</em>.该默认行为可能有损性能,不过可以给予库的原子操作额外的 <code>std::memory_order</code> 实参,以指定确切的约束,在原子性外,编译器和处理器还必须强制该操作.</p><p><code>std::memory_order</code> 是一个枚举类型,用来指定原子操作的内存顺序,影响这些操作的行为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">memory_order</span> &#123;</span></span><br><span class="line">    memory_order_relaxed,</span><br><span class="line">    memory_order_consume,</span><br><span class="line">    memory_order_acquire,</span><br><span class="line">    memory_order_release,</span><br><span class="line">    memory_order_acq_rel,</span><br><span class="line">    memory_order_seq_cst</span><br><span class="line">&#125; memory_order;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++20 起则为：</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">memory_order</span> :</span> <span class="comment">/* 未指明 */</span> &#123;</span><br><span class="line">    relaxed, consume, acquire, release, acq_rel, seq_cst</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_relaxed = memory_order::relaxed;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_consume = memory_order::consume;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_acquire = memory_order::acquire;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_release = memory_order::release;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_acq_rel = memory_order::acq_rel;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_seq_cst = memory_order::seq_cst;</span><br></pre></td></tr></table></figure><p>这 6 个常量,每一个常量都表示不同的内存次序</p><p>大体来说可以将它们分为三类.</p><ol><li><p><code>memory_order_relaxed</code> 宽松定序：不是定序约束,<strong>仅对此操作要求原子性</strong>.</p></li><li><p><code>memory_order_seq_cst</code> 序列一致定序,这是库中所有原子操作的<strong>默认行为</strong>,也是<strong>最严格的内存次序</strong>,是<strong>绝对安全</strong>的.</p><p><img data-src="https://s2.loli.net/2024/10/15/sTrc7EOAY9ubaRF.png" alt="image-20241015195228114"></p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/02使用线程.html#启动新线程">使用线程 | 现代C++并发编程教程 (mq-b.github.io)</a></li><li>C++ Concurrency in Action</li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;更加深入的探讨并发.&lt;br&gt;</summary>
    
    
    
    
    <category term="c++" scheme="https://www.sekyoro.top/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>窗口工具库GLFW使用</title>
    <link href="https://www.sekyoro.top/2024/10/04/%E7%AA%97%E5%8F%A3%E5%B7%A5%E5%85%B7%E5%BA%93GLFW%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.sekyoro.top/2024/10/04/%E7%AA%97%E5%8F%A3%E5%B7%A5%E5%85%B7%E5%BA%93GLFW%E4%BD%BF%E7%94%A8/</id>
    <published>2024-10-04T11:53:18.000Z</published>
    <updated>2024-10-08T14:19:12.563Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用OpenGL或者Vulkan的图形库时经常使用一些窗口工具库搭配,常见的就是<a href="https://www.glfw.org/docs/latest/index.html">GLFW: Introduction</a>了,类似的有SDL,SFML和win32库,这里也会简单说一下. 这篇文章相当于GLFW的api介绍</p><span id="more"></span><p>SDL与SFML都是跨平台的多媒体库,除了创建窗口之外,还包括音视频库甚至网络库<a href="https://www.sfml-dev.org/tutorials/2.6/network-socket.php">sfml</a>和<a href="https://github.com/libsdl-org/SDL_net">SDL_net</a>,它们在不同平台上使用对应的库.比如SDL在windows上使用win32,使用direct3D作为图形库,在Linux上使用x11作为窗口系统,openGL作为图形库.</p><p><img data-src="https://s2.loli.net/2024/10/06/okrmt3QxWUaOfA2.png" alt="image-20241006121306560"></p><p>SFML可以将其视为面向对象的SDL,在windows上使用了gdi32+opengl32.而GLFW相对来说更纯粹,官网直接说是OpenGL的上下文管理器. </p><p><img data-src="https://s2.loli.net/2024/10/06/WK8hxcI5O9VMLzC.png" alt="image-20241006121554268"></p><p>类似SFML的还有<a href="https://www.fltk.org/">Fast Light Toolkit - Fast Light Toolkit (FLTK)</a></p><p>此外也有更上层imgui和raylib库,相当于同时包含了窗口管理和绘图等功能,raylib在windows和Linux上均使用GLFW和OpenGL<a href="https://github.com/raysan5/raylib/wiki/raylib-platforms-and-graphics">raylib platforms and graphics · raysan5/raylib Wiki (github.com)</a>,而imgui可以相对更自由地选择搭配.</p><p>此外我也看到有人提到<a href="https://skia.org/">Skia</a>,<a href="https://blend2d.com/">Blend2D</a>以及<a href="https://www.cairographics.org/">cairographics.org</a>,<a href="https://libyue.com/">Yue (libyue.com)</a>等等,它们是2D绘图库,相对使用opengl,d3d等更节省资源,本身可以创建上下文,也能与窗口结合</p><h2 id="GLFW"><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h2><p>GLFW目前GLFW版本到了3.0,下面是一个GLFW的经典流程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a windowed mode window and its OpenGL context */</span></span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the window&#x27;s context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Poll for and process events */</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="包含头文件"><a href="#包含头文件" class="headerlink" title="包含头文件"></a>包含头文件</h3><p>默认GLFW的头文件包括OpenGL头文件,但是版本可能比较老,一般使用一个loader library获取版本,比如glad. 如果包括了glad可以检测到从而不使用开发环境中的gl头文件.</p><blockquote><p>为了确保没有头冲突，您可以在GLFW头之前定义GLFW_INCLUDE_NONE，以显式禁用开发环境头的包含。这也允许以任何顺序包含两个头</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLFW_INCLUDE_NONE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/gl.h&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="初始化和停止GLFW"><a href="#初始化和停止GLFW" class="headerlink" title="初始化和停止GLFW"></a>初始化和停止GLFW</h3><p>在使用大多数GLFW函数之前，必须初始化库。初始化成功时，返回GLFW_TRUE。如果发生错误，则返回GLFW_FALSE</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!glfwInit())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Initialization failed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用完GLFW后，通常在应用程序退出之前，需要终止GLFW</p><p>这将终止所有剩余的窗口并释放由GLFW分配的任何其他资源。在此调用之后，在使用任何需要它的GLFW函数之前，必须再次初始化GLFW</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwTerminate();</span><br></pre></td></tr></table></figure><h3 id="设置错误处理"><a href="#设置错误处理" class="headerlink" title="设置错误处理"></a>设置错误处理</h3><p>大多数事件都是通过回调的，无论是按下的键、移动的GLFW窗口还是发生的错误。回调是由GLFW调用的带有描述事件的参数的C函数(或c++静态方法)</p><p>如果GLFW函数失败，则会向GLFW错误回调函数报告一个错误。您可以通过错误回调接收这些报告。此函数必须具有下面的签名，但可以执行其他回调中允许的任何操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_callback</span><span class="params">(<span class="keyword">int</span> error, <span class="keyword">const</span> <span class="keyword">char</span>* description)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: %s\n&quot;</span>, description);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须设置回调函数，这样GLFW才知道调用它们。设置错误回调的函数是少数几个可以在初始化之前调用的GLFW函数之一，它可以在初始化期间和之后通知错误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSetErrorCallback(error_callback);</span><br></pre></td></tr></table></figure><h3 id="创建与销毁窗口"><a href="#创建与销毁窗口" class="headerlink" title="创建与销毁窗口"></a>创建与销毁窗口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;My Title&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!window)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Window or OpenGL context creation failed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将创建一个带有OpenGL上下文的640 * 480窗口模式窗口。如果窗口或OpenGL上下文创建失败，将返回NULL。您应该始终检查返回值。虽然窗口创建很少失败，但上下文创建取决于正确安装的驱动程序，甚至在具有必要硬件的机器上也可能失败。</p><p>默认情况下，GLFW创建的OpenGL上下文可以有任何版本。可以通过在创建之前设置GLFW_CONTEXT_VERSION_MAJOR和GLFW_CONTEXT_VERSION_MINOR提示来要求最小OpenGL版本。如果机器上不支持所需的最低版本，则上下文(和窗口)创建失败</p><p>通过设置GLFW_OPENGL_PROFILE提示,可以选择OpenGL profile.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">GLFWwindow* window = glfwCreateWindow(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;My Title&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!window)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Window or context creation failed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们经常提到OpenGL上下文, <code>glfwCreateWindow</code>会返回窗口,这个窗口就相当于一个OpenGL上下文</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwDestroyWindow(window);</span><br></pre></td></tr></table></figure><p>一旦调用这个函数，就不会再为该窗口传递事件，并且它的句柄无效</p><h3 id="设置当前OpenGL上下文"><a href="#设置当前OpenGL上下文" class="headerlink" title="设置当前OpenGL上下文"></a>设置当前OpenGL上下文</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwMakeContextCurrent(window);</span><br></pre></td></tr></table></figure><p>该上下文将保持当前状态，直到将另一个上下文设置为当前状态，或者直到拥有当前上下文的窗口被销毁。</p><h3 id="检查窗口是否关闭"><a href="#检查窗口是否关闭" class="headerlink" title="检查窗口是否关闭"></a>检查窗口是否关闭</h3><p>每个窗口都有一个标志，指示该窗口是否应该关闭。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Keep running</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户试图关闭窗口时，通过按标题栏中的关闭小部件或使用像Alt+F4这样的组合键，该标志被设置为1。注意该窗口实际上并没有关闭，因此您应该监视该标志，并销毁该窗口或向用户提供某种反馈</p><p>当用户试图关闭窗口时，你可以通过使用glfwSetWindowCloseCallback设置一个关闭回调来得到通知。在关闭标志被设置后，回调函数将被立即调用。</p><h3 id="接受用户输入"><a href="#接受用户输入" class="headerlink" title="接受用户输入"></a>接受用户输入</h3><p>每个窗口都有大量的回调函数，可以将其设置为接收所有不同类型的事件。要接收按键按下和释放事件，需要创建按键回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">key_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> key, <span class="keyword">int</span> scancode, <span class="keyword">int</span> action, <span class="keyword">int</span> mods)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)</span><br><span class="line">        glfwSetWindowShouldClose(window, GLFW_TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置键盘回调</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSetKeyCallback(window, key_callback);</span><br></pre></td></tr></table></figure><h3 id="使用OpenGL渲染"><a href="#使用OpenGL渲染" class="headerlink" title="使用OpenGL渲染"></a>使用OpenGL渲染</h3><p>当有一个当前的OpenGL上下文，可以正常使用OpenGL</p><p>使用<code>glfwGetFramebufferSize</code>后去帧缓冲区大小,并为glViewport设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> width, height;</span><br><span class="line">glfwGetFramebufferSize(window, &amp;width, &amp;height);</span><br><span class="line">glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br></pre></td></tr></table></figure><h3 id="获得timer"><a href="#获得timer" class="headerlink" title="获得timer"></a>获得timer</h3><p>为了创建流畅的动画，需要一个时间源。GLFW提供了一个计时器，返回自初始化以来的秒数。所使用的时间源在每个平台上都是最精确的，通常具有微秒或纳秒分辨率</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> time = glfwGetTime();</span><br></pre></td></tr></table></figure><h3 id="交换缓冲区"><a href="#交换缓冲区" class="headerlink" title="交换缓冲区"></a>交换缓冲区</h3><p>默认情况下，GLFW窗口使用双缓冲。这意味着每个窗口都有两个渲染缓冲区;一个前缓冲，一个后缓冲。<strong>前缓冲区是要显示的缓冲区，后缓冲区是要渲染的缓冲区。</strong></p><p><strong>当整个帧被渲染后，缓冲区需要相互交换，所以后缓冲区变成前缓冲区</strong>，反之亦然</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSwapBuffers(window);</span><br></pre></td></tr></table></figure><p>交换间隔表示在交换缓冲区之前需要等待多少帧，通常称为vsync。默认情况下，交换间隔为零，这意味着缓冲区交换将立即发生。在快速的机器上，许多这些帧永远不会被看到，因为屏幕通常每秒只更新60-75次，所以这浪费了大量的CPU和GPU周期</p><blockquote><p>屏幕撕裂是视频显示中的视觉伪影，显示设备在单个屏幕绘制中显示来自多个帧的信息</p></blockquote><p>由于这些原因，应用程序通常希望将交换间隔设置为1。它可以设置为更高的值，但通常不建议这样做，因为它会导致输入延迟</p><h3 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h3><p>GLFW需要定期与窗口系统通信，以便接收事件并显示应用程序尚未锁定。事件处理必须在有可见窗口时定期执行，通常在缓冲区交换后的每一帧执行。</p><p>处理挂起事件有两种方法:<strong>轮询和等待</strong>。这个例子使用事件轮询，它只处理那些已经接收到的事件，然后立即返回。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwPollEvents()<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="使用GLAD"><a href="#使用GLAD" class="headerlink" title="使用GLAD"></a>使用GLAD</h3><p>如果不用glad,opengl版本就与装的动态库与使用的gl头文件相关,如果使用glad,就能根据版本选择对应版本的库</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gladLoadGL(glfwGetProcAddress);</span><br></pre></td></tr></table></figure><blockquote><p>一些老代码使用glfwGetProcAddress((GLADloadproc)glfwGetProcAddress)</p></blockquote><p>可以使用<code>gladLoadGL</code>,首先加载dll库,获取gl动态库中的<code>wglGetProcAddress</code>,得到这个函数方便获的gl的地址,调用<code>gladLoadGLLoader</code>传递<code>get_proc</code>,<code>get_proc</code>中调用类似<code>gladGetProcAddressPtr</code>,<code>GetProcAddress</code>操作获取对应的函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gladLoadGL</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(open_gl()) &#123;</span><br><span class="line">        status = gladLoadGLLoader(&amp;get_proc);</span><br><span class="line">        close_gl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_gl</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> IS_UWP</span></span><br><span class="line">    libGL = LoadLibraryW(<span class="string">L&quot;opengl32.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(libGL != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">void</span> (* tmp)(<span class="keyword">void</span>);</span><br><span class="line">        tmp = (<span class="keyword">void</span>(*)(<span class="keyword">void</span>)) GetProcAddress(libGL, <span class="string">&quot;wglGetProcAddress&quot;</span>);</span><br><span class="line">        gladGetProcAddressPtr = (PFNWGLGETPROCADDRESSPROC_PRIVATE) tmp;</span><br><span class="line">        <span class="keyword">return</span> gladGetProcAddressPtr != <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">get_proc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *namez)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* result = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(libGL == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(__APPLE__) &amp;&amp; !defined(__HAIKU__)</span></span><br><span class="line">    <span class="keyword">if</span>(gladGetProcAddressPtr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        result = gladGetProcAddressPtr(namez);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span>(result == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_WIN32) || defined(__CYGWIN__)</span></span><br><span class="line">        result = (<span class="keyword">void</span>*)GetProcAddress((HMODULE) libGL, namez);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        result = dlsym(libGL, namez);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>gladLoadGLLoader</code>中将利用刚才的<code>get_proc</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gladLoadGLLoader</span><span class="params">(GLADloadproc load)</span> </span>&#123;</span><br><span class="line">GLVersion.major = <span class="number">0</span>; GLVersion.minor = <span class="number">0</span>;</span><br><span class="line">glGetString = (PFNGLGETSTRINGPROC)load(<span class="string">&quot;glGetString&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(glGetString == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(glGetString(GL_VERSION) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">find_coreGL();</span><br><span class="line">load_GL_VERSION_1_0(load);</span><br><span class="line">load_GL_VERSION_1_1(load);</span><br><span class="line">load_GL_VERSION_1_2(load);</span><br><span class="line">load_GL_VERSION_1_3(load);</span><br><span class="line">load_GL_VERSION_1_4(load);</span><br><span class="line">load_GL_VERSION_1_5(load);</span><br><span class="line">load_GL_VERSION_2_0(load);</span><br><span class="line">load_GL_VERSION_2_1(load);</span><br><span class="line">load_GL_VERSION_3_0(load);</span><br><span class="line">load_GL_VERSION_3_1(load);</span><br><span class="line">load_GL_VERSION_3_2(load);</span><br><span class="line">load_GL_VERSION_3_3(load);</span><br><span class="line">load_GL_VERSION_4_0(load);</span><br><span class="line">load_GL_VERSION_4_1(load);</span><br><span class="line">load_GL_VERSION_4_2(load);</span><br><span class="line">load_GL_VERSION_4_3(load);</span><br><span class="line">load_GL_VERSION_4_4(load);</span><br><span class="line">load_GL_VERSION_4_5(load);</span><br><span class="line">load_GL_VERSION_4_6(load);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!find_extensionsGL()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> GLVersion.major != <span class="number">0</span> || GLVersion.minor != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PFNGLGETSTRINGPROC glad_glGetString = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> glGetString glad_glGetString</span></span><br></pre></td></tr></table></figure><p>首先获取gl获取版本的函数,然后根据版本加载</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">find_coreGL</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Thank you @elmindreda</span></span><br><span class="line"><span class="comment">     * https://github.com/elmindreda/greg/blob/master/templates/greg.c.in#L176</span></span><br><span class="line"><span class="comment">     * https://github.com/glfw/glfw/blob/master/src/context.c#L36</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> i, major, minor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* version;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* prefixes[] = &#123;</span><br><span class="line">        <span class="string">&quot;OpenGL ES-CM &quot;</span>,</span><br><span class="line">        <span class="string">&quot;OpenGL ES-CL &quot;</span>,</span><br><span class="line">        <span class="string">&quot;OpenGL ES &quot;</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    version = (<span class="keyword">const</span> <span class="keyword">char</span>*) glGetString(GL_VERSION);</span><br><span class="line">    <span class="keyword">if</span> (!version) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 根据获取到的版本,匹配对应的前缀,再加上</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;  prefixes[i];  i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> length = <span class="built_in">strlen</span>(prefixes[i]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(version, prefixes[i], length) == <span class="number">0</span>) &#123;</span><br><span class="line">            version += length;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* PR #18 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">    sscanf_s(version, <span class="string">&quot;%d.%d&quot;</span>, &amp;major, &amp;minor);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">sscanf</span>(version, <span class="string">&quot;%d.%d&quot;</span>, &amp;major, &amp;minor);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    GLVersion.major = major; GLVersion.minor = minor;</span><br><span class="line">    max_loaded_major = major; max_loaded_minor = minor;</span><br><span class="line">GLAD_GL_VERSION_1_0 = (major == <span class="number">1</span> &amp;&amp; minor &gt;= <span class="number">0</span>) || major &gt; <span class="number">1</span>;</span><br><span class="line">GLAD_GL_VERSION_1_1 = (major == <span class="number">1</span> &amp;&amp; minor &gt;= <span class="number">1</span>) || major &gt; <span class="number">1</span>;</span><br><span class="line">GLAD_GL_VERSION_1_2 = (major == <span class="number">1</span> &amp;&amp; minor &gt;= <span class="number">2</span>) || major &gt; <span class="number">1</span>;</span><br><span class="line">GLAD_GL_VERSION_1_3 = (major == <span class="number">1</span> &amp;&amp; minor &gt;= <span class="number">3</span>) || major &gt; <span class="number">1</span>;</span><br><span class="line">GLAD_GL_VERSION_1_4 = (major == <span class="number">1</span> &amp;&amp; minor &gt;= <span class="number">4</span>) || major &gt; <span class="number">1</span>;</span><br><span class="line">GLAD_GL_VERSION_1_5 = (major == <span class="number">1</span> &amp;&amp; minor &gt;= <span class="number">5</span>) || major &gt; <span class="number">1</span>;</span><br><span class="line">GLAD_GL_VERSION_2_0 = (major == <span class="number">2</span> &amp;&amp; minor &gt;= <span class="number">0</span>) || major &gt; <span class="number">2</span>;</span><br><span class="line">GLAD_GL_VERSION_2_1 = (major == <span class="number">2</span> &amp;&amp; minor &gt;= <span class="number">1</span>) || major &gt; <span class="number">2</span>;</span><br><span class="line">GLAD_GL_VERSION_3_0 = (major == <span class="number">3</span> &amp;&amp; minor &gt;= <span class="number">0</span>) || major &gt; <span class="number">3</span>;</span><br><span class="line">GLAD_GL_VERSION_3_1 = (major == <span class="number">3</span> &amp;&amp; minor &gt;= <span class="number">1</span>) || major &gt; <span class="number">3</span>;</span><br><span class="line">GLAD_GL_VERSION_3_2 = (major == <span class="number">3</span> &amp;&amp; minor &gt;= <span class="number">2</span>) || major &gt; <span class="number">3</span>;</span><br><span class="line">GLAD_GL_VERSION_3_3 = (major == <span class="number">3</span> &amp;&amp; minor &gt;= <span class="number">3</span>) || major &gt; <span class="number">3</span>;</span><br><span class="line">GLAD_GL_VERSION_4_0 = (major == <span class="number">4</span> &amp;&amp; minor &gt;= <span class="number">0</span>) || major &gt; <span class="number">4</span>;</span><br><span class="line">GLAD_GL_VERSION_4_1 = (major == <span class="number">4</span> &amp;&amp; minor &gt;= <span class="number">1</span>) || major &gt; <span class="number">4</span>;</span><br><span class="line">GLAD_GL_VERSION_4_2 = (major == <span class="number">4</span> &amp;&amp; minor &gt;= <span class="number">2</span>) || major &gt; <span class="number">4</span>;</span><br><span class="line">GLAD_GL_VERSION_4_3 = (major == <span class="number">4</span> &amp;&amp; minor &gt;= <span class="number">3</span>) || major &gt; <span class="number">4</span>;</span><br><span class="line">GLAD_GL_VERSION_4_4 = (major == <span class="number">4</span> &amp;&amp; minor &gt;= <span class="number">4</span>) || major &gt; <span class="number">4</span>;</span><br><span class="line">GLAD_GL_VERSION_4_5 = (major == <span class="number">4</span> &amp;&amp; minor &gt;= <span class="number">5</span>) || major &gt; <span class="number">4</span>;</span><br><span class="line">GLAD_GL_VERSION_4_6 = (major == <span class="number">4</span> &amp;&amp; minor &gt;= <span class="number">6</span>) || major &gt; <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span> (GLVersion.major &gt; <span class="number">4</span> || (GLVersion.major &gt;= <span class="number">4</span> &amp;&amp; GLVersion.minor &gt;= <span class="number">6</span>)) &#123;</span><br><span class="line">max_loaded_major = <span class="number">4</span>;</span><br><span class="line">max_loaded_minor = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果版本大于某个大版本,会加载对应的函数,也就是说1.0加载的东西,在1.1的函数中就不会有了,文件中定义了许多函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(APIENTRYP PFNGLGENSAMPLERSPROC)</span><span class="params">(GLsizei count, GLuint *samplers)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(APIENTRYP PFNGLGENTRANSFORMFEEDBACKSPROC)</span><span class="params">(GLsizei n, GLuint *ids)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(APIENTRYP PFNGLGENVERTEXARRAYSPROC)</span><span class="params">(GLsizei n, GLuint *arrays)</span></span>;</span><br><span class="line">PFNGLGENTEXTURESPROC glad_glGenTextures = <span class="literal">NULL</span>;</span><br><span class="line">PFNGLGENTRANSFORMFEEDBACKSPROC glad_glGenTransformFeedbacks = <span class="literal">NULL</span>;</span><br><span class="line">PFNGLGENVERTEXARRAYSPROC glad_glGenVertexArrays = <span class="literal">NULL</span>;</span><br><span class="line">PFNGLGENERATEMIPMAPPROC glad_glGenerateMipmap = <span class="literal">NULL</span>;</span><br><span class="line">PFNGLGENERATETEXTUREMIPMAPPROC glad_glGenerateTextureMipmap = <span class="literal">NULL</span>;</span><br><span class="line">PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC glad_glGetActiveAtomicCounterBufferiv = <span class="literal">NULL</span>;</span><br><span class="line">PFNGLGETACTIVEATTRIBPROC glad_glGetActiveAttrib = <span class="literal">NULL</span>;</span><br><span class="line">PFNGLGETACTIVESUBROUTINENAMEPROC glad_glGetActiveSubroutineName = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>当加载完毕后即可直接使用glad_xx调用glxx库.</p><blockquote><p>glad相当于在知道使用的gl.dll版本之后加载相应版本所有的头文件,加载后即可使用gladxx,而原本的gl头文件实际上就不需要了(除非你还需要在代码中直接使用gl头文件)</p></blockquote><p><img data-src="https://s2.loli.net/2024/10/05/1KpBUDEAqzQlGYn.png" alt="image-20241005230313466"></p><p>在<code>glad.h</code>中如果之前定义了<code>__gl_h_</code>宏,那就会报错,否则自己会定义一个<code>__gl_h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// glad.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __glad_h_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __glad_h_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __gl_h_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> OpenGL header already included, remove this <span class="meta-keyword">include</span>, glad already provides it</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __gl_h_</span></span><br></pre></td></tr></table></figure><p>而在<code>gl.h</code>中,定义了这个宏,表明使用glad并不需要引入gl头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gl.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __gl_h_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __GL_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __gl_h_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __GL_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winapifamily.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>而在<code>glfw3.h</code>中也说明了如果定义了<code>__gl_h_</code>,就不需要再引入头文件了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> !defined(GLFW_INCLUDE_NONE) &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gl_h_) &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gles1_gl_h_) &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gles2_gl2_h_) &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gles2_gl3_h_) &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gles2_gl31_h_) &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gles2_gl32_h_) &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gl_glcorearb_h_) &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gl2_h_) <span class="comment">/*legacy*/</span> &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gl3_h_) <span class="comment">/*legacy*/</span> &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gl31_h_) <span class="comment">/*legacy*/</span> &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gl32_h_) <span class="comment">/*legacy*/</span> &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__glcorearb_h_) <span class="comment">/*legacy*/</span> &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__GL_H__) <span class="comment">/*non-standard*/</span> &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gltypes_h_) <span class="comment">/*non-standard*/</span> &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__glee_h_) <span class="comment">/*non-standard*/</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__)</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> !defined(GLFW_INCLUDE_GLEXT)</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> GL_GLEXT_LEGACY</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;OpenGL/gl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/*__APPLE__*/</span></span></span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/gl.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> defined(GLFW_INCLUDE_GLEXT)</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glext.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/*__APPLE__*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* OpenGL and OpenGL ES headers */</span></span></span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在调用大多数GLFW函数之前，必须初始化库。这个初始化<strong>检查机器上可用的特性、显示器</strong>、<strong>初始化计时器</strong>并执行任何所需的<strong>特定于平台的初始化</strong>。</p><p>在调用<code>glfwInit</code>之前可以调用一些函数,比如获取版本,平台支持,设置错误处理回调等.</p><ul><li><a href="https://www.glfw.org/docs/latest/group__init.html#ga9f8ffaacf3c269cc48eafbf8b9b71197">glfwGetVersion</a></li><li><a href="https://www.glfw.org/docs/latest/group__init.html#ga026abd003c8e6501981ab1662062f1c0">glfwGetVersionString</a></li><li><a href="https://www.glfw.org/docs/latest/group__init.html#ga8785d2b6b36632368d803e78079d38ed">glfwPlatformSupported</a></li><li><a href="https://www.glfw.org/docs/latest/group__init.html#ga944986b4ec0b928d488141f92982aa18">glfwGetError</a></li><li><a href="https://www.glfw.org/docs/latest/group__init.html#gaff45816610d53f0b83656092a4034f40">glfwSetErrorCallback</a></li><li><a href="https://www.glfw.org/docs/latest/group__init.html#ga110fd1d3f0412822b4f1908c026f724a">glfwInitHint</a></li><li><a href="https://www.glfw.org/docs/latest/group__init.html#ga9dde93e9891fa7dd17e4194c9f3ae7c6">glfwInitAllocator</a></li><li><a href="https://www.glfw.org/docs/latest/group__init.html#ga76af552d0307bb5f7791f245417d4752">glfwInitVulkanLoader</a></li><li><a href="https://www.glfw.org/docs/latest/group__init.html#ga317aac130a235ab08c6db0834907d85e">glfwInit</a></li><li><a href="https://www.glfw.org/docs/latest/group__init.html#gaaae48c0a18607ea4a4ba951d939f0901">glfwTerminate</a></li></ul><h3 id="hints"><a href="#hints" class="headerlink" title="hints"></a>hints</h3><p>hints用于设置GLFW,包括共享/通用的hints以及platform-specific的hints.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glfwInitHint(GLFW_JOYSTICK_HAT_BUTTONS, GLFW_FALSE);</span><br><span class="line">glfwInitHint(GLFW_PLATFORM, GLFW_PLATFORM_X11);</span><br></pre></td></tr></table></figure><h3 id="自定义内存分配器"><a href="#自定义内存分配器" class="headerlink" title="自定义内存分配器"></a>自定义内存分配器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GLFWallocator allocator;</span><br><span class="line">allocator.allocate = my_malloc;</span><br><span class="line">allocator.reallocate = my_realloc;</span><br><span class="line">allocator.deallocate = my_free;</span><br><span class="line">allocator.user = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">glfwInitAllocator(&amp;allocator);</span><br></pre></td></tr></table></figure><h3 id="设置错误处理-1"><a href="#设置错误处理-1" class="headerlink" title="设置错误处理"></a>设置错误处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> code = glfwGetError(<span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (code != GLFW_NO_ERROR)</span><br><span class="line">    handle_error(code);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">glfwSetErrorCallback(error_callback);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_callback</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">const</span> <span class="keyword">char</span>* description)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    display_error_message(code, description);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>只要GLFW成功初始化，无论发生多少错误，它都将保持初始化并处于安全状态，直到终止。如果在初始化过程中发生错误导致glfwInit失败，则初始化库的任何部分都将被安全终止</p><h3 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h3><p>GLFW有两个主要的坐标系统,虚拟屏幕和窗口内容区域.</p><p><img data-src="https://s2.loli.net/2024/10/08/RwYs2HjEdPLDOiu.png" alt="image-20241008191903556"></p><p>​    虚拟屏幕和内容区域坐标系统的x轴指向右,y轴指向下.</p><p>​    窗口和显示器的位置指定为其内容区域的左上角相对于虚拟屏幕的位置，而光标的位置指定为相对于窗口的内容区域的位置</p><p>​    由于窗口的内容区域坐标系统的原点也是指定窗口位置的点，因此可以通过添加窗口位置将内容区域坐标转换为虚拟屏幕。当窗口frame出现时，它从内容区域向外延伸，但不影响窗口位置</p><p>​    GLFW中几乎所有的位置和大小都是以相对于上述两个原点之一的屏幕坐标来测量的。这包括光标位置、窗口位置和大小、窗口frame大小、显示器位置和视频分辨率.</p><p>​    显示器的物理大小以毫米为单位和帧缓冲区大小(以像素为单位)。</p><p>​    像素和屏幕坐标在一些机器上可能是1:1的映射，但在其他机器上就不一定了，比如在带有Retina显示屏的Mac上dpr是2:1。屏幕坐标和像素之间的比率也可能在运行时改变，这取决于窗口当前被认为在哪个显示器上</p><h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><p>窗口对象封装了顶级窗口和OpenGL或OpenGL ES上下文。它是用glfwCreateWindow创建的，用glfwDestroyWindow或glfwTerminate销毁</p><p>由于窗口和上下文是不可分割地联系在一起的，窗口对象也充当上下文句柄。</p><h3 id="设置窗口的一些属性"><a href="#设置窗口的一些属性" class="headerlink" title="设置窗口的一些属性"></a>设置窗口的一些属性</h3><p>想像一下,一个窗口能有哪些东西? 标题,显示器,位置,大小,是否透明,最小化,最大化,焦点,图标. 这些属性有些可以使用hints设置,有些有单独的函数设置,还可以使用<code>glfwSetWindowAttrib</code>设置.</p><p>需要注意的是Framebuffer size和window size,window size是虚拟屏幕坐标,而framebuffer size是pixel,适合使用glviewport</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> width, height;</span><br><span class="line">glfwGetFramebufferSize(window, &amp;width, &amp;height);</span><br><span class="line">glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br></pre></td></tr></table></figure><h3 id="窗口属性"><a href="#窗口属性" class="headerlink" title="窗口属性"></a>窗口属性</h3><p>Windows有许多属性可以使用glfwGetWindowAttrib返回。一些反映了可能由于用户交互而改变的状态(例如是否有输入焦点)，而另一些反映了窗口的固有属性(例如它有什么样的边界)。一些与窗口相关，另一些与OpenGL或OpenGL ES上下文相关</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (glfwGetWindowAttrib(window, GLFW_FOCUSED))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// window has input focus</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glfwSetWindowAttrib(window, GLFW_RESIZABLE, GLFW_FALSE);</span><br></pre></td></tr></table></figure><h3 id="buffer交换"><a href="#buffer交换" class="headerlink" title="buffer交换"></a>buffer交换</h3><p>默认情况下，GLFW窗口是双缓冲的。这意味着有两个渲染缓冲区;一个前缓冲，一个后缓冲。前缓冲区是要显示的缓冲区，后缓冲区是要渲染的缓冲区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSwapBuffers(window);</span><br></pre></td></tr></table></figure><p>选择何时进行缓冲区交换是很有用的。使用函数glfwSwapInterval，可以选择驱动程序在交换缓冲区之前从调用glfwSwapBuffers开始应该等待的监视器刷新的最小次数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSwapInterval(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>如果间隔为零，则在调用glfwSwapBuffers时立即进行交换，而无需等待刷新。否则，每次缓冲区交换之间至少会传递间隔回溯。当不希望测量等待垂直回溯所需的时间时，使用零交换间隔对基准测试很有用。但是，交换间隔为1可以避免撕裂</p><h2 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h2><p>当使用glfwCreateWindow创建一个窗口和它的OpenGL或OpenGL ES上下文时，可以指定另一个窗口，它的上下文应该与新窗口共享它的对象(纹理，顶点和元素缓冲区等)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLFWwindow* second_window = glfwCreateWindow(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;Second Window&quot;</span>, <span class="literal">NULL</span>, first_window);</span><br></pre></td></tr></table></figure><p>在你进行OpenGL或OpenGL ES调用之前，需要有一个正确类型的当前上下文。一个上下文一次只能对一个线程是当前的，而一个线程一次只能有一个当前的上下文</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glfwMakeContextCurrent(window);</span><br><span class="line">GLFWwindow* window = glfwGetCurrentContext();</span><br></pre></td></tr></table></figure><h3 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h3><p>显示器对象表示当前连接的显示器，并表示为指向不透明类型GLFWmonitor的指针。显示器对象不能由应用程序创建或销毁，并保留其地址，直到它们所代表的显示器断开连接或直到库终止</p><p>每个显示器都有一个当前视频模式，一个支持的视频模式列表，一个虚拟位置，一个人类可读的名称，一个估计的物理尺寸和一个gamma ramp。其中一个监控器是主监控器.显示器的虚拟位置以屏幕坐标表示,并与当前视频模式一起描述了连接的显示器提供给跨越它们的虚拟桌面的视口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GLFWmonitor* primary = glfwPrimaryMonitor();</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">GLFWmonitor** monitors = glfwGetMonitors(&amp;count);</span><br></pre></td></tr></table></figure><h4 id="显示器配置改变"><a href="#显示器配置改变" class="headerlink" title="显示器配置改变"></a>显示器配置改变</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">glfwSetMonitorCallback(monitor_callback);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">monitor_callback</span><span class="params">(GLFWmonitor* monitor, <span class="keyword">int</span> event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event == GLFW_CONNECTED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The monitor was connected</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event == GLFW_DISCONNECTED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The monitor was disconnected</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="显示器属性"><a href="#显示器属性" class="headerlink" title="显示器属性"></a>显示器属性</h4><p>当创建一个全屏窗口时,改变它的视频模式或使窗口成为一个全屏,GLFW通常会很好地选择一个合适的视频模式,但有时确切地知道支持哪些视频模式是有用的。</p><p>视频模式表示为GLFWvidmode结构。您可以使用glfwGetVideoModes获得监视器支持的视频模式数组。有关返回数组的生命周期</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">GLFWvidmode* modes = glfwGetVideoModes(monitor, &amp;count);</span><br><span class="line"><span class="keyword">const</span> GLFWvidmode* mode = glfwGetVideoMode(monitor);</span><br></pre></td></tr></table></figure><p>监视器的物理尺寸(以毫米为单位)或其估计值可以使用glfwGetMonitorPhysicalSize来检索。这与当前分辨率无关</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> width_mm, height_mm;</span><br><span class="line">glfwGetMonitorPhysicalSize(monitor, &amp;width_mm, &amp;height_mm);</span><br></pre></td></tr></table></figure><p>可以使用glfwGetMonitorPos获取监视器在虚拟桌面上的位置(以屏幕坐标表示)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> xpos, ypos;</span><br><span class="line">glfwGetMonitorPos(monitor, &amp;xpos, &amp;ypos);</span><br></pre></td></tr></table></figure><p>未被全局任务栏或菜单栏占用的监视器区域是工作区域。这是在屏幕坐标中指定的，可以使用glfwGetMonitorWorkarea进行检索</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> xpos, ypos, width, height;</span><br><span class="line">glfwGetMonitorWorkarea(monitor, &amp;xpos, &amp;ypos, &amp;width, &amp;height);</span><br></pre></td></tr></table></figure><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>GLFW提供多种输入。虽然有些只能轮询，如时间，或只能通过回调接收，如滚动，但许多同时提供回调和轮询。回调要比轮询做更多的工作，但CPU密集程度较低，并保证不会错过状态更改</p><p>所有输入回调都接收一个窗口句柄。通过使用窗口用户指针，您可以从回调中访问非全局结构或对象。</p><h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><p>GLFW需要轮询窗口系统的事件，以便向应用程序提供输入，并向窗口系统证明应用程序没有锁定。事件处理通常在缓冲区交换后的每一帧完成。即使没有窗口，也需要进行事件轮询，以便接收监视器和操纵杆连接事件</p><p>有三个函数用于处理挂起事件</p><p>glfwPollEvents，只处理那些已经接收到的事件，然后立即返回。</p><p>如果只需要在接收新输入时更新窗口的内容，那么glfwWaitEvents是更好的选择</p><p>它将线程置于睡眠状态，直到至少接收到一个事件，然后处理所有接收到的事件。这节省了大量的CPU周期，并且对于编辑工具等非常有用。</p><p>如果你想等待事件，但有UI元素或其他需要定期更新的任务,glfwWaitEventsTimeout允许你指定一个超时。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwWaitEventsTimeout(<span class="number">0.7</span>);</span><br></pre></td></tr></table></figure><p>如果主线程在glfwWaitEvents中休眠，可以通过使用glfwPostEmptyEvent向事件队列发送一个空事件来从另一个线程唤醒它</p><p>不要假设回调只会在响应上述函数时被调用。虽然有必要以上述一种或多种方式处理事件，但需要GLFW注册其自身回调的窗口系统可以将事件传递给GLFW以响应许多窗口系统函数调用。GLFW将在返回之前将这些事件传递给应用程序回调</p><h4 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h4><p>GLFW将键盘输入分为两类;关键事件和角色事件。键事件与实际的物理键盘键有关，而字符事件与按下其中一些键产生的文本有关</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> key, <span class="keyword">int</span> scancode, <span class="keyword">int</span> action, <span class="keyword">int</span> mods)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == GLFW_KEY_E &amp;&amp; action == GLFW_PRESS)</span><br><span class="line">        activate_airship();</span><br><span class="line">&#125;</span><br><span class="line">glfwSetKeyCallback(window, key_callback);</span><br></pre></td></tr></table></figure><p>GLFW支持由操作系统文本输入系统生成的Unicode码点流形式的文本输入。与按键输入不同，文本输入受键盘布局和修改键的影响</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">character_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">unsigned</span> <span class="keyword">int</span> codepoint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">glfwSetCharCallback(window, character_callback);</span><br></pre></td></tr></table></figure><h4 id="鼠标输入"><a href="#鼠标输入" class="headerlink" title="鼠标输入"></a>鼠标输入</h4><p>鼠标输入有多种形式，包括鼠标移动、按钮按压和滚动偏移。还可以更改光标的外观，将其更改为自定义图像或来自系统主题的标准光标形状</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> xpos, ypos;</span><br><span class="line">glfwGetCursorPos(window, &amp;xpos, &amp;ypos);</span><br><span class="line">glfwSetCursorPosCallback(window, cursor_position_callback);</span><br></pre></td></tr></table></figure><p>回调函数接收光标位置，以屏幕坐标测量，但相对于窗口内容区域的左上角。。</p><p>如果希望实现基于鼠标运动的相机控制或其他需要无限制鼠标移动的输入方案，请将光标模式设置为<code>GLFW_CURSOR_DISABLED</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</span><br></pre></td></tr></table></figure><p>这将隐藏光标并将其锁定到指定的窗口。然后，GLFW将处理光标重新居中和偏移计算的所有细节，并为应用程序提供虚拟光标位置。这个虚拟位置通常通过回调和轮询提供。原始鼠标运动更接近鼠标在表面上的实际运动。它不受应用于桌面光标运动的缩放和加速的影响。这种处理适合于光标，而原始运动更适合于控制，例如3D相机。因此，仅在禁用光标时才提供原始鼠标运动</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (glfwRawMouseMotionSupported())</span><br><span class="line">    glfwSetInputMode(window, GLFW_RAW_MOUSE_MOTION, GLFW_TRUE);</span><br></pre></td></tr></table></figure><p>使用glfwCreateCursor创建自定义鼠标，它返回创建的鼠标对象的句柄</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> pixels[<span class="number">16</span> * <span class="number">16</span> * <span class="number">4</span>];</span><br><span class="line"><span class="built_in">memset</span>(pixels, <span class="number">0xff</span>, <span class="keyword">sizeof</span>(pixels));</span><br><span class="line"> </span><br><span class="line">GLFWimage image;</span><br><span class="line">image.width = <span class="number">16</span>;</span><br><span class="line">image.height = <span class="number">16</span>;</span><br><span class="line">image.pixels = pixels;</span><br><span class="line"> </span><br><span class="line">GLFWcursor* cursor = glfwCreateCursor(&amp;image, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>可以使用glfwCreateStandardCursor创建当前系统游标主题中具有标准形状的游标</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLFWcursor* url_cursor = glfwCreateStandardCursor(GLFW_POINTING_HAND_CURSOR);</span><br></pre></td></tr></table></figure><p>如果希望在光标进入或离开窗口的内容区域时得到通知设置光标进入/离开回调</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cursor_enter_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> entered)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (entered)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The cursor entered the content area of the window</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The cursor left the content area of the window</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">glfwSetCursorEnterCallback(window, cursor_enter_callback);</span><br></pre></td></tr></table></figure><p>可以查询鼠标当前是否在具有glfw_hoved窗口属性的窗口的内容区域内</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (glfwGetWindowAttrib(window, GLFW_HOVERED))</span><br><span class="line">&#123;</span><br><span class="line">    highlight_interface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="鼠标按钮输入"><a href="#鼠标按钮输入" class="headerlink" title="鼠标按钮输入"></a>鼠标按钮输入</h4><p>如果希望在鼠标按钮被按下或释放时收到通知设置鼠标按钮回调</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSetMouseButtonCallback(window, mouse_button_callback);</span><br></pre></td></tr></table></figure><p>回调函数接收鼠标按钮、按钮动作和修饰符位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse_button_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> button, <span class="keyword">int</span> action, <span class="keyword">int</span> mods)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (button == GLFW_MOUSE_BUTTON_RIGHT &amp;&amp; action == GLFW_PRESS)</span><br><span class="line">        popup_menu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个受支持的鼠标按钮的最后状态也保存在每个窗口状态数组中，可以使用glfwGetMouseButton轮询。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> state = glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT);</span><br><span class="line"><span class="keyword">if</span> (state == GLFW_PRESS)</span><br><span class="line">&#123;</span><br><span class="line">    upgrade_cow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glfw<span class="constructor">SetScrollCallback(<span class="params">window</span>, <span class="params">scroll_callback</span>)</span>;</span><br><span class="line">void scroll<span class="constructor">_callback(GLFWwindow<span class="operator">*</span> <span class="params">window</span>, <span class="params">double</span> <span class="params">xoffset</span>, <span class="params">double</span> <span class="params">yoffset</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通的鼠标滚轮是垂直的，它提供沿y轴的偏移量</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.如何在windows上去掉启动时出现的控制台(使用vs或cmake)<a href="https://stackoverflow.com/questions/5995433/removing-console-window-for-glut-freeglut-glfw">c++ - Removing console window for Glut/FreeGlut/GLFW? - Stack Overflow</a><a href="https://stackoverflow.com/questions/78704285/how-do-i-remove-the-console-window-in-a-c-application-in-visual-studio">How do I remove the console window in a C++ application in Visual Studio? - Stack Overflow</a> 但是似乎只对cl.exe也就是MSVC管用,无法跨平台了,只能针对不同平台分别编译,gcc/clang(但测试了貌似不管用)可以使用<code>-mwindows</code><a href="https://discourse.glfw.org/t/eliminate-shell-window/354/2">Eliminate shell window? - support - GLFW</a></p><p>在vs上在配置属性,链接器,系统上修改subsystem以及高级中的entry point</p><p>设置应用为窗口应用,由于它默认需要wmain函数而不是main函数,还需要修改入口函数为main<a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/entry-entry-point-symbol?view=msvc-170">/ENTRY（入口点符号） | Microsoft Learn</a>.</p><p><img data-src="https://s2.loli.net/2024/10/06/l5MFVcaY4thObmx.png" alt="image-20241006151255023"></p><p><img data-src="https://s2.loli.net/2024/10/06/8jMH3BaLvzRJwEl.png" alt="image-20241006151328843"></p><p>在cmake上类似,但需要使用<code>clang-cl.exe</code>(而不是clang.exe),<code>msvc</code>作为generator(不能是其他的).</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_HOST_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Windows&quot;</span> <span class="keyword">AND</span> CMAKE_CXX_COMPILER_ID <span class="keyword">STREQUAL</span> <span class="string">&quot;MSVC&quot;</span>)</span><br><span class="line">    <span class="keyword">target_link_options</span>(learn_gl PRIVATE  /SUBSYSTEM:WINDOWS /ENTRY:mainCRTStartup)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="comment"># 或者使用set_target_properties(exe_name PROPERTIES </span></span><br><span class="line">    LINK_FLAGS <span class="string">&quot;/ENTRY:mainCRTStartup /SUBSYSTEM:WINDOWS&quot;</span>)</span><br></pre></td></tr></table></figure><p>或者在源文件中添加如下<a href="https://stackoverflow.com/questions/11785157/replacing-winmain-with-main-function-in-win32-programs/11785733#11785733">c++ - Replacing WinMain() with main() function in Win32 programs - Stack Overflow</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/subsystem:windows /ENTRY:mainCRTStartup&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>一个问题是使用了vs作为generator,目前无法生成clangd的compile_commands.json了<a href="https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html">CMAKE_EXPORT_COMPILE_COMMANDS — CMake 3.30.4 Documentation</a>,那就不使用cland使用微软的c++工具用于代码搜索、跳转.</p><p><a href="https://zhuanlan.zhihu.com/p/635410959">C++轻量级跨平台桌面GUI库FLTK的简单使用 - 知乎 (zhihu.com)</a>介绍了一些现有的跨平台桌面库</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用OpenGL或者Vulkan的图形库时经常使用一些窗口工具库搭配,常见的就是&lt;a href=&quot;https://www.glfw.org/docs/latest/index.html&quot;&gt;GLFW: Introduction&lt;/a&gt;了,类似的有SDL,SFML和win32库,这里也会简单说一下. 这篇文章相当于GLFW的api介绍&lt;/p&gt;</summary>
    
    
    
    
    <category term="window library" scheme="https://www.sekyoro.top/tags/window-library/"/>
    
  </entry>
  
  <entry>
    <title>链接动态库在不同操作系统上的行为</title>
    <link href="https://www.sekyoro.top/2024/10/04/%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E5%BA%93%E5%9C%A8%E4%B8%8D%E5%90%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E8%A1%8C%E4%B8%BA/"/>
    <id>https://www.sekyoro.top/2024/10/04/%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E5%BA%93%E5%9C%A8%E4%B8%8D%E5%90%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E8%A1%8C%E4%B8%BA/</id>
    <published>2024-10-04T03:23:29.000Z</published>
    <updated>2024-10-04T09:22:57.518Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>想必很多人已经了解了动态库与静态库,在实际开发中也经常使用. 但是,有必要了解在windows和Linux上开发c++程序生成和链接动态库的不同行为,因为经常混淆或者自以为找到了动态库,这里简单学习并澄清一下.其中许多内容来自官方文档<br><span id="more"></span></p><p>在linux上静态库常常以.a结尾,动态库以.so结尾,而windows上分别以.lib与.dll结尾. 于是很多人就把.dll等同于.so使用了,但其实并不一样. </p><h2 id="编译与链接静态库"><a href="#编译与链接静态库" class="headerlink" title="编译与链接静态库"></a>编译与链接静态库</h2><p><strong>生成动态库</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC -o libfoo.so foo.c</span><br></pre></td></tr></table></figure><p><strong>生成静态库</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o libfoo.o foo.c -I include </span><br><span class="line">ar cr libfoo.a libfoo.o</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td><strong>-ggdb</strong></td><td>此选项将尽可能的生成 gdb 的可以使用的调试信息.</td></tr><tr><td>-l [lib]</td><td>（这里是小写的L,命令无中括号,下同）指定程序要链接的库,[lib]为库文件名称.如果gcc编译选项中加入了“-static”表示寻找静态库文件</td></tr><tr><td>-L [dir]</td><td>指定-l（小写-L）所使用到的库文件所在路径(链接时而非动态查找),不然编译器将只在标准库的目录找</td></tr><tr><td>-I [dir]</td><td>（这里是大写的I）增加 include 头文件路径</td></tr><tr><td>-static</td><td>链接静态库生成目标文件,禁止使用动态库（在支持动态链接的系统上） 所以编译出来的东西一般都很大,也不需要什么动态连接库就可以运行.</td></tr><tr><td>-shared</td><td>生成共享文件,可以与其它文件链接生成可执行文件</td></tr><tr><td>-fpic</td><td>生成适用于共享库的<strong>与地址无关的代码</strong>（PIC）（如果机器支持的话）</td></tr><tr><td>-fPIC</td><td>生成<strong>与位置无关的的代码</strong>,适用于使用动态库,与“-fpic”的区别在于去除去全局偏移表的任何限制（如果机器支持的话）</td></tr></tbody></table></div><p>链接动态库和链接静态库差别不大,但是需要设置一些路径方便linux查找.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c -I/home/alice/foo -lfoo</span><br></pre></td></tr></table></figure><blockquote><p>如果静态库和动态库在同一目录并且前缀相同,e.g. libxx.so和libxx.a,使用<code>g++ -o main main.cpp -L build/lib -l xx -I lib/include</code>会默认链接动态库,添加<code>-static</code>可解决(不过一般也不会同时把动态库和静态库同名放一个目录吧😅)</p></blockquote><p>gcc <code>-L</code> <code>-l</code>含义是什么,不管是动态库还是链接库,如果使用了库,都需要使用<code>-L</code>和<code>-l</code>进行编译时链接,如果是静态库,<code>-l</code>往往就够了,但如果是动态库,<code>-l</code>作用是在编译时让编译器直到用到了库中的某些东西存在,但是运行时还需要另外设置,如果链接动态库不使用<code>-l</code>也会报错</p><p><img data-src="https://s2.loli.net/2024/10/04/w37nS5PECGmVyjc.png" alt="image-20241004132437629"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o main main.cpp   ./build/lib/libdy_lib.so -I lib/include</span><br></pre></td></tr></table></figure><p>或者直接使用<code>.so</code>与<code>.cpp</code>编译链接,注意这在windows上行不通,根本原因是动态库的路径搜索方式不同</p><p>文件一多,项目一大肯定需要使用构建系统的,包括make,Ninja,MSBuilg等等,而cmake就是生成这些构建系统的,当使用cmake时就没有太大必要考虑编译器细节了.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成</span></span><br><span class="line"><span class="keyword">add_library</span>(dy_lib STATIC <span class="keyword">test</span>.cpp)</span><br><span class="line"><span class="comment"># add_library(dy_lib SHARED test.cpp)</span></span><br><span class="line"><span class="comment"># 链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(cpp_test PRIVATE dy_lib)</span><br></pre></td></tr></table></figure><h3 id="链接动态库在cmake中的行为"><a href="#链接动态库在cmake中的行为" class="headerlink" title="链接动态库在cmake中的行为"></a>链接动态库在cmake中的行为</h3><p>RPATH在开发过程中很有用,因为可以将构建树中的库链接到可执行文件中.CMake提供了相当多的选项来优化构建树链接和安装链接期间的行为</p><p>我们知道要使用动态库,光是<code>-l</code>是不行的,在windows上需要看链接方式(下面详细介绍),在linux上也要设置动态库搜索路径. 使用cmake时链接动态库,cmake会默认设置buil_rpath,但安装时使用install_rpath<a href="https://cmake.org/cmake/help/latest/prop_tgt/BUILD_RPATH.html">BUILD_RPATH — CMake 3.30.4 Documentation</a></p><p><strong>BUILD_PATH</strong></p><p>一个分号分隔的列表,指定要添加到构建树中链接的二进制文件中的运行时路径(RPATH)条目(对于支持它的平台).默认情况下,CMake在构建树中设置二进制文件的运行时路径,以包含它知道需要查找它们链接的共享库的搜索路径.项目可以设置BUILD_RPATH来指定额外的搜索路径.</p><ul><li>The <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_SKIP_RPATH.html#variable:CMAKE_SKIP_RPATH"><code>CMAKE_SKIP_RPATH</code></a> variable completely disables runtime paths in both the build tree and install tree.</li><li>The <a href="https://cmake.org/cmake/help/latest/prop_tgt/SKIP_BUILD_RPATH.html#prop_tgt:SKIP_BUILD_RPATH"><code>SKIP_BUILD_RPATH</code></a> target property disables setting any runtime path in the build tree.</li><li>The <a href="https://cmake.org/cmake/help/latest/prop_tgt/BUILD_RPATH_USE_ORIGIN.html#prop_tgt:BUILD_RPATH_USE_ORIGIN"><code>BUILD_RPATH_USE_ORIGIN</code></a> target property causes the automatically-generated runtime path to use entries relative to <code>$ORIGIN</code>.</li><li>The <a href="https://cmake.org/cmake/help/latest/prop_tgt/BUILD_WITH_INSTALL_RPATH.html#prop_tgt:BUILD_WITH_INSTALL_RPATH"><code>BUILD_WITH_INSTALL_RPATH</code></a> target property causes binaries in the build tree to be built with the install-tree runtime path.</li></ul><p>下面是默认设置.默认情况下,如果不更改任何 RPATH 相关设置,CMake 将以完整的 RPATH 连接可执行文件和共享库,并将其连接到联编树中所有使用过的库.安装时,它会清除这些目标的 RPATH,因此它们在安装时的 RPATH 为空</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># use, i.e. don&#x27;t skip the full RPATH for the build tree</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_SKIP_BUILD_RPATH <span class="keyword">FALSE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># when building, don&#x27;t use the install RPATH already</span></span><br><span class="line"><span class="comment"># (but later on when installing)</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_WITH_INSTALL_RPATH <span class="keyword">FALSE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># the RPATH to be used when installing</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_RPATH <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># don&#x27;t add the automatically determined parts of the RPATH</span></span><br><span class="line"><span class="comment"># which point to directories outside the build tree to the install RPATH</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_RPATH_USE_LINK_PATH <span class="keyword">FALSE</span>)</span><br></pre></td></tr></table></figure><p>也就是说cmake在build时默认添加在build目录下使用的动态库路径,在安装库时rpath默认为空</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>在Linux系统中,动态链接器（如ld-linux.so）负责在应用程序启动时解析其依赖的共享库.动态链接器根据一定的搜索顺序来查找这些共享库,这个顺序通常包括：</p><ol><li><strong>RPATH</strong>：如果可执行文件中指定了RPATH,动态链接器会首先在这个路径下搜索共享库.</li><li><strong>LD_LIBRARY_PATH</strong>：如果未找到所需的库,动态链接器会继续在由环境变量LD_LIBRARY_PATH指定的目录中搜索.</li><li>配置文件/etc/ld.so.conf</li><li><strong>系统默认路径</strong>：如果仍未找到,动态链接器会在系统默认的库路径（如<code>/lib</code>和<code>/usr/lib</code>）中搜索.</li></ol><p>理解这个搜索机制有助于我们更好地掌握如何通过调整RPATH来控制应用程序的动态链接行为</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Unless loading object has RUNPATH:</span><br><span class="line">    RPATH <span class="keyword">of</span> <span class="keyword">the</span> loading object,</span><br><span class="line">        <span class="keyword">then</span> <span class="keyword">the</span> RPATH <span class="keyword">of</span> its loader (unless <span class="keyword">it</span> has <span class="keyword">a</span> RUNPATH), ...,</span><br><span class="line">        <span class="keyword">until</span> <span class="keyword">the</span> <span class="function"><span class="keyword">end</span> <span class="title">of</span> <span class="title">the</span> <span class="title">chain</span>, <span class="title">which</span> <span class="title">is</span> <span class="title">either</span> <span class="title">the</span> <span class="title">executable</span></span></span><br><span class="line">        <span class="keyword">or</span> <span class="keyword">an</span> object loaded <span class="keyword">by</span> dlopen</span><br><span class="line">    Unless executable has RUNPATH:</span><br><span class="line">        RPATH <span class="keyword">of</span> <span class="keyword">the</span> executable</span><br><span class="line">LD_LIBRARY_PATH</span><br><span class="line">RUNPATH <span class="keyword">of</span> <span class="keyword">the</span> loading object</span><br><span class="line">ld.so.cache</span><br><span class="line">default dirs</span><br></pre></td></tr></table></figure><h3 id="RPATH"><a href="#RPATH" class="headerlink" title="RPATH"></a>RPATH</h3><p>rpath优先级最高,会优先让执行档去寻找相应的动态库(如果设置了RUNPATH就会忽略RPATH<a href="https://stackoverflow.com/questions/7967848/use-rpath-but-not-runpath">c - use RPATH but not RUNPATH? - Stack Overflow</a>,简单来说,如果设置了RUN_PATH,那么RPATH会被忽略,但是RUNPATH优先级又低于<code>LD_LIBRAY_PATH</code></p><p>作者给的建议是<code>当您发布二进制文件时,要么使用RPATH而不是RUNPATH,要么确保在运行它们之前设置了LD_LIBRARY_PATH</code>,当然也有推荐只使用<code>LIBRARY_PATH</code>的.</p><p>注意,runpath和rpath也许操作系统支持有关,新版本的os<strong>应该</strong>默认使用runpath了,也就是使用<code>gcc -rpath</code>时默认设置<code>runpath</code></p><p>设置rpath,告诉新系统使用老行为</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc ... -Wl --disable-new-dtags -rpath=<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>设置runpath,告诉旧系统使用新行为</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc ... -Wl --enable-new-dtags -rpath=<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>查看一个elf文件的PATH,可以看到目前默认是runpath,rpath是depreacated了,这两者最大差异就是优先级</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf --dynamic obj | grep PATH</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/10/04/wKgcNut2XI1T6VD.png" alt="image-20241004140806996"></p><p>使用cmake开发时,默认就是这样使用动态库的</p><h3 id="LIBRAY-PATH"><a href="#LIBRAY-PATH" class="headerlink" title="LIBRAY_PATH"></a>LIBRAY_PATH</h3><p>LIBRAY_PATH不是运行时搜索动态库,其效果类似于<code>gcc -L</code>,设置编译时查找路径</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LIBRARY_PATH=/home/foo</span><br><span class="line">gcc -o main main.c -I/home/foo -lfoo</span><br><span class="line">ls</span><br><span class="line">main  main.c</span><br></pre></td></tr></table></figure><p>推荐使用<code>gcc -L</code>即可</p><blockquote><p>事实上实践中直接使用cmake</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>()</span><br><span class="line"><span class="keyword">target_link_libraries</span>()</span><br></pre></td></tr></table></figure><h3 id="LD-LIBRAY-PATH"><a href="#LD-LIBRAY-PATH" class="headerlink" title="LD_LIBRAY_PATH"></a>LD_LIBRAY_PATH</h3><p>你会发现在链接动态库后执行程序也无法成功,因为linux搜索动态库的路径并没有包括动态库的路径,道理同<code>rpath</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/home/work</span><br><span class="line">./main</span><br></pre></td></tr></table></figure><h3 id="etc-ld-so-conf"><a href="#etc-ld-so-conf" class="headerlink" title="/etc/ld.so.conf"></a>/etc/ld.so.conf</h3><blockquote><p>将非标准路经加入 /etc/ld.so.conf,然后运行 ldconfig 生成 /etc/ld.so.cache. ld.so 加载共享库的时候,会从 ld.so.cache 查找</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ld.so.conf</span><br><span class="line"><span class="comment"># 在文件中添加库路径 e.g. /project/build/libdy_lib.so</span></span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p>原理是ldconfig这个程序,程序运行时会通过这个程序查找库.</p><h3 id="默认搜索路径"><a href="#默认搜索路径" class="headerlink" title="默认搜索路径"></a>默认搜索路径</h3><p>可执行程序动态库默认搜索路径包括/usr/lib和/lib</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp libdy_lib.so /lib</span><br><span class="line"><span class="comment"># 以下命令均可</span></span><br><span class="line">cp libdy_lib.so /usr/lib</span><br><span class="line">ln -s libdy_lib.so /usr/lib</span><br></pre></td></tr></table></figure><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>windows并没有类似linux的rpath机制<a href="https://stackoverflow.com/questions/107888/is-there-a-windows-msvc-equivalent-to-the-rpath-linker-flag">dll - Is there a Windows/MSVC equivalent to the -rpath linker flag? - Stack Overflow</a></p><blockquote><p>当你使用visual studio开发使用了动态库时,也许你在vs上执行并没有问题,但直接点击可执行程序执行就报错了(即使你给可执行程序添加了相关引用). 主要原因是vs在编译链接时会去引用生成的目录找相关.dll和.lib(即使是动态库,vs也会生成DLL导入库,这类似一个查找表,方便获取DLL中的函数、变量等)</p><p>而在运行时,动态库的查找机制就不一样了</p><p><img data-src="https://s2.loli.net/2024/10/04/kYxoIivzWmrOuGd.png" alt="链接时加载了.dll库,成功执行"></p></blockquote><h3 id="链接方法"><a href="#链接方法" class="headerlink" title="链接方法"></a>链接方法</h3><p>可执行文件通过以下两种方式之一链接到（或加载）DLL：</p><ul><li>隐式链接,其中操作系统会与使用 DLL 的可执行文件同时加载它. 客户端<strong>可执行文件调用 DLL 的导出函数的方式与函数进行静态链接并包含在可执行文件中时的方式相同</strong>. 隐式链接有时称为静态加载或加载时动态链接.</li><li>显式链接,其中操作系统会在运行时按需加载 DLL. 通过显式链接使用 DLL 的可执行文件必须显式加载和卸载 DLL. 它还必须设置函数指针,用于访问它从 DLL 使用的每个函数. 与静态链接的库或隐式链接 DLL 中的函数调用不同,客户端可执行文件必须通过函数指针调用显式链接 DLL 中的导出函数. 显式链接有时称为动态加载或运行时动态链接.</li></ul><h4 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h4><p>当应用程序的代码调用导出 DLL 函数时,会进行隐式链接. 当编译或汇编调用可执行文件的源代码时,DLL 函数调用会在对象代码中生成外部函数引用.</p><p> <strong>若要解析此外部引用,应用程序必须与 DLL 创建者提供的导入库（.lib 文件）链接</strong>.</p><p>导入库包含的代码仅用于加载 DLL 和实现对 DLL 中函数的调用. 在导入库中查找外部函数会告知链接器该函数的代码处于 DLL 中. 若要解析对 DLL 的外部引用,链接器只需将信息添加到可执行文件,告知系统在进程启动时查找 DLL 代码的位置.</p><p>当系统启动包含动态链接引用的程序时,它将使用该程序可执行文件中的信息查找所需 DLL. 如果找不到 DLL,则系统将终止进程,并显示报告错误的对话框. 否则,系统会将 DLL 模块映射到进程地址空间中.</p><p>所以我们需要一个.lib文件方便静态加载,也就是程序在编译时就知道了动态库的位置(通过.lib),这样方便查找,而不是像上面提到的linux再通过rpath等路径去看. 那这样做需要什么呢? 那就是经典的<code>__declspec(dllexport)</code>了<a href="https://learn.microsoft.com/zh-cn/cpp/cpp/dllexport-dllimport?view=msvc-170">dllexport、dllimport | Microsoft Learn</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DllImport   __declspec( dllimport )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DllExport   __declspec( dllexport )</span></span><br><span class="line"></span><br><span class="line"><span class="function">DllExport <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">DllExport <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">DllImport <span class="keyword">int</span> j;</span><br><span class="line">DllExport <span class="keyword">int</span> n;</span><br></pre></td></tr></table></figure><p>使用 <strong><code>dllexport</code></strong> 意味着定义,而使用 <strong><code>dllimport</code></strong> 则意味着声明. 必须使用带 <strong><code>extern</code></strong> 的 <strong><code>dllexport</code></strong> 关键字来强制进行声明；否则,会进行隐式定义.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __declspec( dllimport ) <span class="keyword">int</span> l; <span class="comment">// Error; not declared extern.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> __declspec( dllimport ) <span class="keyword">int</span> s;  <span class="comment">// Error; not declared</span></span><br><span class="line">                                           <span class="comment">// extern.</span></span><br><span class="line">    __declspec( dllimport ) <span class="keyword">int</span> m;         <span class="comment">// Okay; this is a</span></span><br><span class="line">                                           <span class="comment">// declaration.</span></span><br><span class="line">    __declspec( dllexport ) <span class="keyword">int</span> n;         <span class="comment">// Error; implies external</span></span><br><span class="line">                                           <span class="comment">// definition in local scope.</span></span><br><span class="line">    <span class="keyword">extern</span> __declspec( dllimport ) <span class="keyword">int</span> i;  <span class="comment">// Okay; this is a</span></span><br><span class="line">                                           <span class="comment">// declaration.</span></span><br><span class="line">    <span class="keyword">extern</span> __declspec( dllexport ) <span class="keyword">int</span> k;  <span class="comment">// Okay; extern implies</span></span><br><span class="line">                                           <span class="comment">// declaration.</span></span><br><span class="line">    __declspec( dllexport ) <span class="keyword">int</span> x = <span class="number">5</span>;     <span class="comment">// Error; implies external</span></span><br><span class="line">                                           <span class="comment">// definition in local scope.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当声明 <strong><code>dllexport</code></strong> 类时,它的所有成员函数和静态数据成员都会导出. 必须在同一程序中提供所有此类成员的定义. 否则,将生成链接器错误. 此规则有一个例外情况,即对于纯虚函数,无需为其提供显式定义. 但是,由于基类的析构函数始终在调用继承类的析构函数,因此纯虚析构函数必须始终提供定义</p><p>当声明 <strong><code>dllimport</code></strong> 类时,它的所有成员函数和静态数据成员都会导入. 与非类类型上的 <strong><code>dllimport</code></strong> 和 <strong><code>dllexport</code></strong> 的行为不同,静态数据成员无法在定义 <strong><code>dllimport</code></strong> 类的同一程序中指定定义. 如果整个类都已导入或导出,则禁止将成员函数和数据显式声明为 <strong><code>dllimport</code></strong> 或 <strong><code>dllexport</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DllExport   __declspec( dllexport )</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DllExport</span> <span class="title">C</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">( <span class="keyword">void</span> )</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib_link_input_2.cpp</span></span><br><span class="line"><span class="comment">// compile by using: cl /EHsc lib_link_input_1.lib lib_link_input_2.cpp</span></span><br><span class="line">__declspec(dllimport) <span class="function"><span class="keyword">int</span> <span class="title">Test</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="built_in">Test</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在windows上,这几乎成了常用的方式,不管你使用的什么编译器,即便是mingw,clang</p><p>如果使用vc++,那会生成xx.dll与libxx.lib,后者用于找动态库,而使用mingw,clang会生成xx.dll和xx.dll.a,效果一样.</p><p>若要通过隐式链接使用 DLL,客户端可执行文件必须从 DLL 的提供程序获取以下文件：</p><ul><li>一个或多个头文件（.h 文件）,其中包含 DLL 中的导出数据、函数和 C++ 类的声明. DLL 导出的类、函数和数据全都必须在头文件中标记为 <code>__declspec(dllimport)</code></li><li>要链接到可执行文件中的导入库. 生成 DLL 时,链接器会创建导入库</li><li>实际 DLL 文件.</li></ul><p>我们在windows上默认都是使用的隐式链接,如果你要使用动态库,还挺麻烦的.</p><h4 id="显式链接"><a href="#显式链接" class="headerlink" title="显式链接"></a>显式链接</h4><p>有时需要显式链接. 下面是使用显式链接的一些常见原因：</p><ul><li>应用程序直到运行时才知道它所加载的 DLL 的名称. 例如,应用程序可能会在启动时从配置文件获取 DLL 的名称和导出函数.</li><li>如果在使用隐式链接的进程启动时找不到 DLL,则操作系统会终止进程. 使用显式链接的进程在这种情况下不会终止,可以尝试从错误中恢复. 例如,进程可以向用户通知错误,并让用户指定 DLL 的其他路径.</li><li>如果使用隐式链接的进程所链接到的任何 DLL 的 <code>DllMain</code> 函数失败,则进程也会终止. 使用显式链接的进程在这种情况下不会终止.</li><li>隐式链接到许多 DLL 的应用程序可能会速度较慢,因为 Windows 会在应用程序加载时加载所有 DLL. 若要提高启动性能,应用程序可以只对在加载之后立即需要的 DLL 使用隐式链接. 它可以仅在需要时才使用显式链接加载其他 DLL.</li><li>显式链接无需使用导入库链接应用程序. 如果 DLL 中的更改导致导出序号发生更改,则在使用函数名称而不是序号值调用 <code>GetProcAddress</code> 时,应用程序无需重新链接. 使用隐式链接的应用程序仍必须重新链接到更改的导入库.</li></ul><p>若要通过显式链接使用 DLL,应用程序必须在运行时进行函数调用以显式加载 DLL. 若要显式链接到 DLL,应用程序必须：</p><ul><li>调用LoadLibraryEx或类似函数以加载 DLL 并获取模块句柄.</li><li>调用 GetProcAddress以获取应用程序调用的每个导出函数的函数指针. 由于应用程序通过指针调用 DLL 函数,因此编译器不生成外部引用,从而不需要与导入库链接. 不过必须有 <strong><code>typedef</code></strong> 或 <strong><code>using</code></strong> 语句,此语句定义调用的已导出函数的调用签名.</li><li>处理完 DLL 时,调用 FreeLibrary</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;windows.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HRESULT</span> <span class="params">(CALLBACK* LPFNDLLFUNC1)</span><span class="params">(DWORD,UINT*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">HRESULT <span class="title">LoadAndCallSomeFunction</span><span class="params">(DWORD dwParam1, UINT * puParam2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HINSTANCE hDLL;               <span class="comment">// Handle to DLL</span></span><br><span class="line">    LPFNDLLFUNC1 lpfnDllFunc1;    <span class="comment">// Function pointer</span></span><br><span class="line">    HRESULT hrReturnVal;</span><br><span class="line"></span><br><span class="line">    hDLL = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;MyDLL&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != hDLL)</span><br><span class="line">    &#123;</span><br><span class="line">        lpfnDllFunc1 = (LPFNDLLFUNC1)<span class="built_in">GetProcAddress</span>(hDLL, <span class="string">&quot;DLLFunc1&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != lpfnDllFunc1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// call the function</span></span><br><span class="line">            hrReturnVal = <span class="built_in">lpfnDllFunc1</span>(dwParam1, puParam2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// report the error</span></span><br><span class="line">            hrReturnVal = ERROR_DELAY_LOAD_FAILED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FreeLibrary</span>(hDLL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        hrReturnVal = ERROR_DELAY_LOAD_FAILED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hrReturnVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态库查找路径"><a href="#动态库查找路径" class="headerlink" title="动态库查找路径"></a>动态库查找路径</h3><blockquote><p>查找路径不仅针对显式链接,隐式链接也能用. 比较方便的就是可执行程序文件、或环境变量PATH</p></blockquote><p>当应用程序调用 LoadLibrary或 LoadLibraryEx函数时,系统会尝试查找 DLL . 如果搜索成功,系统会将 DLL 模块映射到进程的虚拟地址空间,并递增引用计数.</p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/dlls/dynamic-link-library-search-order">Dynamic-link library search order - Win32 apps | Microsoft Learn</a></p><p>windows搜索dll路径顺序比较麻烦,需要看是否是打包应用(loadPackagedLibrary ),是否开启了安全DLL搜索模式(默认开启)</p><blockquote><p>若要禁用安全 DLL 搜索模式,将<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode</code> 创建注册表值并将其设置为 0</p></blockquote><p>如果是未打包并且是安全搜索模式,那么搜索顺序如下,前六个感觉不用看</p><ol><li>DLL 重定向.</li><li>API sets.</li><li>SxS manifest redirection.</li><li>Loaded-module list.</li><li>Known DLLs.</li><li><strong>Windows 11,版本 21H2 (10.0;内部版本 22000) 及更高版本</strong>. The package dependency graph of the process. This is the application’s package plus any dependencies specified as <code>&lt;PackageDependency&gt;</code> in the <code>&lt;Dependencies&gt;</code> section of the application’s package manifest. Dependencies are searched in the order they appear in the manifest.</li><li>从中加载应用程序的文件夹.</li><li>系统文件夹. 使用GetSystemDirectory函数检索此文件夹的路径.</li><li>16 位系统文件夹. 没有获取此文件夹路径的函数,但会对其进行搜索.</li><li>Windows 文件夹. 使用GetWindowsDirectory函数获取此文件夹的路径.</li><li>当前文件夹.</li><li>环境变量中列出的 <code>PATH</code> 目录. 这不包括由应用路径注册表项指定的<strong>App Paths</strong> . 计算 DLL 搜索路径时,不使用 <strong>App Paths</strong> 变量</li></ol><p>如果禁用安全DLL 搜索模式,则搜索顺序基本相同,只是位置11和8交换顺序</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下,在linux使用cmake开发c/c++程序链接动态库时使用rpath添加搜索目录,使用windows开发开发动态库实在麻烦,一般默认隐式链接然后使用<code>__declspec( dllexport)</code>导出(因为默认不导出),如果使用现成的xx.dll和libxx.lib就不需要声明<code>__declspec(__dllimport)</code>宏了,因为链接了DLL导入库(也就是libxx.lib) <a href="https://www.youtube.com/watch?v=pLy69V2F_8M&amp;t=481s&amp;ab_channel=TheCherno">Using Dynamic Libraries in C++ (youtube.com)</a></p><p><img data-src="https://learn.microsoft.com/zh-cn/cpp/build/media/mathclient-additional-dependencies-property.png?view=msvc-170" alt="Screenshot of the Property Pages dialog showing the Edit command in the Linker &gt; Input &gt; Additional Dependencies property drop-down."></p><p>至于生成的DLL放哪,连微软自己都说放在可执行文件同一目录中,在vs<code>可将“后期生成事件”添加到项目中,以此添加一条命令,将 DLL 复制到生成输出目录.</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcopy <span class="regexp">/y /</span>d <span class="string">&quot;..\..\MathLibrary\$(IntDir)MathLibrary.dll&quot;</span> <span class="string">&quot;$(OutDir)&quot;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://learn.microsoft.com/zh-cn/cpp/build/media/mathclient-post-build-command-line.png?view=msvc-170" alt="Screenshot of the Property Pages dialog showing the post build event command line property."></p><p>我的配置如下</p><p><img data-src="https://s2.loli.net/2024/10/04/yH5w6uk8spCKgnW.png" alt="image-20241004164950315"></p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcopy /y /d <span class="string">&quot;<span class="variable">$(OutDir)</span><span class="variable">$(TargetFileName)</span>&quot;</span> <span class="string">&quot;<span class="variable">$(SolutionDir)</span>bin\<span class="variable">$(Platform)</span>\<span class="variable">$(Configuration)</span>\&quot;</span></span><br></pre></td></tr></table></figure><p>在cmake中添加自定义command,道理相同,使用了<code>cmake -E</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> MyTest POST_BUILD        </span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy_if_different  </span><br><span class="line">        <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/libs/test.dll&quot;</span>      </span><br><span class="line">        $&lt;TARGET_FILE_DIR:MyTest&gt;)                 </span><br></pre></td></tr></table></figure><p>或者类似的使用更好的生成器表达式<code>$&lt;TARGET_RUNTIME_DLLS:MyTest&gt;</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(foo CONFIG REQUIRED) <span class="comment"># package generated by install(EXPORT)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(exe main.c)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(exe PRIVATE foo::foo foo::bar)</span><br><span class="line"><span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> exe POST_BUILD</span><br><span class="line">  <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy -t $&lt;TARGET_FILE_DIR:exe&gt; $&lt;TARGET_RUNTIME_DLLS:exe&gt;</span><br><span class="line">  COMMAND_EXPAND_LISTS</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>cmake -E copy_if_different</code></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">copy</span> <span class="symbol">&lt;file&gt;</span>... destination  - <span class="keyword">copy</span> <span class="keyword">files</span> <span class="keyword">to</span> destination (either <span class="keyword">file</span> <span class="built_in">or</span> directory)</span><br><span class="line">copy_directory <span class="symbol">&lt;dir&gt;</span>... destination   - <span class="keyword">copy</span> content of <span class="symbol">&lt;dir&gt;</span>... directories <span class="keyword">to</span> <span class="string">&#x27;destination&#x27;</span> directory</span><br><span class="line">copy_directory_if_different <span class="symbol">&lt;dir&gt;</span>... destination   - <span class="keyword">copy</span> changed content of <span class="symbol">&lt;dir&gt;</span>... directories <span class="keyword">to</span> <span class="string">&#x27;destination&#x27;</span> directory</span><br><span class="line">copy_if_different <span class="symbol">&lt;file&gt;</span>... destination  - <span class="keyword">copy</span> <span class="keyword">files</span> <span class="keyword">if</span> it <span class="built_in">has</span> changed</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://learn.microsoft.com/zh-cn/cpp/build/linking-an-executable-to-a-dll?view=msvc-170">将可执行文件链接到 DLL | Microsoft Learn</a></li><li><a href="https://learn.microsoft.com/zh-cn/cpp/build/walkthrough-creating-and-using-a-dynamic-link-library-cpp?view=msvc-170">演练：创建和使用自己的动态链接库 (C++) | Microsoft Learn</a></li><li><a href="https://blog.csdn.net/feikudai8460/article/details/121823029">gcc/g++ 动态库和静态库,编译与链接（含示例）_g++ 链接静态库-CSDN博客</a></li><li><a href="https://www.baeldung.com/linux/library_path-vs-ld_library_path">LIBRARY_PATH vs LD_LIBRARY_PATH | Baeldung on Linux</a></li><li><a href="https://developer.aliyun.com/article/1469309">【Linux 应用开发 】Linux环境下动态链接库路径（RPATH）的调整策略-阿里云开发者社区 (aliyun.com)</a></li><li><a href="https://www.cnblogs.com/AndyJee/p/3835092.html">Linux动态库(.so)搜索路径 - AndyJee - 博客园 (cnblogs.com)</a></li><li><a href="https://web.archive.org/web/20120418232524/http://labs.qt.nokia.com/2011/10/28/rpath-and-runpath/">RPATH and RUNPATH (archive.org)</a></li><li><a href="https://blog.tremily.us/posts/rpath/">RPATH, RUNPATH, and dynamic linking (tremily.us)</a></li><li><a href="https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/RPATH-handling">RPATH handling · Wiki · CMake / Community · GitLab (kitware.com)</a></li><li><a href="https://stackoverflow.com/questions/10671916/how-to-copy-dll-files-into-the-same-folder-as-the-executable-using-cmake">How to copy DLL files into the same folder as the executable using CMake? - Stack Overflow</a></li><li><a href="https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#genex:TARGET_RUNTIME_DLLS">cmake-generator-expressions(7) — CMake 3.30.4 Documentation</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;想必很多人已经了解了动态库与静态库,在实际开发中也经常使用. 但是,有必要了解在windows和Linux上开发c++程序生成和链接动态库的不同行为,因为经常混淆或者自以为找到了动态库,这里简单学习并澄清一下.其中许多内容来自官方文档&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>窗口系统与图形绘制接口</title>
    <link href="https://www.sekyoro.top/2024/10/02/%E7%AA%97%E5%8F%A3%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E6%8E%A5%E5%8F%A3/"/>
    <id>https://www.sekyoro.top/2024/10/02/%E7%AA%97%E5%8F%A3%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E6%8E%A5%E5%8F%A3/</id>
    <published>2024-10-02T03:18:22.000Z</published>
    <updated>2024-10-15T02:20:08.025Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>当我们想要进行底层图形应用(GUI)开发时,往往需要用到窗口系统和图形库,这里简单介绍一下<br><span id="more"></span></p><h2 id="视窗系统-window-system-与通信协议"><a href="#视窗系统-window-system-与通信协议" class="headerlink" title="视窗系统(window system)与通信协议"></a>视窗系统(window system)与通信协议</h2><p>下面内容主要针对Unix-like操作系统 </p><p><strong>视窗系统</strong>是以使用视窗作为主要特征之一的图形用户接口的构成组件.更为明确地说,它是桌面环境的构成组件.视窗系统支撑著窗口管理器的实现（implementation）；视窗系统为“图像硬件（graphics hardware）、指向设备（pointing devices）提供基本支持.绘制鼠标光标,一般也与视窗系统相关.</p><h3 id="X-Window-System-X11"><a href="#X-Window-System-X11" class="headerlink" title="X Window System(X11)"></a>X Window System(X11)</h3><p>X窗口系统是一种以位图方式显示的软件窗口系统,X窗口系统通过软件工具及架构协议来建立操作系统所用的<a href="https://zh.wikipedia.org/wiki/图形用户界面">图形用户界面</a>,此后则逐渐扩展适用到各形各色的其他操作系统上.</p><blockquote><p>在X11的设计中,应用程序和显示器不必在同一台计算机上,这一点并不明显.在开发X时,X server运行在工作站上,而用户在具有更强处理能力的远程计算机上运行应用程序是很常见的.</p></blockquote><h4 id="X-Window核心协议"><a href="#X-Window核心协议" class="headerlink" title="X Window核心协议"></a>X Window核心协议</h4><p><strong>X Window 核心协议</strong>是X窗口系统的基础协议,它是一个以位图显示的网络化视窗系统,用来在Unix、类Unix和其它操作系统上建立用户图形界面.X Window 系统基于主从式模型：单一服务器控管硬件的输出入,如屏幕、键盘和鼠标；所有的应用程序都被视作客户端,<strong>用户之间透过服务器来交互</strong>.</p><p>交互部分由X Window核心协议来管理.还有其它与X窗口系统有关的协议,有的建立在X Window核心协议之上的,有的是独立的协议.</p><p><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/03/X_client_server_example.svg/220px-X_client_server_example.svg.png" alt="img"></p><p>X server接受来自键盘,鼠标,显示器的输入,并将这些请求发送给client.</p><p><img data-src="https://jichu4n.com/content/images/2018/10/so1jXbe2d2Vvx917pbA5Cjw.png" alt="so1jXbe2d2Vvx917pbA5Cjw"></p><h4 id="X-server"><a href="#X-server" class="headerlink" title="X server"></a>X server</h4><p>与大多数早期的显示协议不同,X是专门设计用于网络连接,而不是用于集成或附加的显示设备.X具有网络透明性,这意味着在网络上某处的计算机(例如Internet)上运行的X程序可以在网络上其他计算机上运行的X服务器上显示其用户界面.</p><p>X服务器通常为X客户机提供图形资源和键盘/鼠标事件,这意味着X服务器通常在人类用户面前的计算机上运行,而X客户机应用程序在网络上的任何地方运行,并与用户的计算机通信,请求图形内容的呈现,并从包括键盘和鼠标在内的输入设备接收事件</p><h4 id="Xlib与其他的客户端程序"><a href="#Xlib与其他的客户端程序" class="headerlink" title="Xlib与其他的客户端程序"></a>Xlib与其他的客户端程序</h4><blockquote><p>大部分的客户端程序借由 Xlib 客户端程序库与服务器交流.特别是客户端大多使用 Xaw、Motif、GTK+、Qt 之类使用到 Xlib 的程序库,方便和服务器交互.</p></blockquote><p>XLib是<strong>X Window System的核心库</strong>,它提供了与窗口系统交互的基本功能,如创建窗口、处理事件和绘制图形</p><blockquote><p><strong>Xlib</strong>是一种X Window System协议的客户端,以C语言撰写.其功能是与X server沟通.这样的功能可以让程序人员撰写程序时,，毋须了解其协议的细节。但甚少应用程序会直接使用Xlib;通常是透过其他的函数库来调用Xlib用以提供部件工具箱</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;X11/Xlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Display* MainDisplay = XOpenDisplay(<span class="number">0</span>);</span><br><span class="line">    Window RootWindow = XDefaultRootWindow(MainDisplay);</span><br><span class="line">    </span><br><span class="line">    Window MainWindow = XCreateSimpleWindow(MainDisplay, RootWindow, <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00aade87</span>);</span><br><span class="line">    XMapWindow(MainDisplay, MainWindow);</span><br><span class="line">    XFlush(MainDisplay);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123; sleep(<span class="number">1</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;X11/Xlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;X11/Xutil.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> X;</span><br><span class="line">    <span class="keyword">int</span> Y;</span><br><span class="line">    <span class="keyword">int</span> Width;</span><br><span class="line">    <span class="keyword">int</span> Height;</span><br><span class="line">&#125; entity;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Display* MainDisplay = XOpenDisplay(<span class="number">0</span>);</span><br><span class="line">    Window RootWindow = XDefaultRootWindow(MainDisplay);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> DefaultScreen = DefaultScreen(MainDisplay);</span><br><span class="line">    GC Context = XDefaultGC(MainDisplay, DefaultScreen);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> WindowX = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> WindowY = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> WindowWidth = <span class="number">800</span>;</span><br><span class="line">    <span class="keyword">int</span> WindowHeight = <span class="number">600</span>;</span><br><span class="line">    <span class="keyword">int</span> BorderWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> WindowDepth = CopyFromParent;</span><br><span class="line">    <span class="keyword">int</span> WindowClass = CopyFromParent;</span><br><span class="line">    Visual* WindowVisual = CopyFromParent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> AttributeValueMask = CWBackPixel | CWEventMask;</span><br><span class="line">    XSetWindowAttributes WindowAttributes = &#123;&#125;;</span><br><span class="line">    WindowAttributes.background_pixel = <span class="number">0xffffccaa</span>;</span><br><span class="line">    WindowAttributes.event_mask = StructureNotifyMask | KeyPressMask | KeyReleaseMask | ExposureMask;</span><br><span class="line"></span><br><span class="line">    Window MainWindow = XCreateWindow(MainDisplay, RootWindow, </span><br><span class="line">            WindowX, WindowY, WindowWidth, WindowHeight,</span><br><span class="line">            BorderWidth, WindowDepth, WindowClass, WindowVisual,</span><br><span class="line">            AttributeValueMask, &amp;WindowAttributes);</span><br><span class="line"></span><br><span class="line">    XMapWindow(MainDisplay, MainWindow);</span><br><span class="line"></span><br><span class="line">    XStoreName(MainDisplay, MainWindow, <span class="string">&quot;Moving rectangle. Use arrow keys to move.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Atom WM_DELETE_WINDOW = XInternAtom(MainDisplay, <span class="string">&quot;WM_DELETE_WINDOW&quot;</span>, False);</span><br><span class="line">    <span class="keyword">if</span>(!XSetWMProtocols(MainDisplay, MainWindow, &amp;WM_DELETE_WINDOW, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Couldn&#x27;t register WM_DELETE_WINDOW property \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    entity Box = &#123;&#125;;</span><br><span class="line">    Box.Width = <span class="number">50</span>;</span><br><span class="line">    Box.Height = <span class="number">80</span>;</span><br><span class="line">    Box.X = WindowWidth/<span class="number">2</span> - Box.Width/<span class="number">2</span>;</span><br><span class="line">    Box.Y = WindowHeight/<span class="number">2</span> - Box.Height/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> StepSize = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> IsWindowOpen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(IsWindowOpen) &#123;</span><br><span class="line">        XEvent GeneralEvent = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        XNextEvent(MainDisplay, &amp;GeneralEvent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(GeneralEvent.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> KeyPress:</span><br><span class="line">            <span class="keyword">case</span> KeyRelease:</span><br><span class="line">            &#123;</span><br><span class="line">                XKeyPressedEvent *Event = (XKeyPressedEvent *)&amp;GeneralEvent;</span><br><span class="line">                <span class="keyword">if</span>(Event-&gt;keycode == XKeysymToKeycode(MainDisplay, XK_Escape))</span><br><span class="line">                &#123;</span><br><span class="line">                    IsWindowOpen = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(Event-&gt;keycode == XKeysymToKeycode(MainDisplay, XK_Down))</span><br><span class="line">                &#123;</span><br><span class="line">                    Box.Y += StepSize;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(Event-&gt;keycode == XKeysymToKeycode(MainDisplay, XK_Up))</span><br><span class="line">                &#123;</span><br><span class="line">                    Box.Y -= StepSize;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(Event-&gt;keycode == XKeysymToKeycode(MainDisplay, XK_Right))</span><br><span class="line">                &#123;</span><br><span class="line">                    Box.X += StepSize;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(Event-&gt;keycode == XKeysymToKeycode(MainDisplay, XK_Left))</span><br><span class="line">                &#123;</span><br><span class="line">                    Box.X -= StepSize;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> ClientMessage:</span><br><span class="line">            &#123;</span><br><span class="line">                XClientMessageEvent *Event = (XClientMessageEvent *) &amp;GeneralEvent;</span><br><span class="line">                <span class="keyword">if</span>((Atom)Event-&gt;data.l[<span class="number">0</span>] == WM_DELETE_WINDOW) &#123;</span><br><span class="line">                    XDestroyWindow(MainDisplay, MainWindow);</span><br><span class="line">                    IsWindowOpen = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        XClearWindow(MainDisplay, MainWindow);</span><br><span class="line">        XFillRectangle(MainDisplay, MainWindow, Context, Box.X, Box.Y, Box.Width, Box.Height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="窗口管理器"><a href="#窗口管理器" class="headerlink" title="窗口管理器"></a>窗口管理器</h4><blockquote><p><strong>窗口管理器</strong>（Window manager）是在图形用户界面中,控制窗口位置与外观的软件. 许多窗口管理器是为了桌面环境编写,与桌面环境一同发布的,例如被GNOME使用的Mutter.同时也存在不少独立的窗口管理器,如Openbox、Awesome等.</p></blockquote><p>linux的窗口管理器(dwm,i3wm)以及桌面环境(比如Gnome,KDE等)往往不会直接使用xlib编写界面,而是使用其他库调用xlib,比如GTK,Qt以及<a href="https://www.cairographics.org/">cairographics.org</a>等.</p><p>窗口管理器是一个常规的X客户机.它没有任何超级用户权限;它是X服务器允许调用一组特殊api的普通用户进程</p><p>X通过拒绝客户端对这些api的访问(如果另一个客户端当前具有访问权限),确保在任何给定点上运行的窗口管理器不超过一个.第一个尝试访问这些api的客户端总是成功的.</p><p><img data-src="https://jichu4n.com/content/images/2018/10/so1jXbe2d2Vvx917pbA5Cjw.png" alt="so1jXbe2d2Vvx917pbA5Cjw"></p><p>窗口管理器通过两个X机制与它所管理的窗口进行通信:属性和事件。通信是通过X服务器进行的,而不是直接在窗口管理器和其他应用程序之间进行的。</p><h4 id="substructure-redirection"><a href="#substructure-redirection" class="headerlink" title="substructure redirection"></a>substructure redirection</h4><p>在没有窗口管理器的情况下，当一个应用程序想要对一个窗口做一些事情——移动它、调整它的大小、显示/隐藏它等等——它的请求直接由X服务器处理。但是，窗口管理器需要拦截这些请求。例如，窗口管理器可能需要知道一个新的顶层窗口已经创建并显示，以便在其周围绘制窗口装饰(例如最小化/最大化/关闭按钮)。它可能还需要知道现有的顶层窗口已被调整大小，以便重新绘制窗口装饰以重新填充.允许窗口管理器拦截此类请求的机制称为substructure redirection</p><p>假设我们有一个窗口W。如果程序M在W上注册substructure redirection，<strong>则X服务器不会执行修改W的任何直接子窗口的匹配请求。相反，X服务器将此请求重定向到程序M</strong>,程序M可以对请求执行任何操作,包括直接拒绝请求或通过、修改请求。</p><blockquote><p>窗口管理器能为一个root window(是应用的top-level window的父窗口)注册substructure redirection,使得这个顶层窗口的任何直接子窗口(也就是应用的top-level窗口)发送的请求经过x server不经过修改转发到window manager,windows manager可以进行处理</p></blockquote><p><img data-src="https://jichu4n.com/content/images/2018/10/sTifV_OHk9dsZi6cwbLS7qQ.png" alt="sTifV_OHk9dsZi6cwbLS7qQ"></p><h4 id="reparenting"><a href="#reparenting" class="headerlink" title="reparenting"></a>reparenting</h4><p>如果在没有窗口管理器的情况下运行X应用程序,则应用程序的顶层窗口将是根窗口的直接子窗口.但是,在运行窗口管理器时,应用程序的顶层窗口可能被窗口管理器重新定义;它成为由窗口管理器创建的框架窗口的子窗口,并且它本身是根窗口的直接子窗口。窗口管理器可以将其他UI元素添加到这个框架窗口中,并与应用程序的顶层窗口一起使用</p><p>Reparenting允许不同的窗口管理器绘制不同的窗口装饰，从而实现跨窗口的一致外观。然而，也有一些窗口管理器根本不reparent:这些窗口管理器称为非reparent窗口管理器。窗口管理器不希望重命名有两个原因:</p><ol><li><p>如果窗口管理器不在顶层窗口周围绘制窗口装饰，那么它显然不需要重新表示它们。例如:xmonad、dwm。</p></li><li><p>合成窗口管理器并不总是需要reparent窗口</p></li></ol><blockquote><p>简单来说,reparent赋予了窗口管理器对其他应用程序的top-level也就是顶层窗口绘制的能力</p><p>让window manager管理了应用程序的top-level window</p></blockquote><h4 id="compositing"><a href="#compositing" class="headerlink" title="compositing"></a>compositing</h4><p>从窗口管理器的角度来看,top-level窗口是黑盒;它们各自管理自己的后代窗口(UI元素)，可能通过GTK+或Qt这样的框架，窗口管理器无权干涉那里。</p><p>但现在,随着图形硬件计算能力增强,window manager能做的更多了</p><p><img data-src="https://jichu4n.com/content/images/2018/10/sawR1epQiKxE5bX3Cplms2A.png" alt="sawR1epQiKxE5bX3Cplms2A"></p><p>绘制应用top-level窗口下的子元素往往如果直接由应用程序管理,那么其子元素的绘制和事件处理均通过应用发送请求到X server(中间通过window manager可能做出一些修改)</p><p>让我们花点时间思考一下如何实现像上面的Shift Switcher这样的接口。当用户触发这个接口时，我们需要:</p><ol><li><p>将每个顶层窗口及其所有后代窗口(UI元素)呈现到off-screen的内存缓冲区中，而不是直接呈现给硬件。</p></li><li><p>根据设计变换(旋转，扭曲等)每个缓冲区。</p></li><li><p>将转换后的buffer与背景和我们需要显示的任何其他浮动UI元素一起合成为最终buffer</p></li><li><p>创建一个覆盖窗口，覆盖整个屏幕，并隐藏所有其他窗口</p></li><li><p>渲染最终的buffer到覆盖的窗口</p></li></ol><p>​    Composite扩展提供了一种机制，请求X服务器<strong>不要将特定的窗口及其后代直接呈现给硬件，而是呈现给X服务器维护的一个特殊缓冲区，这样做不需要进行常规的裁剪和重叠计算</strong>。然后，发出请求的客户端(也就是composition window manager)可以读取和使用该缓冲区</p><p>​    由于合成窗口管理器已经知道所有顶层窗口的大小和位置,因此在使用图形操作(例如OpenGL)合成到覆盖窗口时,只需绘制窗口装饰就很容易了,而无需创建实际的X框架窗口和reparent</p><p>另一方面，窗口管理器可能需要同时支持合成和非合成模式，以兼容较旧或不受支持的图形硬件。在这种情况下，它需要为非合成模式实现修复和框架窗口，因此使用图形操作额外实现绘制窗口装饰变得多余。这就是为什么许多其他合成窗口管理器仍然选择重命名的原因</p><h3 id="XCB"><a href="#XCB" class="headerlink" title="XCB"></a>XCB</h3><p><a href="https://zh.wikipedia.org/wiki/XCB">XCB - 维基百科,自由的百科全书 (wikipedia.org)</a></p><p>XCB是目标在于取代Xlib,XCB 主要目标是:</p><ul><li>减轻函数库的大小与复杂度;</li><li>可直接访问 X Window核心协议.</li></ul><h3 id="Wayland"><a href="#Wayland" class="headerlink" title="Wayland"></a>Wayland</h3><blockquote><p>Wayland 是在同一个主机上的 GUI 通信协议：新、简单、快速,不需要 setuid root 二进制</p></blockquote><p><strong>Wayland</strong>是一个通信协议,规定了显示服务器与其客户机之间的通信方式,而使用这个协议的显示服务器称为Wayland Compositor.它由Kristian Høgsberg于2008年发起,目标是用更简单的现代化视窗系统取代X Window System.Wayland协议的参考实现称为Weston,由Wayland项目组使用C语言开发</p><p>Wayland与X Window System的最大不同在于<strong>它规定由客户机自身负责窗口边框和装饰的绘制(应用程序直接修改显存?),并且客户机能够通过EGL以及一些Wayland特定的EGL扩展组件直接在显示内存中算绘自己的缓冲器</strong>.</p><p>窗口管理器简化成显示管理服务,专门负责算绘那些屏幕上的程序.这比X Window System中的窗口管理器要更简单、高效</p><p>以“鼠标点击按钮引发按钮更新动作”为例来说明一下Wayland和X server的区别</p><p><strong>在X中</strong>：</p><ol><li><p>内核捕获鼠标点击事件并发送给X server.</p></li><li><p>X server会计算该把这一事件发送给哪个窗口（事实上,窗口位置是由Compositor控制的,X server并不能够正确的计算Compositor做过特效变化之后的按钮的正确位置）.</p></li><li><p>应用程序对此事件进行处理（将引发按钮更新动作）.但是,在此之前它得向X server发送绘制请求.</p></li><li><p>X server接收到这条绘制请求,然后把它发给视频驱动来渲染.X还计算了更新区域,并且这条“垃圾信息”发送给了Compositor.</p></li><li><p>这时,Compositor知道它必须要重新合成屏幕上的一块区域.当然,这还是要向X server发送绘制请求的.</p></li><li><p>开始绘制.但是X server还会去做一些不必要的本职工作（窗口重叠计算、窗口剪裁计算等）</p><p><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/06/X-architecture.png/220px-X-architecture.png" alt="img"></p></li></ol><p><strong>在Wayland中</strong>：</p><ol><li>内核捕获鼠标点击事件并发送给Wayland Compositor.</li><li>由于是直接发给Wayland Compositor的,所以Wayland Compositor会正确地计算出按钮的位置.同时它会把这一事件发送给按钮所在的应用程序来处理.</li><li>应用程序直接渲染,无需向Wayland Compositor请求.只需在绘制完成之后向Wayland Compositor发送一条信息表明这块区域被更新了.</li><li>Wayland Compositor收到这条信息后,立即重新合成整个桌面</li></ol><p><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cd/Wayland-architecture.png/220px-Wayland-architecture.png" alt="img"></p><p>实现 Wayland 显示服务器协议的显示服务器也称为 Wayland 合成器,因为它们也执行合成视窗管理器的任务.</p><ul><li><p>Hyprland – 一个用C++ 编写的基于wlroots 的平铺Wayland 合成器,Hyprland 值得注意的功能包括动态平铺、选项卡式视窗、干净且可读的C++ 代码库以及提供视窗动画、圆角和Dual-Kawase模糊的自定义渲染器.</p></li><li><p>Weston – Wayland 合成器的参考实现,实现客户端装饰.</p></li><li><p>Sway – 平铺 Wayland 合成器和 X11 i3 视窗管理器的直接替代品.</p></li></ul><h2 id="在Windows上"><a href="#在Windows上" class="headerlink" title="在Windows上"></a>在Windows上</h2><h3 id="win32-api"><a href="#win32-api" class="headerlink" title="win32 api"></a>win32 api</h3><p><del>我去,这接口名把我看吐了</del></p><p>win32api提供了用户界面,图形,音视频,设备以及网络等等<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/">Win32 API 的编程参考 - Win32 apps | Microsoft Learn</a></p><h3 id="winui"><a href="#winui" class="headerlink" title="winui"></a>winui</h3><p>WinUI 是适用于 Windows 桌面应用和 UWP 应用的本机用户体验 (UX) 框架</p><p>使用界面使用<code>xaml</code>,处逻辑处理使用c++</p><h2 id="图形绘制接口"><a href="#图形绘制接口" class="headerlink" title="图形绘制接口"></a>图形绘制接口</h2><p>图形绘制与窗口管理(窗口上下文)往往是一起的,比如使用OpenGL往往需要搭配类似GLFW的窗口绘制库.</p><h3 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h3><p><img data-src="https://s2.loli.net/2024/10/02/S3p1byofjQceLEu.png" alt="image-20241002130444685"></p><p><a href="https://learnopengl-cn.github.io/">主页 - LearnOpenGL CN (learnopengl-cn.github.io)</a></p><h3 id="DirectX"><a href="#DirectX" class="headerlink" title="DirectX"></a>DirectX</h3><p><strong>DirectX</strong>（<strong>Direct</strong> e<strong>X</strong>tension,缩写：<strong>DX</strong>）是一系列专为多媒体以及游戏开发的api.旗下包含Direct3D、Direct2D、DirectCompute等等多个不同用途的子部分,因为这一系列<a href="https://zh.wikipedia.org/wiki/API">API</a>皆以Direct字样开头,所以DirectX（只要把X字母替换为任何一个特定API的名字）就成为这一巨大的API系列的统称.目前最新版本为DirectX 12,随附于Windows 10操作系统之上. 之前还有GDI/GDI++(已经过时)<a href="https://learn.microsoft.com/en-us/windows/win32/graphics-and-multimedia?redirectedfrom=MSDN">Graphics and gaming - Win32 apps | Microsoft Learn</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/direct2d/getting-started-with-direct2d?source=recommendations#step-1-include-direct2d-header">Direct2D 快速入门 - Win32 apps | Microsoft Learn</a></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">ID2D1Factory* pD2DFactory = <span class="literal">NULL</span>;</span><br><span class="line">HRESULT hr = D2D1CreateFactory(</span><br><span class="line">    D2D1_FACTORY_TYPE_SINGLE_THREADED,</span><br><span class="line">    &amp;pD2DFactory</span><br><span class="line">    );</span><br><span class="line">   <span class="comment">// Obtain the size of the drawing area.</span></span><br><span class="line">RECT rc;</span><br><span class="line">GetClientRect(hwnd, &amp;rc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Direct2D render target          </span></span><br><span class="line">ID2D1HwndRenderTarget* pRT = <span class="literal">NULL</span>;          </span><br><span class="line">HRESULT hr = pD2DFactory-&gt;CreateHwndRenderTarget(</span><br><span class="line">    D2D1::RenderTargetProperties(),</span><br><span class="line">    D2D1::HwndRenderTargetProperties(</span><br><span class="line">        hwnd,</span><br><span class="line">        D2D1::SizeU(</span><br><span class="line">            rc.right - rc.left,</span><br><span class="line">            rc.bottom - rc.top)</span><br><span class="line">    ),</span><br><span class="line">    &amp;pRT</span><br><span class="line">); </span><br><span class="line"> ID2D1SolidColorBrush* pBlackBrush = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (SUCCEEDED(hr))</span><br><span class="line">&#123;</span><br><span class="line">            </span><br><span class="line">    pRT-&gt;CreateSolidColorBrush(</span><br><span class="line">        D2D1::ColorF(D2D1::ColorF::Black),</span><br><span class="line">        &amp;pBlackBrush</span><br><span class="line">        ); </span><br><span class="line">&#125;   </span><br><span class="line">  pRT-&gt;BeginDraw();</span><br><span class="line"></span><br><span class="line">pRT-&gt;DrawRectangle(</span><br><span class="line">    D2D1::RectF(</span><br><span class="line">        rc.left + <span class="number">100.0</span>f,</span><br><span class="line">        rc.top + <span class="number">100.0</span>f,</span><br><span class="line">        rc.right - <span class="number">100.0</span>f,</span><br><span class="line">        rc.bottom - <span class="number">100.0</span>f),</span><br><span class="line">        pBlackBrush);</span><br><span class="line"></span><br><span class="line">HRESULT hr = pRT-&gt;EndDraw();    </span><br><span class="line"> </span><br><span class="line">SafeRelease(pRT);</span><br><span class="line">SafeRelease(pBlackBrush);</span><br></pre></td></tr></table></figure><h3 id="Vulkan"><a href="#Vulkan" class="headerlink" title="Vulkan"></a>Vulkan</h3><p>跨平台图形与计算应用程序接口,号称下一代OpenGL</p><p><a href="https://easyvulkan.github.io/index.html">首页 — EasyVulkan</a></p><p><a href="https://www.vulkan.org/">Home | Vulkan | Cross platform 3D Graphics</a></p><p><a href="https://github.com/PacktPublishing/Learning-Vulkan">PacktPublishing/Learning-Vulkan: Code repository for Learning Vulkan, published by Packt (github.com)</a></p><p><a href="https://vulkan-tutorial.com/">https://vulkan-tutorial.com/</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    createInstance();</span><br><span class="line">    setupDebugMessenger();</span><br><span class="line">    createSurface();</span><br><span class="line">    pickPhysicalDevice();</span><br><span class="line">    createLogicalDevice();</span><br><span class="line">    createSwapChain();</span><br><span class="line">    createImageViews();</span><br><span class="line">    createGraphicsPipeline();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createGraphicsPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Metal"><a href="#Metal" class="headerlink" title="Metal"></a>Metal</h3><p>苹果上的类似OpenGL,Direct3D,兼顾图形与计算,面向底层应用程序接口.</p><h2 id="相关应用库"><a href="#相关应用库" class="headerlink" title="相关应用库"></a>相关应用库</h2><ol><li>SFML</li><li>SDL</li><li>FLTK</li><li>Qt</li><li>GLFW(针对OpenGL图形库)</li><li>raylib</li><li>imgui</li><li>nanoGui</li><li>easyx</li><li><a href="https://oxygine.org/">Oxygine - 2D C++ game framework</a></li></ol><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ol><li><a href="https://jichu4n.com/posts/how-x-window-managers-work-and-how-to-write-one-part-i/">How X Window Managers Work, And How To Write One (Part I) (jichu4n.com)</a></li><li><a href="https://hereket.com/posts/linux_creating_x11_windows/">Xlib 01: Creating windows from scratch with Xlib on Linux | Hereket</a></li><li><a href="https://xcb.freedesktop.org/tutorial/">tutorial (xcb.freedesktop.org)</a></li><li><a href="https://www.cairographics.org/">cairographics.org</a></li><li><a href="https://zh.wikipedia.org/wiki/Metal_(API">Metal (API) - 维基百科,自由的百科全书 (wikipedia.org)</a>)</li><li><a href="https://zh.wikipedia.org/wiki/Vulkan">Vulkan - 维基百科,自由的百科全书 (wikipedia.org)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;当我们想要进行底层图形应用(GUI)开发时,往往需要用到窗口系统和图形库,这里简单介绍一下&lt;br&gt;</summary>
    
    
    
    
    <category term="window systems" scheme="https://www.sekyoro.top/tags/window-systems/"/>
    
    <category term="graphics library" scheme="https://www.sekyoro.top/tags/graphics-library/"/>
    
  </entry>
  
  <entry>
    <title>打实基础:cs61c学习</title>
    <link href="https://www.sekyoro.top/2024/10/01/%E6%89%93%E5%AE%9E%E5%9F%BA%E7%A1%80-cs61c%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2024/10/01/%E6%89%93%E5%AE%9E%E5%9F%BA%E7%A1%80-cs61c%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-10-01T06:18:42.000Z</published>
    <updated>2024-10-03T06:36:03.157Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>很早之间就想学学传说中的cs61a/b/c了,这里花两三天时间过一遍cs61c(2020).</p><span id="more"></span><p>整个课程做起来最大的问题是,过去的课程目前不开放给校外人员了,现有的资料没有保存图片,所以lab没有图片..</p><h2 id="Labs"><a href="#Labs" class="headerlink" title="Labs"></a>Labs</h2><h3 id="00"><a href="#00" class="headerlink" title="00"></a>00</h3><p>学习常用指令,我个人常用(由于我目前使用windows,许多指令都没有)find,grep,ps,kill等指令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep <span class="string">&quot;xxx&quot;</span></span><br><span class="line">find ./ -<span class="built_in">type</span> f -<span class="built_in">exec</span> grep <span class="string">&quot;xx&quot;</span> &#123;&#125; +</span><br></pre></td></tr></table></figure><p>现在Linux上有许多重写的更好用的工具,比如<code>ripgrep</code>,<code>btop</code>等等</p><h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><p>使用gdb和valgrind</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -o hello hello.c</span><br><span class="line">gdb hello</span><br><span class="line">b <span class="comment"># set breakpoint</span></span><br><span class="line">bt <span class="comment"># backtrace </span></span><br><span class="line">p expr <span class="comment"># display value</span></span><br><span class="line">c <span class="comment"># continue running</span></span><br><span class="line">n <span class="comment"># next line,stepping over function calls</span></span><br><span class="line">s <span class="comment"># next line,stepping into function calls</span></span><br></pre></td></tr></table></figure><p>详情查看manual<a href="https://www.learncs.site/assets/files/gdb5-refcard-89fdebb2475f348ded03071dd13271df.pdf">gdb5-refcard-89fdebb2475f348ded03071dd13271df.pdf (learncs.site)</a></p><p><img data-src="https://s2.loli.net/2024/10/01/vy67mZfx5C9RIok.png" alt="image-20241001160602317"></p><p>运行时内存错误可以使用valgrind. Valgrind是一个程序,模拟你的CPU和跟踪你的内存访问</p><p>此外写一个检查链表是否有循环的c代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ll_cycle.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ll_has_cycle</span><span class="params">(node *head)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* your code here */</span></span><br><span class="line">  <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  node *tortoise = head;</span><br><span class="line">  node *hare = tortoise-&gt;next-&gt;next;</span><br><span class="line">  <span class="keyword">while</span> (hare != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    tortoise = tortoise-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (hare == tortoise) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hare-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hare = hare-&gt;next-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><p>学习使用Makefile(虽然我现在基本使用CMake或者直接用visual studio(当然vs仙子啊也支持了cmake))</p><blockquote><p>makefile是代码目录中的一个文本文件(字面上标记为“makefile”)，其中包含一组规则，每个规则都有为其编译C程序的命令。每个makefile可以包含多个规则，每个规则编译一个或多个目标(例如可执行文件)或执行不同的目标。要编译一个目标，程序员只需要在他们的命令终端输入“make</p></blockquote><p>使用位操作分别获取,设置,翻转一个值的某位.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">get_bit</span><span class="params">(<span class="keyword">unsigned</span> x, <span class="keyword">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">// Returning -1 is a placeholder (it makes</span></span><br><span class="line">  <span class="comment">// no sense, because get_bit only returns</span></span><br><span class="line">  <span class="comment">// 0 or 1)</span></span><br><span class="line">  <span class="keyword">int</span> mask = <span class="number">1</span> &lt;&lt; n; <span class="comment">// e.g. n  = 5, 000100000</span></span><br><span class="line">  <span class="keyword">return</span> (x &amp; mask) &gt;&gt; n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set the nth bit of the value of x to v.</span></span><br><span class="line"><span class="comment">// Assume 0 &lt;= n &lt;= 31, and v is 0 or 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_bit</span><span class="params">(<span class="keyword">unsigned</span> *x, <span class="keyword">unsigned</span> n, <span class="keyword">unsigned</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="keyword">int</span> mask = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="number">1</span>) &#123;</span><br><span class="line">    *x = *x | mask;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *x = *x &amp; ~mask;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Flip the nth bit of the value of x.</span></span><br><span class="line"><span class="comment">// Assume 0 &lt;= n &lt;= 31</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip_bit</span><span class="params">(<span class="keyword">unsigned</span> *x, <span class="keyword">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="keyword">int</span> mask = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">  *x = *x ^ mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现线性反馈移位寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lfsr_calculate</span><span class="params">(<span class="keyword">uint16_t</span> *reg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">  <span class="keyword">int</span> bit0 = *reg &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> bit2 = (*reg &gt;&gt; <span class="number">2</span>) &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> bit3 = (*reg &gt;&gt; <span class="number">3</span>) &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> bit5 = (*reg &gt;&gt; <span class="number">5</span>) &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> new_bit = bit0 ^ bit2 ^ bit3 ^ bit5;</span><br><span class="line">  *reg = *reg &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> mask = new_bit &lt;&lt; <span class="number">15</span>;</span><br><span class="line">  *reg = *reg | mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实现一个动态长度array,其实就是利用<code>malloc</code>,<code>free</code>分配内存,这些内存往往在堆上.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  usize capacity;</span><br><span class="line">  uszie size;</span><br><span class="line">  <span class="keyword">int</span>* data;</span><br><span class="line">&#125; DArray;</span><br></pre></td></tr></table></figure><p>初始化和free时主要需要分别malloc整个结构和存储的data数据,</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">vector_t</span> *<span class="title">vector_new</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Declare what this function will return */</span></span><br><span class="line">  <span class="keyword">vector_t</span> *retval;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First, we need to allocate memory on the heap for the struct */</span></span><br><span class="line">  retval = (<span class="keyword">vector_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">vector_t</span>)); <span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check our return value to make sure we got memory */</span></span><br><span class="line">  <span class="keyword">if</span> (retval == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    allocation_failed();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Now we need to initialize our data.</span></span><br><span class="line"><span class="comment">     Since retval-&gt;data should be able to dynamically grow,</span></span><br><span class="line"><span class="comment">     what do you need to do? */</span></span><br><span class="line">  retval-&gt;size = <span class="number">1</span> <span class="comment">/* YOUR CODE HERE */</span>;</span><br><span class="line">  retval-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(retval-&gt;size * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) <span class="comment">/* YOUR CODE HERE */</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the data attribute of our vector to make sure we got memory */</span></span><br><span class="line">  <span class="keyword">if</span> (retval-&gt;data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">free</span>(retval); <span class="comment">// Why is this line necessary?</span></span><br><span class="line">    allocation_failed();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Complete the initialization by setting the single component to zero */</span></span><br><span class="line">  retval-&gt;data[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* and return... */</span></span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="03"><a href="#03" class="headerlink" title="03"></a>03</h3><p>RISCV汇编,</p><p>.data段落包含初始化的全局和静态变量, .word段用于分配和初始化内存(通常4字节)</p><p>.text段落包括程序的可执行指令,x0寄存器中值始终为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">main:</span><br><span class="line">    add t0, x0, x0 # curr_fib = 0</span><br><span class="line">    addi t1, x0, 1 # next_fib = 1</span><br><span class="line">la t3, n # load the address of the label n</span><br><span class="line">lw t3, 0(t3) # get the value that is stored at the adddress denoted by the label n</span><br><span class="line">fib:</span><br><span class="line">    beq t3, x0, finish # exit loop once we have completed n iterations</span><br><span class="line">    add t2, t1, t0 # new_fib = curr_fib + next_fib;</span><br><span class="line">    mv t0, t1 # curr_fib = next_fib;</span><br><span class="line">    mv t1, t2 # next_fib = new_fib;</span><br><span class="line">    addi t3, t3, -1 # decrement counter</span><br><span class="line">    j fib # loop</span><br><span class="line">finish:</span><br><span class="line">    addi a0, x0, 1 # argument to ecall to execute print integer</span><br><span class="line">    addi a1, t0, 0 # argument to ecall, the value to be printed</span><br><span class="line">    ecall # print integer ecall</span><br></pre></td></tr></table></figure><p><code>ecall</code>是系统调用,要传递参数，需要将其放入参数寄存器(a0-a7)。当函数执行时，它将在这些寄存器中查找参数。第一个参数应该放在a0中，第二个参数应该放在a1中，以此类推。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> source[] = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dest[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> -x * (x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; source[k] != <span class="number">0</span>; k++) &#123;</span><br><span class="line">        dest[k] = fun(source[k]);</span><br><span class="line">        sum += dest[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面c代码转为汇编,全局变量使用<code>.data</code>和<code>.word</code>分配,只写t和a寄存器(临时寄存器和参数寄存器),s寄存器在调用函数前注意保存</p><p><img data-src="https://s2.loli.net/2024/10/01/iKzPvVZAfa1pCnG.png" alt="image-20241001195355718"></p><ul><li><p><strong><code>li</code> 指令</strong>：将立即数加载到寄存器中。</p></li><li><p><strong><code>la</code> 指令</strong>：加载变量的地址到寄存器中。</p></li><li><p><strong><code>lw</code> 指令</strong>：从内存中加载一个 32 位字到寄存器中。</p></li><li><p><strong><code>sw</code> 指令</strong>：将寄存器中的 32 位字存储到内存中。</p></li><li><p><strong><code>sw</code> 指令</strong>：将寄存器中的 32 位字存储到内存中。</p></li><li><p><strong><code>sh</code> 指令</strong>：将寄存器中的 16 位半字存储到内存中。</p></li><li><p><strong><code>sb</code> 指令</strong>：将寄存器中的 8 位字节存储到内存中</p><p>内存地址主要就是寄存器offset寻址</p></li></ul><h4 id="RISC-V-调用约定"><a href="#RISC-V-调用约定" class="headerlink" title="RISC-V 调用约定"></a>RISC-V 调用约定</h4><p>RISC-V 的调用约定规定了哪些寄存器在函数调用时需要保存，哪些寄存器可以被修改。以下是一些主要的约定：</p><ol><li><strong>临时寄存器（Temporary Registers）</strong>：<ul><li><strong><code>t0</code> 至 <code>t6</code></strong>：这些寄存器可以在函数调用时被修改，调用者不需要保存这些寄存器的值。</li><li><strong><code>a0</code> 至 <code>a7</code></strong>：这些寄存器用于传递函数参数，也可以在函数调用时被修改，调用者不需要保存这些寄存器的值。</li></ul></li><li><strong>保存寄存器（Saved Registers）</strong>：<ul><li><strong><code>s0</code> 至 <code>s11</code></strong>：这些寄存器在函数调用时需要保存，被调用者必须在返回前恢复这些寄存器的值。</li><li><strong><code>ra</code></strong>：返回地址寄存器，被调用者必须在返回前恢复 <code>ra</code> 的值。</li></ul></li></ol><p><strong>保存和恢复寄存器</strong></p><p>为了确保函数调用的正确性，通常需要在函数入口处保存这些寄存器的值，并在函数返回前恢复这些值。这通常通过使用堆栈来实现(利用<code>sp</code>栈寄存器). 通常内存上的值首先加到寄存器上然后再进行计算.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">n: .word 8</span><br><span class="line">lw t0, 0(sp) ; t0 = [sp]</span><br><span class="line">la t1, n</span><br><span class="line">lw t1, 0(t1) ; t1 = [t1]</span><br><span class="line">addi t1,t1,2</span><br><span class="line">sw t0, 0(t1) ; [t1] = t0</span><br></pre></td></tr></table></figure><p>使用RISCV写一段factorial代码,注意要么写为recursion要么写更简单的iteration</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">factorial</span><span class="params">(n)</span></span> = n!</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">factorial:</span><br><span class="line">  addi sp,sp,-4</span><br><span class="line">  sw s0,0(sp) # sp[0] = s0</span><br><span class="line">  addi s0,x0,1 # sum = 1</span><br><span class="line">  addi t0,x0,1 # i = 1</span><br><span class="line">loop:</span><br><span class="line">  blt a0,t0,exit # if n &lt; i, goto exit</span><br><span class="line">  mul s0,s0,t0# sum = sum * i</span><br><span class="line">  addi t0,t0,1 # i++</span><br><span class="line">  jal x0,loop</span><br><span class="line">exit:</span><br><span class="line">  add a0,x0,s0 # a0 = sum</span><br><span class="line">  lw s0,0(sp) # s0 = sp[0]</span><br><span class="line">  addi sp,sp,4</span><br><span class="line">  jr ra</span><br></pre></td></tr></table></figure><blockquote><p>所有覆盖按约定保留的寄存器的函数都必须有一个序言(prologue)和一个尾声(epilogue)，序言将这些寄存器值保存到函数开始时的堆栈中;epilogue将为函数的调用者恢复这些值。 由于调用约定违反而导致的bug很难发现,不要直接修改这些寄存器</p><p>也就是对于保存寄存器的处理,包括s开头的寄存器和ra寄存器(受jal影响)</p></blockquote><p>后面有一个专门的测试,在每个函数前后写上将s寄存器值保存到内存的代码,此外如果一个函数栈中调用了另一个函数,如果那个函数修改了t寄存器,那么父函数栈也需要保存相应的寄存器. 对于ra寄存器同理,函数<code>jrl</code>调用另一个函数,修改了ra寄存器值,也需要在调用另一个函数之前保存ra,否则这个函数无法通过<code>jr</code>跳转回去了(当然可以使用j label调转到某个位置).</p><p>此外还使用RISC-V实现了链表分配和map操作.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">create_default_list:</span><br><span class="line">    addi sp, sp, -12</span><br><span class="line">    sw  ra, 0(sp)</span><br><span class="line">    sw  s0, 4(sp)</span><br><span class="line">    sw  s1, 8(sp)</span><br><span class="line">    li  s0, 0       # pointer to the last node we handled</span><br><span class="line">    li  s1, 0       # number of nodes handled</span><br><span class="line">loop:   #do...</span><br><span class="line">    li  a0, 8</span><br><span class="line">    jal ra, malloc      # get memory for the next node</span><br><span class="line">    sw  s1, 0(a0)   # node-&gt;value = i</span><br><span class="line">    sw  s0, 4(a0)   # node-&gt;next = last</span><br><span class="line">    add s0, a0, x0  # last = node</span><br><span class="line">    addi    s1, s1, 1   # i++</span><br><span class="line">    addi t0, x0, 10</span><br><span class="line">    bne s1, t0, loop    # ... while i!= 10</span><br><span class="line">    lw  ra, 0(sp)</span><br><span class="line">    lw  s0, 4(sp)</span><br><span class="line">    lw  s1, 8(sp)</span><br><span class="line">    addi sp, sp, 12</span><br><span class="line">    jr ra</span><br><span class="line">malloc:</span><br><span class="line">    addi    a1, a0, 0</span><br><span class="line">    addi    a0, x0 9</span><br><span class="line">    ecall</span><br><span class="line">    jr  r</span><br></pre></td></tr></table></figure><p>上面malloc中调用了<code>ecall</code>系统调用.</p><p>实现高阶函数<code>map</code>操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">map:</span><br><span class="line">    # Prologue: Make space on the stack and back-up registers</span><br><span class="line">    ### YOUR CODE HERE ###</span><br><span class="line">    addi sp,sp,-12</span><br><span class="line">    sw ra, 0(sp)</span><br><span class="line">    sw s0, 4(sp)</span><br><span class="line">    sw s1, 8(sp)</span><br><span class="line"></span><br><span class="line">    beq a0, x0, done    # If we were given a null pointer (address 0), we&#x27;re done.</span><br><span class="line"></span><br><span class="line">    add s0, a0, x0  # Save address of this node in s0</span><br><span class="line">    add s1, a1, x0  # Save address of function in s1</span><br><span class="line"></span><br><span class="line">    # Remember that each node is 8 bytes long: 4 for the value followed by 4 for the pointer to next.</span><br><span class="line">    # What does this tell you about how you access the value and how you access the pointer to next?</span><br><span class="line"></span><br><span class="line">    # load the value of the current node into a0</span><br><span class="line">    # THINK: why a0? prepare to call map</span><br><span class="line">    ### YOUR CODE HERE ###</span><br><span class="line">    lw a0,0(s0) # a0 = [s0]</span><br><span class="line"></span><br><span class="line">    # Call the function in question on that value. DO NOT use a label (be prepared to answer why).</span><br><span class="line">    # What function? Recall the parameters of &quot;map&quot;</span><br><span class="line">    ### YOUR CODE HERE ###</span><br><span class="line">    # jal is used to jump to label</span><br><span class="line">    jalr ra, s1 ,0 # call square</span><br><span class="line">    # Where can you assume the returned value is?</span><br><span class="line">    ### YOUR CODE HERE ###</span><br><span class="line">    sw a0, 0(s0) # [s0] = a0</span><br><span class="line"></span><br><span class="line">    # Load the address of the next node into a0</span><br><span class="line">    # The Address of the next node is an attribute of the current node.</span><br><span class="line">    # Think about how structs are organized in memory.</span><br><span class="line">    ### YOUR CODE HERE ###</span><br><span class="line">    lw a0, 4(s0) # a0 = [s0+4]</span><br><span class="line"></span><br><span class="line">    # Put the address of the function back into a1 to prepare for the recursion</span><br><span class="line">    # THINK: why a1? What about a0?</span><br><span class="line">    ### YOUR CODE HERE ###</span><br><span class="line">    mv a1, s1 # not really necessary, cause a1 is not changed in square functino</span><br><span class="line"></span><br><span class="line">    # recurse</span><br><span class="line">    ### YOUR CODE HERE ###</span><br><span class="line">    jal ra, map</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    # Epilogue: Restore register values and free space from the stack</span><br><span class="line">    ### YOUR CODE HERE ###</span><br><span class="line">    lw ra, 0(sp)</span><br><span class="line">    lw s0, 4(sp)</span><br><span class="line">    lw s1, 8(sp)</span><br><span class="line">    addi sp,sp,12</span><br><span class="line">    jr ra # Return to caller</span><br><span class="line"></span><br><span class="line">square:</span><br><span class="line">    mul a0 ,a0, a0</span><br><span class="line">    jr ra</span><br></pre></td></tr></table></figure><h3 id="04"><a href="#04" class="headerlink" title="04"></a>04</h3><p>修改一个汇编代码中的问题,我卡了很久还是看了其他人的解答.</p><p>在main中获取数组第一个值地址和大小,在mainLoop中不断遍历,修改数组值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">map:</span><br><span class="line">    addi sp, sp, -12</span><br><span class="line">    sw ra, 0(sp)</span><br><span class="line">    sw s1, 4(sp)</span><br><span class="line">    sw s0, 8(sp)</span><br><span class="line"></span><br><span class="line">    beq a0, x0, done    # if we were given a null pointer, we&#x27;re done.</span><br><span class="line"></span><br><span class="line">    add s0, a0, x0      # save address of this node in s0</span><br><span class="line">    add s1, a1, x0      # save address of function in s1</span><br><span class="line">    add t0, x0, x0      # t0 is a counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    lw t1, 0(s0)   # load the address of the array of current node into t1</span><br><span class="line">    lw t2, 4(s0)        # load the size of the node&#x27;s array into t2</span><br><span class="line">    addi t1, t1, -4</span><br><span class="line">    # remember that each node is 12 bytes long:</span><br><span class="line">    # - 4 for the array pointer</span><br><span class="line">    # - 4 for the size of the array</span><br><span class="line">    # - 4 more for the pointer to the next node</span><br><span class="line"></span><br><span class="line">    # also keep in mind that we should not make ANY assumption on which registers</span><br><span class="line">    # are modified by the callees, even when we know the content inside the functions </span><br><span class="line">    # we call. this is to enforce the abstraction barrier of calling convention.</span><br><span class="line">mapLoop:</span><br><span class="line">    # add t1, s0, x0      # load the address of the array of current node into t1</span><br><span class="line">    addi t1, t1, 4      # offset the array address by the count</span><br><span class="line">    lw a0, 0(t1)        # load the value at that address into a0</span><br><span class="line">    addi sp,sp,-12</span><br><span class="line">    sw t0, 0(sp)</span><br><span class="line">    sw t1, 4(sp)</span><br><span class="line">    sw t2, 8(sp)</span><br><span class="line">    jalr ra,s1,0             # call the function on that value.</span><br><span class="line">    lw t0, 0(sp)</span><br><span class="line">    lw t1, 4(sp)</span><br><span class="line">    lw t2, 8(sp)</span><br><span class="line">    addi sp,sp,12</span><br><span class="line"></span><br><span class="line">    sw a0, 0(t1)        # store the returned value back into the array</span><br><span class="line">    addi t0, t0, 1      # increment the count</span><br><span class="line">    bne t0, t2, mapLoop # repeat if we haven&#x27;t reached the array size yet</span><br><span class="line"></span><br><span class="line">    lw a0, 8(s0)  # load the address of the next node into a0</span><br><span class="line">    mv a1,s1</span><br><span class="line"></span><br><span class="line">    jal  map            # recurse</span><br><span class="line">done:</span><br><span class="line">    lw s0, 8(sp)</span><br><span class="line">    lw s1, 4(sp)</span><br><span class="line">    lw ra, 0(sp)</span><br><span class="line">    addi sp, sp, 12</span><br><span class="line">    jr ra</span><br></pre></td></tr></table></figure><p>然后写一个映射</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">f</span><span class="params">(-<span class="number">3</span>)</span></span> = <span class="number">6</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(-<span class="number">2</span>)</span></span> = <span class="number">61</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(-<span class="number">1</span>)</span></span> = <span class="number">17</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="number">0</span>)</span></span> = -<span class="number">38</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span> = <span class="number">19</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="number">2</span>)</span></span> = <span class="number">42</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="number">3</span>)</span></span> = <span class="number">5</span></span><br></pre></td></tr></table></figure><p>其中a0寄存器是输入值,a1是输出列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f:</span><br><span class="line">    addi a0,a0,3</span><br><span class="line">    # li t0, 4</span><br><span class="line">    # mul a0,a0,t0</span><br><span class="line">    # add s0,a1,a0 # s0 is the address</span><br><span class="line">    slli a0,a0,2</span><br><span class="line">    add a0,a1,a0</span><br><span class="line">    lw a0, 0(a0)</span><br><span class="line">    </span><br><span class="line">    jr ra   </span><br></pre></td></tr></table></figure><h3 id="05"><a href="#05" class="headerlink" title="05"></a>05</h3><p>使用logisim工具构建模拟电路,使用AND,OR,NOT基本件构建NAND,NOR,XOR以及Mux. 此外还有个寄存器</p><p><img data-src="https://s2.loli.net/2024/10/02/2QKgjTAZU48rXcP.png" alt="image-20241002193745279"></p><p>FSM代表有限状态机。FSM跟踪给定的输入，根据这些输入在状态之间移动，并在每次输入时输出一些东西。</p><p>我们使用寄存器来存储当前所在FSM的状态，并使用组合逻辑将FSM的输入和当前寄存器状态映射到FSM的输出和下一个寄存器状态。说实话,这个FSM的作用我没太看懂,貌似是连续两次一样的输入,输出就固定了. 需要连现在状态到下一次状态的电路线,我按照truth  table直接推的.</p><p>此外还需要画出rotr电路,我一开始画成下面这样,使用Mux-16针对每个0-15值选择对应偏移…</p><p><img data-src="https://s2.loli.net/2024/10/02/VFjKlRYLwc826qb.png" alt="image-20241002224915855"></p><p>其实可以根据每一位使用mux-2,简单得多</p><p><img data-src="https://s2.loli.net/2024/10/02/MG3ecRyFif1njkb.png" alt="image-20241002231322258"></p><h3 id="06"><a href="#06" class="headerlink" title="06"></a>06</h3><p>关于电路流水线时间的问题,通过编排优化流水线</p><p><img data-src="https://s2.loli.net/2024/10/02/q8GXlWucIeimaCz.png" alt="image-20241002231814951"></p><p>这个电路所做的就是接收两个输入，将它们相乘，然后将结果与当前状态值相加。对于这个电路，设<strong>加法器块的传播延迟为45ns，乘法块的传播延迟为60ns。寄存器的CLK-to-Q延迟为10ns，设置时间为10ns，保持时间为5ns</strong>。计算该电路可以工作的最大时钟速率。假设两个输入都来自从外部源接收数据的时钟寄存器。</p><p>为了确保电路能够正确工作，时钟周期必须满足以下条件：</p><ol><li><strong>数据路径延迟</strong> + <strong>CLK-to-Q 延迟</strong> + <strong>建立时间</strong> ≤ 时钟周期</li><li><strong>保持时间</strong> &lt; 时钟周期</li></ol><p>首先，计算第一个条件： 时钟周期≥数据路径延迟+CLK-to-Q 延迟+建立时间时钟周期≥数据路径延迟+CLK-to-Q 延迟+建立时间 时钟周期≥105 ns+10 ns+10 ns时钟周期≥105ns+10ns+10ns 时钟周期≥125 ns时钟周期≥125ns</p><p>接下来，检查保持时间的要求： 时钟周期&gt;5 ns时钟周期&gt;5ns</p><p>显然，125ns 已经大于 5ns，所以保持时间的要求自然满足。</p><p><img data-src="https://s2.loli.net/2024/10/02/HAY1F6ZsJbhjix7.png" alt="image-20241002232639288"></p><p>如果一个计算依赖于前一个计算的输出，那么很难对它们进行管道处理，我们通常需要插入一个(或几个)管道“bubbles”，以确保第一个计算的输出准备好成为第二个计算的输入。提醒一下，bubbles是在管道中故意延迟指令的过程。理解为什么这种“bubbles”对于这种特殊的电路是不必要的是很重要的。</p><p>下面这种pipeline方案在乘法和加法之间增加了一个register保存中间值,输出会增加一个前导0</p><p><img data-src="https://s2.loli.net/2024/10/02/DZFX7x5wgIiQHCK.png" alt="image-20241002234052193"></p><p>在non_pipeline版本中,一个tick会同时更新输出值和寄存器的值</p><p>假设我们在乘法器和加法器之间插入一个寄存器，将电路分成两个阶段：</p><ol><li><strong>第一阶段</strong>：乘法器</li><li><strong>第二阶段</strong>：加法器</li></ol><p>每个阶段的延迟如下：</p><ul><li>第一阶段（乘法器）延迟：60ns</li><li>第二阶段（加法器）延迟：45ns</li></ul><p>寄存器的时序要求</p><ul><li><strong>CLK-to-Q 延迟</strong>：10ns</li><li><strong>建立时间</strong>：10ns</li><li><strong>保持时间</strong>：5ns</li></ul><p><strong>计算每个阶段的最大时钟周期</strong></p><p>为了确保每个阶段的时序要求都得到满足，我们需要计算每个阶段的最大时钟周期。</p><p><strong>第一阶段</strong></p><ul><li><strong>数据路径延迟</strong>：60ns</li><li><strong>CLK-to-Q 延迟</strong>：10ns</li><li><strong>建立时间</strong>：10ns</li></ul><p>第一阶段的时钟周期要求： 时钟周期≥60 ns+10 ns+10 ns时钟周期≥60ns+10ns+10ns 时钟周期≥80 ns时钟周期≥80ns</p><p><strong>第二阶段</strong></p><ul><li><strong>数据路径延迟</strong>：45ns</li><li><strong>CLK-to-Q 延迟</strong>：10ns</li><li><strong>建立时间</strong>：10ns</li></ul><p>第二阶段的时钟周期要求： 时钟周期≥45 ns+10 ns+10 ns时钟周期≥45ns+10ns+10ns 时钟周期≥65 ns时钟周期≥65ns</p><p>为了确保整个流水线电路能够正确工作，时钟周期必须满足所有阶段中最严格的要求。因此，最终的时钟周期应取这两个阶段的最大值：</p><p>时钟周期=max⁡(80 ns,65 ns)=80 ns时钟周期=max(80ns,65ns)=80ns</p><p>由于乘法延时比加法长,这两个阶段相对独立.</p><p>在流水线设计中，“气泡”（bubbles）通常指的是空闲的时钟周期，用于处理流水线中的依赖关系或避免冲突。在某些情况下，插入气泡是为了确保数据的正确性和避免数据冒险（data hazards）。然而，在这个电路中，插入一个寄存器将乘法和加法操作分成两个独立的阶段，这样可以避免大多数常见的数据冒险，因此不需要插入气泡。</p><p>为什么这个电路不需要气泡？</p><ol><li><strong>独立的流水线阶段</strong>：<ul><li>通过在乘法器和加法器之间插入一个寄存器，将整个操作分成了两个独立的阶段。</li><li>每个阶段都有自己的时钟周期，数据在每个阶段的末尾被寄存器捕获并传递到下一个阶段。</li></ul></li><li><strong>数据流的清晰分离</strong>：<ul><li>在第一阶段，乘法器完成乘法操作，并将结果存储在寄存器中。</li><li>在第二阶段，加法器从寄存器中读取乘法结果，并将其与当前状态值相加。</li><li>这种分离确保了每个阶段的数据都是在前一个阶段完成后的稳定状态下进行处理的，避免了数据冒险。</li></ul></li><li><strong>时序要求的满足</strong>：<ul><li>每个阶段的时钟周期都足够长，以满足寄存器的时序要求（CLK-to-Q 延迟、建立时间和保持时间）。</li><li>例如，第一阶段的时钟周期为 80ns，第二阶段的时钟周期为 65ns，这两个值都足以确保数据在每个阶段的末尾被正确捕获和传递</li></ul></li></ol><h3 id="07"><a href="#07" class="headerlink" title="07"></a>07</h3><p>主要介绍cache,</p><p>write-back意味着在写入命中时，数据只被写入缓存，当这个写入发生时，被写入块的脏位变为1。写入缓存的速度很快，因此回写缓存中的写入延迟通常非常小。但是，当从回写缓存中取出块时，如果脏位为1，则必须使用该块的内容更新内存，因为它包含尚未反映在内存中的更改。这使得回写缓存更难以在硬件中实现。</p><p>write-through意味着在写命中时，数据同时写入缓存和主存。写入缓存很快，但写入主存很慢;这使得透写缓存中的写延迟比回写缓存中的写延迟慢。然而，透写缓存意味着更简单的硬件，因为我们可以假设在透写缓存中，内存总是拥有最新的数据。</p><p>Write-around意味着在任何情况下，数据只被写入主存;如果缓存中有要写入的块，则块的有效位变为无效位。从本质上讲，在写绕过缓存中没有写命中这样的事情;写“命中”和写“未命中”的作用是一样的</p><p><strong>miss policies</strong></p><p>write -allocate的意思是，在写失败时，将丢失的块拉到缓存中。对于回写，写分配缓存，这意味着内存永远不会直接写入;相反，总是对缓存进行写操作，并且在删除时更新内存。</p><p><strong>过程</strong>：</p><ol><li><strong>写操作</strong>：处理器尝试写入某个内存地址。</li><li><strong>缓存查找</strong>：缓存控制器检查该地址是否在缓存中。</li><li><strong>未命中</strong>：如果该地址不在缓存中，发生未命中。</li><li><strong>加载缓存行</strong>：从主存中读取该地址所在的整个缓存行，并将其加载到缓存中。</li><li><strong>写入缓存</strong>：将写操作的数据写入缓存中的相应位置。</li><li><strong>写入主存</strong>：根据缓存的写策略（写回或写穿透），决定是否立即将数据写入主存</li></ol><p>no write-allocate意味着在写失败时，不会将错过的块拉到缓存中。只更新内存</p><p><strong>过程</strong>：</p><ol><li><strong>写操作</strong>：处理器尝试写入某个内存地址。</li><li><strong>缓存查找</strong>：缓存控制器检查该地址是否在缓存中。</li><li><strong>未命中</strong>：如果该地址不在缓存中，发生未命中。</li><li><strong>加载缓存行</strong>：从主存中读取该地址所在的整个缓存行，并将其加载到缓存中。</li><li><strong>写入缓存</strong>：将写操作的数据写入缓存中的相应位置。</li><li><strong>写入主存</strong>：根据缓存的写策略（写回或写穿透），决定是否立即将数据写入主存</li></ol><p><strong>更新策略</strong></p><p>LRU—最近最少使用当我们决定移除缓存块以腾出空间时，我们选择在所有块中使用时间最远的块</p><p>随机-当我们决定移除一个缓存块来腾出空间时，我们随机选择缓存中的一个块来移除。</p><p>MRU—最近使用的—当我们决定移除缓存块以腾出空间时，我们选择所有块中最近使用的块</p><p>针对下面代码,假设缓存是write through,write-allocate,也就是命中时同时写入缓存和内存,没有命中写入缓存与内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[];  <span class="comment">//Assume sizeof(int) == 4</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; repcount; k++) &#123;<span class="comment">// repeat repcount times</span></span><br><span class="line">  <span class="comment">/* Step through the selected array segment with the given step size. */</span></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; arraysize; index += stepsize) &#123;</span><br><span class="line">    <span class="keyword">if</span>(option==<span class="number">0</span>)</span><br><span class="line">      <span class="built_in">array</span>[index] = <span class="number">0</span>;<span class="comment">// Option 0: One cache access - write</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">array</span>[index] = <span class="built_in">array</span>[index] + <span class="number">1</span>;<span class="comment">// Option 1: Two cache accesses - read AND write</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缓存行的组织</strong></p><p>缓存行的组织方式通常有以下几种：</p><ol><li><strong>直接映射（Direct-Mapped）</strong>：<ul><li>每个主存块只能映射到缓存中的一个特定位置。</li><li>简单但容易发生冲突未命中。</li></ul></li><li><strong>组相联（Set-Associative）</strong>：<ul><li>主存块可以映射到缓存中的多个位置（一组）。</li><li>平衡了直接映射和全相联的优缺点。</li></ul></li><li><strong>全相联（Fully Associative）</strong>：<ul><li>主存块可以映射到缓存中的任意位置。</li><li>复杂但灵活性高</li></ul></li></ol><h4 id="Scene-1"><a href="#Scene-1" class="headerlink" title="Scene 1"></a>Scene 1</h4><ul><li><strong>Array Size (<code>a0</code>)</strong>: 128 (bytes)</li><li><strong>Step Size (<code>a1</code>)</strong>: 8</li><li><strong>Rep Count (<code>a2</code>)</strong>: 4</li><li><strong>Option (<code>a3</code>)</strong>: 0</li></ul><p><strong>Cache Parameters</strong>: (set these in the Cache tab)</p><ul><li><strong>Cache Levels</strong>: 1</li><li><strong>Block Size</strong>: 8</li><li><strong>Number of Blocks</strong>: 4</li><li><strong>Enable?</strong>: Should be green</li><li><strong>Placement Policy</strong>: Direct Mapped</li><li><strong>Associativity</strong>: 1 (Venus won’t let you change this, why?)</li><li><strong>Block Replacement Policy</strong>: LRU</li></ul><p>128/8/4=4,所以一次遍历会写入4次,遍历4次就会写入16次. 发现每次都没有命中,这是为什么呢？ 我们想想,每次没命中就会把对应4字节内容放入缓存和内存(write through,write-allocate),遍历一遍之后block中</p><p><img data-src="https://s2.loli.net/2024/10/03/nkSE5IHOro7KWYV.png" alt="image-20241003134801342"></p><p>cache命中的应用就是矩阵(线性代数)运算</p><p>要正确计算矩阵乘法，循环顺序并不重要。但是<strong>选择访问矩阵元素的顺序会对性能产生很大的影响。当内存访问利用空间和时间局部性，利用已经包含在缓存中的块时，缓存性能更好</strong>(缓存命中更多，缓存丢失更少)。优化程序的内存访问模式对于从内存层次结构中获得良好的性能至关重要</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multMat1</span><span class="params">( <span class="keyword">int</span> n, <span class="keyword">float</span> *A, <span class="keyword">float</span> *B, <span class="keyword">float</span> *C )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="comment">/* This is ijk loop order. */</span></span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; n; i++ )</span><br><span class="line">        <span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; n; j++ )</span><br><span class="line">            <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; n; k++ )</span><br><span class="line">                C[i+j*n] += A[i+k*n]*B[k+j*n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Cache-Blocksize"><a href="#Cache-Blocksize" class="headerlink" title="Cache Blocksize"></a>Cache Blocksize</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose_blocking</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> blocksize, <span class="keyword">int</span> *dst, <span class="keyword">int</span> *src)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += blocksize) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += blocksize) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; blocksize; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; blocksize; y++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (i + x &lt; n &amp;&amp; j + y &lt; n) &#123;</span><br><span class="line">            dst[j + y + (i + x) * n] = src[i + x + (j + y) * n];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置blocksize,一次填写一个方形块，其中每个方形块的尺寸为blocksize × blocksize。</p><p>后面几个lab就是关于页内存,SIMD,OpenMP并行编程以及Spark等等.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.learncs.site/docs/intro">前言 | CS自学社区 (learncs.site)</a></li><li><a href="https://www.learncs.site/assets/files/gdb5-refcard-89fdebb2475f348ded03071dd13271df.pdf">gdb5-refcard-89fdebb2475f348ded03071dd13271df.pdf (learncs.site)</a></li><li><a href="https://www.learncs.site/assets/files/riscvcard-75f9fb3a791fab6eee17d3cf216f77f0.pdf">HTU2.indd (learncs.site)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;很早之间就想学学传说中的cs61a/b/c了,这里花两三天时间过一遍cs61c(2020).&lt;/p&gt;</summary>
    
    
    
    
    <category term="c" scheme="https://www.sekyoro.top/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Just For Fun: 学习c++之后可以尝试的框架/工具</title>
    <link href="https://www.sekyoro.top/2024/09/30/Just-For-Fun-%E5%AD%A6%E4%B9%A0c-%E4%B9%8B%E5%90%8E%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E7%9A%84%E6%A1%86%E6%9E%B6-%E5%B7%A5%E5%85%B7/"/>
    <id>https://www.sekyoro.top/2024/09/30/Just-For-Fun-%E5%AD%A6%E4%B9%A0c-%E4%B9%8B%E5%90%8E%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E7%9A%84%E6%A1%86%E6%9E%B6-%E5%B7%A5%E5%85%B7/</id>
    <published>2024-09-30T09:13:50.000Z</published>
    <updated>2024-10-02T15:05:51.395Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>学习c++与其他语言一个不同之处就是, 你可能不能很快地构建一些有趣的项目. </p><p>这时你可能会转向Rust作为代餐,享受安全系统编程语言带来的性能,同时也有一些高级语言所有的强大标准库.或者你也有可能转向Java,C#等更加具有高级应用生态的语言,利用自带的标准库以及强大的三方生态,快速构建性能并不算差的应用. 这里,我简单介绍一下可以使用c++的框架/库以便play for fun.<br><span id="more"></span></p><p>c++常见的开发系统/底层应用主要方向就是1)图形学 2)网络 3) 存储 4)高性能计算</p><p>这里面作为应用开发比较有趣的可能就是利用网络通信再加上图形绘制的游戏开发了. 事实上c++中游戏开发的大佬还是很多的. 作为学习者来说也有许多这方面的库/框架</p><h2 id="较为底层的图形学接口"><a href="#较为底层的图形学接口" class="headerlink" title="较为底层的图形学接口"></a>较为底层的图形学接口</h2><h3 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h3><p><a href="https://www.opengl.org/">OpenGL - The Industry Standard for High Performance Graphics</a></p><p><a href="https://learnopengl-cn.github.io/">主页 - LearnOpenGL CN (learnopengl-cn.github.io)</a></p><p>OpenGL是一个图形API,它是跨平台的,使用c++. 我觉得这里并不需要过多介绍</p><p>Vulkan,Dir等也类似.</p><h2 id="封装后的UI"><a href="#封装后的UI" class="headerlink" title="封装后的UI"></a>封装后的UI</h2><h3 id="Dear-ImGUI"><a href="#Dear-ImGUI" class="headerlink" title="Dear ImGUI"></a>Dear ImGUI</h3><p><a href="https://github.com/ocornut/imgui">ocornut/imgui: Dear ImGui: Bloat-free Graphical User interface for C++ with minimal dependencies (github.com)</a></p><p>Dear ImGui是一个c++图形用户界面库.它输出优化的顶点缓冲区,可以在启用3d管道的应用程序中随时渲染。它快速、可移植、与渲染器无关，并且是自包含的(没有外部依赖)</p><p>这个库需要你格外安装图形学API与窗口管理工具,比如OpenGL+GLFW.之前我写过简单的搭建教程<a href="https://www.sekyoro.top/2024/09/11/Dear-ImGUI-不太一样的GUI/#more">Dear-ImGUI:不太一样的GUI | Sekyoro的博客小屋</a>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;imgui.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;imgui_impl_glfw.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;imgui_impl_opengl3.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span> <span class="comment">// Will drag system OpenGL headers</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">glfw_error_callback</span><span class="params">(<span class="keyword">int</span> error, <span class="keyword">const</span> <span class="keyword">char</span> *description)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;GLFW Error %d: %s\n&quot;</span>, error, description);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Setup Dear ImGui context</span></span><br><span class="line">  <span class="built_in">glfwSetErrorCallback</span>(glfw_error_callback);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *glsl_version = <span class="string">&quot;#version 130&quot;</span>;</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">0</span>);</span><br><span class="line">  GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(</span><br><span class="line">      <span class="number">1280</span>, <span class="number">720</span>, <span class="string">&quot;Dear ImGui GLFW+OpenGL3 example&quot;</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (window == <span class="literal">nullptr</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">  <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>); <span class="comment">// Enable vsync</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">IMGUI_CHECKVERSION</span>();</span><br><span class="line">  <span class="comment">// initialize</span></span><br><span class="line">  ImGui::<span class="built_in">CreateContext</span>();</span><br><span class="line">  ImGuiIO &amp;io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">  io.ConfigFlags |=</span><br><span class="line">      ImGuiConfigFlags_NavEnableKeyboard; <span class="comment">// Enable Keyboard Controls</span></span><br><span class="line">  io.ConfigFlags |=</span><br><span class="line">      ImGuiConfigFlags_NavEnableGamepad; <span class="comment">// Enable Gamepad Controls</span></span><br><span class="line">  <span class="comment">// io.ConfigFlags |= ImGuiConfigFlags_DockingEnable; // IF using Docking</span></span><br><span class="line">  <span class="comment">// Branch</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Setup Platform/Renderer backends</span></span><br><span class="line">  <span class="built_in">ImGui_ImplGlfw_InitForOpenGL</span>(</span><br><span class="line">      window, <span class="literal">true</span>); <span class="comment">// Second param install_callback=true will install</span></span><br><span class="line">                     <span class="comment">// GLFW callbacks and chain to existing ones.</span></span><br><span class="line">  <span class="built_in">ImGui_ImplOpenGL3_Init</span>();</span><br><span class="line">  <span class="keyword">bool</span> show_demo_window&#123;<span class="literal">true</span>&#125;;</span><br><span class="line">  <span class="keyword">bool</span> show_another_window&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">  ImVec4 clear_color = <span class="built_in">ImVec4</span>(<span class="number">0.45f</span>, <span class="number">0.55f</span>, <span class="number">0.60f</span>, <span class="number">1.00f</span>);</span><br><span class="line">  <span class="comment">// (Your code calls glfwPollEvents())</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// Start the Dear ImGui frame</span></span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class="line">    <span class="comment">// Poll and handle events (inputs, window resize, etc.)</span></span><br><span class="line">    <span class="comment">// You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to</span></span><br><span class="line">    <span class="comment">// tell if dear imgui wants to use your inputs.</span></span><br><span class="line">    <span class="comment">// - When io.WantCaptureMouse is true, do not dispatch mouse input data to</span></span><br><span class="line">    <span class="comment">// your main application, or clear/overwrite your copy of the mouse data.</span></span><br><span class="line">    <span class="comment">// - When io.WantCaptureKeyboard is true, do not dispatch keyboard input</span></span><br><span class="line">    <span class="comment">// data to your main application, or clear/overwrite your copy of the</span></span><br><span class="line">    <span class="comment">// keyboard data. Generally you may always pass all inputs to dear imgui,</span></span><br><span class="line">    <span class="comment">// and hide them from your application based on those two flags.</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetWindowAttrib</span>(window, GLFW_ICONIFIED) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">ImGui_ImplGlfw_Sleep</span>(<span class="number">10</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// at the begining of the frame</span></span><br><span class="line">    <span class="built_in">ImGui_ImplOpenGL3_NewFrame</span>();</span><br><span class="line">    <span class="built_in">ImGui_ImplGlfw_NewFrame</span>();</span><br><span class="line">    ImGui::<span class="built_in">NewFrame</span>();</span><br><span class="line">    <span class="comment">// ImGui::ShowDemoWindow(); // Show demo window! :)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">float</span> f = <span class="number">.0</span>f;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    ImGui::<span class="built_in">Text</span>(<span class="string">&quot;This is some useful text.&quot;</span>);</span><br><span class="line">    ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;Demo Window&quot;</span>, &amp;show_demo_window);</span><br><span class="line">    ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;Another Window&quot;</span>, &amp;show_another_window);</span><br><span class="line">    ImGui::<span class="built_in">SliderFloat</span>(<span class="string">&quot;float&quot;</span>, &amp;f, <span class="number">.0</span>f, <span class="number">1.f</span>);</span><br><span class="line">    ImGui::<span class="built_in">ColorEdit3</span>(<span class="string">&quot;clear color&quot;</span>, (<span class="keyword">float</span> *)&amp;clear_color);</span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Button&quot;</span>)) &#123;</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">    ImGui::<span class="built_in">Text</span>(<span class="string">&quot;counter = %d&quot;</span>, counter);</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Application average %.3f ms/frame (%.1f PFS)&quot;</span>,</span><br><span class="line">                <span class="number">1000.0f</span> / io.Framerate, io.Framerate);</span><br><span class="line">    ImGui::<span class="built_in">End</span>();</span><br><span class="line">    <span class="keyword">if</span> (show_another_window) &#123;</span><br><span class="line">      ImGui::<span class="built_in">Begin</span>(</span><br><span class="line">          <span class="string">&quot;Another Window&quot;</span>,</span><br><span class="line">          &amp;show_another_window); <span class="comment">// Pass a pointer to our bool variable (the</span></span><br><span class="line">                                 <span class="comment">// window will have a closing button that will</span></span><br><span class="line">                                 <span class="comment">// clear the bool when clicked)</span></span><br><span class="line">      ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Hello from another window!&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Close Me&quot;</span>))</span><br><span class="line">        show_another_window = <span class="literal">false</span>;</span><br><span class="line">      ImGui::<span class="built_in">End</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//// Rendering</span></span><br><span class="line">    <span class="comment">// (Your code clears your framebuffer, renders your other stuff etc.)</span></span><br><span class="line">    ImGui::<span class="built_in">Render</span>();</span><br><span class="line">    <span class="keyword">int</span> display_w, display_h;</span><br><span class="line">    <span class="built_in">glfwGetFramebufferSize</span>(window, &amp;display_w, &amp;display_h);</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, display_w, display_h);</span><br><span class="line">    <span class="built_in">glClearColor</span>(clear_color.x, clear_color.y, clear_color.z, clear_color.w);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">ImGui_ImplOpenGL3_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cleanup</span></span><br><span class="line">  <span class="built_in">ImGui_ImplOpenGL3_Shutdown</span>();</span><br><span class="line">  <span class="built_in">ImGui_ImplGlfw_Shutdown</span>();</span><br><span class="line">  ImGui::<span class="built_in">DestroyContext</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust也有类似作用的egui<a href="https://github.com/emilk/egui">emilk/egui: egui: an easy-to-use immediate mode GUI in Rust that runs on both web and native (github.com)</a></p><p><img data-src="https://s2.loli.net/2024/09/30/gymonshOAW9r1BP.png" alt="image-20240930172646741"></p><h3 id="raylib"><a href="#raylib" class="headerlink" title="raylib"></a>raylib</h3><p><a href="https://www.raylib.com/index.html">raylib | A simple and easy-to-use library to enjoy videogames programming</a></p><p>看到有人推荐没过几天我就看到很多使用它开发的小东西. 官网说主要用于vediogames的开发(跟使用imgui的目的类似). </p><p>个人使用体验比imgui更舒服,因为实际上使用imgui需要调用opengl/vulkan的接口,这些接口命名太<del>傻逼</del>了而且使用更繁琐.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;raylib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> screenWidth = <span class="number">800</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> screenHeight = <span class="number">450</span>;</span><br><span class="line">  <span class="built_in">InitWindow</span>(screenWidth, screenHeight, <span class="string">&quot;raylib [core] example - basic window&quot;</span>);</span><br><span class="line">  <span class="built_in">SetTargetFPS</span>(<span class="number">60</span>);</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">WindowShouldClose</span>()) &#123;</span><br><span class="line">    <span class="built_in">BeginDrawing</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ClearBackground</span>(RAYWHITE);</span><br><span class="line">    <span class="built_in">DrawText</span>(<span class="string">&quot;Congrats! You created your first window!&quot;</span>, <span class="number">190</span>, <span class="number">200</span>, <span class="number">20</span>,</span><br><span class="line">             LIGHTGRAY);</span><br><span class="line">    <span class="built_in">EndDrawing</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CloseWindow</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="更加高级的跨平台应用开发"><a href="#更加高级的跨平台应用开发" class="headerlink" title="更加高级的跨平台应用开发"></a>更加高级的跨平台应用开发</h2><h3 id="SDL"><a href="#SDL" class="headerlink" title="SDL"></a>SDL</h3><p><a href="https://www.libsdl.org/">Simple DirectMedia Layer - Homepage (libsdl.org)</a></p><p><a href="https://wiki.libsdl.org/SDL2/Tutorials">SDL2/Tutorials - SDL Wiki (libsdl.org)</a></p><p>SDL本身是跨平台的多媒体库,使用c++与音视频设备交互. 目前最新是SDL3.0版本了,本身使用c编写,也经常用来写小游戏.</p><p>SDL有对应的网络库<a href="https://github.com/libsdl-org/SDL_net">libsdl-org/SDL_net: A simple, cross-platform wrapper over TCP/IP sockets. (github.com)</a></p><h3 id="SFML"><a href="#SFML" class="headerlink" title="SFML"></a>SFML</h3><p><a href="https://www.sfml-dev.org/">SFML (sfml-dev.org)</a></p><p>与SDL类似,但个人觉得API更简洁更易于使用</p><p>关于两者的讨论<a href="https://www.reddit.com/r/gamedev/comments/n8d6an/sfml_vs_sdl2_which_one_should_i_choose/">sfml vs sdl2 .. which one should i choose? : r/gamedev (reddit.com)</a></p><p>这两者都不止是简单的图形接口了,提供音频和网络模块方便使用</p><p><img data-src="https://s2.loli.net/2024/09/30/HlfgAV9Z2exv8Gb.png" alt="image-20240930174112035"></p><h2 id="功能强大的框架"><a href="#功能强大的框架" class="headerlink" title="功能强大的框架"></a>功能强大的框架</h2><h3 id="WinUI3-期待"><a href="#WinUI3-期待" class="headerlink" title="WinUI3 期待"></a>WinUI3 期待</h3><p>借助微软的力量<a href="https://learn.microsoft.com/zh-cn/windows/apps/winui/winui3/">WinUI 3 - Windows apps | Microsoft Learn</a></p><p>使用WinUI开发windows应用,缺点是不能跨平台,并且微软已经有了很多桌面开发框架了,WPF,MAUI,UWP?等等,不知道这个框架能够一直积极维持多久. </p><h3 id="Qt-不只是UI"><a href="#Qt-不只是UI" class="headerlink" title="Qt 不只是UI"></a>Qt 不只是UI</h3><p>Qt是跨平台桌面?(目前Qt也支持了安卓开发)开发工具.目前已经到了6.0+,除了使用widget之外,针对移动端的Qt quick也发展得不错. 除了UI之外,它还有网络库,图形渲染等常用的库. 甚至可以说Qt的一些库都能拿来代替c++贫瘠的标准库了</p><p>Qt不仅可以进行桌面应用开发,也可以拿来开发游戏.</p><h2 id="至尊C-游戏开发"><a href="#至尊C-游戏开发" class="headerlink" title="至尊C++游戏开发"></a>至尊C++游戏开发</h2><p><a href="https://www.unrealengine.com/zh-CN">最强大的实时3D创作工具 - Unreal Engine</a></p><h2 id="实战raylib"><a href="#实战raylib" class="headerlink" title="实战raylib"></a>实战raylib</h2><p>个人使用上感觉raylib-&gt;Qt-&gt;UE从简易到复杂,功能也越来越多. 而imgui还是功能更少. 下面就介绍一下raylib写点小东西学习学习.</p><ul><li><a href="https://www.raylib.com/cheatsheet/cheatsheet_zh.html">raylib - cheatsheet</a></li><li><a href="https://www.raylib.com/examples.html">raylib - examples</a></li></ul><p><img data-src="https://s2.loli.net/2024/09/30/9zaylEkxOSm1eG2.png" alt="image-20240930203756619"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;raylib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Types and Structures Definition</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">GameScreen</span> &#123;</span> LOGO = <span class="number">0</span>, TITLE, GAMEPLAY, ENDING &#125; GameScreen;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Program main entry point</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialization</span></span><br><span class="line">    <span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> screenWidth = <span class="number">800</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> screenHeight = <span class="number">450</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitWindow</span>(screenWidth, screenHeight, <span class="string">&quot;raylib [core] example - basic screen manager&quot;</span>);</span><br><span class="line"></span><br><span class="line">    GameScreen currentScreen = LOGO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Initialize all required variables and load all required data here!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> framesCounter = <span class="number">0</span>;          <span class="comment">// Useful to count frames</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">SetTargetFPS</span>(<span class="number">60</span>);               <span class="comment">// Set desired framerate (frames-per-second)</span></span><br><span class="line">    <span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Main game loop</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">WindowShouldClose</span>())    <span class="comment">// Detect window close button or ESC key</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Update</span></span><br><span class="line">        <span class="comment">//----------------------------------------------------------------------------------</span></span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(currentScreen)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> LOGO:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Update LOGO screen variables here!</span></span><br><span class="line"></span><br><span class="line">                framesCounter++;    <span class="comment">// Count frames</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Wait for 2 seconds (120 frames) before jumping to TITLE screen</span></span><br><span class="line">                <span class="keyword">if</span> (framesCounter &gt; <span class="number">120</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    currentScreen = TITLE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TITLE:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Update TITLE screen variables here!</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Press enter to change to GAMEPLAY screen</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">IsKeyPressed</span>(KEY_ENTER) || <span class="built_in">IsGestureDetected</span>(GESTURE_TAP))</span><br><span class="line">                &#123;</span><br><span class="line">                    currentScreen = GAMEPLAY;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GAMEPLAY:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Update GAMEPLAY screen variables here!</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Press enter to change to ENDING screen</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">IsKeyPressed</span>(KEY_ENTER) || <span class="built_in">IsGestureDetected</span>(GESTURE_TAP))</span><br><span class="line">                &#123;</span><br><span class="line">                    currentScreen = ENDING;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ENDING:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Update ENDING screen variables here!</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Press enter to return to TITLE screen</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">IsKeyPressed</span>(KEY_ENTER) || <span class="built_in">IsGestureDetected</span>(GESTURE_TAP))</span><br><span class="line">                &#123;</span><br><span class="line">                    currentScreen = TITLE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//----------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Draw</span></span><br><span class="line">        <span class="comment">//----------------------------------------------------------------------------------</span></span><br><span class="line">        <span class="built_in">BeginDrawing</span>();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">ClearBackground</span>(RAYWHITE);</span><br><span class="line"></span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(currentScreen)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> LOGO:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Draw LOGO screen here!</span></span><br><span class="line">                    <span class="built_in">DrawText</span>(<span class="string">&quot;LOGO SCREEN&quot;</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">40</span>, LIGHTGRAY);</span><br><span class="line">                    <span class="built_in">DrawText</span>(<span class="string">&quot;WAIT for 2 SECONDS...&quot;</span>, <span class="number">290</span>, <span class="number">220</span>, <span class="number">20</span>, GRAY);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TITLE:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Draw TITLE screen here!</span></span><br><span class="line">                    <span class="built_in">DrawRectangle</span>(<span class="number">0</span>, <span class="number">0</span>, screenWidth, screenHeight, GREEN);</span><br><span class="line">                    <span class="built_in">DrawText</span>(<span class="string">&quot;TITLE SCREEN&quot;</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">40</span>, DARKGREEN);</span><br><span class="line">                    <span class="built_in">DrawText</span>(<span class="string">&quot;PRESS ENTER or TAP to JUMP to GAMEPLAY SCREEN&quot;</span>, <span class="number">120</span>, <span class="number">220</span>, <span class="number">20</span>, DARKGREEN);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> GAMEPLAY:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Draw GAMEPLAY screen here!</span></span><br><span class="line">                    <span class="built_in">DrawRectangle</span>(<span class="number">0</span>, <span class="number">0</span>, screenWidth, screenHeight, PURPLE);</span><br><span class="line">                    <span class="built_in">DrawText</span>(<span class="string">&quot;GAMEPLAY SCREEN&quot;</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">40</span>, MAROON);</span><br><span class="line">                    <span class="built_in">DrawText</span>(<span class="string">&quot;PRESS ENTER or TAP to JUMP to ENDING SCREEN&quot;</span>, <span class="number">130</span>, <span class="number">220</span>, <span class="number">20</span>, MAROON);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ENDING:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Draw ENDING screen here!</span></span><br><span class="line">                    <span class="built_in">DrawRectangle</span>(<span class="number">0</span>, <span class="number">0</span>, screenWidth, screenHeight, BLUE);</span><br><span class="line">                    <span class="built_in">DrawText</span>(<span class="string">&quot;ENDING SCREEN&quot;</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">40</span>, DARKBLUE);</span><br><span class="line">                    <span class="built_in">DrawText</span>(<span class="string">&quot;PRESS ENTER or TAP to RETURN to TITLE SCREEN&quot;</span>, <span class="number">120</span>, <span class="number">220</span>, <span class="number">20</span>, DARKBLUE);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">EndDrawing</span>();</span><br><span class="line">        <span class="comment">//----------------------------------------------------------------------------------</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// De-Initialization</span></span><br><span class="line">    <span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Unload all loaded data (textures, fonts, audio) here!</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseWindow</span>();        <span class="comment">// Close window and OpenGL context</span></span><br><span class="line">    <span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">raylib example source code</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习c++与其他语言一个不同之处就是, 你可能不能很快地构建一些有趣的项目. &lt;/p&gt;
&lt;p&gt;这时你可能会转向Rust作为代餐,享受安全系统编程语言带来的性能,同时也有一些高级语言所有的强大标准库.或者你也有可能转向Java,C#等更加具有高级应用生态的语言,利用自带的标准库以及强大的三方生态,快速构建性能并不算差的应用. 这里,我简单介绍一下可以使用c++的框架/库以便play for fun.&lt;br&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://www.sekyoro.top/tags/cpp/"/>
    
    <category term="fun" scheme="https://www.sekyoro.top/tags/fun/"/>
    
  </entry>
  
  <entry>
    <title>脑子没有坏掉系列:使用Rust写Web</title>
    <link href="https://www.sekyoro.top/2024/09/29/%E8%84%91%E5%AD%90%E6%B2%A1%E6%9C%89%E5%9D%8F%E6%8E%89%E7%B3%BB%E5%88%97-%E4%BD%BF%E7%94%A8Rust%E5%86%99Web/"/>
    <id>https://www.sekyoro.top/2024/09/29/%E8%84%91%E5%AD%90%E6%B2%A1%E6%9C%89%E5%9D%8F%E6%8E%89%E7%B3%BB%E5%88%97-%E4%BD%BF%E7%94%A8Rust%E5%86%99Web/</id>
    <published>2024-09-29T12:46:44.000Z</published>
    <updated>2024-09-30T09:26:04.135Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用rust写web框架的目的: </p><p>1)学习rust语法等知识. 找个感兴趣的项目写写</p><p>2)写写web程序练练手感.<br><span id="more"></span><br>我这里使用的是<a href="https://rocket.rs/">Rocket - Simple, Fast, Type-Safe Web Framework for Rust</a></p><p><img data-src="https://s2.loli.net/2024/09/29/YBv5JnyopKIZDzC.png" alt="image-20240929205536867"></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ol><li>路由</li></ol><p>Rocket 会将传入的 HTTP 请求解析为本地结构，供你的代码间接操作。Rocket 通过与应用程序中声明的路由属性进行匹配，确定要调用的请求处理程序</p><ol><li>验证</li></ol><p>Rocket根据匹配路由中存在的类型和守卫验证传入请求。如果验证失败，Rocket将请求转发到下一个匹配路由或调用错误处理程序。</p><ol><li>处理</li></ol><p>使用经过验证的参数调用与路由关联的请求处理程序。这是应用程序的主要业务逻辑。处理通过返回一个响应完成。</p><ol><li>相应</li></ol><p>处理返回的响应。Rocket生成适当的HTTP响应并将其发送到客户机。这就完成了生命周期。Rocket继续侦听请求，重新启动每个传入请求的生命周期。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/flosse/rust-web-framework-comparison?tab=readme-ov-file">flosse/rust-web-framework-comparison: A comparison of some web frameworks and libs written in Rust (github.com)</a></li><li><a href="https://course.rs/practice/third-party-libs.html">日常开发三方库精选 - Rust语言圣经(Rust Course)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用rust写web框架的目的: &lt;/p&gt;
&lt;p&gt;1)学习rust语法等知识. 找个感兴趣的项目写写&lt;/p&gt;
&lt;p&gt;2)写写web程序练练手感.&lt;br&gt;</summary>
    
    
    
    
    <category term="web" scheme="https://www.sekyoro.top/tags/web/"/>
    
    <category term="rust" scheme="https://www.sekyoro.top/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>现代cpp多线程与并发初探</title>
    <link href="https://www.sekyoro.top/2024/09/26/%E7%8E%B0%E4%BB%A3cpp%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%88%9D%E6%8E%A2/"/>
    <id>https://www.sekyoro.top/2024/09/26/%E7%8E%B0%E4%BB%A3cpp%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%88%9D%E6%8E%A2/</id>
    <published>2024-09-26T15:28:12.000Z</published>
    <updated>2024-09-28T11:32:01.205Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在现代c++(c++20)中,有了jthread和协程的概念,使得我们编写并发程序更加方便. 这里作简单学习.<br><span id="more"></span></p><h2 id="前言知识"><a href="#前言知识" class="headerlink" title="前言知识"></a>前言知识</h2><h3 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h3><p><code>std::thread</code> 用于创建一个执行的线程实例,所以它是一切并发编程的基础,使用时需要包含 <code>&lt;thread&gt;</code> 头文件, 它提供了很多基本的线程操作,例如 <code>get_id()</code> 来获取所创建线程的线程 ID,使用 <code>join()</code> 来等待这个线程结束（与该线程汇合）等等</p><p><code>std::mutex</code> 是 C++11 中最基本的互斥量类,可以通过构造 <code>std::mutex</code> 对象创建互斥量, 而通过其成员函数 <code>lock()</code> 可以进行上锁,<code>unlock()</code> 可以进行解锁. 但是在实际编写代码的过程中,最好不去直接调用成员函数, 因为调用成员函数就需要在每个临界区的出口处调用 <code>unlock()</code></p><p>而 <code>std::unique_lock</code> 则是相对于 <code>std::lock_guard</code> 出现的,<code>std::unique_lock</code> 更加灵活, <strong><code>std::unique_lock</code> 的对象会以独占所有权（没有其他的 <code>unique_lock</code> 对象同时拥有某个 <code>mutex</code> 对象的所有权）</strong> 的方式管理 <code>mutex</code> 对象上的上锁和解锁的操作.所以在并发编程中,推荐使用 <code>std::unique_lock</code>.</p><p>如果用到了条件变量 <code>std::condition_variable::wait</code> 则必须使用 <code>std::unique_lock</code> 作为参数.</p><p>条件变量 <code>std::condition_variable</code> 是为了解决死锁而生,当互斥操作不够用而引入的. 比如,线程可能需要等待某个条件为真才能继续执行, 而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时,就会发生死锁. 所以,<code>condition_variable</code> 对象被创建出现主要就是用于唤醒等待线程从而避免死锁. <code>std::condition_variable</code>的 <code>notify_one()</code> 用于唤醒一个线程； <code>notify_all()</code> 则是通知所有线程</p><p><code>std::future</code>,它提供了一个访问异步操作结果的途径</p><p>试想,如果主线程 A 希望新开辟一个线程 B 去执行某个我们预期的任务,并返回一个结果. 而这时候,线程 A 可能正在忙其他的事情,无暇顾及 B 的结果, 所以我们会很自然的<strong>希望能够在某个特定的时间获得线程 B 的结果</strong>.</p><p>在 C++11 的 <code>std::future</code> 被引入之前,通常的做法是： 创建一个线程 A,在线程 A 里启动任务 B,当准备完毕后发送一个事件,并将结果保存在全局变量中. 而主函数线程 A 里正在做其他的事情,当需要结果的时候,调用一个线程等待函数来获得执行的结果</p><p>而 C++11 提供的 <code>std::future</code> 简化了这个流程,可以用来获取异步任务的结果. 自然地,我们很容易能够想象到把它作为一种简单的线程同步手段,即屏障（barrier）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将一个返回值为7的 lambda 表达式封装到 task 中</span></span><br><span class="line">    <span class="comment">// std::packaged_task 的模板参数为要封装函数的类型</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">([]()&#123;<span class="keyword">return</span> <span class="number">7</span>;&#125;)</span></span>;</span><br><span class="line">    <span class="comment">// 获得 task 的期物</span></span><br><span class="line">    std::future&lt;<span class="keyword">int</span>&gt; result = task.<span class="built_in">get_future</span>(); <span class="comment">// 在一个线程中执行 task</span></span><br><span class="line">    std::<span class="built_in">thread</span>(std::<span class="built_in">move</span>(task)).<span class="built_in">detach</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;waiting...&quot;</span>;</span><br><span class="line">    result.<span class="built_in">wait</span>(); <span class="comment">// 在此设置屏障,阻塞到期物的完成</span></span><br><span class="line">    <span class="comment">// 输出执行结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;done!&quot;</span> &lt;&lt; std:: endl &lt;&lt; <span class="string">&quot;future result is &quot;</span></span><br><span class="line">              &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="promise-packaged-task-async-解决异步"><a href="#promise-packaged-task-async-解决异步" class="headerlink" title="promise packaged_task async 解决异步"></a>promise packaged_task async 解决异步</h3><p>也许你在Python,Js中已经享受到了异步的好处,在c++中也可以,不过可能会稍微麻烦一些.</p><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p><code>std::async</code>函数可以接受几个不同的启动策略,这些策略在<code>std::launch</code>枚举中定义</p><p>使用 <code>std::launch::async</code> 时,<code>std::async</code> 会立即在一个新线程中启动任务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个异步任务</span></span><br><span class="line"><span class="function">std::string <span class="title">fetchDataFromDB</span><span class="params">(std::string query)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟一个异步任务,比如从数据库中获取数据</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Data: &quot;</span> + query;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::async 异步调用 fetchDataFromDB</span></span><br><span class="line">    std::future&lt;std::string&gt; resultFromDB =      std::<span class="built_in">async</span>(std::launch::async, fetchDataFromDB, <span class="string">&quot;Data&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在主线程中做其他事情</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing something else...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 future 对象中获取数据</span></span><br><span class="line">    std::string dbData = resultFromDB.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; dbData &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="packaged-task"><a href="#packaged-task" class="headerlink" title="packaged_task"></a>packaged_task</h4><p><code>std::packaged_task</code>是一个可调用目标,它包装了一个任务,该任务可以在另一个线程上运行.它可以捕获任务的返回值或异常,并将其存储在<code>std::future</code>对象中,以便以后使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;my task run 5 s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_package</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个包装了任务的 std::packaged_task 对象  </span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(my_task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取与任务关联的 std::future 对象  </span></span><br><span class="line">    std::future&lt;<span class="keyword">int</span>&gt; result = task.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在另一个线程上执行任务  </span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task))</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>(); <span class="comment">// 将线程与主线程分离,以便主线程可以等待任务完成  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待任务完成并获取结果  </span></span><br><span class="line">    <span class="keyword">int</span> value = result.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The result is: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h4><p><code>std::promise</code>用于在某一线程中设置某个值或异常,而<code>std::future</code>则用于在另一线程中获取这个值或异常</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_value</span><span class="params">(std::promise&lt;<span class="keyword">int</span>&gt; prom)</span> </span>&#123; prom.<span class="built_in">set_value</span>(<span class="number">10</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> std::promise&lt;<span class="keyword">int</span>&gt; prom;</span><br><span class="line">  std::future&lt;<span class="keyword">int</span>&gt; fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(set_value, std::move(prom))</span></span>;</span><br><span class="line">  <span class="keyword">int</span> value2 = fut.<span class="built_in">get</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;result&quot;</span> &lt;&lt; value2 &lt;&lt; std::endl;</span><br><span class="line">  t.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="面向c-20"><a href="#面向c-20" class="headerlink" title="面向c++20"></a>面向c++20</h2><p>C++11 引入了 std::thread 类型,其与操作系统提供的线程对应,但该类型有一个严重的设计缺陷: 不是 RAII 类型. std::thread 要求在其生命周期结束时,若表示正在运行的线程,则调用 join()(等待线程结束) 或 detach()(让线程在后台运行)</p><p>若两者都没有调用,析构函数会立即导致异常的程序终止 (在某些系统上导致段错误).</p><p>不能“杀死”已 经启动的线程.线程不是进程,线程只能通过结束自身或结束整个程序来结束. 因此,在调用 join() 之前,应该确保等待的线程将取消其执行.不过,对于 std::thread,没有这 样的机制,必须自己实现取消请求和对它的响应</p><h3 id="std-jthread"><a href="#std-jthread" class="headerlink" title="std::jthread"></a>std::jthread</h3><p>std::jthread 解决了这些问题,它是 RAII 类型.若线程是可汇入的 (“j”代表“汇入”),析构函数会自动调用 join()</p><ol><li><strong>自动加入</strong>：<code>std::jthread</code> 在析构时会自动调用 <code>join</code>,确保线程在销毁前完成执行.这避免了 <code>std::thread</code> 在析构时未调用 <code>join</code> 或 <code>detach</code> 导致的未定义行为.</li><li><strong>停止标记</strong>：<code>std::jthread</code> 支持停止标记（stop token）,允许线程协作地停止执行.这使得线程可以优雅地处理停止请求.</li><li><strong>异常安全</strong>：<code>std::jthread</code> 在异常处理方面更加安全,确保在异常抛出时线程能够正确地清理资源.</li></ol><p>使用 std::jthread 就不再存在导致异常程序终止的危险,也不需要异常处理.为了支持尽可能容易地切换到 std::jthread 类,该类提供了与 std::thread 相同的 API,包括: </p><ul><li><strong><code>jthread()</code></strong>：默认构造函数,创建一个未关联任何线程的 <code>jthread</code>.</li><li><strong><code>jthread(Function&amp;&amp; f, Args&amp;&amp;... args)</code></strong>：构造函数,启动一个新的线程来执行给定的函数.</li><li><strong><code>join()</code></strong>：等待线程完成执行.</li><li><strong><code>detach()</code></strong>：分离线程,使其独立运行.</li><li><strong><code>get_id()</code></strong>：获取线程的标识符.</li><li><strong><code>joinable()</code></strong>：检查线程是否可以加入.</li><li><strong><code>swap(jthread&amp; other)</code></strong>：交换两个 <code>jthread</code> 对象.</li><li><strong><code>request_stop()</code></strong>：请求线程停止执行.</li><li><strong><code>stop_requested()</code></strong>：检查是否请求了停止.</li><li><strong><code>get_stop_token()</code></strong>：获取线程的停止标记</li><li><strong>get_stop_source</strong>:获取线程停止源</li></ul><h4 id="引入停止请求与停止回调"><a href="#引入停止请求与停止回调" class="headerlink" title="引入停止请求与停止回调"></a>引入停止请求与停止回调</h4><p>std::jthread 提供了一种协作机制来表示线程不应该再运行.它是“协作的”,因为该机制 不会杀死正在运行的线程 (因为 C++ 线程根本不支持杀死线程,杀死线程的操作可能很容易使程序处于损坏状态).</p><p>为了响应停止请求,已启动的线程必须声明<code>std::stop_token</code>作为附加的第一个参数, 并使用它不时的检查是否应该继续运行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">(std::stop_token st, std::string s, <span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!st.<span class="built_in">stop_requested</span>())&#123; # 检查是否停止了请求</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// t.request_sop() 显式请求task()停止执行</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(std::stop_token st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">stop_requested</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker thread is running...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread is stopping...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::jthread <span class="title">jt</span><span class="params">(worker)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程继续执行其他任务</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread is doing other work...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一些工作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求工作线程停止</span></span><br><span class="line">    jt.<span class="built_in">request_stop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待工作线程完成</span></span><br><span class="line">    jt.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有另一种对停止请求作出反应的方法: 可以为<code>std::stop_token</code>注册回调,该回调将在请求停止时自动调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::stop_callback cb&#123;st,[]()&#123;&#125;&#125;;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stop_token&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(std::stop_token st)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::stop_callback <span class="title">sc</span><span class="params">(st, []&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;Stop request received, cleaning up...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">stop_requested</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker thread is running...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread is stopping...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::jthread <span class="title">jt</span><span class="params">(worker)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程继续执行其他任务</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread is doing other work...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一些工作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求工作线程停止</span></span><br><span class="line">    jt.<span class="built_in">request_stop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待工作线程完成</span></span><br><span class="line">    jt.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::jthread 的主要优点是会自动建立停止信号的机制.<strong>启动线程的构造函数将创建一个停止源</strong>,将其存储为线程对象的成员,并将相应的停止令牌传递给被调用的函数,以避免该函数将额外的 stop_token 作为第一个参数</p><h4 id="停止来源"><a href="#停止来源" class="headerlink" title="停止来源"></a>停止来源</h4><p><code>std::stop_source</code> 是 C++20 引入的一个类,用于管理停止请求.它与 <code>std::stop_token</code> 和 <code>std::jthread</code> 一起使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::stop_source ssrc;</span><br><span class="line">  std::stop_token stok&#123;ssrc.<span class="built_in">get_token</span>()&#125;;</span><br><span class="line">  std::stop_callback cb&#123;stok, []() &#123; <span class="built_in">syncOut</span>() &lt;&lt; <span class="string">&quot;stop requested\n&quot;</span>; &#125;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> fut1 = std::<span class="built_in">async</span>(std::launch::async, [stok] &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">      <span class="built_in">stop_callback_task</span>(stok, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  ssrc.<span class="built_in">request_stop</span>();</span><br></pre></td></tr></table></figure><p>停止来源可以request_stop,jthread对象也可以request_stop. jthread对象可以可以获得停止源和stop_token</p><p>若启动多个 jthread,每个线程都有自己的停止令牌,这可能会导致停止所有线程的时间可能比预期的要长</p><p>可能还需要使用相同的停止令牌为多个线程请求停止,只需自己创建停止令牌,或者从已经启 动的第一个线程中获取停止令牌,并将此停止令牌作为第一个参数启动线程</p><h3 id="std-latch锁存器与std-barrier"><a href="#std-latch锁存器与std-barrier" class="headerlink" title="std::latch锁存器与std::barrier"></a>std::latch锁存器与std::barrier</h3><p><code>std::latch</code> 是一个一次性的同步点,类似于倒计时事件.它允许多个线程等待某个计数器达到零,然后所有等待的线程同时继续执行.一旦计数器达到零,<code>std::latch</code> 就不能再被重置.</p><p><strong>主要特点</strong></p><ul><li><strong>一次性</strong>：一旦计数器达到零,<code>std::latch</code> 就不能再被重置.</li><li><strong>倒计时</strong>：多个线程可以通过调用 <code>count_down</code> 方法减少计数器的值.</li><li><strong>等待</strong>：线程可以调用 <code>wait</code> 方法等待计数器达到零.</li></ul><p><strong>成员方法</strong></p><ul><li><strong><code>latch(count_t count)</code></strong>：构造函数,初始化计数器.</li><li><strong><code>count_down(count_t n = 1)</code></strong>：减少计数器的值.</li><li><strong><code>count_down_and_wait(count_t n = 1)</code></strong>：减少计数器的值并等待计数器达到零.</li><li><strong><code>wait()</code></strong>：等待计数器达到零.</li><li><strong><code>try_wait()</code></strong>：尝试等待计数器达到零,如果计数器尚未达到零则立即返回 <code>false</code>.</li><li><strong><code>arrive_and_wait(count_t n = 1)</code></strong>：等同于 <code>count_down_and_wait(n)</code></li></ul><p>锁存器是用于并发执行的一种新的同步机制,支持单次使用异步倒计时.从初始整数值开始, 各种线程可以自动将该值计数到零.当计数器达到零时,等待此倒计时的所有线程继续运行</p><p><img data-src="https://s2.loli.net/2024/09/28/eyjWsP9bpHdwacD.png" alt="image-20240928144118863"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;latch&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stop_token&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(std::latch &amp;l)</span> </span>&#123;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">  l.<span class="built_in">count_down</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Worker thread finished and counted down\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> num_threads&#123;<span class="number">5</span>&#125;;</span><br><span class="line">  <span class="function">std::latch <span class="title">l</span><span class="params">(num_threads)</span></span>;</span><br><span class="line">  std::vector&lt;std::jthread&gt; threads;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(worker, std::<span class="built_in">ref</span>(l));</span><br><span class="line">  &#125;</span><br><span class="line">  l.<span class="built_in">wait</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : threads) &#123;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::latch allReady&#123;<span class="number">10</span>&#125;;</span><br><span class="line">  std::vector&lt;std::jthread&gt; threads2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">    std::jthread t&#123;[i, &amp;allReady] &#123;</span><br><span class="line">      std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line">      allReady.<span class="built_in">arrive_and_wait</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i + <span class="number">5</span>; ++j) &#123;</span><br><span class="line">        std::cout.<span class="built_in">put</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(<span class="string">&#x27;A&#x27;</span> + j));</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">100</span>ms);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    threads2.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(t));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>barrier</code>是用于并发执行的新的同步机制,允许多次同步多个异步任务.设置初始计数后,多个线程可以对其进行计数,并等待计数器达到零.与锁存器相比,当达到零时,将调用一个 (可选的) 回调,计数器将重新初始化为初始计数</p><p><img data-src="https://s2.loli.net/2024/09/28/SKiqeEcvdDM9N2C.png" alt="image-20240928145528067"></p><p>arrive() 函数会返回一个类型为 std::barrier::arrival_token 的到达令牌,以确保 barrier 知道要等待哪个线程.</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>C++20 引入了处理信号量的新类型.信号量是轻量级同步原语,允许同步或限制对一个或一组资源的访问</p><p>C++ 标准库提供了两种信号量类型:</p><ul><li>std::counting_semaphore&lt;&gt; 将多个资源的使用限制在最大值</li><li>std::binary_semaphore&lt;&gt; 限制对单一资源的使用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::queue&lt;<span class="keyword">char</span>&gt; values;</span><br><span class="line">  std::mutex valuesMx;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">    values.<span class="built_in">push</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(<span class="string">&#x27;a&#x27;</span> + (i % (<span class="string">&#x27;z&#x27;</span> - <span class="string">&#x27;a&#x27;</span>))));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">int</span> numThreads = <span class="number">10</span>;</span><br><span class="line">  std::counting_semaphore&lt;numThreads&gt; enabled&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  std::vector&lt;std::jthread&gt; pool;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; numThreads; ++idx) &#123;</span><br><span class="line">    std::jthread t&#123;[idx, &amp;enabled, &amp;values, &amp;valuesMx](std::stop_token st) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!st.<span class="built_in">stop_requested</span>()) &#123;</span><br><span class="line">        enabled.<span class="built_in">acquire</span>();</span><br><span class="line">        <span class="keyword">char</span> val;</span><br><span class="line">        &#123;</span><br><span class="line">          std::lock_guard lg&#123;valuesMx&#125;;</span><br><span class="line">          val = values.<span class="built_in">front</span>();</span><br><span class="line">          values.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">          std::cout.<span class="built_in">put</span>(val);</span><br><span class="line">          <span class="keyword">auto</span> dur = <span class="number">130</span>ms * ((idx % <span class="number">3</span>) + <span class="number">1</span>);</span><br><span class="line">          std::this_thread::<span class="built_in">sleep_for</span>(dur);</span><br><span class="line">        &#125;</span><br><span class="line">        enabled.<span class="built_in">release</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    pool.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(t));</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;====================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;====================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  enabled.<span class="built_in">release</span>(<span class="number">3</span>);</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t:pool)&#123;</span><br><span class="line">    t.<span class="built_in">request_stop</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>启动了 10 个线程,但限制了允许其中多少线程主动运行和处理数据,因此将信号量 初始化为最大数量 (10) 和初始资源数量 (0)</p><p>因为信号量初始化为零,所以最初的情况是阻塞,因此没有可用的资源.使用release控制最大资源,acquire获得资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sharedData = <span class="number">0</span>;</span><br><span class="line">std::binary_semaphore dataReady&#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::binary_semaphore dataDone&#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::jthread process&#123;[&amp;](std::stop_token st) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!st.<span class="built_in">stop_requested</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dataReady.<span class="built_in">try_acquire_for</span>(<span class="number">1</span>s)) &#123;</span><br><span class="line">      <span class="keyword">int</span> data = sharedData;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;[process] read &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">      std::this_thread::<span class="built_in">sleep_for</span>(data * <span class="number">.5</span>s);</span><br><span class="line"></span><br><span class="line">      dataDone.<span class="built_in">release</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;[process] no data to process\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;[main] write &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">  sharedData = i;</span><br><span class="line">  dataReady.<span class="built_in">release</span>();</span><br><span class="line">  dataDone.<span class="built_in">acquire</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;[main] data processed\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><ul><li><strong><code>std::atomic_ref</code></strong>：用于在现有对象上提供原子操作,适用于非侵入性地将非原子类型包装成原子类型.</li><li><strong><code>std::atomic&lt;std::shared_ptr&lt;T&gt;&gt;</code></strong>：用于在多线程环境中安全地管理共享指针,确保指针的引用计数和其他操作是线程安全的.</li></ul><p>流的并发输出会导致未定义行为 (这是数据竞争,指具有未定义行为的竞争条件).</p><p>同步并发输出流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syncstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">syncOut</span><span class="params">(std::ostream&amp; strm=std::cout)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::osyncstream&#123;strm&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-中的协程"><a href="#c-中的协程" class="headerlink" title="c++中的协程"></a>c++中的协程</h2><p>C++20 引入了对协程的支持,<strong>协程 是可以挂起的函数</strong>(类似于python中yield的生成器?)</p><p>调用普通函数 (或过程) 时,然后运行到它们的结束 (或直到到达返回语句或抛出异常),而协程 是可以分多个步骤运行的函数 </p><p>某些时刻,可以挂起一个协程,所以该函数暂停其计算,直到恢复.挂起可能是因为函数必须 等待某些东西,有其他 (更重要的) 事情要做,或者有一个中间结果要给调用者. 因此,启动协程意味着启动另一个函数,直到它的一部分完成.调用函数和协程都在它们的两 条执行路径之间来回切换.</p><p>注意,这两个函数不是并行运行的,我们用控制流来打乒乓球:</p><ul><li>函数可以通过开始或继续协程的语句来决定启动或恢复其当前控制流. </li><li>当协程运行时,协程可以决定挂起或结束其执行,启动或恢复协程的函数将继续执行其控制流.</li></ul><p><img data-src="https://s2.loli.net/2024/09/28/6q3sc8P4LS7wt5x.png" alt="image-20240928155220941"></p><p>协程的最简单形式中,主控制流和协程的控制流都在同一个线程中运行.不需要使用多线程, 也不需要处理并发访问,但可以在不同的线程中运行协程.甚至可以在不同的线程上将协程恢复到 先前挂起的位置.协程有一种正交特性,但其可以与多个线程一起使用.甚至可以在不同的线程上 将协程恢复到先前挂起的位置</p><p>使用协程就像在后台有一个函数,可以不时地启动和继续.然而,由于协程的生命周期超出了嵌套作用域,因此协程也是一个将其状态存储在某些内存中并提供处理状态的 API.</p><ul><li>协程通常返回一个对象,作为调用者的协程接口.根据协程的目的和用途,该对象可以表示 一个不时挂起或切换上下文的正在运行的任务,不时产生值的生成器,或者一个按需惰性地 返回一个或多个值的工厂</li><li>协程无堆栈.不挂起外部协程的情况下,无法挂起在外部协程中调用的内部协程,只能将外 部协程作为一个整体挂起. 当协程挂起时,协程的状态作为一个整体被存储在与堆栈分开的对象中,以便它可以在完全 不同的上下文中 (在不同的调用堆栈中,在另一个线程中等) 恢复.</li></ul><p>只需在函数中使用以下关键字即可隐式定义协程: </p><ul><li>co_await </li><li>co_yield</li><li>co_return </li></ul><p>若这些关键字在协程中都不没有,则必须显式地使用 co_return; 语句.</p><p>协程具有以下属性和限制: </p><ul><li>协程不允许有返回语句. </li><li>协程不能是 constexpr 或 consteval</li><li>协程不能有返回类型 auto 或其他占位符类型. </li><li>main() 不能是协程. </li><li>构造函数或析构函数不可为协程</li><li>协程可以是静态</li><li>协程若不是构造函数或析构函数,可以是成员函数</li><li>协程甚至可以是 Lambda,但在这种情况下,必须谨慎使用</li></ul><h3 id="实现协程接口与句柄"><a href="#实现协程接口与句柄" class="headerlink" title="实现协程接口与句柄"></a>实现协程接口与句柄</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;coroutine&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroTask</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">promise_type</span>;</span></span><br><span class="line">  <span class="keyword">using</span> CoroHdl = std::coroutine_handle&lt;promise_type&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  CoroHdl hdl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CoroTask</span>(<span class="keyword">auto</span> h) : hdl&#123;h&#125; &#123;&#125;</span><br><span class="line">  ~<span class="built_in">CoroTask</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hdl)</span><br><span class="line">      hdl.<span class="built_in">destroy</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CoroTask</span>(<span class="keyword">const</span> CoroTask &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  CoroTask &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> CoroTask &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">resume</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hdl || hdl.<span class="built_in">done</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    hdl.<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span> !hdl.<span class="built_in">done</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CoroTask</span>:</span>:promise_type &#123;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> CoroTask&#123;CoroHdl::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">final_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>处理 C++ 中的协程,需要做两件事: </p><ul><li>promise 类型 此类型用于定义处理协同例程的某些自定义点,特定的成员函数定义了在特定情况下调用的 回调函数. </li><li>std::coroutine_handle&lt;&gt; 类型的内部协程句柄 此对象在调用协程时创建 (使用上述 promise 类型的标准回调之一),可以通过提供一个底层接 口来恢复协程以及处理协程的结束,从而用于管理协程的状态</li></ul><p>引入 promise_type(每个协程类型都必须拥有),并声明本地协程句柄 hdl,它管理协程的状态. 原生协程句柄 std::coroutine_handle&lt;&gt; 的类型是用 promise 类型参数化的,存储在 promise 中的任何 数据都是句柄的一部分,promise 中的函数可以通过句柄访问</p><p>resume方法在协程挂起时恢复协程,其或多或少地将恢复请求传播到原生协程句 柄,其<strong>返回表示是否有必要再次恢复协程</strong>. </p><p>函数检查是否有句柄,或者协程是否已经结束. 尽管在这个实现中协程接口总是有一个句柄,但这是一个必要的检查,例如,若接口支持移动 语义. 只有当协程挂起且尚未结束时才允许调用 resume(),所以检查是否 done() 是必要的.调用本身恢复挂起的协程并阻塞,直到下一个挂起点或结束</p><p><strong>针对co_await等待</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoroTask.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Coro <span class="title">coro</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;CORO&quot;</span> &lt;&lt; max &lt;&lt; <span class="string">&quot; start\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> val = <span class="number">1</span>; val &lt;= max; ++val) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;CORO&quot;</span> &lt;&lt; max &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">co_await</span> std::suspend_always&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> coroTask = <span class="built_in">coro</span>(<span class="number">3</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;coro() started\n&quot;</span>;</span><br><span class="line">  <span class="keyword">while</span> (coroTask.<span class="built_in">resume</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;coro() suspended&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;coro() done\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 定义promise 类型目的是: </p><ul><li>定义如何创建或获取协程的返回值 (通常包括创建协程句柄)</li><li>决定协同程序是应该在开始还是结束时挂起</li><li>处理协程调用者与协程之间交换的值</li><li>处理未处理的异常</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CoroTask</span>:</span>:promise_type &#123;</span><br><span class="line">  <span class="comment">// init and return coroutine interface</span></span><br><span class="line">  <span class="comment">// 创建协程接口 创建对象</span></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> CoroTask&#123;CoroHdl::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;; &#125;</span><br><span class="line">  <span class="comment">// 主动启动还是需要resume</span></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">  <span class="comment">// 到达结束时的操作</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 异常处理</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 最终是否挂起</span></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">final_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>针对co_yield返回值</strong></p><p>在promise_type中定义值,并定义<code>yield_value</code>用于保存值,在协程返回对象中定义<code>getValue</code>方便访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroTask</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">promise_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> coroValue = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">yield_value</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">      coroValue = val;</span><br><span class="line">      <span class="keyword">return</span> std::suspend_always&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">using</span> CoroHdl = std::coroutine_handle&lt;promise_type&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  CoroHdl hdl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CoroTask</span>(<span class="keyword">auto</span> h) : hdl&#123;h&#125; &#123;&#125;</span><br><span class="line">  ~<span class="built_in">CoroTask</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hdl)</span><br><span class="line">      hdl.<span class="built_in">destroy</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CoroTask</span>(<span class="keyword">const</span> CoroTask &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  CoroTask &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> CoroTask &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">resume</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hdl || hdl.<span class="built_in">done</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    hdl.<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span> !hdl.<span class="built_in">done</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> hdl.<span class="built_in">promise</span>().coroValue; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>针对co_return结束并返回值</strong></p><p>通过使用 co_return,协程可以在其结束时向调用者返回结果. 实现方式是在promise_type中增加return_value,然后依旧在协程接口对象中声明一个方法访问coroutine_handle.</p><p>若协程以有时可能返回值,有时可能不返回值的方式实现,则这是未定义行为.则这个协程无效. 也就是return_value和return_void也不能同时声明</p><h3 id="实现Awaitable对象"><a href="#实现Awaitable对象" class="headerlink" title="实现Awaitable对象"></a>实现Awaitable对象</h3><p>协程必须)提供Awaitables(实现方式是使用 Awaiter)</p><p> Awaitables 是 co_await 需要作为其操作数的术语,所以 awaitables 是 co_await 可以处理的所有对象. </p><p>Awaiter 是实现 Awaitables 的一种特定 (和典型) 方式的术语.</p><p>其必须提供三个特定的成员函数来处理协程的暂停和恢复</p><p><img data-src="https://s2.loli.net/2024/09/28/giQEJnrPypb7Ko8.png" alt="image-20240928181236087"></p><p><strong>await_ready()</strong> 在协程被挂起之前调用,提供挂起.若它返回 true,则协程根本不会挂起. 这个函数通常只返回 false</p><p><strong>auto await_suspend(awaitHdl)</strong> </p><p>在<strong>协程挂起后立即为协程调用此函数</strong>.参数 awaitHdl 是被挂起的协程的句柄,其类型是 std::coroutine_handle. 这个函数中,可以指定下一步要做什么,包括立即恢复挂起的或等待的协程.</p><p> <strong>auto await_resume()</strong> 当<strong>成功挂起后恢复协程时,将为协程调用此函数</strong>.可以返回一个值,这个值就是 co_await 表达式产生的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Awaiter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; await_ready\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">await_suspend</span><span class="params">(<span class="keyword">auto</span> hdl)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; await_suspend\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot; await_resume\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>Awaiter</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CoroTask <span class="title">coro</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;CORO&quot;</span> &lt;&lt; max &lt;&lt; <span class="string">&quot; start\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> val = <span class="number">1</span>; val &lt;= max; ++val) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;CORO&quot;</span> &lt;&lt; max &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">co_await</span> std::suspend_always&#123;&#125;;</span><br><span class="line">    <span class="keyword">co_await</span> Awaiter&#123;&#125;;</span><br><span class="line">    <span class="comment">// co_yield val;</span></span><br><span class="line">    <span class="comment">// co_return 1;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个标准<code>Awaiters</code>,<code>`std::suspend_always</code>和<code>std::suspend_never</code>. 差别就是<code>await_ready</code>的返回值</p><p>若在 await_ready() 中返回 false(而在 await_suspend() 中没有返回任何值),则 suspend_always 接受每个挂起,并将协程返回给其调用者. </p><p>若在 await_ready() 中返回 true,则 suspend_never 永远不会接受任何挂起,则协程继续 (永远不会调用 await_suspend()).</p><p><code>std::suspend_always</code>通常用作 co_await 的基本 awaiter.</p><p><strong>挂起后将值传递回协程</strong></p><p>协程接口的 promise 类型是协程与调用者共享和交换数据的最佳位置,在promse_type的<code>yield_value</code>中返回一个<code>awaiter</code>,这个<code>awaiter</code>能够修改协程接口中的promise并在挂起恢复时设置值.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBackValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;val)</span> </span>&#123; hdl.<span class="built_in">promise</span>().backValue = val; &#125; <span class="comment">// 在协程接口中写一个方法能够修改返回值</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">yield_value</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  coroValue = val;</span><br><span class="line">  backValue.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="comment">// return std::suspend_always&#123;&#125;;</span></span><br><span class="line">  <span class="keyword">return</span> BackAwaiter&lt;CoroHdl&gt;&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Hdl&gt; <span class="class"><span class="keyword">class</span> <span class="title">BackAwaiter</span> &#123;</span></span><br><span class="line">  Hdl hdl = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BackAwaiter</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;BackAwaiter await_ready\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">await_suspend</span><span class="params">(Hdl h)</span> <span class="keyword">noexcept</span> </span>&#123; hdl = h; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> hdl.<span class="built_in">promise</span>().backValue; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://changkun.de/modern-cpp/zh-cn/07-thread/">第 7 章 并行与并发 现代 C++ 教程: 高速上手 C++ 11/14/17/20 - Modern C++ Tutorial: C++ 11/14/17/20 On the Fly (changkun.de)</a></li><li><a href="https://gitbookcpp.llfc.club/sections/cpp/concurrent/concpp07.html">C++ 并发三剑客future, promise和async · 恋恋风辰的编程笔记 (llfc.club)</a></li><li>C++ Concurrency In Action</li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在现代c++(c++20)中,有了jthread和协程的概念,使得我们编写并发程序更加方便. 这里作简单学习.&lt;br&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://www.sekyoro.top/tags/cpp/"/>
    
    <category term="thread" scheme="https://www.sekyoro.top/tags/thread/"/>
    
    <category term="concurrency" scheme="https://www.sekyoro.top/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>回看深度学习:经典网络学习</title>
    <link href="https://www.sekyoro.top/2024/09/24/%E5%9B%9E%E7%9C%8B%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2024/09/24/%E5%9B%9E%E7%9C%8B%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-09-24T07:38:15.000Z</published>
    <updated>2024-10-24T08:46:12.910Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>传统深度学习,或者说在llm之前的深度学习,现在看来,还是有很多trick以及各种模块”缝合”的内容,这部分有很多提出来的方法其实都有一些共通点的,这里简单回顾总结一下.<br><span id="more"></span></p><h2 id="Vision-Transformer-and-its-variants"><a href="#Vision-Transformer-and-its-variants" class="headerlink" title="Vision Transformer and its variants"></a>Vision Transformer and its variants</h2><h3 id="AN-IMAGE-IS-WORTH-16X16-WORDS-TRANSFORMERS-FOR-IMAGE-RECOGNITION-AT-SCALE"><a href="#AN-IMAGE-IS-WORTH-16X16-WORDS-TRANSFORMERS-FOR-IMAGE-RECOGNITION-AT-SCALE" class="headerlink" title="AN IMAGE IS WORTH 16X16 WORDS: TRANSFORMERS FOR IMAGE RECOGNITION AT SCALE"></a>AN IMAGE IS WORTH 16X16 WORDS: TRANSFORMERS FOR IMAGE RECOGNITION AT SCALE</h3><p><img data-src="https://s2.loli.net/2024/09/26/GI83VzYUF4PaKg6.png" alt="image-20240926173222690"></p><h3 id="Swin-Transformer-Hierarchical-Vision-Transformer-using-Shifted-Windows"><a href="#Swin-Transformer-Hierarchical-Vision-Transformer-using-Shifted-Windows" class="headerlink" title="Swin Transformer: Hierarchical Vision Transformer using Shifted Windows"></a>Swin Transformer: Hierarchical Vision Transformer using Shifted Windows</h3><p><img data-src="https://s2.loli.net/2024/09/26/BEDZibGuALMsfUx.png" alt="image-20240926173305765"></p><h2 id="Modernify-Conv"><a href="#Modernify-Conv" class="headerlink" title="Modernify Conv"></a>Modernify Conv</h2><h3 id="A-ConvNet-for-the-2020s"><a href="#A-ConvNet-for-the-2020s" class="headerlink" title="A ConvNet for the 2020s"></a>A ConvNet for the 2020s</h3><p>出发点是一个ResNet-50模型.首先使用类似的训练技术来训练vision transformer,并获得了比原始ResNet-50更好的结果</p><p>然后我们研究了一系列的设计决策,总结为</p><p>1 )marco design,2 ) ResNeXt,3 )inverted- bottleneck,4 )大核尺寸,5 )各种layer-wise的mirco design.</p><p><img data-src="https://s2.loli.net/2024/09/26/LoV7htDUYzE3TuI.png" alt="image-20240926153040226"></p><h4 id="训练技术"><a href="#训练技术" class="headerlink" title="训练技术"></a>训练技术</h4><p>最近的研究表明,一套现代的训练技术可以显著提高一个简单的ResNet-50模型的性能.在本研究中,使用了与Dei-T和Swin Transformer相近的训练方法.</p><p>对于深度残差网络,训练从原来的90次扩展到300次.</p><p>使用Adam W优化器,数据增强技术如Mixup、Cutmix、Rand Augment、Random Erasing,以及正则化方案包括Stochastic Depth和Label Smoothing</p><h4 id="Marco-Design"><a href="#Marco-Design" class="headerlink" title="Marco Design"></a>Marco Design</h4><h5 id="修改阶段计算比例"><a href="#修改阶段计算比例" class="headerlink" title="修改阶段计算比例"></a>修改阶段计算比例</h5><p>Swin-T阶段计算比例略有不同,为1：1：3：1.对于较大的Swin Transformer,比例为1：1：9：1.</p><p>根据设计将每个阶段的块数从ResNet-50中的( 3、4、6、3)调整为( 3、3、9、3),这也将FLOPs与Swin-T对齐</p><h4 id="修改stem为patchify"><a href="#修改stem为patchify" class="headerlink" title="修改stem为patchify"></a>修改stem为patchify</h4><p>标准ResNet中的stem包含一个7 × 7的步幅为2的卷积层,然后是一个max pooling,这导致对输入图像进行4 ×的下采样.</p><p>在Vision Transformers中,使用了patchify策略作为stem,对应于较大的核尺寸(如kernel大小= 14或16)和非重叠卷积.</p><p>Swin Transformer使用了类似的” Patchify “层,但是具有更小的Patch size 4以适应架构的多级设计</p><p>将ResNet风格的stem替换为使用4 × 4,stride为4的卷积层实现的patchify层.准确率从79.4 %变为79.5 %.这表明ResNet中的stem可能被更简单的” patchify “层ViT替代,这将导致类似的性能</p><h4 id="ResNext-ify"><a href="#ResNext-ify" class="headerlink" title="ResNext-ify"></a>ResNext-ify</h4><p>核心部件是group normalization,其中卷积滤波器被分成不同的组.在更高的层面上,ResNeXt的指导原则是”利用更多群体,拓展宽度”.更确切地说,ResNeXt对瓶颈块中的3 × 3 conv层使用分组卷积.由于这显著降低了FLOPs,因此扩大了网络宽度以补偿容量损失,</p><p>depth-wise卷积类似于自注意力中的加权和操作,它在每个通道的基础上操作,即只在空间维度上混合信息</p><p>深度卷积和1 × 1卷积的结合导致了空间和通道混合的分离,这是视觉转换器共有的特性,其中每个操作要么混合了空间或通道维度的信息,但不是两者都混合.</p><p>depth-wise卷积的使用有效地降低了网络的FLOPs,但会降低精度</p><p>根据ResNeXt提出的策略,将网络宽度增加到与Swin-T的( 64 ~ 96)相同的通道数.随着FLOPs ( 5.3G )的增加,网络性能达到80.5 %.</p><h4 id="Inverted-Bottleneck"><a href="#Inverted-Bottleneck" class="headerlink" title="Inverted Bottleneck"></a>Inverted Bottleneck</h4><p>在每个Transformer模块中,一个重要的设计是它创建了一个反向瓶颈,即<strong>MLP模块的隐藏维度比输入维度宽4倍</strong></p><p><img data-src="https://s2.loli.net/2024/09/26/qsz5JcBe1dC9Dak.png" alt="image-20240926163046594"></p><p>尽管depth-wise卷积层的FLOP值有所增加,但由于下采样残差块的捷径1 × 1 conv层的FLOP值显著降低,该变化使得整个网络的FLOP值降低到4.6 G</p><h4 id="更大的尺寸大小"><a href="#更大的尺寸大小" class="headerlink" title="更大的尺寸大小"></a>更大的尺寸大小</h4><p>Vision Transformer最具有特色的一个方面是其非局部自注意力,这使得每一层都具有全局的感受野.过去,卷积神经网络使用大的内核尺寸,而(由VGGNet 推广)的金标准是堆叠小的内核尺寸( 3 × 3 )的conv层,它们在现代GPU上具有高效的硬件实现</p><p>虽然Swin Transformers将局部窗口重新引入到自注意力块中,但窗口大小至少为7 × 7,明显大于ResNe ( X ) t核大小3 × 3.在这里重新考虑了卷积神经网络中大核卷积的使用.</p><p>为了探索大核,<strong>一个先决条件是将depth-wise卷积放在前面</strong>.这在Transformers中也是显而易见的设计决策:MSA块( 大内核conv)放置在复杂/低效的模块的MLP层之前会有更少的通道,而高效、密集的1 × 1层会做繁重的提升.这一中间步骤将FLOPs降低到4.1 G,导致性能暂时下降到79.9 %.</p><p><img data-src="https://s2.loli.net/2024/09/26/j1EB3GYx5Kz9wJa.png" alt="image-20240926164338145"></p><p>在所有这些准备工作中,采用更大的核卷积的好处是显著的.实验了几种不同的核尺寸,包括3、5、7、9和11.网络的性能从79.9 % ( 3 × 3 )提高到80.6 % ( 7 × 7 ),而网络的FLOPs基本保持不变.此外观察到<strong>较大的核尺寸带来的收益在7 × 7处达到饱和点</strong>.在大容量模型中也验证了这一行为:将内核大小增加到7 × 7以上时,ResNet - 200机制模型没有表现出进一步的增益</p><h4 id="Micro-Design"><a href="#Micro-Design" class="headerlink" title="Micro Design"></a>Micro Design</h4><p><strong>使用GELU替换RELU</strong></p><p>NLP和视觉架构的一个不同之处在于使用的激活函数的具体形式.随着时间的推移,许多激活函数已经被开发出来,但ReLU 由于其简单和高效,仍然被广泛用于卷积神经网络中.</p><p>在ConvNet中,ReLU也可以用GELU代替,尽管精度保持不变</p><p><strong>更少的激活函数</strong></p><p>transfomer的激活函数较少.考虑一个具有key / query / value线性嵌入层的Transformer块,一个MLP块中的投影层和两个线性层.MLP块中只有一个激活函数.相比较而言,通常的做法是在每个卷积层中添加一个激活函数,包括1 × 1卷积层.</p><p>除了两个1 × 1层之间的GELU层外,从残差块中消除了所有GELU层,复制了Transformer块的风格.该过程使结果提高了0.7 % ~ 81.3 %,与Swin - T的性能基本匹配</p><p><strong>更少的normalization层</strong></p><p>transformer块通常也具有较少的归一化层数.这里去掉两个Batch Norm ( BN )层,在conv 1 × 1层之前只留下一个BN层.</p><p>每个块的归一化层数甚至比Transformers还要少,因为从经验上发现在块的开头增加一个BN层并不能提高性能</p><p><strong>替换BN为LN</strong></p><p>BatchNorm是卷积神经网络中的一个重要组成部分,它提高了收敛性并减少了过拟合</p><p>更简单的层归一化 在Transformer中得到了应用,在不同的应用场景中表现出良好的性能</p><p>直接将原始ResNet中的LN替换为BN会导致次优的性能.随着网络结构和训练技术的改变,这里重新使用LN代替BN的影响,观察到ConvNet模型在使用LN进行训练时没有任何困难；事实上,性能略好,获得了81.5 %的准确率</p><p><strong>单独的下采样层</strong></p><p>在ResNet中,空间下采样是通过每个阶段开始时的残差块来实现的,采用3×3的conv,stride为2 (short connection时使用stride为2的1 × 1 conv).</p><p>在Swin Transformers中,不同尺度之间增加了单独的下采样层.这里使用2×2的conv层和stride为2进行空间下采样.</p><p>进一步的研究表明,<strong>在空间分辨率变化的地方增加归一化层有助于稳定训练</strong>.其中包括Swin Transformers中也使用的几个LN层：每个下采样层之前的一个,stem之后的一个,最后全局平均池化之后的一个.可以将准确率提高到82.0%,明显超过Swin-T的81.3%</p><h3 id="Early-Convolutions-Help-Transformers-See-Better"><a href="#Early-Convolutions-Help-Transformers-See-Better" class="headerlink" title="Early Convolutions Help Transformers See Better"></a>Early Convolutions Help Transformers See Better</h3><p><img data-src="https://s2.loli.net/2024/09/26/Q5ajrv8dZT6MoKS.png" alt="image-20240926160213575"></p><p>Vision Transformer(ViT)模型表现出不达标的可优化性。特别地，它们对优化器( Adam W vs . SGD)、优化器超参数和训练调度长度的选择非常敏感。相比较而言，现代卷积神经网络更容易优化。为什么会出现这种情况?在这项工作中猜想问题在于ViT模型的patchify stem,它是通过应用于输入图像的stride-p p × p卷积(默认p = 16)来实现的</p><blockquote><p>也就是下采样p倍</p></blockquote><p>这种大核加大步长的卷积与神经网络中卷积层的典型设计选择背道而驰。为了检验这种非典型的设计选择是否会导致问题，分析了ViT模型的优化行为，其原始的Patchify词干与一个简单部分对应,将ViT patchify stem替换为少量堆叠的stride-2 3 × 3卷积。</p><p>虽然两种ViT设计的绝大多数计算量是相同的,但发现这种<strong>早期视觉处理的微小变化导致训练行为在对优化设置的敏感性以及最终的模型精度方面有明显的不同</strong>。在ViT中使用卷积树干显著地增加了优化的稳定性，并提高了峰值性能(在ImageNet - 1k上的top - 1准确率提高了1 - 2 %)，同时保持了触发器和运行时间</p><p>这种改进可以在模型复杂度(从1G到36G触发器)和数据集规模(从ImageNet - 1k到ImageNet - 21k)的宽光谱范围内观察到。这些发现促使我们推荐在该机制下为ViT模型使用一个标准的、轻量级的卷积主干，作为比原始ViT模型设计更稳健的架构选择。</p><h2 id="Vector-quantization-and-Codebook"><a href="#Vector-quantization-and-Codebook" class="headerlink" title="Vector quantization and Codebook"></a>Vector quantization and Codebook</h2><h3 id="Neural-Discrete-Representation-Learning"><a href="#Neural-Discrete-Representation-Learning" class="headerlink" title="Neural Discrete Representation Learning"></a>Neural Discrete Representation Learning</h3><p><a href="https://arxiv.org/abs/1711.00937">1711.00937] Neural Discrete Representation Learning (arxiv.org)</a></p><p><strong>在没有监督的情况下学习有用的表示</strong>(个人认为算是自监督-&gt;生成式学习)仍然是机器学习中的一个关键挑战.</p><p>VQ-VAE 两个关键方面与VAEs不同：</p><ul><li>encoder输出离散的编码,也就是中间嵌入是离散的</li><li>先验知识是学到的.</li></ul><p>为了学习一个离散的潜在表示,结合了向量量化( VQ )的思想.使用VQ方法可以使模型避免”后验崩溃”问题- -当潜在变量(中间嵌入)与decoder配对时被忽略</p><h4 id="离散潜变量-中间嵌入"><a href="#离散潜变量-中间嵌入" class="headerlink" title="离散潜变量(中间嵌入)"></a>离散潜变量(中间嵌入)</h4><p>定义一个潜在嵌入空间e∈R^K×D^,其中K为离散潜在空间(即K - way范畴)的大小,D为每个潜在嵌入向量e^i^的维数.注意到存在K个嵌入向量e~i~∈R^D^,i∈1,2,..,K.该模型取一个输入x,通过编码器产生输出z~e~(x)</p><p>然后利用共享嵌入空间e通过最近邻查找计算离散潜变量z</p><p><img data-src="https://s2.loli.net/2024/09/24/B5C7huNZsTWfdGP.png" alt="image-20240924160115359"></p><p>Z~e~(x)是编码器网络的输出,根据这个输出通过找到最近邻映射到给定的潜在空间中,得到z~q~(x)作为decoder的输入.</p><script type="math/tex; mode=display">z_q(x)=e_k,\quad\text{where}\quad k=\text{argmin}_j\|z_e(x)-e_j\|_2</script><p>对于梯度,直接将z~q~(x)的梯度copy到z~e~(x)</p><p>由于encoder的输出表示和decoder的输入共享相同的D维空间<strong>,梯度包含了encoder如何改变其输出以降低重构损失的有用信息</strong></p><p>总损失如下,有三个组成部分,分别用于训练VQ-VAE的不同部分.</p><p>第一项是重构损失(或数据项),它优化了解码器和编码器</p><p>由于z~e~ (x)到z~q~( x)映射的直通梯度估计(梯度直接copy),嵌入e~i~没有从重构损失log~p~ ( z | z~q~ ( x ) )中获得梯度.因此,为了学习嵌入空间,使用最简单的字典学习算法之一,向量量化( VQ ).VQ目标使用l2误差将嵌入向量e~i~移动到编码器输出z~e~ (x).</p><p>最后,由于嵌入空间的体积是无量纲的,如果嵌入e~i~的训练速度没有编码器参数那么快,嵌入空间的体积可以任意增长.</p><script type="math/tex; mode=display">L=\log p(x|z_q(x))+\|\mathrm{sg}[z_e(x)]-e\|_2^2+\beta\|z_e(x)-\mathrm{sg}[e]\|_2^2</script><p>Sg表示在前向计算时定义为恒等式且具有零偏导数的停止梯度算子,从而有效地约束其操作数为非更新常数</p><script type="math/tex; mode=display">sg(x)=\left\{\begin{array}{l}x (in forward propagation)\\0 (in backward propagation)\end{array}\right.</script><p>decoder只优化第一个损失项,encoder优化第一个和最后一个损失项,嵌入由中间损失项优化.</p><p><img data-src="https://raw.githubusercontent.com/zalandoresearch/pytorch-vq-vae/b98fde9a8f8f65486dbfaf12958049e8d33184a1//images/vq-vae.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VectorQuantizer</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_embeddings, embedding_dim, commitment_cost</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(VectorQuantizer, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self._embedding_dim = embedding_dim</span><br><span class="line">        self._num_embeddings = num_embeddings</span><br><span class="line">        </span><br><span class="line">        self._embedding = nn.Embedding(self._num_embeddings, self._embedding_dim)</span><br><span class="line">        self._embedding.weight.data.uniform_(-<span class="number">1</span>/self._num_embeddings, <span class="number">1</span>/self._num_embeddings)</span><br><span class="line">        self._commitment_cost = commitment_cost</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, inputs</span>):</span></span><br><span class="line">        <span class="comment"># convert inputs from BCHW -&gt; BHWC</span></span><br><span class="line">        inputs = inputs.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>).contiguous()</span><br><span class="line">        input_shape = inputs.shape</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Flatten input</span></span><br><span class="line">        flat_input = inputs.view(-<span class="number">1</span>, self._embedding_dim)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Calculate distances</span></span><br><span class="line">        distances = (torch.<span class="built_in">sum</span>(flat_input**<span class="number">2</span>, dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>) </span><br><span class="line">                    + torch.<span class="built_in">sum</span>(self._embedding.weight**<span class="number">2</span>, dim=<span class="number">1</span>)</span><br><span class="line">                    - <span class="number">2</span> * torch.matmul(flat_input, self._embedding.weight.t()))</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># Encoding</span></span><br><span class="line">        encoding_indices = torch.argmin(distances, dim=<span class="number">1</span>).unsqueeze(<span class="number">1</span>)</span><br><span class="line">        encodings = torch.zeros(encoding_indices.shape[<span class="number">0</span>], self._num_embeddings, device=inputs.device)</span><br><span class="line">        encodings.scatter_(<span class="number">1</span>, encoding_indices, <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Quantize and unflatten</span></span><br><span class="line">        quantized = torch.matmul(encodings, self._embedding.weight).view(input_shape)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Loss</span></span><br><span class="line">        e_latent_loss = F.mse_loss(quantized.detach(), inputs)</span><br><span class="line">        q_latent_loss = F.mse_loss(quantized, inputs.detach())</span><br><span class="line">        loss = q_latent_loss + self._commitment_cost * e_latent_loss</span><br><span class="line">        </span><br><span class="line">        quantized = inputs + (quantized - inputs).detach()</span><br><span class="line">        avg_probs = torch.mean(encodings, dim=<span class="number">0</span>)</span><br><span class="line">        perplexity = torch.exp(-torch.<span class="built_in">sum</span>(avg_probs * torch.log(avg_probs + <span class="number">1e-10</span>)))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># convert quantized from BHWC -&gt; BCHW</span></span><br><span class="line">        <span class="keyword">return</span> loss, quantized.permute(<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>).contiguous(), perplexity, encodings</span><br></pre></td></tr></table></figure><ul><li><a href="https://zhuanlan.zhihu.com/p/640000410">VQVAE PyTorch 实现教程 - 知乎 (zhihu.com)</a></li><li><a href="https://github.com/Jackson-Kang/Pytorch-VAE-tutorial/blob/master/02_Vector_Quantized_Variational_AutoEncoder.ipynb">Pytorch-VAE-tutorial/02_Vector_Quantized_Variational_AutoEncoder.ipynb at master · Jackson-Kang/Pytorch-VAE-tutorial (github.com)</a></li><li><a href="https://github.com/zalandoresearch/pytorch-vq-vae/blob/master/vq-vae.ipynb">pytorch-vq-vae/vq-vae.ipynb at master · zalandoresearch/pytorch-vq-vae (github.com)</a></li></ul><h3 id="Generating-Diverse-High-Fidelity-Images-with-VQ-VAE-2"><a href="#Generating-Diverse-High-Fidelity-Images-with-VQ-VAE-2" class="headerlink" title="Generating Diverse High-Fidelity Images with VQ-VAE-2"></a>Generating Diverse High-Fidelity Images with VQ-VAE-2</h3><p><img data-src="https://s2.loli.net/2024/10/08/mZbQlPEJiKeTztn.png" alt="image-20241008113944530"></p><h3 id="Taming-Transformers-for-High-Resolution-Image-Synthesis"><a href="#Taming-Transformers-for-High-Resolution-Image-Synthesis" class="headerlink" title="Taming Transformers for High-Resolution Image Synthesis"></a>Taming Transformers for High-Resolution Image Synthesis</h3><p><a href="https://arxiv.org/pdf/2012.09841">2012.09841 (arxiv.org)</a></p><p><img data-src="https://s2.loli.net/2024/09/24/eyoQUhlq24Ynxru.png" alt="image-20240924210104616"></p><p>为了学习序列数据上的长程交互,Transformer在各种各样的任务上不断地展示出最先进的结果.与卷积神经网络不同的是,它们不包含优先考虑局部交互的归纳偏差.这使得它们具有表达能力,<strong>但对于长序列,如高分辨率图像,在计算上也是不可行的.本文展示了如何将CNN的感应偏置的有效性与transformer的表达能力相结合,使其能够建模,从而合成高分辨率图像</strong></p><p>复杂度不是建立在单个像素上,而是需要一种方法,使用学习表示的离散码本,使得任何图像x∈R^H×W×3^都可以由码本项的空间集合z~q~∈R^h×w×nz^表示,其中nz是中间变量的维数</p><h4 id="学习高效codebook"><a href="#学习高效codebook" class="headerlink" title="学习高效codebook"></a>学习高效codebook</h4><p>首先学习一个由编码器E和解码器G组成的卷积模型,使得它们一起从一个学习的离散codebook $\mathcal{Z}={z<em>k}</em>{k=1}^K\subset\mathbb{R}^{n_z}$中学习用码表示图像,获得</p><script type="math/tex; mode=display">z_{\mathbf{q}}=\mathbf{q}(\hat{z}):=\left(\underset{z_k\in\mathcal{Z}}{\operatorname*{\arg\min}}\|\hat{z}_{ij}-z_k\|\right)\in\mathbb{R}^{h\times w\times n_z}</script><script type="math/tex; mode=display">\hat{x}=G(z_\mathbf{q})=G\left(\mathbf{q}(E(x))\right)</script><p>利用编码( z = E(x)∈R^h×w×nz^ )和每个空间码( z~ij~^^^∈R^nz^ )在其最近的codebook项z~k~上的后续逐元素量化q ( · )得到zq</p><script type="math/tex; mode=display">\begin{aligned}\mathcal{L}_{\mathrm{VQ}}(E,G,\mathcal{Z})&=\|x-\hat{x}\|^{2}+\|\mathrm{sg}[E(x)]-z_{\mathbf{q}}\|_{2}^{2}\\&+\|\mathrm{sg}[z_{\mathbf{q}}]-E(x)\|_{2}^{2}.\end{aligned}</script><p>使用Transformer将图像表示为潜在图像成分上的分布</p><h4 id="生成视觉丰富的codebook"><a href="#生成视觉丰富的codebook" class="headerlink" title="生成视觉丰富的codebook"></a>生成视觉丰富的codebook</h4><script type="math/tex; mode=display">\mathcal{L}_\mathrm{GAN}(\{E,G,\mathcal{Z}\},D)=[\log D(x)+\log(1-D(\hat{x}))]</script><script type="math/tex; mode=display">\begin{aligned}\mathcal{Q}^{*}=\arg\min_{E,G,\mathcal{Z}}\max_{D}\mathbb{E}_{x\sim p(x)}\Big[\mathcal{L}_{\mathrm{VQ}}(E,G,\mathcal{Z})\\+\lambda\mathcal{L}_{\mathrm{GAN}}(\{E,G,\mathcal{Z}\},D)\Big]\end{aligned}</script><p>$\lambda$设置取</p><script type="math/tex; mode=display">\lambda=\frac{\nabla_{G_L}[\mathcal{L}_{\mathrm{rec}}]}{\nabla_{G_L}[\mathcal{L}_{\mathrm{GAN}}]+\delta}</script><p>∂~GL~ [ · ]表示其梯度也就是在decoder最后一层L的梯度</p><h4 id="使用transformers学习图像生成"><a href="#使用transformers学习图像生成" class="headerlink" title="使用transformers学习图像生成"></a>使用transformers学习图像生成</h4><p>在E和G可用的情况下可以根据它们编码的codebook索引来表示图像.图像x的量化编码是由z~q~ = q ( E ( x ) )∈R^h×w×nz^给出的,并且等价于一个序列从码本中得到的索引$s\in{0,\ldots,|\mathcal{Z}|-1}^{n\times w}$,它是由码本Z中的索引替换每个码得到的</p><p>通过将序列s的索引映射回其对应的码本项,z~q~ = ( z~sij~ )很容易恢复并解码成图像(x = G(z~q~ ) ).</p><p>在s中选择一些指标的排序后图像生成可以表示为自回归下一指标预测：给定指标s &lt; i,转换器学习预测可能的下一指标的分布,即p(s~i~ | s &lt; i)</p><script type="math/tex; mode=display">\mathcal{L}_{\text{Transformer}}=\mathbb{E}_{x\sim p(x)}\left[-\log p(s)\right]</script><h4 id="约束的图像生成"><a href="#约束的图像生成" class="headerlink" title="约束的图像生成"></a>约束的图像生成</h4><p>在许多图像合成任务中,用户需要通过提供额外的信息来控制生成过程,从而合成一个示例.这种信息,我们称之为c,可以是描述整体图像类别的单个标签,也可以是另一幅图像本身.然后任务是学习给定这个信息c的序列的似然</p><script type="math/tex; mode=display">p(s|c)=\prod_ip(s_i|s_{<i},c)</script><h4 id="生成高分辨率图片"><a href="#生成高分辨率图片" class="headerlink" title="生成高分辨率图片"></a>生成高分辨率图片</h4><p>为了生成百万像素级别的图像,我们必须在训练过程中对图像块和裁剪图像进行处理,将s的长度限制在最大可行尺寸.</p><p>为了对图像进行采样使用滑动窗口方式的transformers</p><p><img data-src="https://s2.loli.net/2024/09/24/fPyLMHekCdGRWrT.png" alt="image-20240924225113569"></p><p><a href="https://github.com/Shubhamai/pytorch-vqgan">Shubhamai/pytorch-vqgan: This repo contains the implementation of VQGAN, Taming Transformers for High-Resolution Image Synthesis in PyTorch from scratch. I have added support for custom datasets, testings, experiment tracking etc. (github.com)</a></p><h2 id="UDA"><a href="#UDA" class="headerlink" title="UDA"></a>UDA</h2><h3 id="Unsupervised-Domain-Adaptation-by-Backpropagation"><a href="#Unsupervised-Domain-Adaptation-by-Backpropagation" class="headerlink" title="Unsupervised Domain Adaptation by Backpropagation"></a>Unsupervised Domain Adaptation by Backpropagation</h3><p><a href="https://arxiv.org/abs/1409.7495">1409.7495] Unsupervised Domain Adaptation by Backpropagation (arxiv.org)</a></p><p><img data-src="https://s2.loli.net/2024/09/24/l5AuBIpzqbGL2WO.png" alt="image-20240924230029897"></p><h3 id="CDTrans-Cross-domain-Transformer-for-Unsupervised-Domain-Adaptation"><a href="#CDTrans-Cross-domain-Transformer-for-Unsupervised-Domain-Adaptation" class="headerlink" title="CDTrans: Cross-domain Transformer for Unsupervised Domain Adaptation"></a>CDTrans: Cross-domain Transformer for Unsupervised Domain Adaptation</h3><p><a href="https://arxiv.org/abs/2109.06165">2109.06165] CDTrans: Cross-domain Transformer for Unsupervised Domain Adaptation (arxiv.org)</a></p><p><img data-src="https://s2.loli.net/2024/09/25/dPITi2QMRE8u4Z3.png" alt="image-20240925162052101"></p><p>它由3个权重共享的transformer组成,通过使用two-way center-aware labeling method方法选择成对输入.</p><p>源分支( HS )和目标分支( HT )采用交叉熵,源-目标分支( HS + T )和HT之间采用蒸馏损失</p><h3 id="TVT-Transferable-Vision-Transformer-for-Unsupervised-Domain-Adaptation"><a href="#TVT-Transferable-Vision-Transformer-for-Unsupervised-Domain-Adaptation" class="headerlink" title="TVT: Transferable Vision Transformer for Unsupervised Domain Adaptation"></a>TVT: Transferable Vision Transformer for Unsupervised Domain Adaptation</h3><p><a href="https://openaccess.thecvf.com/content/WACV2023/papers/Yang_TVT_Transferable_Vision_Transformer_for_Unsupervised_Domain_Adaptation_WACV_2023_paper.pdf">TVT: Transferable Vision Transformer for Unsupervised Domain Adaptation (thecvf.com)</a></p><p>随着近年来Vision Transformer在视觉任务中的应用呈指数增长,然而,ViT在适应跨领域知识方面的能力在文献中仍未被探索.为了填补这一空白,本文首先全面考察了ViT在多种域适应任务上的表现.令人惊讶的是,ViT表现出优越的泛化能力,而通过结合对抗自适应可以进一步提高性能</p><p>尽管如此,直接使用基于CNNs的适应策略并没有利用ViT在知识转移中发挥重要作用的内在优势(例如,注意力机制和序列图像表示).为了弥补这一缺陷,我们提出了一个统一的框架,即可迁移视觉转换器( Transferable Vision Transformer,TVT ),以充分利用视觉里程计的可迁移性进行领域自适应.</p><p><img data-src="https://s2.loli.net/2024/09/25/bVSItlqa89kWpmj.png" alt="image-20240925162302199"></p><p>与ViT一样,源图像和目标图像都被分割成固定大小的图像块,然后线性映射并嵌入位置信息.生成的补丁送入变压器编码器,最后一层由可转让性适配模块( TAM )替换.特征学习、对抗域适应和分类由ViT-akin骨干、两个域判别器(在path-level和global-level上)、判别聚类模块( Discriminative Clustering Module,DCM )和基于MLP的分类器完成</p><h2 id="Variant-Transformer"><a href="#Variant-Transformer" class="headerlink" title="Variant Transformer"></a>Variant Transformer</h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;传统深度学习,或者说在llm之前的深度学习,现在看来,还是有很多trick以及各种模块”缝合”的内容,这部分有很多提出来的方法其实都有一些共通点的,这里简单回顾总结一下.&lt;br&gt;</summary>
    
    
    
    
    <category term="deep learning" scheme="https://www.sekyoro.top/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>完整的C++项目构建注意事项</title>
    <link href="https://www.sekyoro.top/2024/09/16/%E5%AE%8C%E6%95%B4%E7%9A%84C-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://www.sekyoro.top/2024/09/16/%E5%AE%8C%E6%95%B4%E7%9A%84C-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2024-09-16T09:27:04.000Z</published>
    <updated>2024-09-18T15:31:47.999Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近常常使用cmake构建c++项目有感,从创建项目到打包发布总结一下需要注意的事情.<br><span id="more"></span></p><h2 id="项目组织方式"><a href="#项目组织方式" class="headerlink" title="项目组织方式"></a>项目组织方式</h2><p>具体的项目组织方式因人而异,这里推荐一种,在src目录中创建模块目录,再在include目录中常见对应的同名目录包含头文件,可执行程序的源代码或者最终生成库的源代码可以放在app目录中.</p><p>比如我看的一个项目组织如图</p><ol><li>在src目录中包括demo,view,assignment三个项目,对应include目录相同,或者在生成程序的目录中包含头文件而不另外放include中.</li></ol><p><img data-src="https://s2.loli.net/2024/09/16/ctGKixOyJs19qo6.png" alt="image-20240916205927734"></p><ol><li>此外也有src目录中放所有的源代码文件,include目录分别放每个模块对应的头文件,相对来说更方便.</li></ol><p>针对第一种组织方式,cmake会在src目录添加模块</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(view)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(demo)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(assignments)</span><br></pre></td></tr></table></figure><p>每个模块再单独写cmake,甚至可以单独写project,这样方便模块化,可以看到下面利用不同的<code>$&#123;PROJECT_NAME&#125;</code>设置库生成位置</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(demo_hello_world)</span><br><span class="line"><span class="keyword">file</span>(GLOB source</span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/demo_hello_world.cpp&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;source&#125;</span>)</span><br><span class="line"><span class="keyword">set_target_properties</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PROPERTIES </span><br><span class="line">  DEBUG_POSTFIX <span class="string">&quot;_d&quot;</span></span><br><span class="line">  RUNTIME_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;BINARY_DIR&#125;&quot;</span></span><br><span class="line">  LIBRARY_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;LIBRARY_DIR&#125;&quot;</span></span><br><span class="line">  ARCHIVE_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;LIBRARY_DIR&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PUBLIC view) </span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(demo)</span><br><span class="line"><span class="keyword">file</span>(GLOB source</span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/demo.cpp&quot;</span></span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/window_demo.cpp&quot;</span></span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/window_demo.h&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;source&#125;</span>)</span><br><span class="line"><span class="keyword">set_target_properties</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PROPERTIES </span><br><span class="line">  DEBUG_POSTFIX <span class="string">&quot;_d&quot;</span></span><br><span class="line">  RUNTIME_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;BINARY_DIR&#125;&quot;</span></span><br><span class="line">  LIBRARY_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;LIBRARY_DIR&#125;&quot;</span></span><br><span class="line">  ARCHIVE_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;LIBRARY_DIR&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PUBLIC view) </span><br></pre></td></tr></table></figure><p>比较来看,如果给src目录中放所有的cpp源文件,那不好给模块分离,因为一个项目中一般包括一个生成可执行程序或最终库的源代码,一起一堆供这个目标依赖的模块,这些模块如果能单独提出来更好,也就是说这些模板的cpp代码如果放在分别的模块目录下虽然更麻烦但更好. 此外将main程序放在app目录中也更加清晰.</p><h2 id="依赖图与文档生成"><a href="#依赖图与文档生成" class="headerlink" title="依赖图与文档生成"></a>依赖图与文档生成</h2><h3 id="查看目标的依赖"><a href="#查看目标的依赖" class="headerlink" title="查看目标的依赖"></a>查看目标的依赖</h3><p>下载graphviz</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build &amp;&amp; cmake .. --graphviz=graph.dot &amp;&amp; dot -Tpng graph.dot -o graphImage.png</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/09/17/z7DmyW4sqKfaMFg.png" alt="graphImage"></p><h3 id="使用Doxygen生成文档"><a href="#使用Doxygen生成文档" class="headerlink" title="使用Doxygen生成文档"></a>使用Doxygen生成文档</h3><p>需要按照规定格式撰写注释,根据注释生成文档<a href="https://www.doxygen.nl/manual/docblocks.html">Doxygen: Documenting the code</a>. </p><p>doxygen支持许多格式注释,下面列举三种</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ... text ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/** Brief description which ends at this dot. Details follow</span></span><br><span class="line"><span class="comment"> *  here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * ... text ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*! \brief Brief description.</span></span><br><span class="line"><span class="comment"> *         Brief description continued.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Detailed description starts here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*!</span></span><br><span class="line"><span class="comment"> ... text ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>注释</th><th>介绍</th></tr></thead><tbody><tr><td>@file</td><td>文件说明</td></tr><tr><td>@author</td><td>作者的信息</td></tr><tr><td>@brief</td><td>用于class 或function的批注中，后面为class 或function的简易说明</td></tr><tr><td>@param</td><td>参数介绍</td></tr><tr><td>@return</td><td>函数传回值的说明</td></tr></tbody></table></div><blockquote><p>Doxygen 还需要一个 Doxyfile，其包含文档生成的所有参数，比如输出格式、排除的文件模式、 项目名称等。因为配置参数太多，开始配置 Doxygen 可能会让人望而生畏，但 CMake 可以自动生 成 Doxyfile。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doxygen -g <span class="comment"># 生成doxyfile</span></span><br></pre></td></tr></table></figure><p>配置doxygenfile然后运行<code>doxygen</code>生成.</p><p>当然更好的方式是结合cmake,首先找到doxygen程序,然后设置需要的选项<a href="https://www.doxygen.nl/manual/config.html#cfg_recursive">Doxygen: Configuration</a>,最后生成文旦. 可以使用<code>add_custom_target</code>或者<code>doxygen_add_docs(推荐)</code><a href="https://cmake.org/cmake/help/latest/module/FindDoxygen.html">FindDoxygen — CMake 3.30.3 Documentation</a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(Doxygen)</span></span></span><br><span class="line"><span class="keyword">if</span> (DOXYGEN_FOUND)</span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_OUTPUT_DIRECTORY<span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/docs&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_GENERATE_HTML YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_GENERATE_MAN YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_MARKDOWN_SUPPORT YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_AUTOLINK_SUPPORT YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_HAVE_DOT YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_COLLABORATION_GRAPH YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_CLASS_GRAPH YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_UML_LOOK YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_DOT_UML_DETAILS YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_DOT_WRAP_THRESHOLD <span class="number">100</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_CALL_GRAPH YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_QUIET YES)</span></span></span><br><span class="line"><span class="number">#add</span>_custom_target(docs  $&#123;DOXYGEN_EXECUTABLE&#125; WORKING_DIRECTORY $&#123;CMAKE_SOURCE_DIR&#125;/docs))</span><br><span class="line">doxygen_add_docs(</span><br><span class="line">docs</span><br><span class="line"><span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;&quot;</span></span><br><span class="line">ALL</span><br><span class="line">COMMENT <span class="string">&quot;Generating documentation for myproject&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">doxygen_add_docs(targetName</span><br><span class="line"><span class="string">    [filesOrDirs...]</span></span><br><span class="line"><span class="string">    [ALL]</span></span><br><span class="line"><span class="string">    [USE_STAMP_FILE]</span></span><br><span class="line"><span class="string">    [WORKING_DIRECTORY dir]</span></span><br><span class="line"><span class="string">    [COMMENT comment]</span></span><br><span class="line"><span class="string">    [CONFIG_FILE filename]</span>)</span><br></pre></td></tr></table></figure><p>第一个参数 targetName 是文档目标的名称,该函数将生成一个名为 targetName 的自定义目 标。这个目标将触发 Doxygen,并在构建时使用代码创建文档。</p><p>filesOrDirs包含想要从文档生成的代码的文件或目录的列表。</p><p>ALL 参数用于使 CMake 的 ALL 元目标依赖于 doxygen_add_docs(…) 创建的文档目标，因此在构建 ALL 元目标时自动生成文档。</p><p>WORKING_DIRECTORY默认是 <code>CMAKE_CURRENT_SOURCE_DIR</code></p><h2 id="代码检查和格式化工具"><a href="#代码检查和格式化工具" class="headerlink" title="代码检查和格式化工具"></a>代码检查和格式化工具</h2><p>这部分工作其实完全可以交由IDE提供,不需要在cmake build时使用的,但为了保持兼容,这里简略写一点</p><p>可以考虑使用<code>clang-tidy</code>和<code>clang-format</code>工具,在cmake文件中</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.28</span>)</span><br><span class="line"><span class="keyword">project</span>(my-<span class="keyword">project</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(my-app main.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE ALL_SOURCE_FILES</span><br><span class="line">    *.c *.h *.cpp *.hpp *.cxx *.hxx *.cc *.hh *.cppm *.ipp *.ixx)</span><br><span class="line"><span class="keyword">add_custom_target</span>(format</span><br><span class="line">    <span class="keyword">COMMAND</span> clang-format</span><br><span class="line">    -i</span><br><span class="line">    <span class="variable">$&#123;ALL_SOURCE_FILES&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于<code>clang-tidy</code>完全可以在<code>.clang-tidy</code>文件中设置并通过clangd进行检查<a href="https://discourse.llvm.org/t/enabling-clang-tidy-checks-in-clangd/4906/2">Enabling clang-tidy checks in clangd - Clang Frontend / clangd - LLVM Discussion Forums</a></p><p><a href="https://clangd.llvm.org/config.html#clangtidy">Configuration (llvm.org)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># .clangd</span><br><span class="line">Diagnostics:</span><br><span class="line">  ClangTidy:</span><br><span class="line">    CheckOptions:</span><br><span class="line">      readability-identifier-naming.VariableCase: CamelCase</span><br></pre></td></tr></table></figure><p>此外还可以设置编译器编译链接选项检查内存和初始化等错误</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> (add_sanitier <span class="keyword">target</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Adding sanitizer to target $&#123;target&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> (CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> <span class="string">&quot;CLANG&quot;</span> <span class="keyword">OR</span> CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> <span class="string">&quot;GNU&quot;</span>)</span><br><span class="line">    <span class="keyword">add_compile_options</span>(<span class="string">&quot;-fno-omit-frame-pointer&quot;</span>)</span><br><span class="line">    <span class="keyword">add_link_options</span>(<span class="string">&quot;-fno-omit-frame-pointer&quot;</span>)</span><br><span class="line">    <span class="keyword">target_compile_options</span>(<span class="variable">$&#123;target&#125;</span> PRIVATE -fsanitize=address)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;target&#125;</span> PRIVATE -fsanitize=address)</span><br><span class="line">    <span class="keyword">target_compile_options</span>(<span class="variable">$&#123;target&#125;</span> PRIVATE -fsanitize=undefined)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;target&#125;</span> PRIVATE -fsanitize=undefined)</span><br><span class="line">  <span class="keyword">elseif</span> (CMAKE_CXX_COMPILER_ID <span class="keyword">STREQUAL</span> <span class="string">&quot;MSVC&quot;</span>)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(<span class="variable">$&#123;target&#125;</span> PRIVATE /fsanitize=address)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(WARNING <span class="string">&quot;Sanitier is not supported for $&#123;CMAKE_CXX_COMPILER_ID&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure><p>除此之外,可以使用<code>valgrind</code>等工具动态debug查找内存问题.</p><h2 id="进行测试"><a href="#进行测试" class="headerlink" title="进行测试"></a>进行测试</h2><h3 id="CTest"><a href="#CTest" class="headerlink" title="CTest"></a>CTest</h3><p><a href="https://cmake.org/cmake/help/book/mastering-cmake/chapter/Testing With CMake and CTest.html">Testing With CMake and CTest — Mastering CMake</a></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(CTest)</span><br><span class="line"><span class="keyword">add_executable</span>(TestInstantiator TestInstantiator.cxx)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(TestInstantiator vtkCommon)</span><br><span class="line"><span class="keyword">add_test</span>(NAME TestInstantiator</span><br><span class="line">         <span class="keyword">COMMAND</span> TestInstantiator)</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>CTest 模块通常应该只包含在项目的顶层 CMakeLists.txt 中。自从 CMake 版本 3.21 以 来，PROJECT_IS_TOP_LEVEL 可以用来测试当前的 CMakeLists.txt 是否为顶层文件。</p><p>对于项目的顶层目录和使用 ExternalProject 添加的项目顶层目录，此变量为 True。对于使用 add_subdirectory 或 FetchContent 添加的目录，该值为 False</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(CMakeBestPractice)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span>(PROJECT_IS_TOP_LEVEL)</span><br><span class="line"><span class="keyword">include</span>(CTest)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_test(NAME &lt;name&gt; COMMAND &lt;command&gt; <span class="meta">[&lt;arg&gt;...]</span></span><br><span class="line"><span class="meta">[CONFIGURATIONS &lt;config&gt;...]</span></span><br><span class="line"><span class="meta">[WORKING_DIRECTORY &lt;dir&gt;]</span></span><br><span class="line">[COMMAND_EXPAND_LISTS])</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctest --test-dir &lt;build_dir&gt;</span><br><span class="line">cmake --build &lt;build_dir&gt; --target <span class="built_in">test</span> <span class="comment"># 注意这里目标就是test,而不是add_test中添加的NAME</span></span><br><span class="line">ctest --build-and-test &lt;source_dir&gt; &lt;build_dir&gt;</span><br></pre></td></tr></table></figure><p>可以设置ctest多个lable,然后通过过滤查看对应结果</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_test</span>(NAME labeled_test_1 <span class="keyword">COMMAND</span> someTest)</span><br><span class="line"><span class="keyword">set_tests_properties</span>(labeled_test PROPERTIES LABELS <span class="string">&quot;example&quot;</span>)</span><br><span class="line"><span class="keyword">add_test</span>(NAME labeled_test_2 <span class="keyword">COMMAND</span> anotherTest)</span><br><span class="line"><span class="keyword">set_tests_properties</span>(labeled_test_2 PROPERTIES LABELS <span class="string">&quot;will_fail&quot;</span> )</span><br><span class="line"><span class="keyword">add_test</span>(NAME labeled_test_3 <span class="keyword">COMMAND</span> YetAnotherText)</span><br><span class="line"><span class="keyword">set_tests_properties</span>(labeled_test_3 PROPERTIES LABELS <span class="string">&quot;example;will_fail&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctest -L <span class="string">&quot;example|will_fail&quot;</span></span><br></pre></td></tr></table></figure><p><code>-L</code>进行过滤</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctest -I [Start,End,Stride,<span class="built_in">test</span><span class="comment">#,test#,...|Test file] </span></span><br></pre></td></tr></table></figure><p>通过 Start、End 和 Stride，可以指定要执行的测试的范围。这三个数字是与显式测试数字 test# 相结合的范围，或传递包含参数的文件</p><h4 id="处理大量测试"><a href="#处理大量测试" class="headerlink" title="处理大量测试"></a>处理大量测试</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create_test_sourcelist</span> (SourceListName</span><br><span class="line">                        DriverName</span><br><span class="line">                        test1 test2 test3</span><br><span class="line">                        EXTRA_INCLUDE <span class="keyword">include</span>.h</span><br><span class="line">                        <span class="keyword">FUNCTION</span> <span class="keyword">function</span></span><br><span class="line">                        )</span><br></pre></td></tr></table></figure><blockquote><p>注意ctest并不提供方便测试的方法,可以使用第三方库提供的REQUIRE等方法</p></blockquote><p>使用<code>include(Ctest)</code>和<code>add_test</code>可使得可以方便使用<code>ctest</code>命令进行测试</p><p>比如</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake --build build</span><br><span class="line"><span class="built_in">cd</span> build &amp;&amp; ctest</span><br></pre></td></tr></table></figure><h3 id="使用Catch2"><a href="#使用Catch2" class="headerlink" title="使用Catch2"></a>使用Catch2</h3><p><a href="https://github.com/catchorg/Catch2">catchorg/Catch2: A modern, C++-native, test framework for unit-tests, TDD and BDD - using C++14, C++17 and later (C++11 support is in v2.x branch, and C++03 on the Catch1.x branch) (github.com)</a></p><p>创建tests目录,编写cmake文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">ENABLE_TESTING</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span>(TEST_MAIN <span class="string">&quot;unit_tests&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(TEST_SOURCES main.cpp)</span><br><span class="line">    <span class="keyword">set</span>(TEST_INCLUDES <span class="string">&quot;./&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">add_executable</span>(<span class="variable">$&#123;TEST_MAIN&#125;</span> <span class="variable">$&#123;TEST_SOURCES&#125;</span>)</span><br><span class="line">    <span class="keyword">target_include_directories</span>(<span class="variable">$&#123;TEST_MAIN&#125;</span> PUBLIC <span class="variable">$&#123;TEST_INCLUDES&#125;</span>)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;TEST_MAIN&#125;</span> PUBLIC <span class="variable">$&#123;LIBRARY_NAME&#125;</span> Catch2::Catch2WithMain)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>自动发现测试</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"><span class="keyword">project</span>(baz LANGUAGES CXX VERSION <span class="number">0.0</span>.<span class="number">1</span>)</span><br><span class="line"><span class="keyword">find_package</span>(Catch2 REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(tests <span class="keyword">test</span>.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(tests PRIVATE Catch2::Catch2)</span><br><span class="line"><span class="comment"># list(APPEND CMAKE_MODULE_PATH $&#123;catch2_SOURCE_DIR&#125;/extras) # use FetchContent</span></span><br><span class="line"><span class="keyword">include</span>(CTest)</span><br><span class="line"><span class="keyword">include</span>(Catch)</span><br><span class="line">catch_discover_tests(tests)</span><br></pre></td></tr></table></figure><h3 id="使用GoogleTest"><a href="#使用GoogleTest" class="headerlink" title="使用GoogleTest"></a>使用GoogleTest</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.14</span>)</span><br><span class="line"><span class="keyword">project</span>(my_project)</span><br><span class="line"></span><br><span class="line"><span class="comment"># GoogleTest requires at least C++14</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(</span><br><span class="line">  googletest</span><br><span class="line">  URL https://github.com/google/googletest/archive/<span class="number">03597</span>a01ee50ed33e9dfd640b249b4be3799d395.zip</span><br><span class="line">)</span><br><span class="line"><span class="comment"># For Windows: Prevent overriding the parent project&#x27;s compiler/linker settings</span></span><br><span class="line"><span class="keyword">set</span>(gtest_force_shared_crt <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line">FetchContent_MakeAvailable(googletest)</span><br><span class="line"></span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(hello_test hello_test.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello_test GTest::gtest_main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(GoogleTest)</span><br><span class="line">gtest_discover_tests(hello_test) <span class="comment"># 自动发现测试</span></span><br></pre></td></tr></table></figure><h3 id="代码覆盖检查"><a href="#代码覆盖检查" class="headerlink" title="代码覆盖检查"></a>代码覆盖检查</h3><p>检查测试了哪些代码并生成覆盖率报告,使用Gcov生成覆盖率信息,使用覆盖分析程序,如 Gcovr 或 LCOVn分析覆盖文件并生成报告</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>CTest+Catch2即可</p><h2 id="第三方库管理"><a href="#第三方库管理" class="headerlink" title="第三方库管理"></a>第三方库管理</h2><h3 id="使用FetchContent下载库"><a href="#使用FetchContent下载库" class="headerlink" title="使用FetchContent下载库"></a>使用FetchContent下载库</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(nlohmann_json </span><br><span class="line">GIT_REPOSITORY https://github.com/nlohmann/json</span><br><span class="line">GIT_TAG v3.<span class="number">11.2</span></span><br><span class="line">GIT_SHALLOW <span class="keyword">TRUE</span>)</span><br><span class="line">FetchContent_Makeavailable(nlohmann_json)</span><br></pre></td></tr></table></figure><p>需要项目是cmake项目</p><h3 id="使用vcpkg等包管理工具下载库"><a href="#使用vcpkg等包管理工具下载库" class="headerlink" title="使用vcpkg等包管理工具下载库"></a>使用vcpkg等包管理工具下载库</h3><p><a href="https://www.sekyoro.top/2024/09/11/C-现代构建系统/#more">包管理器与xmake介绍</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="attr">&quot;configurePresets&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;my-preset&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;binaryDir&quot;</span>: <span class="string">&quot;$&#123;sourceDir&#125;/build&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;toolchainFile&quot;</span>: <span class="string">&quot;$env&#123;VCPKG_ROOT&#125;/scripts/buildsystems/vcpkg.cmake&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.28</span>)</span><br><span class="line"><span class="keyword">project</span>(my-<span class="keyword">project</span>)</span><br><span class="line"><span class="keyword">find_package</span>(ftxui REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(my-app main.cpp)</span><br><span class="line"><span class="keyword">target_compile_features</span>(my-app PRIVATE cxx_std_20)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(my-app PRIVATE ftxui::dom ftxui::screen ftxui::component)</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install</span><br><span class="line">cmake --preset my-preset</span><br><span class="line">cmake --build build</span><br><span class="line">./build/my-app</span><br></pre></td></tr></table></figure><h3 id="使用Conan"><a href="#使用Conan" class="headerlink" title="使用Conan"></a>使用Conan</h3><p>简单介绍一下使用流程</p><p>首先定义conanfile.txt和conan profile</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[requires]</span></span><br><span class="line">zlib/<span class="number">1.2</span><span class="number">.11</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[generators]</span></span><br><span class="line">CMakeDeps</span><br><span class="line">CMakeToolchain</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conan profile detect --force</span><br></pre></td></tr></table></figure><p>然后执行<code>conan insatll</code>会生成<code>conan_toolchain.cmake</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conan install . --output-folder=build --build=missing</span><br></pre></td></tr></table></figure><p>再在cmake中使用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. -G <span class="string">&quot;Visual Studio 15 2017&quot;</span> -DCMAKE_TOOLCHAIN_FILE=<span class="string">&quot;conan_toolchain.cmake&quot;</span></span><br></pre></td></tr></table></figure><h3 id="借助git-submodule下载库"><a href="#借助git-submodule下载库" class="headerlink" title="借助git submodule下载库"></a>借助git submodule下载库</h3><p><a href="https://git.github.io/git-scm.com/docs/git-submodule/zh_HANS-CN">Git - git-submodule Documentation</a></p><p><a href="https://www.atlassian.com/git/tutorials/git-submodule">Git submodule | Atlassian</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https://bitbucket.org/jaredw/awesomelibrary <span class="comment"># 添加子模块(当前新版本git也会下载对应模块)</span></span><br><span class="line">git submodule init //初始化子模块 (根据.gitmodules更新信息)</span><br><span class="line">git submodule update //更新子模块</span><br><span class="line">git submodule update --init --recursive <span class="comment"># 更新映射关系并递归下载模块</span></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/09/17/yJh84dN6IPrOjAz.png" alt="image-20240917150517478"></p><p>使用<code>git submodule add</code>之后会创建<strong>.gitmodules</strong>文件并写入相关信息,包括子模块path和url,其中path是安装路径,因此我们可以借助修改path,使得<code>git update --init</code>安装子模块时安装到3rd_party或vendor目录便于管理,比如</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[submodule <span class="string">&quot;glfw&quot;</span>]</span><br><span class="line">path = third_party/glfw</span><br><span class="line">url = https:<span class="regexp">//gi</span>thub.com<span class="regexp">/glfw/g</span>lfw.git</span><br></pre></td></tr></table></figure><p>修改.gitmodules 文件中对应模块的名字或者path,然后使用<code>git submodule sync</code>进行更新.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule sync --recursive</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>此外还会在<code>.git/config</code>和<code>.git/modules</code>中添加子模块信息</p><p><code>update</code>的作用是根据项目的配置信息,拉取更新子模块中的代码,也可以使用<code>git clone --recurse-submodules</code>直接下载子模块</p><p><strong>卸载子模块</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule deinit project-sub <span class="comment"># 在.gitmodules中对应的模块名 </span></span><br><span class="line">git rm project-sub <span class="comment"># 删除模块目录与.git/config,.git/modules信息</span></span><br></pre></td></tr></table></figure><p>总结来说,可以使用第三方管理工具,下载链接非常方便. 对于自己写的一些库或者没有cmake的项目可以使用vendor/3rd_party方式,放在一个单独目录,如果是源代码,添加源文件和头文件,生成库,cmake如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># glad</span></span><br><span class="line"><span class="keyword">set</span>(glad_SOURCE_DIR <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/glad&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB source</span><br><span class="line">  <span class="string">&quot;$&#123;glad_SOURCE_DIR&#125;/src/*.c&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_library</span>(glad <span class="variable">$&#123;source&#125;</span>)</span><br><span class="line"><span class="keyword">target_include_directories</span>(glad</span><br><span class="line">  PUBLIC <span class="string">&quot;$&#123;glad_SOURCE_DIR&#125;/include&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">set_target_properties</span>(glad PROPERTIES FOLDER <span class="string">&quot;third_party&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果是已经编译好的库,使用<code>add_library(xxx SHARED IMPORTED)</code>并设置库文件位置</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(glad SHARED IMPORTED)</span><br><span class="line"><span class="keyword">set_target_properties</span>(glad PROPERTIES IMPORTED_LOCATION <span class="string">&quot;/path/to/glad/library&quot;</span>)</span><br><span class="line"><span class="keyword">set_target_properties</span>(glad PROPERTIES IMPORTED_IMPLIB <span class="string">&quot;/path/to/glad/library&quot;</span>) <span class="comment"># 针对windows</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set_target_properties</span>(glad PROPERTIES FOLDER <span class="string">&quot;third_party&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>IMPORTED_IMPLIB:用于指定导入库的导入库文件（import library file）。在 Windows 上，通常用于 .lib 文件。这个属性通常用于静态链接的导入库</p></blockquote><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>vcpkg,conan的逻辑是使用一个文件声明项目信息和依赖,然后在cmake中添加toolchainfile用于下载对应的包,而CPM和FetchContent直接在cmake中声明需要添加的包.</p><p>优先使用第三方包管理工具,因为相比<code>FetchContent</code>提供更多功能,如果第三方库不是cmake项目,使用<code>git submodule</code>方式,下载到某个文件夹编译源代码、链接库</p><h2 id="项目打包、安装与分发"><a href="#项目打包、安装与分发" class="headerlink" title="项目打包、安装与分发"></a>项目打包、安装与分发</h2><h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><h4 id="安装target"><a href="#安装target" class="headerlink" title="安装target"></a>安装target</h4><p>具体来说install(TARGETS …)会安装生成的的东西,不会安装头文件或者项目中的json、txt等读取文件.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install(TARGETS &lt;target&gt;... [...])</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/09/18/mkgtxHpDOQMJfuh.png" alt="image-20240918153002484"></p><p>这里最需要注意的就是动态库不包括windows上的dll.</p><p>默认安装路径如下,安装目录在Unix上usr/local,Windows是C:/program files,前缀通过<code>cmake  --prefix</code>或<code>CMAKE_INSTALL_PREFIX</code>指定</p><p><img data-src="https://s2.loli.net/2024/09/18/15lWXcPTQeqg37F.png" alt="image-20240918160115134"></p><p>install(TARGETS…) 如果 包 含 EXPORT 参 数, 用 于 从 给 定 的 install(…) 目 标 创 建 一 个 导 出 名 称,可以使用此导出名称导出这些目标</p><h4 id="安装文件"><a href="#安装文件" class="headerlink" title="安装文件"></a>安装文件</h4><blockquote><p>安装的东西并不总是目标输出构件的一部分。它们可能是目标的运行时依赖项，例如图片、源文件、脚本和配置文件</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span> (</span><br><span class="line">DIRECTORY <span class="keyword">include</span>/</span><br><span class="line">DESTINATION <span class="string">&quot;$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>install(FILES…) 指令接受一个或多个文件作为参数，TYPE 和DESTINATION 用于确定指定文件的目标目录。TYPE 用于指示哪些文件将使用该文件类型的默认 路径作为安装目录</p><p><img data-src="https://s2.loli.net/2024/09/18/WBoifXtdSRDcejq.png" alt="image-20240918155717561"></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(FILES <span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/greeter_content&quot;</span></span><br><span class="line">DESTINATION <span class="string">&quot;$&#123;CMAKE_INSTALL_BINDIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">install</span>(PROGRAMS <span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/greeter.py&quot;</span></span><br><span class="line">DESTINATION <span class="string">&quot;$&#123;CMAKE_INSTALL_BINDIR&#125;&quot;</span> RENAME chapter4_greeter)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="安装目录"><a href="#安装目录" class="headerlink" title="安装目录"></a>安装目录</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(DIRECTORY dir1 dir2 dir3 TYPE LOCALSTATE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(DIRECTORY dir2 DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_</span></span><br><span class="line"><span class="variable">LOCALSTATEDIR&#125;</span> FILES_MATCHING PATTERN <span class="string">&quot;*.hpp&quot;</span></span><br><span class="line">EXCLUDE PATTERN <span class="string">&quot;*&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以指定匹配文件和排除文件模式.</p><h4 id="config-file"><a href="#config-file" class="headerlink" title="config-file"></a>config-file</h4><p>当别人安装了你的库,也要方便使用.为了让其他用户使用<code>find_package</code>找到我们的包,需要config-file.</p><p>包配置文件<code>Config.cmake</code>设置如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(GNUInstallDirs) <span class="comment"># 便于获取安装路径变量</span></span><br><span class="line"><span class="keyword">set</span>(FOO_INCLUDE_DIRS <span class="variable">$&#123;PREFIX&#125;</span>/<span class="keyword">include</span>/foo-<span class="number">1.2</span>)</span><br><span class="line"><span class="keyword">set</span>(FOO_LIBRARIES <span class="variable">$&#123;PREFIX&#125;</span>/lib/foo-<span class="number">1.2</span>/libfoo.a)</span><br></pre></td></tr></table></figure><p>搜索包时,find_package(…) 会查找 /cmake 目录,所以包配置文件放在/cmake中.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># top level cmake</span></span><br><span class="line"><span class="keyword">include</span>(GNUInstallDirs)</span><br><span class="line"><span class="keyword">set</span>(project_INSTALL_CMAKEDIR cmake CACHE PATH</span><br><span class="line"><span class="string">&quot;Installation directory for config-file package cmake files&quot;</span>) <span class="comment"># 于设置 config-file 打包配置文件的安装目录</span></span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(ch4_ex05_lib PUBLIC</span><br><span class="line">$&lt;BUILD_INTERFACE:<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>&gt;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_compile_features</span>(ch4_ex05_lib PUBLIC cxx_std_11)</span><br></pre></td></tr></table></figure><p>使用$<BUILD_INTERFACE>设置头文件目录,因为在安装时</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS ex05_lib</span><br><span class="line"><span class="keyword">EXPORT</span> cex05_lib_export</span><br><span class="line">INCLUDES DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">install</span> (</span><br><span class="line">DIRECTORY <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/</span><br><span class="line">DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用<code>install(EXPORT)</code>得到xxConfig.cmake文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> ex05_lib_export</span><br><span class="line"><span class="keyword">FILE</span> ex05_lib-config.cmake</span><br><span class="line">NAMESPACE ex05_lib::</span><br><span class="line">DESTINATION <span class="variable">$&#123;project_INSTALL_CMAKEDIR&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>要实现对 find_package(…) 的完全支持，还需要获取xxxConfig-version.cmake 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">include(CMakePackageConfigHelpers)</span><br><span class="line">write_basic_package_version_file(</span><br><span class="line"><span class="string">&quot;ex05_lib-config-version.cmake&quot;</span></span><br><span class="line"><span class="comment"># Package compatibility strategy. SameMajorVersion is</span></span><br><span class="line">essentially <span class="string">&#x27;semantic versioning&#x27;</span>.</span><br><span class="line">COMPATIBILITY SameMajorVersion <span class="comment"># 与主版本号相同即可</span></span><br><span class="line">)</span><br><span class="line">install(FILES</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/ex05_lib-config-version.</span></span><br><span class="line"><span class="string">cmake&quot;</span></span><br><span class="line">DESTINATION <span class="string">&quot;<span class="variable">$&#123;project_INSTALL_CMAKEDIR&#125;</span>&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake –S . -B ./build</span><br><span class="line">cmake --build ./build</span><br><span class="line">cmake --install ./build --prefix /3rdparty</span><br></pre></td></tr></table></figure><p>安装包并使用<code>find_package</code>使用包</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> PROJECT_IS_TOP_LEVEL)</span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;The chapter-4, ex05_consumer project is</span></span><br><span class="line"><span class="string">intended to be a standalone, top-level project. Do not</span></span><br><span class="line"><span class="string">include this directory.&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">find_package</span>(ex05_lib <span class="number">1</span> CONFIG REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(ex05_consumer src/main.cpp)</span><br><span class="line"><span class="keyword">target_compile_features</span>(ex05_consumer PRIVATE cxx_std_11)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(ex05_consumer ex05_lib::ch4_ex05_</span><br><span class="line">lib)</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/09/18/Fg985AeDWyStn47.png" alt="image-20240918175420391"></p><h3 id="CPack"><a href="#CPack" class="headerlink" title="CPack"></a>CPack</h3><p><a href="https://cmake.org/cmake/help/book/mastering-cmake/chapter/Packaging With CPack.html">Packaging With CPack — Mastering CMake</a></p><p>cpack包含多种生成器生成包</p><p><img data-src="https://s2.loli.net/2024/09/18/xgPj8oBc7YtLTXC.png" alt="image-20240918161939375"></p><p>常用cpack变量,用于设置项目打包时的信息</p><p><img data-src="https://s2.loli.net/2024/09/18/vTwgth6iM8qGKWV.png" alt="image-20240918162023449"></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.21</span>)</span><br><span class="line"><span class="keyword">project</span>(</span><br><span class="line">ch4_ex06_pack</span><br><span class="line">VERSION <span class="number">1.0</span></span><br><span class="line">DESCRIPTION <span class="string">&quot;Chapter 4 Example 06, Packaging with CPack&quot;</span></span><br><span class="line">LANGUAGES CXX)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> PROJECT_IS_TOP_LEVEL)</span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;The chapter-4, ex06_pack project is</span></span><br><span class="line"><span class="string">intended to be a standalone, top-level project.</span></span><br><span class="line"><span class="string">Do not include this directory.&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">add_subdirectory</span>(executable)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(library)</span><br><span class="line"><span class="keyword">set</span>(CPACK_PACKAGE_VENDOR <span class="string">&quot;CTT Authors&quot;</span>) <span class="comment"># 作者</span></span><br><span class="line"><span class="keyword">set</span>(CPACK_GENERATOR <span class="string">&quot;DEB;RPM;TBZ2&quot;</span>) <span class="comment"># 包管理器</span></span><br><span class="line"><span class="keyword">set</span>(CPACK_THREADS <span class="number">0</span>)</span><br><span class="line"><span class="keyword">set</span>(CPACK_DEBIAN_PACKAGE_MAINTAINER <span class="string">&quot;CTT Authors&quot;</span>)</span><br><span class="line"><span class="keyword">include</span>(CPack)</span><br></pre></td></tr></table></figure><p>CPACK<em>PACKAGE_NAME 和 CPACK_PACKAGE_VERSION</em>* 默认从顶层项目名称和版本中获取</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake –S . -B build/</span><br></pre></td></tr></table></figure><p>项目配置后,生成CpackConfig.cmake 和 CpackConfigSource.cmake文件到build/CPack*中,使用<code>cpack</code>得到最终包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake --build build/</span><br><span class="line">cpack --config build/CPackConfig.cmake -B build/</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/09/18/5VcBEb1fQwq7eDA.png" alt="image-20240918164647416"></p><blockquote><p>注意设置generator时,其中每个都需要符合条件. 比如nsis需要安装对应的软件,否则设置generator包括它时会直接报错</p></blockquote><h2 id="经常遗忘的指令"><a href="#经常遗忘的指令" class="headerlink" title="经常遗忘的指令"></a>经常遗忘的指令</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add_custom_target(Name <span class="comment">[ALL]</span> <span class="comment">[command1 <span class="comment">[args1...]</span>]</span></span><br><span class="line"><span class="comment">[COMMAND command2 <span class="comment">[args2...]</span> ...]</span></span><br><span class="line"><span class="comment">[DEPENDS depend depend depend ... ]</span></span><br><span class="line"><span class="comment">[BYPRODUCTS <span class="comment">[files...]</span>]</span></span><br><span class="line"><span class="comment">[WORKING_DIRECTORY dir]</span></span><br><span class="line"><span class="comment">[COMMENT comment]</span></span><br><span class="line"><span class="comment">[JOB_POOL job_pool]</span></span><br><span class="line"><span class="comment">[VERBATIM]</span> <span class="comment">[USES_TERMINAL]</span></span><br><span class="line"><span class="comment">[COMMAND_EXPAND_LISTS]</span></span><br><span class="line"><span class="comment">[SOURCES src1 <span class="comment">[src2...]</span>]</span>)</span><br></pre></td></tr></table></figure><p>add_custom_target 的核心是通过 COMMAND 选项传递的命令列表。虽然第一个命令可 以不带这个选项,但最好在 add_custom_target 中添加 COMMAND 选项。</p><p><strong>默认情况下,定制目标只在显式请求时执行,除非指定了 ALL 选项</strong>。</p><p>自定义目标总认为是过时的，因此总是运行指 定的命令，而不管是否会反复产生相同的结果。</p><p>使用 DEPENDS 关键字，可以使定制目标依赖于使用 add_custom_command 或其他目标定义的定制命令的文件和输出。</p><p>要使自定义目标依赖于另 一个目标，可以使用 add_dependencies。若使用自定义目标创建文件，可以在 BYPRODUCTS 选项下列出这些文件。</p><p>列出的文件都将使用 GENERATED 属性标记，CMake 使用该属性来确定构建是否过期，并找出需要清理的文件，但使用 add_custom_command 创建文件的任务可能更适 合。</p><p> 通常，命令在当前二进制目录中执行，该目录在 CMAKE_CURRENT_BINARY_DIRECTORY 缓存变量中。若需要修改，这可以<strong>通过 WORKING_DIRECTORY 选项来更改</strong>。该选项可以是绝对 路径，也可以是相对路径 (当前二进制目录的相对路径)。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_custom_command(TARGET &lt;target&gt;</span><br><span class="line">PRE_BUILD | PRE_LINK | POST_BUILD</span><br><span class="line">COMMAND command1 <span class="comment">[ARGS]</span> <span class="comment">[args1...]</span></span><br><span class="line"><span class="comment">[COMMAND command2 <span class="comment">[ARGS]</span> <span class="comment">[args2...]</span> ...]</span></span><br><span class="line"><span class="comment">[BYPRODUCTS <span class="comment">[files...]</span>]</span></span><br><span class="line"><span class="comment">[WORKING_DIRECTORY dir]</span></span><br><span class="line"><span class="comment">[COMMENT comment]</span></span><br><span class="line"><span class="comment">[VERBATIM]</span> <span class="comment">[USES_TERMINAL]</span></span><br><span class="line"><span class="comment">[COMMAND_EXPAND_LISTS]</span>)</span><br></pre></td></tr></table></figure><p>可以在以下时段将命令连接到构建中: </p><p>• PRE_BUILD: 在 Visual Studio 中，此命令在执行其他构建步骤之前执行。当使用其他生成器 时，会在 PRE_LINK 命令之前运行。</p><p> • PRE_LINK: 此命令将在编译源代码之后运行，在可执行文件或存档工具链接到静态库之前运行。</p><p> • <strong>POS_BUILD: 这将在执行所有其他构建规则后运行该命令</strong>。 执行自定义步骤最常见的方法是使用 POST_BUILD; 其他两个选项很少使用，要么是因为支持 有限，要么是因为它们既不能影响链接，也不能影响构建。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_parse_arguments</span>(&lt;prefix&gt; &lt;options&gt; &lt;one_value_keywords&gt;</span><br><span class="line">                      &lt;multi_value_keywords&gt; &lt;args&gt;...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_parse_arguments</span>(PARSE_ARGV &lt;N&gt; &lt;prefix&gt; &lt;options&gt;</span><br><span class="line">                      &lt;one_value_keywords&gt; &lt;multi_value_keywords&gt;)</span><br></pre></td></tr></table></figure><p><a href="https://cmake.org/cmake/help/latest/command/cmake_parse_arguments.html">cmake_parse_arguments — CMake 3.30.3 Documentation</a></p><h3 id="Great-resoureces-for-learning"><a href="#Great-resoureces-for-learning" class="headerlink" title="Great resoureces for learning"></a>Great resoureces for learning</h3><ol><li><a href="https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1">Effective Modern CMake (github.com)</a></li><li><a href="https://github.com/franneck94/CppProjectTemplate">franneck94/CppProjectTemplate: C++ project template with unit-tests, documentation, ci-testing and workflows. (github.com)</a></li></ol><p>书籍推荐<a href="https://book.douban.com/subject/35793146/">CMake Best Practices (豆瓣) (douban.com)</a>和<a href="https://book.douban.com/subject/34936765/">Professional CMake (豆瓣) (douban.com)</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近常常使用cmake构建c++项目有感,从创建项目到打包发布总结一下需要注意的事情.&lt;br&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://www.sekyoro.top/tags/cpp/"/>
    
    <category term="cmake" scheme="https://www.sekyoro.top/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>build a mini project starter in Rust</title>
    <link href="https://www.sekyoro.top/2024/09/15/build-a-mini-project-starter-in-Rust/"/>
    <id>https://www.sekyoro.top/2024/09/15/build-a-mini-project-starter-in-Rust/</id>
    <published>2024-09-15T01:45:08.000Z</published>
    <updated>2024-09-15T15:52:27.127Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近沉迷写c++以及cmake构建项目(不是吧,这也能沉迷?),主要关注的是一个项目的架构,以及一些辅助工具,比如生成文档,代码检查(sanitize)等,打算使用Rust写一个非常简单的c++项目的generator<br><span id="more"></span></p><p>项目源码:<a href="https://github.com/drowning-in-codes/build-my-own-x/tree/main/mini-project-starter">build-my-own-x/mini-project-starter at main · drowning-in-codes/build-my-own-x (github.com)</a></p><p>crates.io:<a href="https://crates.io/crates/mini-project-starter">mini-project-starter - crates.io: Rust Package Registry</a></p><p><img data-src="https://s2.loli.net/2024/09/15/39hKmTFezL5vJM1.png" alt="image-20240915235220102"></p><h2 id="常见的c-项目组织方式"><a href="#常见的c-项目组织方式" class="headerlink" title="常见的c++项目组织方式"></a>常见的c++项目组织方式</h2><p>项目组织方式因人而异,但一些基本点还是相同的,比如参考Rust一些模块组织方式,由于c++代码需要有头文件(不知道c++26之后的未来会不会尽可能地使用模块替代头文件这种组织方式)</p><p>由于在其他语言中,一个模块基本上就是单独一个文件,而c++中是cpp源文件和对应的头文件,这个模块最好(或者说必须)放在对应名字的目录下,比如我的项目下写了一个logger模块,它一种组织方式如下,src目录下放置需要的库,app目录下放可执行程序或者最后生成的库.相当于在src目录下放置多个模块目录,每个目录中放源文件和头文件</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> root_dir\</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> src\</span></span><br><span class="line"><span class="ruby"></span>       -<span class="ruby"> logger\</span></span><br><span class="line"><span class="ruby"></span>         -<span class="ruby"> logger.cpp</span></span><br><span class="line"><span class="ruby"></span>         -<span class="ruby"> logger.hpp</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> <span class="keyword">include</span>\  (optional)</span></span><br><span class="line"><span class="ruby"></span>       -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> app\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> main.cpp</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> <span class="keyword">include</span>\</span></span><br><span class="line"><span class="ruby"></span>          -<span class="ruby"> main.hpp (optional)</span></span><br></pre></td></tr></table></figure><p>或者稍微改改,将模块的头文件放在include中,也就是头文件和源文件不放在同一个目录</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> root_dir\</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> src\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> logger.cpp</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> <span class="keyword">include</span>\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> logger\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> logger.hpp</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> app\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> main.cpp</span></span><br></pre></td></tr></table></figure><p>此外还有一种,将所有cpp文件都放在src中,头文件放在include中,差异就是它的源文件是放在一起的,没有放在一个所谓模块目录下.</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> root_dir\</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> src\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> logger.cpp</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> main.cpp</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> <span class="keyword">include</span>\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> main.hpp</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> logger\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> logger.hpp</span></span><br></pre></td></tr></table></figure><p>上面几种方式其实都行,我们看看rust是怎么组织的,由于没有头文件,在src目录下有main.rs,而garden.rs是模块,garden目录下的vegetables.rs是模块的子模块.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">backyard</span><br><span class="line">├── Cargo<span class="selector-class">.lock</span></span><br><span class="line">├── Cargo<span class="selector-class">.toml</span></span><br><span class="line">└── <span class="attribute">src</span></span><br><span class="line">    ├── garden</span><br><span class="line">    │   └── vegetables<span class="selector-class">.rs</span></span><br><span class="line">    ├── garden<span class="selector-class">.rs</span></span><br><span class="line">    └── <span class="selector-tag">main</span>.rs</span><br></pre></td></tr></table></figure><p>上面组织方式的核心差别,是针对头文件,要么在include目录下按照模块名分几个目录,而不是将头文件放在一起,要么在src目录下分多个需要的库目录,每个目录包括源文件和头文件.</p><h2 id="mini-project-starter"><a href="#mini-project-starter" class="headerlink" title="mini-project-starter"></a>mini-project-starter</h2><h3 id="命令行解析"><a href="#命令行解析" class="headerlink" title="命令行解析"></a>命令行解析</h3><p>使用<code>Clap</code>库解析参数，</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mini-project-starter new -p &lt;DIR&gt; <span class="comment"># 在一个目录下创建项目</span></span><br><span class="line">mini-project-starter init <span class="comment"># 在当前目录下初始化项目</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> utils;</span><br><span class="line"><span class="keyword">use</span> clap::&#123;command, Arg, Command&#125;;</span><br><span class="line"><span class="keyword">use</span> utils::&#123;init_project, new_project&#125;;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> starter_config = command!()</span><br><span class="line">        .propagate_version(<span class="literal">true</span>)</span><br><span class="line">        .subcommand_required(<span class="literal">true</span>)</span><br><span class="line">        .arg_required_else_help(<span class="literal">true</span>)</span><br><span class="line">        .subcommand(</span><br><span class="line">            Command::new(<span class="string">&quot;new&quot;</span>)</span><br><span class="line">                .about(<span class="string">&quot;Create a new project in the specified directory&quot;</span>)</span><br><span class="line">                .arg(</span><br><span class="line">                    Arg::new(<span class="string">&quot;project_root_dir&quot;</span>)</span><br><span class="line">                        .short(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">                        .long(<span class="string">&quot;project_root_dir&quot;</span>)</span><br><span class="line">                        .value_name(<span class="string">&quot;DIR&quot;</span>)</span><br><span class="line">                        .value_parser(clap::builder::NonEmptyStringValueParser::new())</span><br><span class="line">                        .help(<span class="string">&quot;The root dir of the project&quot;</span>)</span><br><span class="line">                        .required(<span class="literal">true</span>),</span><br><span class="line">                ),</span><br><span class="line">        )</span><br><span class="line">        .subcommand(Command::new(<span class="string">&quot;init&quot;</span>).about(<span class="string">&quot;Init the project in the current directory&quot;</span>))</span><br><span class="line">        .get_matches();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> starter_config.subcommand() &#123;</span><br><span class="line">        <span class="literal">Some</span>((<span class="string">&quot;new&quot;</span>, sub_matches)) =&gt; &#123;</span><br><span class="line">            new_project(sub_matches.get_one::&lt;<span class="built_in">String</span>&gt;(<span class="string">&quot;project_root_dir&quot;</span>).unwrap())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">Some</span>((<span class="string">&quot;init&quot;</span>, _)) =&gt; init_project(),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Please specify a subcommand&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后让用户输入项目的一些信息,这些信息可以替换后面<code>CMakeLists.txt</code>中的项目信息</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> root_dir_name = default_root_dir_name</span><br><span class="line">                .file_name()</span><br><span class="line">                .unwrap()</span><br><span class="line">                .to_str()</span><br><span class="line">                .unwrap();</span><br><span class="line">    <span class="keyword">let</span> project_name = Input::&lt;<span class="built_in">String</span>&gt;::new()</span><br><span class="line">        .with_prompt(<span class="string">r&quot;Enter your project name.(project root folder name if leave blank)&quot;</span>)</span><br><span class="line">        .with_initial_text(root_dir_name.to_string())</span><br><span class="line">        .interact_text()</span><br><span class="line">        .unwrap_or(root_dir_name.to_string());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 项目版本</span></span><br><span class="line">    <span class="keyword">let</span> project_version = Input::&lt;<span class="built_in">String</span>&gt;::new()</span><br><span class="line">        .with_prompt(<span class="string">&quot;Enter your project version.(default: 0.1.0)&quot;</span>)</span><br><span class="line">        .with_initial_text(<span class="string">&quot;0.1.0&quot;</span>.to_string())</span><br><span class="line">        .interact_text()</span><br><span class="line">        .unwrap_or(<span class="string">&quot;0.1.0&quot;</span>.to_string());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 项目描述</span></span><br><span class="line">    <span class="keyword">let</span> project_desc = Input::&lt;<span class="built_in">String</span>&gt;::new()</span><br><span class="line">        .with_prompt(<span class="string">&quot;Enter your project description.(default: A new project)&quot;</span>)</span><br><span class="line">        .with_initial_text(<span class="string">&quot;A new project&quot;</span>.to_string())</span><br><span class="line">        .interact_text()</span><br><span class="line">        .unwrap_or(<span class="string">&quot;A new project&quot;</span>.to_string());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择项目类型</span></span><br><span class="line">    <span class="keyword">let</span> project_types = <span class="built_in">vec!</span>[ ProjectType::Cpp];</span><br><span class="line">    <span class="keyword">let</span> project_type_selection = Select::with_theme(&amp;theme)</span><br><span class="line">        .with_prompt(<span class="string">&quot;choose the peoject type&quot;</span>)</span><br><span class="line">        .items(&amp;project_types)</span><br><span class="line">        .interact()</span><br><span class="line">        .unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择生成目标类型</span></span><br><span class="line">    <span class="keyword">let</span> target_type = <span class="built_in">vec!</span>[</span><br><span class="line">        TargetType::Executable,</span><br><span class="line">        TargetType::StaticLibrary,</span><br><span class="line">        TargetType::DynamicLibrary,</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">let</span> target_type_selection = Select::with_theme(&amp;theme)</span><br><span class="line">        .with_prompt(<span class="string">&quot;choose the target type&quot;</span>)</span><br><span class="line">        .items(&amp;target_type)</span><br><span class="line">        .interact()</span><br><span class="line">        .unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择包管理器</span></span><br><span class="line">    <span class="keyword">let</span> package_manager_list = <span class="built_in">vec!</span>[PackageManager::VCPKG, PackageManager::CPM,PackageManager::<span class="literal">None</span>];</span><br><span class="line">    <span class="keyword">let</span> package_manager_selection = Select::with_theme(&amp;theme)</span><br><span class="line">        .with_prompt(<span class="string">&quot;choose the package manager &quot;</span>)</span><br><span class="line">        .items(&amp;package_manager_list)</span><br><span class="line">        .interact()</span><br><span class="line">        .unwrap();</span><br><span class="line">    <span class="keyword">let</span> package_manager = package_manager_list[package_manager_selection].clone();</span><br></pre></td></tr></table></figure><p>创建一个项目需要拷贝一些目录和文件,如果是目录注意不要重复创建,而文件可以直接truncate</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建src目录与main.cpp</span></span><br><span class="line"> <span class="keyword">match</span> fs::create_dir_all(root_dir.join(project_name).join(<span class="string">&quot;src&quot;</span>)) &#123;</span><br><span class="line">         <span class="literal">Ok</span>(_)=&gt;&#123;&#125;,</span><br><span class="line">         <span class="literal">Err</span>(e)=&gt;&#123;</span><br><span class="line">             eprintln!(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>,e.kind(),e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">         <span class="keyword">let</span> src_file = File::create(root_dir.join(project_name).join(<span class="string">&quot;src/main.cpp&quot;</span>)).unwrap();</span><br><span class="line">         <span class="keyword">match</span> fs::read_to_string(env::current_dir().unwrap().join(<span class="string">&quot;templates/main.cpp&quot;</span>)) &#123;</span><br><span class="line">             <span class="literal">Ok</span>(contents) =&gt; <span class="built_in">write!</span>(&amp;src_file, <span class="string">&quot;&#123;&#125;&quot;</span>, contents).unwrap(),</span><br><span class="line">             <span class="literal">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;Error reading file: &#123;&#125;&quot;</span>, e),</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>在<code>CMakeLists.txt</code>中,添加如下内容</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.29</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER <span class="string">&quot;C:/Program Files/LLVM/bin/clang.exe&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER <span class="string">&quot;C:/Program Files/LLVM/bin/clang++.exe&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="comment"># include($&#123;CMAKE_SOURCE_DIR&#125;/cmake/sanitier.cmake)</span></span><br><span class="line"><span class="keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cmake&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(sanitizer)</span><br><span class="line"><span class="keyword">include</span>(copy_target)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(@PROJECT_NAME@ LANGUAGES C CXX VERSION @PROJECT_VERSION@ PROJECT_DESCRIPTION <span class="string">&quot;@PROJECT_DESCRIPTION@&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">FILE</span>(GLOB_RECURSE LIB_SOURCE  src/*.cpp src/*.c)</span><br><span class="line"><span class="keyword">FILE</span>(GLOB_RECURSE HEADER  <span class="keyword">include</span>/*.h <span class="keyword">include</span>/*.hpp)</span><br><span class="line"><span class="keyword">source_group</span>(headers FILES <span class="variable">$&#123;HEADER&#125;</span>) </span><br><span class="line"><span class="keyword">add_library</span>(@PROJECT_NAME@ STATIC <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(@PROJECT_NAME@ PRIVATE <span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(ENABLE_SANITIZER <span class="string">&quot;Enable sanitizer&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">if</span>(ENABLE_SANITIZER)</span><br><span class="line">  add_sanitier(@PROJECT_NAME@)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(ENABLE_COPY_TARGET <span class="string">&quot;Enable copy target&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">if</span>(ENABLE_COPY_TARGET)</span><br><span class="line">  copy_target(@PROJECT_NAME@)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>针对包管理器,我设置了可以使用vcpkg或者cpm,如果是cpm可以在网上下载对应cmake脚本,如果是vcpkg,在<code>CMakePresets.json</code>中添加对应toolchainfile.</p><p>最后还有测试目录,cmake脚本,scripts辅助脚本,docs文档等等,如下</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> .gitignore</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> cmake</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> FindSomeLib.cmake</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> something_else.cmake</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> README.md</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> LICENCE.md</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> tests</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> CMakeLists.txt</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> testlib.cpp</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> docs</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> CMakeLists.txt</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> extern</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> googletest</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> scripts</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> helper.py</span></span><br></pre></td></tr></table></figure><h3 id="还不错的视频参考"><a href="#还不错的视频参考" class="headerlink" title="还不错的视频参考"></a>还不错的视频参考</h3><ol><li><a href="https://www.bilibili.com/video/BV1Z44y1c7UX">CMake, Tests and Tooling for C/C++ Projects</a></li><li><a href="https://www.bilibili.com/video/BV1Tr4y1Z762">Update to Modern C++</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近沉迷写c++以及cmake构建项目(不是吧,这也能沉迷?),主要关注的是一个项目的架构,以及一些辅助工具,比如生成文档,代码检查(sanitize)等,打算使用Rust写一个非常简单的c++项目的generator&lt;br&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://www.sekyoro.top/tags/Rust/"/>
    
    <category term="Cpp" scheme="https://www.sekyoro.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>xmake:另一个C++现代构建系统</title>
    <link href="https://www.sekyoro.top/2024/09/11/C-%E7%8E%B0%E4%BB%A3%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>https://www.sekyoro.top/2024/09/11/C-%E7%8E%B0%E4%BB%A3%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/</id>
    <published>2024-09-11T09:22:10.000Z</published>
    <updated>2024-09-14T10:42:43.084Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>主要起因是我在逛Reddit帖子时,看到关于一些c++构建系统的评价. cmake似乎有些过于复杂,它与vcpkg,conan的包管理之间的”融合”可能在有些时候也显得麻烦. 一些人尝试了我没见过的选项,</p><p>所以这里主要试试除了cmake之外的构建工具(这些选项中个人目前看好xmake),除了<a href="https://xmake.io/#/getting_started">xmake</a>之外,还有<a href="https://mesonbuild.com/">The Meson Build system</a>，<a href="https://spack.io/about/">About Spack - Spack</a>，<a href="https://bazel.google.cn/versions/7.3.0/about/intro?hl=zh-cn">Bazel 简介 (google.cn)</a>等等.我选择xmake主要原因是其自带的包管理和方便的写法<br><span id="more"></span></p><p>在进一步介绍xmake之前,有必要区分构建工具和包管理工具.c++目前常用的包管理工具有vcpkg,cpm以及conan,它们都有自己的registries,类似于node的npm,cargo的crates,python的pip registries,java的maven仓库. 都是社区或官方维护的库下载点,一般来允许用户注册后上传自己的包(不过考虑到c++生态是一堆轮子哥,用第三方库的人可能没有python,js一半多).</p><h2 id="纯纯FetchContent"><a href="#纯纯FetchContent" class="headerlink" title="纯纯FetchContent"></a>纯纯FetchContent</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## from https://cmakebyexample.dev/use-library-fetchcontent/</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.28</span>)</span><br><span class="line"><span class="keyword">project</span>(my-<span class="keyword">project</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(</span><br><span class="line">  cpr</span><br><span class="line">  GIT_REPOSITORY https://github.com/libcpr/cpr.git</span><br><span class="line">  <span class="comment"># https://github.com/libcpr/cpr/releases</span></span><br><span class="line">  GIT_TAG <span class="number">1.10</span>.<span class="number">4</span>)</span><br><span class="line">FetchContent_MakeAvailable(cpr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(my-app main.cpp)</span><br><span class="line"><span class="keyword">target_compile_features</span>(my-app PUBLIC cxx_std_20)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(my-app PRIVATE cpr::cpr)</span><br></pre></td></tr></table></figure><p>利用cmake内置功能,下载相应库.它需要从源代码构建curl.</p><blockquote><p>FetchContent 可让您直接在 CMake 项目中包含外部项目，从而更轻松地处理依赖关系，而无需用户单独下载和构建，或依赖系统级软件包管理器。它通过自动处理下载、构建和配置这些依赖项等任务，简化了将外部代码引入项目的过程。</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line"></span><br><span class="line">FetchContent_Declare(</span><br><span class="line">    my_dependency</span><br><span class="line">    GIT_REPOSITORY https://github.com/example/my_dependency.git</span><br><span class="line">    GIT_TAG v1.<span class="number">0.0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">FetchContent_MakeAvailable(my_dependency)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now you can use the components of &#x27;my_dependency&#x27; in your project</span></span><br></pre></td></tr></table></figure><h2 id="vcpkg"><a href="#vcpkg" class="headerlink" title="vcpkg"></a>vcpkg</h2><p>包仓库<a href="https://vcpkg.io/en/packages">Browse public vcpkg packages</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir myModule &amp;&amp; <span class="built_in">cd</span> myModule</span><br><span class="line">vcpkg --new application <span class="comment"># 创建应用</span></span><br></pre></td></tr></table></figure><p>在目录下生成了两个文件,<code>vcpkg.json</code>和<code>vcpkg-confuguration.json</code>分别用于存依赖信息和仓库信息.初始前者为空,后者</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;default-registry&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;git&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;baseline&quot;</span>: <span class="string">&quot;9760ce6194ef51aa4faf77b6321e1280daa4545c&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;repository&quot;</span>: <span class="string">&quot;https://github.com/microsoft/vcpkg&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;registries&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;artifact&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;https://github.com/microsoft/vcpkg-ce-catalog/archive/refs/heads/main.zip&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;microsoft&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认的 <code>vcpkg-configuration.json</code> 文件引入了基线约束，指定了项目应使用的依赖项的最小版本,将 <code>vcpkg-configuration.json</code> 添加到代码控制中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg add port fmt</span><br></pre></td></tr></table></figure><p>添加依赖信息,这里并没有下载包,所以直接引入头文件会报错的</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911180835085.png" alt="image-20240911180835085"></p><p>使用下面指令下载<code>vcpkg.json</code>中的包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install</span><br></pre></td></tr></table></figure><p>还会贴心提示在cmake中如何使用</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911181040866.png" alt="image-20240911181040866"></p><p>vcpkg官方推荐使用<code>CMakePresets.json</code>配置进行构建</p><blockquote><p>使用预设，项目的顶层目录必须包含名为 CMakePresets.json 或 CMakeUserPresets.json 的文 件。若两个文件都存在，将先解析 CMakePresets.json，再解析 CMakeUserPresets.json。这两个文件 有相同的格式，但使用方式略有不同</p></blockquote><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911181547753.png" alt="image-20240911181547753"></p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911181640286.png" alt="image-20240911181640286"></p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cmake</span> <span class="built_in">--listpresets</span> <span class="comment"># 列出写的预设</span></span><br><span class="line"><span class="string">cmake</span> <span class="built_in">--preset=name</span> <span class="comment">#选择某个预设</span></span><br></pre></td></tr></table></figure><p>其要求写入缓存变量<code>CMAKE_TOOLCHAIN_FILE</code>就是本机安装的<code>vcpkg.cmake</code>,</p><p>如果你设置了<code>VCPKG_ROOT</code>环境变量,可以使用”$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake”</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">&quot;configurePresets&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">       <span class="attr">&quot;displayname&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;generator&quot;</span>: <span class="string">&quot;Ninja&quot;</span>, # 构建工具</span><br><span class="line">      <span class="attr">&quot;binaryDir&quot;</span>: <span class="string">&quot;$&#123;sourceDir&#125;/build&quot;</span>, # 构建输出目录</span><br><span class="line">      <span class="attr">&quot;cacheVariables&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;CMAKE_TOOLCHAIN_FILE&quot;</span>: <span class="string">&quot;&lt;VCPKG_ROOT&gt;/scripts/buildsystems/vcpkg.cmake&quot;</span> #设置vcpkg工具链</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>version 字段指定要使用的 JSON 模式。版本 1 是 CMake 3.19 的第一个版本，只支持 configurePresets。版本 2 增加了 buildPresets 和 testPresets，CMake 3.20 开始支持; 版本 3 增加了 更多选项，CMake 3.21 开始支持。 可选的 cmakeMinimumRequired 字段可以用来定义构建此项目所需的 CMake 的最小版本。由于 最低要求通常也在 CMakeLists.txt 文件中说明，这通常会省略。 这三个列表:configurePresets、buildPresets 和 testPresets，每个列表都包含了用于配置、构建和 测试项目的配置。构建和测试的预置要求至少有一个配置预置，将在本节后面看到。 vendor 字段包含特定于供应商或 IDE 信息的可选映射。CMake 不解释该字段的内容</p><p>然后写上cmake文件,因为先使用preset会执行</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.23</span>)</span><br><span class="line"><span class="keyword">project</span>(HelloWorld)</span><br><span class="line"><span class="keyword">find_package</span>(fmt CONFIG REQUIRED) <span class="comment">#重点 find_package找包</span></span><br><span class="line"><span class="keyword">add_executable</span>(HelloWorld main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(HelloWorld PRIVATE fmt::fmt) <span class="comment">#进行链接</span></span><br></pre></td></tr></table></figure><p>执行<code>cmake --preset=name</code>会进行构建,如果没有安装相应库,也会安装.所以上面的<code>vcpkg install</code>就没必要执行了.</p><p>我在使用时遇到了找不到实现的问题,这貌似需要设置vcpkg triplet,网上有一些triplets模板,简单来说需要设置一系列vcpkg变量</p><ul><li><a href="https://stackoverflow.com/questions/74422058/how-to-use-vcpkg-with-clang-on-linux">How to use vcpkg with clang on linux? - Stack Overflow</a> 创建的自己的triplets<a href="https://learn.microsoft.com/zh-cn/vcpkg/users/examples/overlay-triplets-linux-dynamic">使用覆盖三联密码 | Microsoft Learn</a></li><li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/triplets.md">vcpkg/docs/users/triplets.md at master · microsoft/vcpkg (github.com)</a></li><li><a href="https://learn.microsoft.com/zh-cn/vcpkg/concepts/triplets">三元组 | Microsoft Learn</a>在windows默认的就是msvc的,难怪编译不过,我使用的时mingw…</li><li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/triplets.md">vcpkg/docs/users/triplets.md at master · microsoft/vcpkg (github.com)</a></li><li><a href="https://stackoverflow.com/questions/78962135/cmake-add-library-with-set-property-can-not-found-fmt-dll-on-windows/78962177?noredirect=1#comment139223613_78962177">c++ - cmake add_library with set_property can not found fmt dll on windows - Stack Overflow</a> 在windows上编译后将动态库拷贝一份到可执行程序同一个目录.<code>exe文件运行必须依赖同一目录(或者环境变量)下的dll</code></li></ul><p>一个简单的方法时设置<code>VCPKG_TARGET_TRIPLET</code>变量为”x64-mingw-dynamic”,表示使用mingw的动态库.或者使用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install fmt:x64-mingw-dynamic</span><br></pre></td></tr></table></figure><p>可以设置 <code>VCPKG_TARGET_TRIPLET</code>(需要下载和使用的库的架构)和<code>VCPKG_HOST_TRIPLET</code>(生成自己的库需要的构建架构)来设置target和host的架构,使用<code>VCPKG_OVERLAY_TRIPLETS</code>使用社区的.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg <span class="built_in">help</span> triplets </span><br></pre></td></tr></table></figure><p>查看官方和社区提供的triplets.</p><h3 id="Triplets"><a href="#Triplets" class="headerlink" title="Triplets"></a>Triplets</h3><p>triplets指定平台架构,并按照对应的架构去设置toolchain,默认是在vcpkg/triplets下找一个符合平台的,比如<code>vcpkg install xxx:abcd</code>,其中abcd就是一个triplets,设置好triplet后清单模式下就去下载相应的包</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912123855699.png" alt="image-20240912123855699" style="zoom:50%;" /></p><blockquote><p>更新:如果你只是想用clang++编译器,在<code>CMakeLists.txt</code>project指令之前指定即可</p></blockquote><p>用于交叉编译的,也就是在宿主机上编译不同平台架构的程序/库.</p><p>默认triplets</p><ul><li>Windows: <code>x64-windows</code></li><li>Linux: <code>x64-linux</code></li><li>OSX: <code>x64-osx</code></li></ul><p>可以分别指定target-triplet和host-triplet设置对应需要的工具链名称,会根据对应的名字去vcpkg/triplets找,或者使用overlay-triplets覆盖目录</p><p>以上的问题可以总结为</p><ol><li><p>使用clang需要配置triplets,可以使用社区的</p><p><a href="https://github.com/microsoft/vcpkg/issues/38042">How to compile vcpkg libraries using Clang? · Issue #38042 · microsoft/vcpkg (github.com)</a></p><p><a href="https://learn.microsoft.com/zh-cn/vcpkg/users/examples/overlay-triplets-linux-dynamic">使用覆盖三联密码 | Microsoft Learn</a></p><p><a href="https://github.com/Neumann-A/my-vcpkg-triplets/tree/master">Neumann-A/my-vcpkg-triplets: my collection of vcpkg triplets (github.com)</a></p></li></ol><p>我注意到社区中的triplets中很多使用了<code>VCPKG_CHAINLOAD_TOOLCHAIN_FILE</code>指定要使用的备用 CMake 工具链文件,如果设置将替代所有其他编译器检测逻辑.默认情况下工具链文件是从 <code>scripts/toolchains/</code> 适合平台选择的,使用<code>--overlay-triplets</code>选择一个目录进行覆盖<a href="https://learn.microsoft.com/zh-cn/vcpkg/users/examples/overlay-triplets-linux-dynamic">使用覆盖三联密码 | Microsoft Learn</a></p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911232109031.png" alt="image-20240911232109031"></p><blockquote><p>CMake 使用工具链实用程序来编译、link libraries和创建archives，并执行其他任务来进行构建。</p><p>可用的工具链由启用的语言决定。在正常编译中，<strong>CMake 会根据系统自省和默认值自动为主机编译确定工具链</strong>。在交叉编译情况下，可指定一个包含编译器和工具路径信息的工具链文件</p></blockquote><p>下面信息很重要,cmake在project()指令处查找可用的工具链,在<code>CMAKE_TOOLCHAIN_FILE</code>中处理vcpkg逻辑,其中将默认调用合适的vckpg/scripts/toolchains/中的toolchain</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911232412863.png" alt="image-20240911232412863"></p><ol><li>在windows上使用vcpkg安装得到的动态库如果想要自己放在一个统一的3rdparty目录,include目录和bin目录中再自己设置link</li></ol><p>需要放在可执行程序目录下,可以通过设置路径解决</p><p><a href="https://blog.csdn.net/Tracker647/article/details/142070768">CMake+MinGW+vcpkg项目引入三方库的两种方式（手动路径，vcpkg）-CSDN博客</a></p><p><a href="https://stackoverflow.com/questions/78962135/cmake-add-library-with-set-property-can-not-found-fmt-dll-on-windows/78962177?noredirect=1#comment139223613_78962177">c++ - cmake add_library with set_property can not found fmt dll on windows - Stack Overflow</a>注意需要设置链接的.lib和.dll库,通过<code>IMPORTED_IMPLIB</code>设置输出的.lib库</p><blockquote><ul><li><strong>IMPORTED_LOCATION</strong>：用于存储导入库的实际文件路径，通常是共享库或可执行文件的位置。</li><li><strong>IMPORTED_IMPLIB</strong>：用于存储导入库（导入库 .lib 文件）的路径，通常在 Windows 平台上使用。</li></ul></blockquote><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911230257291.png" alt="image-20240911230257291"></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(HelloWorld)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;CMAKE_SOURCE_DIR: $&#123;CMAKE_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(HelloWorld main.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(fmt SHARED IMPORTED)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> fmt PROPERTY IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="number">3</span>rdparty/fmt_x64-mingw-dynamic/bin/libfmt.dll)</span><br><span class="line"><span class="comment"># 改变导入库的.dll的位置</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(fmt INTERFACE <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="number">3</span>rdparty/fmt_x64-mingw-dynamic/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(HelloWorld fmt)</span><br><span class="line"><span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> HelloWorld POST_BUILD     <span class="comment">#-for copy libs in windows</span></span><br><span class="line">            <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy_if_different </span><br><span class="line">            <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="number">3</span>rdparty/fmt_x64-mingw-dynamic/bin/libfmt.dll </span><br><span class="line">            <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/build)</span><br><span class="line">            <span class="comment"># 将输出动态库放在build目录下</span></span><br></pre></td></tr></table></figure><p>需要添加设置<code>IMORTED_IMPLIB</code>路径</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(fmt SHARED IMPORTED)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> fmt PROPERTY</span><br><span class="line">  IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="number">3</span>rdparty/fmt_x64-mingw-dynamic/bin/libfmt.dll</span><br><span class="line">  IMORTED_IMPLIB <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="number">3</span>rdparty/fmt_x64-mingw-dynamic/lib/libfmt.lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>注意,使用vcpkg自动引入需要设置build_type,这样第三方库的动态库.dll就放在对应位置不用改了.</p></blockquote><p>使用vcpkg时注意,</p><ol><li>设置<code>CMAKE_TOOLCHAIN_FILE</code>要在project指令之前</li></ol><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911224541731.png" alt="image-20240911224541731"></p><ol><li>使用find_package(xxx <strong>CONFIG</strong> REQUIRED)</li><li>推荐使用preset</li><li>设置<code>CMAKE_EXPORT_COMPILE_COMMANDS</code>为ON让clangd检测头文件目录</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build -S /my/project --preset debug</span><br></pre></td></tr></table></figure><p>除了下载包之外,也有打包、发布等常用功能,已经满足常用需求了,cmake本身有cpack,但没有vcpkg提供的一些发布功能</p><p>要创建vcpkg包,首先创建manifest清单文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;libogg&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version-string&quot;</span>: <span class="string">&quot;1.3.3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Ogg is a multimedia container format, and the native file and stream format for the Xiph.org multimedia codecs.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目<code>vcpkg.json</code>中写上包内容,然后创建<code>portfile.cmake</code>,修改下面的配置</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vcpkg_from_github(</span><br><span class="line">    OUT_SOURCE_PATH SOURCE_PATH</span><br><span class="line">    REPO xiph/ogg</span><br><span class="line">    <span class="keyword">REF</span> v1.<span class="number">3.3</span></span><br><span class="line">    SHA512 <span class="number">0</span>bd6095d647530d4cb1f509eb5e99965a25cc3dd9b8125b93abd6b248255c890cf20710154bdec40568478eb5c4cde724abfb2eff1f3a04e63acef0fbbc9799b</span><br><span class="line">    HEAD_REF <span class="keyword">master</span></span><br><span class="line"><span class="title">)</span></span><br></pre></td></tr></table></figure><p>用于GitHub存储库路径的REPO,用于使用稳定标签/提交的REF，以及带有下载文件校验和的SHA512,别人使用时也使用vcpkg下载</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vcpkg_cmake_configure(SOURCE_PATH <span class="variable">$&#123;SOURCE_PATH&#125;</span>)</span><br><span class="line">vcpkg_cmake_install()</span><br><span class="line"><span class="keyword">file</span>(<span class="keyword">INSTALL</span> <span class="string">&quot;$&#123;SOURCE_PATH&#125;/COPYING&quot;</span> DESTINATION <span class="string">&quot;$&#123;CURRENT_PACKAGES_DIR&#125;/share/libogg&quot;</span> RENAME copyright)</span><br></pre></td></tr></table></figure><p>缺点就是微软文档实在烂,不是翻译的问题,英文原文的用词像是东拼西凑,感觉像是不停换人写出来的.</p><h2 id="CPM-cmake"><a href="#CPM-cmake" class="headerlink" title="CPM.cmake"></a>CPM.cmake</h2><p>轻量的包管理工具<a href="https://github.com/cpm-cmake/CPM.cmake">cpm-cmake/CPM.cmake: 📦 CMake’s missing package manager. A small CMake script for setup-free, cross-platform, reproducible dependency management. (github.com)</a>,基于cmake的FetchContent.</p><p>你只需要<code>include</code>提供的<code>cpm.cmake</code>文件即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p cmake</span><br><span class="line">wget -O cmake/CPM.cmake https://github.com/cpm-cmake/CPM.cmake/releases/latest/download/get_cpm.cmake</span><br></pre></td></tr></table></figure><p>此外也可以在cmake文件中下载</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># download CPM.cmake</span></span><br><span class="line"><span class="keyword">file</span>(</span><br><span class="line">  DOWNLOAD</span><br><span class="line">  https://github.com/cpm-cmake/CPM.cmake/releases/download/v0.<span class="number">38.3</span>/CPM.cmake</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/cmake/CPM.cmake</span><br><span class="line">  EXPECTED_HASH SHA256=cc155ce02e7945e7b8967ddfaff0b050e958a723ef7aad3766d368940cb15494</span><br><span class="line">)</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/cmake/CPM.cmake)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add dependencies here</span></span><br><span class="line">CPMAddPackage(...)</span><br><span class="line"></span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>然后就能直接使用了,</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CPMAddPackage(</span><br><span class="line">  NAME          <span class="comment"># The unique name of the dependency (should be the exported target&#x27;s name)</span></span><br><span class="line">  VERSION       <span class="comment"># The minimum version of the dependency (optional, defaults to 0)</span></span><br><span class="line">  PATCHES       <span class="comment"># Patch files to be applied sequentially using patch and PATCH_OPTIONS (optional)</span></span><br><span class="line">  OPTIONS       <span class="comment"># Configuration options passed to the dependency (optional)</span></span><br><span class="line">  DOWNLOAD_ONLY <span class="comment"># If set, the project is downloaded, but not configured (optional)</span></span><br><span class="line">  [...]         <span class="comment"># Origin parameters forwarded to FetchContent_Declare, see below</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>来源可以由 GIT_REPOSITORY 指定，但也支持其他来源，如一般的URL。如果没有明确指定 GIT_TAG，则默认为 v(VERSION)，这是 git 项目的通用约定。另一方面，如果没有明确指定 VERSION，在某些常见情况下，CPM 可以根据 git 标签自动识别版本。GIT_TAG 也可以设置为特定的提交或分支名称（如 master），但不建议这样做，因为这样的软件包只有在缓存被清除时才会被更新</p><p>如果将附加的可选参数 EXCLUDE_FROM_ALL 设为真,则默认情况下不会编译依赖关系中定义的任何目标.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A git package from a given uri with a version</span></span><br><span class="line">CPMAddPackage(<span class="string">&quot;uri@version&quot;</span>)</span><br><span class="line"><span class="comment"># A git package from a given uri with a git tag or commit hash</span></span><br><span class="line">CPMAddPackage(<span class="string">&quot;uri#tag&quot;</span>)</span><br><span class="line"><span class="comment"># A git package with both version and tag provided</span></span><br><span class="line">CPMAddPackage(<span class="string">&quot;uri@version#tag&quot;</span>)</span><br></pre></td></tr></table></figure><p>与findpackage差别,在 CMake 项目中添加库的通常方法是调用 find_package(\<PackageName>)，并与 \<PackageName>_LIBRARIES 变量中定义的库进行链接。这种方法虽然简单，<strong>但可能会导致无法预测的编译，因为它需要在系统中安装库，而且不清楚添加的是哪个版本的库</strong>。此外，<strong>交叉编译项目（如mobile项目）也很困难</strong>，因为需要针对每个目标架构手动重建依赖关系。</p><p>CPM.cmake 允许明确定义依赖关系，并从源代码构建依赖关系。请注意，该行为不同于 find_package，因为使用 CPM.cmake 添加软件包后，导出到父作用域的变量（如 \<PackageName>_LIBRARIES ）将不可见。如果需要，可以手动实现该行为<a href="https://github.com/cpm-cmake/CPM.cmake/issues/132">find_package and CPMFindPackage have different behaviors · Issue #132 · cpm-cmake/CPM.cmake (github.com)</a>。</p><p>与fech_content差别,CPM.cmake 会检查任何添加的依赖项的版本号，如果另一个依赖项需要更新版,则会发出警告。<br>离线编译： CPM.cmake 将覆盖 CMake 的下载和更新命令，如果本地有所有依赖项，则可在离线状态下配置新的构建。<br>自动浅层克隆：如果提供了版本标签（如 v2.2.0）并使用了 CPM_SOURCE_CACHE，CPM.cmake 将执行依赖关系的浅层克隆，这应比完全克隆更快，同时使用的存储空间更少。可重写：通过设置 CMake 标志，所有 CPMAddPackage 都可配置为使用 find_package，从而轻松集成到可能需要通过系统的软件包管理器进行本地版本控制的项目中。软件包锁定文件可实现更简便的跨依赖关系管理。<br>每次编译时，可使用 CMake CLI 参数覆盖依赖关系。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.28</span>)</span><br><span class="line"><span class="keyword">project</span>(my-<span class="keyword">project</span>)</span><br><span class="line"><span class="keyword">include</span>(cmake/CPM.cmake)</span><br><span class="line">CPMAddPackage(<span class="string">&quot;gh:fmtlib/fmt#10.2.0&quot;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(my-app main.cpp)</span><br><span class="line"><span class="keyword">target_compile_features</span>(my-app PRIVATE cxx_std_20)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(my-app fmt::fmt)</span><br></pre></td></tr></table></figure><p>上面的就使用<code>CPMAddPackage</code>添加了github上的fmtlib作者的fmt库,版本10.2.0</p><p>更多例子<a href="https://github.com/cpm-cmake/CPM.cmake/tree/master/examples">CPM.cmake/examples at master · cpm-cmake/CPM.cmake (github.com)</a></p><h2 id="CONAN"><a href="#CONAN" class="headerlink" title="CONAN"></a>CONAN</h2><p>这里做简单介绍,conan有仓库中心<a href="https://conan.io/center">Conan 2.0: C and C++ Open Source Package Manager</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install conan</span><br></pre></td></tr></table></figure><p>在项目中创建<code>conanfile.txt</code>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[requires]</span><br><span class="line">zlib/1.2.11</span><br><span class="line"></span><br><span class="line">[generators]</span><br><span class="line">CMakeDeps</span><br><span class="line">CMakeToolchain</span><br></pre></td></tr></table></figure><p>generators表示将使用CMakeDeps来生成关于Zlib库文件安装位置的信息，CMakeToolchain通过CMake工具链文件传递构建信息给CMake</p><p>此外还要创建conan profile,里面提供本机系统信息,</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conan profile detect --force</span><br></pre></td></tr></table></figure><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912092357159.png" alt="image-20240912092357159"></p><p>生成的信息可以修改,比如改编译器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conan install . --output-folder=build --build=missing</span><br></pre></td></tr></table></figure><p>安装库,在build目录下会生成preset和conan_toolchain.cmake文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(compressor C)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(ZLIB REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> src/main.c)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> ZLIB::ZLIB)</span><br></pre></td></tr></table></figure><p>再写个cmake文件,链接库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"><span class="comment"># assuming Visual Studio 15 2017 is your VS version and that it matches your default profile</span></span><br><span class="line">cmake .. -G <span class="string">&quot;Visual Studio 15 2017&quot;</span> -DCMAKE_TOOLCHAIN_FILE=<span class="string">&quot;conan_toolchain.cmake&quot;</span></span><br><span class="line">cmake --build . --config Release</span><br></pre></td></tr></table></figure><p>利用toolchain文件导入包. </p><p>上面讲的都是包管理工具(实际上脱离不了相应的构建工具),最大的问题就是两者分开了,但事实上完全可以放在一起,就像rust的cargo,<code>cargo build</code>,<code>cargo add</code></p><h2 id="xmake"><a href="#xmake" class="headerlink" title="xmake"></a>xmake</h2><p>xmake包括了自带的构建工具和包管理,也有项目创建工具的功能.xmake使用lua配置. xmake create创建项目,可以选择语言和模板(竟然还包括zig)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake create --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912100635482.png" alt="image-20240912100635482"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake create -P hello</span><br></pre></td></tr></table></figure><p>创建好后目录下有<code>xmake.lua</code>,使用xmake即可直接构建.<code>xmake run hello</code>运行程序,</p><p>在<code>xmake.lua</code>中常见配置就是创建可执行程序,库,添加头文件,设置语言标准等.</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;library&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;shared&quot;</span>) # 设置生成的类型</span><br><span class="line">    add_files(<span class="string">&quot;src/library/*.c&quot;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_deps(<span class="string">&quot;library&quot;</span>) # 添加依赖</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此外<code>add_headerfiles</code>添加头文件,<code>set_languages</code>设置语言版本.</p><p><code>xmake f -p</code>表示配置架构</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmake config -m debug xmake`</span><br><span class="line">xmake run -d hello</span><br></pre></td></tr></table></figure><p>可以进行debug</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake f -p [macosx|linux|iphoneos ..] -a [x86_64|i386|arm64 ..] -m [debug|release]</span><br></pre></td></tr></table></figure><p>使用xmake配置项目,注意编译器设置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake f -p linux --sdk=/user/toolsdk --cxx=armv7-linux-clang++</span><br></pre></td></tr></table></figure><p>我在windows上使用clang++工具,配置llvm工具链即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmake f -p cross --toolchain=llvm --sdk=<span class="string">&quot;C:\Program Files\LLVM&quot;</span> </span><br><span class="line">xmake</span><br><span class="line">xmake run hello</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake -v <span class="comment"># 验证工具链配置</span></span><br></pre></td></tr></table></figure><p>或者使用mingw</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake f -p mingw</span><br></pre></td></tr></table></figure><p>xmake官方有<code>`xmake-repo</code>仓库用于下载包,</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;tbox 1.6.*&quot;</span>, <span class="string">&quot;libpng ~1.16&quot;</span>, <span class="string">&quot;zlib&quot;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;tbox&quot;</span>, <span class="string">&quot;libpng&quot;</span>, <span class="string">&quot;zlib&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面配置从官方仓库中添加了依赖,执行<code>xmake</code>进行构建,会拉取相关的源包，然后自动编译安装，最后编译项目，并链接依赖包,此外还可以设置第三方依赖,从vcpkg,conan等地方</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;vcpkg::zlib&quot;</span>, <span class="string">&quot;vcpkg::pcre2&quot;</span>)</span><br></pre></td></tr></table></figure><p>此外还有独立的xrepo可用于下载包,可以指定平台,版本等,支持从vcpkg,conan中搜索下载.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xrepo install zlib tbox </span><br><span class="line">xrepo install <span class="string">&quot;zlib &gt;=1.2.0&quot;</span> </span><br><span class="line">xrepo install -p iphoneos -a arm64 zlib</span><br><span class="line">xrepo install vcpkg::zlib </span><br><span class="line">xrepo install conan::zlib/1.2.11 </span><br></pre></td></tr></table></figure><p>我写了下面<code>xmake.lua</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">add_requires(<span class="string">&quot;fmt&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">add_files(<span class="string">&quot;src/*.cpp&quot;</span>)</span><br><span class="line">add_packages(<span class="string">&quot;fmt::fmt&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果说vcpkg重点是选好triplet、toolchainfile,那么xmake也是配好toolchain</p><p>我直接配置<code>xmake f -p windows</code>使用msvc能成功build,如果要使用clang,配置好平台和工具链即可,相比vcpkg要好一些,vcpkg官方对clang/llvm貌似没有那么上心,官方triplet都没有,只能用社区的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmake f -p windows  --toolchain=clang-cl </span><br><span class="line">xmake f -p windows  --toolchain=clang <span class="comment">#或者</span></span><br></pre></td></tr></table></figure><p><code>xmake show -l toolchains</code>查看所有的toolchains</p><p>或者在<code>xmake.lua</code>中使用</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_plat(<span class="built_in">os</span>.host())</span><br><span class="line">set_arch(<span class="built_in">os</span>.arch())</span><br><span class="line">set_toochains(<span class="string">&quot;clang&quot;</span>)</span><br><span class="line"># 或者直接统一设置</span><br><span class="line">set_toochains(<span class="string">&quot;clang&quot;</span>,&#123;palt=<span class="built_in">os</span>.host(),arch=<span class="built_in">os</span>.arch()&#125;)</span><br></pre></td></tr></table></figure><p>目前还存在头文件无法识别的问题</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912121858364.png" alt="image-20240912121858364" style="zoom:50%;" /></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake project -k compile_commands</span><br></pre></td></tr></table></figure><p>参考作者给出的解决<a href="https://github.com/xmake-io/xmake-vscode/issues/40">支持为vscode-cpptools提供intellisense配置信息 · Issue #40 · xmake-io/xmake-vscode (github.com)</a>生成<code>compile_commands.json</code>包含编译器,工作目录和头文件目录等信息.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmake project -k vsxmake -m <span class="string">&quot;debug,release&quot;</span> <span class="comment"># New vsproj generator (Recommended)</span></span><br><span class="line">xmake project -k vs -m <span class="string">&quot;debug,release&quot;</span></span><br><span class="line">xmake project -k cmake</span><br><span class="line">xmake project -k ninja</span><br><span class="line">xmake project -k compile_commands</span><br></pre></td></tr></table></figure><p>因为目前就langd和vscode的intellisense能检测文件中头文件目录信息等,需要这个文件</p><p>使用下来的体验就是写起来比cmake用的轻松,文档写的案例也比较全面.但是因为没有深度使用,一些细节不知道怎样.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因为我已经在很多项目中使用了cmake,经验相对更多,xmake学习起来并不困难,搭配官方文档很容易搭建一个项目.</p><p>但目前还是推荐使用cmake+vcpkg/cpm.cmake方案,因为更成熟,解决方案更多.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要起因是我在逛Reddit帖子时,看到关于一些c++构建系统的评价. cmake似乎有些过于复杂,它与vcpkg,conan的包管理之间的”融合”可能在有些时候也显得麻烦. 一些人尝试了我没见过的选项,&lt;/p&gt;
&lt;p&gt;所以这里主要试试除了cmake之外的构建工具(这些选项中个人目前看好xmake),除了&lt;a href=&quot;https://xmake.io/#/getting_started&quot;&gt;xmake&lt;/a&gt;之外,还有&lt;a href=&quot;https://mesonbuild.com/&quot;&gt;The Meson Build system&lt;/a&gt;，&lt;a href=&quot;https://spack.io/about/&quot;&gt;About Spack - Spack&lt;/a&gt;，&lt;a href=&quot;https://bazel.google.cn/versions/7.3.0/about/intro?hl=zh-cn&quot;&gt;Bazel 简介 (google.cn)&lt;/a&gt;等等.我选择xmake主要原因是其自带的包管理和方便的写法&lt;br&gt;</summary>
    
    
    
    
    <category term="c++ build" scheme="https://www.sekyoro.top/tags/c-build/"/>
    
  </entry>
  
  <entry>
    <title>Dear-ImGUI:不太一样的GUI</title>
    <link href="https://www.sekyoro.top/2024/09/11/Dear-ImGUI-%E4%B8%8D%E5%A4%AA%E4%B8%80%E6%A0%B7%E7%9A%84GUI/"/>
    <id>https://www.sekyoro.top/2024/09/11/Dear-ImGUI-%E4%B8%8D%E5%A4%AA%E4%B8%80%E6%A0%B7%E7%9A%84GUI/</id>
    <published>2024-09-11T07:00:54.000Z</published>
    <updated>2024-10-14T15:58:47.775Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>之前介绍过Qt,作为c++界面(事实上不只是界面,Qt本身已经成了写C++的一种工具了)工具,采用的是创建控件然后绑定事件处理的逻辑,与winform,WPF等都是类似的,但是这里介绍一种不太一样的GUI库,其使用immediate mode,也就是在每一帧进行处理,没有保留状态维护. 在游戏界面开发中受到热捧.<br><span id="more"></span></p><p>这种立即模式可能受到一些游戏开发的喜爱,ImGui<a href="https://github.com/ocornut/imgui">ocornut/imgui: Dear ImGui: Bloat-free Graphical User interface for C++ with minimal dependencies (github.com)</a>直到最近还不停有commit,Unity也采用了类似模式构建控件<a href="https://docs.unity.cn/cn/2019.4/Manual/gui-Basics.html">IMGUI 基础知识 - Unity 手册</a>. 在Rust也有<a href="https://github.com/emilk/egui">emilk/egui: egui: an easy-to-use immediate mode GUI in Rust that runs on both web and native (github.com)</a>,Go也有<a href="https://gioui.org/">Gio UI</a>.</p><p>下面写个简单的ImGUI程序学习学习.</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>我们把GUI分成了retained mode和immediate mode</p><p><img data-src="https://learn.microsoft.com/en-us/windows/win32/learnwin32/images/graphics06.png" alt="a diagram that shows retained-mode graphics."></p><p>保留模式(retained mode) API 是声明式的。应用程序通过图形基元（如形状和线条）构建场景。图形库将场景模型存储在内存中。要绘制帧，图形库会将场景转换为一组绘图命令。在帧与帧之间，图形库会将场景保存在内存中。要更改渲染的内容，应用程序会发出更新场景的命令，例如添加或删除一个形状。然后图形库负责重新绘制场景。</p><p><img data-src="https://learn.microsoft.com/en-us/windows/win32/learnwin32/images/graphics07.png" alt="a diagram that shows immediate-mode graphics."></p><p>即时模式 API (immediate mode)是程序性的。每次绘制新帧时，应用程序都会直接发出绘制命令。图形库不会在帧与帧之间存储场景模型。相反，应用程序会跟踪场景</p><p>保留模式 API 使用起来可能更简单，因为 API 会为您完成更多工作，如初始化、状态维护和清理。另一方面，它们通常灵活性较差，因为 API 强加了自己的场景模型。此外，保留模式 API 对内存的要求可能更高，因为它需要提供通用场景模型。使用即时模式 API，您可以实现有针对性的优化。</p><p>此外注意到还有DirectUI的说法,区分win32窗体<a href="https://www.zhihu.com/question/20580684"> DirectUI与GUI框架有什么区别，如MFC，QT，wxWidgets的区别是什么？ - 知乎 (zhihu.com)</a></p><blockquote><p>系统窗口的消息路由是操作系统负责的，比如按钮上的消息就会被自动分发给按钮的窗口过程。而DirectUI这类框架创建的窗口的消息是由应用程序负责的路由的，无论你点击了窗口中哪个按钮，消息统统分发给单一的窗口过程，它再根据鼠标的坐标判决应该由哪个对象进一步处理消息</p></blockquote><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>imgui背后需要调用图形backend和窗体调用. 它提供了几种不同的头文件,包括win32(窗体)+direcx11/12(图形api),glfw+opengl,sdl+opengl,glfw+vulkan等等.</p><p>这里我使用glfw+opengl.</p><p>你可以在在对应的官方仓库下载源码或者预编译包链接使用,但是为了更方便地使用,可以直接使用包管理器vcpkg等下载然后再cmake中加上两句即可. vcpkg具体使用可以参考<a href="https://www.sekyoro.top/2024/09/11/C-现代构建系统/#more">xmake:另一个C++现代构建系统 | Sekyoro的博客小屋</a>.</p><p>简单来说就是</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir project &amp;&amp; <span class="built_in">cd</span> project</span><br><span class="line">vcpkg new --application</span><br><span class="line">vcpkg add port opengl</span><br><span class="line">cmake install <span class="comment"># 如果在cmakepresets中设置好了直接cmake --preset=&lt;preset_name&gt;即可</span></span><br><span class="line">cmake --build build</span><br></pre></td></tr></table></figure><p>然后在<code>main.cpp</code>添加相应代码,执行程序</p><p><img data-src="https://s2.loli.net/2024/09/14/IdSPbTwpMn5U1XC.png" alt="image-20240914172255349"></p><blockquote><p>很多时候一些c++程序员喜欢把源码下载到本地然后进行编译,得到的库统一放在vendor/3rd_party目录,但是利用现代工具(vcpkg,conan等)可以方便地进行交叉编译(在宿主机上通过不同工具链得到其他架构的库/可执行程序),何乐而不为呢?</p></blockquote><p>其与Qt等<code>高等</code>框架相比,直接使用图形api和系统或在系统之上封装的窗口管理生成窗口、进行绘图.</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">At</span> initialization:</span><br><span class="line">  <span class="keyword">call</span> ImGui::CreateContext()</span><br><span class="line">  <span class="keyword">call</span> ImGui_ImplXXXX_Init() for <span class="number">each</span> backend.</span><br><span class="line"></span><br><span class="line"><span class="meta">At</span> the beginning of your frame:</span><br><span class="line">  <span class="keyword">call</span> ImGui_ImplXXXX_NewFrame() for <span class="number">each</span> backend.</span><br><span class="line">  <span class="keyword">call</span> ImGui::NewFrame()</span><br><span class="line"></span><br><span class="line"><span class="meta">At</span> the end of your frame:</span><br><span class="line">  <span class="keyword">call</span> ImGui::Render()</span><br><span class="line">  <span class="keyword">call</span> ImGui_ImplXXXX_RenderDrawData() for your Renderer backend.</span><br><span class="line"></span><br><span class="line"><span class="meta">At</span> shutdown:</span><br><span class="line">  <span class="keyword">call</span> ImGui_ImplXXXX_Shutdown() for <span class="number">each</span> backend.</span><br><span class="line">  <span class="keyword">call</span> ImGui::DestroyContext()</span><br></pre></td></tr></table></figure><p>基本逻辑如上,我们需要在<code>while</code>循环中针对每帧做动作,比如下面代码表示如果窗口最小化等待10ms再进行,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class="line">    <span class="comment">// Poll and handle events (inputs, window resize, etc.)</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetWindowAttrib</span>(window, GLFW_ICONIFIED) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">ImGui_ImplGlfw_Sleep</span>(<span class="number">10</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些简单代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> clicked = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 按钮</span></span><br><span class="line">       <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Button&quot;</span>))</span><br><span class="line">           clicked++;</span><br><span class="line">       <span class="keyword">if</span> (clicked &amp; <span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">           ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Thanks for clicking me!&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 选择框</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">bool</span> check = <span class="literal">true</span>;</span><br><span class="line">       ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;checkbox&quot;</span>, &amp;check);</span><br><span class="line"><span class="comment">// 选择按钮</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line">       ImGui::<span class="built_in">RadioButton</span>(<span class="string">&quot;radio a&quot;</span>, &amp;e, <span class="number">0</span>); ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">       ImGui::<span class="built_in">RadioButton</span>(<span class="string">&quot;radio b&quot;</span>, &amp;e, <span class="number">1</span>); ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">       ImGui::<span class="built_in">RadioButton</span>(<span class="string">&quot;radio c&quot;</span>, &amp;e, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Color buttons, demonstrate using PushID() to add unique identifier in the ID stack, and changing style.</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">               ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">           ImGui::<span class="built_in">PushID</span>(i);</span><br><span class="line">           ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_Button, (ImVec4)ImColor::<span class="built_in">HSV</span>(i / <span class="number">7.0f</span>, <span class="number">0.6f</span>, <span class="number">0.6f</span>));</span><br><span class="line">           ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_ButtonHovered, (ImVec4)ImColor::<span class="built_in">HSV</span>(i / <span class="number">7.0f</span>, <span class="number">0.7f</span>, <span class="number">0.7f</span>));</span><br><span class="line">           ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_ButtonActive, (ImVec4)ImColor::<span class="built_in">HSV</span>(i / <span class="number">7.0f</span>, <span class="number">0.8f</span>, <span class="number">0.8f</span>));</span><br><span class="line">           ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Click&quot;</span>);</span><br><span class="line">           ImGui::<span class="built_in">PopStyleColor</span>(<span class="number">3</span>);</span><br><span class="line">           ImGui::<span class="built_in">PopID</span>();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Use AlignTextToFramePadding() to align text baseline to the baseline of framed widgets elements</span></span><br><span class="line">       <span class="comment">// (otherwise a Text+SameLine+Button sequence will have the text a little too high by default!)</span></span><br><span class="line">       <span class="comment">// See &#x27;Demo-&gt;Layout-&gt;Text Baseline Alignment&#x27; for details.</span></span><br><span class="line">       ImGui::<span class="built_in">AlignTextToFramePadding</span>();</span><br><span class="line">       ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Hold to repeat:&quot;</span>);</span><br><span class="line">       ImGui::<span class="built_in">SameLine</span>();</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://github.com/ocornut/imgui">ocornut/imgui: Dear ImGui: Bloat-free Graphical User interface for C++ with minimal dependencies (github.com)</a></p></li><li><p><a href="https://blog.codingnow.com/2020/07/game_ui.html">云风的 BLOG: 游戏 UI 模块的选择 (codingnow.com)</a></p><p>如果你不想使用Qt庞然大物,也不想使用提供内置功能太少的界面库,可以试试SFML<a href="https://www.sfml-dev.org/">SFML (sfml-dev.org)</a>.</p></li><li><p><a href="https://tulach.cc/writing-gui-apps-for-windows-is-painful/">Writing GUI apps for Windows is painful - Samuel Tulach</a>一篇介绍windows上桌面程序开发框架选择的文章,提到了winui3,qt以及使用其他技术栈链接.dll库,比如wpf等.事实上我已经多次谈论界面开发/桌面开发/移动端开发,注意一个事实,一些库不只是用于界面绘制的,除去界面绘制,一些基本工具库的提供往往也非常有必要.所以在windows下使用微软带来的生态是很好的(wpf,maui,winui3等),在移动端下使用compose也很舒服.还有Flutter也吃Dart的生态. 此外也有很多使用web的技术,比如electron,tauri,<a href="https://pywebview.flowrl.com/">pywebview (flowrl.com)</a></p><p>很多时候没有必要考虑跨平台的需求(那就做web).</p><p>(delphi和lazarus有谁用过?)<a href="https://www.zhihu.com/question/54905309">用 Lazarus 做 GUI 程序合适吗？ - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://pthom.github.io/imgui_manual_online/manual/imgui_manual.html">ImGui Manual (pthom.github.io)</a>第三方文档</p></li><li><p>其他教程<a href="https://www.cnblogs.com/timefiles/p/17632348.html#打包程序">使用C++界面框架ImGUI开发一个简单程序 - 二次元攻城狮 - 博客园 (cnblogs.com)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/639795542">【漫谈】关于图形引擎的一些看法 - 知乎 (zhihu.com)</a> 一位知乎er对现有绘图引擎评价</p></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前介绍过Qt,作为c++界面(事实上不只是界面,Qt本身已经成了写C++的一种工具了)工具,采用的是创建控件然后绑定事件处理的逻辑,与winform,WPF等都是类似的,但是这里介绍一种不太一样的GUI库,其使用immediate mode,也就是在每一帧进行处理,没有保留状态维护. 在游戏界面开发中受到热捧.&lt;br&gt;</summary>
    
    
    
    
    <category term="GUI" scheme="https://www.sekyoro.top/tags/GUI/"/>
    
  </entry>
  
  <entry>
    <title>cs144:intro to computer network</title>
    <link href="https://www.sekyoro.top/2024/09/01/cs144-intro-to-computer-network/"/>
    <id>https://www.sekyoro.top/2024/09/01/cs144-intro-to-computer-network/</id>
    <published>2024-09-01T11:50:34.000Z</published>
    <updated>2024-09-12T12:47:21.943Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>开始计划做点计算机课程lab,涉及到操作系统、并行分布式系统,计算机网络,数据库系统等等.<br><span id="more"></span></p><p>代码lian’jie<a href="https://github.com/drowning-in-codes/build-my-own-x/tree/main/cs144">build-my-own-x/cs144 at main · drowning-in-codes/build-my-own-x (github.com)</a></p><h2 id="Lab0"><a href="#Lab0" class="headerlink" title="Lab0"></a>Lab0</h2><p>第一个项目minnow,看看<code>CMakeLists.txt</code>,写得是真的好.</p><p>首先确保generator必须是Unix Makefiles,然后保证out of build(也就是src和build目录不同,使用cmake -B build)</p><p>然后添加其他辅助cmake脚本,这里通过<code>include</code>指令添加,应该是为了访问父作用域的变量. 然后添加头文件目录,最后使用<code>add_subdirectory</code>添加需要编译的子项目.每个目录下都是一个<code>CMakeLists.txt</code>,设置<code>CMAKE_EXPORT_COMPILE_COMMANDS</code>得到编译指令(也是为了搭配一些编辑器使用).光是CmakeLists.txt就学到很多c++项目组织的知识.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.24</span>.<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(minnow CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$&#123;CMAKE_GENERATOR&#125;</span> <span class="keyword">STREQUAL</span> <span class="string">&quot;Unix Makefiles&quot;</span>)</span><br><span class="line">  <span class="keyword">set</span>(CMAKE_MAKE_PROGRAM <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/scripts/make-parallel.sh&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span> <span class="keyword">STREQUAL</span> <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>)</span><br><span class="line">  <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Minnow must be built outside its source directory, e.g. `cmake -B build`.&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(etc/build_type.cmake)</span><br><span class="line"><span class="keyword">include</span>(etc/cflags.cmake)</span><br><span class="line"><span class="keyword">include</span>(etc/scanners.cmake)</span><br><span class="line"><span class="keyword">include</span>(etc/tests.cmake)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/util&quot;</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/src&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/util&quot;</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/src&quot;</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/tests&quot;</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/apps&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure><p>在添加的cmake脚本中,包括设置构建类型的(Debug或Release),一些编译器设置,clang-tidy和format用于语法提示和格式化,以及一些测试.</p><p>在代码中,许多c++17和20新东西都用上了,比如string_view,span等,</p><p>第一次作业要求写一个bytestream的reader和writer,分别读取和写入字节流. 我看了一些网上的实现,太吓人了,还使用<code>`std::deque</code>等容器,根本没必要,还可能在提交测试时出现heap overflow. 直接使用string即可,熟悉一下一些STL常用操作.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;byte_stream.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ByteStream::<span class="built_in">ByteStream</span>(<span class="keyword">uint64_t</span> capacity) : <span class="built_in">capacity_</span>(capacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Writer::is_closed</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> _is_closed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Writer::push</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  std::<span class="keyword">size_t</span> data_len = data.<span class="built_in">length</span>();</span><br><span class="line">  std::<span class="keyword">size_t</span> avai_cap = <span class="keyword">this</span>-&gt;<span class="built_in">available_capacity</span>();</span><br><span class="line">  <span class="keyword">if</span> (data_len &gt;= avai_cap) &#123;</span><br><span class="line">    _buffer.<span class="built_in">insert</span>(_buffer.<span class="built_in">end</span>(), data.<span class="built_in">begin</span>(), data.<span class="built_in">begin</span>() + avai_cap);</span><br><span class="line">    push_counts += avai_cap;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _buffer.<span class="built_in">insert</span>(_buffer.<span class="built_in">end</span>(), data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>());</span><br><span class="line">    push_counts += data_len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Writer::close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  _is_closed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">Writer::available_capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> capacity_ - _buffer.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">Writer::bytes_pushed</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> push_counts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Reader::is_finished</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> _is_closed &amp;&amp; _buffer.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">Reader::bytes_popped</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> pop_counts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string_view <span class="title">Reader::peek</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">if</span> (_buffer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  string_view sv&#123;&amp;*_buffer.<span class="built_in">begin</span>(), _buffer.<span class="built_in">size</span>()&#125;;</span><br><span class="line">  <span class="keyword">return</span> sv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reader::pop</span><span class="params">(<span class="keyword">uint64_t</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">if</span> (_buffer.<span class="built_in">size</span>() &lt;= len) &#123;</span><br><span class="line">    pop_counts += _buffer.<span class="built_in">size</span>();</span><br><span class="line">    _buffer.<span class="built_in">clear</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _buffer.<span class="built_in">assign</span>(_buffer.<span class="built_in">begin</span>() + len, _buffer.<span class="built_in">end</span>());</span><br><span class="line">    pop_counts += len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">Reader::bytes_buffered</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> _buffer.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/09/03/7M1R6WH3g8iKQdc.png" alt="image-20240903120538215"></p><blockquote><p>后面我看到有人使用queue\<string>,效果还不错.所以我又改了😅</p><p>逻辑是每次push数据,都是推一个新的string,如果没有超过容量直接推,如果超了就截断后再推.</p><p>pop数据时,如果queue中string数据长度大于len,就不需要将该数据pop掉,而是设置为removed_prefix,方便peek时返回. 如果小于等于,就将其推掉再看下一个string的长度.</p></blockquote><h2 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h2><p>第一个实验就折磨了我很久,写一个对乱序(是指的发送的数据段的序列是乱的,数据段substring内部是顺序的)的字节流进行重排的reassembler.</p><p><img data-src="https://s2.loli.net/2024/09/06/gJCwbV4RtfLrW9j.png" alt="image-20240906172137248"></p><p>重点就是上面的图,绿色加红色的段落是固定长度并且只会往右移动到发送过来的数据最大长度.</p><p>如果来的数据段first_index为first_unasembled_index,那就说明来对了.但是在push到bytestream之前,需要注意可能有重叠部分,</p><p><img data-src="https://s2.loli.net/2024/09/06/cgsVmdDfLGSXWBj.png" alt="image-20240906172716413"></p><p>比如上面有重叠部分,需要截断数据,比较好的方法是将incoming data前面没有重叠的部分取出来作为新的数据,后面准备直接push到bytestream</p><p><img data-src="https://s2.loli.net/2024/09/06/RvQ3uFjrKMeIVwX.png" alt="image-20240906173236584"></p><p>有人就要问了,为啥不直接将这段数据直接都推进去,就像下图中红框这样,如果像上面那样截断,不就要后面多推一次吗？</p><p><img data-src="https://s2.loli.net/2024/09/06/84oJBaVHhO1PkDj.png" alt="image-20240906173340799"></p><p>理论上来说也是可行的,包括也可以像下面这样截断,但隐含的问题是,这两种方法后面的数据都有可能overlap.</p><p><img data-src="https://s2.loli.net/2024/09/06/wGFBxXy8jOcgWkr.png" alt="image-20240906173540255"></p><p>而像第一种截断方法中绿色那一段数据就不会有overlap.  而且后面的数据重复段可能不止一个,需要连续处理知道处理完后面的所有数据或者部分重叠.</p><p>如果是完全重叠,就可以直接删掉这段,比如下面的红色段数据.</p><p><img data-src="https://s2.loli.net/2024/09/06/UjCw2PEJ9mtbeAp.png" alt="image-20240906174432079"></p><p>除了对后面的数据做截断,针对排在前面的数据也是类似. 注意,在这里并没有对超过first_unaccepted_index的数据段进行截取.</p><p><img data-src="https://s2.loli.net/2024/09/06/letiLN4d5mMpsHS.png" alt="image-20240906173933135"></p><p>总的来说,首先需要对数据的first_index和大小进行调整,比如截断啥的. 使得它没有与其他数据段重叠.</p><p>然后就是判断更新后的first_index与first_unassemble_index,如果相等,push数据(由于在上一节push的实现中,如果数据长度大于capacity,就只会将数据填满,超过的数据忽略),否则放在一个map<uint64_t,string>中,称为substrings,注意这里有多种选择,你可以将其超过first_unassemble_index的段截断,也可以先直接推进去,后面再处理,但为了节省内存,可以直接先截断.</p><p>可能到这里有人以为已经结束了,但当推送了某个数据之后,可能后面的substrings就能使用上了,就需要进行处理.如果是next_assembled_idx(其实就是first_unassemble_idx==bytes_pushed),就继续推,因为前面存substrings中的数据时已经考虑到了截断超过first_unassemble_index的数据,数据长度加起来肯定小于容量,这里直接推进去就行了.</p><p><img data-src="https://s2.loli.net/2024/09/06/Czik8Pc4KM2rBHE.png" alt="image-20240906173613597" style="zoom:50%;" /></p><h2 id="Lab2"><a href="#Lab2" class="headerlink" title="Lab2"></a>Lab2</h2><blockquote><p>TCP是一种协议，它在不可靠的数据报上可靠地传输一对流控制的字节流(每个方向一个)。双方或“peers”参与TCP连接，每个peers都充当(其自身输出字节流的)“发送者”和“接收者”</p></blockquote><p><img data-src="https://s2.loli.net/2024/09/06/nzAsKGwy4xWNqH3.png" alt="image-20240906180021011"></p><p>首先需要实现一个32-bit的相对索引wrapper与64位绝对索引相互转换.</p><p><img data-src="https://s2.loli.net/2024/09/06/dD4tQgeqRLTm8vj.png" alt="image-20240906234140049"></p><p>而注意在接受的数据段(stream index),是直接从0开始,不包括SYN的.</p><p>从接收到的absolute seqno-&gt;seqno,也就是从64位转为32位,比较简单,可以采取取余或者直接<code>static_cat&lt;uint32_t&gt;</code>即可,相当于把多出的截断.从seqno-&gt;absolute seqno,有非常多可能,比如假设seqno-zero_point的值是144,那么就有可能是144+GAP*k,其中GAP是<code>1UL&lt;&lt;32</code>. 所以需要一个值帮助确定,checkpoint就是这个值,离它最近的就是这个absolute seqno. 需要做的就是求k. k是(checkpoint-absolute seqno)/(1UL&lt;&lt;32)的四舍五入值.  但是要注意,如果checpoint&lt;absolute seqno,上面的公式就会出问题.</p><p>当checpoint&lt;absolute seqno时,直接返回<code>seqno-zero_point</code>即可.</p><p>在此基础上需要实现TCP receiver.</p><p>它将(1)从peer的发送方接收消息并使用Reassembler重新组装字节流</p><p>(2)将包含确认号(ackno)和窗口大小的消息发送回peer的发送方.</p><p>注意SYN和FIN并不包含在数据payload中,但是在计算ackno时需要加上相应的值以确定需要的数据index. </p><p>接收到数据时,如果带有SYN则对应的seqno就是zero_point(并不是数据的开始,zero_point+1才是数据),我们本身需要的是发过来的数据在absolute seqno中的索引,但这个值我们无法确定,checkpoint可以设置为bytes_pushed也就是first_unassembled_index,因为这是我们需要的值.在获得absolute seqno后还需要-1除去SYN,然后再insert数据. 如果writer关闭则设置FIN关闭,方便后面send及时关闭.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCPSenderMessage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Wrap32 seqno &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">bool</span> SYN &#123;&#125;;</span><br><span class="line">std::string payload &#123;&#125;;</span><br><span class="line"><span class="keyword">bool</span> FIN &#123;&#125;;</span><br><span class="line"><span class="keyword">bool</span> RST &#123;&#125;;</span><br><span class="line"><span class="comment">// How many sequence numbers does this segment use?</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">sequence_length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> SYN + payload.<span class="built_in">size</span>() + FIN; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCPReceiverMessage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">std::optional&lt;Wrap32&gt; ackno &#123;&#125;;</span><br><span class="line"><span class="keyword">uint16_t</span> window_size &#123;&#125;;</span><br><span class="line"><span class="keyword">bool</span> RST &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPReceiver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Construct with given Reassembler</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">TCPReceiver</span><span class="params">( Reassembler&amp;&amp; reassembler )</span> : reassembler_( std::move( reassembler ) ) &#123;</span>&#125;</span><br><span class="line"><span class="comment">// The TCPReceiver receives TCPSenderMessages from the peer&#x27;s TCPSender.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">( TCPSenderMessage message )</span></span>;</span><br><span class="line"><span class="comment">// The TCPReceiver sends TCPReceiverMessages to the peer&#x27;s TCPSender.</span></span><br><span class="line"><span class="function">TCPReceiverMessage <span class="title">send</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">// Access the output (only Reader is accessible non-const)</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> Reassembler&amp; <span class="title">reassembler</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> reassembler_; &#125;</span><br><span class="line"><span class="function">Reader&amp; <span class="title">reader</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reassembler_.<span class="built_in">reader</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Reader&amp; <span class="title">reader</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> reassembler_.<span class="built_in">reader</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Writer&amp; <span class="title">writer</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> reassembler_.<span class="built_in">writer</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Reassembler reassembler_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在send中,需要返回ackno和window_size,后者就是writer().available_capacity(),但注意如果初始化时超过了就设置MAX.</p><p>前者就是目前接收到的数据加上标志位.</p><p>发送数据时首先初始化SYN作为开始位置,开始位置之后的一个位置是数据位置.发送数据时携带这个标志和数据payload,同时每次只允许最多发送uint_32_t数据,所以发送数据时需要将原本64位的索引转成32位</p><blockquote><p>在TCP报头中，空间是宝贵的，流中的每个字节的索引不是用64位索引表示，而是用32位的“序列号”或“seqno”表示。这增加了复杂性</p></blockquote><p><img data-src="https://s2.loli.net/2024/09/07/gE7IOc6ZdzyKbel.png" alt="image-20240907145920140"></p><p>当接收者拿到32位的相对索引时如何知道在绝对位置上的索引呢<img data-src="https://s2.loli.net/2024/09/07/HRkMqCVI5ApihuJ.png" alt="image-20240907151332005"></p><p>关键是确定checkpoint,因为absolute seqno可能是k*GAP+offset,offset是小于GAP的.</p><p>假设如下图,如果此时发送一个之前的重复段,实际的absolute seqno比较小,如果使用bytes_pushed,那么可能会导致得到的first_index比较大. 出现这种情况的前提是,bytes_pushed&gt;uint32_t,因为此时会有多个可能的绝对位置,如果再发送之前的数据,那么absolute seqno的first_index就会选择错误.</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240907152015454.png" alt="image-20240907152015454"></p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240907155828700.png" alt="image-20240907155828700"></p><p>当我尝试这么测试时,要么报错oom要么timeout.</p><h2 id="Lab3"><a href="#Lab3" class="headerlink" title="Lab3"></a>Lab3</h2><p>实现TcpSender.在文档中需要要点都说了.但是有些细节还是容易忘.</p><p>首先在push方法中,什么时候发送数据?</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240908231650614.png" alt="image-20240908231650614"></p><p>只要有可读数据并且空余的window_size就能使用transmit读取数据.什么叫做空余的window_size,只要window_size大于0就能发送数据吗,事实上并不是,比如如果我连续发送了很多数据,但是window_size一直为0,我还需要不断发送直到读完所有数据吗,貌似也是可行的. 更好的方式是window_size如果小于outstanding_bytes的数量,那就先等着,直到接收到peer发来的ackno更新window_size.  每次发送的数据就是window_size-outstanding_bytes,但是有个MAX_PAYLOAD_SIZE的限制,另外注意发送的数据大小是包含SYN的,也就是说如果是开始的数据,window_size =100,那么只能发送99个数据.payload大小是99.</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240907171424559.png" alt="image-20240907171424559"></p><p>如何确定sender需要发送FIN？</p><p>首先reader需要结束,也就是reader().is_finished() (注意不是bytes_bufferd==0,还需要reader关闭,因为还没有关闭时也有可能存在buffer为空的情况).此外剩余的数据已经小于window_size-outstanding_bytes(相当于peer还剩的空间).</p><p>然后发送数据,开启计时同时增加发送的index和outstanding_bytes,保存发送的信息. 当接收到ackno和window_size时进行更新窗口大小,并根据ackno删除数据,如果确实超过了保留数据的ackno+seq_len,那就更新ack_abs_seqno,此外重新设置timer,如果清空了outstanding_byte_stream,那就关闭定时器,否则还是打开但需要重置时间.tick方法计时器超时并且还有重传数据时,发送最早的重传数据,重置timer,如果window_size不为0,double重传时间,重传次数+1,背后的逻辑可能是,如果window_size为0,表示peer没有什么要接受的,没有那么急</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240908234129034.png" alt="image-20240908234129034"></p><p>注意,当window_size为0时,说明peer没有需要的数据了,但如果依然能发送(&gt;outstanding_bytes),就需要多发送1byte数据来查看peer还能否扩展空间.如果没有数据了就不发了. </p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240908235508628.png" alt="image-20240908235508628"></p><p>想象一下,如果peer依然发送window_size=0,在tick中我们就会不断重试,直到超过次数然后退出.</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240908235847377.png" alt="image-20240908235847377" style="zoom:50%;" /></p><h2 id="Lab4"><a href="#Lab4" class="headerlink" title="Lab4"></a>Lab4</h2><p>使用之前的工具进行数据分析.无代码</p><h2 id="Lab5"><a href="#Lab5" class="headerlink" title="Lab5"></a>Lab5</h2><p>在有了TCP实现之后,还需要怎么封装才能传输信息?</p><ul><li>TCP-in-UDP-in-IP:TCP段可以在用户数据报的有效载荷中携带。在正常(用户空间)设置中工作时，这是最容易实现的:Linux提供了一个接口(“数据报套接字”，UDPSocket)，它允许应用程序只提供用户数据报的有效载荷和目标地址，内核负责构造UDP报头、IP报头和以太网报头，然后将数据包发送到适当的下一跳</li><li>内核确保每个套接字具有本地和远程地址和端口号的独占组合，并且由于内核负责将这些写入UDP和IP头，因此它可以保证不同应用程序之间的隔离</li><li>TCP-in-IP:在通常的用法中，TCP段几乎总是直接放在互联网数据报中，在IP和TCP头之间没有UDP头。这就是人们所说的“TCP/IP”.“这有点难以实施。Linux提供了一个称为TUN设备的接口，它允许应用程序提供一个完整的Internet数据报，内核负责其余的工作(写入以太网头，并实际通过物理以太网卡发送，等等)。但是应用程序必须自己构造完整的IP报头，而不仅仅是有效负载</li><li>TCP-in-IP-in-Ethernet: 在上述方法中仍然依赖Linux内核来实现部分网络堆栈。每次代码向TUN设备写入IP数据报时，Linux都必须用IP数据报作为有效负载构建一个适当的链路层(以太网)帧。这意味着Linux必须找出下一跳以太网目的地址，给定下一跳的IP地址。如果不知道,Linux广播一个查询:“谁声明了以下内容?IP地址?以太网地址是什么?，然后等待回复。这些功能由网络接口执行:一个将出站IP数据报转换为链路层(例如，以太网)帧的组件，反之亦然。(在实际系统中，网络接口通常有eth0、eth1、wlan0等名称)</li></ul><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240908231059785.png" alt="image-20240908231059785" style="zoom: 50%;" /></p><p>这一节说白了就是实现简单的ARP,保存IP地址与MAC(以太网)地址映射.</p><p>关键是两个方法,接受数据和发送数据.对于发送数据,如果在映射表中,那就直接发送,如果不在,那就需要发送arp消息,但前提是之前没有发送过或者发送后超过了一定时间,发送arp消息后timer置0.注意发送的arp请求消息中,目标以太网地址为0,广播地址在以太网地址字段中而不是arp中.arp消息是payload,以太网头是header.然后将要发送的消息和next_hop保存,等接受到相应的地址后再发送.对于接受消息,如果数据是ip数据报并且目标ip是自己,就接受消息并且更新映射表,如果是新的映射设置timer,否则不管.然后看新的映射是否跟保存的消息的目标ip相同,相同则发送.如果是arp消息,也更新映射与timer,如果是请求就发送自己的ip.否则根据更新的映射发送消息. 在tick中更新timer,并且如果超时就删除对应映射. 需要注意的是,什么时候需要开启timer,什么时候删除.</p><p>发送了arp消息时需要设置为0,接收到arp回应时删除对应arp请求的ip记录. 接收到新的映射时开启timer,超过30s后删除映射表和timer. </p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240910202737584.png" alt="image-20240910202737584" style="zoom:67%;" /></p><h2 id="Lab6"><a href="#Lab6" class="headerlink" title="Lab6"></a>Lab6</h2><p>一个router有几个网络接口，可以在其中任何一个接口上接收Internet数据报.</p><p>router的工作是根据路由表转发它收到的数据报:路由表是一个规则列表，它告诉router，对于任何给定的数据报，</p><p>•发送哪个接口</p><p>•下一跳IP地址</p><p>实现一个路由器，它可以为给定的数据报得到这两个东西。</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240910204547680.png" alt="image-20240910204547680"></p><p>这里本身逻辑并不复杂,写一个路由表记录ip掩码和掩码后的地址,对应下一跳地址和interface. 首先遍历interface,拿到消息队列,对于每个消息ttl的ttl如果小于等于1,直接丢掉,否则拿去匹配路由表中,找到最长匹配的ip地址.</p><p>我一开始使用的路由表结构是map,但是发现一直过不了,改成multimap就过了,说明有重复的key,我的结构体如下,如果有重复key,表明掩码长度.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_addr</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> masked_ipaddr&#123;&#125;; #掩码后的地址</span><br><span class="line"><span class="keyword">uint8_t</span> prefix_length&#123;&#125;; # 前缀长度</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> ip_addr&amp; ip_) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> prefix_length &lt; ip_.prefix_length;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由两种解决方法,要么使用multimap允许重复key,要么将&lt;比较操作为修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> masked_ipaddr&#123;&#125;;</span><br><span class="line">    <span class="keyword">uint8_t</span> prefix_length&#123;&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> ip_addr&amp; ip_) <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(prefix_length != ip_.prefix_length) &#123;</span><br><span class="line">        <span class="keyword">return</span> prefix_length&lt;ip_.prefix_length;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> masked_ipaddr&lt;ip_.masked_ipaddr;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>c++20增加了<code>&lt;=&gt;</code>操作符和 std::strong_ordering,std::weak_ordering<br>,std::partial_ordering. 定义一个默认的<code>&lt;=&gt;</code>操作符基本就能允许所有比较,实在是太酷啦! 比较顺序与类中声明成员的顺序一致.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  std::string name&#123;&#125;;</span><br><span class="line">  <span class="keyword">double</span> value&#123;&#125;;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span>&lt;=&gt;(<span class="keyword">const</span> Person &amp;) <span class="keyword">const</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person p1&#123;.name = <span class="string">&quot;张三&quot;</span>, .value = <span class="number">12.</span>&#125;, p2&#123;.name = <span class="string">&quot;李四&quot;</span>, .value = <span class="number">13.</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;我们都一样&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lab7"><a href="#Lab7" class="headerlink" title="Lab7"></a>Lab7</h2><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912173600895.png" alt="image-20240912173600895"></p><p>lab7也是测试</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912200347129.png" alt="image-20240912200347129"></p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912200356663.png" alt="image-20240912200356663"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次计算机网络实验,从一开始的bytestream,到reassember,再到tcpsender,reader,最后写路由分配ip数据报. </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/Kiprey/sponge/tree/master">Kiprey/sponge: CS144 Lab Assignments (github.com)</a></li><li><a href="https://github.com/Kenshin2438/CS144">Kenshin2438/CS144: CS 144: Introduction to Computer Networking, Winter 2024 (github.com)</a></li><li><a href="https://cs144.github.io/">CS 144: Introduction to Computer Networking</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;开始计划做点计算机课程lab,涉及到操作系统、并行分布式系统,计算机网络,数据库系统等等.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>dive deeper into functional programming</title>
    <link href="https://www.sekyoro.top/2024/08/17/dive-deeper-into-functional-programming/"/>
    <id>https://www.sekyoro.top/2024/08/17/dive-deeper-into-functional-programming/</id>
    <published>2024-08-17T06:49:47.000Z</published>
    <updated>2024-08-29T12:43:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>我们在许多编程语言中都能看到一些函数式编程,其最初起源于大学实验室、数学推理的思想,虽然在目前大型软件的源代码中相对OOP编程并没有那么多,但是在一些核心数据处理中利用函数式编程能一定程度上保证程序正确性.这里使用<a href="https://ocaml.org/">ocaml.org</a>学习函数式编程.</p><span id="more"></span><p>相对来说,ocaml,elixir,scala以及clojure等在工业界用得比其他语言要多一点,主要原因个人认为还是对于大数据、多线程的处理以及语法上的可读性.  学习这些语言能帮助扩展思维以及在其他现代的编程语言中,你很可能会看见类似的设计和思想.</p><p>函数式语言的设计往往非常优雅严谨,以此达到编写正确优美的代码.下面以ocaml作介绍.</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>OCaml语法的主要部分是表达式。就像命令式语言中的程序主要由命令构建一样，函数式语言中的程序主要由表达式构建。表达式的例子包括2+2和increment 21</p><p>在函数式语言中，计算的主要任务是将表达式求值为一个值。值是一个表达式，它不需要执行任何计算。所以，<strong>所有的值都是表达式，但不是所有的表达式都是值</strong>。值的例子包括2、true和”yay!”</p><h3 id="Assertions"><a href="#Assertions" class="headerlink" title="Assertions"></a>Assertions</h3><p>表达式assert e求e的值。如果结果为真，则不再发生任何事情，整个表达式的求值为一个名为unit的特殊值。unit写作()，类型为unit。但如果结果为false，则会引发异常。</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="literal">()</span> = <span class="keyword">assert</span> (f input1 = output1)</span><br><span class="line"><span class="keyword">let</span> <span class="literal">()</span> = <span class="keyword">assert</span> (f input2 = output2)</span><br><span class="line"><span class="keyword">let</span> <span class="literal">()</span> = <span class="keyword">assert</span> (f input3 = output3)</span><br></pre></td></tr></table></figure><h3 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h3><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">3</span> + <span class="number">5</span> &gt; <span class="number">2</span> <span class="keyword">then</span> <span class="string">&quot;yay!&quot;</span> <span class="keyword">else</span> <span class="string">&quot;boo!&quot;</span></span><br></pre></td></tr></table></figure><h3 id="let表达式"><a href="#let表达式" class="headerlink" title="let表达式"></a>let表达式</h3><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">42</span> <span class="keyword">in</span> x + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>注意<code>let x = 42;;</code>是定义而不是表达式</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(** [fact n] is [n!].</span></span><br><span class="line"><span class="comment">    Requires: [n &gt;= 0]. *)</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> fact n = <span class="keyword">if</span> n = <span class="number">0</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> n * fact (n - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> inc x = x + <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> inc = <span class="keyword">fun</span> x -&gt; x + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h3><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">square (inc <span class="number">5</span>);;</span><br><span class="line"><span class="number">5</span> |&gt; inc |&gt; square;;</span><br></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>这是在其他编程语言中非常常见的,包括map,filter,fold等等操作</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(** [add1 lst] adds 1 to each element of [lst]. *)</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> add1 = <span class="keyword">function</span></span><br><span class="line">  | <span class="literal">[]</span> -&gt; <span class="literal">[]</span></span><br><span class="line">  | h :: t -&gt; (h + <span class="number">1</span>) :: add1 t</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lst1 = add1 [<span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> map f = <span class="keyword">function</span></span><br><span class="line">  | <span class="literal">[]</span> -&gt; <span class="literal">[]</span></span><br><span class="line">  | h :: t -&gt; f h :: map f t</span><br><span class="line"></span><br><span class="line"><span class="comment">(** [add1 lst] adds 1 to each element of [lst]. *)</span></span><br><span class="line"><span class="keyword">let</span> add1 = map (<span class="keyword">fun</span> x -&gt; x + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">(** [concat_bang lst] concatenates &quot;!&quot; to each element of [lst]. *)</span></span><br><span class="line"><span class="keyword">let</span> concat_bang = map (<span class="keyword">fun</span> x -&gt; x ^ <span class="string">&quot;!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p x = print_int x; print_newline<span class="literal">()</span>; x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lst = map p [<span class="number">1</span>; <span class="number">2</span>]</span><br></pre></td></tr></table></figure><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> filter p = <span class="keyword">function</span></span><br><span class="line">  | <span class="literal">[]</span> -&gt; <span class="literal">[]</span></span><br><span class="line">  | h :: t -&gt; <span class="keyword">if</span> p h <span class="keyword">then</span> h :: filter p t <span class="keyword">else</span> filter p t</span><br></pre></td></tr></table></figure><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> combine op init = <span class="keyword">function</span></span><br><span class="line">            | <span class="literal">[]</span> -&gt; init</span><br><span class="line">            | h::t -&gt; op h (combine op init t)</span><br><span class="line"><span class="keyword">let</span> sum = combine ( + ) <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> concat = combine (^) <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="primitive-types和values"><a href="#primitive-types和values" class="headerlink" title="primitive types和values"></a>primitive types和values</h2><p>基本类型是内置的和最基本的类型:整数、浮点数、字符、字符串和布尔值。它们将被识别为类似于其他编程语言中的基本类型.</p><p>除了上面之外,Ocaml还有许多东西,但我也就止于此了.目前我主要关注的还高阶函数</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://cs3110.github.io/textbook/chapters/intro/past.html">1.1. The Past of OCaml — OCaml Programming: Correct + Efficient + Beautiful (cs3110.github.io)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在许多编程语言中都能看到一些函数式编程,其最初起源于大学实验室、数学推理的思想,虽然在目前大型软件的源代码中相对OOP编程并没有那么多,但是在一些核心数据处理中利用函数式编程能一定程度上保证程序正确性.这里使用&lt;a href=&quot;https://ocaml.org/&quot;&gt;ocaml.org&lt;/a&gt;学习函数式编程.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>

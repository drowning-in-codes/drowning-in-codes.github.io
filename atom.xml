<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sekyoro的博客小屋</title>
  
  
  <link href="https://www.sekyoro.top/atom.xml" rel="self"/>
  
  <link href="https://www.sekyoro.top/"/>
  <updated>2023-05-22T03:35:12.967Z</updated>
  <id>https://www.sekyoro.top/</id>
  
  <author>
    <name>Sekyoro</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Wox插件编写</title>
    <link href="https://www.sekyoro.top/2023/05/20/Wox%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/"/>
    <id>https://www.sekyoro.top/2023/05/20/Wox%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/</id>
    <published>2023-05-20T02:21:31.000Z</published>
    <updated>2023-05-22T03:35:12.967Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近正再使用Wox，这个软件还挺高效的，而且还能自己编写一些插件，这里打算自己写点插件用用.<br><span id="more"></span></p><p><a href="http://www.wox.one/">Wox</a>官网</p><p><a href="http://www.wox.one/plugin">Plugin (wox.one)</a>插件,此外官方也提供了编写文档，<a href="http://doc.wox.one/zh/plugin/create_plugin.html">编写插件 · GitBook (wox.one)</a>提供Python和C#两种优秀的语言编写方案。我这里就使用Python写了.</p><p>首先需要做的是创建新的虚拟环境作隔离，一般使用python自带的<code>venv</code>或者<code>virtualenv</code>,当然也有比较新的<code>pipenv</code>和被认为比较重的<code>Anaconda</code>，后两者也是包管理器，功能比较多。</p><p>以下是创建虚拟环境的代码示例：</p><p>使用 virtualenv：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 virtualenv</span></span><br><span class="line">pip install virtualenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建名为 myenv 的虚拟环境</span></span><br><span class="line">virtualenv myenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活虚拟环境（Windows 平台）</span></span><br><span class="line">myenv\Scripts\activate.bat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活虚拟环境（Linux 和 Mac 平台）</span></span><br><span class="line"><span class="built_in">source</span> myenv/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出虚拟环境</span></span><br><span class="line">deactivate</span><br></pre></td></tr></table></figure><p>使用 venv：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建名为 myenv 的虚拟环境</span></span><br><span class="line">python3 -m venv myenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活虚拟环境</span></span><br><span class="line"><span class="built_in">source</span> myenv/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出虚拟环境</span></span><br><span class="line">deactivate</span><br></pre></td></tr></table></figure><p>这一步还是很重要的，环境不能乱。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>可以看看官方案例以及其他插件的目录结构</p><p><img data-src="https://s2.loli.net/2023/05/20/79rv3TcFb4fYPqn.png" alt="image-20230520114456394"></p><p>在创建Wox的时候，用户必须在插件的根目录方式一个名为<code>plugin.json</code>的文件。该文件中包含了该插件的一些基本信息。</p><p><code>plugin.json</code>的格式如下： <strong>请在粘贴下面代码的时候移除其中的注释</strong></p><p>重点是触发词<code>ActionKeyword</code>以及<code>IcoPath</code>插件图标,<code>ID</code>需要一个32位不与其他插件重复的随机数，自己生成即可。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;ID&quot;</span>:<span class="string">&quot;D2D2C23B084D411DB66FE0C79D6C2A6H&quot;</span>,   <span class="comment">//插件ID，32位的UUID</span></span><br><span class="line">  <span class="attr">&quot;ActionKeyword&quot;</span>:<span class="string">&quot;wpm&quot;</span>,                     <span class="comment">//插件默认的触发关键字</span></span><br><span class="line">  <span class="attr">&quot;Name&quot;</span>:<span class="string">&quot;WPM&quot;</span>,                              <span class="comment">//插件名字</span></span><br><span class="line">  <span class="attr">&quot;Description&quot;</span>:<span class="string">&quot;Wox Package Management&quot;</span>,    <span class="comment">//插件介绍</span></span><br><span class="line">  <span class="attr">&quot;Author&quot;</span>:<span class="string">&quot;qianlifeng&quot;</span>,                     <span class="comment">//作者</span></span><br><span class="line">  <span class="attr">&quot;Version&quot;</span>:<span class="string">&quot;1.0.0&quot;</span>,                         <span class="comment">//插件版本，必须是x.x.x的格式</span></span><br><span class="line">  <span class="attr">&quot;Language&quot;</span>:<span class="string">&quot;csharp&quot;</span>,                       <span class="comment">//插件语言，目前支持csharp,python</span></span><br><span class="line">  <span class="attr">&quot;Website&quot;</span>:<span class="string">&quot;http://www.getwox.com&quot;</span>,         <span class="comment">//插件网站或者个人网站</span></span><br><span class="line">  <span class="attr">&quot;IcoPath&quot;</span>: <span class="string">&quot;Images\\pic.png&quot;</span>,              <span class="comment">//插件图标，路径是相对插件根目录的路径</span></span><br><span class="line">  <span class="attr">&quot;ExecuteFileName&quot;</span>:<span class="string">&quot;PluginManagement.dll&quot;</span>   <span class="comment">//执行文件入口，如果是C#插件则填写DLL路径，如果是pyhton则填写python文件路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是主文件以及插件图标文件</p><h2 id="Python开发"><a href="#Python开发" class="headerlink" title="Python开发"></a>Python开发</h2><blockquote><p>Wox自带了一个打包的Python及其标准库，所以使用Python插件的用户不必自己再安装Python环境。同时，Wox还打包了requests和beautifulsoup4两个库， 方便用户进行网络访问与解析。</p></blockquote><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>使用Python开发需要有一个类继承Wox,注意这个东西并不需要pip下载，是Wox自带的运行时，包括requests和BeautifulSoup4，而其他的第三方包需要自己下载.下载Wox时有一个full-installer包含python解释器，自己可以设置Python解释器文件夹路径为环境变量，一般下载Python时选择加入环境变量即可。</p><p>继承Wox类后关键要继承的方法是<code>query</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> webbrowser</span><br><span class="line"><span class="keyword">from</span> wox <span class="keyword">import</span> Wox,WoxAPI</span><br><span class="line"></span><br><span class="line"><span class="comment">#用户写的Python类必须继承Wox类 https://github.com/qianlifeng/Wox/blob/master/PythonHome/wox.py</span></span><br><span class="line"><span class="comment">#这里的Wox基类做了一些工作，简化了与Wox通信的步骤。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span>(<span class="params">Wox</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request</span>(<span class="params">self,url</span>):</span></span><br><span class="line">    <span class="comment">#如果用户配置了代理，那么可以在这里设置。这里的self.proxy来自Wox封装好的对象</span></span><br><span class="line">    <span class="keyword">if</span> self.proxy <span class="keyword">and</span> self.proxy.get(<span class="string">&quot;enabled&quot;</span>) <span class="keyword">and</span> self.proxy.get(<span class="string">&quot;server&quot;</span>):</span><br><span class="line">      proxies = &#123;</span><br><span class="line">        <span class="string">&quot;http&quot;</span>:<span class="string">&quot;http://&#123;&#125;:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(self.proxy.get(<span class="string">&quot;server&quot;</span>),self.proxy.get(<span class="string">&quot;port&quot;</span>)),</span><br><span class="line">        <span class="string">&quot;https&quot;</span>:<span class="string">&quot;http://&#123;&#125;:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(self.proxy.get(<span class="string">&quot;server&quot;</span>),self.proxy.get(<span class="string">&quot;port&quot;</span>))&#125;</span><br><span class="line">      <span class="keyword">return</span> requests.get(url,proxies = proxies)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> requests.get(url)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#必须有一个query方法，用户执行查询的时候会自动调用query方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span>(<span class="params">self,key</span>):</span></span><br><span class="line">    r = self.request(<span class="string">&#x27;https://news.ycombinator.com/&#x27;</span>)</span><br><span class="line">    bs = BeautifulSoup(r.text)</span><br><span class="line">    results = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> bs.select(<span class="string">&quot;.comhead&quot;</span>):</span><br><span class="line">      title = i.previous_sibling.text</span><br><span class="line">      url = i.previous_sibling[<span class="string">&quot;href&quot;</span>]</span><br><span class="line">      results.append(&#123;</span><br><span class="line">        <span class="string">&quot;Title&quot;</span>: title ,</span><br><span class="line">        <span class="string">&quot;SubTitle&quot;</span>:title,</span><br><span class="line">        <span class="string">&quot;IcoPath&quot;</span>:<span class="string">&quot;Images/app.ico&quot;</span>,</span><br><span class="line">        <span class="string">&quot;JsonRPCAction&quot;</span>:&#123;</span><br><span class="line">          <span class="comment">#这里除了自已定义的方法，还可以调用Wox的API。调用格式如下：Wox.xxxx方法名</span></span><br><span class="line">          <span class="comment">#方法名字可以从这里查阅https://github.com/qianlifeng/Wox/blob/master/Wox.Plugin/IPublicAPI.cs 直接同名方法即可</span></span><br><span class="line">          <span class="string">&quot;method&quot;</span>: <span class="string">&quot;openUrl&quot;</span>,</span><br><span class="line">          <span class="comment">#参数必须以数组的形式传过去</span></span><br><span class="line">          <span class="string">&quot;parameters&quot;</span>:[url],</span><br><span class="line">          <span class="comment">#是否隐藏窗口</span></span><br><span class="line">          <span class="string">&quot;dontHideAfterAction&quot;</span>:<span class="literal">True</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">openUrl</span>(<span class="params">self,url</span>):</span></span><br><span class="line">    webbrowser.<span class="built_in">open</span>(url)</span><br><span class="line">    WoxAPI.change_query(url)</span><br><span class="line"></span><br><span class="line"><span class="comment">#以下代码是必须的</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">Main()</span><br></pre></td></tr></table></figure><p>上面这个例子就很典型，每次在Wox中输入就会调用query方法,其需要返回一个列表，列表中每一项内容如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">&quot;Title&quot;</span>: title ,</span><br><span class="line">        <span class="attr">&quot;SubTitle&quot;</span>:title,</span><br><span class="line">        <span class="attr">&quot;IcoPath&quot;</span>:<span class="string">&quot;Images/app.ico&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;JsonRPCAction&quot;</span>:&#123;</span><br><span class="line">          <span class="attr">&quot;method&quot;</span>: <span class="string">&quot;openUrl&quot;</span>,  </span><br><span class="line">          <span class="attr">&quot;parameters&quot;</span>:[url],</span><br><span class="line">          <span class="attr">&quot;dontHideAfterAction&quot;</span>:True</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2023/05/21/rqlJXwZEeTzhdIK.png" alt="image-20230521171823745"></p><p>其中,拿一个翻译插件来说，Title就是要点,SubTitle就是翻译结果,icoPath是左边图标的路径，我测试了必须使用本地文件，而JsonRPCAction就是按Enter键或鼠标左击后的响应，method就是触发的方法，可以自己写，也可以用wox.py<a href="https://github.com/Wox-launcher/Wox/blob/master/JsonRPC/wox.py">Wox/wox.py at master · Wox-launcher/Wox · GitHub</a>中的WoxAPI方法,parameters就是参数，要求传入一个列表.<code>dontHideAfterAction</code>表示点击之后Wox会不会隐藏.</p><p>此外还有个有意思的方法就是<code>context_menu</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">context_menu</span>(<span class="params">self, data</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    optional context menu entries for a result</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><p>就是鼠标右击或者Shift+Enter后的响应，<strong>需要注意的是</strong>,重载的必须是<code>context_menu(self, data)</code>,不能确少data参数，这个data可以在query方法中返回的结果里设置<code>ContextData</code>如下</p><p><img data-src="https://s2.loli.net/2023/05/22/Tu4YXj6OHxD9ngG.png" alt="image-20230522112012105" style="zoom:67%;" /></p><p>比如我在Context menu里添加一项<code>去我的博客看看</code>,下面两项是默认的.</p><p><img data-src="https://s2.loli.net/2023/05/22/vLZGqJ58NnWkBoi.png" alt="image-20230522113028138" style="zoom: 67%;" /></p><p>所以<code>query</code>和<code>context_menu</code>返回的结果就是展示的结果项目。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>像对于这种插件的开发个人认为是比较累的，debug比较麻烦,不能在终端直接显示，不像一般的客户端或者Web开发，所以日志还是很重要的，主要使用Python自带的logging模块.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 日志记录</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        filename = os.path.join(os.path.dirname(__file__), <span class="string">&#x27;log.txt&#x27;</span>)</span><br><span class="line">        logging.basicConfig(level=logging.DEBUG, filename=filename, filemode=<span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">                            <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#x27;</span>)</span><br><span class="line">        self.logger = logging.getLogger()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">self, msg</span>):</span></span><br><span class="line">        self.logger.debug(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self, msg</span>):</span></span><br><span class="line">        self.logger.info(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span>(<span class="params">self, msg</span>):</span></span><br><span class="line">        self.logger.error(msg)</span><br></pre></td></tr></table></figure><p>使用时初始化Logger,再掉用实例方法输出信息到文件.</p><h4 id="显示项目"><a href="#显示项目" class="headerlink" title="显示项目"></a>显示项目</h4><p>Wox插件机制叫做<a href="https://www.jsonrpc.org/specification">JSON-RPC 2.0 Specification (jsonrpc.org)</a>,利用这种方法将要展示的信息发给Wox并显示出来.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query</span>(<span class="params">self, key</span>):</span></span><br><span class="line">    self.results = []</span><br><span class="line">    logger = Logger()</span><br><span class="line">    logger.info(<span class="string">&quot;-------------info--------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">    args = key.split()</span><br><span class="line">    length = <span class="built_in">len</span>(args)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">        self.results.append(</span><br><span class="line">            self.add_item(<span class="string">&quot;有道智云翻译(正在开发中)&quot;</span>, <span class="string">&quot;需要配置key&quot;</span>, <span class="string">&#x27;Images/zhiyun.png&#x27;</span>, <span class="string">&quot;configyoudao&quot;</span>, <span class="string">&quot;zy&quot;</span>))</span><br><span class="line">        self.results.append(</span><br><span class="line">            self.add_item(<span class="string">&quot;使用有道翻译免费版本&quot;</span>, <span class="string">&quot;暂只支持中英互译&quot;</span>, <span class="string">&#x27;Images/youdao.png&#x27;</span>, <span class="string">&quot;freetrans&quot;</span>, <span class="string">&quot;yd&quot;</span>))</span><br><span class="line">        self.results.append(self.add_item(<span class="string">&quot;使用百度翻译&quot;</span>, <span class="string">&quot;需要配置key&quot;</span>, <span class="string">&#x27;Images/bd.png&#x27;</span>, <span class="string">&quot;configbaidu&quot;</span>, <span class="string">&quot;bd&quot;</span>))</span><br><span class="line">        self.results.append(self.add_item(<span class="string">&quot;重载插件&quot;</span>, <span class="string">&quot;重新加载插件&quot;</span>, <span class="string">&#x27;Images/pic.jpg&#x27;</span>, <span class="string">&quot;reload&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> self.results</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> self.results</span><br></pre></td></tr></table></figure><p>这是我写的部分代码，可以看到返回了一个列表，展示出来就是下面样子的</p><p><img data-src="https://s2.loli.net/2023/05/21/K5TBRAWYpmGbeaf.png" alt="image-20230521172551777"></p><p>可以通过显示项目的方法debug.</p><h3 id="响应方法"><a href="#响应方法" class="headerlink" title="响应方法"></a>响应方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">openUrl</span>(<span class="params">self, url</span>):</span></span><br><span class="line">    webbrowser.<span class="built_in">open</span>(url)</span><br><span class="line">    WoxAPI.change_query(url, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>在返回的项目中，<code>JsonRPCAction</code>的method就填方法名,可以写在一个类中，可以使用WoxAPI改变query也就是搜索的字符串，此外还有其他方法，<strong>注意</strong>，我测试的发现show_msg已经无法正常使用了</p><p><img data-src="https://s2.loli.net/2023/05/21/kwTv5QKbJtL716S.png" alt="image-20230521173212739" style="zoom:50%;" /></p><p><code>JsonRPCAction</code>的parameters传入的列表就对应method中的参数，比如传[1,2],而method中就可以使用method(a,b)来接收,当然也可以使用method(*para)用一个元组接收.</p><p><img data-src="https://s2.loli.net/2023/05/21/7FJRkB6H21wNcsL.png" alt="image-20230521174809680"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Python编写插件相关资料比较少,C#要多一点</li><li>可以参考这个文件的代码,还是不错的<a href="https://github.com/Wox-launcher/Wox/tree/master/Plugins/HelloWorldPython">Wox/Plugins/HelloWorldPython at master · Wox-launcher/Wox · GitHub</a></li><li>可以看看我的翻译插件,支持免费中英互译,也支持百度的有一定免费额度的API翻译，支持多种语言<br><img data-src="https://s2.loli.net/2023/05/21/zH9peMTlJg13GYU.png" alt="image-20230521173938835"><br><img data-src="https://s2.loli.net/2023/05/21/7CioWXbFr4nSx3d.png" alt="image-20230521174103179"></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/81568689#:~:text=virtualenv ：Python 虚拟环境管理工具。 venv ：Python 标准库内置的虚拟环境管理工具，Python 3.3 加入，Python,开始作为管理虚拟环境的推荐工具，用法类似 virtualenv。 如果你使用 Python 3，推荐使用 venv 来替代 virtualenv。">要不我们还是用回 virtualenv/venv 和 pip 吧 </a></li><li><a href="https://github.com/Wox-launcher/Wox/blob/master/JsonRPC/wox.py">Wox/wox.py at master · Wox-launcher/Wox · GitHub</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近正再使用Wox，这个软件还挺高效的，而且还能自己编写一些插件，这里打算自己写点插件用用.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>python的特别方法与装饰器</title>
    <link href="https://www.sekyoro.top/2023/05/07/python%E7%9A%84%E7%89%B9%E5%88%AB%E6%96%B9%E6%B3%95%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>https://www.sekyoro.top/2023/05/07/python%E7%9A%84%E7%89%B9%E5%88%AB%E6%96%B9%E6%B3%95%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/</id>
    <published>2023-05-07T03:31:24.000Z</published>
    <updated>2023-05-07T07:15:13.795Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这里将介绍python的所谓魔法方法以及装饰器<br><span id="more"></span></p><h3 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h3><p>一般在类中以双下划线包围的方法就是魔术方法，或者叫特殊方法。</p><p>简单来说，Python的魔术方法是为了利用Python的标准方法以及不用去记住标准操作的名称，实现更统一的接口。</p><p><img data-src="https://s2.loli.net/2023/05/07/2QCAj8iUIsNtrzO.png" alt="image-20230507133421451"></p><p>例如下面的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Card = collections.namedtuple(<span class="string">&#x27;Card&#x27;</span>, [<span class="string">&#x27;rank&#x27;</span>, <span class="string">&#x27;suit&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span>:</span></span><br><span class="line">    ranks = [<span class="built_in">str</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>)] + <span class="built_in">list</span>(<span class="string">&#x27;JQKA&#x27;</span>)</span><br><span class="line">    suits = <span class="string">&#x27;spades diamonds clubs hearts&#x27;</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                                        <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._cards[item]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(deck))</span><br><span class="line">    <span class="built_in">print</span>(deck[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><code>__len__</code>这个特别方法使得调用len(beer<em>card)实际调用`<em>_len</em></em>`</p><p> <strong>getitem</strong> 方法把 [] 操作交给了 self._cards 列表，所以我们的 deck 类自动支持切 片（slicing）操作。</p><p>输出如下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">52</span><br><span class="line">Card(<span class="attribute">rank</span>=<span class="string">&#x27;2&#x27;</span>, <span class="attribute">suit</span>=<span class="string">&#x27;spades&#x27;</span>)</span><br></pre></td></tr></table></figure><p>另外，仅仅实现了 <strong>getitem</strong> 方法，对象就变成可迭代的了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> deck:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2023/05/07/nBPSwYrg68y47Ff.png" alt="image-20230507134341143"></p><p>同时<code>__contains__</code>可以实现<code>in</code>方法</p><p>除了上面通过特殊方法实现迭代，len(),切片等方法外，还可以实现类似重载运算符的效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x=<span class="number">0</span>, y=<span class="number">0</span></span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Vector(%r, %r)&#x27;</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(<span class="built_in">abs</span>(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        x = self.x + other.x</span><br><span class="line">        y = self.y + other.y</span><br><span class="line">        <span class="keyword">return</span> Vector(x, y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span>(<span class="params">self, scalar</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.x * scalar, self.y * scalar)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v1 = Vector(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">v2 = Vector(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">v3 = v1+v2</span><br><span class="line"><span class="built_in">print</span>(v3)</span><br></pre></td></tr></table></figure><p>输出Vector(7, 9)</p><p>还有<code>__repr__</code>和<code>__str__</code></p><p><strong>repr</strong> 和 <strong>str</strong> 的区别在于，后者是在 str() 函数被使用，或是在用 print 函数打印一个对象的时候才被调用的，并且它返回的字符串对终端用户更友好。</p><p> 如果你只想实现这两个特殊方法中的一个，<strong>repr</strong> 是更好的选择，因为如果一个对象没有 <strong>str</strong> 函数，而 Python 又需要调用它的时候，解释器会用 <strong>repr</strong> 作为替代。</p><blockquote><ul><li><code>&#123;!r&#125;</code>就是使用format语法时候的<code>%r</code>。因此，我们只需要关注<code>%r</code>就好。</li><li><code>%r</code>表示的用<code>repr()</code>处理；类似于的<code>%s</code>表示用<code>str()</code>处理一样</li></ul></blockquote><p>其他特别方法</p><p><img data-src="https://s2.loli.net/2023/05/07/GpmoahVdxD1TNwL.png" alt="image-20230507134927018"></p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><blockquote><p>装饰器的作用就是为已经存在的函数或对象添加额外的功能。<br>装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure><p>装饰器涉及到闭包的概念,什么是闭包，一句话说就是，在函数中再嵌套一个函数，并且引用外部函数的变量，这就是一个闭包了</p><p>上述无参装饰器可以用于输出日志。</p><p>如果要在wrapper中访问参数,如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;params&quot;</span>, args, kwargs)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;this is a test function&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果要在装饰器中使用参数,还要在外面包围一层。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span>(<span class="params">level</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">outwrapper</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[&#123;0&#125;]: enter &#123;1&#125;()&quot;</span>.<span class="built_in">format</span>(level, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> outwrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(<span class="params">level=<span class="string">&quot;INFO&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br></pre></td></tr></table></figure><p>除了使用函数装饰器也可以是使用类装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logging</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func</span>):</span></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(self.func.__name__))</span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br></pre></td></tr></table></figure><p>装饰器中使用参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logging</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, level</span>):</span></span><br><span class="line">        self.level = level</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[&#123;0&#125;]: enter &#123;1&#125;()&quot;</span>.<span class="built_in">format</span>(self.level, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(<span class="params">level=<span class="string">&quot;TEST&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><blockquote><p>当我们创建一个类，以定义对象时，我们可能会希望一些属性对于外界是只读的，或者希望创建属性只能按特定的方式访问或修改。这时就可以使用 Python 中的属性（Property）。</p><p>在 Python 中，属性是包装在函数中的代码段，它们能够拦截对对象属性的访问和修改。Python 内置了@property 装饰器，可以用来修饰一个方法，使之成为属性调用。同时，Python 还提供了 @property 修饰器的对应方法的 setter 方法，用于设置属性。</p></blockquote><p>简单来说，属性优化了之前使用公共方法来访问私有属性得方法同时有更精细的粒度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myObj</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.__name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;init&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    obj = myObj(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(obj.name)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>如果使用<code>obj.name = &quot;world&quot;</code>更改属性则会报错.</p><p>添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@name.setter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self, newname</span>):</span></span><br><span class="line">     self.__name = newname</span><br></pre></td></tr></table></figure><p>可以通过name属性更改<code>self.__name</code></p><p>此外还有deleter</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@name.deleter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">     self.__name = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>使用del删除属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> obj.name</span><br><span class="line"><span class="built_in">print</span>(obj.name)</span><br></pre></td></tr></table></figure><p>输出就是<code>None</code></p><p>属性也可以通过property() 函数创建.</p><p>基本使用格式如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">属性名=property(<span class="attribute">fget</span>=None, <span class="attribute">fset</span>=None, <span class="attribute">fdel</span>=None, <span class="attribute">doc</span>=None)</span><br></pre></td></tr></table></figure><p>其中，fget 参数用于指定获取该属性值的类方法，fset 参数用于指定设置该属性值的方法，fdel 参数用于指定删除该属性值的方法，最后的 doc 是一个文档字符串，用于说明此函数的作用。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/329962624">Python常用魔术方法 - 知乎 (zhihu.com)</a></li><li>《流畅的Python》</li><li><a href="https://blog.csdn.net/luoz_java/article/details/90339876">Python基础（十四）—装饰器 wrapper_luoz_python的博客-CSDN博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/87353829">python 装饰器详解 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/366156798">Python @property属性详解 - 知乎 (zhihu.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;这里将介绍python的所谓魔法方法以及装饰器&lt;br&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://www.sekyoro.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python中的logging模块</title>
    <link href="https://www.sekyoro.top/2023/05/02/python%E4%B8%AD%E7%9A%84logging%E6%A8%A1%E5%9D%97/"/>
    <id>https://www.sekyoro.top/2023/05/02/python%E4%B8%AD%E7%9A%84logging%E6%A8%A1%E5%9D%97/</id>
    <published>2023-05-02T13:55:55.000Z</published>
    <updated>2023-05-03T15:09:24.034Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>开发一个程序或者软件使用日志记录是非常有用的,对于开发者DEBUG,维护以及有经验的程序使用者都可以根据日志判断软件出了什么问题以及能做什么.这里主要介绍使用Python的原生模块logging写日志.<br><span id="more"></span></p><h2 id="日志概念"><a href="#日志概念" class="headerlink" title="日志概念"></a>日志概念</h2><blockquote><p>日志是一种可以追踪某些软件运行时所发生事件的方法。软件开发人员可以向他们的代码中调用日志记录相关的方法来表明发生了某些事情。一个事件可以用一个可包含可选变量数据的消息来描述。</p><p>此外，事件也有重要性的概念，这个重要性也可以被称为严重性级别（level）。</p></blockquote><p>在部署项目时，不可能直接将所有的信息都输出到控制台中，我们可以将这些信息记录到日志文件中，这样不仅方便我们查看程序运行时的情况，也可以在项目出现故障时根据程序运行时产生的日志快速定位问题出现的位置。</p><p>日志等级,在python的logging模块中有以下几个等级以及等级的值</p><blockquote><p>CRITICAL = 50<br>FATAL = CRITICAL<br>ERROR = 40<br>WARNING = 30<br>WARN = WARNING<br>INFO = 20<br>DEBUG = 10<br>NOTSET = 0</p></blockquote><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line">logger = logging.getLogger(__name__)</span><br></pre></td></tr></table></figure><p>使用<code>basicConfig</code>进行基本配置,</p><p><img data-src="https://img.proanimer.com/imgs/02/05image-20230502221157465.png" alt="image-20230502221157465"></p><p>可以设置<code>filename</code>作为日志信息的输入文件.</p><p>可以创造多个 Logger 对象，但是真正输出日志的是root Logger 对象。每个 Logger 对象都可以设置一个名字，如果设置<code>logger = logging.getLogger(__name__)</code>，<strong>name</strong> 是 Python 中的一个特殊内置变量，他代表当前模块的名称（默认为 <strong>main</strong>）。则 Logger 对象的 name 为建议使用使用以点号作为分隔符的命名空间等级制度。</p><h3 id="Logging组件"><a href="#Logging组件" class="headerlink" title="Logging组件"></a>Logging组件</h3><div class="table-container"><table><thead><tr><th>组件名称</th><th>类名</th><th>描述</th></tr></thead><tbody><tr><td>日志器</td><td>Logger</td><td>提供程序一直使用的接口</td></tr><tr><td>处理器</td><td>Handler</td><td>将日志记录发送到合适的目的输出</td></tr><tr><td>过滤器</td><td>Filer</td><td>决定输出哪条日志记录</td></tr><tr><td>格式器</td><td>Formatter</td><td>决定日志记录的最终输出格式</td></tr></tbody></table></div><p>如果直接想要简单使用,可以直接使用<code>logging</code>对象,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.DEBUG,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&quot;%(asctime)s %(name)s %(levelname)s %(message)s&quot;</span>,</span><br><span class="line">                    datefmt = <span class="string">&#x27;%Y-%m-%d  %H:%M:%S %a&#x27;</span>   </span><br><span class="line">                    )</span><br><span class="line">logging.debug(<span class="string">&quot;msg1&quot;</span>)</span><br><span class="line">logging.info(<span class="string">&quot;msg2&quot;</span>)</span><br><span class="line">logging.warning(<span class="string">&quot;msg3&quot;</span>)</span><br><span class="line">logging.error(<span class="string">&quot;msg4&quot;</span>)</span><br><span class="line">logging.critical(<span class="string">&quot;msg5&quot;</span>)</span><br></pre></td></tr></table></figure><p>对于<code>format</code>的值</p><div class="table-container"><table><thead><tr><th>字段/属性名称</th><th>使用格式</th><th>描述</th></tr></thead><tbody><tr><td>asctime</td><td>%(asctime)s</td><td>将日志的时间构造成可读的形式，默认情况下是‘2016-02-08 12:00:00,123’精确到毫秒</td></tr><tr><td>name</td><td>%(name)s</td><td>所使用的日志器名称，默认是’root’，因为默认使用的是 rootLogger</td></tr><tr><td>filename</td><td>%(filename)s</td><td>调用日志输出函数的模块的文件名； pathname的文件名部分，包含文件后缀</td></tr><tr><td>funcName</td><td>%(funcName)s</td><td>由哪个function发出的log， 调用日志输出函数的函数名</td></tr><tr><td>levelname</td><td>%(levelname)s</td><td>日志的最终等级（被filter修改后的）</td></tr><tr><td>message</td><td>%(message)s</td><td>日志信息， 日志记录的文本内容</td></tr><tr><td>lineno</td><td>%(lineno)d</td><td>当前日志的行号， 调用日志输出函数的语句所在的代码行</td></tr><tr><td>levelno</td><td>%(levelno)s</td><td>该日志记录的数字形式的日志级别（10, 20, 30, 40, 50）</td></tr><tr><td>pathname</td><td>%(pathname)s</td><td>完整路径 ，调用日志输出函数的模块的完整路径名，可能没有</td></tr><tr><td>process</td><td>%(process)s</td><td>当前进程， 进程ID。可能没有</td></tr><tr><td>processName</td><td>%(processName)s</td><td>进程名称，Python 3.1新增</td></tr><tr><td>thread</td><td>%(thread)s</td><td>当前线程， 线程ID。可能没有</td></tr><tr><td>threadName</td><td>%(thread)s</td><td>线程名称</td></tr><tr><td>module</td><td>%(module)s</td><td>调用日志输出函数的模块名， filename的名称部分，不包含后缀即不包含文件后缀的文件名</td></tr><tr><td>created</td><td>%(created)f</td><td>当前时间，用UNIX标准的表示时间的浮点数表示； 日志事件发生的时间—时间戳，就是当时调用time.time()函数返回的值</td></tr><tr><td>relativeCreated</td><td>%(relativeCreated)d</td><td>输出日志信息时的，自Logger创建以 来的毫秒数； 日志事件发生的时间相对于logging模块加载时间的相对毫秒数</td></tr><tr><td>msecs</td><td>%(msecs)d</td><td>日志事件发生事件的毫秒部分。logging.basicConfig()中用了参数datefmt，将会去掉asctime中产生的毫秒部分，可以用这个加上</td></tr></tbody></table></div><p>对于<code>datefmt</code>字段,对应的是<code>format</code>字段的<code>%(asctime)s</code>,用于修改时间显示格式.</p><p><code>level</code>字段用于显示的<strong>最低等级</strong></p><p>总结来说,简单实用就是配置logging.basicConfig()（用默认日志格式（Formatter）为日志系统建立一个默认的流处理器（StreamHandler），设置基础配置（如日志级别等）并加到root logger（根Logger）中）这几个logging模块级别的函数。</p><h3 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h3><p>进阶使用跟上述的模块四大组件有关,</p><ul><li>日志器（logger）需要通过处理器（handler）将日志信息输出到目标位置，如：文件、sys.stdout、网络等；</li><li>不同的处理器（handler）可以将日志输出到不同的位置；</li><li>日志器（logger）可以设置多个处理器（handler）将同一条日志记录输出到不同的位置；</li><li>每个处理器（handler）都可以设置自己的过滤器（filter）实现日志过滤，从而只保留感兴趣的日志；</li><li>每个处理器（handler）都可以设置自己的格式器（formatter）实现同一条日志以不同的格式输出到不同的地方。</li></ul><h4 id="Logger类"><a href="#Logger类" class="headerlink" title="Logger类"></a>Logger类</h4><blockquote><p>Logger对象有3个任务要做：</p><ul><li>1）向应用程序代码暴露几个方法，使应用程序可以在运行时记录日志消息；</li><li>2）基于日志严重等级（默认的过滤设施）或filter对象来决定要对哪些日志进行后续处理；</li><li>3）将日志消息传送给所有感兴趣的日志handlers。</li></ul><p>Logger对象最常用的方法分为两类：配置方法 和 消息发送方法</p></blockquote><p>一般通过<code>logging.getLogger(__name__)</code>得到logger对象,然后通过<code>logger.setLevel</code>设置logger过滤的等级.</p><p>通过addHandler和addFilter添加处理器和过滤器.</p><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Logger.setLevel()</td><td>设置日志器将会处理的日志消息的最低严重级别</td></tr><tr><td>Logger.addHandler() 和 Logger.removeHandler()</td><td>为该logger对象添加 和 移除一个handler对象</td></tr><tr><td>Logger.addFilter() 和 Logger.removeFilter()</td><td>为该logger对象添加 和 移除一个filter对象</td></tr></tbody></table></div><p>使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;DEBUG&quot;</span>)</span><br><span class="line">logger.info(<span class="string">&quot;INFO&quot;</span>)</span><br><span class="line">logger.warning(<span class="string">&quot;WARNING&quot;</span>)</span><br><span class="line">logger.error(<span class="string">&quot;ERROR&quot;</span>)</span><br><span class="line">logger.critical(<span class="string">&quot;CRITICAL&quot;</span>)</span><br><span class="line">logger.log(<span class="number">15</span>,<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>常用的就是info,debug,warning,error几种日志等级,也可以通过logger.log设置自己的日志等级和消息.</p><h4 id="Handler类"><a href="#Handler类" class="headerlink" title="Handler类"></a>Handler类</h4><p>Handler对象的作用是（基于日志消息的level）将消息分发到handler指定的位置（文件、网络、邮件等）。Logger对象可以通过addHandler()方法为自己添加0个或者更多个handler对象。比如，一个应用程序可能想要实现以下几个日志需求：</p><ul><li>1）把所有日志都发送到一个日志文件中；</li><li>2）把所有严重级别大于等于error的日志发送到stdout（标准输出）；</li><li>3）把所有严重级别为critical的日志发送到一个email邮件地址。这种场景就需要3个不同的handlers，每个handler复杂发送一个特定严重级别的日志到一个特定的位置。</li></ul><p>Handler一般使用StreamHandler和FileHandler用于输入到Stream和磁盘文件.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">handler = logging.StreamHandler()</span><br><span class="line">logger.addHandler(handler)</span><br></pre></td></tr></table></figure><p>handler也可以设置level,过滤通过了logger的日志,此外handler也可以设置Filter用于更细致的过滤以及设置Formatter用于输出格式.</p><div class="table-container"><table><thead><tr><th>Handler</th><th>描述</th></tr></thead><tbody><tr><td>logging.StreamHandler</td><td>将日志消息发送到输出到Stream，如std.out, std.err或任何file-like对象。</td></tr><tr><td>logging.FileHandler</td><td>将日志消息发送到磁盘文件，默认情况下文件大小会无限增长</td></tr><tr><td>logging.handlers.RotatingFileHandler</td><td>将日志消息发送到磁盘文件，并支持日志文件按大小切割</td></tr><tr><td>logging.hanlders.TimedRotatingFileHandler</td><td>将日志消息发送到磁盘文件，并支持日志文件按时间切割</td></tr><tr><td>logging.handlers.HTTPHandler</td><td>将日志消息以GET或POST的方式发送给一个HTTP服务器</td></tr><tr><td>logging.handlers.SMTPHandler</td><td>将日志消息发送给一个指定的email地址</td></tr><tr><td>logging.NullHandler</td><td>该Handler实例会忽略error messages，通常被想使用logging的library开发者使用来避免’No handlers could be found for logger XXX’信息的出现。</td></tr></tbody></table></div><h4 id="Formatter类"><a href="#Formatter类" class="headerlink" title="Formatter类"></a>Formatter类</h4><p>常用的两个参数是</p><ul><li>fmt：指定消息格式化字符串，如果不指定该参数则默认使用message的原始值</li><li>datefmt：指定日期格式字符串，如果不指定该参数则默认使用”%Y-%m-%d %H:%M:%S”</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">formatter = logging.Formatter(<span class="string">&#x27;Hello %(message)s&#x27;</span>)</span><br><span class="line">handler.setFormatter(formatter)</span><br></pre></td></tr></table></figure><p><img data-src="https://img.proanimer.com/imgs/03/05image-20230503222936462.png" alt="image-20230503222936462"></p><h4 id="Filter类"><a href="#Filter类" class="headerlink" title="Filter类"></a>Filter类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoParsingFilter</span>(<span class="params">logging.Filter</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">filter</span>(<span class="params">self, record</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(record.getMessage())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> record.getMessage().startswith(<span class="string">&#x27;parsing&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter_grammar_messages</span>(<span class="params">record</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(record.funcName,<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> record.funcName == <span class="string">&#x27;load_grammar&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>可以使用类或者函数作为Filter</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logger.addFilter(NoParsingFilter())</span><br><span class="line">logger.addFilter(filter_grammar_messages)</span><br></pre></td></tr></table></figure><p>同时也可以在类中的初始化函数设置类的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filter</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Filter instances are used to perform arbitrary filtering of LogRecords.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Loggers and Handlers can optionally use Filter instances to filter</span></span><br><span class="line"><span class="string">    records as desired. The base filter class only allows events which are</span></span><br><span class="line"><span class="string">    below a certain point in the logger hierarchy. For example, a filter</span></span><br><span class="line"><span class="string">    initialized with &quot;A.B&quot; will allow events logged by loggers &quot;A.B&quot;,</span></span><br><span class="line"><span class="string">    &quot;A.B.C&quot;, &quot;A.B.C.D&quot;, &quot;A.B.D&quot; etc. but not &quot;A.BB&quot;, &quot;B.A.B&quot; etc. If</span></span><br><span class="line"><span class="string">    initialized with the empty string, all events are passed.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize a filter.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Initialize with the name of the logger which, together with its</span></span><br><span class="line"><span class="string">        children, will have its events allowed through the filter. If no</span></span><br><span class="line"><span class="string">        name is specified, allow every event.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.nlen = <span class="built_in">len</span>(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">filter</span>(<span class="params">self, record</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Determine if the specified record is to be logged.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Is the specified record to be logged? Returns 0 for no, nonzero for</span></span><br><span class="line"><span class="string">        yes. If deemed appropriate, the record may be modified in-place.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.nlen == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> self.name == record.name:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> record.name.find(self.name, <span class="number">0</span>, self.nlen) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> (record.name[self.nlen] == <span class="string">&quot;.&quot;</span>)</span><br></pre></td></tr></table></figure><p>注意Filter也有默认行为,过滤行为设计到初始化的Filer,这里就不细说了.</p><blockquote><h3 id="日志流处理简要流程"><a href="#日志流处理简要流程" class="headerlink" title="日志流处理简要流程"></a>日志流处理简要流程</h3><p>1、创建一个logger</p><p>2、设置下logger的日志的等级</p><p>3、创建合适的Handler(FileHandler要有路径)</p><p>4、设置下每个Handler的日志等级</p><p>5、创建下日志的格式</p><p>6、向Handler中添加上面创建的格式</p><p>7、将上面创建的Handler添加到logger中</p><p>8、打印输出logger.debug\logger.info\logger.warning\logger.error\logger.critical</p></blockquote><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li>重复写日志问题</li></ol><blockquote><p>用Python的logging模块记录日志时，可能会遇到重复记录日志的问题，第一条记录写一次，第二条记录写两次，第三条记录写三次</p></blockquote><p>原因:：第二次调用log的时候，根据getLogger(name)里的name获取同一个logger，而这个logger里已经有了第一次你添加的handler，第二次调用又添加了一个handler，所以，这个logger里有了两个同样的handler，以此类推，调用几次就会有几个handler。</p><p> 解决办法:1. 最后移除handler 2.做判断,若logger已有handler,则不再添加handler</p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">#解决方案1，添加removeHandler语句，每次用完之后移除Handler</span></span><br><span class="line">logger.removeHandler(fh)</span><br><span class="line">logger.removeHandler(ch)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> logger.handlers:</span><br><span class="line">        <span class="comment">#创建handler</span></span><br><span class="line">    fh = logging.FileHandler(<span class="string">&quot;test.log&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    ch = logging.StreamHandler()</span><br><span class="line">​</span><br><span class="line">        <span class="comment">#设置输出日志格式</span></span><br><span class="line">     formatter = logging.Formatter(</span><br><span class="line">            fmt=<span class="string">&quot;%(asctime)s %(name)s %(filename)s %(message)s&quot;</span>,</span><br><span class="line">            datefmt=<span class="string">&quot;%Y/%m/%d %X&quot;</span></span><br><span class="line">            )</span><br></pre></td></tr></table></figure><h3 id="logging配置文件"><a href="#logging配置文件" class="headerlink" title="logging配置文件"></a>logging配置文件</h3><p>可以使用<code>logging.conf.fileconf</code>进行配置logging</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging.config</span><br><span class="line">logging.config.fileConfig(<span class="string">&#x27;logging.conf&#x27;</span>)</span><br></pre></td></tr></table></figure><p>下面是一个<code>logging.conf</code>文件demo</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">文件配置</span><br><span class="line">配置文件logging.conf如下:</span><br><span class="line">[loggers]</span><br><span class="line"><span class="attribute">keys</span>=root,example01</span><br><span class="line"></span><br><span class="line">[logger_root]</span><br><span class="line"><span class="attribute">level</span>=DEBUG</span><br><span class="line"><span class="attribute">handlers</span>=hand01,hand02</span><br><span class="line"></span><br><span class="line">[logger_example01]</span><br><span class="line"><span class="attribute">handlers</span>=hand01,hand02</span><br><span class="line"><span class="attribute">qualname</span>=example01</span><br><span class="line"><span class="attribute">propagate</span>=0</span><br><span class="line"></span><br><span class="line">[handlers]</span><br><span class="line"><span class="attribute">keys</span>=hand01,hand02</span><br><span class="line"></span><br><span class="line">[handler_hand01]</span><br><span class="line"><span class="attribute">class</span>=StreamHandler</span><br><span class="line"><span class="attribute">level</span>=INFO</span><br><span class="line"><span class="attribute">formatter</span>=form02</span><br><span class="line">args=(sys.stderr,)</span><br><span class="line"></span><br><span class="line">[handler_hand02]</span><br><span class="line"><span class="attribute">class</span>=FileHandler</span><br><span class="line"><span class="attribute">level</span>=DEBUG</span><br><span class="line"><span class="attribute">formatter</span>=form01</span><br><span class="line">args=(<span class="string">&#x27;log.log&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">[formatters]</span><br><span class="line"><span class="attribute">keys</span>=form01,form02</span><br><span class="line"></span><br><span class="line">[formatter_form01]</span><br><span class="line"><span class="attribute">format</span>=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s```</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/445411809">最棒总结！Python日志库 logging 使用指南来了 - 知乎 (zhihu.com)</a></li><li><a href="https://www.cnblogs.com/yuanyongqiang/p/11913812.html#_label0">Python3 日志(内置logging模块) - 天马行宇 - 博客园 (cnblogs.com)</a></li><li><a href="https://www.jianshu.com/p/feb86c06c4f4">python logging模块使用教程 - 简书 (jianshu.com)</a></li><li><a href="https://www.cnblogs.com/yyds/p/6901864.html">Python之日志处理（logging模块） - 云游道士 - 博客园 (cnblogs.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;开发一个程序或者软件使用日志记录是非常有用的,对于开发者DEBUG,维护以及有经验的程序使用者都可以根据日志判断软件出了什么问题以及能做什么.这里主要介绍使用Python的原生模块logging写日志.&lt;br&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://www.sekyoro.top/tags/python/"/>
    
    <category term="logging" scheme="https://www.sekyoro.top/tags/logging/"/>
    
    <category term="日志" scheme="https://www.sekyoro.top/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>如何使用word组织一篇学术垃圾</title>
    <link href="https://www.sekyoro.top/2023/04/07/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8word%E7%BB%84%E7%BB%87%E4%B8%80%E7%AF%87%E5%AD%A6%E6%9C%AF%E5%9E%83%E5%9C%BE/"/>
    <id>https://www.sekyoro.top/2023/04/07/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8word%E7%BB%84%E7%BB%87%E4%B8%80%E7%AF%87%E5%AD%A6%E6%9C%AF%E5%9E%83%E5%9C%BE/</id>
    <published>2023-04-07T03:57:06.000Z</published>
    <updated>2023-04-11T07:57:00.463Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>简单来说就是word样式设置</p><span id="more"></span><h3 id="设置标题样式"><a href="#设置标题样式" class="headerlink" title="设置标题样式"></a>设置标题样式</h3><p><img data-src="https://s2.loli.net/2023/04/08/ebjiD7yvBS63HCW.png" alt="image-20230408221018455" style="zoom:50%;" /></p><p><img data-src="https://s2.loli.net/2023/04/08/PfaiO9EkbVGl7Up.png" alt="image-20230408221508064" style="zoom:50%;" /></p><p><img data-src="https://s2.loli.net/2023/04/08/OYpf3ti2mgGLKbR.png" alt="image-20230408221523407" style="zoom:50%;" /></p><h3 id="设置多级列表"><a href="#设置多级列表" class="headerlink" title="设置多级列表"></a>设置多级列表</h3><h3 id="题注和引用"><a href="#题注和引用" class="headerlink" title="题注和引用"></a>题注和引用</h3><h3 id="制作三线表"><a href="#制作三线表" class="headerlink" title="制作三线表"></a>制作三线表</h3><p>表格的应用</p><p><img data-src="https://s2.loli.net/2023/04/11/FshAErVzwxaZIOQ.png" alt="image-20230411155154936" style="zoom:67%;" /></p><p><img data-src="https://s2.loli.net/2023/04/11/3PKRuZlpk8wAQvN.png" alt="image-20230411155204407"></p><h3 id="插入参考文献"><a href="#插入参考文献" class="headerlink" title="插入参考文献"></a>插入参考文献</h3><p>EndNote或Zotero</p><h3 id="生成目录"><a href="#生成目录" class="headerlink" title="生成目录"></a>生成目录</h3><h3 id="设置页码"><a href="#设置页码" class="headerlink" title="设置页码"></a>设置页码</h3><h3 id="导出pdf"><a href="#导出pdf" class="headerlink" title="导出pdf"></a>导出pdf</h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单来说就是word样式设置&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>mne处理脑电数据基本使用</title>
    <link href="https://www.sekyoro.top/2023/04/04/mne%E5%A4%84%E7%90%86%E8%84%91%E7%94%B5%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.sekyoro.top/2023/04/04/mne%E5%A4%84%E7%90%86%E8%84%91%E7%94%B5%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2023-04-04T06:40:57.000Z</published>
    <updated>2023-05-03T04:05:43.495Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近的东西,不定期更新<br><span id="more"></span></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>一般处理脑电数据的工具有matlab的EEGlab和python的相关包工具,当然事实上有很多类似的工具.本人现在只接触了这些.</p><p>EEGLAB的使用这里不详细说了,比较方便的是其有方便的GUI,当然后面我也发现python也有相关的带GUI的EEG数据处理包.</p><p>这里主要介绍MNE同时也会搭配一些机器学习算法等.<a href="[Documentation overview — MNE 1.3.1 documentation](https://mne.tools/stable/overview/index.html">MNE官网</a>)</p><p><a href="[Glossary — MNE 1.3.1 documentation](https://mne.tools/stable/glossary.html">一些概念介绍</a>)</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>主要包括设置电极位置,重参考,降采样,滤波,使用ICA方法去除伪迹等.</p><h3 id="划分数据集"><a href="#划分数据集" class="headerlink" title="划分数据集"></a>划分数据集</h3><p>将数据集划分话训练集和测试集,主要使用sklearn工具包</p><p>可以直接使用<code>train_test_split</code>分割训练集,就是简单的按比例分割,可以先打乱</p><blockquote><p>import numpy as np<br>from sklearn.model_selection import train_test_split</p><h1 id="创建一个数据集X和相应的标签y-X中样本数目为100"><a href="#创建一个数据集X和相应的标签y-X中样本数目为100" class="headerlink" title="创建一个数据集X和相应的标签y,X中样本数目为100"></a>创建一个数据集X和相应的标签y,X中样本数目为100</h1><p>X, y = np.arange(200).reshape((100, 2)), range(100)</p><h1 id="用train-test-split函数划分出训练集和测试集，测试集占比0-33"><a href="#用train-test-split函数划分出训练集和测试集，测试集占比0-33" class="headerlink" title="用train_test_split函数划分出训练集和测试集，测试集占比0.33"></a>用train_test_split函数划分出训练集和测试集，测试集占比0.33</h1><p>X_train, X_test, y_train, y_test = train_test_split( X, y, test_size=0.33, random_state=42)</p><h1 id="打印出原始样本集、训练集和测试集的数目"><a href="#打印出原始样本集、训练集和测试集的数目" class="headerlink" title="打印出原始样本集、训练集和测试集的数目"></a>打印出原始样本集、训练集和测试集的数目</h1><p>print(“The length of original data X is:”, X.shape[0])<br>print(“The length of train Data is:”, X_train.shape[0])<br>print(“The length of test Data is:”, X_test.shape[0])</p></blockquote><p>但是一般用交叉验证划分比较多,比如<code>KFold</code>和<code>ShuffleSplit</code>.</p><p>这类包一般在<code>sklearn.model_selection</code>中,使用KFold等处理一个对象的运动想象任务的数据集划分,使用GroupKFold等处理对象间数据集划分. 也就是说可以使用GoupKFold,LeaveOneGoupOut处理跨对象的数据.</p><p>同时搭配<code>GridSearchCV</code>用于调整超参数,获得较好的模型.</p><h3 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://www.cnblogs.com/hellcat/p/7045585.html">『Sklearn』数据划分方法 - 叠加态的猫 - 博客园 (cnblogs.com)</a></li></ol><h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://mne.tools/stable/overview/index.html">Documentation overview — MNE 1.3.1 documentation</a></li><li><a href="https://github.com/ZitongLu1996/Python-EEG-Handbook">ZitongLu1996/Python-EEG-Handbook: Python脑电数据处理中文手册 - A Chinese handbook for EEG data analysis based on Python (github.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近的东西,不定期更新&lt;br&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://www.sekyoro.top/tags/python/"/>
    
    <category term="MNE" scheme="https://www.sekyoro.top/tags/MNE/"/>
    
    <category term="EEG" scheme="https://www.sekyoro.top/tags/EEG/"/>
    
  </entry>
  
  <entry>
    <title>EndNote基本使用</title>
    <link href="https://www.sekyoro.top/2023/04/02/EndNote%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.sekyoro.top/2023/04/02/EndNote%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2023-04-02T11:45:33.000Z</published>
    <updated>2023-04-02T13:27:30.413Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>之前讲过使用Zotero管理并阅读文献,现在写论文的使用为了方便管理插入文献,这里使用EndNote管理.<br><span id="more"></span></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>Endnote是一款被广泛使用的文献管理软件，其是<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/SCI/18829">SCI</a>（Thomson Scientific 公司）的官方软件，支持国际期刊的参考文献格式有3776 种【也可以自定义期刊引用格式】。</p><p>软件非常方便科研狗进行文献整理，写笔记，做备注，分类，导出期刊格式，进行数据迁移【这个特别方便，可以随时将其他电脑上的文献导入到自己的电脑中】</p></blockquote><p>EndNote版本特别多,我目前用的是EndNote20,不过其他版本也类似.</p><p><a href="https://link.zhihu.com/?target=https%3A//its.tsinghua.edu.cn/column/bgrj/2">下载地址</a></p><p>注意下载的时候有一个添加的word选项勾上即可.</p><p>下面简单地介绍其使用</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="创建Library"><a href="#创建Library" class="headerlink" title="创建Library"></a>创建Library</h3><p><img data-src="http://cdn.sekyoro.top/imgs/02/0420230402200455.png" alt="image-20230402200448244" style="zoom:50%;" /></p><p>一个Library用于存放文献以及笔记.可以对文献进行分组.</p><p><img data-src="https://pic2.zhimg.com/80/v2-959f0acb60032ef5c334118a1f5b9a2d_720w.webp" alt="img" style="zoom:67%;" /></p><p>这里我以Pub Med的一篇文章导入为例</p><p><img data-src="http://cdn.sekyoro.top/imgs/02/0420230402200702.png" alt="image-20230402200702560" style="zoom: 50%;" /></p><p>下载好文件即可选择导入</p><p><img data-src="http://cdn.sekyoro.top/imgs/02/0420230402200741.png" alt="image-20230402200740915" style="zoom:50%;" /></p><p>由于这里是Pub Med格式,导入时还需要选择Filter</p><p><img data-src="http://cdn.sekyoro.top/imgs/02/0420230402201909.png" alt="image-20230402201908947" style="zoom:50%;" /></p><p>这里推荐尝试使用EndNote打开这个文件,也会导入到Library中,更加简单.</p><p>当然还可以直接通过自己填写信息添加文献,不过我推荐就使用上面的方式即可.</p><p><img data-src="http://cdn.sekyoro.top/imgs/02/0420230402202743.png" alt="image-20230402202743736" style="zoom:50%;" /></p><h3 id="文献目录"><a href="#文献目录" class="headerlink" title="文献目录"></a>文献目录</h3><p>导入文献后常常需要对文献进行分类.</p><p>创建好一个Library后默认会有一个Group Set,这个是删除不掉的.我一般在这个set里创建group</p><p>然后将文献添加到group中.</p><p><img data-src="http://cdn.sekyoro.top/imgs/02/0420230402203123.png" alt="image-20230402203122928" style="zoom:50%;" /></p><h3 id="添加笔记"><a href="#添加笔记" class="headerlink" title="添加笔记"></a>添加笔记</h3><p>右键点击文献,选择Edit Reference,点击Summary,选择Attach file链接笔记文件即可.</p><p><img data-src="http://cdn.sekyoro.top/imgs/02/0420230402204815.png" alt="image-20230402204815649" style="zoom:50%;" /></p><p>同时添加pdf也是类似.</p><h3 id="设置参考文献格式"><a href="#设置参考文献格式" class="headerlink" title="设置参考文献格式"></a>设置参考文献格式</h3><p><img data-src="http://cdn.sekyoro.top/imgs/02/0420230402204250.png" alt="image-20230402204250594" style="zoom:50%;" /></p><p>插入论文的文献格式设置,可以去<a href="https://www.endnote.com/">https://www.EndNote.com/</a> 下载想要的格式</p><h3 id="本地迁移"><a href="#本地迁移" class="headerlink" title="本地迁移"></a>本地迁移</h3><p>使用压缩功能把当前文献库报错,如果需要迁移到另一个电脑,选择上方菜单栏中的【File】-【Compress Library.enlx】</p><p><img data-src="http://cdn.sekyoro.top/imgs/02/0420230402205005.png" alt="image-20230402205005519" style="zoom:50%;" /></p><p>如果双击打开这个压缩文件，会自动生成一个文件「测试.enl」和一个文件夹「测试.Data」，这样又会自动还原为正常的数据库文件。</p><h3 id="与Word一起使用"><a href="#与Word一起使用" class="headerlink" title="与Word一起使用"></a>与Word一起使用</h3><p>在下载时记得勾选与Word联动,如果忘了可以查看下载目录</p><p><img data-src="http://cdn.sekyoro.top/imgs/02/0420230402205432.png" alt="image-20230402205432273"></p><p>点击这个config endnote.exe进行设置.</p><p>配置后Word中就有相关选项</p><p><img data-src="http://cdn.sekyoro.top/imgs/02/0420230402210145.png" alt="image-20230402210145730"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/110516363">还不会EndNote？超详细教程来了！ - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/65652207">[EndNote]导入PubMed数据库文献方法 - 知乎 (zhihu.com)</a></li><li><a href="https://www.cnblogs.com/vmware-com/p/12244995.html#:~:text=1，首先在电脑上打开word2019，点击左上角的“文件”菜单。 2，然后在打开的文件菜单中点击“选项”的快捷链接。,3，接下来在打开的Word选项窗口中点击左侧边栏的“加载项”的菜单项。 4，在右侧的窗口中点击com加载项后面的“转到”按钮。 5，接下来就会弹出COM加载项的窗口，在窗口中找到并勾选Endnote的选项。">如何将EndNote 和 Word (office)连接起来 - VMWARE_COM - 博客园 (cnblogs.com)</a></li><li><a href="https://www.jianshu.com/p/ffb7ee272457">Endnote20文献管理软件使用教程 - 简书 (jianshu.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前讲过使用Zotero管理并阅读文献,现在写论文的使用为了方便管理插入文献,这里使用EndNote管理.&lt;br&gt;</summary>
    
    
    
    
    <category term="paper" scheme="https://www.sekyoro.top/tags/paper/"/>
    
    <category term="thesis" scheme="https://www.sekyoro.top/tags/thesis/"/>
    
  </entry>
  
  <entry>
    <title>服务器结合OSS存储用于自动录播</title>
    <link href="https://www.sekyoro.top/2023/04/01/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%93%E5%90%88OSS%E5%AD%98%E5%82%A8%E7%94%A8%E4%BA%8E%E8%87%AA%E5%8A%A8%E5%BD%95%E6%92%AD/"/>
    <id>https://www.sekyoro.top/2023/04/01/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%93%E5%90%88OSS%E5%AD%98%E5%82%A8%E7%94%A8%E4%BA%8E%E8%87%AA%E5%8A%A8%E5%BD%95%E6%92%AD/</id>
    <published>2023-04-01T05:19:46.000Z</published>
    <updated>2023-04-16T09:24:04.851Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>搭建一个自动录播平台,录播的内容存储到云盘中.使用B站录播姬+OSS对象存储+服务器<br><span id="more"></span><br>之前买过一台廉价的服务器,只有40G的云盘存储,再想增加存储加个40G的云盘</p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401132610.png" alt="image-20230401132603630"></p><p>看见价格还是算了,所以考虑使用OSS对象存储.</p><p>1、对象存储一般可以单独使用，无需跟云主机进行组合搭配，而云硬盘则必须跟云主机同时使用，无法单独使用。</p><p>2、对象存储是可以共享的，而云硬盘一般无法共享，即便可以共享，操作起来也是非常复杂。</p><p>3、两者最大的差别在于一个是本地局域网内的存储方式，而另一个是使用云端服务器。简单来说一个是局域网，一个是公网；一个是存储设备，一个就是一个云端硬盘。</p><p>所以选择OSS存储.</p><h2 id="购买OSS对象存储"><a href="#购买OSS对象存储" class="headerlink" title="购买OSS对象存储"></a>购买OSS对象存储</h2><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401132832.png" alt="image-20230401132831841" style="zoom:50%;" /></p><p>创建bucket,这个地域选择与OSS对象存储一样的区域.</p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401134520.png" alt="image-20230401134520599" style="zoom:50%;" /></p><p>接下来尝试将OSS的bucket作为服务器的文件系统,也就是bucket在服务器上访问.</p><blockquote><p>OSS以目录的方式挂载到ECS实例，可通过以下两种方法进行实现：</p><ul><li>通过配置云存储网关来实现，详情请参见<a href="https://help.aliyun.com/document_detail/134092.htm?spm=a2c4g.11186623.0.0.740f1e4f2KpgFK">通过云存储网关挂载OSS</a>。</li><li>如没有云存储网关，您也可通过ossfs命令行的方式，将存储空间下的某个文件目录挂载到本地文件系统。详情请参见以下方案：<ul><li><a href="https://help.aliyun.com/document_detail/153893.htm?spm=a2c4g.11186623.0.0.740f1e4f2KpgFK">使用ossfs挂载指定文件目录</a></li><li><a href="https://help.aliyun.com/document_detail/39524.htm">ossfs如何通过非root用户挂载Bucket到ECS实例</a></li></ul></li></ul></blockquote><p>第一种方法的前提条件,要求ECS的地域与OSS同地域,<del>这里不满足所以采用第二种方法</del>后面发现如果想让服务器跟OSS存储联动,最好还是选择同地域的,因为我发现我服务器在国内,OSS放在新加坡,内网是ping不通的.下面两种方法都介绍一下,推荐使用云存储网关.</p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401135037.png" alt="image-20230401135037647"></p><h2 id="挂载对象存储到服务器"><a href="#挂载对象存储到服务器" class="headerlink" title="挂载对象存储到服务器"></a>挂载对象存储到服务器</h2><p><strong>使用ossfs挂载</strong></p><h3 id="安装ossfs"><a href="#安装ossfs" class="headerlink" title="安装ossfs"></a>安装ossfs</h3><p>首先在阿里云上查看你的操作系统,这里以Centos8.0为标准</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget http://gosspublic.alicdn.com/ossfs/ossfs_1.80.7_centos8.0_x86_64.rpm</span><br></pre></td></tr></table></figure><p>安装后下载</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install ossfs_1.80.7_centos8.0_x86_64.rpm</span><br></pre></td></tr></table></figure><h3 id="配置账号信息"><a href="#配置账号信息" class="headerlink" title="配置账号信息"></a>配置账号信息</h3><blockquote><p>通过ossfs访问OSS存储空间时，需要配置账号信息，也就是AccessKey ID和AccessKey Secret。这些账号信息需要按照特定的格式写到账号配置文件中。当挂载ossfs时，会从这个账号配置文件上获取账号信息，格式为<code>$bucket_name:$access_key_id:$access_key_secret</code>。</p></blockquote><p>access key可以使用<strong>RAM用户</strong>或者阿里云账号.我之前创建了<strong>阿里云账号的AccessKey</strong>,由于阿里提醒说有安全问题让我用RAM用户,这里就再创建一个用户使用AccessKey.</p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401141144.png" alt="image-20230401141143831" style="zoom:50%;" /></p><p>如果使用RAM角色访问,需要先创建角色</p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401150541.png" alt="image-20230401150541565" style="zoom:50%;" /></p><p><strong>创建角色</strong></p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401150651.png" alt="image-20230401150651605" style="zoom:50%;" /></p><p><strong>然后为角色添加权限</strong></p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401150816.png" alt="image-20230401150815904" style="zoom:50%;" /></p><p><strong>为实例添加角色</strong></p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401150907.png" alt="image-20230401150907529" style="zoom:50%;" /></p><blockquote><p>通过ossfs访问OSS存储空间时，需要配置账号信息，也就是AccessKey ID和AccessKey Secret。这些账号信息需要按照特定的格式写到账号配置文件中。当挂载ossfs时，会从这个账号配置文件上获取账号信息，格式为<code>$bucket_name:$access_key_id:$access_key_secret</code></p></blockquote><p>完成上述要求后需要配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ossfs bucket1 /tmp/ossfs -ourl=http://oss-cn-hangzhou.aliyuncs.com -oram_role=http://100.100.100.200/latest/meta-data/ram/security-credentials/EcsRamRoleOssTest</span><br></pre></td></tr></table></figure><p>命令类似.也就是将账号信息配置到一个目录中,默认账号配置文件的默认路径为/etc/passwd-ossfs.账号配置文件的默认路径为/etc/passwd-ossfs</p><p>如果使用阿里云账户的AccessKey</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> bucket-test-1:AAAIbZcdVCmQ****:AAA8x0y9hxQ31coh7A5e2MZEUz**** &gt; /etc/passwd-ossfs</span><br></pre></td></tr></table></figure><p>配置好后进行挂载,bucket的内网测试是能ping通的.</p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401152415.png" alt="image-20230401152412179"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ossfs bili-record /home/files/bili-record -ourl=http://oss-ap-southeast-1-internal.aliyuncs.com</span><br></pre></td></tr></table></figure><p>这里是内网访问</p><p><strong>卸载</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fusermount -u /tmp/ossfs</span><br></pre></td></tr></table></figure><h3 id="通过云存储网关挂载"><a href="#通过云存储网关挂载" class="headerlink" title="通过云存储网关挂载"></a>通过云存储网关挂载</h3><p><a href="https://help.aliyun.com/document_detail/134092.htm?spm=a2c4g.11186623.0.0.740f36b5JO1KZv">通过云存储网关挂载OSS (aliyun.com)</a></p><p>还需要付费</p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401152902.png" alt="image-20230401152901650" style="zoom:50%;" /></p><h3 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h3><ol><li><p>在centos系统中,在/etc/init.d/目录下建立文件ossfs,内容为挂载指令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ossfs bili-record /home/files/bili-record -ourl=http://oss-ap-southeast-1-internal.aliyuncs.com</span><br></pre></td></tr></table></figure></li></ol><p>2.赋予可执行权限</p>   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x /etc/init.d/ossfs</span><br></pre></td></tr></table></figure><p>3.把ossfs启动脚本作为其他服务，开机自动启动：</p>   <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig ossfs <span class="keyword">on</span></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在网站上上传文件,然后查看服务器</p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401155033.png" alt="image-20230401155032846" style="zoom:50%;" /></p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401155048.png" alt="image-20230401155048241" style="zoom:67%;" /></p><h2 id="增加域名管理"><a href="#增加域名管理" class="headerlink" title="增加域名管理"></a>增加域名管理</h2><blockquote><p>文件（Object）上传至存储空间（Bucket）后，OSS会自动生成文件URL，您可以直接通过文件URL（即Bucket外网访问域名）访问该文件。若您希望通过自定义域名（自有域名）访问这些文件，需要将自定义域名绑定至文件所在的Bucket。</p><p>域名信息更新需 1 分钟左右的时间，CD</p></blockquote><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401155607.png" alt="image-20230401155607206" style="zoom:50%;" /></p><p>在域名服务商配置即可,这里不详细说了.</p><h2 id="使用B站录播姬"><a href="#使用B站录播姬" class="headerlink" title="使用B站录播姬"></a>使用B站录播姬</h2><p><a href="https://rec.danmuji.org/">B站录播姬 (danmuji.org)</a>官网</p><p>我这里使用docker版本,首先拉取镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull bililive/recorder:latest</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制粘贴运行之前记得修改  &quot;宿主机路径&quot;</span></span><br><span class="line">docker run -d -v 宿主机路径:/rec -p 2356:2356 bililive/recorder</span><br></pre></td></tr></table></figure><ol><li><code>/rec</code> ：作为 <code>&quot;工作目录&quot;</code> ，用于存储录播配置和录播 <code>.flv</code> 视频文件。</li><li><code>/ssl</code> ：作为 Nginx 证书存储目录。</li><li><code>/file</code> ：官方文档中指出：</li></ol><p>由于安全问题,这里增加HTTP Basic登录功能</p><p><strong>配置文件</strong></p><p><a href="https://rec.danmuji.org/user/settings/">设置项 - B站录播姬 (danmuji.org)</a></p><p>由于配置文件json还挺麻烦,由于有web ui,可以开放端口直接配置搭配文档编写.</p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0420230401172201.png" alt="image-20230401172201099" style="zoom:67%;" /></p><p>比如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;version&quot;</span>:<span class="number">3</span>,<span class="attr">&quot;global&quot;</span>:&#123;&#125;,<span class="attr">&quot;rooms&quot;</span>:[&#123;<span class="attr">&quot;RoomId&quot;</span>:&#123;<span class="attr">&quot;HasValue&quot;</span>:<span class="literal">true</span>,<span class="attr">&quot;Value&quot;</span>:<span class="string">&quot;房间号&quot;</span>&#125;,<span class="attr">&quot;AutoRecord&quot;</span>:&#123;<span class="attr">&quot;HasValue&quot;</span>:<span class="literal">true</span>,<span class="attr">&quot;Value&quot;</span>:<span class="literal">true</span>&#125;&#125;]&#125;</span><br></pre></td></tr></table></figure><h4 id="更新录播姬"><a href="#更新录播姬" class="headerlink" title="更新录播姬"></a>更新录播姬</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取最新版本的镜像</span></span><br><span class="line"><span class="comment"># 参考本页面上面的拉取镜像部分</span></span><br><span class="line">docker pull bililive/recorder:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止运行并删除</span></span><br><span class="line">docker stop &lt;旧容器ID&gt;</span><br><span class="line">docker rm &lt;旧容器ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新新建容器运行</span></span><br><span class="line"><span class="comment"># 参考本页面上面的运行录播姬部分</span></span><br><span class="line">docker run -d -v 宿主机路径:/rec -p 2356:2356 bililive/recorder:latest</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://rec.danmuji.org/user/install/docker/">Docker 镜像 - 安装使用 - B站录播姬 (danmuji.org)</a></li><li><a href="https://www.bilibili.com/read/cv15242801">基于云服务器以及OSS存储打造属于自己的自动录播姬 - 哔哩哔哩 (bilibili.com)</a></li><li><a href="https://help.aliyun.com/document_detail/405812.html">OSS如何以目录的方式挂载到ECS实例 (aliyun.com)</a></li><li><a href="https://www.bilibili.com/read/cv15242801">阿里云OSS通过服务器ESC内网流量访问文件</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;搭建一个自动录播平台,录播的内容存储到云盘中.使用B站录播姬+OSS对象存储+服务器&lt;br&gt;</summary>
    
    
    
    
    <category term="OSS存储" scheme="https://www.sekyoro.top/tags/OSS%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>实战写浏览器插件</title>
    <link href="https://www.sekyoro.top/2023/03/23/%E5%AE%9E%E6%88%98%E5%86%99%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    <id>https://www.sekyoro.top/2023/03/23/%E5%AE%9E%E6%88%98%E5%86%99%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/</id>
    <published>2023-03-23T13:40:04.000Z</published>
    <updated>2023-03-26T07:13:44.237Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>写一些浏览器脚本或者插件方便平时的自动化操作.<br>油猴脚本编写不难,但考虑到浏览器插件可能涉及功能多同时并不是所有人会去安装一个类似油猴的插件,所以这里选择开发插件</p><span id="more"></span><p>现在Edge浏览器和Chrome浏览器都差不太多,需要修改一些API即可进行移植,这里选择Chrome浏览器,因为谷歌官方教程写得更详细一些.</p><p>如果要从谷歌浏览器插件迁移到Edge,也只需要修改一些不支持的API即可</p><p>Microsoft Edge 不支持以下扩展 API：</p><ul><li><code>chrome.gcm</code>.</li><li><code>chrome.identity.getAccounts</code>.</li><li><code>chrome.identity.getAuthToken</code> - 作为替代项，可以使用 <code>launchWebAuthFlow</code> 提取 OAuth2 令牌来对用户进行身份验证。</li><li><code>chrome.instanceID</code>.</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://learn.microsoft.com/zh-cn/microsoft-edge/extensions-chromium/getting-started/part1-simple-extension?tabs=v3">创建扩展教程，第 1 部分 - Microsoft Edge Development | Microsoft Learn</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;写一些浏览器脚本或者插件方便平时的自动化操作.&lt;br&gt;油猴脚本编写不难,但考虑到浏览器插件可能涉及功能多同时并不是所有人会去安装一个类似油猴的插件,所以这里选择开发插件&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://www.sekyoro.top/tags/JavaScript/"/>
    
    <category term="油猴脚本" scheme="https://www.sekyoro.top/tags/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>vscode+latex本地搭建tex写论文</title>
    <link href="https://www.sekyoro.top/2023/03/22/vscode-latex%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAtex%E5%86%99%E8%AE%BA%E6%96%87/"/>
    <id>https://www.sekyoro.top/2023/03/22/vscode-latex%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAtex%E5%86%99%E8%AE%BA%E6%96%87/</id>
    <published>2023-03-22T08:14:39.000Z</published>
    <updated>2023-03-22T09:13:30.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>如果是为了方便简洁,实际使用<a href="https://www.overleaf.com/">Overleaf</a>完全够了,之前也写过使用Obsidian写文章的教程. 这次主要介绍使用在本地vscode加上插件写论文.<br><span id="more"></span></p><h2 id="需要工具"><a href="#需要工具" class="headerlink" title="需要工具"></a>需要工具</h2><ol><li><strong>vscode</strong> 官网即可</li><li><strong>texlive</strong> 通过镜像站即可,比如<a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/">Index of /CTAN/systems/texlive/Images/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></li></ol><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322162307.png" alt="image-20230322162300639" style="zoom:67%;" /></p><p>选中箭头指向的其中一个即可,然后一步一步来即可.可以参考相关教程<a href="https://zhuanlan.zhihu.com/p/493412905">TeX Live 2022 安装指南【安装 LaTeX】</a>. 安装TexLive目的就是为了有个解析引擎,类似与c++程序下载g++一样</p><ol><li><a href="https://www.sumatrapdfreader.org/free-pdf-reader">Sumatra PDF (sumatrapdfreader.org)</a>  用于查看pdf,当然用其他的也可以.这是一个开源免费的pdf阅读器,用于查看tex编译后得到的pdf,并且设置反向搜索(即双击pdf的某个位置可以跳转到tex代码相应的位置)</li></ol><h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><p><strong>下载texlive之后</strong>,进行测试是否安装成功. 在命令行输入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tex</span><br></pre></td></tr></table></figure><p>显示</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322163046.png" alt="image-20230322163046678"></p><p>表示安装成功.</p><p><strong>在vscode中</strong>下载插件Latex Workshop,用于有效地编译预览tex文件.</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322162850.png" alt="image-20230322162849810" style="zoom:50%;" /></p><p>当然你也可以同时下载其他用于自动补全tex的插件.然后进行配置.</p><p>如果你还不了解tex相关的一类东西,可以在文章末尾<strong>参考资料</strong>中查看Tex家族.</p><h4 id="简单实用"><a href="#简单实用" class="headerlink" title="简单实用"></a>简单实用</h4><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322163519.png" alt="image-20230322163519674"></p><p>下载了插件后,你会注意到左部有这个插件标识,点击即可. 发现上面有相关命令.有编译,查看pdf,导向等等. 我们常用的就是构建,值得注意的是我们构建就是利用工具设置工具链进行一套编译流程.</p><p>现在你就可以写tex然后点击 <code>pdflatex-&gt;bibtex-&gt;pdflatex*2</code>即可得到pdf</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322163846.png" alt="image-20230322163846157"></p><p>但是你会发现使用中文会报错,所以接下来我们会进行相关配置.</p><blockquote><ul><li>TeX：1978年由Donald Erwin Knuth（高德纳）开发。是后来大部分TeX相关的基础。其生成dvi文件，然后经由其他程序转换为pdf文件。</li><li>pdfTeX：Tex语言的又一个实现，将TeX代码直接编译成PDF文件。</li><li>XeTeX：TeX 语言的新的实现，支持 Unicode 编码和直接访问操作系统字体。</li><li>LuaTeX：TeX 语言的一个完整的有扩展的实现。LuaTeX支持Unicode、系统字体和内嵌语言扩展，能直接输出PDF格式文件，也可以仍然输出 DVI 格式。</li></ul></blockquote><p>我们需要增加xelatex工具.首先在设置中搜索<code>tools</code></p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322164243.png" alt="image-20230322164243143" style="zoom:50%;" /></p><p>点击setting.json配置，增加xelatex,代码如下.即数组中的第一项.</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322164343.png" alt="image-20230322164343493" style="zoom:67%;" /></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;-synctex=1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-interaction=nonstopmode&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-file-line-error&quot;</span>,</span><br><span class="line">        <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上相当于增加了一个tool.</p><p>现在需要增加一个recipe,相当于一套流程,这个流程需要用到xelatex.</p><p>设置中搜索recipe</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322164525.png" alt="image-20230322164525817"></p><p>点击setting.json,增加红框的代码</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322164546.png" alt="image-20230322164546431" style="zoom:50%;" /></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tools&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">    ],</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xelatex ➞ bibtex ➞ xelatex × 2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tools&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;bibtex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在你可以看见增加的recipe了,如红箭头所示. 现在支持tex中有中文了.</p><p>注意需要使用ctex包</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125;</span><br></pre></td></tr></table></figure><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322164634.png" alt="image-20230322164634064"></p><h3 id="实现正反向搜索"><a href="#实现正反向搜索" class="headerlink" title="实现正反向搜索"></a>实现正反向搜索</h3><p>这里使用sumatra作为external的pdf阅读器并实现双向搜索.</p><p>设置中搜索viewer.</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322165018.png" alt="image-20230322165018028" style="zoom: 67%;" /></p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322165037.png" alt="image-20230322165036922" style="zoom:67%;" /></p><p>设置external同时设置sumatra安装路径.</p><h4 id="正向搜索"><a href="#正向搜索" class="headerlink" title="正向搜索"></a>正向搜索</h4><p>在设置中搜索 viewer,看到下图参数设置.</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322165147.png" alt="image-20230322165147100" style="zoom:67%;" /></p><p>注意,这里可以先尝试随便添加项,然后在setting.json中查找这个配置.</p><p>将这个参数修改如下,注意其中的逆向搜索路径(这里是<code>&quot;D:/Microsoft VS Code/Code.exe\&quot; \&quot;D:/Microsoft VS Code/resources/app/out/cli.js\&quot; -r -g \&quot;%f:%l\&quot;</code>)表示vscode相关下载位置,注意使用自己安装vscode的相关位置.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;latex-workshop.view.pdf.external.viewer.args&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;-forward-search&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%TEX%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%LINE%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-reuse-instance&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-inverse-search&quot;</span>,</span><br><span class="line">    <span class="string">&quot;\&quot;D:/Microsoft VS Code/Code.exe\&quot; \&quot;D:/Microsoft VS Code/resources/app/out/cli.js\&quot; -r -g \&quot;%f:%l\&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%PDF%&quot;</span>,</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><p>然后就配置成功了(事实上并没有完全成功,具体可以看下面的<a href="#attention">注意</a>).</p><p>正向搜索方法:平时选择其中之一即可</p><ol><li><p><img data-src="http://cdn.sekyoro.top/imgs/22/03image-20230322165523694.png" alt="image-20230322165523694"></p></li><li><p>按下<code>Ctrl+Alt+J</code>，直接跳转至PDF对应的地方。</p></li><li><p>点击<strong>View LaTeX PDF -&gt; View in external viewer</strong>。</p></li></ol><h4 id="逆向搜索"><a href="#逆向搜索" class="headerlink" title="逆向搜索"></a>逆向搜索</h4><p>设置中搜索Synctex,配置参数和命令. 跟上面的其实类似. </p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322165700.png" alt="image-20230322165659967" style="zoom:80%;" /></p><p><code>latex-workshop.view.pdf.external.synctex.args</code>参数配置如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;-forward-search&quot;</span>,</span><br><span class="line">   <span class="string">&quot;%TEX%&quot;</span>,</span><br><span class="line">   <span class="string">&quot;%LINE%&quot;</span>,</span><br><span class="line">   <span class="string">&quot;-reuse-instance&quot;</span>,</span><br><span class="line">   <span class="string">&quot;-inverse-search&quot;</span>,</span><br><span class="line">   <span class="string">&quot;\&quot;D:/Microsoft VS Code/Code.exe\&quot; \&quot;D:/Microsoft VS Code/resources/app/out/cli.js\&quot; -r -g \&quot;%f:%l\&quot;&quot;</span>,</span><br><span class="line">   <span class="string">&quot;%PDF%&quot;</span>,</span><br></pre></td></tr></table></figure><p>上面的路径也是根据你下载vscode的路径配置.</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><a id="attention">注意</a></h3><p>事实上要实现在sumatra中反向搜索,你还需要进行其他配置. 打开sumatra,点击左上角选择<strong>高级选项</strong>.</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322170018.png" alt="image-20230322170018604" style="zoom:67%;" /></p><p>搜索<code>InverseSearchCmdLine</code> 可以发现这里的值应该已经被设置了.后面发现,按照上述设置在vscode中打开sumatra后会将这里的参数设置会vscode中配置的,但是现在需要更改一下.</p><p>在vscode配置中,逆向搜索增加<code>--ms-enable-electron-run-as-node</code>参数.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;latex-workshop.view.pdf.external.viewer.args&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;-forward-search&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%TEX%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%LINE%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-reuse-instance&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-inverse-search&quot;</span>,</span><br><span class="line">    <span class="string">&quot;\&quot;D:/Microsoft VS Code/Code.exe\&quot; \&quot;D:/Microsoft VS Code/resources/app/out/cli.js\&quot; --ms-enable-electron-run-as-node -r -g \&quot;%f:%l\&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%PDF%&quot;</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;latex-workshop.view.pdf.external.synctex.command&quot;</span>: <span class="string">&quot;D:\\SumatraPDF\\SumatraPDF.exe&quot;</span>,</span><br><span class="line">  <span class="string">&quot;latex-workshop.view.pdf.external.synctex.args&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;-forward-search&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%TEX%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%LINE%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-reuse-instance&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-inverse-search&quot;</span>,</span><br><span class="line">    <span class="string">&quot;\&quot;D:/Microsoft VS Code/Code.exe\&quot; \&quot;D:/Microsoft VS Code/resources/app/out/cli.js\&quot; --ms-enable-electron-run-as-node -r -g \&quot;%f:%l\&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%PDF%&quot;</span>,</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><p>这样双击sumatra中的pdf即可跳转到vscode中的tex相应位置了.</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/273343930">在vscode中使用latex高效书写论文教程 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/144729565">学术论文写作利器—— VS Code + LaTeX - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/71432461">VS Code下配置LaTeX编译环境 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/434142338">VScode+Latex+SumatraPDF反向搜索失败解决办法（Version 1.63） - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/248669482">TeX 家族（TeX, XeTeX, LuaTeX,XeLaTeX …看完这篇就懂了） - 知乎 (zhihu.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果是为了方便简洁,实际使用&lt;a href=&quot;https://www.overleaf.com/&quot;&gt;Overleaf&lt;/a&gt;完全够了,之前也写过使用Obsidian写文章的教程. 这次主要介绍使用在本地vscode加上插件写论文.&lt;br&gt;</summary>
    
    
    
    <category term="latex" scheme="https://www.sekyoro.top/categories/latex/"/>
    
    
    <category term="latex" scheme="https://www.sekyoro.top/tags/latex/"/>
    
    <category term="vscode" scheme="https://www.sekyoro.top/tags/vscode/"/>
    
    <category term="sumatra" scheme="https://www.sekyoro.top/tags/sumatra/"/>
    
  </entry>
  
  <entry>
    <title>STL学习</title>
    <link href="https://www.sekyoro.top/2023/03/05/STL%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2023/03/05/STL%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-03-05T15:56:00.000Z</published>
    <updated>2023-03-05T15:57:32.116Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>刷算法时有必要使用一些stl.<br><span id="more"></span></p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h3><h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><p>初始化 通过如下创建 array 容器的方式，可以将所有的元素初始化为 0 或者和默认元素类型等效的值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="keyword">double</span>, 10&gt; values &#123;&#125;;</span><br></pre></td></tr></table></figure><p>array 容器是 <a href="http://c.biancheng.net/cplus/">C++</a> 11 标准中新增的序列容器，简单地理解，它就是在 C++ 普通数组的基础上，添加了一些成员函数和全局函数。在使用上，它比普通数组更安全，且效率并没有因此变差。</p><div class="table-container"><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的随机访问迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的随机访问迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素之前一个位置的随机访问迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>size()</td><td>返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。</td></tr><tr><td>max_size()</td><td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。</td></tr><tr><td>empty()</td><td>判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快。</td></tr><tr><td>at(n)</td><td>返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。</td></tr><tr><td>front()</td><td>返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。</td></tr><tr><td>back()</td><td>返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。</td></tr><tr><td>data()</td><td>返回一个指向容器首个元素的<a href="http://c.biancheng.net/c/80/">指针</a>。利用该指针，可实现复制容器中所有元素等类似功能。</td></tr><tr><td>fill(val)</td><td>将 val 这个值赋值给容器中的每个元素。</td></tr><tr><td>array1.swap(array2)</td><td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</td></tr></tbody></table></div><p>对于array相比一般的c数组,可以直接利用front,back获取前后引用,size函数获取个数,以及一般的容器迭代器等</p><p>同时还有at函数更加安全的获取array中的元素,但由于不能更改长度,实践中用的并不多</p><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><div class="table-container"><table><thead><tr><th>begin()</th><th>返回指向容器中第一个元素的迭代器。</th></tr></thead><tbody><tr><td>end()</td><td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>size()</td><td>返回实际元素个数。</td></tr><tr><td>max_size()</td><td>返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td></tr><tr><td>resize()</td><td>改变实际元素的个数。</td></tr><tr><td>capacity()</td><td>返回当前容量。</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td></tr><tr><td>reserve()</td><td>增加容器的容量。</td></tr><tr><td>shrink _to_fit()</td><td>将内存减少到等于当前元素实际所使用的大小。</td></tr><tr><td>operator[ ]</td><td>重载了 [ ] 运算符，可以向访问数组中元素那样，通过下标即可访问甚至修改 vector 容器中的元素。</td></tr><tr><td>at()</td><td>使用经过边界检查的索引访问元素。</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td></tr><tr><td>back()</td><td>返回最后一个元素的引用。</td></tr><tr><td>data()</td><td>返回指向容器中第一个元素的指针。</td></tr><tr><td>assign()</td><td>用新元素替换原有内容。</td></tr><tr><td>push_back()</td><td>在序列的尾部添加一个元素。</td></tr><tr><td>pop_back()</td><td>移出序列尾部的元素。</td></tr><tr><td>insert()</td><td>在指定的位置插入一个或多个元素。</td></tr><tr><td>erase()</td><td>移出一个元素或一段元素。</td></tr><tr><td>clear()</td><td>移出所有的元素，容器大小变为 0。</td></tr><tr><td>swap()</td><td>交换两个容器的所有元素。</td></tr><tr><td>emplace()</td><td>在指定的位置直接生成一个元素。</td></tr><tr><td>emplace_back()</td><td>在序列尾部生成一个元素。</td></tr></tbody></table></div><p>可以更改大小,在内存上是连续分布的.所以可以随机访问,跟一般的数组和array类似.  可以使用reserve函数调整大小,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values.<span class="built_in">reserve</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>这样就设置了容器的内存分配，即至少可以容纳 20 个元素。注意，如果 vector 的容量在执行此语句之前，已经大于或等于 20 个元素，那么这条语句什么也不做；另外，调用 reserve() 不会影响已存储的元素，也不会生成任何元素，即 values 容器内此时仍然没有任何元素.</p><p>同时使用emplace,emplace_back,erase等来增加或删除元素.</p><blockquote><p>emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p></blockquote><p>插入元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; demo&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">//第一种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">3</span>);<span class="comment">//&#123;1,3,2&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>);<span class="comment">//&#123;1,3,2,5,5&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种格式用法</span></span><br><span class="line">    std::array&lt;<span class="keyword">int</span>,3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>());<span class="comment">//&#123;1,3,2,5,5,7,8,9&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;);<span class="comment">//&#123;1,3,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; demo[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除元素</p><div class="table-container"><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>pop_back()</td><td>删除 vector 容器中最后一个元素，该容器的大小（size）会减 1，但容量（capacity）不会发生改变。</td></tr><tr><td>erase(pos)</td><td>删除 vector 容器中 pos 迭代器指定位置处的元素，并返回指向被删除元素下一个位置元素的迭代器。该容器的大小（size）会减 1，但容量（capacity）不会发生改变。</td></tr><tr><td>swap(beg)、pop_back()</td><td>先调用 swap() 函数交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back() 删除该目标元素。</td></tr><tr><td>erase(beg,end)</td><td>删除 vector 容器中位于迭代器 [beg,end)指定区域内的所有元素，并返回指向被删除区域下一个位置元素的迭代器。该容器的大小（size）会减小，但容量（capacity）不会发生改变。</td></tr><tr><td>remove()</td><td>删除容器中所有和指定元素值相等的元素，并返回指向最后一个元素下一个位置的迭代器。值得一提的是，调用该函数不会改变容器的大小和容量。</td></tr><tr><td>clear()</td><td>删除 vector 容器中所有的元素，使其变成空的 vector 容器。该函数会改变 vector 的大小（变为 0），但不是改变其容量。</td></tr></tbody></table></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">//删除 2、3</span></span><br><span class="line">    <span class="keyword">auto</span> iter = demo.<span class="built_in">erase</span>(demo.<span class="built_in">begin</span>()+<span class="number">1</span>, demo.<span class="built_in">end</span>() - <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size is :&quot;</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity is :&quot;</span> &lt;&lt; demo.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; demo[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用emplace,emplace_back,pop_back,erase对vector进行增删数据,使用at访问数据</p><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>deque 容器和 vecotr 容器有很多相似之处，比如：</p><ul><li>deque 容器也擅长在序列尾部添加或删除元素（时间复杂度为<code>O(1)</code>），而不擅长在序列中间添加或删除元素。</li><li>deque 容器也可以根据需要修改自身的容量和大小</li></ul><p>和 vector 不同的是，deque 还擅长在序列头部添加或删除元素，所耗费的时间复杂度也为常数阶<code>O(1)</code>。并且更重要的一点是，deque 容器中存储元素并不能保证所有元素都存储到连续的内存空间中。</p><blockquote><p>当需要向序列两端频繁的添加或删除元素时，应首选 deque 容器。</p></blockquote><p>和 vector 相比，额外增加了实现在容器头部添加和删除元素的成员函数比如emplace_front,pop_font，同时删除了 capacity()、reserve() 和 data() 成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化一个空deque容量</span></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt;d;</span><br><span class="line">    <span class="comment">//向d容器中的尾部依次添加 1，2,3</span></span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">2</span>); <span class="comment">//&#123;1,2&#125;</span></span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">3</span>); <span class="comment">//&#123;1,2,3&#125;</span></span><br><span class="line">    <span class="comment">//向d容器的头部添加 0 </span></span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">0</span>); <span class="comment">//&#123;0,1,2,3&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用 size() 成员函数输出该容器存储的字符个数。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素个数为：%d\n&quot;</span>, d.<span class="built_in">size</span>());</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//使用迭代器遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = d.<span class="built_in">begin</span>(); i &lt; d.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p><a href="http://c.biancheng.net/stl/">STL</a> list 容器，又称双向链表容器，即该容器的底层是以双向链表的形式实现的。这意味着，list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。</p><p>list 容器具有一些其它容器（array、vector 和 deque）所不具备的优势，即它可以在序列已知的任何位置快速插入或删除元素（时间复杂度为<code>O(1)</code>）。并且在 list 容器中移动元素，也比其它容器的效率高。</p><p>和之前的序列容器相比，list 容器迭代器最大的不同在于，其配备的迭代器类型为双向迭代器，而不再是随机访问迭代器。</p><div class="table-container"><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的双向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器中最后一个元素所在位置的下一个位置的双向迭代器。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的反向双向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的反向双向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td></tr><tr><td>size()</td><td>返回当前容器实际包含的元素个数。</td></tr><tr><td>max_size()</td><td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td></tr><tr><td>back()</td><td>返回最后一个元素的引用。</td></tr><tr><td>assign()</td><td>用新元素替换容器中原有内容。</td></tr><tr><td>emplace_front()</td><td>在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。</td></tr><tr><td>push_front()</td><td>在容器头部插入一个元素。</td></tr><tr><td>pop_front()</td><td>删除容器头部的一个元素。</td></tr><tr><td>emplace_back()</td><td>在容器尾部直接生成一个元素。该函数和 push_back() 的功能相同，但效率更高。</td></tr><tr><td>push_back()</td><td>在容器尾部插入一个元素。</td></tr><tr><td>pop_back()</td><td>删除容器尾部的一个元素。</td></tr><tr><td>emplace()</td><td>在容器中的指定位置插入元素。该函数和 insert() 功能相同，但效率更高。</td></tr><tr><td>insert()</td><td>在容器中的指定位置插入元素。</td></tr><tr><td>erase()</td><td>删除容器中一个或某区域内的元素。</td></tr><tr><td>swap()</td><td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。</td></tr><tr><td>resize()</td><td>调整容器的大小。</td></tr><tr><td>clear()</td><td>删除容器存储的所有元素。</td></tr><tr><td>splice()</td><td>将一个 list 容器中的元素插入到另一个容器的指定位置。</td></tr><tr><td>remove(val)</td><td>删除容器中所有等于 val 的元素。</td></tr><tr><td>remove_if()</td><td>删除容器中满足条件的元素。</td></tr><tr><td>unique()</td><td>删除容器中相邻的重复元素，只保留一个。</td></tr><tr><td>merge()</td><td>合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的。</td></tr><tr><td>sort()</td><td>通过更改容器中元素的位置，将它们进行排序。</td></tr><tr><td>reverse()</td><td>反转容器中元素的顺序。</td></tr></tbody></table></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空的 list 容器</span></span><br><span class="line">    std::list&lt;<span class="keyword">double</span>&gt; values;</span><br><span class="line">    <span class="comment">//向容器中添加元素</span></span><br><span class="line">    values.<span class="built_in">push_back</span>(<span class="number">3.1</span>);</span><br><span class="line">    values.<span class="built_in">push_back</span>(<span class="number">2.2</span>);</span><br><span class="line">    values.<span class="built_in">push_back</span>(<span class="number">2.9</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;values size：&quot;</span> &lt;&lt; values.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//对容器中的元素进行排序</span></span><br><span class="line">    values.<span class="built_in">sort</span>();</span><br><span class="line">    <span class="comment">//使用迭代器输出list容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (std::list&lt;<span class="keyword">double</span>&gt;::iterator it = values.<span class="built_in">begin</span>(); it != values.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::list&lt;<span class="keyword">int</span>&gt; values&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="comment">//第一种格式用法</span></span><br><span class="line">    values.<span class="built_in">insert</span>(values.<span class="built_in">begin</span>() , <span class="number">3</span>);<span class="comment">//&#123;3,1,2&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种格式用法</span></span><br><span class="line">    values.<span class="built_in">insert</span>(values.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>);<span class="comment">//&#123;3,1,2,5,5&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种格式用法</span></span><br><span class="line">    std::array&lt;<span class="keyword">int</span>, 3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    values.<span class="built_in">insert</span>(values.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>());<span class="comment">//&#123;3,1,2,5,5,7,8,9&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四种格式用法</span></span><br><span class="line">    values.<span class="built_in">insert</span>(values.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;);<span class="comment">//&#123;3,1,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = values.<span class="built_in">begin</span>(); p != values.<span class="built_in">end</span>(); ++p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h3><p>关联式容器在存储元素值的同时，会为各元素额外再配备一个值（又称为“键”，其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联式容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。</p><blockquote><p>弃用序列式容器，转而选用关联式容器存储元素，往往就是看中了关联式容器可以快速查找、读取或者删除所存储的元素，同时该类型容器插入元素的效率也比序列式容器高。</p></blockquote><p>也就是说，使用关联式容器存储的元素，都是一个一个的“键值对”（ <key,value> ），这是和序列式容器最大的不同。除此之外，序列式容器中存储的元素默认都是未经过排序的，而使用关联式容器存储的元素，默认会根据各元素的键值的大小做升序排序</p><div class="table-container"><table><thead><tr><th>关联式容器名称</th><th>特点</th></tr></thead><tbody><tr><td>map</td><td>定义在 <map> 头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根据各元素键的大小，默认进行升序排序（调用 std::less<T>）。</td></tr><tr><td>set</td><td>定义在 <set> 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个元素的键（其实也就是元素值）的大小进行升序排序（调用 std::less<T>）。</td></tr><tr><td>multimap</td><td>定义在 <map> 头文件中，和 map 容器唯一的不同在于，multimap 容器中存储元素的键可以重复。</td></tr><tr><td>multiset</td><td>定义在 <set> 头文件中，和 set 容器唯一的不同在于，multiset 容器中存储元素的值可以重复（一旦值重复，则意味着键也是重复的）。</td></tr></tbody></table></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span> <span class="comment">//使用 map 容器，必须引入该头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空的 map 关联式容器，该容器中存储的键值对，其中键为 string 字符串，值也为 string 字符串类型</span></span><br><span class="line">    map&lt;string, string&gt; mymap;</span><br><span class="line">    <span class="comment">//向 mymap 容器中添加数据</span></span><br><span class="line">    mymap[<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>] = <span class="string">&quot;C语言教程&quot;</span>;</span><br><span class="line">    mymap[<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>] = <span class="string">&quot;Python教程&quot;</span>;</span><br><span class="line">    mymap[<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>] = <span class="string">&quot;Java教程&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用 map 容器的迭代器，遍历 mymap 容器，并输出其中存储的各个键值对</span></span><br><span class="line">    <span class="keyword">for</span> (map&lt;string, string&gt;::iterator it = mymap.<span class="built_in">begin</span>(); it != mymap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="comment">//输出各个元素中的键和值</span></span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到“键值对”并不是普通类型数据，<a href="http://c.biancheng.net/cplus/">C++</a> <a href="http://c.biancheng.net/stl/">STL</a> 标准库提供了 pair 类模板，其专门用来将 2 个普通元素 first 和 second（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素<code>&lt;first, second&gt;</code>。通过其构成的元素格式不难看出，使用 pair 类模板来创建“键值对”形式的元素</p><p>pair 类模板定义在<code>&lt;utility&gt;</code>头文件中，所以在使用该类模板之前，需引入此头文件。另外值得一提的是，在 C++ 11 标准之前，pair 类模板中提供了以下 3 种构造函数：</p><h1 id="1-默认构造函数，即创建空的-pair-对象pair"><a href="#1-默认构造函数，即创建空的-pair-对象pair" class="headerlink" title="1) 默认构造函数，即创建空的 pair 对象pair();"></a>1) 默认构造函数，即创建空的 pair 对象pair();</h1><h1 id="2-直接使用-2-个元素初始化成-pair-对象pair-const-first-type-amp-a-const-second-type-amp-b"><a href="#2-直接使用-2-个元素初始化成-pair-对象pair-const-first-type-amp-a-const-second-type-amp-b" class="headerlink" title="2) 直接使用 2 个元素初始化成 pair 对象pair (const first_type&amp; a, const second_type&amp; b);"></a>2) 直接使用 2 个元素初始化成 pair 对象pair (const first_type&amp; a, const second_type&amp; b);</h1><h1 id="3-拷贝（复制）构造函数，即借助另一个-pair-对象，创建新的-pair-对象template-pair-const-pair-amp-pr"><a href="#3-拷贝（复制）构造函数，即借助另一个-pair-对象，创建新的-pair-对象template-pair-const-pair-amp-pr" class="headerlink" title="3) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象template pair (const pair&amp; pr);"></a>3) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象template<class U, class V> pair (const pair<U,V>&amp; pr);</h1><p>在 C++ 11 标准中，在引入<a href="http://c.biancheng.net/view/439.html">右值引用</a>的基础上，pair 类模板中又增添了如下 2 个构造函数：</p><h1 id="4-移动构造函数template-pair-pair-amp-amp-pr-5-使用右值引用参数，创建-pair-对象template-pair-U-amp-amp-a-V-amp-amp-b"><a href="#4-移动构造函数template-pair-pair-amp-amp-pr-5-使用右值引用参数，创建-pair-对象template-pair-U-amp-amp-a-V-amp-amp-b" class="headerlink" title="4) 移动构造函数template pair (pair&amp;&amp; pr);#5) 使用右值引用参数，创建 pair 对象template pair (U&amp;&amp; a, V&amp;&amp; b);"></a>4) 移动构造函数template<class U, class V> pair (pair<U,V>&amp;&amp; pr);#5) 使用右值引用参数，创建 pair 对象template<class U, class V> pair (U&amp;&amp; a, V&amp;&amp; b);</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span>      <span class="comment">// pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用构造函数 1，也就是默认构造函数</span></span><br><span class="line">    pair &lt;string, <span class="keyword">double</span>&gt; pair1;</span><br><span class="line">    <span class="comment">// 调用第 2 种构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair2</span>(<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);  </span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair3</span>(pair2);</span><br><span class="line">    <span class="comment">//调用移动构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair4</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;C++教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/cplus/&quot;</span>));</span><br><span class="line">    <span class="comment">// 调用第 5 种构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair5</span>(<span class="built_in">string</span>(<span class="string">&quot;Python教程&quot;</span>), <span class="built_in">string</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>));  </span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair1: &quot;</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair1.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair2: &quot;</span>&lt;&lt; pair2.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair2.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair3: &quot;</span> &lt;&lt; pair3.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair3.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair4: &quot;</span> &lt;&lt; pair4.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair4.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair5: &quot;</span> &lt;&lt; pair5.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair5.second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,<span class="keyword">int</span>&gt;myMap;</span><br><span class="line">   map&lt;string,<span class="keyword">int</span>&gt;mymap&#123;&#123;<span class="string">&quot;C语言&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;C++教程&quot;</span>,<span class="number">20</span>&#125;&#125;;</span><br><span class="line">   map&lt;string,string&gt;m&#123;<span class="built_in">make_pair</span>(<span class="string">&quot;hi&quot;</span>,<span class="string">&quot;hello&quot;</span>)&#125;;</span><br><span class="line">   map&lt;string,string&gt;copiedmap&#123;m&#125;;</span><br><span class="line"></span><br><span class="line">   map&lt;string,<span class="keyword">int</span>,greater&lt;string&gt; &gt;hismap;</span><br></pre></td></tr></table></figure><p>常用的成员函数是find,count</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>      <span class="comment">// map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建空 map 容器，默认根据个键值对中键的值，对键值对做降序排序</span></span><br><span class="line">    std::map&lt;std::string, std::string, std::greater&lt;std::string&gt;&gt;myMap;</span><br><span class="line">    <span class="comment">//调用 emplace() 方法，直接向 myMap 容器中指定位置构造新键值对</span></span><br><span class="line">    myMap.<span class="built_in">emplace</span>(<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">    myMap.<span class="built_in">emplace</span>(<span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    myMap.<span class="built_in">emplace</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    <span class="comment">//输出当前 myMap 容器存储键值对的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myMap size==&quot;</span> &lt;&lt; myMap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//判断当前 myMap 容器是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!myMap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">//借助 myMap 容器迭代器，将该容器的键值对逐个输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = myMap.<span class="built_in">begin</span>(); i != myMap.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">            cout &lt;&lt; i-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i-&gt;second &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string&gt; myset&#123;<span class="string">&quot;shit&quot;</span>&#125;;</span><br><span class="line">    set&lt;string&gt; set2&#123;</span><br><span class="line">        <span class="string">&quot;hi&quot;</span>,</span><br><span class="line">        <span class="string">&quot;hello&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">set&lt;string&gt; <span class="title">s1</span><span class="params">(set2)</span></span>;</span><br><span class="line">    s.<span class="built_in">emplace</span>(<span class="string">&quot;hi&quot;</span>);</span><br></pre></td></tr></table></figure><p>删除元素 erase</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 set 容器</span></span><br><span class="line">    std::set&lt;<span class="keyword">int</span>&gt;myset&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//1) 调用第一种格式的 erase() 方法</span></span><br><span class="line">    <span class="keyword">int</span> num = myset.<span class="built_in">erase</span>(<span class="number">2</span>); <span class="comment">//删除元素 2，myset=&#123;1,3,4,5&#125;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2) 调用第二种格式的 erase() 方法</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt;::iterator iter = myset.<span class="built_in">erase</span>(myset.<span class="built_in">begin</span>()); <span class="comment">//删除元素 1，myset=&#123;3,4,5&#125;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter-&gt;&quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3) 调用第三种格式的 erase() 方法</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt;::iterator iter2 = myset.<span class="built_in">erase</span>(myset.<span class="built_in">begin</span>(), --myset.<span class="built_in">end</span>());<span class="comment">//删除元素 3,4，myset=&#123;5&#125;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter2-&gt;&quot;</span> &lt;&lt; *iter2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset;</span><br><span class="line">    <span class="comment">//空set容器不存储任何元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//向myset容器中插入新元素</span></span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//利用双向迭代器，遍历myset</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myset.<span class="built_in">begin</span>(); iter != myset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th>介绍</th></tr></thead><tbody><tr><td style="text-align:left">upper_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td style="text-align:left">equal_range(val)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。</td></tr><tr><td style="text-align:left">lower_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr></tbody></table></div><p>注意count,find等新的成员函数</p><p>此外关联式容器还有multimap和multiset,这里不介绍了.</p><h4 id="无序关联式容器"><a href="#无序关联式容器" class="headerlink" title="无序关联式容器"></a>无序关联式容器</h4><p>和关联式容器一样，无序容器也使用键值对（pair 类型）的方式存储数据。不过，它们有本质上的不同：</p><ul><li>关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构；</li><li>无序容器的底层实现采用的是哈希表的存储结构。</li></ul><div class="table-container"><table><thead><tr><th>无序容器</th><th>功能</th></tr></thead><tbody><tr><td>unordered_map</td><td>存储键值对 <key, value> 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。</td></tr><tr><td>unordered_multimap</td><td>和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。</td></tr><tr><td>unordered_set</td><td>不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。</td></tr><tr><td>unordered_multiset</td></tr></tbody></table></div><p>总的来说，实际场景中如果涉及大量遍历容器的操作，建议首选关联式容器；反之，如果更多的操作是通过键获取对应的值，则应首选无序容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化一个 unordered_map 容器，其存储的 &lt;string,string&gt; 类型的键值对</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; my_uMap&#123;</span><br><span class="line">        &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Python教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//查找指定键对应的值，效率比关联式容器高</span></span><br><span class="line">    string str = my_uMap.<span class="built_in">at</span>(<span class="string">&quot;C语言教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用迭代器遍历哈希容器，效率不如关联式容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = my_uMap.<span class="built_in">begin</span>(); iter != my_uMap.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//pair 类型键值对分为 2 部分</span></span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器是cpp STL库的概念,要访问顺序容器和关联容器中的元素，需要通过“迭代器（iterator）”进行。迭代器是一个变量，相当于容器</p><p>和操纵容器的算法之间的中介。迭代器可以指向容器中的某个元素，通过迭代器就可以读写它指向的元素。从这一点上看，迭代器和<a href="http://c.biancheng.net/c/80/">指针</a>类似.</p><p>通过迭代器可以读取它指向的元素，<code>*迭代器名</code>就表示迭代器指向的元素。通过非常量迭代器还能修改其指向的元素。</p><p>迭代器都可以进行<code>++</code>操作。反向迭代器和正向迭代器的区别在于：</p><ul><li>对正向迭代器进行<code>++</code>操作时，迭代器会指向容器中的后一个元素；</li><li>而对反向迭代器进行<code>++</code>操作时，迭代器会指向容器中的前一个元素</li></ul><h3 id="迭代器的分类"><a href="#迭代器的分类" class="headerlink" title="迭代器的分类"></a>迭代器的分类</h3><p>常用的迭代器按功能强弱分为输入、输出、正向、双向、随机访问五种，这里只介绍常用的三种。</p><p>1) 正向迭代器。假设 p 是一个正向迭代器，则 p 支持以下操作：++p，p++，*p。此外，两个正向迭代器可以互相赋值，还可以用<code>==</code>和<code>!=</code>运算符进行比较。</p><p>2) 双向迭代器。双向迭代器具有正向迭代器的全部功能。除此之外，若 p 是一个双向迭代器，则<code>--p</code>和<code>p--</code>都是有定义的。<code>--p</code>使得 p 朝和<code>++p</code>相反的方向移动。</p><p>3) 随机访问迭代器。随机访问迭代器具有双向迭代器的全部功能。若 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p><ul><li>p+=i：使得 p 往后移动 i 个元素。</li><li>p-=i：使得 p 往前移动 i 个元素。</li><li>p+i：返回 p 后面第 i 个元素的迭代器。</li><li>p-i：返回 p 前面第 i 个元素的迭代器。</li><li>p[i]：返回 p 后面第 i 个元素的引用</li></ul><div class="table-container"><table><thead><tr><th>容器</th><th>迭代器功能</th></tr></thead><tbody><tr><td>vector</td><td>随机访问</td></tr><tr><td>deque</td><td>随机访问</td></tr><tr><td>list</td><td>双向</td></tr><tr><td>set / multiset</td><td>双向</td></tr><tr><td>map / multimap</td><td>双向</td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr><tr><td>priority_queue</td><td>不支持迭代器</td></tr></tbody></table></div><h2 id="迭代器的辅助函数"><a href="#迭代器的辅助函数" class="headerlink" title="迭代器的辅助函数"></a>迭代器的辅助函数</h2><p>STL 中有用于操作迭代器的三个函数模板，它们是：</p><ul><li>advance(p, n)：使迭代器 p 向前或向后移动 n 个元素。</li><li>dis<a href="http://c.biancheng.net/ref/tan.html">tan</a>ce(p, q)：计算两个迭代器之间的距离，即迭代器 p 经过多少次 + + 操作后和迭代器 q 相等。如果调用时 p 已经指向 q 的后面，则这个函数会陷入死循环。</li><li>iter_swap(p, q)：用于交换两个迭代器 p、q 指向的值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span> <span class="comment">//要使用操作迭代器的函数模板，需要包含此文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    list &lt;<span class="keyword">int</span>&gt; <span class="built_in">lst</span>(a, a+<span class="number">5</span>);</span><br><span class="line">    list &lt;<span class="keyword">int</span>&gt;::iterator p = lst.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">advance</span>(p, <span class="number">2</span>);  <span class="comment">//p向后移动两个元素，指向3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1)&quot;</span> &lt;&lt; *p &lt;&lt; endl;  <span class="comment">//输出 1)3</span></span><br><span class="line">    <span class="built_in">advance</span>(p, <span class="number">-1</span>);  <span class="comment">//p向前移动一个元素，指向2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2)&quot;</span> &lt;&lt; *p &lt;&lt; endl;  <span class="comment">//输出 2)2</span></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt;::iterator q = lst.<span class="built_in">end</span>();</span><br><span class="line">    q--;  <span class="comment">//q 指向 5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3)&quot;</span> &lt;&lt; <span class="built_in">distance</span>(p, q) &lt;&lt; endl;  <span class="comment">//输出 3)3</span></span><br><span class="line">    <span class="built_in">iter_swap</span>(p, q); <span class="comment">//交换 2 和 5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;4)&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = lst.<span class="built_in">begin</span>(); p != lst.<span class="built_in">end</span>(); ++p)</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;刷算法时有必要使用一些stl.&lt;br&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://www.sekyoro.top/tags/cpp/"/>
    
    <category term="stl" scheme="https://www.sekyoro.top/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>浏览器CORS和CSP介绍</title>
    <link href="https://www.sekyoro.top/2023/03/04/%E6%B5%8F%E8%A7%88%E5%99%A8CORS%E5%92%8CCSP%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.sekyoro.top/2023/03/04/%E6%B5%8F%E8%A7%88%E5%99%A8CORS%E5%92%8CCSP%E4%BB%8B%E7%BB%8D/</id>
    <published>2023-03-04T07:08:59.000Z</published>
    <updated>2023-03-04T08:53:05.173Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>了解浏览器的一些安全策略同时了解跨域问题.<br><span id="more"></span></p><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>全称是跨源资源共享(Cross-Origin Resource Sharing).是一个系统，它由一系列传输的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP_header">HTTP 标头</a>组成，这些 HTTP 标头决定浏览器是否阻止前端 JavaScript 代码获取跨源请求的响应.</p><p>这又涉及到了浏览器的同源策略.</p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p><strong>同源策略</strong>是一个重要的安全策略，它用于限制一个<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin">源</a>的文档或者它加载的脚本如何能与另一个源的资源进行交互。</p><blockquote><p>它能帮助阻隔恶意文档，减少可能被攻击的媒介。例如，它可以防止互联网上的恶意网站在浏览器中运行 JS 脚本，从第三方网络邮件服务（用户已登录）或公司内网（因没有公共 IP 地址而受到保护，不会被攻击者直接访问）读取数据，并将这些数据转发给攻击者。</p></blockquote><h4 id="源的定义"><a href="#源的定义" class="headerlink" title="源的定义"></a>源的定义</h4><p>如果两个 URL 的<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol">协议</a>、<a href="https://developer.mozilla.org/en-US/docs/Glossary/Port">端口 (en-US)</a>（如果有指定的话）和<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Host">主机</a>都相同的话，则这两个 URL 是<em>同源</em>的。这个方案也被称为“协议/主机/端口元组”，或者直接是“元组”。（“元组”是指一组项目构成的整体，具有双重/三重/四重/五重等通用形式。）</p><p>协议比如http,https.  主机是域名或者ip地址.</p><div class="table-container"><table><thead><tr><th style="text-align:left">URL</th><th style="text-align:left">结果</th><th style="text-align:left">原因</th></tr></thead><tbody><tr><td style="text-align:left"><code>http://store.company.com/dir2/other.html</code></td><td style="text-align:left">同源</td><td style="text-align:left">只有路径不同</td></tr><tr><td style="text-align:left"><code>http://store.company.com/dir/inner/another.html</code></td><td style="text-align:left">同源</td><td style="text-align:left">只有路径不同</td></tr><tr><td style="text-align:left"><code>https://store.company.com/secure.html</code></td><td style="text-align:left">失败</td><td style="text-align:left">协议不同</td></tr><tr><td style="text-align:left"><code>http://store.company.com:81/dir/etc.html</code></td><td style="text-align:left">失败</td><td style="text-align:left">端口不同（<code>http://</code> 默认端口是 80）</td></tr><tr><td style="text-align:left"><code>http://news.company.com/dir/other.html</code></td><td style="text-align:left">失败</td><td style="text-align:left">主机不同</td></tr></tbody></table></div><p>除了一般的HTTP还有<strong>文件源</strong>.</p><p>现代浏览器通常将使用 <code>file:///</code> 模式加载的文件的来源视为<em>不透明的来源</em>。这意味着，假如一个文件包括来自同一文件夹的其它文件，它们不会被认为来自同一来源，并可能引发 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CORS">CORS</a> 错误</p><p><strong>源的继承</strong></p><p>在页面中通过 <code>about:blank</code> 或 <code>javascript:</code> URL 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URL 没有包含源服务器的相关信息。</p><p>例如，<code>about:blank</code> 通常作为父脚本写入内容的新的空白弹出窗口的 URL（例如，通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open"><code>Window.open()</code></a>）。如果此弹出窗口也包含 JavaScript，则该脚本将从创建它的脚本那里继承对应的源。</p><h4 id="跨源网络访问"><a href="#跨源网络访问" class="headerlink" title="跨源网络访问"></a>跨源网络访问</h4><p>同源策略会影响不同源之间的交互.</p><blockquote><p>例如在使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img"><code>img</code></a> 标签时则会受到同源策略的约束。这些交互通常分为三类：</p><ul><li>跨源<strong>写操作</strong>（Cross-origin writes）一般是被允许的。例如链接、重定向以及表单提交。特定少数的 HTTP 请求需要添加<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#预检请求">预检请求</a>。</li><li>跨源<strong>资源嵌入</strong>（Cross-origin embedding）一般是被允许的.</li><li>跨源<strong>读操作</strong>（Cross-origin reads）一般是不被允许的，但常可以通过内嵌资源来巧妙的进行读取访问。例如，你可以读取嵌入图片的高度和宽度，调用内嵌脚本的方法，或<a href="https://bugzil.la/629094">得知内嵌资源的可用性</a>。</li></ul></blockquote><p>以下是<strong>可能嵌入跨源的资源</strong>的一些示例：</p><ul><li>使用 <code>&lt;script src=&quot;…&quot;&gt;&lt;/script&gt;</code> 标签嵌入的 JavaScript 脚本。语法错误信息只能被同源脚本中捕捉到。</li><li>使用 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;…&quot;&gt;</code> 标签嵌入的 CSS。由于 CSS 的松散的语法规则，CSS 的跨源需要一个设置正确的 <code>Content-Type</code> 标头。如果样式表是跨源的，且 MIME 类型不正确，资源不以有效的 CSS 结构开始，浏览器会阻止它的加载。</li><li>通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img"><code>img</code></a> 展示的图片。</li><li>通过<code>video</code>和<code>audio</code>播放的多媒体资源。</li><li>通过 <code>object</code>和<code>embed</code> 嵌入的插件。</li><li>通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face"><code>@font-face</code></a> 引入的字体。一些浏览器允许跨源字体（cross-origin fonts），另一些需要同源字体（same-origin fonts）。</li><li>通过iframe载入的资源。站点可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Frame-Options"><code>X-Frame-Options</code></a> 标头来阻止这种形式的跨源交互。</li></ul><p>这份<a href="https://fetch.spec.whatwg.org/#http-cors-protocol">跨源共享标准</a>允许在下列场景中使用跨站点 HTTP 请求：</p><ul><li>前文提到的由 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">Fetch API</a> 发起的跨源 HTTP 请求。</li><li>Web 字体（CSS 中通过 <code>@font-face</code> 使用跨源字体资源），<a href="https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements">因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用</a>。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL">WebGL 贴图</a>。</li><li>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage"><code>drawImage()</code></a> 将图片或视频画面绘制到 canvas。</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Shapes/Shapes_From_Images">来自图像的 CSS 图形 (en-US)</a>。</li></ul><p>可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">CORS</a> 来允许跨源访问。CORS 是 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP">HTTP</a> 的一部分，它允许服务端来指定哪些主机可以从这个服务端加载资源。</p><h3 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h3><p>cors是一种基于HTTP头的机制,解决浏览器同源策略,允许服务器标示除了它自己以外的其它<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin">源</a>（域、协议或端口），使得浏览器允许这些源访问加载自己的资源.</p><p><strong>CORS 标头</strong></p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin"><code>Access-Control-Allow-Origin</code></a></p><p>指示响应的资源是否可以被给定的来源共享。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials"><code>Access-Control-Allow-Credentials</code></a></p><p>指示当请求的凭证标记为 true 时，是否可以公开对该请求响应。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Headers"><code>Access-Control-Allow-Headers</code></a></p><p>用在对预检请求的响应中，指示实际的请求中可以使用哪些 HTTP 标头。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Methods"><code>Access-Control-Allow-Methods</code></a></p><p>指定对预检请求的响应中，哪些 HTTP 方法允许访问请求的资源。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Expose-Headers"><code>Access-Control-Expose-Headers</code></a></p><p>通过列出标头的名称，指示哪些标头可以作为响应的一部分公开。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Max-Age"><code>Access-Control-Max-Age</code></a></p><p>指示预检请求的结果能被缓存多久。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers"><code>Access-Control-Request-Headers</code></a></p><p>用于发起一个预检请求，告知服务器正式请求会使用哪些 HTTP 标头。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Method"><code>Access-Control-Request-Method</code></a></p><p>用于发起一个预检请求，告知服务器正式请求会使用哪一种 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods">HTTP 请求方法</a>。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin"><code>Origin</code></a></p><p>指示获取资源的请求是从什么源发起的。</p></li></ul><p>跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求,通过浏览器发起一个到服务器托管的跨源资源的“预检”请求。在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头.</p><h4 id="实际访问控制场景"><a href="#实际访问控制场景" class="headerlink" title="实际访问控制场景"></a>实际访问控制场景</h4><ol><li><p>简单请求不会触发CORS预检请求.</p><p>若满足所有下述条件,</p><ul><li>使用下列方法之一：<ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD"><code>HEAD</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST"><code>POST</code></a></li></ul></li></ul></li></ol><p>​    允许人为设置下面的字段</p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept"><code>Accept</code></a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language"><code>Accept-Language</code></a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language"><code>Content-Language</code></a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a>（需要注意额外的限制）</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Range"><code>Range</code></a>（只允许<a href="https://fetch.spec.whatwg.org/#simple-range-header-value">简单的范围标头值</a> 如 <code>bytes=256-</code> 或 <code>bytes=127-255</code>）</p></li><li><p><code>Content-Type</code></p></li></ul><p>  标头所指定的</p><p>  媒体类型</p><p>  的值仅限于下列三者之一：</p><ul><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul><p>具体请查阅MDN<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#什么情况下需要_cors？">跨源资源共享（CORS） - HTTP | MDN (mozilla.org)</a></p><p>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin"><code>Origin</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin"><code>Access-Control-Allow-Origin</code></a> 就能完成最简单的访问控制。如果 <code>https://bar.other</code> 的资源持有者想限制他的资源<em>只能</em>通过 <code>https://foo.example</code> 来访问</p><ol><li>预检请求</li></ol><p>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin"><code>Origin</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin"><code>Access-Control-Allow-Origin</code></a> 就能完成最简单的访问控制。如果 <code>https://bar.other</code> 的资源持有者想限制他的资源<em>只能</em>通过 <code>https://foo.example</code> 来访问</p><ol><li><p>附带身份凭证的请求</p><p>一般而言，对于跨源 <code>XMLHttpRequest</code> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">Fetch</a> 请求，浏览器<strong>不会</strong>发送身份凭证信息。如果要发送凭证信息，需要设置 <code>XMLHttpRequest</code> 对象的某个特殊标志位，或在构造 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Request"><code>Request</code></a> 对象时设置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> invocation = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"> invocation.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>如果服务器端的响应中未携带 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials"><code>Access-Control-Allow-Credentials</code></a><code>: true</code>，浏览器将<strong>不会</strong>把响应内容返回给请求的发送者</p></li></ol><h2 id="内容安全策略-CSP"><a href="#内容安全策略-CSP" class="headerlink" title="内容安全策略(CSP)"></a>内容安全策略(CSP)</h2><p><strong>内容安全策略</strong>（<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CSP">CSP</a>）是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括<strong>跨站脚本</strong>（<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting">XSS</a>）和<strong>数据注入攻击</strong>等。无论是数据盗取、网站内容污染还是恶意软件分发，这些攻击都是主要的手段。  </p><p>为使 CSP 可用，你需要配置你的网络服务器返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy"><code>Content-Security-Policy</code></a> HTTP 标头（有时你会看到 <code>X-Content-Security-Policy</code> 标头，但那是旧版本，并且你无须再如此指定它）。</p><p>除此之外，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta">``</a> 元素也可以被用来配置该策略，例如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; img-src https://*; child-src &#x27;none&#x27;;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP#示例_1">示例 1</a></h3><p>一个网站管理者想要所有内容均来自站点的同一个源（不包括其子域名）。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-<span class="keyword">Security</span>-<span class="keyword">Policy</span>: <span class="keyword">default</span>-src <span class="string">&#x27;self&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP#示例_2">示例 2</a></h3><p>一个网站管理者允许内容来自信任的域名及其子域名（域名不必须与 CSP 设置所在的域名相同）。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-<span class="keyword">Security</span>-<span class="keyword">Policy</span>: <span class="keyword">default</span>-src <span class="string">&#x27;self&#x27;</span> *.<span class="keyword">trusted</span>.com</span><br></pre></td></tr></table></figure><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP#示例_3">示例 3</a></h3><p>一个网站管理者允许网页应用的用户在他们自己的内容中包含来自任何源的图片，但是限制音频或视频需从信任的资源提供者，所有脚本必须从特定主机服务器获取可信的代码。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content</span>-Security-Policy: default-src <span class="string">&#x27;self&#x27;</span>; <span class="selector-tag">img</span>-<span class="attribute">src</span> *; media-<span class="attribute">src</span> media1<span class="selector-class">.com</span> media2<span class="selector-class">.com</span>; script-<span class="attribute">src</span> userscripts<span class="selector-class">.example</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure><p>在这里，各种内容默认仅允许从文档所在的源获取，但存在如下例外：</p><ul><li>图片可以从任何地方加载 (注意“*”通配符)。</li><li>多媒体文件仅允许从 media1.com 和 media2.com 加载（不允许从这些站点的子域名）。</li><li>可运行脚本仅允许来自于 userscripts.example.com。</li></ul><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP#示例_4">示例 4</a></h3><p>一个线上银行网站的管理者想要确保网站的所有内容都要通过 SSL 方式获取，以避免攻击者窃听用户发出的请求。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src <span class="attribute">https</span>:<span class="comment">//onlinebanking.jumbobank.com</span></span><br></pre></td></tr></table></figure><p>该服务器仅允许通过 HTTPS 方式并仅从 onlinebanking.jumbobank.com 域名来访问文档。</p><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP#示例_5">示例 5</a></h3><p>一个在线邮箱的管理者想要允许在邮件里包含 HTML，同样图片允许从任何地方加载，但不允许 JavaScript 或者其它潜在的危险内容（从任意位置加载）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content</span>-Security-Policy: default-src <span class="string">&#x27;self&#x27;</span> *.mailsite.com; <span class="selector-tag">img</span>-<span class="attribute">src</span> *</span><br></pre></td></tr></table></figure><p>注意这个示例并未指定 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src"><code>script-src</code> (en-US)</a>；在此 CSP 示例中，站点通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src"><code>default-src</code></a> 指令的对其进行配置，这也同样意味着脚本文件仅允许从原始服务器获取。</p><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">跨源资源共享（CORS） - HTTP | MDN (mozilla.org)</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP#对策略进行测试">内容安全策略（CSP） - HTTP | MDN (mozilla.org)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;了解浏览器的一些安全策略同时了解跨域问题.&lt;br&gt;</summary>
    
    
    
    
    <category term="cors" scheme="https://www.sekyoro.top/tags/cors/"/>
    
    <category term="csp" scheme="https://www.sekyoro.top/tags/csp/"/>
    
    <category term="浏览器" scheme="https://www.sekyoro.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>学习purecss构建自己的css框架</title>
    <link href="https://www.sekyoro.top/2023/02/18/%E5%AD%A6%E4%B9%A0purecss%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84css%E6%A1%86%E6%9E%B6/"/>
    <id>https://www.sekyoro.top/2023/02/18/%E5%AD%A6%E4%B9%A0purecss%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84css%E6%A1%86%E6%9E%B6/</id>
    <published>2023-02-18T04:35:33.000Z</published>
    <updated>2023-02-18T04:58:31.377Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>更加简易的Bootstrap框架,定制度更高.比Tailwind轻量.<br><span id="more"></span></p><p>中文官方文档<a href="https://purecss.cn/start.html">开始使用 - Pure | Pure中文站 | Purecss学习网</a></p><p>官网有最新版<a href="https://purecss.io/start/">Get Started - Pure (purecss.io)</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;更加简易的Bootstrap框架,定制度更高.比Tailwind轻量.&lt;br&gt;</summary>
    
    
    
    
    <category term="css" scheme="https://www.sekyoro.top/tags/css/"/>
    
    <category term="pure.css" scheme="https://www.sekyoro.top/tags/pure-css/"/>
    
  </entry>
  
  <entry>
    <title>DLHLP学习</title>
    <link href="https://www.sekyoro.top/2023/02/17/DLHLP%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2023/02/17/DLHLP%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-02-17T02:37:57.000Z</published>
    <updated>2023-02-17T03:03:53.064Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>李宏毅的语言处理. Deep Learning for Human Language Processing.<br><span id="more"></span></p><p>课程链接<a href="https://www.youtube.com/watch?v=nER51ZyJaCQ&amp;list=PLJV_el3uVTsO07RpBYFsXg-bN5Lu0nhdG&amp;ab_channel=Hung-yiLee">DLHLP 2020] Deep Learning for Human Language Processing (Course Overview) - YouTube</a></p><p><img data-src="http://cdn.sekyoro.top/imgs/17/0220230217105241.png" alt="image-20230217105215776" style="zoom:67%;" /></p><h3 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h3><p>传统语音处理</p><p><img data-src="http://cdn.sekyoro.top/imgs/17/0220230217105753.png" alt="image-20230217105753162"></p><p>ASR(automatic speech recognition)</p><h3 id="语音合成"><a href="#语音合成" class="headerlink" title="语音合成"></a>语音合成</h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;李宏毅的语言处理. Deep Learning for Human Language Processing.&lt;br&gt;</summary>
    
    
    
    
    <category term="Deep Learning" scheme="https://www.sekyoro.top/tags/Deep-Learning/"/>
    
    <category term="Speech" scheme="https://www.sekyoro.top/tags/Speech/"/>
    
  </entry>
  
  <entry>
    <title>docker学习</title>
    <link href="https://www.sekyoro.top/2023/02/13/docker%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2023/02/13/docker%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-02-13T09:41:44.000Z</published>
    <updated>2023-02-13T15:27:29.952Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Docker可以方便部署以及利用镜像快速学习一些项目,解决环境冲突等.重点关注Dockerfile和docker-compose文件的编写.<br><span id="more"></span></p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Docker 是一个开源的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html">Go 语言</a> 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><blockquote><p>Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p></blockquote><ul><li>Web 应用的自动化打包和发布。</li><li>自动化测试和持续集成、发布。</li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li><li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li></ul><h3 id="镜像-image"><a href="#镜像-image" class="headerlink" title="镜像(image)"></a>镜像(image)</h3><p>镜像类似于一个打包好的软件或可执行程序,可以通过运行这个镜像得到容器(类似于一个进程).</p><p>镜像可以<strong>自己打包</strong>或从<strong>Docker Hub</strong><a href="https://hub.docker.com/">Docker Hub Container Image Library | App Containerization</a>获取,如果本地没有打包的默认从后者拉取.</p><p>自己打包需要Dockerfile定制这个”可执行程序”,有了Dockerfile后可以使用<code>docker build .</code>构建镜像.</p><p><code>.</code>符号表示在这个目录下的Dockerfile文件.</p><p>一个镜像可以在多个容器运行,可以将镜像分享给别人.</p><p>使用<code>docker run</code>运行镜像,如果本地没有会自动<code>docker pull</code>拉取.</p><p>使用<code>docker push</code>可以将自己的镜像推送到Docker Hub.</p><p>这里我们创建一个小项目.</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213175949.png" alt="image-20230213175925727" style="zoom:50%;" /></p><p>创建一个服务监听端口.</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213175946.png" alt="image-20230213175946483"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span></span><br><span class="line">        &#123;</span><br><span class="line">res.send(<span class="string">&#x27;&lt;p&gt;你好&lt;/p&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">app.listen(port,<span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="string">&quot;端口是3000&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写好后就可以直接创建Dockerfile建立镜像了.</p><p>首先Dockerfile文件创建在项目根目录中.</p><p>需要先拉取镜像,可以在<a href="https://hub.docker.com/">Docker Hub Container Image Library | App Containerization</a>中查找.</p><p>首先我们用到了node,所以需要拉取相应的node镜像(一般node镜像肯定带了OS等底层的镜像)</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213180313.png" alt="image-20230213180312673" style="zoom: 50%;" /></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">19</span>-alpine3.<span class="number">16</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /myworkdir</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm i</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;node&quot;</span>,<span class="string">&quot;app.js&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>docker会一行一行扫描代码.</p><p>FROM表示拉取node:19-alpine3.16,node:19-alpine3.16是镜像名,19-alpine3.16表示版本,node 19版本,alpine是一个操作系统常用于Docker构建.  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myimage:v1  .</span><br></pre></td></tr></table></figure><p>如果不使用tag,则没有名字</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/02image-20230213190037683.png" alt="image-20230213190037683"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag &lt;IMAGE ID&gt; &lt;REPO:TAG&gt;</span><br></pre></td></tr></table></figure><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213190203.png" alt="image-20230213190203625"></p><p>没有tag默认latest</p><p>使用<code>docker push</code>推送镜像</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213190322.png" alt="image-20230213190322542" style="zoom:50%;" /></p><p>使用<code>docker rmi</code>删除本地镜像</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213190427.png" alt="image-20230213190427515"></p><p>使用<code>docker pull</code>拉取Docker Hub中的镜像.</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213190537.png" alt="image-20230213190537437"></p><h3 id="容器-container"><a href="#容器-container" class="headerlink" title="容器(container)"></a>容器(container)</h3><p>使用<code>docker run &lt;镜像名&gt;</code>运行镜像从而得到</p><p><code>-d</code>参数后台运行</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213191520.png" alt="image-20230213191519991" style="zoom:67%;" /></p><p>使用<code>docker images</code>查询镜像信息.</p><p>使用<code>docker ps</code>查询容器信息.</p><p>这里并不能直接通过3000端口访问网页,因为并没有实际暴露.</p><p>Dockerfile文件中EXPOSE命令只是标识提醒作用.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3000:3000 --name mydocker proanimer/nodejs:<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><code>-p</code>参数表示端口映射 本地3000映射后者容器的3000.</p><p><code>--name</code>参数表示给容器命名,否则有默认命名.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3000:3000 --name mydockerpro proanimer/nodejs:<span class="built_in">test</span>           </span><br></pre></td></tr></table></figure><p>使用<code>docker stop &lt;容器id&gt;</code>停止运行.</p><p>使用<code>docker rm &lt;容器id&gt;</code>删除窗口.</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213192549.png" alt="image-20230213192549208"></p><p>修改文件后容器并不会跟着改变,因为修改的文件时本地镜像中的文件,容器是之前的镜像运行后的结果.我们需要与运行的容器直接交互.</p><p>使用<code>docker exec -it &lt;镜像名或id&gt; /bin/sh</code> </p><p><code>/bin/sh</code>是容器中os的shell.</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213201031.png" alt="image-20230213195526472"></p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213201022.png" alt="image-20230213200936929"></p><p>注意 如果在Windows上需要加上winpty,同时设定shell路径时是<code>//bin/sh</code>即需要多加上一个<code>/</code></p><p>注意进入容器后很多工具比如vim可能都没有,所以需要用到路径映射.</p><p>设置volume,-v 把本地指定文件夹和容器指定文件夹绑定</p><p>这里使用</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213210813.png" alt="image-20230213210813343">注意如果是git bash for windows.使用下面命令,</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  -v F://docker_exp1://myworkdir -p 3000:3000 --name mypro proanimer/nodejs:<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213220937.png" alt="image-20230213220937554"></p><p>发现挂载路径有/hostmnt,这是git bash比较特别的,表示宿主机.</p><p>如果是在windows的powershell.</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213220123.png" alt="image-20230213220122719"></p><p>检查挂载路径,<img data-src="http://cdn.sekyoro.top/imgs/13/0220230213221258.png" alt="image-20230213221258083" style="zoom:80%;" /></p><p>两者这里不同,但本质上是一样的.</p><p>注意,这里路径映射时是依照宿主机的,即如果宿主机/dir上有A,B文件,容器路径中/dir中有C文件,将这两个路径映射,则实际用时是A,B文件.</p><p>同时使用<code>-v 目录</code>对这个容器中的目录不进行同步.本地只读后增加:ro</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213225237.png" alt="image-20230213225237389" style="zoom:67%;" /></p><p><strong>ro模式</strong></p><p>（1）文件：容器内不能修改，会提示read-only</p><p>（2）文件夹：容器内不能修改、新增、删除文件夹中的文件，会提示read-only</p><p><code>docker rm -fv</code>同时把volume删除.</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>通过写Dockerfile定制镜像文件,使用<code>docker build</code>创建镜像.</p><h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p><strong>FROM</strong>：定制的镜像都是基于FROM的镜像</p><h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p><strong>RUN</strong>：用于执行后面跟着的命令行命令。有以下两种格式：</p><p>shell 格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;命令行命令&gt;</span><br><span class="line"><span class="comment"># &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span></span><br></pre></td></tr></table></figure><p>exec 格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN [<span class="string">&quot;可执行文件&quot;</span>, <span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>]</span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line"><span class="comment"># RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN **yum** -y **install** **wget**</span><br><span class="line">RUN **wget** -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span><br><span class="line">RUN **tar** -xvf redis.tar.gz</span><br></pre></td></tr></table></figure><p>以上执行会创建 3 层镜像。可简化为以下格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum -y install wget \</span><br><span class="line">  &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span><br><span class="line">  &amp;&amp; tar -xvf redis.tar.gz</span><br></pre></td></tr></table></figure><p>如上，以 <strong>&amp;&amp;</strong> 符号连接命令，这样执行后，只会创建 1 层镜像。</p><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p><ul><li><strong>CMD 在docker run</strong> 时运行。</li><li><strong>RUN 是在 docker build</strong>即构建时运行.</li></ul><p><strong>作用</strong>：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD &lt;shell 命令&gt; </span><br><span class="line">CMD [<span class="string">&quot;&lt;可执行文件或命令&gt;&quot;</span>,<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...] </span><br><span class="line">CMD [<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...]  <span class="comment"># 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span></span><br></pre></td></tr></table></figure><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p><p>但是, 如果运行 docker run 时使用了 —entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序。</p><p><strong>优点</strong>：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [<span class="string">&quot;&lt;executeable&gt;&quot;</span>,<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...]</span><br></pre></td></tr></table></figure><h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。</p><p>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> &lt;工作目录路径&gt;</span></span><br></pre></td></tr></table></figure><h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p><p>作用：</p><ul><li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li><li>避免容器不断变大。</li></ul><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">&quot;&lt;路径1&gt;&quot;</span>, <span class="string">&quot;&lt;路径2&gt;&quot;</span>...]</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> &lt;路径&gt;</span></span><br></pre></td></tr></table></figure><p>在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。</p><h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p>仅仅只是声明端口. <strong>注意</strong>并没有实际作用</p><p>作用：</p><ul><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li><li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li></ul><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;端口<span class="number">1</span>&gt; [&lt;端口<span class="number">2</span>&gt;...]</span><br></pre></td></tr></table></figure><h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="keyword">ENV</span> &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br></pre></td></tr></table></figure><p>以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span></span><br><span class="line"><span class="bash">  &amp;&amp; curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span></span></span><br></pre></td></tr></table></figure><h4 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h4><p>构建参数，与 ENV 作用一致。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</p><p>构建命令 docker build 中可以用 —build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> &lt;参数名&gt;[=&lt;默认值&gt;]</span><br></pre></td></tr></table></figure><h4 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h4><p>用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在<strong>本次构建镜像的过程中不会执行</strong>（假设镜像为 test-build）。当有新的 Dockerfile <strong>使用了之前构建的镜像 FROM test-build ，这时执行新镜像的 Dockerfile 构建时候，会执行</strong> test-build 的 Dockerfile 里的 ONBUILD 指定的命令。</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ONBUILD</span> &lt;其它指令&gt;</span><br></pre></td></tr></table></figure><h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p>LABEL 指令用来给镜像添加一些元数据（metadata），以键值对的形式，语法格式如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt; =&lt;value&gt; ...</span></span><br></pre></td></tr></table></figure><p>比如我们可以添加镜像的作者：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL org.opencontainers.image.authors=<span class="string">&quot;runoob&quot;</span></span><br></pre></td></tr></table></figure><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h3><p>启动多个容器处理应用.</p><p>yaml文件格式.</p><p><strong>基本语法</strong></p><ul><li><strong>大小写敏感</strong></li><li><strong>使用缩进表示层级关系</strong></li><li>缩进不允许使用tab，<strong>只允许空格</strong></li><li>缩进的空格数不重要，<strong>只要相同层级的元素左对齐即可</strong></li><li>‘#’表示注释</li></ul><p>创建docker-compose.yml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yaml 配置实例</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">.:/code</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">logvolume01:/var/log</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">logvolume01:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>services下都是镜像,build表示通过Dockerfile构建.</p><p>ports和volumes用于映射端口和数据卷.</p><p>使用命令<code>docker-compose up -d --build</code>-d表示后台,—build表示如果镜像修改就会重建.</p><h4 id="version"><a href="#version" class="headerlink" title="version"></a>version</h4><p>指定本 yml 依从的 compose 哪个版本制定的。</p><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>指定为构建镜像上下文路径：</p><h4 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h4><p>将主机的数据卷或着文件挂载到容器里。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:latest</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/localhost/postgres.sock:/var/run/postgres/postgres.sock&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/localhost/data:/var/lib/postgresql/data&quot;</span></span><br></pre></td></tr></table></figure><h4 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h4><p>暴露端口，但不映射到宿主机，只允许能被连接的服务访问。仅可以指定内部端口为参数，如下所示：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">expose:</span></span><br><span class="line">    - <span class="string">&quot;3000&quot;</span></span><br><span class="line">    - <span class="string">&quot;8000&quot;</span></span><br></pre></td></tr></table></figure><h4 id="links"><a href="#links" class="headerlink" title="links"></a>links</h4><p>链接到其它服务中的容器。使用服务名称（同时作为别名），或者服务名称:服务别名（如 SERVICE:ALIAS），例如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">links:</span><br><span class="line"><span class="bullet">    -</span> db</span><br><span class="line"><span class="bullet">    -</span> db:database</span><br><span class="line"><span class="bullet">    -</span> redis</span><br></pre></td></tr></table></figure><p>使用<code>docker-compose down -v</code>删除镜像同时删除volume</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.cnblogs.com/minseo/p/11548177.html">Docker入门之docker-compose - minseo - 博客园 (cnblogs.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;Docker可以方便部署以及利用镜像快速学习一些项目,解决环境冲突等.重点关注Dockerfile和docker-compose文件的编写.&lt;br&gt;</summary>
    
    
    
    
    <category term="tutorial" scheme="https://www.sekyoro.top/tags/tutorial/"/>
    
    <category term="docker" scheme="https://www.sekyoro.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>TotalCommander使用和学习</title>
    <link href="https://www.sekyoro.top/2023/02/07/TotalCommander%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2023/02/07/TotalCommander%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-02-07T08:21:28.000Z</published>
    <updated>2023-02-07T10:39:45.484Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用TotalCommander提升平时工作学习效率.<br><span id="more"></span></p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>由于之前使用Premiere Pro时发现必须使用管理员身份打开,否则会出现莫名奇妙的问题包含但不限于<code>显示表面初始化失败</code>以及后面打开时无法使用一些<code>动态运动图形素材</code>.</p><p>当使用管理员身份打开后,就难以从文件管理器中拖入文件到素材库中. 因为权限问题无法拖入.</p><iframe src="//player.bilibili.com/player.html?aid=393029005&bvid=BV12d4y1V7Ns&cid=972854406&page=1" scrolling="yes" border="2" frameborder="yes" framespacing="5" allowfullscreen="true"> </iframe><p>简单的方法可以打开注册表设置LUA为0,但这个方法并不推荐.或者用管理员身份打开Everything软件,从Everything中拖入素材.</p><p>但是Everything这个软件还是适合直接用来找文件,后面查询了一些资料发现了Total Commander这个工具以管理员身份打开用来拖文件到素材库.发现这个工具还挺不错的.</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>Total Commander，简称TC，原名Windows Commander，功能强大的全能文件管理器。Total Commander 是<a href="https://baike.baidu.com/item/共享软件/680839">共享软件</a>，<a href="https://baike.baidu.com/item/官网/7805125">官网</a>下载版本为一个月<a href="https://baike.baidu.com/item/试用版/1656171">试用版</a></p></blockquote><p><img data-src="http://cdn.sekyoro.top/imgs/07/0220230207172756.png" alt="image-20230207172746360" style="zoom:67%;" /></p><p>所以这里就需要动用自己找资源的能力了,我在本文最后附有我找到的破解版下载网址,可以跳过其中的打开注册表文件夹操作,原价现在貌似需要200多.</p><p>可以看到这里就是一个没有怎么配置的TC界面.</p><p>这里直接使用别人的图片</p><p><img data-src="https://pic3.zhimg.com/80/v2-75f6664b0bd8160569a8254fb03c0572_720w.webp" alt="img" style="zoom:80%;" /></p><p>以管理员身份打开,测试成功.可以拖入素材</p><p><img data-src="http://cdn.sekyoro.top/imgs/07/0220230207175417.png" alt="image-20230207175417295"></p><p>到这里其实我的目的就达到了,不过这个工具其实思想跟Linux系统常用的桌面管理器类似(我之前的文章也介绍过),所以稍微学习一下也不错.</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>这个软件有两侧文件夹栏目</p><p><strong>标签栏常用快捷键</strong>:<br>Ctrl+T 创建标签页<br>Ctrl+W 关闭标签页<br>Ctrl+Shift+W 关闭所有非锁定标签页<br>Ctrl+Tab键 切换下一个标签<br>Ctrl+Shift+Tab键 切换上一个标签页</p><p>Ctrl+D 唤出书签栏菜单</p><p>ctrl+q 快速预览效果</p><p>ctrl+\ 跳转到跟目录</p><p> Ctrl + →或←，将光标下的文件夹或压缩包在另一个窗口打开</p><p>Alt +↓显示 历史文件夹，Alt + ←到 前一个访问过的目录，Alt + →到 后一个访问过的目录。</p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p><img data-src="http://cdn.sekyoro.top/imgs/07/0220230207172756.png" style="zoom:50%;" /></p><p>其实更多的就需要自己配快捷键了.另外还有插件等,这里就不更多探索了.</p><p>这里由于我需要输入文件路径到目录下拖素材,所以增加了快捷键.</p><p><img data-src="http://cdn.sekyoro.top/imgs/07/0220230207175417.png" style="zoom:80%;" /></p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/163301413">Total Commander用法介绍 - 知乎 (zhihu.com)</a></li><li><a href="https://www.jb51.net/softs/824660.html">Total Commander破解补丁下载</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用TotalCommander提升平时工作学习效率.&lt;br&gt;</summary>
    
    
    
    
    <category term="TotalCommander" scheme="https://www.sekyoro.top/tags/TotalCommander/"/>
    
    <category term="工具使用" scheme="https://www.sekyoro.top/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    <category term="效率提升" scheme="https://www.sekyoro.top/tags/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>闲置服务器BT下载影视</title>
    <link href="https://www.sekyoro.top/2023/01/23/%E9%97%B2%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8BT%E4%B8%8B%E8%BD%BD%E5%BD%B1%E8%A7%86/"/>
    <id>https://www.sekyoro.top/2023/01/23/%E9%97%B2%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8BT%E4%B8%8B%E8%BD%BD%E5%BD%B1%E8%A7%86/</id>
    <published>2023-01-23T13:38:55.000Z</published>
    <updated>2023-01-24T05:26:11.614Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>利用闲置服务器通过BT SSR下载动漫,并通过filebrowser浏览下载.<br><span id="more"></span></p><h2 id="FileBrowser"><a href="#FileBrowser" class="headerlink" title="FileBrowser"></a>FileBrowser</h2><blockquote><p>filebrowser 是一个使用go语言编写的软件，功能是可以通过浏览器对服务器上的文件进行管理。可以是修改文件，或者是添加删除文件，甚至可以分享文件，是一个很棒的文件管理器，你甚至可以当成一个网盘来使用。</p></blockquote><p>在网站上下载压缩包后并解压.</p><p><a href="https://github.com/filebrowser/filebrowser">filebrowser/filebrowser: 📂 Web File Browser (github.com)</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf linux-amd64-filebrowser.tar.gz</span><br><span class="line">CHANGELOG.md</span><br><span class="line">LICENSE</span><br><span class="line">README.md</span><br><span class="line">filebrowser</span><br></pre></td></tr></table></figure><p>直接运行程序,默认端口在8080</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> ./filebrowser</span><br><span class="line">15:22:42 No config file used</span><br><span class="line">15:22:42 Listening on 127.0.0.1:8080</span><br></pre></td></tr></table></figure><p>一般都需要更改这个默认端口,可以先找到其db配置文件.</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>你可以直接通过命令参数filebrowser 后接参数设置,这里我推荐设置db文件.</p><p><img data-src="http://cdn.sekyoro.top/imgs/23/0120230123235939.png" alt="image-20230123221036526" style="zoom:80%;" /></p><p>默认配置文件在上面三个目录下你可以依次找看有没有.db文件,如果没有可以通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filebrowser config init</span><br></pre></td></tr></table></figure><p>新建文件,然后通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filebrowser config cat</span><br></pre></td></tr></table></figure><p>查看设置</p><p><img data-src="http://cdn.sekyoro.top/imgs/23/0120230123235942.png" alt="image-20230123221243713" style="zoom:67%;" /></p><p>我们可以通过filebrowser config set -p 9200设置运行端口为9200.</p><h3 id="设置安全组"><a href="#设置安全组" class="headerlink" title="设置安全组"></a>设置安全组</h3><p>开启后注意在服务器商那,比如腾讯云,阿里云拿<strong>设置安全组</strong>开通这个端口,允许外网访问,<strong>同时</strong>还要在服务器这开启端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=9201/tcp --permanent</span><br></pre></td></tr></table></figure><p>同时最好重启一下防火墙服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p>进入目录/lib/systemd/system,可以新建filebrowser.service或者下载一个类似的文件.</p><p><img data-src="http://cdn.sekyoro.top/imgs/23/0120230123235958.png" alt="image-20230123222348866"></p><p>写入以上内容,主要设置-d 配置刚才的db文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start filebrowser.service</span><br></pre></td></tr></table></figure><p>开启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> filebrowser.service</span><br></pre></td></tr></table></figure><p>设置开机自启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status filebrowser.service</span><br></pre></td></tr></table></figure><p>查看运行状态</p><p><img data-src="http://cdn.sekyoro.top/imgs/23/0120230123235947.png" alt="image-20230123223854973"></p><p>然后打开你的网站,即公网ip+port,打开后类似如下图</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000007.png" alt="image-20230123222855110" style="zoom:80%;" /></p><p>可以在设置页面设置一些选项.</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000010.png" alt="image-20230123222951056" style="zoom:67%;" />这样设置后就能访问某个文件夹下的内容了.</p><h2 id="qbtorrent"><a href="#qbtorrent" class="headerlink" title="qbtorrent"></a>qbtorrent</h2><p>qbtorrent下载之前讲过,现在就是需要查看webui,以及放开相应端口,设置后台运行.</p><p>操作跟刚才类似.</p><p>在Centos下下载qb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y qbittorrent-nox</span><br></pre></td></tr></table></figure><p>其他平台类似,当然也可以自己下载包编译安装.</p><p>下载安装后直接运行,默认端口8080</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qbittorrent-nox</span><br></pre></td></tr></table></figure><h3 id="开启后台运行服务"><a href="#开启后台运行服务" class="headerlink" title="开启后台运行服务"></a>开启后台运行服务</h3><blockquote><p>/usr/lib/systemd/system/目录下，您将找到一个qbittorrent-nox@.service文件。通过运行以下命令，使qbittorrent-nox在启动时自动启动。替换username为您的实际用户名。</p></blockquote><p>可以用whoami命令查看当前用户.</p><p>注意这里的username是您的用户名</p><p>然后开启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start qbittorrent-nox@username.service</span><br></pre></td></tr></table></figure><p>开机启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> qbittorrent-nox@username.service</span><br></pre></td></tr></table></figure><p>在那个目录下可以查看并配置这个服务</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000014.png" alt="image-20230123224137176"></p><p>然后更改端口</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/01image-20230123224224945.png" alt="image-20230123224224945"></p><p>后面设置安全组什么的跟上面类似.</p><p>打开这个端口即可. 默认username:admin  password:adminadmin</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000018.png" alt="image-20230123224318627"></p><p>用户界面</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000026.png" alt="image-20230123224417888" style="zoom:50%;" /></p><h3 id="更改web-ui密码"><a href="#更改web-ui密码" class="headerlink" title="更改web ui密码"></a>更改web ui密码</h3><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000030.png" alt="image-20230123224715884"></p><p>在tools-&gt;options-&gt;web ui中更改语言,验证信息.</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000033.png" alt="image-20230123224801908" style="zoom:67%;" /></p><h3 id="设置下载路径"><a href="#设置下载路径" class="headerlink" title="设置下载路径"></a>设置下载路径</h3><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000037.png" alt="image-20230123225109400" style="zoom:67%;" /></p><p>将下载的文件放在filebrowser暴露的文件中,然后最好设置完成后删除torrent节省空间.</p><h3 id="设置RSS"><a href="#设置RSS" class="headerlink" title="设置RSS"></a>设置RSS</h3><p>注意,截至现在时间qbittorrent版本是4.2.5,其Web UI界面没有RSS订阅功能.</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/01image-20230123234248037.png" alt="image-20230123234248037"></p><p>这里我们设置第三方UI增加RSS订阅功能,这样就不用手动加磁力链接了.</p><p>有两种方法,其中一种需要开启HTTPS,懒得去申请了.</p><p>第二种需要下载文件到服务器,下载Release文件并解压.</p><p><a href="https://github.com/CzBiX/qb-web">CzBiX/qb-web: A qBittorrent Web UI, write in TypeScript+Vue. (github.com)</a></p><p>将解压后的文件放在服务器某个位置.</p><p>在设置界面 web UI下文件路径放那个文件的路径,比如 /config/dist. dist就是解压后的文件夹.</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000045.png" alt="image-20230123234702168"></p><p>然后打开网页即可.</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000048.png" alt="image-20230123234752928" style="zoom:67%;" /></p><p>左侧点击RSS增加RSS功能即可.</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000051.png" alt="image-20230123234823176" style="zoom:67%;" /></p><p>可以结合之前我的文章查看一些RSS订阅源.比如利用蜜柑计划等等…</p><h3 id="部分优化"><a href="#部分优化" class="headerlink" title="部分优化"></a>部分优化</h3><h4 id="增加tracker"><a href="#增加tracker" class="headerlink" title="增加tracker"></a>增加tracker</h4><p>需要切换到原来的UI</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000102.png" alt="image-20230123235226961" style="zoom: 67%;" /></p><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><ol><li><a href="https://www.filebrowser.cn/">filebrowser 是一款非常优秀的文件管理工具，并且是跨平台。安装也非常简单，安装后就可以使用，同样使用也非常的简单。在linux环境中使用的比较多</a></li><li><a href="https://github.com/filebrowser/filebrowser">filebrowser/filebrowser: 📂 Web File Browser (github.com)</a></li><li><a href="https://www.cnblogs.com/webenh/p/13334303.html">File Browser 安装及使用 - WebEnh - 博客园 (cnblogs.com)</a></li><li><a href="https://www.cnblogs.com/a5idc/p/13784155.html">如何在CentOS 8 / RHEL 8服务器上安装qBittorrent - A5互联 - 博客园 (cnblogs.com)</a></li><li><a href="https://www.misterma.com/archives/902/">Linux 服务器安装 qBittorrent - Mr. Ma’s Blog (misterma.com)</a></li><li><a href="https://eatash.com/index.php/2021/09/02/qbittorrent这两个-第三方-webui-还不错-geekman/">qbittorrent这两个 第三方 webui 还不错-Geekman | 吃灰网 (eatash.com)</a></li><li><a href="https://www.jianshu.com/p/54a6bf9e5ebe">Docker版qBittorrent或qBittorrent WebUI使用RSS功能 - 简书 (jianshu.com)</a></li><li><a href="https://github.com/CzBiX/qb-web">CzBiX/qb-web: A qBittorrent Web UI, write in TypeScript+Vue. (github.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;利用闲置服务器通过BT SSR下载动漫,并通过filebrowser浏览下载.&lt;br&gt;</summary>
    
    
    
    
    <category term="torrent" scheme="https://www.sekyoro.top/tags/torrent/"/>
    
    <category term="Centos" scheme="https://www.sekyoro.top/tags/Centos/"/>
    
    <category term="filebrowser" scheme="https://www.sekyoro.top/tags/filebrowser/"/>
    
  </entry>
  
  <entry>
    <title>dart学习</title>
    <link href="https://www.sekyoro.top/2023/01/14/dart%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2023/01/14/dart%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-01-14T13:45:23.000Z</published>
    <updated>2023-01-14T14:20:48.628Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>基本就是看看文档,对比学习.注意重点.<br><span id="more"></span></p><blockquote><p>所有变量引用的都是 <strong>对象</strong>，每个对象都是一个 <strong>类</strong> 的实例。数字、函数以及 <code>null</code> 都是对象。除去 <code>null</code> 以外（如果你开启了 <a href="https://dart.cn/null-safety">空安全</a>）, 所有的类都继承于 <a href="https://api.dart.cn/stable/dart-core/Object-class.html"><code>Object</code></a> 类。</p></blockquote><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>Dart 是支持<strong>基于 mixin 继承机制</strong>的面向对象语言，所有对象都是一个类的实例，而除了 <code>Null</code> 以外的所有的类都继承自 <a href="https://api.dart.cn/stable/dart-core/Object-class.html"><code>Object</code></a> 类。 <strong>基于 mixin 的继承</strong> 意味着尽管每个类（<a href="https://dart.cn/null-safety/understanding-null-safety#top-and-bottom">top class</a> <code>Object?</code> 除外）都只有一个超类，一个类的代码可以在其它多个类继承中重复使用。 <a href="https://dart.cn/guides/language/language-tour#extension-methods">扩展方法</a> 是一种在不更改类或创建子类的情况下向类添加功能的方式</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;基本就是看看文档,对比学习.注意重点.&lt;br&gt;</summary>
    
    
    
    
    <category term="dart" scheme="https://www.sekyoro.top/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>python构建微信公众号文章发表控制台应用</title>
    <link href="https://www.sekyoro.top/2023/01/04/python%E6%9E%84%E5%BB%BA%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0%E5%8F%91%E8%A1%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%BA%94%E7%94%A8/"/>
    <id>https://www.sekyoro.top/2023/01/04/python%E6%9E%84%E5%BB%BA%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0%E5%8F%91%E8%A1%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%BA%94%E7%94%A8/</id>
    <published>2023-01-04T15:41:43.000Z</published>
    <updated>2023-01-08T08:57:32.788Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用Python构建控制台应用,简单一点.主目的是抓取某个网站图片然后上传到素材.<br><span id="more"></span></p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="获取access-token"><a href="#获取access-token" class="headerlink" title="获取access token"></a>获取access token</h3><p>首先需要知道自己的开发者AppID和开发者密码AppSecret.</p><p>然后获取access token</p><blockquote><p>https请求方式: GET <a href="https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET">https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</a></p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">是否必须</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">grant_type</td><td style="text-align:left">是</td><td style="text-align:left">获取access_token填写client_credential</td></tr><tr><td style="text-align:left">appid</td><td style="text-align:left">是</td><td style="text-align:left">第三方用户唯一凭证</td></tr><tr><td style="text-align:left">secret</td><td style="text-align:left">是</td><td style="text-align:left">第三方用户唯一凭证密钥，即appsecret</td></tr></tbody></table></div><p><strong>返回说明</strong></p><p>正常情况下，微信会返回下述 JSON 数据包给公众号：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;access_token&quot;</span>:<span class="string">&quot;ACCESS_TOKEN&quot;</span>,<span class="attr">&quot;expires_in&quot;</span>:<span class="number">7200</span>&#125;</span><br></pre></td></tr></table></figure><p>错误时微信会返回错误码等信息，JSON数据包示例如下（该示例为 AppID 无效错误）:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;errcode&quot;</span>:<span class="number">40013</span>,<span class="attr">&quot;errmsg&quot;</span>:<span class="string">&quot;invalid appid&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="素材管理"><a href="#素材管理" class="headerlink" title="素材管理"></a>素材管理</h2><h3 id="新增永久素材"><a href="#新增永久素材" class="headerlink" title="新增永久素材"></a>新增永久素材</h3><p>对于常用的素材，开发者可通过本接口上传到微信服务器，永久使用。新增的永久素材也可以在公众平台官网素材管理模块中查询管理。</p><p>通过 POST 表单来调用接口，表单 id 为media，包含需要上传的素材内容，有filename、filelength、content-type等信息。</p><p><strong>请注意：图片素材将进入公众平台官网素材管理模块中的默认分组。</strong>也就是说现在还不支持上传素材时创建分组.不过问题不大,到时候写文章时手动</p><blockquote><p>http请求方式: POST，需使用https <a href="https://api.weixin.qq.com/cgi-bin/material/add_material?access_token=ACCESS_TOKEN&amp;type=TYPE">https://api.weixin.qq.com/cgi-bin/material/add_material?access_token=ACCESS_TOKEN&amp;type=TYPE</a> </p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">是否必须</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">access_token</td><td style="text-align:left">是</td><td style="text-align:left">调用接口凭证</td></tr><tr><td style="text-align:left">type</td><td style="text-align:left">是</td><td style="text-align:left">媒体文件类型，分别有图片（image）、语音（voice）、视频（video）和缩略图（thumb）</td></tr><tr><td style="text-align:left">media</td><td style="text-align:left">是</td><td style="text-align:left">form-data中媒体文件标识，有filename、filelength、content-type等信息</td></tr></tbody></table></div><p>新增永久视频素材需特别注意</p><p>在上传视频素材时需要 POST 另一个表单，id为description，包含素材的描述信息，内容格式为JSON，格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>:VIDEO_TITLE,</span><br><span class="line">    <span class="attr">&quot;introduction&quot;</span>:INTRODUCTION</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">是否必须</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">title</td><td style="text-align:left">是</td><td style="text-align:left">视频素材的标题</td></tr><tr><td style="text-align:left">introduction</td><td style="text-align:left">是</td><td style="text-align:left">视频素材的描述</td></tr></tbody></table></div><p>返回说明</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;media_id&quot;</span>:MEDIA_ID,</span><br><span class="line">  <span class="attr">&quot;url&quot;</span>:URL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取素材总数"><a href="#获取素材总数" class="headerlink" title="获取素材总数"></a>获取素材总数</h3><p>永久素材的总数，也会计算公众平台官网素材管理中的素材 2.图片和图文消息素材（包括单图文和多图文）的总数上限为100000，其他素材的总数上限为1000 3.调用该接口需 https 协议</p><p>接口调用请求说明</p><blockquote><p>http请求方式: GET <a href="https://api.weixin.qq.com/cgi-bin/material/get_materialcount?access_token=ACCESS_TOKEN">https://api.weixin.qq.com/cgi-bin/material/get_materialcount?access_token=ACCESS_TOKEN</a></p></blockquote><h2 id="使用库"><a href="#使用库" class="headerlink" title="使用库"></a>使用库</h2><p>requests发送http请求,lxml解析html,tqdm显示进度条.</p><p>主要功能 爬取某个网站的所有图片,将某个文件夹下的图片全部上传.</p><p>一天随便写了写,比较菜还请见谅.</p><h3 id="用户类"><a href="#用户类" class="headerlink" title="用户类"></a>用户类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.access_token = <span class="literal">None</span></span><br><span class="line">        self.__appId = <span class="built_in">input</span>(<span class="string">&#x27;请输入您的appid:&#x27;</span>)</span><br><span class="line">        self.__appSecret = <span class="built_in">input</span>(<span class="string">&#x27;请输入您的appsecret:&#x27;</span>)</span><br><span class="line">        self.logintime = <span class="number">3</span></span><br><span class="line">        self.login()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> self.logintime:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                res = requests.get(</span><br><span class="line">                    <span class="string">f&quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=<span class="subst">&#123;self.__appId&#125;</span>&amp;secret=<span class="subst">&#123;self.__appSecret&#125;</span>&quot;</span>, )</span><br><span class="line">                <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">                    self.access_token = res.json()[<span class="string">&#x27;access_token&#x27;</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;输入错误!请尝试再次输入,还剩&#x27;</span> + self.logintime + <span class="string">&#x27;次机会&#x27;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;错误&#x27;</span>, res.json(), e)</span><br><span class="line">            self.logintime = self.logintime - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;退出&#x27;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里就是注册 没什么好说的 可以增加一个错误机会.</p><h3 id="获取图片类"><a href="#获取图片类" class="headerlink" title="获取图片类"></a>获取图片类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__url = <span class="literal">None</span></span><br><span class="line">        self.title = <span class="literal">None</span></span><br><span class="line">        self.__header = &#123;</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &#x27;</span></span><br><span class="line">                          <span class="string">&#x27;Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1462.54&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        self.filepathList = <span class="built_in">set</span>()</span><br><span class="line">        self.getUpdated()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getUpdated</span>(<span class="params">self</span>):</span></span><br><span class="line">        url = <span class="string">&#x27;https://www.pixivision.net/zh/c/illustration&#x27;</span></span><br><span class="line">        res = requests.get(url,headers=self.__header)</span><br><span class="line">        selector = etree.HTML(res.text)</span><br><span class="line">        lastUpdatedNumber = selector.xpath(<span class="string">&quot;//li[@class=&#x27;article-card-container&#x27;][1]/article/div[@class=&#x27;arc__thumbnail-container&#x27;]/a[1]/@href&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">        lastUpdatedNumber = lastUpdatedNumber.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;最新的图文号为&#x27;</span>,lastUpdatedNumber)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getarticle</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__url = <span class="built_in">input</span>(<span class="string">&#x27;输入网站链接(仅限pixvision:https://www.pixivision.net/zh/a/number):&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.__url.isnumeric():</span><br><span class="line">            self.__url = <span class="string">&#x27;https://www.pixivision.net/zh/a/&#x27;</span> + self.__url</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = requests.get(self.__url, headers=self.__header)</span><br><span class="line">        <span class="keyword">except</span> requests.exceptions.ProxyError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;网络出现问题&#x27;</span>, e)</span><br><span class="line">            sys.exit(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;出错&#x27;</span>, e)</span><br><span class="line">            sys.exit(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        selector = etree.HTML(res.text)</span><br><span class="line">        imgLinks = selector.xpath(</span><br><span class="line">            <span class="string">&quot;////div[@class=&#x27;_feature-article-body&#x27;]/div[@class=&#x27;article-item _feature-article-body__pixiv_illust&#x27;]//div[@class=&#x27;am__work__main&#x27;]//img/@src&quot;</span>)  <span class="comment"># 返回为一列表</span></span><br><span class="line">        self.title = selector.xpath(<span class="string">&quot;//h1[@class=&#x27;am__title&#x27;]/text()&quot;</span>)</span><br><span class="line">        self.download(imgLinks)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">self, imgLinks</span>):</span></span><br><span class="line">        filepath = <span class="built_in">input</span>(<span class="string">&#x27;输入下载的目录路径(默认F:\公众号\图片):&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(filepath):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;目录输入错误&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        absfilepath = filepath + <span class="string">f&#x27;\\<span class="subst">&#123;self.title&#125;</span>&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> os.path.exists(absfilepath):</span><br><span class="line">            <span class="comment"># 清空文件夹中的文件</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;清空文件夹中的文件&#x27;</span>)</span><br><span class="line">            del_list = os.listdir(absfilepath)</span><br><span class="line">            <span class="keyword">for</span> f <span class="keyword">in</span> del_list:</span><br><span class="line">                file_path = os.path.join(absfilepath, f)</span><br><span class="line">                <span class="keyword">if</span> os.path.isfile(file_path):</span><br><span class="line">                    os.remove(file_path)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;生成文件夹&#x27;</span>)</span><br><span class="line">            os.mkdir(absfilepath)</span><br><span class="line">        self.filepathList.add(absfilepath)</span><br><span class="line">        self.__header[<span class="string">&#x27;Referer&#x27;</span>] = <span class="string">&#x27;https://www.pixiv.net/&#x27;</span></span><br><span class="line">        pbar = tqdm.tqdm(imgLinks)</span><br><span class="line">        total = <span class="built_in">len</span>(imgLinks)</span><br><span class="line">        <span class="keyword">for</span> index, link <span class="keyword">in</span> <span class="built_in">enumerate</span>(pbar):</span><br><span class="line">            filename = link.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">            pbar.set_description(<span class="string">&quot;正在下载%s,&quot;</span> % filename)</span><br><span class="line">            pbar.set_postfix(&#123;<span class="string">&#x27;current&#x27;</span>: index + <span class="number">1</span>, <span class="string">&#x27;total&#x27;</span>: total&#125;)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                res = requests.get(link, headers=self.__header)</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(absfilepath + <span class="string">f&#x27;\\<span class="subst">&#123;filename&#125;</span>&#x27;</span>, <span class="string">&#x27;wb+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(res.content)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;需要设置代理&#x27;</span>, e)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里主要利用xpath解析获取到的网页.</p><h3 id="上传素材类"><a href="#上传素材类" class="headerlink" title="上传素材类"></a>上传素材类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">upload</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ACCESS_TOKEN, FILEPATHLIST</span>):</span></span><br><span class="line">        self.url = <span class="string">f&#x27;https://api.weixin.qq.com/cgi-bin/material/add_material?access_token=<span class="subst">&#123;ACCESS_TOKEN&#125;</span>&amp;type&#x27;</span> \</span><br><span class="line">                   <span class="string">f&#x27;=image&#x27;</span></span><br><span class="line">        self.filepath = FILEPATHLIST</span><br><span class="line">        self.uploadPics()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uploadPics</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(self.filepath, <span class="built_in">str</span>):</span><br><span class="line">            self.uploadPic(self.filepath)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> f <span class="keyword">in</span> self.filepath:</span><br><span class="line">                self.uploadPic(f)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uploadPic</span>(<span class="params">self, filepath</span>):</span></span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(filepath):</span><br><span class="line">            filelist = os.listdir(filepath)</span><br><span class="line">            total = <span class="built_in">len</span>(filelist)</span><br><span class="line">            pbar = tqdm.tqdm(filelist)</span><br><span class="line">            <span class="keyword">for</span> index, f <span class="keyword">in</span> <span class="built_in">enumerate</span>(pbar):</span><br><span class="line">                file_path = os.path.join(filepath, f)</span><br><span class="line">                <span class="keyword">if</span> os.path.isfile(file_path):</span><br><span class="line">                    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">                        files = &#123;</span><br><span class="line">                            <span class="string">&#x27;media&#x27;</span>: file</span><br><span class="line">                        &#125;</span><br><span class="line">                        res = requests.post(self.url, files=files)</span><br><span class="line">                        pbar.set_description(<span class="string">&#x27;正在上传&#x27;</span> + res.json()[<span class="string">&#x27;url&#x27;</span>])</span><br><span class="line">                        pbar.set_postfix(&#123;<span class="string">&#x27;current&#x27;</span>: index + <span class="number">1</span>, <span class="string">&#x27;total&#x27;</span>: total&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;文件夹错误&#x27;</span>, filepath)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意</strong>:requests上传FormData 需要利用files</p><h3 id="主文件"><a href="#主文件" class="headerlink" title="主文件"></a>主文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> user <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> getpic <span class="keyword">import</span> Article</span><br><span class="line"><span class="keyword">from</span> uploadpic <span class="keyword">import</span> upload</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    uploadDownloadpic = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">input</span>(<span class="string">&#x27;直接上传图片?0表示直接上传,1表示下载\n&#x27;</span>) == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        article = Article()</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            article.getarticle()</span><br><span class="line">            doContinue = <span class="built_in">input</span>(<span class="string">&#x27;是否继续下载图片？1表示继续,0表示退出\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> doContinue != <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        uploadDownloadpic = <span class="built_in">input</span>(<span class="string">&#x27;是否上传刚才的图片?1表示是,0表示自己选择\n&#x27;</span>)</span><br><span class="line">    u = User()</span><br><span class="line">    <span class="keyword">if</span> uploadDownloadpic == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        upload(u.access_token, article.filepathList)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        filepath = <span class="built_in">input</span>(<span class="string">&#x27;输入需要上传的文件目录(单个):\n&#x27;</span>)</span><br><span class="line">        upload(u.access_token, filepath)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>只是连续写了一会就累了,最近有点忙,利用这个工具上传素材到微信公众号方便水文章.最后可以利用pyinstaller打包</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用Python构建控制台应用,简单一点.主目的是抓取某个网站图片然后上传到素材.&lt;br&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://www.sekyoro.top/tags/python/"/>
    
    <category term="xpath" scheme="https://www.sekyoro.top/tags/xpath/"/>
    
    <category term="request" scheme="https://www.sekyoro.top/tags/request/"/>
    
    <category term="wechat" scheme="https://www.sekyoro.top/tags/wechat/"/>
    
  </entry>
  
  <entry>
    <title>构建微信快捷发布文章工具</title>
    <link href="https://www.sekyoro.top/2023/01/04/%E6%9E%84%E5%BB%BA%E5%BE%AE%E4%BF%A1%E5%BF%AB%E6%8D%B7%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0%E5%B7%A5%E5%85%B7/"/>
    <id>https://www.sekyoro.top/2023/01/04/%E6%9E%84%E5%BB%BA%E5%BE%AE%E4%BF%A1%E5%BF%AB%E6%8D%B7%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0%E5%B7%A5%E5%85%B7/</id>
    <published>2023-01-04T09:19:07.000Z</published>
    <updated>2023-01-05T05:26:04.945Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近在使用微信公众号写文章但是每天打开网页太麻烦,而且上传图片文章也麻烦.于是打算自己写个桌面程序.主要使用vue和electron,使用vite构建工具. 长期更新<br><span id="more"></span></p><h2 id="工具的选择"><a href="#工具的选择" class="headerlink" title="工具的选择"></a>工具的选择</h2><p><a href="https://www.bilibili.com/video/BV1FP4115739?p=36&amp;vd_source=177ef88aa6608bc3652c72d71b0aa098">036-Vue3+Electron19项目-1_哔哩哔哩_bilibili</a></p><p>这个视频用了vite构建,比较新.之前我还在用webpack以及vue2. Vite与vue3比较搭.</p><h3 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h3><p><a href="https://cn.vitejs.dev/guide/#scaffolding-your-first-vite-project">开始 | Vite 官方中文文档 (vitejs.dev)</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vite@latest</span><br></pre></td></tr></table></figure><p>值得注意的是Vite 需要 <a href="https://nodejs.org/en/">Node.js</a> 版本 14.18+，16+。然而，有些模板需要依赖更高的 Node 版本才能正常运行，当你的包管理器发出警告时，请注意升级你的 Node 版本.当然我这里windows环境下主要利用nvm切换版本到新的.</p><p><img data-src="http://cdn.sekyoro.top/imgs/04/0120230104172727.png" alt="image-20230104172713111"></p><blockquote><p>注意:你可能使用低版本node创建一开始没报错,但后面会出问题.同时使用nvm注意版本问题,我这里使用了旧版本nvm报错unexpected token ‘.’.需要升级nvm<a href="https://blog.csdn.net/weixin_45696837/article/details/127830020">nvm：npm ERR! Unexpected token ‘.‘_爱天蝎的双鱼的博客-CSDN博客</a></p></blockquote><p>主要利用Vite构建</p><h3 id="electron"><a href="#electron" class="headerlink" title="electron"></a>electron</h3><p><a href="https://www.electronjs.org/zh/docs/latest/">简介 | Electron (electronjs.org)</a></p><p>Electron是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入 <a href="https://www.chromium.org/">Chromium</a> 和 <a href="https://nodejs.org/">Node.js</a> 到 二进制的 Electron 允许您保持一个 JavaScript 代码代码库并创建 在Windows上运行的跨平台应用 macOS和Linux——不需要本地开发 经验</p><p>同时注意须要electron-builder打包</p><h3 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h3><p><a href="https://cn.vuejs.org/">Vue.js - 渐进式 JavaScript 框架 | Vue.js (vuejs.org)</a></p><p>Vue (发音为 /vjuː/，类似 <strong>view</strong>) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。</p><p>vite构建时即可选择使用vue.现在已经默认3.x</p><h3 id="Element-plus"><a href="#Element-plus" class="headerlink" title="Element plus"></a>Element plus</h3><p><a href="https://element-plus.org/zh-CN/guide/design.html"><a href="https://element-plus.org/zh-CN/">一个 Vue 3 UI 框架 | Element Plus (element-plus.org)</a></a></p><p>基于 Vue 3，面向设计师和开发者的组件库</p><h3 id="其他UI-Bootstrap5"><a href="#其他UI-Bootstrap5" class="headerlink" title="其他UI Bootstrap5"></a>其他UI Bootstrap5</h3><p>也可以使用Bootstrap</p><p>npm导入后需要引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;bootstrap/dist/css/bootstrap.min.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;bootstrap/dist/js/bootstrap.min.js&#x27;</span></span><br></pre></td></tr></table></figure><p><a href="https://v5.bootcss.com/">Bootstrap v5 中文文档 · Bootstrap 是全球最受欢迎的 HTML、CSS 和 JS 前端工具库。 | Bootstrap 中文网 (bootcss.com)</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i bootstrap@5.3.0-alpha1</span><br></pre></td></tr></table></figure><h3 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h3><p><a href="https://jrsoftware.org/isinfo.php">Inno Setup (jrsoftware.org)</a></p><p>用于把生成的exe打包发布,这样就不是光溜溜的一个exe了.</p><p><a href="https://zhuanlan.zhihu.com/p/168690637">Inno Setup使用总结 - 知乎 (zhihu.com)</a></p><h3 id="热重载"><a href="#热重载" class="headerlink" title="热重载"></a>热重载</h3><p><a href="https://github.com/Kuari/Blog/issues/53">Vite+Electron快速构建一个VUE3桌面应用(二)——动态模块热重载 · Issue #53 · Kuari/Blog (github.com)</a></p><p>为了使vite和electron正常运行，需要先运行vite，使得其开发服务器的url可以正常访问，然后再开启electron去加载url。</p><p>此处需要安装两个库：</p><ul><li><p><strong>concurrently</strong>：阻塞运行多个命令，<code>-k</code>参数用来清除其它已经存在或者挂掉的进程</p></li><li><p><strong>wait-on</strong>：等待资源，此处用来等待url可访问</p></li><li><p>接着更新文件<code>package.json</code>，<code>scripts</code>新增两条命令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;electron&quot;</span>: <span class="string">&quot;wait-on tcp:5173 &amp;&amp; electron .&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;concurrently -k \&quot;yarn dev\&quot; \&quot;yarn electron\&quot;&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><p>start命令就是为了运行vue项目然后等其打开后运行electron.在开发时electron需要加载这个url.</p><p>在目录下创建main.js   加载5173端口 这个端口就是vite打开的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; app, BrowserWindow &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createWindow = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> win = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">800</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">600</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// win.loadFile(&#x27;index.html&#x27;)</span></span><br><span class="line">  win.loadURL(<span class="string">&#x27;http://localhost:5173&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.whenReady().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  createWindow()</span><br><span class="line"></span><br><span class="line">  app.on(<span class="string">&#x27;activate&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (BrowserWindow.getAllWindows().length === <span class="number">0</span>) createWindow()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">&#x27;window-all-closed&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.platform !== <span class="string">&#x27;darwin&#x27;</span>) app.quit()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最后运行npm run start</p><p><img data-src="http://cdn.sekyoro.top/imgs/04/0120230104222629.png" alt="image-20230104222628604" style="zoom:67%;" /></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://blog.csdn.net/lw001x/article/details/127589755?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~ESLANDING~default-6-127589755-blog-128000357.pc_relevant_landingrelevant&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~ESLANDING~default-6-127589755-blog-128000357.pc_relevant_landingrelevant&amp;utm_relevant_index=7">Vite+Vue+Electron环境搭建_⑥②的博客-CSDN博客_electron vite vue</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在使用微信公众号写文章但是每天打开网页太麻烦,而且上传图片文章也麻烦.于是打算自己写个桌面程序.主要使用vue和electron,使用vite构建工具. 长期更新&lt;br&gt;</summary>
    
    
    
    
    <category term="vue" scheme="https://www.sekyoro.top/tags/vue/"/>
    
    <category term="wechat" scheme="https://www.sekyoro.top/tags/wechat/"/>
    
    <category term="vite" scheme="https://www.sekyoro.top/tags/vite/"/>
    
    <category term="electron" scheme="https://www.sekyoro.top/tags/electron/"/>
    
    <category term="Bootstrap5" scheme="https://www.sekyoro.top/tags/Bootstrap5/"/>
    
  </entry>
  
  <entry>
    <title>美化github首页</title>
    <link href="https://www.sekyoro.top/2023/01/01/%E7%BE%8E%E5%8C%96github%E9%A6%96%E9%A1%B5/"/>
    <id>https://www.sekyoro.top/2023/01/01/%E7%BE%8E%E5%8C%96github%E9%A6%96%E9%A1%B5/</id>
    <published>2023-01-01T04:48:06.000Z</published>
    <updated>2023-01-01T08:58:49.532Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>新年到了,新年新气象.美化一下github首页.<br><span id="more"></span></p><p>在几年前Github推出了美化profile的功能,到现在我来体验一下.</p><p>最后成果,比较简单方便.</p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0120230101163704.png" alt="image-20230101163704294" style="zoom:50%;" /></p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0120230101163735.png" alt="image-20230101163735498" style="zoom:50%;" /></p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0120230101163806.png" alt="image-20230101163806235" style="zoom:50%;" /></p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>主要流程比较简单,创建一个仓库,仓库的命名需要与自己Github用户名一致.</p><p>这里因为我创建过了所以提示重命名.然后这个仓库需要一个readme.md文件,就是用这个markdown文件来美化主页.重要的是其中显示个人数据的接口.</p><p>这里推荐两个模板生成器,可以看参考资料的前两个.</p><h3 id="github-stats"><a href="#github-stats" class="headerlink" title="github stats"></a>github stats</h3><p>接下来是github stats<a href="https://github.com/anuraghazra/github-readme-stats/blob/master/docs/readme_cn.md">github-readme-stats/readme_cn.md at master · anuraghazra/github-readme-stats</a></p><p><img data-src="https://camo.githubusercontent.com/8fd2570f103d1aae8a4d8970535274ae19c2ee62587d8868d618be37001263d0/68747470733a2f2f7265732e636c6f7564696e6172792e636f6d2f616e7572616768617a72612f696d6167652f75706c6f61642f76313539353137343533362f6772732d7468656d65735f6c34796e6a612e706e67" alt="GitHub Readme Stat Themes" style="zoom: 33%;" /></p><blockquote><p>你可以通过使用 URL 参数的方式，为你的 <code>Stats Card</code> 或 <code>Repo Card</code> 自定义样式。</p><p>常用选项：</p><ul><li><code>title_color</code> - 卡片标题颜色 <em>（十六进制色码）</em></li><li><code>text_color</code> - 内容文本颜色 <em>（十六进制色码）</em></li><li><code>icon_color</code> - 图标颜色（如果可用）<em>（十六进制色码）</em></li><li><code>bg_color</code> - 卡片背景颜色 <em>（十六进制色码）</em> <strong>或者</strong> 以 <em>angle,start,end</em> 的形式渐变</li><li><code>hide_border</code> - 隐藏卡的边框 <em>(布尔值)</em></li><li><code>theme</code> - 主题名称，从<a href="https://github.com/anuraghazra/github-readme-stats/blob/master/themes/README.md">所有可用主题</a>中选择</li><li><code>cache_seconds</code> - 手动设置缓存头 <em>（最小值: 1800，最大值: 86400）</em></li><li><code>locale</code> - 在卡片中设置语言 <em>(例如 cn, de, es, 等等)</em></li></ul></blockquote><p>同时也有个人常用语言统计</p><p>将此代码复制粘贴到您的 <code>README.md</code> 文件中，并修改链接。</p><p>端点: <code>api/top-langs?username=anuraghazra</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![Top Langs</span>](<span class="link">https://github-readme-stats.vercel.app/api/top-langs/?username=anuraghazra</span>)](<span class="link">https://github.com/anuraghazra/github-readme-stats</span>)</span><br></pre></td></tr></table></figure><h3 id="github-stats-1"><a href="#github-stats-1" class="headerlink" title="github stats"></a>github stats</h3><p>然后是个人信息统计,可以利用<a href="https://metrics.lecoq.io/">Metrics (lecoq.io)</a>,只需要输入Github用户名生成个人metrics.</p><p><img data-src="https://camo.githubusercontent.com/b9deb4987189bc5222f2b2fad0c0b461a171abfcaa31ac38006df8db466e4d2f/68747470733a2f2f6d6574726963732e6c65636f712e696f2f64726f776e696e672d696e2d636f6465733f74656d706c6174653d636c617373696326626173653d6865616465722532432532306163746976697479253243253230636f6d6d756e6974792532432532307265706f7369746f726965732532432532306d6574616461746126626173652e696e64657074683d66616c736526626173652e6869726561626c653d66616c736526626173652e736b69703d66616c736526636f6e6669672e74696d657a6f6e653d417369612532465368616e67686169" alt="img" style="zoom:50%;" /></p><h3 id="github-activity-graph"><a href="#github-activity-graph" class="headerlink" title="github activity graph"></a>github activity graph</h3><p>github活动图 也就是显示提交记录的.<a href="https://github.com/Ashutosh00710/github-readme-activity-graph/">Ashutosh00710/github-readme-activity-graph: A dynamically generated activity graph to show your GitHub activities of last 31 days.</a></p><p><img data-src="https://github.com/Ashutosh00710/github-readme-activity-graph/raw/main/asset/default.svg" alt="graph" style="zoom: 33%;" /></p><p>类似的将下面markdown中username改为自己github用户名.    </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![Ashutosh&#x27;s github activity graph</span>](<span class="link">https://github-readme-activity-graph.cyclic.app/graph?username=Ashutosh00710&amp;theme=dracula</span>)](<span class="link">https://github.com/ashutosh00710/github-readme-activity-graph</span>)</span><br></pre></td></tr></table></figure><h3 id="github-streak"><a href="#github-streak" class="headerlink" title="github streak"></a>github streak</h3><p>显示个人github成就</p><p><a href="https://github.com/DenverCoder1/github-readme-streak-stats">DenverCoder1/github-readme-streak-stats: 🔥 Stay motivated and show off your contribution streak! 🌟 Display your total contributions, current streak, and longest streak on your GitHub profile README</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![GitHub Streak</span>](<span class="link">https://streak-stats.demolab.com/?user=DenverCoder1</span>)](<span class="link">https://git.io/streak-stats</span>)</span><br></pre></td></tr></table></figure><h3 id="Shields（GitHub-徽章）"><a href="#Shields（GitHub-徽章）" class="headerlink" title="Shields（GitHub 徽章）"></a>Shields（GitHub 徽章）</h3><p><img data-src="http://cdn.sekyoro.top/imgs/01/0120230101165219.png" alt="image-20230101165219583" style="zoom:50%;" /></p><p>主要使用<a href="https://shields.io/这个网站生成图标比较简单,可以在外面包裹一个超链接用于跳转">https://shields.io/这个网站生成图标比较简单,可以在外面包裹一个超链接用于跳转</a>.</p><h3 id="Visitor-Badge（GitHub-访客徽章）"><a href="#Visitor-Badge（GitHub-访客徽章）" class="headerlink" title="Visitor Badge（GitHub 访客徽章）"></a>Visitor Badge（GitHub 访客徽章）</h3><p><img data-src="http://cdn.sekyoro.top/imgs/01/01image-20230101165431536.png" alt="image-20230101165431536" style="zoom: 67%;" /></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">visitors</span>](<span class="link">https://visitor-badge.glitch.me/badge?page_id=page.id&amp;left_color=green&amp;right_color=red</span>)</span><br></pre></td></tr></table></figure><p>将page_id替换为用户名即可.</p><p>最后可以看一下我的Github主页<a href="https://github.com/drowning-in-codes">drowning-in-codes (martyr) (github.com)</a>参观,模板生成的也比较简便.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://profilinator.rishav.dev/">Github Profilinator - GitHub Profile README Generator (rishav.dev)</a> 快捷的模板生成器</li><li><a href="https://rahuldkjain.github.io/gh-profile-readme-generator/">GitHub Profile Readme Generator | GitHub Profile Readme Generator (rahuldkjain.github.io)</a> 另一个快捷的模板生成器</li><li><a href="https://zhuanlan.zhihu.com/p/454597068">Github 首页美化教程（一）：打造个性化的GitHub首页</a> 其他教程</li><li><a href="https://sumygg.com/2021/04/25/beautify-your-github-profile-readme/">美化你的Github个人信息页 | SumyBlog (sumygg.com)</a></li><li><a href="https://shields.io/">Shields.io: Quality metadata badges for open source projects</a> 图标</li><li><a href="https://github.com/abhisheknaiidu/awesome-github-profile-readme">abhisheknaiidu/awesome-github-profile-readme: 😎 A curated list of awesome GitHub Profile READMEs 📝</a> 优美的github profile案例</li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;新年到了,新年新气象.美化一下github首页.&lt;br&gt;</summary>
    
    
    
    
    <category term="github" scheme="https://www.sekyoro.top/tags/github/"/>
    
    <category term="github profile" scheme="https://www.sekyoro.top/tags/github-profile/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sekyoro的博客小屋</title>
  
  
  <link href="https://www.sekyoro.top/atom.xml" rel="self"/>
  
  <link href="https://www.sekyoro.top/"/>
  <updated>2023-03-22T09:13:30.886Z</updated>
  <id>https://www.sekyoro.top/</id>
  
  <author>
    <name>Sekyoro</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vscode+latex本地搭建tex写论文</title>
    <link href="https://www.sekyoro.top/2023/03/22/vscode-latex%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAtex%E5%86%99%E8%AE%BA%E6%96%87/"/>
    <id>https://www.sekyoro.top/2023/03/22/vscode-latex%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAtex%E5%86%99%E8%AE%BA%E6%96%87/</id>
    <published>2023-03-22T08:14:39.000Z</published>
    <updated>2023-03-22T09:13:30.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>如果是为了方便简洁,实际使用<a href="https://www.overleaf.com/">Overleaf</a>完全够了,之前也写过使用Obsidian写文章的教程. 这次主要介绍使用在本地vscode加上插件写论文.<br><span id="more"></span></p><h2 id="需要工具"><a href="#需要工具" class="headerlink" title="需要工具"></a>需要工具</h2><ol><li><strong>vscode</strong> 官网即可</li><li><strong>texlive</strong> 通过镜像站即可,比如<a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/">Index of /CTAN/systems/texlive/Images/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></li></ol><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322162307.png" alt="image-20230322162300639" style="zoom:67%;" /></p><p>选中箭头指向的其中一个即可,然后一步一步来即可.可以参考相关教程<a href="https://zhuanlan.zhihu.com/p/493412905">TeX Live 2022 安装指南【安装 LaTeX】</a>. 安装TexLive目的就是为了有个解析引擎,类似与c++程序下载g++一样</p><ol><li><a href="https://www.sumatrapdfreader.org/free-pdf-reader">Sumatra PDF (sumatrapdfreader.org)</a>  用于查看pdf,当然用其他的也可以.这是一个开源免费的pdf阅读器,用于查看tex编译后得到的pdf,并且设置反向搜索(即双击pdf的某个位置可以跳转到tex代码相应的位置)</li></ol><h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><p><strong>下载texlive之后</strong>,进行测试是否安装成功. 在命令行输入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tex</span><br></pre></td></tr></table></figure><p>显示</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322163046.png" alt="image-20230322163046678"></p><p>表示安装成功.</p><p><strong>在vscode中</strong>下载插件Latex Workshop,用于有效地编译预览tex文件.</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322162850.png" alt="image-20230322162849810" style="zoom:50%;" /></p><p>当然你也可以同时下载其他用于自动补全tex的插件.然后进行配置.</p><p>如果你还不了解tex相关的一类东西,可以在文章末尾<strong>参考资料</strong>中查看Tex家族.</p><h4 id="简单实用"><a href="#简单实用" class="headerlink" title="简单实用"></a>简单实用</h4><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322163519.png" alt="image-20230322163519674"></p><p>下载了插件后,你会注意到左部有这个插件标识,点击即可. 发现上面有相关命令.有编译,查看pdf,导向等等. 我们常用的就是构建,值得注意的是我们构建就是利用工具设置工具链进行一套编译流程.</p><p>现在你就可以写tex然后点击 <code>pdflatex-&gt;bibtex-&gt;pdflatex*2</code>即可得到pdf</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322163846.png" alt="image-20230322163846157"></p><p>但是你会发现使用中文会报错,所以接下来我们会进行相关配置.</p><blockquote><ul><li>TeX：1978年由Donald Erwin Knuth（高德纳）开发。是后来大部分TeX相关的基础。其生成dvi文件，然后经由其他程序转换为pdf文件。</li><li>pdfTeX：Tex语言的又一个实现，将TeX代码直接编译成PDF文件。</li><li>XeTeX：TeX 语言的新的实现，支持 Unicode 编码和直接访问操作系统字体。</li><li>LuaTeX：TeX 语言的一个完整的有扩展的实现。LuaTeX支持Unicode、系统字体和内嵌语言扩展，能直接输出PDF格式文件，也可以仍然输出 DVI 格式。</li></ul></blockquote><p>我们需要增加xelatex工具.首先在设置中搜索<code>tools</code></p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322164243.png" alt="image-20230322164243143" style="zoom:50%;" /></p><p>点击setting.json配置，增加xelatex,代码如下.即数组中的第一项.</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322164343.png" alt="image-20230322164343493" style="zoom:67%;" /></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;-synctex=1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-interaction=nonstopmode&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-file-line-error&quot;</span>,</span><br><span class="line">        <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上相当于增加了一个tool.</p><p>现在需要增加一个recipe,相当于一套流程,这个流程需要用到xelatex.</p><p>设置中搜索recipe</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322164525.png" alt="image-20230322164525817"></p><p>点击setting.json,增加红框的代码</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322164546.png" alt="image-20230322164546431" style="zoom:50%;" /></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tools&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">    ],</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xelatex ➞ bibtex ➞ xelatex × 2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tools&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;bibtex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在你可以看见增加的recipe了,如红箭头所示. 现在支持tex中有中文了.</p><p>注意需要使用ctex包</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125;</span><br></pre></td></tr></table></figure><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322164634.png" alt="image-20230322164634064"></p><h3 id="实现正反向搜索"><a href="#实现正反向搜索" class="headerlink" title="实现正反向搜索"></a>实现正反向搜索</h3><p>这里使用sumatra作为external的pdf阅读器并实现双向搜索.</p><p>设置中搜索viewer.</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322165018.png" alt="image-20230322165018028" style="zoom: 67%;" /></p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322165037.png" alt="image-20230322165036922" style="zoom:67%;" /></p><p>设置external同时设置sumatra安装路径.</p><h4 id="正向搜索"><a href="#正向搜索" class="headerlink" title="正向搜索"></a>正向搜索</h4><p>在设置中搜索 viewer,看到下图参数设置.</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322165147.png" alt="image-20230322165147100" style="zoom:67%;" /></p><p>注意,这里可以先尝试随便添加项,然后在setting.json中查找这个配置.</p><p>将这个参数修改如下,注意其中的逆向搜索路径(这里是<code>&quot;D:/Microsoft VS Code/Code.exe\&quot; \&quot;D:/Microsoft VS Code/resources/app/out/cli.js\&quot; -r -g \&quot;%f:%l\&quot;</code>)表示vscode相关下载位置,注意使用自己安装vscode的相关位置.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;latex-workshop.view.pdf.external.viewer.args&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;-forward-search&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%TEX%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%LINE%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-reuse-instance&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-inverse-search&quot;</span>,</span><br><span class="line">    <span class="string">&quot;\&quot;D:/Microsoft VS Code/Code.exe\&quot; \&quot;D:/Microsoft VS Code/resources/app/out/cli.js\&quot; -r -g \&quot;%f:%l\&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%PDF%&quot;</span>,</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><p>然后就配置成功了(事实上并没有完全成功,具体可以看下面的<a href="#attention">注意</a>).</p><p>正向搜索方法:平时选择其中之一即可</p><ol><li><p><img data-src="http://cdn.sekyoro.top/imgs/22/03image-20230322165523694.png" alt="image-20230322165523694"></p></li><li><p>按下<code>Ctrl+Alt+J</code>，直接跳转至PDF对应的地方。</p></li><li><p>点击<strong>View LaTeX PDF -&gt; View in external viewer</strong>。</p></li></ol><h4 id="逆向搜索"><a href="#逆向搜索" class="headerlink" title="逆向搜索"></a>逆向搜索</h4><p>设置中搜索Synctex,配置参数和命令. 跟上面的其实类似. </p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322165700.png" alt="image-20230322165659967" style="zoom:80%;" /></p><p><code>latex-workshop.view.pdf.external.synctex.args</code>参数配置如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;-forward-search&quot;</span>,</span><br><span class="line">   <span class="string">&quot;%TEX%&quot;</span>,</span><br><span class="line">   <span class="string">&quot;%LINE%&quot;</span>,</span><br><span class="line">   <span class="string">&quot;-reuse-instance&quot;</span>,</span><br><span class="line">   <span class="string">&quot;-inverse-search&quot;</span>,</span><br><span class="line">   <span class="string">&quot;\&quot;D:/Microsoft VS Code/Code.exe\&quot; \&quot;D:/Microsoft VS Code/resources/app/out/cli.js\&quot; -r -g \&quot;%f:%l\&quot;&quot;</span>,</span><br><span class="line">   <span class="string">&quot;%PDF%&quot;</span>,</span><br></pre></td></tr></table></figure><p>上面的路径也是根据你下载vscode的路径配置.</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><a id="attention">注意</a></h3><p>事实上要实现在sumatra中反向搜索,你还需要进行其他配置. 打开sumatra,点击左上角选择<strong>高级选项</strong>.</p><p><img data-src="http://cdn.sekyoro.top/imgs/22/0320230322170018.png" alt="image-20230322170018604" style="zoom:67%;" /></p><p>搜索<code>InverseSearchCmdLine</code> 可以发现这里的值应该已经被设置了.后面发现,按照上述设置在vscode中打开sumatra后会将这里的参数设置会vscode中配置的,但是现在需要更改一下.</p><p>在vscode配置中,逆向搜索增加<code>--ms-enable-electron-run-as-node</code>参数.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;latex-workshop.view.pdf.external.viewer.args&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;-forward-search&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%TEX%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%LINE%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-reuse-instance&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-inverse-search&quot;</span>,</span><br><span class="line">    <span class="string">&quot;\&quot;D:/Microsoft VS Code/Code.exe\&quot; \&quot;D:/Microsoft VS Code/resources/app/out/cli.js\&quot; --ms-enable-electron-run-as-node -r -g \&quot;%f:%l\&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%PDF%&quot;</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;latex-workshop.view.pdf.external.synctex.command&quot;</span>: <span class="string">&quot;D:\\SumatraPDF\\SumatraPDF.exe&quot;</span>,</span><br><span class="line">  <span class="string">&quot;latex-workshop.view.pdf.external.synctex.args&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;-forward-search&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%TEX%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%LINE%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-reuse-instance&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-inverse-search&quot;</span>,</span><br><span class="line">    <span class="string">&quot;\&quot;D:/Microsoft VS Code/Code.exe\&quot; \&quot;D:/Microsoft VS Code/resources/app/out/cli.js\&quot; --ms-enable-electron-run-as-node -r -g \&quot;%f:%l\&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%PDF%&quot;</span>,</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><p>这样双击sumatra中的pdf即可跳转到vscode中的tex相应位置了.</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/273343930">在vscode中使用latex高效书写论文教程 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/144729565">学术论文写作利器—— VS Code + LaTeX - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/71432461">VS Code下配置LaTeX编译环境 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/434142338">VScode+Latex+SumatraPDF反向搜索失败解决办法（Version 1.63） - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/248669482">TeX 家族（TeX, XeTeX, LuaTeX,XeLaTeX …看完这篇就懂了） - 知乎 (zhihu.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果是为了方便简洁,实际使用&lt;a href=&quot;https://www.overleaf.com/&quot;&gt;Overleaf&lt;/a&gt;完全够了,之前也写过使用Obsidian写文章的教程. 这次主要介绍使用在本地vscode加上插件写论文.&lt;br&gt;</summary>
    
    
    
    <category term="latex" scheme="https://www.sekyoro.top/categories/latex/"/>
    
    
    <category term="latex" scheme="https://www.sekyoro.top/tags/latex/"/>
    
    <category term="vscode" scheme="https://www.sekyoro.top/tags/vscode/"/>
    
    <category term="sumatra" scheme="https://www.sekyoro.top/tags/sumatra/"/>
    
  </entry>
  
  <entry>
    <title>STL学习</title>
    <link href="https://www.sekyoro.top/2023/03/05/STL%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2023/03/05/STL%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-03-05T15:56:00.000Z</published>
    <updated>2023-03-05T15:57:32.116Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>刷算法时有必要使用一些stl.<br><span id="more"></span></p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h3><h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><p>初始化 通过如下创建 array 容器的方式，可以将所有的元素初始化为 0 或者和默认元素类型等效的值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="keyword">double</span>, 10&gt; values &#123;&#125;;</span><br></pre></td></tr></table></figure><p>array 容器是 <a href="http://c.biancheng.net/cplus/">C++</a> 11 标准中新增的序列容器，简单地理解，它就是在 C++ 普通数组的基础上，添加了一些成员函数和全局函数。在使用上，它比普通数组更安全，且效率并没有因此变差。</p><div class="table-container"><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的随机访问迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的随机访问迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素之前一个位置的随机访问迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>size()</td><td>返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。</td></tr><tr><td>max_size()</td><td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。</td></tr><tr><td>empty()</td><td>判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快。</td></tr><tr><td>at(n)</td><td>返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。</td></tr><tr><td>front()</td><td>返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。</td></tr><tr><td>back()</td><td>返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。</td></tr><tr><td>data()</td><td>返回一个指向容器首个元素的<a href="http://c.biancheng.net/c/80/">指针</a>。利用该指针，可实现复制容器中所有元素等类似功能。</td></tr><tr><td>fill(val)</td><td>将 val 这个值赋值给容器中的每个元素。</td></tr><tr><td>array1.swap(array2)</td><td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</td></tr></tbody></table></div><p>对于array相比一般的c数组,可以直接利用front,back获取前后引用,size函数获取个数,以及一般的容器迭代器等</p><p>同时还有at函数更加安全的获取array中的元素,但由于不能更改长度,实践中用的并不多</p><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><div class="table-container"><table><thead><tr><th>begin()</th><th>返回指向容器中第一个元素的迭代器。</th></tr></thead><tbody><tr><td>end()</td><td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>size()</td><td>返回实际元素个数。</td></tr><tr><td>max_size()</td><td>返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td></tr><tr><td>resize()</td><td>改变实际元素的个数。</td></tr><tr><td>capacity()</td><td>返回当前容量。</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td></tr><tr><td>reserve()</td><td>增加容器的容量。</td></tr><tr><td>shrink _to_fit()</td><td>将内存减少到等于当前元素实际所使用的大小。</td></tr><tr><td>operator[ ]</td><td>重载了 [ ] 运算符，可以向访问数组中元素那样，通过下标即可访问甚至修改 vector 容器中的元素。</td></tr><tr><td>at()</td><td>使用经过边界检查的索引访问元素。</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td></tr><tr><td>back()</td><td>返回最后一个元素的引用。</td></tr><tr><td>data()</td><td>返回指向容器中第一个元素的指针。</td></tr><tr><td>assign()</td><td>用新元素替换原有内容。</td></tr><tr><td>push_back()</td><td>在序列的尾部添加一个元素。</td></tr><tr><td>pop_back()</td><td>移出序列尾部的元素。</td></tr><tr><td>insert()</td><td>在指定的位置插入一个或多个元素。</td></tr><tr><td>erase()</td><td>移出一个元素或一段元素。</td></tr><tr><td>clear()</td><td>移出所有的元素，容器大小变为 0。</td></tr><tr><td>swap()</td><td>交换两个容器的所有元素。</td></tr><tr><td>emplace()</td><td>在指定的位置直接生成一个元素。</td></tr><tr><td>emplace_back()</td><td>在序列尾部生成一个元素。</td></tr></tbody></table></div><p>可以更改大小,在内存上是连续分布的.所以可以随机访问,跟一般的数组和array类似.  可以使用reserve函数调整大小,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values.<span class="built_in">reserve</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>这样就设置了容器的内存分配，即至少可以容纳 20 个元素。注意，如果 vector 的容量在执行此语句之前，已经大于或等于 20 个元素，那么这条语句什么也不做；另外，调用 reserve() 不会影响已存储的元素，也不会生成任何元素，即 values 容器内此时仍然没有任何元素.</p><p>同时使用emplace,emplace_back,erase等来增加或删除元素.</p><blockquote><p>emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p></blockquote><p>插入元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; demo&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">//第一种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">3</span>);<span class="comment">//&#123;1,3,2&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>);<span class="comment">//&#123;1,3,2,5,5&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种格式用法</span></span><br><span class="line">    std::array&lt;<span class="keyword">int</span>,3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>());<span class="comment">//&#123;1,3,2,5,5,7,8,9&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;);<span class="comment">//&#123;1,3,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; demo[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除元素</p><div class="table-container"><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>pop_back()</td><td>删除 vector 容器中最后一个元素，该容器的大小（size）会减 1，但容量（capacity）不会发生改变。</td></tr><tr><td>erase(pos)</td><td>删除 vector 容器中 pos 迭代器指定位置处的元素，并返回指向被删除元素下一个位置元素的迭代器。该容器的大小（size）会减 1，但容量（capacity）不会发生改变。</td></tr><tr><td>swap(beg)、pop_back()</td><td>先调用 swap() 函数交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back() 删除该目标元素。</td></tr><tr><td>erase(beg,end)</td><td>删除 vector 容器中位于迭代器 [beg,end)指定区域内的所有元素，并返回指向被删除区域下一个位置元素的迭代器。该容器的大小（size）会减小，但容量（capacity）不会发生改变。</td></tr><tr><td>remove()</td><td>删除容器中所有和指定元素值相等的元素，并返回指向最后一个元素下一个位置的迭代器。值得一提的是，调用该函数不会改变容器的大小和容量。</td></tr><tr><td>clear()</td><td>删除 vector 容器中所有的元素，使其变成空的 vector 容器。该函数会改变 vector 的大小（变为 0），但不是改变其容量。</td></tr></tbody></table></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">//删除 2、3</span></span><br><span class="line">    <span class="keyword">auto</span> iter = demo.<span class="built_in">erase</span>(demo.<span class="built_in">begin</span>()+<span class="number">1</span>, demo.<span class="built_in">end</span>() - <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size is :&quot;</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity is :&quot;</span> &lt;&lt; demo.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; demo[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用emplace,emplace_back,pop_back,erase对vector进行增删数据,使用at访问数据</p><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>deque 容器和 vecotr 容器有很多相似之处，比如：</p><ul><li>deque 容器也擅长在序列尾部添加或删除元素（时间复杂度为<code>O(1)</code>），而不擅长在序列中间添加或删除元素。</li><li>deque 容器也可以根据需要修改自身的容量和大小</li></ul><p>和 vector 不同的是，deque 还擅长在序列头部添加或删除元素，所耗费的时间复杂度也为常数阶<code>O(1)</code>。并且更重要的一点是，deque 容器中存储元素并不能保证所有元素都存储到连续的内存空间中。</p><blockquote><p>当需要向序列两端频繁的添加或删除元素时，应首选 deque 容器。</p></blockquote><p>和 vector 相比，额外增加了实现在容器头部添加和删除元素的成员函数比如emplace_front,pop_font，同时删除了 capacity()、reserve() 和 data() 成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化一个空deque容量</span></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt;d;</span><br><span class="line">    <span class="comment">//向d容器中的尾部依次添加 1，2,3</span></span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">2</span>); <span class="comment">//&#123;1,2&#125;</span></span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">3</span>); <span class="comment">//&#123;1,2,3&#125;</span></span><br><span class="line">    <span class="comment">//向d容器的头部添加 0 </span></span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">0</span>); <span class="comment">//&#123;0,1,2,3&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用 size() 成员函数输出该容器存储的字符个数。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素个数为：%d\n&quot;</span>, d.<span class="built_in">size</span>());</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//使用迭代器遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = d.<span class="built_in">begin</span>(); i &lt; d.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p><a href="http://c.biancheng.net/stl/">STL</a> list 容器，又称双向链表容器，即该容器的底层是以双向链表的形式实现的。这意味着，list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。</p><p>list 容器具有一些其它容器（array、vector 和 deque）所不具备的优势，即它可以在序列已知的任何位置快速插入或删除元素（时间复杂度为<code>O(1)</code>）。并且在 list 容器中移动元素，也比其它容器的效率高。</p><p>和之前的序列容器相比，list 容器迭代器最大的不同在于，其配备的迭代器类型为双向迭代器，而不再是随机访问迭代器。</p><div class="table-container"><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的双向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器中最后一个元素所在位置的下一个位置的双向迭代器。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的反向双向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的反向双向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td></tr><tr><td>size()</td><td>返回当前容器实际包含的元素个数。</td></tr><tr><td>max_size()</td><td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td></tr><tr><td>back()</td><td>返回最后一个元素的引用。</td></tr><tr><td>assign()</td><td>用新元素替换容器中原有内容。</td></tr><tr><td>emplace_front()</td><td>在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。</td></tr><tr><td>push_front()</td><td>在容器头部插入一个元素。</td></tr><tr><td>pop_front()</td><td>删除容器头部的一个元素。</td></tr><tr><td>emplace_back()</td><td>在容器尾部直接生成一个元素。该函数和 push_back() 的功能相同，但效率更高。</td></tr><tr><td>push_back()</td><td>在容器尾部插入一个元素。</td></tr><tr><td>pop_back()</td><td>删除容器尾部的一个元素。</td></tr><tr><td>emplace()</td><td>在容器中的指定位置插入元素。该函数和 insert() 功能相同，但效率更高。</td></tr><tr><td>insert()</td><td>在容器中的指定位置插入元素。</td></tr><tr><td>erase()</td><td>删除容器中一个或某区域内的元素。</td></tr><tr><td>swap()</td><td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。</td></tr><tr><td>resize()</td><td>调整容器的大小。</td></tr><tr><td>clear()</td><td>删除容器存储的所有元素。</td></tr><tr><td>splice()</td><td>将一个 list 容器中的元素插入到另一个容器的指定位置。</td></tr><tr><td>remove(val)</td><td>删除容器中所有等于 val 的元素。</td></tr><tr><td>remove_if()</td><td>删除容器中满足条件的元素。</td></tr><tr><td>unique()</td><td>删除容器中相邻的重复元素，只保留一个。</td></tr><tr><td>merge()</td><td>合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的。</td></tr><tr><td>sort()</td><td>通过更改容器中元素的位置，将它们进行排序。</td></tr><tr><td>reverse()</td><td>反转容器中元素的顺序。</td></tr></tbody></table></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空的 list 容器</span></span><br><span class="line">    std::list&lt;<span class="keyword">double</span>&gt; values;</span><br><span class="line">    <span class="comment">//向容器中添加元素</span></span><br><span class="line">    values.<span class="built_in">push_back</span>(<span class="number">3.1</span>);</span><br><span class="line">    values.<span class="built_in">push_back</span>(<span class="number">2.2</span>);</span><br><span class="line">    values.<span class="built_in">push_back</span>(<span class="number">2.9</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;values size：&quot;</span> &lt;&lt; values.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//对容器中的元素进行排序</span></span><br><span class="line">    values.<span class="built_in">sort</span>();</span><br><span class="line">    <span class="comment">//使用迭代器输出list容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (std::list&lt;<span class="keyword">double</span>&gt;::iterator it = values.<span class="built_in">begin</span>(); it != values.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::list&lt;<span class="keyword">int</span>&gt; values&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="comment">//第一种格式用法</span></span><br><span class="line">    values.<span class="built_in">insert</span>(values.<span class="built_in">begin</span>() , <span class="number">3</span>);<span class="comment">//&#123;3,1,2&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种格式用法</span></span><br><span class="line">    values.<span class="built_in">insert</span>(values.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>);<span class="comment">//&#123;3,1,2,5,5&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种格式用法</span></span><br><span class="line">    std::array&lt;<span class="keyword">int</span>, 3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    values.<span class="built_in">insert</span>(values.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>());<span class="comment">//&#123;3,1,2,5,5,7,8,9&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四种格式用法</span></span><br><span class="line">    values.<span class="built_in">insert</span>(values.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;);<span class="comment">//&#123;3,1,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = values.<span class="built_in">begin</span>(); p != values.<span class="built_in">end</span>(); ++p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h3><p>关联式容器在存储元素值的同时，会为各元素额外再配备一个值（又称为“键”，其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联式容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。</p><blockquote><p>弃用序列式容器，转而选用关联式容器存储元素，往往就是看中了关联式容器可以快速查找、读取或者删除所存储的元素，同时该类型容器插入元素的效率也比序列式容器高。</p></blockquote><p>也就是说，使用关联式容器存储的元素，都是一个一个的“键值对”（ <key,value> ），这是和序列式容器最大的不同。除此之外，序列式容器中存储的元素默认都是未经过排序的，而使用关联式容器存储的元素，默认会根据各元素的键值的大小做升序排序</p><div class="table-container"><table><thead><tr><th>关联式容器名称</th><th>特点</th></tr></thead><tbody><tr><td>map</td><td>定义在 <map> 头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根据各元素键的大小，默认进行升序排序（调用 std::less<T>）。</td></tr><tr><td>set</td><td>定义在 <set> 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个元素的键（其实也就是元素值）的大小进行升序排序（调用 std::less<T>）。</td></tr><tr><td>multimap</td><td>定义在 <map> 头文件中，和 map 容器唯一的不同在于，multimap 容器中存储元素的键可以重复。</td></tr><tr><td>multiset</td><td>定义在 <set> 头文件中，和 set 容器唯一的不同在于，multiset 容器中存储元素的值可以重复（一旦值重复，则意味着键也是重复的）。</td></tr></tbody></table></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span> <span class="comment">//使用 map 容器，必须引入该头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空的 map 关联式容器，该容器中存储的键值对，其中键为 string 字符串，值也为 string 字符串类型</span></span><br><span class="line">    map&lt;string, string&gt; mymap;</span><br><span class="line">    <span class="comment">//向 mymap 容器中添加数据</span></span><br><span class="line">    mymap[<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>] = <span class="string">&quot;C语言教程&quot;</span>;</span><br><span class="line">    mymap[<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>] = <span class="string">&quot;Python教程&quot;</span>;</span><br><span class="line">    mymap[<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>] = <span class="string">&quot;Java教程&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用 map 容器的迭代器，遍历 mymap 容器，并输出其中存储的各个键值对</span></span><br><span class="line">    <span class="keyword">for</span> (map&lt;string, string&gt;::iterator it = mymap.<span class="built_in">begin</span>(); it != mymap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="comment">//输出各个元素中的键和值</span></span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到“键值对”并不是普通类型数据，<a href="http://c.biancheng.net/cplus/">C++</a> <a href="http://c.biancheng.net/stl/">STL</a> 标准库提供了 pair 类模板，其专门用来将 2 个普通元素 first 和 second（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素<code>&lt;first, second&gt;</code>。通过其构成的元素格式不难看出，使用 pair 类模板来创建“键值对”形式的元素</p><p>pair 类模板定义在<code>&lt;utility&gt;</code>头文件中，所以在使用该类模板之前，需引入此头文件。另外值得一提的是，在 C++ 11 标准之前，pair 类模板中提供了以下 3 种构造函数：</p><h1 id="1-默认构造函数，即创建空的-pair-对象pair"><a href="#1-默认构造函数，即创建空的-pair-对象pair" class="headerlink" title="1) 默认构造函数，即创建空的 pair 对象pair();"></a>1) 默认构造函数，即创建空的 pair 对象pair();</h1><h1 id="2-直接使用-2-个元素初始化成-pair-对象pair-const-first-type-amp-a-const-second-type-amp-b"><a href="#2-直接使用-2-个元素初始化成-pair-对象pair-const-first-type-amp-a-const-second-type-amp-b" class="headerlink" title="2) 直接使用 2 个元素初始化成 pair 对象pair (const first_type&amp; a, const second_type&amp; b);"></a>2) 直接使用 2 个元素初始化成 pair 对象pair (const first_type&amp; a, const second_type&amp; b);</h1><h1 id="3-拷贝（复制）构造函数，即借助另一个-pair-对象，创建新的-pair-对象template-pair-const-pair-amp-pr"><a href="#3-拷贝（复制）构造函数，即借助另一个-pair-对象，创建新的-pair-对象template-pair-const-pair-amp-pr" class="headerlink" title="3) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象template pair (const pair&amp; pr);"></a>3) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象template<class U, class V> pair (const pair<U,V>&amp; pr);</h1><p>在 C++ 11 标准中，在引入<a href="http://c.biancheng.net/view/439.html">右值引用</a>的基础上，pair 类模板中又增添了如下 2 个构造函数：</p><h1 id="4-移动构造函数template-pair-pair-amp-amp-pr-5-使用右值引用参数，创建-pair-对象template-pair-U-amp-amp-a-V-amp-amp-b"><a href="#4-移动构造函数template-pair-pair-amp-amp-pr-5-使用右值引用参数，创建-pair-对象template-pair-U-amp-amp-a-V-amp-amp-b" class="headerlink" title="4) 移动构造函数template pair (pair&amp;&amp; pr);#5) 使用右值引用参数，创建 pair 对象template pair (U&amp;&amp; a, V&amp;&amp; b);"></a>4) 移动构造函数template<class U, class V> pair (pair<U,V>&amp;&amp; pr);#5) 使用右值引用参数，创建 pair 对象template<class U, class V> pair (U&amp;&amp; a, V&amp;&amp; b);</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span>      <span class="comment">// pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用构造函数 1，也就是默认构造函数</span></span><br><span class="line">    pair &lt;string, <span class="keyword">double</span>&gt; pair1;</span><br><span class="line">    <span class="comment">// 调用第 2 种构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair2</span>(<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);  </span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair3</span>(pair2);</span><br><span class="line">    <span class="comment">//调用移动构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair4</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;C++教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/cplus/&quot;</span>));</span><br><span class="line">    <span class="comment">// 调用第 5 种构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair5</span>(<span class="built_in">string</span>(<span class="string">&quot;Python教程&quot;</span>), <span class="built_in">string</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>));  </span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair1: &quot;</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair1.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair2: &quot;</span>&lt;&lt; pair2.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair2.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair3: &quot;</span> &lt;&lt; pair3.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair3.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair4: &quot;</span> &lt;&lt; pair4.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair4.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair5: &quot;</span> &lt;&lt; pair5.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair5.second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,<span class="keyword">int</span>&gt;myMap;</span><br><span class="line">   map&lt;string,<span class="keyword">int</span>&gt;mymap&#123;&#123;<span class="string">&quot;C语言&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;C++教程&quot;</span>,<span class="number">20</span>&#125;&#125;;</span><br><span class="line">   map&lt;string,string&gt;m&#123;<span class="built_in">make_pair</span>(<span class="string">&quot;hi&quot;</span>,<span class="string">&quot;hello&quot;</span>)&#125;;</span><br><span class="line">   map&lt;string,string&gt;copiedmap&#123;m&#125;;</span><br><span class="line"></span><br><span class="line">   map&lt;string,<span class="keyword">int</span>,greater&lt;string&gt; &gt;hismap;</span><br></pre></td></tr></table></figure><p>常用的成员函数是find,count</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>      <span class="comment">// map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建空 map 容器，默认根据个键值对中键的值，对键值对做降序排序</span></span><br><span class="line">    std::map&lt;std::string, std::string, std::greater&lt;std::string&gt;&gt;myMap;</span><br><span class="line">    <span class="comment">//调用 emplace() 方法，直接向 myMap 容器中指定位置构造新键值对</span></span><br><span class="line">    myMap.<span class="built_in">emplace</span>(<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">    myMap.<span class="built_in">emplace</span>(<span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    myMap.<span class="built_in">emplace</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    <span class="comment">//输出当前 myMap 容器存储键值对的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myMap size==&quot;</span> &lt;&lt; myMap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//判断当前 myMap 容器是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!myMap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">//借助 myMap 容器迭代器，将该容器的键值对逐个输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = myMap.<span class="built_in">begin</span>(); i != myMap.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">            cout &lt;&lt; i-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i-&gt;second &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string&gt; myset&#123;<span class="string">&quot;shit&quot;</span>&#125;;</span><br><span class="line">    set&lt;string&gt; set2&#123;</span><br><span class="line">        <span class="string">&quot;hi&quot;</span>,</span><br><span class="line">        <span class="string">&quot;hello&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">set&lt;string&gt; <span class="title">s1</span><span class="params">(set2)</span></span>;</span><br><span class="line">    s.<span class="built_in">emplace</span>(<span class="string">&quot;hi&quot;</span>);</span><br></pre></td></tr></table></figure><p>删除元素 erase</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 set 容器</span></span><br><span class="line">    std::set&lt;<span class="keyword">int</span>&gt;myset&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//1) 调用第一种格式的 erase() 方法</span></span><br><span class="line">    <span class="keyword">int</span> num = myset.<span class="built_in">erase</span>(<span class="number">2</span>); <span class="comment">//删除元素 2，myset=&#123;1,3,4,5&#125;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2) 调用第二种格式的 erase() 方法</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt;::iterator iter = myset.<span class="built_in">erase</span>(myset.<span class="built_in">begin</span>()); <span class="comment">//删除元素 1，myset=&#123;3,4,5&#125;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter-&gt;&quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3) 调用第三种格式的 erase() 方法</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt;::iterator iter2 = myset.<span class="built_in">erase</span>(myset.<span class="built_in">begin</span>(), --myset.<span class="built_in">end</span>());<span class="comment">//删除元素 3,4，myset=&#123;5&#125;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter2-&gt;&quot;</span> &lt;&lt; *iter2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset;</span><br><span class="line">    <span class="comment">//空set容器不存储任何元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//向myset容器中插入新元素</span></span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//利用双向迭代器，遍历myset</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myset.<span class="built_in">begin</span>(); iter != myset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th>介绍</th></tr></thead><tbody><tr><td style="text-align:left">upper_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td style="text-align:left">equal_range(val)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。</td></tr><tr><td style="text-align:left">lower_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr></tbody></table></div><p>注意count,find等新的成员函数</p><p>此外关联式容器还有multimap和multiset,这里不介绍了.</p><h4 id="无序关联式容器"><a href="#无序关联式容器" class="headerlink" title="无序关联式容器"></a>无序关联式容器</h4><p>和关联式容器一样，无序容器也使用键值对（pair 类型）的方式存储数据。不过，它们有本质上的不同：</p><ul><li>关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构；</li><li>无序容器的底层实现采用的是哈希表的存储结构。</li></ul><div class="table-container"><table><thead><tr><th>无序容器</th><th>功能</th></tr></thead><tbody><tr><td>unordered_map</td><td>存储键值对 <key, value> 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。</td></tr><tr><td>unordered_multimap</td><td>和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。</td></tr><tr><td>unordered_set</td><td>不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。</td></tr><tr><td>unordered_multiset</td></tr></tbody></table></div><p>总的来说，实际场景中如果涉及大量遍历容器的操作，建议首选关联式容器；反之，如果更多的操作是通过键获取对应的值，则应首选无序容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化一个 unordered_map 容器，其存储的 &lt;string,string&gt; 类型的键值对</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; my_uMap&#123;</span><br><span class="line">        &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Python教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//查找指定键对应的值，效率比关联式容器高</span></span><br><span class="line">    string str = my_uMap.<span class="built_in">at</span>(<span class="string">&quot;C语言教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用迭代器遍历哈希容器，效率不如关联式容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = my_uMap.<span class="built_in">begin</span>(); iter != my_uMap.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//pair 类型键值对分为 2 部分</span></span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器是cpp STL库的概念,要访问顺序容器和关联容器中的元素，需要通过“迭代器（iterator）”进行。迭代器是一个变量，相当于容器</p><p>和操纵容器的算法之间的中介。迭代器可以指向容器中的某个元素，通过迭代器就可以读写它指向的元素。从这一点上看，迭代器和<a href="http://c.biancheng.net/c/80/">指针</a>类似.</p><p>通过迭代器可以读取它指向的元素，<code>*迭代器名</code>就表示迭代器指向的元素。通过非常量迭代器还能修改其指向的元素。</p><p>迭代器都可以进行<code>++</code>操作。反向迭代器和正向迭代器的区别在于：</p><ul><li>对正向迭代器进行<code>++</code>操作时，迭代器会指向容器中的后一个元素；</li><li>而对反向迭代器进行<code>++</code>操作时，迭代器会指向容器中的前一个元素</li></ul><h3 id="迭代器的分类"><a href="#迭代器的分类" class="headerlink" title="迭代器的分类"></a>迭代器的分类</h3><p>常用的迭代器按功能强弱分为输入、输出、正向、双向、随机访问五种，这里只介绍常用的三种。</p><p>1) 正向迭代器。假设 p 是一个正向迭代器，则 p 支持以下操作：++p，p++，*p。此外，两个正向迭代器可以互相赋值，还可以用<code>==</code>和<code>!=</code>运算符进行比较。</p><p>2) 双向迭代器。双向迭代器具有正向迭代器的全部功能。除此之外，若 p 是一个双向迭代器，则<code>--p</code>和<code>p--</code>都是有定义的。<code>--p</code>使得 p 朝和<code>++p</code>相反的方向移动。</p><p>3) 随机访问迭代器。随机访问迭代器具有双向迭代器的全部功能。若 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p><ul><li>p+=i：使得 p 往后移动 i 个元素。</li><li>p-=i：使得 p 往前移动 i 个元素。</li><li>p+i：返回 p 后面第 i 个元素的迭代器。</li><li>p-i：返回 p 前面第 i 个元素的迭代器。</li><li>p[i]：返回 p 后面第 i 个元素的引用</li></ul><div class="table-container"><table><thead><tr><th>容器</th><th>迭代器功能</th></tr></thead><tbody><tr><td>vector</td><td>随机访问</td></tr><tr><td>deque</td><td>随机访问</td></tr><tr><td>list</td><td>双向</td></tr><tr><td>set / multiset</td><td>双向</td></tr><tr><td>map / multimap</td><td>双向</td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr><tr><td>priority_queue</td><td>不支持迭代器</td></tr></tbody></table></div><h2 id="迭代器的辅助函数"><a href="#迭代器的辅助函数" class="headerlink" title="迭代器的辅助函数"></a>迭代器的辅助函数</h2><p>STL 中有用于操作迭代器的三个函数模板，它们是：</p><ul><li>advance(p, n)：使迭代器 p 向前或向后移动 n 个元素。</li><li>dis<a href="http://c.biancheng.net/ref/tan.html">tan</a>ce(p, q)：计算两个迭代器之间的距离，即迭代器 p 经过多少次 + + 操作后和迭代器 q 相等。如果调用时 p 已经指向 q 的后面，则这个函数会陷入死循环。</li><li>iter_swap(p, q)：用于交换两个迭代器 p、q 指向的值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span> <span class="comment">//要使用操作迭代器的函数模板，需要包含此文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    list &lt;<span class="keyword">int</span>&gt; <span class="built_in">lst</span>(a, a+<span class="number">5</span>);</span><br><span class="line">    list &lt;<span class="keyword">int</span>&gt;::iterator p = lst.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">advance</span>(p, <span class="number">2</span>);  <span class="comment">//p向后移动两个元素，指向3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1)&quot;</span> &lt;&lt; *p &lt;&lt; endl;  <span class="comment">//输出 1)3</span></span><br><span class="line">    <span class="built_in">advance</span>(p, <span class="number">-1</span>);  <span class="comment">//p向前移动一个元素，指向2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2)&quot;</span> &lt;&lt; *p &lt;&lt; endl;  <span class="comment">//输出 2)2</span></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt;::iterator q = lst.<span class="built_in">end</span>();</span><br><span class="line">    q--;  <span class="comment">//q 指向 5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3)&quot;</span> &lt;&lt; <span class="built_in">distance</span>(p, q) &lt;&lt; endl;  <span class="comment">//输出 3)3</span></span><br><span class="line">    <span class="built_in">iter_swap</span>(p, q); <span class="comment">//交换 2 和 5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;4)&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = lst.<span class="built_in">begin</span>(); p != lst.<span class="built_in">end</span>(); ++p)</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;刷算法时有必要使用一些stl.&lt;br&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://www.sekyoro.top/tags/cpp/"/>
    
    <category term="stl" scheme="https://www.sekyoro.top/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>浏览器CORS和CSP介绍</title>
    <link href="https://www.sekyoro.top/2023/03/04/%E6%B5%8F%E8%A7%88%E5%99%A8CORS%E5%92%8CCSP%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.sekyoro.top/2023/03/04/%E6%B5%8F%E8%A7%88%E5%99%A8CORS%E5%92%8CCSP%E4%BB%8B%E7%BB%8D/</id>
    <published>2023-03-04T07:08:59.000Z</published>
    <updated>2023-03-04T08:53:05.173Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>了解浏览器的一些安全策略同时了解跨域问题.<br><span id="more"></span></p><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>全称是跨源资源共享(Cross-Origin Resource Sharing).是一个系统，它由一系列传输的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP_header">HTTP 标头</a>组成，这些 HTTP 标头决定浏览器是否阻止前端 JavaScript 代码获取跨源请求的响应.</p><p>这又涉及到了浏览器的同源策略.</p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p><strong>同源策略</strong>是一个重要的安全策略，它用于限制一个<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin">源</a>的文档或者它加载的脚本如何能与另一个源的资源进行交互。</p><blockquote><p>它能帮助阻隔恶意文档，减少可能被攻击的媒介。例如，它可以防止互联网上的恶意网站在浏览器中运行 JS 脚本，从第三方网络邮件服务（用户已登录）或公司内网（因没有公共 IP 地址而受到保护，不会被攻击者直接访问）读取数据，并将这些数据转发给攻击者。</p></blockquote><h4 id="源的定义"><a href="#源的定义" class="headerlink" title="源的定义"></a>源的定义</h4><p>如果两个 URL 的<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol">协议</a>、<a href="https://developer.mozilla.org/en-US/docs/Glossary/Port">端口 (en-US)</a>（如果有指定的话）和<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Host">主机</a>都相同的话，则这两个 URL 是<em>同源</em>的。这个方案也被称为“协议/主机/端口元组”，或者直接是“元组”。（“元组”是指一组项目构成的整体，具有双重/三重/四重/五重等通用形式。）</p><p>协议比如http,https.  主机是域名或者ip地址.</p><div class="table-container"><table><thead><tr><th style="text-align:left">URL</th><th style="text-align:left">结果</th><th style="text-align:left">原因</th></tr></thead><tbody><tr><td style="text-align:left"><code>http://store.company.com/dir2/other.html</code></td><td style="text-align:left">同源</td><td style="text-align:left">只有路径不同</td></tr><tr><td style="text-align:left"><code>http://store.company.com/dir/inner/another.html</code></td><td style="text-align:left">同源</td><td style="text-align:left">只有路径不同</td></tr><tr><td style="text-align:left"><code>https://store.company.com/secure.html</code></td><td style="text-align:left">失败</td><td style="text-align:left">协议不同</td></tr><tr><td style="text-align:left"><code>http://store.company.com:81/dir/etc.html</code></td><td style="text-align:left">失败</td><td style="text-align:left">端口不同（<code>http://</code> 默认端口是 80）</td></tr><tr><td style="text-align:left"><code>http://news.company.com/dir/other.html</code></td><td style="text-align:left">失败</td><td style="text-align:left">主机不同</td></tr></tbody></table></div><p>除了一般的HTTP还有<strong>文件源</strong>.</p><p>现代浏览器通常将使用 <code>file:///</code> 模式加载的文件的来源视为<em>不透明的来源</em>。这意味着，假如一个文件包括来自同一文件夹的其它文件，它们不会被认为来自同一来源，并可能引发 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CORS">CORS</a> 错误</p><p><strong>源的继承</strong></p><p>在页面中通过 <code>about:blank</code> 或 <code>javascript:</code> URL 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URL 没有包含源服务器的相关信息。</p><p>例如，<code>about:blank</code> 通常作为父脚本写入内容的新的空白弹出窗口的 URL（例如，通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open"><code>Window.open()</code></a>）。如果此弹出窗口也包含 JavaScript，则该脚本将从创建它的脚本那里继承对应的源。</p><h4 id="跨源网络访问"><a href="#跨源网络访问" class="headerlink" title="跨源网络访问"></a>跨源网络访问</h4><p>同源策略会影响不同源之间的交互.</p><blockquote><p>例如在使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img"><code>img</code></a> 标签时则会受到同源策略的约束。这些交互通常分为三类：</p><ul><li>跨源<strong>写操作</strong>（Cross-origin writes）一般是被允许的。例如链接、重定向以及表单提交。特定少数的 HTTP 请求需要添加<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#预检请求">预检请求</a>。</li><li>跨源<strong>资源嵌入</strong>（Cross-origin embedding）一般是被允许的.</li><li>跨源<strong>读操作</strong>（Cross-origin reads）一般是不被允许的，但常可以通过内嵌资源来巧妙的进行读取访问。例如，你可以读取嵌入图片的高度和宽度，调用内嵌脚本的方法，或<a href="https://bugzil.la/629094">得知内嵌资源的可用性</a>。</li></ul></blockquote><p>以下是<strong>可能嵌入跨源的资源</strong>的一些示例：</p><ul><li>使用 <code>&lt;script src=&quot;…&quot;&gt;&lt;/script&gt;</code> 标签嵌入的 JavaScript 脚本。语法错误信息只能被同源脚本中捕捉到。</li><li>使用 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;…&quot;&gt;</code> 标签嵌入的 CSS。由于 CSS 的松散的语法规则，CSS 的跨源需要一个设置正确的 <code>Content-Type</code> 标头。如果样式表是跨源的，且 MIME 类型不正确，资源不以有效的 CSS 结构开始，浏览器会阻止它的加载。</li><li>通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img"><code>img</code></a> 展示的图片。</li><li>通过<code>video</code>和<code>audio</code>播放的多媒体资源。</li><li>通过 <code>object</code>和<code>embed</code> 嵌入的插件。</li><li>通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face"><code>@font-face</code></a> 引入的字体。一些浏览器允许跨源字体（cross-origin fonts），另一些需要同源字体（same-origin fonts）。</li><li>通过iframe载入的资源。站点可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Frame-Options"><code>X-Frame-Options</code></a> 标头来阻止这种形式的跨源交互。</li></ul><p>这份<a href="https://fetch.spec.whatwg.org/#http-cors-protocol">跨源共享标准</a>允许在下列场景中使用跨站点 HTTP 请求：</p><ul><li>前文提到的由 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">Fetch API</a> 发起的跨源 HTTP 请求。</li><li>Web 字体（CSS 中通过 <code>@font-face</code> 使用跨源字体资源），<a href="https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements">因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用</a>。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL">WebGL 贴图</a>。</li><li>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage"><code>drawImage()</code></a> 将图片或视频画面绘制到 canvas。</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Shapes/Shapes_From_Images">来自图像的 CSS 图形 (en-US)</a>。</li></ul><p>可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">CORS</a> 来允许跨源访问。CORS 是 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP">HTTP</a> 的一部分，它允许服务端来指定哪些主机可以从这个服务端加载资源。</p><h3 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h3><p>cors是一种基于HTTP头的机制,解决浏览器同源策略,允许服务器标示除了它自己以外的其它<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin">源</a>（域、协议或端口），使得浏览器允许这些源访问加载自己的资源.</p><p><strong>CORS 标头</strong></p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin"><code>Access-Control-Allow-Origin</code></a></p><p>指示响应的资源是否可以被给定的来源共享。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials"><code>Access-Control-Allow-Credentials</code></a></p><p>指示当请求的凭证标记为 true 时，是否可以公开对该请求响应。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Headers"><code>Access-Control-Allow-Headers</code></a></p><p>用在对预检请求的响应中，指示实际的请求中可以使用哪些 HTTP 标头。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Methods"><code>Access-Control-Allow-Methods</code></a></p><p>指定对预检请求的响应中，哪些 HTTP 方法允许访问请求的资源。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Expose-Headers"><code>Access-Control-Expose-Headers</code></a></p><p>通过列出标头的名称，指示哪些标头可以作为响应的一部分公开。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Max-Age"><code>Access-Control-Max-Age</code></a></p><p>指示预检请求的结果能被缓存多久。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers"><code>Access-Control-Request-Headers</code></a></p><p>用于发起一个预检请求，告知服务器正式请求会使用哪些 HTTP 标头。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Method"><code>Access-Control-Request-Method</code></a></p><p>用于发起一个预检请求，告知服务器正式请求会使用哪一种 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods">HTTP 请求方法</a>。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin"><code>Origin</code></a></p><p>指示获取资源的请求是从什么源发起的。</p></li></ul><p>跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求,通过浏览器发起一个到服务器托管的跨源资源的“预检”请求。在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头.</p><h4 id="实际访问控制场景"><a href="#实际访问控制场景" class="headerlink" title="实际访问控制场景"></a>实际访问控制场景</h4><ol><li><p>简单请求不会触发CORS预检请求.</p><p>若满足所有下述条件,</p><ul><li>使用下列方法之一：<ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD"><code>HEAD</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST"><code>POST</code></a></li></ul></li></ul></li></ol><p>​    允许人为设置下面的字段</p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept"><code>Accept</code></a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language"><code>Accept-Language</code></a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language"><code>Content-Language</code></a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a>（需要注意额外的限制）</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Range"><code>Range</code></a>（只允许<a href="https://fetch.spec.whatwg.org/#simple-range-header-value">简单的范围标头值</a> 如 <code>bytes=256-</code> 或 <code>bytes=127-255</code>）</p></li><li><p><code>Content-Type</code></p></li></ul><p>  标头所指定的</p><p>  媒体类型</p><p>  的值仅限于下列三者之一：</p><ul><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul><p>具体请查阅MDN<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#什么情况下需要_cors？">跨源资源共享（CORS） - HTTP | MDN (mozilla.org)</a></p><p>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin"><code>Origin</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin"><code>Access-Control-Allow-Origin</code></a> 就能完成最简单的访问控制。如果 <code>https://bar.other</code> 的资源持有者想限制他的资源<em>只能</em>通过 <code>https://foo.example</code> 来访问</p><ol><li>预检请求</li></ol><p>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin"><code>Origin</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin"><code>Access-Control-Allow-Origin</code></a> 就能完成最简单的访问控制。如果 <code>https://bar.other</code> 的资源持有者想限制他的资源<em>只能</em>通过 <code>https://foo.example</code> 来访问</p><ol><li><p>附带身份凭证的请求</p><p>一般而言，对于跨源 <code>XMLHttpRequest</code> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">Fetch</a> 请求，浏览器<strong>不会</strong>发送身份凭证信息。如果要发送凭证信息，需要设置 <code>XMLHttpRequest</code> 对象的某个特殊标志位，或在构造 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Request"><code>Request</code></a> 对象时设置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> invocation = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"> invocation.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>如果服务器端的响应中未携带 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials"><code>Access-Control-Allow-Credentials</code></a><code>: true</code>，浏览器将<strong>不会</strong>把响应内容返回给请求的发送者</p></li></ol><h2 id="内容安全策略-CSP"><a href="#内容安全策略-CSP" class="headerlink" title="内容安全策略(CSP)"></a>内容安全策略(CSP)</h2><p><strong>内容安全策略</strong>（<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CSP">CSP</a>）是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括<strong>跨站脚本</strong>（<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting">XSS</a>）和<strong>数据注入攻击</strong>等。无论是数据盗取、网站内容污染还是恶意软件分发，这些攻击都是主要的手段。  </p><p>为使 CSP 可用，你需要配置你的网络服务器返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy"><code>Content-Security-Policy</code></a> HTTP 标头（有时你会看到 <code>X-Content-Security-Policy</code> 标头，但那是旧版本，并且你无须再如此指定它）。</p><p>除此之外，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta">``</a> 元素也可以被用来配置该策略，例如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; img-src https://*; child-src &#x27;none&#x27;;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP#示例_1">示例 1</a></h3><p>一个网站管理者想要所有内容均来自站点的同一个源（不包括其子域名）。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-<span class="keyword">Security</span>-<span class="keyword">Policy</span>: <span class="keyword">default</span>-src <span class="string">&#x27;self&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP#示例_2">示例 2</a></h3><p>一个网站管理者允许内容来自信任的域名及其子域名（域名不必须与 CSP 设置所在的域名相同）。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-<span class="keyword">Security</span>-<span class="keyword">Policy</span>: <span class="keyword">default</span>-src <span class="string">&#x27;self&#x27;</span> *.<span class="keyword">trusted</span>.com</span><br></pre></td></tr></table></figure><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP#示例_3">示例 3</a></h3><p>一个网站管理者允许网页应用的用户在他们自己的内容中包含来自任何源的图片，但是限制音频或视频需从信任的资源提供者，所有脚本必须从特定主机服务器获取可信的代码。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content</span>-Security-Policy: default-src <span class="string">&#x27;self&#x27;</span>; <span class="selector-tag">img</span>-<span class="attribute">src</span> *; media-<span class="attribute">src</span> media1<span class="selector-class">.com</span> media2<span class="selector-class">.com</span>; script-<span class="attribute">src</span> userscripts<span class="selector-class">.example</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure><p>在这里，各种内容默认仅允许从文档所在的源获取，但存在如下例外：</p><ul><li>图片可以从任何地方加载 (注意“*”通配符)。</li><li>多媒体文件仅允许从 media1.com 和 media2.com 加载（不允许从这些站点的子域名）。</li><li>可运行脚本仅允许来自于 userscripts.example.com。</li></ul><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP#示例_4">示例 4</a></h3><p>一个线上银行网站的管理者想要确保网站的所有内容都要通过 SSL 方式获取，以避免攻击者窃听用户发出的请求。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src <span class="attribute">https</span>:<span class="comment">//onlinebanking.jumbobank.com</span></span><br></pre></td></tr></table></figure><p>该服务器仅允许通过 HTTPS 方式并仅从 onlinebanking.jumbobank.com 域名来访问文档。</p><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP#示例_5">示例 5</a></h3><p>一个在线邮箱的管理者想要允许在邮件里包含 HTML，同样图片允许从任何地方加载，但不允许 JavaScript 或者其它潜在的危险内容（从任意位置加载）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content</span>-Security-Policy: default-src <span class="string">&#x27;self&#x27;</span> *.mailsite.com; <span class="selector-tag">img</span>-<span class="attribute">src</span> *</span><br></pre></td></tr></table></figure><p>注意这个示例并未指定 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src"><code>script-src</code> (en-US)</a>；在此 CSP 示例中，站点通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src"><code>default-src</code></a> 指令的对其进行配置，这也同样意味着脚本文件仅允许从原始服务器获取。</p><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">跨源资源共享（CORS） - HTTP | MDN (mozilla.org)</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP#对策略进行测试">内容安全策略（CSP） - HTTP | MDN (mozilla.org)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;了解浏览器的一些安全策略同时了解跨域问题.&lt;br&gt;</summary>
    
    
    
    
    <category term="cors" scheme="https://www.sekyoro.top/tags/cors/"/>
    
    <category term="csp" scheme="https://www.sekyoro.top/tags/csp/"/>
    
    <category term="浏览器" scheme="https://www.sekyoro.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>学习purecss构建自己的css框架</title>
    <link href="https://www.sekyoro.top/2023/02/18/%E5%AD%A6%E4%B9%A0purecss%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84css%E6%A1%86%E6%9E%B6/"/>
    <id>https://www.sekyoro.top/2023/02/18/%E5%AD%A6%E4%B9%A0purecss%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84css%E6%A1%86%E6%9E%B6/</id>
    <published>2023-02-18T04:35:33.000Z</published>
    <updated>2023-02-18T04:58:31.377Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>更加简易的Bootstrap框架,定制度更高.比Tailwind轻量.<br><span id="more"></span></p><p>中文官方文档<a href="https://purecss.cn/start.html">开始使用 - Pure | Pure中文站 | Purecss学习网</a></p><p>官网有最新版<a href="https://purecss.io/start/">Get Started - Pure (purecss.io)</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;更加简易的Bootstrap框架,定制度更高.比Tailwind轻量.&lt;br&gt;</summary>
    
    
    
    
    <category term="css" scheme="https://www.sekyoro.top/tags/css/"/>
    
    <category term="pure.css" scheme="https://www.sekyoro.top/tags/pure-css/"/>
    
  </entry>
  
  <entry>
    <title>DLHLP学习</title>
    <link href="https://www.sekyoro.top/2023/02/17/DLHLP%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2023/02/17/DLHLP%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-02-17T02:37:57.000Z</published>
    <updated>2023-02-17T03:03:53.064Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>李宏毅的语言处理. Deep Learning for Human Language Processing.<br><span id="more"></span></p><p>课程链接<a href="https://www.youtube.com/watch?v=nER51ZyJaCQ&amp;list=PLJV_el3uVTsO07RpBYFsXg-bN5Lu0nhdG&amp;ab_channel=Hung-yiLee">DLHLP 2020] Deep Learning for Human Language Processing (Course Overview) - YouTube</a></p><p><img data-src="http://cdn.sekyoro.top/imgs/17/0220230217105241.png" alt="image-20230217105215776" style="zoom:67%;" /></p><h3 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h3><p>传统语音处理</p><p><img data-src="http://cdn.sekyoro.top/imgs/17/0220230217105753.png" alt="image-20230217105753162"></p><p>ASR(automatic speech recognition)</p><h3 id="语音合成"><a href="#语音合成" class="headerlink" title="语音合成"></a>语音合成</h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;李宏毅的语言处理. Deep Learning for Human Language Processing.&lt;br&gt;</summary>
    
    
    
    
    <category term="Deep Learning" scheme="https://www.sekyoro.top/tags/Deep-Learning/"/>
    
    <category term="Speech" scheme="https://www.sekyoro.top/tags/Speech/"/>
    
  </entry>
  
  <entry>
    <title>docker学习</title>
    <link href="https://www.sekyoro.top/2023/02/13/docker%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2023/02/13/docker%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-02-13T09:41:44.000Z</published>
    <updated>2023-02-13T15:27:29.952Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Docker可以方便部署以及利用镜像快速学习一些项目,解决环境冲突等.重点关注Dockerfile和docker-compose文件的编写.<br><span id="more"></span></p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Docker 是一个开源的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html">Go 语言</a> 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><blockquote><p>Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p></blockquote><ul><li>Web 应用的自动化打包和发布。</li><li>自动化测试和持续集成、发布。</li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li><li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li></ul><h3 id="镜像-image"><a href="#镜像-image" class="headerlink" title="镜像(image)"></a>镜像(image)</h3><p>镜像类似于一个打包好的软件或可执行程序,可以通过运行这个镜像得到容器(类似于一个进程).</p><p>镜像可以<strong>自己打包</strong>或从<strong>Docker Hub</strong><a href="https://hub.docker.com/">Docker Hub Container Image Library | App Containerization</a>获取,如果本地没有打包的默认从后者拉取.</p><p>自己打包需要Dockerfile定制这个”可执行程序”,有了Dockerfile后可以使用<code>docker build .</code>构建镜像.</p><p><code>.</code>符号表示在这个目录下的Dockerfile文件.</p><p>一个镜像可以在多个容器运行,可以将镜像分享给别人.</p><p>使用<code>docker run</code>运行镜像,如果本地没有会自动<code>docker pull</code>拉取.</p><p>使用<code>docker push</code>可以将自己的镜像推送到Docker Hub.</p><p>这里我们创建一个小项目.</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213175949.png" alt="image-20230213175925727" style="zoom:50%;" /></p><p>创建一个服务监听端口.</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213175946.png" alt="image-20230213175946483"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span></span><br><span class="line">        &#123;</span><br><span class="line">res.send(<span class="string">&#x27;&lt;p&gt;你好&lt;/p&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">app.listen(port,<span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="string">&quot;端口是3000&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写好后就可以直接创建Dockerfile建立镜像了.</p><p>首先Dockerfile文件创建在项目根目录中.</p><p>需要先拉取镜像,可以在<a href="https://hub.docker.com/">Docker Hub Container Image Library | App Containerization</a>中查找.</p><p>首先我们用到了node,所以需要拉取相应的node镜像(一般node镜像肯定带了OS等底层的镜像)</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213180313.png" alt="image-20230213180312673" style="zoom: 50%;" /></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">19</span>-alpine3.<span class="number">16</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /myworkdir</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm i</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;node&quot;</span>,<span class="string">&quot;app.js&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>docker会一行一行扫描代码.</p><p>FROM表示拉取node:19-alpine3.16,node:19-alpine3.16是镜像名,19-alpine3.16表示版本,node 19版本,alpine是一个操作系统常用于Docker构建.  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myimage:v1  .</span><br></pre></td></tr></table></figure><p>如果不使用tag,则没有名字</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/02image-20230213190037683.png" alt="image-20230213190037683"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag &lt;IMAGE ID&gt; &lt;REPO:TAG&gt;</span><br></pre></td></tr></table></figure><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213190203.png" alt="image-20230213190203625"></p><p>没有tag默认latest</p><p>使用<code>docker push</code>推送镜像</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213190322.png" alt="image-20230213190322542" style="zoom:50%;" /></p><p>使用<code>docker rmi</code>删除本地镜像</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213190427.png" alt="image-20230213190427515"></p><p>使用<code>docker pull</code>拉取Docker Hub中的镜像.</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213190537.png" alt="image-20230213190537437"></p><h3 id="容器-container"><a href="#容器-container" class="headerlink" title="容器(container)"></a>容器(container)</h3><p>使用<code>docker run &lt;镜像名&gt;</code>运行镜像从而得到</p><p><code>-d</code>参数后台运行</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213191520.png" alt="image-20230213191519991" style="zoom:67%;" /></p><p>使用<code>docker images</code>查询镜像信息.</p><p>使用<code>docker ps</code>查询容器信息.</p><p>这里并不能直接通过3000端口访问网页,因为并没有实际暴露.</p><p>Dockerfile文件中EXPOSE命令只是标识提醒作用.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3000:3000 --name mydocker proanimer/nodejs:<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><code>-p</code>参数表示端口映射 本地3000映射后者容器的3000.</p><p><code>--name</code>参数表示给容器命名,否则有默认命名.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3000:3000 --name mydockerpro proanimer/nodejs:<span class="built_in">test</span>           </span><br></pre></td></tr></table></figure><p>使用<code>docker stop &lt;容器id&gt;</code>停止运行.</p><p>使用<code>docker rm &lt;容器id&gt;</code>删除窗口.</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213192549.png" alt="image-20230213192549208"></p><p>修改文件后容器并不会跟着改变,因为修改的文件时本地镜像中的文件,容器是之前的镜像运行后的结果.我们需要与运行的容器直接交互.</p><p>使用<code>docker exec -it &lt;镜像名或id&gt; /bin/sh</code> </p><p><code>/bin/sh</code>是容器中os的shell.</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213201031.png" alt="image-20230213195526472"></p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213201022.png" alt="image-20230213200936929"></p><p>注意 如果在Windows上需要加上winpty,同时设定shell路径时是<code>//bin/sh</code>即需要多加上一个<code>/</code></p><p>注意进入容器后很多工具比如vim可能都没有,所以需要用到路径映射.</p><p>设置volume,-v 把本地指定文件夹和容器指定文件夹绑定</p><p>这里使用</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213210813.png" alt="image-20230213210813343">注意如果是git bash for windows.使用下面命令,</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  -v F://docker_exp1://myworkdir -p 3000:3000 --name mypro proanimer/nodejs:<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213220937.png" alt="image-20230213220937554"></p><p>发现挂载路径有/hostmnt,这是git bash比较特别的,表示宿主机.</p><p>如果是在windows的powershell.</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213220123.png" alt="image-20230213220122719"></p><p>检查挂载路径,<img data-src="http://cdn.sekyoro.top/imgs/13/0220230213221258.png" alt="image-20230213221258083" style="zoom:80%;" /></p><p>两者这里不同,但本质上是一样的.</p><p>注意,这里路径映射时是依照宿主机的,即如果宿主机/dir上有A,B文件,容器路径中/dir中有C文件,将这两个路径映射,则实际用时是A,B文件.</p><p>同时使用<code>-v 目录</code>对这个容器中的目录不进行同步.本地只读后增加:ro</p><p><img data-src="http://cdn.sekyoro.top/imgs/13/0220230213225237.png" alt="image-20230213225237389" style="zoom:67%;" /></p><p><strong>ro模式</strong></p><p>（1）文件：容器内不能修改，会提示read-only</p><p>（2）文件夹：容器内不能修改、新增、删除文件夹中的文件，会提示read-only</p><p><code>docker rm -fv</code>同时把volume删除.</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>通过写Dockerfile定制镜像文件,使用<code>docker build</code>创建镜像.</p><h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p><strong>FROM</strong>：定制的镜像都是基于FROM的镜像</p><h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p><strong>RUN</strong>：用于执行后面跟着的命令行命令。有以下两种格式：</p><p>shell 格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;命令行命令&gt;</span><br><span class="line"><span class="comment"># &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span></span><br></pre></td></tr></table></figure><p>exec 格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN [<span class="string">&quot;可执行文件&quot;</span>, <span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>]</span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line"><span class="comment"># RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN **yum** -y **install** **wget**</span><br><span class="line">RUN **wget** -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span><br><span class="line">RUN **tar** -xvf redis.tar.gz</span><br></pre></td></tr></table></figure><p>以上执行会创建 3 层镜像。可简化为以下格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum -y install wget \</span><br><span class="line">  &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span><br><span class="line">  &amp;&amp; tar -xvf redis.tar.gz</span><br></pre></td></tr></table></figure><p>如上，以 <strong>&amp;&amp;</strong> 符号连接命令，这样执行后，只会创建 1 层镜像。</p><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p><ul><li><strong>CMD 在docker run</strong> 时运行。</li><li><strong>RUN 是在 docker build</strong>即构建时运行.</li></ul><p><strong>作用</strong>：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD &lt;shell 命令&gt; </span><br><span class="line">CMD [<span class="string">&quot;&lt;可执行文件或命令&gt;&quot;</span>,<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...] </span><br><span class="line">CMD [<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...]  <span class="comment"># 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span></span><br></pre></td></tr></table></figure><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p><p>但是, 如果运行 docker run 时使用了 —entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序。</p><p><strong>优点</strong>：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [<span class="string">&quot;&lt;executeable&gt;&quot;</span>,<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...]</span><br></pre></td></tr></table></figure><h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。</p><p>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> &lt;工作目录路径&gt;</span></span><br></pre></td></tr></table></figure><h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p><p>作用：</p><ul><li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li><li>避免容器不断变大。</li></ul><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">&quot;&lt;路径1&gt;&quot;</span>, <span class="string">&quot;&lt;路径2&gt;&quot;</span>...]</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> &lt;路径&gt;</span></span><br></pre></td></tr></table></figure><p>在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。</p><h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p>仅仅只是声明端口. <strong>注意</strong>并没有实际作用</p><p>作用：</p><ul><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li><li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li></ul><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;端口<span class="number">1</span>&gt; [&lt;端口<span class="number">2</span>&gt;...]</span><br></pre></td></tr></table></figure><h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="keyword">ENV</span> &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br></pre></td></tr></table></figure><p>以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span></span><br><span class="line"><span class="bash">  &amp;&amp; curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span></span></span><br></pre></td></tr></table></figure><h4 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h4><p>构建参数，与 ENV 作用一致。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</p><p>构建命令 docker build 中可以用 —build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> &lt;参数名&gt;[=&lt;默认值&gt;]</span><br></pre></td></tr></table></figure><h4 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h4><p>用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在<strong>本次构建镜像的过程中不会执行</strong>（假设镜像为 test-build）。当有新的 Dockerfile <strong>使用了之前构建的镜像 FROM test-build ，这时执行新镜像的 Dockerfile 构建时候，会执行</strong> test-build 的 Dockerfile 里的 ONBUILD 指定的命令。</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ONBUILD</span> &lt;其它指令&gt;</span><br></pre></td></tr></table></figure><h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p>LABEL 指令用来给镜像添加一些元数据（metadata），以键值对的形式，语法格式如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt; =&lt;value&gt; ...</span></span><br></pre></td></tr></table></figure><p>比如我们可以添加镜像的作者：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL org.opencontainers.image.authors=<span class="string">&quot;runoob&quot;</span></span><br></pre></td></tr></table></figure><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h3><p>启动多个容器处理应用.</p><p>yaml文件格式.</p><p><strong>基本语法</strong></p><ul><li><strong>大小写敏感</strong></li><li><strong>使用缩进表示层级关系</strong></li><li>缩进不允许使用tab，<strong>只允许空格</strong></li><li>缩进的空格数不重要，<strong>只要相同层级的元素左对齐即可</strong></li><li>‘#’表示注释</li></ul><p>创建docker-compose.yml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yaml 配置实例</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">.:/code</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">logvolume01:/var/log</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">logvolume01:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>services下都是镜像,build表示通过Dockerfile构建.</p><p>ports和volumes用于映射端口和数据卷.</p><p>使用命令<code>docker-compose up -d --build</code>-d表示后台,—build表示如果镜像修改就会重建.</p><h4 id="version"><a href="#version" class="headerlink" title="version"></a>version</h4><p>指定本 yml 依从的 compose 哪个版本制定的。</p><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>指定为构建镜像上下文路径：</p><h4 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h4><p>将主机的数据卷或着文件挂载到容器里。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:latest</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/localhost/postgres.sock:/var/run/postgres/postgres.sock&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/localhost/data:/var/lib/postgresql/data&quot;</span></span><br></pre></td></tr></table></figure><h4 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h4><p>暴露端口，但不映射到宿主机，只允许能被连接的服务访问。仅可以指定内部端口为参数，如下所示：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">expose:</span></span><br><span class="line">    - <span class="string">&quot;3000&quot;</span></span><br><span class="line">    - <span class="string">&quot;8000&quot;</span></span><br></pre></td></tr></table></figure><h4 id="links"><a href="#links" class="headerlink" title="links"></a>links</h4><p>链接到其它服务中的容器。使用服务名称（同时作为别名），或者服务名称:服务别名（如 SERVICE:ALIAS），例如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">links:</span><br><span class="line"><span class="bullet">    -</span> db</span><br><span class="line"><span class="bullet">    -</span> db:database</span><br><span class="line"><span class="bullet">    -</span> redis</span><br></pre></td></tr></table></figure><p>使用<code>docker-compose down -v</code>删除镜像同时删除volume</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.cnblogs.com/minseo/p/11548177.html">Docker入门之docker-compose - minseo - 博客园 (cnblogs.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;Docker可以方便部署以及利用镜像快速学习一些项目,解决环境冲突等.重点关注Dockerfile和docker-compose文件的编写.&lt;br&gt;</summary>
    
    
    
    
    <category term="tutorial" scheme="https://www.sekyoro.top/tags/tutorial/"/>
    
    <category term="docker" scheme="https://www.sekyoro.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>TotalCommander使用和学习</title>
    <link href="https://www.sekyoro.top/2023/02/07/TotalCommander%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2023/02/07/TotalCommander%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-02-07T08:21:28.000Z</published>
    <updated>2023-02-07T10:39:45.484Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用TotalCommander提升平时工作学习效率.<br><span id="more"></span></p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>由于之前使用Premiere Pro时发现必须使用管理员身份打开,否则会出现莫名奇妙的问题包含但不限于<code>显示表面初始化失败</code>以及后面打开时无法使用一些<code>动态运动图形素材</code>.</p><p>当使用管理员身份打开后,就难以从文件管理器中拖入文件到素材库中. 因为权限问题无法拖入.</p><iframe src="//player.bilibili.com/player.html?aid=393029005&bvid=BV12d4y1V7Ns&cid=972854406&page=1" scrolling="yes" border="2" frameborder="yes" framespacing="5" allowfullscreen="true"> </iframe><p>简单的方法可以打开注册表设置LUA为0,但这个方法并不推荐.或者用管理员身份打开Everything软件,从Everything中拖入素材.</p><p>但是Everything这个软件还是适合直接用来找文件,后面查询了一些资料发现了Total Commander这个工具以管理员身份打开用来拖文件到素材库.发现这个工具还挺不错的.</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>Total Commander，简称TC，原名Windows Commander，功能强大的全能文件管理器。Total Commander 是<a href="https://baike.baidu.com/item/共享软件/680839">共享软件</a>，<a href="https://baike.baidu.com/item/官网/7805125">官网</a>下载版本为一个月<a href="https://baike.baidu.com/item/试用版/1656171">试用版</a></p></blockquote><p><img data-src="http://cdn.sekyoro.top/imgs/07/0220230207172756.png" alt="image-20230207172746360" style="zoom:67%;" /></p><p>所以这里就需要动用自己找资源的能力了,我在本文最后附有我找到的破解版下载网址,可以跳过其中的打开注册表文件夹操作,原价现在貌似需要200多.</p><p>可以看到这里就是一个没有怎么配置的TC界面.</p><p>这里直接使用别人的图片</p><p><img data-src="https://pic3.zhimg.com/80/v2-75f6664b0bd8160569a8254fb03c0572_720w.webp" alt="img" style="zoom:80%;" /></p><p>以管理员身份打开,测试成功.可以拖入素材</p><p><img data-src="http://cdn.sekyoro.top/imgs/07/0220230207175417.png" alt="image-20230207175417295"></p><p>到这里其实我的目的就达到了,不过这个工具其实思想跟Linux系统常用的桌面管理器类似(我之前的文章也介绍过),所以稍微学习一下也不错.</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>这个软件有两侧文件夹栏目</p><p><strong>标签栏常用快捷键</strong>:<br>Ctrl+T 创建标签页<br>Ctrl+W 关闭标签页<br>Ctrl+Shift+W 关闭所有非锁定标签页<br>Ctrl+Tab键 切换下一个标签<br>Ctrl+Shift+Tab键 切换上一个标签页</p><p>Ctrl+D 唤出书签栏菜单</p><p>ctrl+q 快速预览效果</p><p>ctrl+\ 跳转到跟目录</p><p> Ctrl + →或←，将光标下的文件夹或压缩包在另一个窗口打开</p><p>Alt +↓显示 历史文件夹，Alt + ←到 前一个访问过的目录，Alt + →到 后一个访问过的目录。</p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p><img data-src="http://cdn.sekyoro.top/imgs/07/0220230207172756.png" style="zoom:50%;" /></p><p>其实更多的就需要自己配快捷键了.另外还有插件等,这里就不更多探索了.</p><p>这里由于我需要输入文件路径到目录下拖素材,所以增加了快捷键.</p><p><img data-src="http://cdn.sekyoro.top/imgs/07/0220230207175417.png" style="zoom:80%;" /></p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/163301413">Total Commander用法介绍 - 知乎 (zhihu.com)</a></li><li><a href="https://www.jb51.net/softs/824660.html">Total Commander破解补丁下载</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用TotalCommander提升平时工作学习效率.&lt;br&gt;</summary>
    
    
    
    
    <category term="TotalCommander" scheme="https://www.sekyoro.top/tags/TotalCommander/"/>
    
    <category term="工具使用" scheme="https://www.sekyoro.top/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    <category term="效率提升" scheme="https://www.sekyoro.top/tags/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>闲置服务器BT下载影视</title>
    <link href="https://www.sekyoro.top/2023/01/23/%E9%97%B2%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8BT%E4%B8%8B%E8%BD%BD%E5%BD%B1%E8%A7%86/"/>
    <id>https://www.sekyoro.top/2023/01/23/%E9%97%B2%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8BT%E4%B8%8B%E8%BD%BD%E5%BD%B1%E8%A7%86/</id>
    <published>2023-01-23T13:38:55.000Z</published>
    <updated>2023-01-24T05:26:11.614Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>利用闲置服务器通过BT SSR下载动漫,并通过filebrowser浏览下载.<br><span id="more"></span></p><h2 id="FileBrowser"><a href="#FileBrowser" class="headerlink" title="FileBrowser"></a>FileBrowser</h2><blockquote><p>filebrowser 是一个使用go语言编写的软件，功能是可以通过浏览器对服务器上的文件进行管理。可以是修改文件，或者是添加删除文件，甚至可以分享文件，是一个很棒的文件管理器，你甚至可以当成一个网盘来使用。</p></blockquote><p>在网站上下载压缩包后并解压.</p><p><a href="https://github.com/filebrowser/filebrowser">filebrowser/filebrowser: 📂 Web File Browser (github.com)</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf linux-amd64-filebrowser.tar.gz</span><br><span class="line">CHANGELOG.md</span><br><span class="line">LICENSE</span><br><span class="line">README.md</span><br><span class="line">filebrowser</span><br></pre></td></tr></table></figure><p>直接运行程序,默认端口在8080</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> ./filebrowser</span><br><span class="line">15:22:42 No config file used</span><br><span class="line">15:22:42 Listening on 127.0.0.1:8080</span><br></pre></td></tr></table></figure><p>一般都需要更改这个默认端口,可以先找到其db配置文件.</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>你可以直接通过命令参数filebrowser 后接参数设置,这里我推荐设置db文件.</p><p><img data-src="http://cdn.sekyoro.top/imgs/23/0120230123235939.png" alt="image-20230123221036526" style="zoom:80%;" /></p><p>默认配置文件在上面三个目录下你可以依次找看有没有.db文件,如果没有可以通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filebrowser config init</span><br></pre></td></tr></table></figure><p>新建文件,然后通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filebrowser config cat</span><br></pre></td></tr></table></figure><p>查看设置</p><p><img data-src="http://cdn.sekyoro.top/imgs/23/0120230123235942.png" alt="image-20230123221243713" style="zoom:67%;" /></p><p>我们可以通过filebrowser config set -p 9200设置运行端口为9200.</p><h3 id="设置安全组"><a href="#设置安全组" class="headerlink" title="设置安全组"></a>设置安全组</h3><p>开启后注意在服务器商那,比如腾讯云,阿里云拿<strong>设置安全组</strong>开通这个端口,允许外网访问,<strong>同时</strong>还要在服务器这开启端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=9201/tcp --permanent</span><br></pre></td></tr></table></figure><p>同时最好重启一下防火墙服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p>进入目录/lib/systemd/system,可以新建filebrowser.service或者下载一个类似的文件.</p><p><img data-src="http://cdn.sekyoro.top/imgs/23/0120230123235958.png" alt="image-20230123222348866"></p><p>写入以上内容,主要设置-d 配置刚才的db文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start filebrowser.service</span><br></pre></td></tr></table></figure><p>开启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> filebrowser.service</span><br></pre></td></tr></table></figure><p>设置开机自启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status filebrowser.service</span><br></pre></td></tr></table></figure><p>查看运行状态</p><p><img data-src="http://cdn.sekyoro.top/imgs/23/0120230123235947.png" alt="image-20230123223854973"></p><p>然后打开你的网站,即公网ip+port,打开后类似如下图</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000007.png" alt="image-20230123222855110" style="zoom:80%;" /></p><p>可以在设置页面设置一些选项.</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000010.png" alt="image-20230123222951056" style="zoom:67%;" />这样设置后就能访问某个文件夹下的内容了.</p><h2 id="qbtorrent"><a href="#qbtorrent" class="headerlink" title="qbtorrent"></a>qbtorrent</h2><p>qbtorrent下载之前讲过,现在就是需要查看webui,以及放开相应端口,设置后台运行.</p><p>操作跟刚才类似.</p><p>在Centos下下载qb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y qbittorrent-nox</span><br></pre></td></tr></table></figure><p>其他平台类似,当然也可以自己下载包编译安装.</p><p>下载安装后直接运行,默认端口8080</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qbittorrent-nox</span><br></pre></td></tr></table></figure><h3 id="开启后台运行服务"><a href="#开启后台运行服务" class="headerlink" title="开启后台运行服务"></a>开启后台运行服务</h3><blockquote><p>/usr/lib/systemd/system/目录下，您将找到一个qbittorrent-nox@.service文件。通过运行以下命令，使qbittorrent-nox在启动时自动启动。替换username为您的实际用户名。</p></blockquote><p>可以用whoami命令查看当前用户.</p><p>注意这里的username是您的用户名</p><p>然后开启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start qbittorrent-nox@username.service</span><br></pre></td></tr></table></figure><p>开机启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> qbittorrent-nox@username.service</span><br></pre></td></tr></table></figure><p>在那个目录下可以查看并配置这个服务</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000014.png" alt="image-20230123224137176"></p><p>然后更改端口</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/01image-20230123224224945.png" alt="image-20230123224224945"></p><p>后面设置安全组什么的跟上面类似.</p><p>打开这个端口即可. 默认username:admin  password:adminadmin</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000018.png" alt="image-20230123224318627"></p><p>用户界面</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000026.png" alt="image-20230123224417888" style="zoom:50%;" /></p><h3 id="更改web-ui密码"><a href="#更改web-ui密码" class="headerlink" title="更改web ui密码"></a>更改web ui密码</h3><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000030.png" alt="image-20230123224715884"></p><p>在tools-&gt;options-&gt;web ui中更改语言,验证信息.</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000033.png" alt="image-20230123224801908" style="zoom:67%;" /></p><h3 id="设置下载路径"><a href="#设置下载路径" class="headerlink" title="设置下载路径"></a>设置下载路径</h3><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000037.png" alt="image-20230123225109400" style="zoom:67%;" /></p><p>将下载的文件放在filebrowser暴露的文件中,然后最好设置完成后删除torrent节省空间.</p><h3 id="设置RSS"><a href="#设置RSS" class="headerlink" title="设置RSS"></a>设置RSS</h3><p>注意,截至现在时间qbittorrent版本是4.2.5,其Web UI界面没有RSS订阅功能.</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/01image-20230123234248037.png" alt="image-20230123234248037"></p><p>这里我们设置第三方UI增加RSS订阅功能,这样就不用手动加磁力链接了.</p><p>有两种方法,其中一种需要开启HTTPS,懒得去申请了.</p><p>第二种需要下载文件到服务器,下载Release文件并解压.</p><p><a href="https://github.com/CzBiX/qb-web">CzBiX/qb-web: A qBittorrent Web UI, write in TypeScript+Vue. (github.com)</a></p><p>将解压后的文件放在服务器某个位置.</p><p>在设置界面 web UI下文件路径放那个文件的路径,比如 /config/dist. dist就是解压后的文件夹.</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000045.png" alt="image-20230123234702168"></p><p>然后打开网页即可.</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000048.png" alt="image-20230123234752928" style="zoom:67%;" /></p><p>左侧点击RSS增加RSS功能即可.</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000051.png" alt="image-20230123234823176" style="zoom:67%;" /></p><p>可以结合之前我的文章查看一些RSS订阅源.比如利用蜜柑计划等等…</p><h3 id="部分优化"><a href="#部分优化" class="headerlink" title="部分优化"></a>部分优化</h3><h4 id="增加tracker"><a href="#增加tracker" class="headerlink" title="增加tracker"></a>增加tracker</h4><p>需要切换到原来的UI</p><p><img data-src="http://cdn.sekyoro.top/imgs/24/0120230124000102.png" alt="image-20230123235226961" style="zoom: 67%;" /></p><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><ol><li><a href="https://www.filebrowser.cn/">filebrowser 是一款非常优秀的文件管理工具，并且是跨平台。安装也非常简单，安装后就可以使用，同样使用也非常的简单。在linux环境中使用的比较多</a></li><li><a href="https://github.com/filebrowser/filebrowser">filebrowser/filebrowser: 📂 Web File Browser (github.com)</a></li><li><a href="https://www.cnblogs.com/webenh/p/13334303.html">File Browser 安装及使用 - WebEnh - 博客园 (cnblogs.com)</a></li><li><a href="https://www.cnblogs.com/a5idc/p/13784155.html">如何在CentOS 8 / RHEL 8服务器上安装qBittorrent - A5互联 - 博客园 (cnblogs.com)</a></li><li><a href="https://www.misterma.com/archives/902/">Linux 服务器安装 qBittorrent - Mr. Ma’s Blog (misterma.com)</a></li><li><a href="https://eatash.com/index.php/2021/09/02/qbittorrent这两个-第三方-webui-还不错-geekman/">qbittorrent这两个 第三方 webui 还不错-Geekman | 吃灰网 (eatash.com)</a></li><li><a href="https://www.jianshu.com/p/54a6bf9e5ebe">Docker版qBittorrent或qBittorrent WebUI使用RSS功能 - 简书 (jianshu.com)</a></li><li><a href="https://github.com/CzBiX/qb-web">CzBiX/qb-web: A qBittorrent Web UI, write in TypeScript+Vue. (github.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;利用闲置服务器通过BT SSR下载动漫,并通过filebrowser浏览下载.&lt;br&gt;</summary>
    
    
    
    
    <category term="torrent" scheme="https://www.sekyoro.top/tags/torrent/"/>
    
    <category term="Centos" scheme="https://www.sekyoro.top/tags/Centos/"/>
    
    <category term="filebrowser" scheme="https://www.sekyoro.top/tags/filebrowser/"/>
    
  </entry>
  
  <entry>
    <title>dart学习</title>
    <link href="https://www.sekyoro.top/2023/01/14/dart%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2023/01/14/dart%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-01-14T13:45:23.000Z</published>
    <updated>2023-01-14T14:20:48.628Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>基本就是看看文档,对比学习.注意重点.<br><span id="more"></span></p><blockquote><p>所有变量引用的都是 <strong>对象</strong>，每个对象都是一个 <strong>类</strong> 的实例。数字、函数以及 <code>null</code> 都是对象。除去 <code>null</code> 以外（如果你开启了 <a href="https://dart.cn/null-safety">空安全</a>）, 所有的类都继承于 <a href="https://api.dart.cn/stable/dart-core/Object-class.html"><code>Object</code></a> 类。</p></blockquote><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>Dart 是支持<strong>基于 mixin 继承机制</strong>的面向对象语言，所有对象都是一个类的实例，而除了 <code>Null</code> 以外的所有的类都继承自 <a href="https://api.dart.cn/stable/dart-core/Object-class.html"><code>Object</code></a> 类。 <strong>基于 mixin 的继承</strong> 意味着尽管每个类（<a href="https://dart.cn/null-safety/understanding-null-safety#top-and-bottom">top class</a> <code>Object?</code> 除外）都只有一个超类，一个类的代码可以在其它多个类继承中重复使用。 <a href="https://dart.cn/guides/language/language-tour#extension-methods">扩展方法</a> 是一种在不更改类或创建子类的情况下向类添加功能的方式</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;基本就是看看文档,对比学习.注意重点.&lt;br&gt;</summary>
    
    
    
    
    <category term="dart" scheme="https://www.sekyoro.top/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>python构建微信公众号文章发表控制台应用</title>
    <link href="https://www.sekyoro.top/2023/01/04/python%E6%9E%84%E5%BB%BA%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0%E5%8F%91%E8%A1%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%BA%94%E7%94%A8/"/>
    <id>https://www.sekyoro.top/2023/01/04/python%E6%9E%84%E5%BB%BA%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0%E5%8F%91%E8%A1%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%BA%94%E7%94%A8/</id>
    <published>2023-01-04T15:41:43.000Z</published>
    <updated>2023-01-08T08:57:32.788Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用Python构建控制台应用,简单一点.主目的是抓取某个网站图片然后上传到素材.<br><span id="more"></span></p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="获取access-token"><a href="#获取access-token" class="headerlink" title="获取access token"></a>获取access token</h3><p>首先需要知道自己的开发者AppID和开发者密码AppSecret.</p><p>然后获取access token</p><blockquote><p>https请求方式: GET <a href="https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET">https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</a></p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">是否必须</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">grant_type</td><td style="text-align:left">是</td><td style="text-align:left">获取access_token填写client_credential</td></tr><tr><td style="text-align:left">appid</td><td style="text-align:left">是</td><td style="text-align:left">第三方用户唯一凭证</td></tr><tr><td style="text-align:left">secret</td><td style="text-align:left">是</td><td style="text-align:left">第三方用户唯一凭证密钥，即appsecret</td></tr></tbody></table></div><p><strong>返回说明</strong></p><p>正常情况下，微信会返回下述 JSON 数据包给公众号：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;access_token&quot;</span>:<span class="string">&quot;ACCESS_TOKEN&quot;</span>,<span class="attr">&quot;expires_in&quot;</span>:<span class="number">7200</span>&#125;</span><br></pre></td></tr></table></figure><p>错误时微信会返回错误码等信息，JSON数据包示例如下（该示例为 AppID 无效错误）:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;errcode&quot;</span>:<span class="number">40013</span>,<span class="attr">&quot;errmsg&quot;</span>:<span class="string">&quot;invalid appid&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="素材管理"><a href="#素材管理" class="headerlink" title="素材管理"></a>素材管理</h2><h3 id="新增永久素材"><a href="#新增永久素材" class="headerlink" title="新增永久素材"></a>新增永久素材</h3><p>对于常用的素材，开发者可通过本接口上传到微信服务器，永久使用。新增的永久素材也可以在公众平台官网素材管理模块中查询管理。</p><p>通过 POST 表单来调用接口，表单 id 为media，包含需要上传的素材内容，有filename、filelength、content-type等信息。</p><p><strong>请注意：图片素材将进入公众平台官网素材管理模块中的默认分组。</strong>也就是说现在还不支持上传素材时创建分组.不过问题不大,到时候写文章时手动</p><blockquote><p>http请求方式: POST，需使用https <a href="https://api.weixin.qq.com/cgi-bin/material/add_material?access_token=ACCESS_TOKEN&amp;type=TYPE">https://api.weixin.qq.com/cgi-bin/material/add_material?access_token=ACCESS_TOKEN&amp;type=TYPE</a> </p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">是否必须</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">access_token</td><td style="text-align:left">是</td><td style="text-align:left">调用接口凭证</td></tr><tr><td style="text-align:left">type</td><td style="text-align:left">是</td><td style="text-align:left">媒体文件类型，分别有图片（image）、语音（voice）、视频（video）和缩略图（thumb）</td></tr><tr><td style="text-align:left">media</td><td style="text-align:left">是</td><td style="text-align:left">form-data中媒体文件标识，有filename、filelength、content-type等信息</td></tr></tbody></table></div><p>新增永久视频素材需特别注意</p><p>在上传视频素材时需要 POST 另一个表单，id为description，包含素材的描述信息，内容格式为JSON，格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>:VIDEO_TITLE,</span><br><span class="line">    <span class="attr">&quot;introduction&quot;</span>:INTRODUCTION</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">是否必须</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">title</td><td style="text-align:left">是</td><td style="text-align:left">视频素材的标题</td></tr><tr><td style="text-align:left">introduction</td><td style="text-align:left">是</td><td style="text-align:left">视频素材的描述</td></tr></tbody></table></div><p>返回说明</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;media_id&quot;</span>:MEDIA_ID,</span><br><span class="line">  <span class="attr">&quot;url&quot;</span>:URL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取素材总数"><a href="#获取素材总数" class="headerlink" title="获取素材总数"></a>获取素材总数</h3><p>永久素材的总数，也会计算公众平台官网素材管理中的素材 2.图片和图文消息素材（包括单图文和多图文）的总数上限为100000，其他素材的总数上限为1000 3.调用该接口需 https 协议</p><p>接口调用请求说明</p><blockquote><p>http请求方式: GET <a href="https://api.weixin.qq.com/cgi-bin/material/get_materialcount?access_token=ACCESS_TOKEN">https://api.weixin.qq.com/cgi-bin/material/get_materialcount?access_token=ACCESS_TOKEN</a></p></blockquote><h2 id="使用库"><a href="#使用库" class="headerlink" title="使用库"></a>使用库</h2><p>requests发送http请求,lxml解析html,tqdm显示进度条.</p><p>主要功能 爬取某个网站的所有图片,将某个文件夹下的图片全部上传.</p><p>一天随便写了写,比较菜还请见谅.</p><h3 id="用户类"><a href="#用户类" class="headerlink" title="用户类"></a>用户类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.access_token = <span class="literal">None</span></span><br><span class="line">        self.__appId = <span class="built_in">input</span>(<span class="string">&#x27;请输入您的appid:&#x27;</span>)</span><br><span class="line">        self.__appSecret = <span class="built_in">input</span>(<span class="string">&#x27;请输入您的appsecret:&#x27;</span>)</span><br><span class="line">        self.logintime = <span class="number">3</span></span><br><span class="line">        self.login()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> self.logintime:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                res = requests.get(</span><br><span class="line">                    <span class="string">f&quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=<span class="subst">&#123;self.__appId&#125;</span>&amp;secret=<span class="subst">&#123;self.__appSecret&#125;</span>&quot;</span>, )</span><br><span class="line">                <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">                    self.access_token = res.json()[<span class="string">&#x27;access_token&#x27;</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;输入错误!请尝试再次输入,还剩&#x27;</span> + self.logintime + <span class="string">&#x27;次机会&#x27;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;错误&#x27;</span>, res.json(), e)</span><br><span class="line">            self.logintime = self.logintime - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;退出&#x27;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里就是注册 没什么好说的 可以增加一个错误机会.</p><h3 id="获取图片类"><a href="#获取图片类" class="headerlink" title="获取图片类"></a>获取图片类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__url = <span class="literal">None</span></span><br><span class="line">        self.title = <span class="literal">None</span></span><br><span class="line">        self.__header = &#123;</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &#x27;</span></span><br><span class="line">                          <span class="string">&#x27;Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1462.54&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        self.filepathList = <span class="built_in">set</span>()</span><br><span class="line">        self.getUpdated()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getUpdated</span>(<span class="params">self</span>):</span></span><br><span class="line">        url = <span class="string">&#x27;https://www.pixivision.net/zh/c/illustration&#x27;</span></span><br><span class="line">        res = requests.get(url,headers=self.__header)</span><br><span class="line">        selector = etree.HTML(res.text)</span><br><span class="line">        lastUpdatedNumber = selector.xpath(<span class="string">&quot;//li[@class=&#x27;article-card-container&#x27;][1]/article/div[@class=&#x27;arc__thumbnail-container&#x27;]/a[1]/@href&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">        lastUpdatedNumber = lastUpdatedNumber.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;最新的图文号为&#x27;</span>,lastUpdatedNumber)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getarticle</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__url = <span class="built_in">input</span>(<span class="string">&#x27;输入网站链接(仅限pixvision:https://www.pixivision.net/zh/a/number):&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.__url.isnumeric():</span><br><span class="line">            self.__url = <span class="string">&#x27;https://www.pixivision.net/zh/a/&#x27;</span> + self.__url</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = requests.get(self.__url, headers=self.__header)</span><br><span class="line">        <span class="keyword">except</span> requests.exceptions.ProxyError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;网络出现问题&#x27;</span>, e)</span><br><span class="line">            sys.exit(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;出错&#x27;</span>, e)</span><br><span class="line">            sys.exit(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        selector = etree.HTML(res.text)</span><br><span class="line">        imgLinks = selector.xpath(</span><br><span class="line">            <span class="string">&quot;////div[@class=&#x27;_feature-article-body&#x27;]/div[@class=&#x27;article-item _feature-article-body__pixiv_illust&#x27;]//div[@class=&#x27;am__work__main&#x27;]//img/@src&quot;</span>)  <span class="comment"># 返回为一列表</span></span><br><span class="line">        self.title = selector.xpath(<span class="string">&quot;//h1[@class=&#x27;am__title&#x27;]/text()&quot;</span>)</span><br><span class="line">        self.download(imgLinks)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">self, imgLinks</span>):</span></span><br><span class="line">        filepath = <span class="built_in">input</span>(<span class="string">&#x27;输入下载的目录路径(默认F:\公众号\图片):&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(filepath):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;目录输入错误&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        absfilepath = filepath + <span class="string">f&#x27;\\<span class="subst">&#123;self.title&#125;</span>&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> os.path.exists(absfilepath):</span><br><span class="line">            <span class="comment"># 清空文件夹中的文件</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;清空文件夹中的文件&#x27;</span>)</span><br><span class="line">            del_list = os.listdir(absfilepath)</span><br><span class="line">            <span class="keyword">for</span> f <span class="keyword">in</span> del_list:</span><br><span class="line">                file_path = os.path.join(absfilepath, f)</span><br><span class="line">                <span class="keyword">if</span> os.path.isfile(file_path):</span><br><span class="line">                    os.remove(file_path)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;生成文件夹&#x27;</span>)</span><br><span class="line">            os.mkdir(absfilepath)</span><br><span class="line">        self.filepathList.add(absfilepath)</span><br><span class="line">        self.__header[<span class="string">&#x27;Referer&#x27;</span>] = <span class="string">&#x27;https://www.pixiv.net/&#x27;</span></span><br><span class="line">        pbar = tqdm.tqdm(imgLinks)</span><br><span class="line">        total = <span class="built_in">len</span>(imgLinks)</span><br><span class="line">        <span class="keyword">for</span> index, link <span class="keyword">in</span> <span class="built_in">enumerate</span>(pbar):</span><br><span class="line">            filename = link.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">            pbar.set_description(<span class="string">&quot;正在下载%s,&quot;</span> % filename)</span><br><span class="line">            pbar.set_postfix(&#123;<span class="string">&#x27;current&#x27;</span>: index + <span class="number">1</span>, <span class="string">&#x27;total&#x27;</span>: total&#125;)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                res = requests.get(link, headers=self.__header)</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(absfilepath + <span class="string">f&#x27;\\<span class="subst">&#123;filename&#125;</span>&#x27;</span>, <span class="string">&#x27;wb+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(res.content)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;需要设置代理&#x27;</span>, e)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里主要利用xpath解析获取到的网页.</p><h3 id="上传素材类"><a href="#上传素材类" class="headerlink" title="上传素材类"></a>上传素材类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">upload</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ACCESS_TOKEN, FILEPATHLIST</span>):</span></span><br><span class="line">        self.url = <span class="string">f&#x27;https://api.weixin.qq.com/cgi-bin/material/add_material?access_token=<span class="subst">&#123;ACCESS_TOKEN&#125;</span>&amp;type&#x27;</span> \</span><br><span class="line">                   <span class="string">f&#x27;=image&#x27;</span></span><br><span class="line">        self.filepath = FILEPATHLIST</span><br><span class="line">        self.uploadPics()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uploadPics</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(self.filepath, <span class="built_in">str</span>):</span><br><span class="line">            self.uploadPic(self.filepath)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> f <span class="keyword">in</span> self.filepath:</span><br><span class="line">                self.uploadPic(f)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uploadPic</span>(<span class="params">self, filepath</span>):</span></span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(filepath):</span><br><span class="line">            filelist = os.listdir(filepath)</span><br><span class="line">            total = <span class="built_in">len</span>(filelist)</span><br><span class="line">            pbar = tqdm.tqdm(filelist)</span><br><span class="line">            <span class="keyword">for</span> index, f <span class="keyword">in</span> <span class="built_in">enumerate</span>(pbar):</span><br><span class="line">                file_path = os.path.join(filepath, f)</span><br><span class="line">                <span class="keyword">if</span> os.path.isfile(file_path):</span><br><span class="line">                    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">                        files = &#123;</span><br><span class="line">                            <span class="string">&#x27;media&#x27;</span>: file</span><br><span class="line">                        &#125;</span><br><span class="line">                        res = requests.post(self.url, files=files)</span><br><span class="line">                        pbar.set_description(<span class="string">&#x27;正在上传&#x27;</span> + res.json()[<span class="string">&#x27;url&#x27;</span>])</span><br><span class="line">                        pbar.set_postfix(&#123;<span class="string">&#x27;current&#x27;</span>: index + <span class="number">1</span>, <span class="string">&#x27;total&#x27;</span>: total&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;文件夹错误&#x27;</span>, filepath)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意</strong>:requests上传FormData 需要利用files</p><h3 id="主文件"><a href="#主文件" class="headerlink" title="主文件"></a>主文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> user <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> getpic <span class="keyword">import</span> Article</span><br><span class="line"><span class="keyword">from</span> uploadpic <span class="keyword">import</span> upload</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    uploadDownloadpic = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">input</span>(<span class="string">&#x27;直接上传图片?0表示直接上传,1表示下载\n&#x27;</span>) == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        article = Article()</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            article.getarticle()</span><br><span class="line">            doContinue = <span class="built_in">input</span>(<span class="string">&#x27;是否继续下载图片？1表示继续,0表示退出\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> doContinue != <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        uploadDownloadpic = <span class="built_in">input</span>(<span class="string">&#x27;是否上传刚才的图片?1表示是,0表示自己选择\n&#x27;</span>)</span><br><span class="line">    u = User()</span><br><span class="line">    <span class="keyword">if</span> uploadDownloadpic == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        upload(u.access_token, article.filepathList)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        filepath = <span class="built_in">input</span>(<span class="string">&#x27;输入需要上传的文件目录(单个):\n&#x27;</span>)</span><br><span class="line">        upload(u.access_token, filepath)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>只是连续写了一会就累了,最近有点忙,利用这个工具上传素材到微信公众号方便水文章.最后可以利用pyinstaller打包</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用Python构建控制台应用,简单一点.主目的是抓取某个网站图片然后上传到素材.&lt;br&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://www.sekyoro.top/tags/python/"/>
    
    <category term="xpath" scheme="https://www.sekyoro.top/tags/xpath/"/>
    
    <category term="request" scheme="https://www.sekyoro.top/tags/request/"/>
    
    <category term="wechat" scheme="https://www.sekyoro.top/tags/wechat/"/>
    
  </entry>
  
  <entry>
    <title>构建微信快捷发布文章工具</title>
    <link href="https://www.sekyoro.top/2023/01/04/%E6%9E%84%E5%BB%BA%E5%BE%AE%E4%BF%A1%E5%BF%AB%E6%8D%B7%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0%E5%B7%A5%E5%85%B7/"/>
    <id>https://www.sekyoro.top/2023/01/04/%E6%9E%84%E5%BB%BA%E5%BE%AE%E4%BF%A1%E5%BF%AB%E6%8D%B7%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0%E5%B7%A5%E5%85%B7/</id>
    <published>2023-01-04T09:19:07.000Z</published>
    <updated>2023-01-05T05:26:04.945Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近在使用微信公众号写文章但是每天打开网页太麻烦,而且上传图片文章也麻烦.于是打算自己写个桌面程序.主要使用vue和electron,使用vite构建工具. 长期更新<br><span id="more"></span></p><h2 id="工具的选择"><a href="#工具的选择" class="headerlink" title="工具的选择"></a>工具的选择</h2><p><a href="https://www.bilibili.com/video/BV1FP4115739?p=36&amp;vd_source=177ef88aa6608bc3652c72d71b0aa098">036-Vue3+Electron19项目-1_哔哩哔哩_bilibili</a></p><p>这个视频用了vite构建,比较新.之前我还在用webpack以及vue2. Vite与vue3比较搭.</p><h3 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h3><p><a href="https://cn.vitejs.dev/guide/#scaffolding-your-first-vite-project">开始 | Vite 官方中文文档 (vitejs.dev)</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vite@latest</span><br></pre></td></tr></table></figure><p>值得注意的是Vite 需要 <a href="https://nodejs.org/en/">Node.js</a> 版本 14.18+，16+。然而，有些模板需要依赖更高的 Node 版本才能正常运行，当你的包管理器发出警告时，请注意升级你的 Node 版本.当然我这里windows环境下主要利用nvm切换版本到新的.</p><p><img data-src="http://cdn.sekyoro.top/imgs/04/0120230104172727.png" alt="image-20230104172713111"></p><blockquote><p>注意:你可能使用低版本node创建一开始没报错,但后面会出问题.同时使用nvm注意版本问题,我这里使用了旧版本nvm报错unexpected token ‘.’.需要升级nvm<a href="https://blog.csdn.net/weixin_45696837/article/details/127830020">nvm：npm ERR! Unexpected token ‘.‘_爱天蝎的双鱼的博客-CSDN博客</a></p></blockquote><p>主要利用Vite构建</p><h3 id="electron"><a href="#electron" class="headerlink" title="electron"></a>electron</h3><p><a href="https://www.electronjs.org/zh/docs/latest/">简介 | Electron (electronjs.org)</a></p><p>Electron是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入 <a href="https://www.chromium.org/">Chromium</a> 和 <a href="https://nodejs.org/">Node.js</a> 到 二进制的 Electron 允许您保持一个 JavaScript 代码代码库并创建 在Windows上运行的跨平台应用 macOS和Linux——不需要本地开发 经验</p><p>同时注意须要electron-builder打包</p><h3 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h3><p><a href="https://cn.vuejs.org/">Vue.js - 渐进式 JavaScript 框架 | Vue.js (vuejs.org)</a></p><p>Vue (发音为 /vjuː/，类似 <strong>view</strong>) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。</p><p>vite构建时即可选择使用vue.现在已经默认3.x</p><h3 id="Element-plus"><a href="#Element-plus" class="headerlink" title="Element plus"></a>Element plus</h3><p><a href="https://element-plus.org/zh-CN/guide/design.html"><a href="https://element-plus.org/zh-CN/">一个 Vue 3 UI 框架 | Element Plus (element-plus.org)</a></a></p><p>基于 Vue 3，面向设计师和开发者的组件库</p><h3 id="其他UI-Bootstrap5"><a href="#其他UI-Bootstrap5" class="headerlink" title="其他UI Bootstrap5"></a>其他UI Bootstrap5</h3><p>也可以使用Bootstrap</p><p>npm导入后需要引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;bootstrap/dist/css/bootstrap.min.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;bootstrap/dist/js/bootstrap.min.js&#x27;</span></span><br></pre></td></tr></table></figure><p><a href="https://v5.bootcss.com/">Bootstrap v5 中文文档 · Bootstrap 是全球最受欢迎的 HTML、CSS 和 JS 前端工具库。 | Bootstrap 中文网 (bootcss.com)</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i bootstrap@5.3.0-alpha1</span><br></pre></td></tr></table></figure><h3 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h3><p><a href="https://jrsoftware.org/isinfo.php">Inno Setup (jrsoftware.org)</a></p><p>用于把生成的exe打包发布,这样就不是光溜溜的一个exe了.</p><p><a href="https://zhuanlan.zhihu.com/p/168690637">Inno Setup使用总结 - 知乎 (zhihu.com)</a></p><h3 id="热重载"><a href="#热重载" class="headerlink" title="热重载"></a>热重载</h3><p><a href="https://github.com/Kuari/Blog/issues/53">Vite+Electron快速构建一个VUE3桌面应用(二)——动态模块热重载 · Issue #53 · Kuari/Blog (github.com)</a></p><p>为了使vite和electron正常运行，需要先运行vite，使得其开发服务器的url可以正常访问，然后再开启electron去加载url。</p><p>此处需要安装两个库：</p><ul><li><p><strong>concurrently</strong>：阻塞运行多个命令，<code>-k</code>参数用来清除其它已经存在或者挂掉的进程</p></li><li><p><strong>wait-on</strong>：等待资源，此处用来等待url可访问</p></li><li><p>接着更新文件<code>package.json</code>，<code>scripts</code>新增两条命令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;electron&quot;</span>: <span class="string">&quot;wait-on tcp:5173 &amp;&amp; electron .&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;concurrently -k \&quot;yarn dev\&quot; \&quot;yarn electron\&quot;&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><p>start命令就是为了运行vue项目然后等其打开后运行electron.在开发时electron需要加载这个url.</p><p>在目录下创建main.js   加载5173端口 这个端口就是vite打开的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; app, BrowserWindow &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createWindow = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> win = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">800</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">600</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// win.loadFile(&#x27;index.html&#x27;)</span></span><br><span class="line">  win.loadURL(<span class="string">&#x27;http://localhost:5173&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.whenReady().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  createWindow()</span><br><span class="line"></span><br><span class="line">  app.on(<span class="string">&#x27;activate&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (BrowserWindow.getAllWindows().length === <span class="number">0</span>) createWindow()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">&#x27;window-all-closed&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.platform !== <span class="string">&#x27;darwin&#x27;</span>) app.quit()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最后运行npm run start</p><p><img data-src="http://cdn.sekyoro.top/imgs/04/0120230104222629.png" alt="image-20230104222628604" style="zoom:67%;" /></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://blog.csdn.net/lw001x/article/details/127589755?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~ESLANDING~default-6-127589755-blog-128000357.pc_relevant_landingrelevant&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~ESLANDING~default-6-127589755-blog-128000357.pc_relevant_landingrelevant&amp;utm_relevant_index=7">Vite+Vue+Electron环境搭建_⑥②的博客-CSDN博客_electron vite vue</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在使用微信公众号写文章但是每天打开网页太麻烦,而且上传图片文章也麻烦.于是打算自己写个桌面程序.主要使用vue和electron,使用vite构建工具. 长期更新&lt;br&gt;</summary>
    
    
    
    
    <category term="vue" scheme="https://www.sekyoro.top/tags/vue/"/>
    
    <category term="wechat" scheme="https://www.sekyoro.top/tags/wechat/"/>
    
    <category term="vite" scheme="https://www.sekyoro.top/tags/vite/"/>
    
    <category term="electron" scheme="https://www.sekyoro.top/tags/electron/"/>
    
    <category term="Bootstrap5" scheme="https://www.sekyoro.top/tags/Bootstrap5/"/>
    
  </entry>
  
  <entry>
    <title>美化github首页</title>
    <link href="https://www.sekyoro.top/2023/01/01/%E7%BE%8E%E5%8C%96github%E9%A6%96%E9%A1%B5/"/>
    <id>https://www.sekyoro.top/2023/01/01/%E7%BE%8E%E5%8C%96github%E9%A6%96%E9%A1%B5/</id>
    <published>2023-01-01T04:48:06.000Z</published>
    <updated>2023-01-01T08:58:49.532Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>新年到了,新年新气象.美化一下github首页.<br><span id="more"></span></p><p>在几年前Github推出了美化profile的功能,到现在我来体验一下.</p><p>最后成果,比较简单方便.</p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0120230101163704.png" alt="image-20230101163704294" style="zoom:50%;" /></p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0120230101163735.png" alt="image-20230101163735498" style="zoom:50%;" /></p><p><img data-src="http://cdn.sekyoro.top/imgs/01/0120230101163806.png" alt="image-20230101163806235" style="zoom:50%;" /></p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>主要流程比较简单,创建一个仓库,仓库的命名需要与自己Github用户名一致.</p><p>这里因为我创建过了所以提示重命名.然后这个仓库需要一个readme.md文件,就是用这个markdown文件来美化主页.重要的是其中显示个人数据的接口.</p><p>这里推荐两个模板生成器,可以看参考资料的前两个.</p><h3 id="github-stats"><a href="#github-stats" class="headerlink" title="github stats"></a>github stats</h3><p>接下来是github stats<a href="https://github.com/anuraghazra/github-readme-stats/blob/master/docs/readme_cn.md">github-readme-stats/readme_cn.md at master · anuraghazra/github-readme-stats</a></p><p><img data-src="https://camo.githubusercontent.com/8fd2570f103d1aae8a4d8970535274ae19c2ee62587d8868d618be37001263d0/68747470733a2f2f7265732e636c6f7564696e6172792e636f6d2f616e7572616768617a72612f696d6167652f75706c6f61642f76313539353137343533362f6772732d7468656d65735f6c34796e6a612e706e67" alt="GitHub Readme Stat Themes" style="zoom: 33%;" /></p><blockquote><p>你可以通过使用 URL 参数的方式，为你的 <code>Stats Card</code> 或 <code>Repo Card</code> 自定义样式。</p><p>常用选项：</p><ul><li><code>title_color</code> - 卡片标题颜色 <em>（十六进制色码）</em></li><li><code>text_color</code> - 内容文本颜色 <em>（十六进制色码）</em></li><li><code>icon_color</code> - 图标颜色（如果可用）<em>（十六进制色码）</em></li><li><code>bg_color</code> - 卡片背景颜色 <em>（十六进制色码）</em> <strong>或者</strong> 以 <em>angle,start,end</em> 的形式渐变</li><li><code>hide_border</code> - 隐藏卡的边框 <em>(布尔值)</em></li><li><code>theme</code> - 主题名称，从<a href="https://github.com/anuraghazra/github-readme-stats/blob/master/themes/README.md">所有可用主题</a>中选择</li><li><code>cache_seconds</code> - 手动设置缓存头 <em>（最小值: 1800，最大值: 86400）</em></li><li><code>locale</code> - 在卡片中设置语言 <em>(例如 cn, de, es, 等等)</em></li></ul></blockquote><p>同时也有个人常用语言统计</p><p>将此代码复制粘贴到您的 <code>README.md</code> 文件中，并修改链接。</p><p>端点: <code>api/top-langs?username=anuraghazra</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![Top Langs</span>](<span class="link">https://github-readme-stats.vercel.app/api/top-langs/?username=anuraghazra</span>)](<span class="link">https://github.com/anuraghazra/github-readme-stats</span>)</span><br></pre></td></tr></table></figure><h3 id="github-stats-1"><a href="#github-stats-1" class="headerlink" title="github stats"></a>github stats</h3><p>然后是个人信息统计,可以利用<a href="https://metrics.lecoq.io/">Metrics (lecoq.io)</a>,只需要输入Github用户名生成个人metrics.</p><p><img data-src="https://camo.githubusercontent.com/b9deb4987189bc5222f2b2fad0c0b461a171abfcaa31ac38006df8db466e4d2f/68747470733a2f2f6d6574726963732e6c65636f712e696f2f64726f776e696e672d696e2d636f6465733f74656d706c6174653d636c617373696326626173653d6865616465722532432532306163746976697479253243253230636f6d6d756e6974792532432532307265706f7369746f726965732532432532306d6574616461746126626173652e696e64657074683d66616c736526626173652e6869726561626c653d66616c736526626173652e736b69703d66616c736526636f6e6669672e74696d657a6f6e653d417369612532465368616e67686169" alt="img" style="zoom:50%;" /></p><h3 id="github-activity-graph"><a href="#github-activity-graph" class="headerlink" title="github activity graph"></a>github activity graph</h3><p>github活动图 也就是显示提交记录的.<a href="https://github.com/Ashutosh00710/github-readme-activity-graph/">Ashutosh00710/github-readme-activity-graph: A dynamically generated activity graph to show your GitHub activities of last 31 days.</a></p><p><img data-src="https://github.com/Ashutosh00710/github-readme-activity-graph/raw/main/asset/default.svg" alt="graph" style="zoom: 33%;" /></p><p>类似的将下面markdown中username改为自己github用户名.    </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![Ashutosh&#x27;s github activity graph</span>](<span class="link">https://github-readme-activity-graph.cyclic.app/graph?username=Ashutosh00710&amp;theme=dracula</span>)](<span class="link">https://github.com/ashutosh00710/github-readme-activity-graph</span>)</span><br></pre></td></tr></table></figure><h3 id="github-streak"><a href="#github-streak" class="headerlink" title="github streak"></a>github streak</h3><p>显示个人github成就</p><p><a href="https://github.com/DenverCoder1/github-readme-streak-stats">DenverCoder1/github-readme-streak-stats: 🔥 Stay motivated and show off your contribution streak! 🌟 Display your total contributions, current streak, and longest streak on your GitHub profile README</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![GitHub Streak</span>](<span class="link">https://streak-stats.demolab.com/?user=DenverCoder1</span>)](<span class="link">https://git.io/streak-stats</span>)</span><br></pre></td></tr></table></figure><h3 id="Shields（GitHub-徽章）"><a href="#Shields（GitHub-徽章）" class="headerlink" title="Shields（GitHub 徽章）"></a>Shields（GitHub 徽章）</h3><p><img data-src="http://cdn.sekyoro.top/imgs/01/0120230101165219.png" alt="image-20230101165219583" style="zoom:50%;" /></p><p>主要使用<a href="https://shields.io/这个网站生成图标比较简单,可以在外面包裹一个超链接用于跳转">https://shields.io/这个网站生成图标比较简单,可以在外面包裹一个超链接用于跳转</a>.</p><h3 id="Visitor-Badge（GitHub-访客徽章）"><a href="#Visitor-Badge（GitHub-访客徽章）" class="headerlink" title="Visitor Badge（GitHub 访客徽章）"></a>Visitor Badge（GitHub 访客徽章）</h3><p><img data-src="http://cdn.sekyoro.top/imgs/01/01image-20230101165431536.png" alt="image-20230101165431536" style="zoom: 67%;" /></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">visitors</span>](<span class="link">https://visitor-badge.glitch.me/badge?page_id=page.id&amp;left_color=green&amp;right_color=red</span>)</span><br></pre></td></tr></table></figure><p>将page_id替换为用户名即可.</p><p>最后可以看一下我的Github主页<a href="https://github.com/drowning-in-codes">drowning-in-codes (martyr) (github.com)</a>参观,模板生成的也比较简便.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://profilinator.rishav.dev/">Github Profilinator - GitHub Profile README Generator (rishav.dev)</a> 快捷的模板生成器</li><li><a href="https://rahuldkjain.github.io/gh-profile-readme-generator/">GitHub Profile Readme Generator | GitHub Profile Readme Generator (rahuldkjain.github.io)</a> 另一个快捷的模板生成器</li><li><a href="https://zhuanlan.zhihu.com/p/454597068">Github 首页美化教程（一）：打造个性化的GitHub首页</a> 其他教程</li><li><a href="https://sumygg.com/2021/04/25/beautify-your-github-profile-readme/">美化你的Github个人信息页 | SumyBlog (sumygg.com)</a></li><li><a href="https://shields.io/">Shields.io: Quality metadata badges for open source projects</a> 图标</li><li><a href="https://github.com/abhisheknaiidu/awesome-github-profile-readme">abhisheknaiidu/awesome-github-profile-readme: 😎 A curated list of awesome GitHub Profile READMEs 📝</a> 优美的github profile案例</li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;新年到了,新年新气象.美化一下github首页.&lt;br&gt;</summary>
    
    
    
    
    <category term="github" scheme="https://www.sekyoro.top/tags/github/"/>
    
    <category term="github profile" scheme="https://www.sekyoro.top/tags/github-profile/"/>
    
  </entry>
  
  <entry>
    <title>Flutter学习</title>
    <link href="https://www.sekyoro.top/2022/12/28/Flutter%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2022/12/28/Flutter%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-12-28T08:16:25.000Z</published>
    <updated>2023-01-01T08:14:43.104Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Flutter学习,主要用于移动端,展示的应用,跨平台.长期更新<br><span id="more"></span></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Flutter主要是跨平台移动端UI框架,我使用它主要也是不错的UI设计以及跨平台的特性.至于原生开发其实也是不错的,各有所长吧.</p><p>开发工具是Android Studio或者vscode.至少就我现在的开发体验来说两者差别不大,前者功能更多.</p><p><strong>Android Studio的一些重要快捷键</strong>     </p><p><img data-src="http://cdn.sekyoro.top/imgs/28/1220221228215414.png" alt="image-20221228215320830" style="zoom:67%;" /></p><p><img data-src="http://cdn.sekyoro.top/imgs/28/1220221228215449.png" alt="image-20221228215449009"></p><p><img data-src="http://cdn.sekyoro.top/imgs/28/1220221228215521.png" alt="image-20221228215521331" style="zoom:67%;" /></p><h3 id="代码辅助和快速修复"><a href="#代码辅助和快速修复" class="headerlink" title="代码辅助和快速修复"></a>代码辅助和快速修复</h3><p>代码辅助功能是特定代码标识符相关的代码修改。当光标放在 Flutter widget 上时，黄色灯泡图标会指示可用的修改，可以通过点击灯泡进行修改，或使用键盘快捷键（在 Linux 和 Windows 上使用 <code>Alt</code>+<code>Enter</code>，在 macOS 上使用 <code>Option</code>+<code>Return</code>）</p><h4 id="Widget-嵌套辅助"><a href="#Widget-嵌套辅助" class="headerlink" title="Widget 嵌套辅助"></a>Widget 嵌套辅助</h4><p>当你有一个 widget 需要嵌套在其他 widget 时，可以使用该功能。例如，需要将 widget 嵌套在 <code>Row</code> 或 <code>Column</code> 中。</p><h4 id="Widget-列表嵌套辅助"><a href="#Widget-列表嵌套辅助" class="headerlink" title="Widget 列表嵌套辅助"></a>Widget 列表嵌套辅助</h4><p>和上面的辅助类似，但它嵌套的是一个 widget 的列表，而不是单个的 widget。</p><h4 id="child-和-children-转换辅助"><a href="#child-和-children-转换辅助" class="headerlink" title="child 和 children 转换辅助"></a>child 和 children 转换辅助</h4><p>将 child 转换成 children，并且把参数值写进一个 list。</p><p>Flutter 插件包含了以下模板：</p><ul><li>前缀 <code>stless</code>：创建一个 <code>StatelessWidget</code> 的子类。</li><li>前缀 <code>stful</code>：创建一个 <code>StatefulWidget</code> 的子类，并关联 State 子类。</li><li>前缀 <code>stanim</code>：创建一个 <code>StatefulWidget</code> 的子类，并关联 State 子类，包含一个 <code>AnimationController</code> 的初始化字段</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>不同系统不同配置可能有不同情况. 我这边首先需要在管理员模式下使用adb devices或者类似命令使得能访问adb.然后选择该模拟器,使用flutter run开启应用.</p><p><img data-src="http://cdn.sekyoro.top/imgs/28/1220221228222209.png" alt="image-20221228222209219" style="zoom:50%;" /></p><h3 id="vscode重要快捷键"><a href="#vscode重要快捷键" class="headerlink" title="vscode重要快捷键"></a>vscode重要快捷键</h3><p><img data-src="http://cdn.sekyoro.top/imgs/28/1220221228223036.png" alt="image-20221228223036046"></p><p>另外Ctrl+shift+\可以跳转到括号另一边.</p><h3 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">body: Center(</span><br><span class="line">          <span class="comment">// ignore: prefer_const_constructors</span></span><br><span class="line">          child: Image(</span><br><span class="line">        image: <span class="keyword">const</span> AssetImage(<span class="string">&#x27;assets/4.jpg&#x27;</span>),</span><br><span class="line">              <span class="comment">//NetworkImage(&#x27;&#x27;)</span></span><br><span class="line">        <span class="comment">// fit: BoxFit.cover,</span></span><br><span class="line">      )),</span><br></pre></td></tr></table></figure><h3 id="发布app"><a href="#发布app" class="headerlink" title="发布app"></a>发布app</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -v -keystore  my-release-key.keystore -<span class="built_in">alias</span> my-key-alias -keyalg RSA -keysize 2048 -validity 10000</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;Flutter学习,主要用于移动端,展示的应用,跨平台.长期更新&lt;br&gt;</summary>
    
    
    
    
    <category term="Flutter" scheme="https://www.sekyoro.top/tags/Flutter/"/>
    
    <category term="Tutorial" scheme="https://www.sekyoro.top/tags/Tutorial/"/>
    
  </entry>
  
  <entry>
    <title>css中的flex和grid布局</title>
    <link href="https://www.sekyoro.top/2022/12/27/css%E4%B8%AD%E7%9A%84flex%E5%92%8Cgrid%E5%B8%83%E5%B1%80/"/>
    <id>https://www.sekyoro.top/2022/12/27/css%E4%B8%AD%E7%9A%84flex%E5%92%8Cgrid%E5%B8%83%E5%B1%80/</id>
    <published>2022-12-27T08:32:10.000Z</published>
    <updated>2022-12-27T09:05:13.067Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>css中的布局flex和grid现在已经比较常用了.这里简单介绍一下<br><span id="more"></span></p><h2 id="Grid布局"><a href="#Grid布局" class="headerlink" title="Grid布局"></a>Grid布局</h2><p>grid布局,即网格布局.</p><p>采用网格布局的区域，称为”容器”（container）。容器内部采用网格定位的子元素，称为”项目”（item）。容器里面的水平区域称为”行”（row），垂直区域称为”列”（column）。</p><p><img data-src="https://www.wangbase.com/blogimg/asset/201903/1_bg2019032502.png" alt="img" style="zoom:50%;" /></p><p><strong>单元格</strong>:行和列的交叉区域，称为”单元格”（cell）。</p><p>正常情况下，<code>n</code>行和<code>m</code>列会产生<code>n x m</code>个单元格。比如，3行3列会产生9个单元格。</p><p><strong>网格线</strong>:划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。</p><p>正常情况下，<code>n</code>行有<code>n + 1</code>根水平网格线，<code>m</code>列有<code>m + 1</code>根垂直网格线，比如三行就有四根水平网格线。</p><p>Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">   <span class="attribute">display</span>: grid;</span><br><span class="line">   <span class="comment">/* grid-template-columns: 100px 100px 100px; */</span></span><br><span class="line">   <span class="comment">/* grid-template-columns: repeat(3,33.33%); */</span></span><br><span class="line">   <span class="comment">/* grid-template-columns: repeat(2,100px 20px 80px); */</span></span><br><span class="line">   <span class="comment">/* grid-template-columns: repeat(auto-fill,100px); */</span></span><br><span class="line">   grid-template-<span class="attribute">columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">   grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">   row-gap: <span class="number">20px</span>;</span><br><span class="line">   <span class="comment">/* column-gap: 20px; */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* grid-template-areas: ; */</span></span><br><span class="line">   <span class="comment">/* grid-auto-flow: row; */</span></span><br><span class="line"></span><br><span class="line">   justify-items: center;</span><br><span class="line">   <span class="attribute">align-items</span>: center;</span><br><span class="line"></span><br><span class="line">   <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">   <span class="attribute">align-content</span>: end;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="grid-template-columns-属性，-grid-template-rows-属性"><a href="#grid-template-columns-属性，-grid-template-rows-属性" class="headerlink" title="grid-template-columns 属性， grid-template-rows 属性"></a>grid-template-columns 属性， grid-template-rows 属性</h3><p>容器指定了网格布局以后，接着就要划分行和列。<code>grid-template-columns</code>属性定义每一列的列宽，<code>grid-template-rows</code>属性定义每一行的行高。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-</span><br></pre></td></tr></table></figure><p>为了方便表示比例关系，网格布局提供了<code>fr</code>关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为<code>1fr</code>和<code>2fr</code>，就表示后者是前者的两倍。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="grid-row-gap-属性，-grid-column-gap-属性，-grid-gap-属性"><a href="#grid-row-gap-属性，-grid-column-gap-属性，-grid-gap-属性" class="headerlink" title="grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性"></a>grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性</h3><p><code>grid-row-gap</code>属性设置行与行的间隔（行间距），<code>grid-column-gap</code>属性设置列与列的间隔（列间距）。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  grid-row-gap: <span class="number">20px</span>;</span><br><span class="line">  grid-<span class="attribute">column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="justify-items-属性，-align-items-属性，-place-items-属性"><a href="#justify-items-属性，-align-items-属性，-place-items-属性" class="headerlink" title="justify-items 属性， align-items 属性， place-items 属性"></a>justify-items 属性， align-items 属性， place-items 属性</h3><p><code>justify-items</code>属性设置单元格内容的水平位置（左中右），<code>align-items</code>属性设置单元格内容的垂直位置（上中下）。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  justify-items: start | end | center | stretch;</span><br><span class="line">  <span class="attribute">align-items</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="justify-content-属性，-align-content-属性，-place-content-属性"><a href="#justify-content-属性，-align-content-属性，-place-content-属性" class="headerlink" title="justify-content 属性， align-content 属性， place-content 属性"></a>justify-content 属性， align-content 属性， place-content 属性</h3><p><code>justify-content</code>属性是整个内容区域在容器里面的水平位置（左中右），<code>align-content</code>属性是整个内容区域的垂直位置（上中下）。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">  <span class="attribute">align-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以<code>justify-content</code>属性为例，<code>align-content</code>属性的图完全一样，只是将水平方向改成垂直方向。）</p><h3 id="grid-column-start-属性，-grid-column-end-属性，-grid-row-start-属性，-grid-row-end-属性"><a href="#grid-column-start-属性，-grid-column-end-属性，-grid-row-start-属性，-grid-row-end-属性" class="headerlink" title="grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性"></a>grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性</h3><p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p><blockquote><ul><li><code>grid-column-start</code>属性：左边框所在的垂直网格线</li><li><code>grid-column-end</code>属性：右边框所在的垂直网格线</li><li><code>grid-row-start</code>属性：上边框所在的水平网格线</li><li><code>grid-row-end</code>属性：下边框所在的水平网格线</li></ul></blockquote><p><code>grid-area</code>属性指定项目放在哪一个区域。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  grid-area: e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="justify-self-属性，-align-self-属性，-place-self-属性"><a href="#justify-self-属性，-align-self-属性，-place-self-属性" class="headerlink" title="justify-self 属性， align-self 属性， place-self 属性"></a>justify-self 属性， align-self 属性， place-self 属性</h3><p><code>justify-self</code>属性设置单元格内容的水平位置（左中右），跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。</p><p><code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  justify-self: start | end | center | stretch;</span><br><span class="line">  <span class="attribute">align-self</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><p>以下6个属性设置在容器上。</p><h3 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h3><blockquote><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul></blockquote><h3 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h3><p>以下6个属性设置在项目上。</p><blockquote><ul><li><code>order</code></li><li><code>flex-grow</code></li><li><code>flex-shrink</code></li><li><code>flex-basis</code></li><li><code>flex</code></li><li><code>align-self</code></li></ul></blockquote><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</p><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小</p><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://learncssgrid.com/">Learn CSS Grid - A Guide to Learning CSS Grid | Jonathan Suh</a></li><li><a href="http://ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">CSS Grid 网格布局教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></li><li><a href="http://ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程：语法篇 - 阮一峰的网络日志 (ruanyifeng.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;css中的布局flex和grid现在已经比较常用了.这里简单介绍一下&lt;br&gt;</summary>
    
    
    
    
    <category term="css" scheme="https://www.sekyoro.top/tags/css/"/>
    
    <category term="flex" scheme="https://www.sekyoro.top/tags/flex/"/>
    
    <category term="grid" scheme="https://www.sekyoro.top/tags/grid/"/>
    
  </entry>
  
  <entry>
    <title>pr剪辑学习</title>
    <link href="https://www.sekyoro.top/2022/12/26/pr%E5%89%AA%E8%BE%91%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2022/12/26/pr%E5%89%AA%E8%BE%91%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-12-26T03:07:03.000Z</published>
    <updated>2023-02-03T14:59:26.293Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>短视频和一般的视频剪辑挺火的,如果是简单的短视频用剪映或者必剪就行了.但是为了体现专业(zhuang bi)性,我这里学学pr.可能要花几周时间.<br><span id="more"></span></p><h2 id="界面布局"><a href="#界面布局" class="headerlink" title="界面布局"></a>界面布局</h2><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>工作区:下面每一个都是一个工作区,每个工作区有很多面板组,每个面板组中又有很多面板.</p><p>可以自己修改工作区的内容又可以自己创建自己的工作区.</p><p><img data-src="http://cdn.sekyoro.top/imgs/26/12image-20221226111354984.png" alt="image-20221226111354984" style="zoom:80%;" /></p><h2 id="新建序列"><a href="#新建序列" class="headerlink" title="新建序列"></a>新建序列</h2><p>项目面板右下角新建项 序列</p><p>进行序列设置</p><p><img data-src="http://cdn.sekyoro.top/imgs/10/0120230110175918.png" alt="image-20230110175721067" style="zoom:50%;" /></p><p>选择序列设置 模式自定义</p><p><img data-src="http://cdn.sekyoro.top/imgs/10/0120230110180110.png" alt="image-20230110180110474" style="zoom:50%;" /></p><h3 id="调整时间轴"><a href="#调整时间轴" class="headerlink" title="调整时间轴"></a>调整时间轴</h3><p>alt+鼠标滚轮  鼠标滚轮  \键  </p><p>时间轴轨道 轨道上的图像折叠</p><p><img data-src="http://cdn.sekyoro.top/imgs/10/0120230110181120.png" alt="image-20230110181119820"></p><p><img data-src="http://cdn.sekyoro.top/imgs/11/01image-20230111110359012.png" alt="image-20230111110359012"></p><ol><li>嵌套图标对齐工具  </li><li>视频与音频的链接   </li><li>添加标记(m)  在时间轨道上   在视频或音频上</li></ol><p><img data-src="http://cdn.sekyoro.top/imgs/11/01image-20230111110857150.png" alt="image-20230111110857150"></p><p>左侧 视频或音频拖进来时有视频还是yinpin</p><p>右侧 决定视频优先级</p><p>选择工具 V   提到工具 C</p><h3 id="效果空间"><a href="#效果空间" class="headerlink" title="效果空间"></a>效果空间</h3><p>运动  不透明度 时间映射 </p><p>批量添加过渡效果 设置过渡效果为常用过渡效果  ctrl+d</p><p>复制素材 alt拖动</p><p><img data-src="http://cdn.sekyoro.top/imgs/11/01image-20230111113253991.png" alt="image-20230111113253991"></p><h3 id="电子相册制作"><a href="#电子相册制作" class="headerlink" title="电子相册制作"></a>电子相册制作</h3><p>复制素材拖到上一个轨道,缩放70%</p><h4 id="添加径向阴影"><a href="#添加径向阴影" class="headerlink" title="添加径向阴影"></a>添加径向阴影</h4><p><img data-src="http://cdn.sekyoro.top/imgs/11/0120230111114026.png" alt="image-20230111114026246"></p><h4 id="添加投影"><a href="#添加投影" class="headerlink" title="添加投影"></a>添加投影</h4><p><img data-src="http://cdn.sekyoro.top/imgs/11/0120230111114046.png" alt="image-20230111114046133"></p><h4 id="添加模糊"><a href="#添加模糊" class="headerlink" title="添加模糊"></a>添加模糊</h4><p>在下一个轨道图片上加模糊</p><p><img data-src="http://cdn.sekyoro.top/imgs/11/0120230111113934.png" alt="image-20230111113933985"></p><h4 id="批量复制"><a href="#批量复制" class="headerlink" title="批量复制"></a>批量复制</h4><p>复制某个素材,选中其他素材粘贴属性</p><p>或者使用快捷键ctrl+alt+v 粘贴属性快捷键</p><p>将上轨道改为立方体旋转</p><h4 id="光影"><a href="#光影" class="headerlink" title="光影"></a>光影</h4><p>加上光影素材,混合模式改为滤色</p><h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><p>H.264即可</p><h3 id="电影混剪"><a href="#电影混剪" class="headerlink" title="电影混剪"></a>电影混剪</h3><h4 id="加上字幕遮罩"><a href="#加上字幕遮罩" class="headerlink" title="加上字幕遮罩"></a>加上字幕遮罩</h4><p>新建项 字幕遮罩  效果加上裁剪</p><p>上下都加上</p><h4 id="配上字幕"><a href="#配上字幕" class="headerlink" title="配上字幕"></a>配上字幕</h4><p>可以利用Arctime pro</p><h4 id="去除字幕"><a href="#去除字幕" class="headerlink" title="去除字幕"></a>去除字幕</h4><p>高斯模糊 蒙版</p><p>中间值 蒙版</p><h4 id="定格动画"><a href="#定格动画" class="headerlink" title="定格动画"></a>定格动画</h4><p>五帧或十帧</p><h2 id="剪辑工具"><a href="#剪辑工具" class="headerlink" title="剪辑工具"></a>剪辑工具</h2><p>镜头剪辑、排列以及各种调节方法</p><p><img data-src="http://cdn.sekyoro.top/imgs/26/12image-20221226210816710.png" alt="image-20221226210816710"></p><h3 id="抠图"><a href="#抠图" class="headerlink" title="抠图"></a>抠图</h3><p>超级键,但是有时候超级键扣不干净.可以利用颜色键和裁剪</p><p>最后加上超级键,加上基值,抑制和柔化.</p><p><img data-src="http://cdn.sekyoro.top/imgs/16/0120230116185035.png" alt="image-20230116185017552"  /></p><h4 id="人物调色"><a href="#人物调色" class="headerlink" title="人物调色"></a>人物调色</h4><p>让人物脸上光更均匀</p><p>新建调整图层,在Lumetric颜色</p><h4 id="转场过度"><a href="#转场过度" class="headerlink" title="转场过度"></a>转场过度</h4><p>filmImpact zoom blur</p><h3 id="直接花字法"><a href="#直接花字法" class="headerlink" title="直接花字法"></a>直接花字法</h3><h3 id="图片花字法"><a href="#图片花字法" class="headerlink" title="图片花字法"></a>图片花字法</h3><h3 id="表情贴图方法"><a href="#表情贴图方法" class="headerlink" title="表情贴图方法"></a>表情贴图方法</h3><p>追踪法</p><h3 id="特效素材法"><a href="#特效素材法" class="headerlink" title="特效素材法"></a>特效素材法</h3><p>添加帧定格</p><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ol><li>q w剪辑  ctrl+k剪辑 shift+delete波纹剪辑</li><li>i o出入标记</li></ol><h4 id="转场合集"><a href="#转场合集" class="headerlink" title="转场合集"></a>转场合集</h4><h5 id="回忆快闪"><a href="#回忆快闪" class="headerlink" title="回忆快闪"></a>回忆快闪</h5><ol><li>变换 关键帧缩放 从大到小  缓入缓出</li><li>快门角度调大 </li><li>不透明度关键帧 </li></ol><h5 id="闪烁抽帧"><a href="#闪烁抽帧" class="headerlink" title="闪烁抽帧"></a>闪烁抽帧</h5><ol><li>将多段相同素材嵌套</li><li>慢动作效果</li><li><img data-src="http://cdn.sekyoro.top/imgs/31/0120230131000810.png" alt="image-20230130232754138"></li><li>alt运动视频设置,在起始和结尾处设置输出控制速度例如50%,中间可以设置10%</li><li>闪烁效果</li></ol><p>卡点弹边</p><ol><li>alt向上复制一份</li><li>查找边缘效果 色彩效果 混合模式颜色减淡</li><li>变换效果 缩放变大  关键帧</li></ol><h3 id="PR效果合集"><a href="#PR效果合集" class="headerlink" title="PR效果合集"></a>PR效果合集</h3><h4 id="眨眼效果"><a href="#眨眼效果" class="headerlink" title="眨眼效果"></a>眨眼效果</h4><ol><li><p>添加黑场视频 网格,球面化效果</p></li><li><p>调整边框加关键帧</p><p><img data-src="http://cdn.sekyoro.top/imgs/31/0120230131211816.png" alt="image-20230131211812320" style="zoom:67%;" /></p></li><li><p>快速模糊效果 关键帧</p></li><li><p>不透明度 关键帧</p></li></ol><h4 id="弹性缩放"><a href="#弹性缩放" class="headerlink" title="弹性缩放"></a>弹性缩放</h4><ol><li>新建图层 变换效果加新建图层</li><li>变换 缩放50</li><li>镜像 反射中心</li></ol><h4 id="拍照效果"><a href="#拍照效果" class="headerlink" title="拍照效果"></a>拍照效果</h4><ol><li>帧定格</li><li>alt增加一层 变换效果 油漆桶 描边 颜色 不透明度</li><li>高斯模糊v1</li></ol><h3 id="剪辑技巧"><a href="#剪辑技巧" class="headerlink" title="剪辑技巧"></a>剪辑技巧</h3><ol><li>隐藏标题栏 ctrl+\</li><li>ctrl+alt交换素材</li><li>快速添加素材 <code>,</code>键  快速复制alt</li><li>ctrl+alt+v 快速复制属性</li><li>回避人声  基本声音-对话 选择音乐素材 音乐-回避 调整闪避量和淡化 生成关键帧   </li></ol><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><ol><li>径向阴影或油漆桶制作描边效果</li><li>任务定格出场秒百年:轨道遮罩键 笔刷 转场 油漆桶,遮罩为转场水墨素材,合成方式为亮度遮罩,位置移动 缓入缓出 添加水墨 文字 白场</li></ol><p><img data-src="http://cdn.sekyoro.top/imgs/01/0220230201125226.png" alt="image-20230201125223057"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;短视频和一般的视频剪辑挺火的,如果是简单的短视频用剪映或者必剪就行了.但是为了体现专业(zhuang bi)性,我这里学学pr.可能要花几周时间.&lt;br&gt;</summary>
    
    
    
    
    <category term="premiere pro" scheme="https://www.sekyoro.top/tags/premiere-pro/"/>
    
    <category term="剪辑" scheme="https://www.sekyoro.top/tags/%E5%89%AA%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>uniapp申请获取地理位置</title>
    <link href="https://www.sekyoro.top/2022/12/11/uniapp%E7%94%B3%E8%AF%B7%E8%8E%B7%E5%8F%96%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE/"/>
    <id>https://www.sekyoro.top/2022/12/11/uniapp%E7%94%B3%E8%AF%B7%E8%8E%B7%E5%8F%96%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE/</id>
    <published>2022-12-11T06:51:37.000Z</published>
    <updated>2022-12-20T14:26:42.993Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>老板要求做一个微信小程序,后面又希望能转为app. 所以选择了uniapp开发. 我的体验和感想就是以后不用uniapp了. 资源不多,学习了可能用处也不大.适合外包的干.这里写一下使用uniapp开发微信小程序获取地理位置<br><span id="more"></span></p><p>基本逻辑是使用uniapp的api首先获得地理经纬度位置等信息(在这之前可以先让用户授权,然后根据获得的地理位置信息利用腾讯的服务得到具体的位置名字.</p><p>这里我主要利用uniapp开发微信小程序.</p><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p><img data-src="http://cdn.sekyoro.top/imgs/image-20221220185902594.png" alt="流程" style="zoom:50%;" /></p><p>getsetting主要用于获取用户当前设置</p><p><img data-src="http://cdn.sekyoro.top/imgs/20/1220221220210453.png" alt="setting获取" style="zoom:67%;" /></p><p>这里重要的就是scope.xx查看用户的授权</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">uni.getSetting(&#123;<span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (res.authSetting &amp;&amp; res.authSetting.hasOwnProperty(<span class="string">&quot;scope.userFuzzyLocation&quot;</span>)) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;获取到auth&#x27;</span>,res)</span><br><span class="line"><span class="keyword">if</span> (res.authSetting[<span class="string">&quot;scope.userFuzzyLocation&quot;</span>]) &#123;</span><br><span class="line"><span class="built_in">this</span>.getCityInfo();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">uni.showModal(&#123;</span><br><span class="line"><span class="attr">title</span>: <span class="string">&quot;提示&quot;</span>,</span><br><span class="line"><span class="attr">content</span>: <span class="string">&quot;请重新授权获取你的地理位置，否则部分功能将无法使用.\r\n提示:点击小程序右上角的三个点在设置中修改授权&quot;</span>,</span><br><span class="line"><span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (res.confirm) &#123;</span><br><span class="line">uni.openSetting(&#123;</span><br><span class="line"><span class="attr">success</span>: <span class="function">() =&gt;</span> <span class="built_in">this</span>.getCityInfo()</span><br><span class="line">&#125;);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">this</span>.getCovidData();</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;正确&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"><span class="built_in">this</span>.getCityInfo();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里的scope.userFuzzyLocation就是需要用户授权的,res.authsetting如果包含这个且为true就进行下一步操作.如果没有这个选项,即res.authSetting.hasOwnProperty(“scope.userFuzzyLocation”)返回false,这样就需要去授权.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getCityInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;调用getCityInfo&#x27;</span>)</span><br><span class="line">uni.authorize(&#123;</span><br><span class="line"><span class="attr">scope</span>: <span class="string">&quot;scope.userFuzzyLocation&quot;</span>,</span><br><span class="line"><span class="attr">success</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;授权&#x27;</span>)</span><br><span class="line"><span class="comment">//做授权之后的操作</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">fail</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">fail</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="built_in">this</span>.loadError();</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>uni.authorize 提前向用户发起授权请求。调用后会立刻弹窗询问用户是否同意授权小程序使用某项功能或获取用户的某些数据，但不会实际调用对应接口.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uni.authorize(&#123;</span><br><span class="line">    <span class="attr">scope</span>: <span class="string">&#x27;scope.userLocation&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">success</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        uni.getLocation()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果用户之前已经同意授权，则不会出现弹窗，直接返回成功。如果用户之前拒绝了授权，此接口会直接进入失败回调.</p><p>当调用这个接口之后就能有对应的scope.xx的值了,要么为true要么为false. authorize会跳出一个弹窗,请求获取权限,如果接受了那就没多大事了.</p><p>如果没有接受,就可以调取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uni.openSetting(&#123;</span><br><span class="line"><span class="attr">success</span>: <span class="function">() =&gt;</span> <span class="built_in">this</span>.getCityInfo()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>调起客户端小程序设置界面，返回用户设置的操作结果.</p><p><img data-src="http://cdn.sekyoro.top/imgs/20/1220221220220021.png" alt="设置界面" style="zoom:50%;" /></p><p>uni.openSetting会打开一个这样的界面让用户设置.用户在这里允许授权即可.</p><h2 id="具体设置"><a href="#具体设置" class="headerlink" title="具体设置"></a>具体设置</h2><p>在uniapp中,需要设置一些需要用户授权的权限.</p><p>  <img data-src="http://cdn.sekyoro.top/imgs/20/1220221220220601.png" alt="image-20221220220601255"></p><p>在uniapp中打开manifest.json中的源码视图,找到permission如上图.</p><p>添加需要的scope和requirePrivateInfos.</p><p>同时getsetting中需要看scope.xx是否存在以及是否为true.</p><p><img data-src="http://cdn.sekyoro.top/imgs/20/12image-20221220220755694.png" alt="image-20221220220755694"></p><p><img data-src="http://cdn.sekyoro.top/imgs/20/1220221220221058.png" alt="image-20221220221057784"></p><p>uni.authorize中也需要获取需要用户授权的scope</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在微信小程序中,使用一些平台提供的接口需要权限.</p><p><img data-src="http://cdn.sekyoro.top/imgs/20/1220221220221401.png" alt="image-20221220221400954" style="zoom:50%;" /></p><p>比如获取当前的地理位置、速度需要小程序的类目相符合,而获取当前的模糊地理位置也需要申请权限.不过这个接口相对来说比较好申请,但是这个接口有点bug,我一开始申请之后当天模拟器上有点问题,不过后面就好了.申请了之后可以利用腾讯提供的sdk将经纬度转为具体的位置名.</p><p>代码基本如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">uni.getFuzzyLocation(&#123;</span><br><span class="line"><span class="attr">type</span>: <span class="string">&quot;gcj02&quot;</span>, <span class="comment">//  wgs84: 返回GPS坐标，gcj02: 返回国测局坐标</span></span><br><span class="line"><span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;获取位置&#x27;</span>, res)</span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">latitude,</span><br><span class="line">longitude</span><br><span class="line">&#125; = res;</span><br><span class="line"><span class="keyword">const</span> location = &#123;</span><br><span class="line">latitude,</span><br><span class="line">longitude</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">this</span>.qqmapsdk.reverseGeocoder(&#123;</span><br><span class="line">location,</span><br><span class="line"><span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> loginAddress = res.result.ad_info.name</span><br><span class="line"><span class="built_in">console</span>.log(loginAddress)</span><br><span class="line"><span class="built_in">this</span>.flag = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 获取信息</span></span><br><span class="line"><span class="built_in">this</span>.country = loginAddress.split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">this</span>.province = loginAddress.split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">this</span>.city = loginAddress.split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">this</span>.district = loginAddress.split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">3</span>];</span><br><span class="line"><span class="built_in">this</span>.formvalue.location = <span class="built_in">this</span>.province + <span class="string">&#x27;&gt;&#x27;</span> +</span><br><span class="line"><span class="built_in">this</span>.city + <span class="string">&#x27;&gt;&#x27;</span> + <span class="built_in">this</span>.district;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.donext();</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">fail</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">fail</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://lbs.qq.com/miniProgram/jsSdk/jsSdkGuide/jsSdkOverview">微信小程序JavaScript SDK | 腾讯位置服务 (qq.com)</a></li><li><a href="https://blog.csdn.net/a18792627168/article/details/108962311#:~:text=uni-app,小程序项目无法直接获取到地理位置，只能通过获取到的经纬度，调用第三方地图Api获取。">uni-app微信小程序获取用户地理位置信息_DOM曼珠沙华的博客-CSDN博客_uni.getsetting</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;老板要求做一个微信小程序,后面又希望能转为app. 所以选择了uniapp开发. 我的体验和感想就是以后不用uniapp了. 资源不多,学习了可能用处也不大.适合外包的干.这里写一下使用uniapp开发微信小程序获取地理位置&lt;br&gt;</summary>
    
    
    
    
    <category term="uniapp" scheme="https://www.sekyoro.top/tags/uniapp/"/>
    
    <category term="微信小程序" scheme="https://www.sekyoro.top/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    <category term="获取地理位置" scheme="https://www.sekyoro.top/tags/%E8%8E%B7%E5%8F%96%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>磁力链接与RSS订阅</title>
    <link href="https://www.sekyoro.top/2022/11/22/%E7%A3%81%E5%8A%9B%E9%93%BE%E6%8E%A5%E4%B8%8ERSS%E8%AE%A2%E9%98%85/"/>
    <id>https://www.sekyoro.top/2022/11/22/%E7%A3%81%E5%8A%9B%E9%93%BE%E6%8E%A5%E4%B8%8ERSS%E8%AE%A2%E9%98%85/</id>
    <published>2022-11-22T04:43:50.000Z</published>
    <updated>2022-11-22T06:09:57.690Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近接触到了BT下载和RSS订阅,稍微学习学习,了解下概念.内容主要来自维基百科<br><span id="more"></span></p><h2 id="BT介绍"><a href="#BT介绍" class="headerlink" title="BT介绍"></a>BT介绍</h2><p>BT全称BitTorrent,是用在<a href="https://zh.wikipedia.org/wiki/对等网络">对等网络</a>中<a href="https://zh.wikipedia.org/wiki/文件分享">文件分享</a>的<a href="https://zh.wikipedia.org/wiki/网络协议">网络协议</a><a href="https://zh.wikipedia.org/wiki/计算机程序">程序</a>。和<a href="https://zh.wikipedia.org/wiki/点对点协议">点对点</a>（point-to-point）的协议<a href="https://zh.wikipedia.org/wiki/计算机程序">程序</a>不同，它是用户群对用户群（peer-to-peer），而且用户越多，下载同一文件的人越多，下载该文件的速度越快。且下载后，继续维持上传的状态，就可以“分享”，成为其用户端节点下载的<a href="https://zh.wikipedia.org/wiki/种子文件">种子文件</a>（.torrent），同时上传及下载.</p><p>普通的<a href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a>／<a href="https://zh.wikipedia.org/wiki/FTP">FTP</a>下载使用<a href="https://zh.wikipedia.org/wiki/TCP/IP协议">TCP/IP协议</a>，BitTorrent协议是架构于TCP/IP协议之上的一个<a href="https://zh.wikipedia.org/wiki/对等网络">P2P</a>文件传输<a href="https://zh.wikipedia.org/wiki/通訊協定">通信协议</a>，处于TCP/IP结构的<a href="https://zh.wikipedia.org/wiki/应用层">应用层</a>。BitTorrent协议本身也包含了很多具体的内容协议和扩展协议，并在不断扩展中</p><p>在BT下载的流程中,文件发布者会根据要发布的文件生成提供一个.torrent文件,这就是种子文件.发布这个文件就是做种(发布者提供下载任务的全部内容的行为；下载者下载完成后继续提供给他人下载的行为).</p><p>这个种子文件本质上是<a href="https://zh.wikipedia.org/wiki/文本文件">文本文件</a>，包含Tracker信息和文件信息两部分。<strong>Tracker信息主要是BT下载中需要用到的Tracker服务器的地址和针对Tracker服务器的设置</strong>，<strong>文件信息是根据对目标文件的计算生成的，计算结果根据BitTorrent协议内的<a href="https://zh.wikipedia.org/wiki/Bencode">Bencode</a>规则进行编码</strong>。它的主要原理是需要把提供下载的文件虚拟分成大小相等的块，块大小必须为2k的整数次方（由于是虚拟分块，硬盘上并不产生各个块文件），并把每个块的索引信息和<a href="https://zh.wikipedia.org/wiki/Hash">Hash</a>验证码写入种子文件中；所以，种子文件就是被下载文件的“索引”。</p><p>下载者要下载文件内容，需要先得到相应的种子文件，然后使用BT客户端软件进行下载。</p><p>因为种子文件中有tracker地址,这个tracker就是个服务器地址(下载者的信息也会记录.收集下载者信息的服务器，并将此信息提供给其他下载者，使下载者们相互连接起来，传输数据。).下图是在Motrix中的种子的tracker信息<img data-src="http://cdn.sekyoro.top/imgs/image-20221122140032781.png" alt="image-20221122140032781" style="zoom:50%;" /></p><p>下载时，BT客户端首先解析种子文件得到Tracker地址，然后连接Tracker服务器。Tracker服务器回应下载者的请求，提供下载者其他下载者（包括发布者）的IP。下载者再连接其他下载者，根据种子文件，两者分别告知对方自己已经有的块，然后交换对方所没有的数据。此时不需要其他服务器参与，分散了单个线路上的数据流量，因此减轻了服务器负担。</p><p>下载者每得到一个块，需要算出下载块的Hash验证码与种子文件中的对比，如果一样则说明块正确，不一样则需要重新下载这个块。这种规定是为了解决下载内容准确性的问题。</p><h2 id="磁力链接"><a href="#磁力链接" class="headerlink" title="磁力链接"></a>磁力链接</h2><p><strong>磁力链接</strong>（Magnet URI scheme），是<a href="https://zh.wikipedia.org/wiki/对等网络">对等网络</a>中进行信息检索和下载文档的<a href="https://zh.wikipedia.org/wiki/电脑程序">电脑程序</a>。和基于“位置”连接的<a href="https://zh.wikipedia.org/wiki/统一资源定位符">统一资源定位符</a>不同，磁力链接是基于<a href="https://zh.wikipedia.org/wiki/元数据">元数据</a>（metadata）文件内容，属于<a href="https://zh.wikipedia.org/wiki/统一资源名称">统一资源名称</a>。也就是说，磁力链接不基于文档的<a href="https://zh.wikipedia.org/wiki/IP地址">IP地址</a>或定位符，而是在<a href="https://zh.wikipedia.org/wiki/分布式数据库">分布式数据库</a>中，通过<a href="https://zh.wikipedia.org/wiki/散列函数">散列函数</a>值来识别、<a href="https://zh.wikipedia.org/wiki/搜索">搜索</a>来下载文档。因为不依赖一个处于启动状态的主机来下载文档，所以特别适用没有中心服务器的<a href="https://zh.wikipedia.org/wiki/对等网络">对等网络</a>。它符合<a href="https://zh.wikipedia.org/wiki/开源标准">开源标准</a>。</p><p>磁力链接由一组参数组成，参数间的顺序没有讲究，其格式与在HTTP链接末尾的查询字符串相同。最常见的参数是”xt”，是”exact topic”的缩写，通常是一个特定文件的内容散列函数值形成的<a href="https://zh.wikipedia.org/wiki/统一资源名称">URN</a></p><p><img data-src="http://cdn.sekyoro.top/imgs/image-20221122140625013.png" alt="image-20221122140625013"></p><h2 id="RSS订阅"><a href="#RSS订阅" class="headerlink" title="RSS订阅"></a>RSS订阅</h2><p><strong>RSS</strong>（英文全称：<a href="https://zh.wikipedia.org/wiki/Resource_Description_Framework">RDF</a> Site Summary 或 Really Simple Syndication<a href="https://zh.wikipedia.org/wiki/RSS#cite_note-powers-2003-1-2">[2]</a>），中文译作<strong>简易信息聚合</strong><a href="https://zh.wikipedia.org/wiki/RSS#cite_note-3">[3]</a>，也称<strong>聚合内容</strong><a href="https://zh.wikipedia.org/wiki/RSS#cite_note-张锐2015-4">[4]</a>，是一种<a href="https://zh.wikipedia.org/wiki/消息來源">消息来源</a>格式规范，用以聚合多个网站更新的内容并自动通知网站订阅者。使用 RSS 后，网站订阅者便无需再手动查看网站是否有新的内容，同时 RSS 可将多个网站更新的内容进行整合，以摘要的形式呈现，有助于订阅者快速获取重要信息，并选择性地点阅查看。</p><p>RSS 摘要可以借由 RSS 阅读器、feed reader 或 aggregator 等网页或以桌面为架构的软件来阅读。标准的 <a href="https://zh.wikipedia.org/wiki/XML">XML</a> 档式可允许信息在一次发布后通过不同的程序阅览。用户借由将网摘输入 RSS 阅读器，或是用鼠标点取浏览器上指向订阅程序的 RSS 小图标 <a href="https://zh.wikipedia.org/wiki/URI">URI</a>（非通常所称的 <a href="https://zh.wikipedia.org/wiki/URL">URL</a>）来订阅网摘。RSS 阅读器会定期检阅网站是否有更新，然后下载至监看用户界面。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zh.wikipedia.org/wiki/RSS">RSS - 维基百科，自由的百科全书 (wikipedia.org)</a></p><p><a href="https://zh.wikipedia.org/wiki/BitTorrent_(协议">BitTorrent (协议) - 维基百科，自由的百科全书 (wikipedia.org)</a>)</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近接触到了BT下载和RSS订阅,稍微学习学习,了解下概念.内容主要来自维基百科&lt;br&gt;</summary>
    
    
    
    
    <category term="RSS" scheme="https://www.sekyoro.top/tags/RSS/"/>
    
    <category term="torrent" scheme="https://www.sekyoro.top/tags/torrent/"/>
    
    <category term="BT" scheme="https://www.sekyoro.top/tags/BT/"/>
    
  </entry>
  
  <entry>
    <title>使用overleaf优雅地写文章</title>
    <link href="https://www.sekyoro.top/2022/11/11/%E4%BD%BF%E7%94%A8overleaf%E4%BC%98%E9%9B%85%E5%9C%B0%E5%86%99%E6%96%87%E7%AB%A0/"/>
    <id>https://www.sekyoro.top/2022/11/11/%E4%BD%BF%E7%94%A8overleaf%E4%BC%98%E9%9B%85%E5%9C%B0%E5%86%99%E6%96%87%E7%AB%A0/</id>
    <published>2022-11-11T07:24:55.000Z</published>
    <updated>2022-11-11T10:56:20.703Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>之前一般都用markdown写完转word或者pdf.为了更方便地插入公式和使用模板,使用tex格式来写文章,特别是科研可能是个更好的选择.<br><span id="more"></span></p><blockquote><p><strong>TeX/LaTeX</strong> 既可以表示所指的宏语言/格式，也可以表示实现该宏语言的整套软件，也可以表示软件中的一两个可执行程序命令</p></blockquote><p>本地如果要使用可能需要装多个软件,比如texLive,texStudio等.主要是无法很好的跨平台,当换平台时一般需要通过网盘传送.如果使用overleaf从各个角度来看都方便多了,还方便与人分享交流review.与markdown差别是通过导入包使得功能更丰富,更加偏向科研.</p><h2 id="Latex基本语法"><a href="#Latex基本语法" class="headerlink" title="Latex基本语法"></a>Latex基本语法</h2><p>这东西包含内容很多,通览一下即可.个人感觉是需要先了解一篇文章的结构.</p><h3 id="序言-Preamble-和正文-Document"><a href="#序言-Preamble-和正文-Document" class="headerlink" title="序言(Preamble)和正文(Document)"></a>序言(Preamble)和正文(Document)</h3><p>首先基本文档结构氛围序言和正文.</p><h4 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h4><p>主要用来申明你写的文档类型、文档语言、文档使用的包(类似于Python中的<code>import</code>)等。一个常见的序言如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[12pt, letterpaper]&#123;article&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>[utf8]&#123;inputenc&#125;</span><br></pre></td></tr></table></figure><p>简单来说就是声明要写的是article,report还是book并设置属性.同时导包并设置属性.</p><p><img data-src="http://cdn.sekyoro.top/imgs/image-20221111162352108.png" alt="image-20221111162352108" style="zoom:67%;" /></p><p>babel设置语言,inputenc设置编码,geometry设置布局.</p><p>amsmath数学公式包,graphicx导入图片,hyperref设置超链接.</p><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>对于正文内容使用<code>\begin&#123;ducument&#125;</code>和<code>\end&#123;document&#125;</code>标签进行控制，在标签内就可以进行写作了，写在标签外的内容是不会展示出来的。和Markdown一样，换行需要按两次<code>Enter</code>。<code>\begin&#123;abstract&#125;</code>和<code>\end&#123;abstract&#125;</code>可以在正文中添加摘要</p><p>添加属性,即设置文档的标题 作者 时间 致谢</p><ul><li><code>\title&#123;your title&#125;</code>:添加文档标题</li><li><code>\author&#123;your name&#125;</code>:添加作者</li><li><code>\thanks&#123;funded by ...&#125;</code>:添加致谢信息，必须在<code>author</code>的花括号里面才有用</li><li><code>\date&#123;your date&#125;</code>:添加日期，<code>\today</code>表示设置成编译文档那一天的日期</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\title&#123;This is a title&#125;</span><br><span class="line">\author&#123;</span><br><span class="line">Zhao Xuhui\thanks&#123;thanks 1&#125;,</span><br><span class="line">Xuhui Zhao\thanks&#123;thanks 2&#125;&#125;</span><br><span class="line">\date&#123;\today&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\maketitle</span><br><span class="line">This is test text.</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure><p>注释使用%</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\label&#123;pic&#125;</span><br><span class="line">this is a pic\ref&#123;pic&#125;</span><br></pre></td></tr></table></figure><p>通常用在图片,表格的引用中.</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ul><li>加粗:<code>\textbf&#123;...&#125;</code></li><li>斜体:<code>\textit&#123;...&#125;</code></li><li>下划线:<code>\underline&#123;...&#125;</code></li><li>强调:<code>\emph&#123;...&#125;</code>，与上下文字体相反，上下文常规它就是斜体，上下文斜体它就是常规</li><li>居中:<code>\centerline&#123;...&#125;</code>，居中显示文本</li></ul><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage&#123;graphicx&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">This is a test of image insertion.</span><br><span class="line"></span><br><span class="line">\begin&#123;figure&#125;[h]   % 必须要有[h]否则插入的图片都在文字前面</span><br><span class="line">    \centering  % 图像居中</span><br><span class="line">    \includegraphics[width=4cm]&#123;test/cover31.jpg&#125;   %[]里可以指定影像大小</span><br><span class="line">    \caption&#123;Electronic&#125;    % 图名</span><br><span class="line">    \label&#123;fig_electronic&#125;  % 用于内部引用的图名</span><br><span class="line">\end&#123;figure&#125;</span><br><span class="line"></span><br><span class="line">It is a great figure.</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure><p>插入图片的基本流程 \begin{figure} 居中 设置路径与大小 设置名字 在名字种设置label方便引用</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>无序列表使用<code>itemize</code>，有序列表使用<code>enumerate</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">This is a test of list.</span><br><span class="line"></span><br><span class="line">\begin&#123;itemize&#125;</span><br><span class="line">  \item The individual entries are indicated with a black dot, a so-called bullet.</span><br><span class="line">  \item The text in the entries may be of any length.</span><br><span class="line">\end&#123;itemize&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;enumerate&#125;</span><br><span class="line">  \item This is the first entry in our list</span><br><span class="line">  \item The list numbers increase with each entry we add</span><br><span class="line">\end&#123;enumerate&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;table&#125;</span><br><span class="line">\centering</span><br><span class="line">\begin&#123;tabular&#125;&#123;l|r&#125;</span><br><span class="line">Item &amp; Quantity \\\hline</span><br><span class="line">Widgets &amp; 42 \\</span><br><span class="line">Gadgets &amp; 13</span><br><span class="line">\end&#123;tabular&#125;</span><br><span class="line">\caption&#123;\label&#123;tab:widgets&#125;An example table.&#125;</span><br><span class="line">\end&#123;table&#125;</span><br></pre></td></tr></table></figure><p><code>\begin&#123;tabular&#125;&#123;l|c|r&#125;</code>这里面的<code>&#123;l|c|r&#125;</code>，包含了三个字母，代表了表格总共有三列，第一列靠左偏移，第二列居中，第三列靠右偏移。竖线代表列之间用线分隔开来，如果想要左右两边都用线包围起来，应该改成<code>&#123;|l|c|r|&#125;</code>。接下来就是正式的表格绘制部分。</p><h2 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h2><p>用<code>\section&#123;&#125;</code>来表示章节，从当前<code>section</code>开始直到下一个<code>section</code>出现，这期间的内容都属于当前<code>section</code>，花括号内是章节标题。章节号是LaTeX自动生成的</p><p><img data-src="https://zhaoxuhui.top/assets/images/blog/content/2019-09-04-06.png" alt="img" style="zoom:67%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\section&#123;Introduction&#125;</span><br><span class="line"></span><br><span class="line">Your introduction goes here! Simply start writing your document and use the Recompile button to view the updated PDF preview. Examples of commonly used commands and features are listed below, to help you get started.</span><br></pre></td></tr></table></figure><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>添加目录的命令是<code>\tableofcontents</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line"></span><br><span class="line">\title&#123;Test title&#125;</span><br><span class="line">\author&#123;Zhao Xuhui&#125;</span><br><span class="line">\date&#123;\today&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\maketitle</span><br><span class="line"> </span><br><span class="line">\tableofcontents</span><br><span class="line"> </span><br><span class="line">\section&#123;Introduction&#125;</span><br><span class="line"> </span><br><span class="line">This is the first section.</span><br><span class="line"> </span><br><span class="line">Lorem  ipsum  dolor  sit  amet,  consectetuer  adipiscing  </span><br><span class="line">elit.   Etiam  lobortisfacilisis sem.  Nullam nec mi et </span><br><span class="line">neque pharetra sollicitudin.  Praesent imperdietmi nec ante. </span><br><span class="line">Donec ullamcorper, felis non sodales...</span><br><span class="line"> </span><br><span class="line">\addcontentsline&#123;toc&#125;&#123;section&#125;&#123;Unnumbered Section&#125;</span><br><span class="line">\section*&#123;Unnumbered Section&#125;</span><br><span class="line"> </span><br><span class="line">Lorem ipsum dolor sit amet, consectetuer adipiscing elit.  </span><br><span class="line">Etiam lobortis facilisissem.  Nullam nec mi et neque pharetra </span><br><span class="line">sollicitudin.  Praesent imperdiet mi necante...</span><br><span class="line"> </span><br><span class="line">\section&#123;Second Section&#125;</span><br><span class="line"> </span><br><span class="line">Lorem ipsum dolor sit amet, consectetuer adipiscing elit.  </span><br><span class="line">Etiam lobortis facilisissem.  Nullam nec mi et neque pharetra </span><br><span class="line">sollicitudin.  Praesent imperdiet mi necante...</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><p>LaTeX公式分为行内(inline)与展示(display)两种类型。前者是文本中的一部分，后者是单独占一行。</p><p>行内公式有三种方式：反斜线小括号、<script type="math/tex">`和`</script>、<code>\begin&#123;math&#125;</code>和<code>\end&#123;math&#125;</code>。</p><p>展示型公式有四种方式：反斜线中括号、<code>\begin&#123;equation&#125;</code>和<code>\end&#123;equation&#125;</code>、<code>\begin&#123;displaymath&#125;</code>和<code>\end&#123;displaymath&#125;</code>、双美元标志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\LaTeX&#123;&#125; is great at typesetting mathematics. Let $X_1, X_2, \ldots, X_n$ be a sequence of independent and identically distributed random variables with $\text&#123;E&#125;[X_i] = \mu$ and $\text&#123;Var&#125;[X_i] = \sigma^2 &lt; \infty$, and let</span><br><span class="line">\[S_n = \frac&#123;X_1 + X_2 + \cdots + X_n&#125;&#123;n&#125;</span><br><span class="line">      = \frac&#123;1&#125;&#123;n&#125;\sum_&#123;i&#125;^&#123;n&#125; X_i\]</span><br><span class="line">denote their mean. Then as $n$ approaches infinity, the random variables $\sqrt&#123;n&#125;(S_n - \mu)$ converge in distribution to a normal $\mathcal&#123;N&#125;(0, \sigma^2)$.</span><br></pre></td></tr></table></figure><h2 id="引用-1"><a href="#引用-1" class="headerlink" title="引用"></a>引用</h2><p>上传bib文件,比如叫sample.bib,进行引用\cite{},然后在最后添加引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\bibliographystyle&#123;plain&#125;</span><br><span class="line">\bibliography&#123;sample&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.overleaf.com/learn/latex/Learn_LaTeX_in_30_minutes">Learn LaTeX in 30 minutes - Overleaf, Online LaTeX Editor</a> overleaf上的Latex入门</p><p><a href="http://zhaoxuhui.top/blog/2019/09/04/latex-overleaf-note.html">LaTeX基本语法</a></p><p><a href="https://www.jianshu.com/p/5fe5e4d33a41">Latex基本语法(入门)</a></p><p><a href="https://blog.csdn.net/ayaishere_/article/details/123332393">【排版】用Overleaf速成LaTeX代码（从入门到开门）<em>ayaishere</em>的博客-CSDN博客_overleaf 空格</a></p><p><a href="https://blog.csdn.net/m0_52037292/article/details/109768317"> 快速上手系列——用Overleaf写中文文档_DeShawnPhang的博客-CSDN博客_overleaf怎么写中文</a></p><p><a href="https://blog.csdn.net/Canhui_WANG/article/details/87364800">关于Latex的Figure图像编号关联所在章节编号之问题的解决方案<em>林微的博客-CSDN博客</em>\begin{figure}</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前一般都用markdown写完转word或者pdf.为了更方便地插入公式和使用模板,使用tex格式来写文章,特别是科研可能是个更好的选择.&lt;br&gt;</summary>
    
    
    
    
    <category term="latex" scheme="https://www.sekyoro.top/tags/latex/"/>
    
    <category term="tex" scheme="https://www.sekyoro.top/tags/tex/"/>
    
    <category term="overleaf" scheme="https://www.sekyoro.top/tags/overleaf/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题记录</title>
    <link href="https://www.sekyoro.top/2022/11/11/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://www.sekyoro.top/2022/11/11/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2022-11-11T05:50:43.000Z</published>
    <updated>2023-03-05T15:58:35.997Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>唉,很久没做做题了.这里记录一下每天刷题练习.<br><span id="more"></span></p><p>主要刷一些简单中等题,难了我也不会.</p><p>剑指Offer 启动</p><p><img data-src="http://cdn.sekyoro.top/imgs/26/1220221226173618.png" alt="image-20221226173618143" style="zoom: 80%;" /></p><p>09.用两个栈实现队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 用两个栈实现队列;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CQueue2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Deque&lt;Integer&gt; inStack;</span><br><span class="line">  Deque&lt;Integer&gt; outStack;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CQueue2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    inStack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    outStack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    inStack.push(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(outStack.isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(inStack.isEmpty())</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span>(!inStack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">          outStack.push(inStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> outStack.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="设计一个有getMin功能的栈"><a href="#设计一个有getMin功能的栈" class="headerlink" title="设计一个有getMin功能的栈"></a>设计一个有getMin功能的栈</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。</span><br></pre></td></tr></table></figure><p>【要求】</p><p>1.pop、push、getMin 操作的时间复杂度都是 <em>O</em>(1)。 2.设计的栈类型可以使用现成的栈结构</p><h4 id="设计方案"><a href="#设计方案" class="headerlink" title="设计方案"></a>设计方案</h4><p>使用辅助栈,多一个存最小值的栈stackmin. 即有stackdata和stackmin</p><p><strong>第一种</strong></p><p>压入规则</p><p>压入数据时,stackdata直接压入;stackmin如果为空,直接压入,如果不为空,进行比较:将要压入的值和栈顶的值进行比较,如果栈顶值更小则不处理,否则压入.</p><p>弹出规则</p><p>stackdata弹出数据,将弹出的数据与stackmin顶数据比较,如果弹出数据等于stackmin栈顶数据,则同时弹出stackmin数据,否则不处理.</p><p>最小值即位stackmin中栈顶值</p><p><strong>第二种</strong></p><p>压入规则</p><p>压入数据时,stackdata直接压入;stackmin如果为空也直接压入,否则将栈顶数据与待压入数据比较,如果栈顶数据更小,则stackmin再压入一次栈顶数据,否则stackmin压入待压入数据.</p><p>弹出规则</p><p>两个栈都弹出</p><p>最小值也是stackmin的栈顶</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt;s,min_s;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">emplace</span>(val);</span><br><span class="line">            min_s.<span class="built_in">emplace</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> topvalue = min_s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(topvalue&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                min_s.<span class="built_in">emplace</span>(val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                min_s.<span class="built_in">emplace</span>(topvalue);</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">emplace</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        min_s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_s.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）</p><h4 id="设计方案-1"><a href="#设计方案-1" class="headerlink" title="设计方案"></a>设计方案</h4><p>利用栈结构或者使用递归</p><p>这里使用递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; v =<span class="built_in">reversePrint</span>(head-&gt;next);</span><br><span class="line">        v.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>使用辅助栈结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(ptr it=head;it!=<span class="literal">nullptr</span>;it=it-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(it-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> val = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            v.<span class="built_in">push_back</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p><strong>示例:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment">  ListNode(int x):val(x),next(NULL)&#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> ListNode* LN;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LN nd = head-&gt;next;</span><br><span class="line">        LN pre = head;</span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span>(LN it = nd;it!=<span class="literal">nullptr</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            nd = it-&gt;next;</span><br><span class="line">            it-&gt;next = pre;</span><br><span class="line">            pre = it;</span><br><span class="line">            it = nd;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用递归方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h3><p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li>回溯和哈希表(或者单独使用哈希表)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;Node *, Node *&gt; cachedNode;</span><br><span class="line">    <span class="function">Node *<span class="title">copyRandomList</span><span class="params">(Node *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!cachedNode.<span class="built_in">count</span>(head))</span><br><span class="line">        &#123;</span><br><span class="line">            cachedNode[head] = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">            cachedNode[head]-&gt;next = <span class="built_in">copyRandomList</span>(head-&gt;next);</span><br><span class="line">            cachedNode[head]-&gt;random = <span class="built_in">copyRandomList</span>(head-&gt;random);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cachedNode[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><p>迭代+节点拆分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Node* node = head; node != <span class="literal">nullptr</span>; node = node-&gt;next-&gt;next) &#123;</span><br><span class="line">            Node* nodeNew = <span class="keyword">new</span> <span class="built_in">Node</span>(node-&gt;val);</span><br><span class="line">            nodeNew-&gt;next = node-&gt;next;</span><br><span class="line">            node-&gt;next = nodeNew;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Node* node = head; node != <span class="literal">nullptr</span>; node = node-&gt;next-&gt;next) &#123;</span><br><span class="line">            Node* nodeNew = node-&gt;next;</span><br><span class="line">            nodeNew-&gt;random = (node-&gt;random != <span class="literal">nullptr</span>) ? node-&gt;random-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* headNew = head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (Node* node = head; node != <span class="literal">nullptr</span>; node = node-&gt;next) &#123;</span><br><span class="line">            Node* nodeNew = node-&gt;next;</span><br><span class="line">            node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">            nodeNew-&gt;next = (nodeNew-&gt;next != <span class="literal">nullptr</span>) ? nodeNew-&gt;next-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headNew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;唉,很久没做做题了.这里记录一下每天刷题练习.&lt;br&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="https://www.sekyoro.top/tags/leetcode/"/>
    
    <category term="algorithm" scheme="https://www.sekyoro.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>vue网上商城项目</title>
    <link href="https://www.sekyoro.top/2022/10/25/vue%E7%BD%91%E4%B8%8A%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/"/>
    <id>https://www.sekyoro.top/2022/10/25/vue%E7%BD%91%E4%B8%8A%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/</id>
    <published>2022-10-25T09:37:34.000Z</published>
    <updated>2022-10-25T12:33:16.331Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>学了就要写<br><span id="more"></span></p><p>使用vue cli,自己选一些feature.vuex和vue-router必要的.还要安装axios,vue-axios(axios使用的时候不能像vue的插件（如：Vue-Router、VueX等）通过Vue.use()安装插件，需要在原型上进行绑定：Vue.prototype.$axios = axios).</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios vue-axios -S</span><br></pre></td></tr></table></figure><p>在main.js文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueAxios <span class="keyword">from</span> <span class="string">&#x27;vue-axios&#x27;</span></span><br><span class="line">createApp(App).use(store).use(router).use(VueAxios,axios).mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>views目录下存放页面级组件,一般的小组件存放在components的文件夹下,这些组件会被复用.</p><p>请求后端数据就需要配置一个反向代理,在vue.config.js中配置</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/qq_43654065/article/details/121288529">axios和vue-axios_在线小白www的博客-CSDN博客_axios vue-axios</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;学了就要写&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
</feed>

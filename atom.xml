<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sekyoro的博客小屋</title>
  
  
  <link href="https://www.sekyoro.top/atom.xml" rel="self"/>
  
  <link href="https://www.sekyoro.top/"/>
  <updated>2024-09-15T15:52:27.127Z</updated>
  <id>https://www.sekyoro.top/</id>
  
  <author>
    <name>Sekyoro</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>build a mini project starter in Rust</title>
    <link href="https://www.sekyoro.top/2024/09/15/build-a-mini-project-starter-in-Rust/"/>
    <id>https://www.sekyoro.top/2024/09/15/build-a-mini-project-starter-in-Rust/</id>
    <published>2024-09-15T01:45:08.000Z</published>
    <updated>2024-09-15T15:52:27.127Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近沉迷写c++以及cmake构建项目(不是吧,这也能沉迷?),主要关注的是一个项目的架构,以及一些辅助工具,比如生成文档,代码检查(sanitize)等,打算使用Rust写一个非常简单的c++项目的generator<br><span id="more"></span></p><p>项目源码:<a href="https://github.com/drowning-in-codes/build-my-own-x/tree/main/mini-project-starter">build-my-own-x/mini-project-starter at main · drowning-in-codes/build-my-own-x (github.com)</a></p><p>crates.io:<a href="https://crates.io/crates/mini-project-starter">mini-project-starter - crates.io: Rust Package Registry</a></p><p><img data-src="https://s2.loli.net/2024/09/15/39hKmTFezL5vJM1.png" alt="image-20240915235220102"></p><h2 id="常见的c-项目组织方式"><a href="#常见的c-项目组织方式" class="headerlink" title="常见的c++项目组织方式"></a>常见的c++项目组织方式</h2><p>项目组织方式因人而异,但一些基本点还是相同的,比如参考Rust一些模块组织方式,由于c++代码需要有头文件(不知道c++26之后的未来会不会尽可能地使用模块替代头文件这种组织方式)</p><p>由于在其他语言中,一个模块基本上就是单独一个文件,而c++中是cpp源文件和对应的头文件,这个模块最好(或者说必须)放在对应名字的目录下,比如我的项目下写了一个logger模块,它一种组织方式如下,src目录下放置需要的库,app目录下放可执行程序或者最后生成的库.相当于在src目录下放置多个模块目录,每个目录中放源文件和头文件</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> root_dir\</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> src\</span></span><br><span class="line"><span class="ruby"></span>       -<span class="ruby"> logger\</span></span><br><span class="line"><span class="ruby"></span>         -<span class="ruby"> logger.cpp</span></span><br><span class="line"><span class="ruby"></span>         -<span class="ruby"> logger.hpp</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> <span class="keyword">include</span>\  (optional)</span></span><br><span class="line"><span class="ruby"></span>       -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> app\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> main.cpp</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> <span class="keyword">include</span>\</span></span><br><span class="line"><span class="ruby"></span>          -<span class="ruby"> main.hpp (optional)</span></span><br></pre></td></tr></table></figure><p>或者稍微改改,将模块的头文件放在include中,也就是头文件和源文件不放在同一个目录</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> root_dir\</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> src\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> logger.cpp</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> <span class="keyword">include</span>\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> logger\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> logger.hpp</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> app\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> main.cpp</span></span><br></pre></td></tr></table></figure><p>此外还有一种,将所有cpp文件都放在src中,头文件放在include中,差异就是它的源文件是放在一起的,没有放在一个所谓模块目录下.</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> root_dir\</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> src\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> logger.cpp</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> main.cpp</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> <span class="keyword">include</span>\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> main.hpp</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> logger\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> logger.hpp</span></span><br></pre></td></tr></table></figure><p>上面几种方式其实都行,我们看看rust是怎么组织的,由于没有头文件,在src目录下有main.rs,而garden.rs是模块,garden目录下的vegetables.rs是模块的子模块.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">backyard</span><br><span class="line">├── Cargo<span class="selector-class">.lock</span></span><br><span class="line">├── Cargo<span class="selector-class">.toml</span></span><br><span class="line">└── <span class="attribute">src</span></span><br><span class="line">    ├── garden</span><br><span class="line">    │   └── vegetables<span class="selector-class">.rs</span></span><br><span class="line">    ├── garden<span class="selector-class">.rs</span></span><br><span class="line">    └── <span class="selector-tag">main</span>.rs</span><br></pre></td></tr></table></figure><p>上面组织方式的核心差别,是针对头文件,要么在include目录下按照模块名分几个目录,而不是将头文件放在一起,要么在src目录下分多个需要的库目录,每个目录包括源文件和头文件.</p><h2 id="mini-project-starter"><a href="#mini-project-starter" class="headerlink" title="mini-project-starter"></a>mini-project-starter</h2><h3 id="命令行解析"><a href="#命令行解析" class="headerlink" title="命令行解析"></a>命令行解析</h3><p>使用<code>Clap</code>库解析参数，</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mini-project-starter new -p &lt;DIR&gt; <span class="comment"># 在一个目录下创建项目</span></span><br><span class="line">mini-project-starter init <span class="comment"># 在当前目录下初始化项目</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> utils;</span><br><span class="line"><span class="keyword">use</span> clap::&#123;command, Arg, Command&#125;;</span><br><span class="line"><span class="keyword">use</span> utils::&#123;init_project, new_project&#125;;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> starter_config = command!()</span><br><span class="line">        .propagate_version(<span class="literal">true</span>)</span><br><span class="line">        .subcommand_required(<span class="literal">true</span>)</span><br><span class="line">        .arg_required_else_help(<span class="literal">true</span>)</span><br><span class="line">        .subcommand(</span><br><span class="line">            Command::new(<span class="string">&quot;new&quot;</span>)</span><br><span class="line">                .about(<span class="string">&quot;Create a new project in the specified directory&quot;</span>)</span><br><span class="line">                .arg(</span><br><span class="line">                    Arg::new(<span class="string">&quot;project_root_dir&quot;</span>)</span><br><span class="line">                        .short(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">                        .long(<span class="string">&quot;project_root_dir&quot;</span>)</span><br><span class="line">                        .value_name(<span class="string">&quot;DIR&quot;</span>)</span><br><span class="line">                        .value_parser(clap::builder::NonEmptyStringValueParser::new())</span><br><span class="line">                        .help(<span class="string">&quot;The root dir of the project&quot;</span>)</span><br><span class="line">                        .required(<span class="literal">true</span>),</span><br><span class="line">                ),</span><br><span class="line">        )</span><br><span class="line">        .subcommand(Command::new(<span class="string">&quot;init&quot;</span>).about(<span class="string">&quot;Init the project in the current directory&quot;</span>))</span><br><span class="line">        .get_matches();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> starter_config.subcommand() &#123;</span><br><span class="line">        <span class="literal">Some</span>((<span class="string">&quot;new&quot;</span>, sub_matches)) =&gt; &#123;</span><br><span class="line">            new_project(sub_matches.get_one::&lt;<span class="built_in">String</span>&gt;(<span class="string">&quot;project_root_dir&quot;</span>).unwrap())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">Some</span>((<span class="string">&quot;init&quot;</span>, _)) =&gt; init_project(),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Please specify a subcommand&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后让用户输入项目的一些信息,这些信息可以替换后面<code>CMakeLists.txt</code>中的项目信息</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> root_dir_name = default_root_dir_name</span><br><span class="line">                .file_name()</span><br><span class="line">                .unwrap()</span><br><span class="line">                .to_str()</span><br><span class="line">                .unwrap();</span><br><span class="line">    <span class="keyword">let</span> project_name = Input::&lt;<span class="built_in">String</span>&gt;::new()</span><br><span class="line">        .with_prompt(<span class="string">r&quot;Enter your project name.(project root folder name if leave blank)&quot;</span>)</span><br><span class="line">        .with_initial_text(root_dir_name.to_string())</span><br><span class="line">        .interact_text()</span><br><span class="line">        .unwrap_or(root_dir_name.to_string());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 项目版本</span></span><br><span class="line">    <span class="keyword">let</span> project_version = Input::&lt;<span class="built_in">String</span>&gt;::new()</span><br><span class="line">        .with_prompt(<span class="string">&quot;Enter your project version.(default: 0.1.0)&quot;</span>)</span><br><span class="line">        .with_initial_text(<span class="string">&quot;0.1.0&quot;</span>.to_string())</span><br><span class="line">        .interact_text()</span><br><span class="line">        .unwrap_or(<span class="string">&quot;0.1.0&quot;</span>.to_string());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 项目描述</span></span><br><span class="line">    <span class="keyword">let</span> project_desc = Input::&lt;<span class="built_in">String</span>&gt;::new()</span><br><span class="line">        .with_prompt(<span class="string">&quot;Enter your project description.(default: A new project)&quot;</span>)</span><br><span class="line">        .with_initial_text(<span class="string">&quot;A new project&quot;</span>.to_string())</span><br><span class="line">        .interact_text()</span><br><span class="line">        .unwrap_or(<span class="string">&quot;A new project&quot;</span>.to_string());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择项目类型</span></span><br><span class="line">    <span class="keyword">let</span> project_types = <span class="built_in">vec!</span>[ ProjectType::Cpp];</span><br><span class="line">    <span class="keyword">let</span> project_type_selection = Select::with_theme(&amp;theme)</span><br><span class="line">        .with_prompt(<span class="string">&quot;choose the peoject type&quot;</span>)</span><br><span class="line">        .items(&amp;project_types)</span><br><span class="line">        .interact()</span><br><span class="line">        .unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择生成目标类型</span></span><br><span class="line">    <span class="keyword">let</span> target_type = <span class="built_in">vec!</span>[</span><br><span class="line">        TargetType::Executable,</span><br><span class="line">        TargetType::StaticLibrary,</span><br><span class="line">        TargetType::DynamicLibrary,</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">let</span> target_type_selection = Select::with_theme(&amp;theme)</span><br><span class="line">        .with_prompt(<span class="string">&quot;choose the target type&quot;</span>)</span><br><span class="line">        .items(&amp;target_type)</span><br><span class="line">        .interact()</span><br><span class="line">        .unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择包管理器</span></span><br><span class="line">    <span class="keyword">let</span> package_manager_list = <span class="built_in">vec!</span>[PackageManager::VCPKG, PackageManager::CPM,PackageManager::<span class="literal">None</span>];</span><br><span class="line">    <span class="keyword">let</span> package_manager_selection = Select::with_theme(&amp;theme)</span><br><span class="line">        .with_prompt(<span class="string">&quot;choose the package manager &quot;</span>)</span><br><span class="line">        .items(&amp;package_manager_list)</span><br><span class="line">        .interact()</span><br><span class="line">        .unwrap();</span><br><span class="line">    <span class="keyword">let</span> package_manager = package_manager_list[package_manager_selection].clone();</span><br></pre></td></tr></table></figure><p>创建一个项目需要拷贝一些目录和文件,如果是目录注意不要重复创建,而文件可以直接truncate</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建src目录与main.cpp</span></span><br><span class="line"> <span class="keyword">match</span> fs::create_dir_all(root_dir.join(project_name).join(<span class="string">&quot;src&quot;</span>)) &#123;</span><br><span class="line">         <span class="literal">Ok</span>(_)=&gt;&#123;&#125;,</span><br><span class="line">         <span class="literal">Err</span>(e)=&gt;&#123;</span><br><span class="line">             eprintln!(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>,e.kind(),e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">         <span class="keyword">let</span> src_file = File::create(root_dir.join(project_name).join(<span class="string">&quot;src/main.cpp&quot;</span>)).unwrap();</span><br><span class="line">         <span class="keyword">match</span> fs::read_to_string(env::current_dir().unwrap().join(<span class="string">&quot;templates/main.cpp&quot;</span>)) &#123;</span><br><span class="line">             <span class="literal">Ok</span>(contents) =&gt; <span class="built_in">write!</span>(&amp;src_file, <span class="string">&quot;&#123;&#125;&quot;</span>, contents).unwrap(),</span><br><span class="line">             <span class="literal">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;Error reading file: &#123;&#125;&quot;</span>, e),</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>在<code>CMakeLists.txt</code>中,添加如下内容</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.29</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER <span class="string">&quot;C:/Program Files/LLVM/bin/clang.exe&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER <span class="string">&quot;C:/Program Files/LLVM/bin/clang++.exe&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="comment"># include($&#123;CMAKE_SOURCE_DIR&#125;/cmake/sanitier.cmake)</span></span><br><span class="line"><span class="keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cmake&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(sanitizer)</span><br><span class="line"><span class="keyword">include</span>(copy_target)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(@PROJECT_NAME@ LANGUAGES C CXX VERSION @PROJECT_VERSION@ PROJECT_DESCRIPTION <span class="string">&quot;@PROJECT_DESCRIPTION@&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">FILE</span>(GLOB_RECURSE LIB_SOURCE  src/*.cpp src/*.c)</span><br><span class="line"><span class="keyword">FILE</span>(GLOB_RECURSE HEADER  <span class="keyword">include</span>/*.h <span class="keyword">include</span>/*.hpp)</span><br><span class="line"><span class="keyword">source_group</span>(headers FILES <span class="variable">$&#123;HEADER&#125;</span>) </span><br><span class="line"><span class="keyword">add_library</span>(@PROJECT_NAME@ STATIC <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(@PROJECT_NAME@ PRIVATE <span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(ENABLE_SANITIZER <span class="string">&quot;Enable sanitizer&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">if</span>(ENABLE_SANITIZER)</span><br><span class="line">  add_sanitier(@PROJECT_NAME@)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(ENABLE_COPY_TARGET <span class="string">&quot;Enable copy target&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">if</span>(ENABLE_COPY_TARGET)</span><br><span class="line">  copy_target(@PROJECT_NAME@)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>针对包管理器,我设置了可以使用vcpkg或者cpm,如果是cpm可以在网上下载对应cmake脚本,如果是vcpkg,在<code>CMakePresets.json</code>中添加对应toolchainfile.</p><p>最后还有测试目录,cmake脚本,scripts辅助脚本,docs文档等等,如下</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> .gitignore</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> cmake</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> FindSomeLib.cmake</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> something_else.cmake</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> README.md</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> LICENCE.md</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> tests</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> CMakeLists.txt</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> testlib.cpp</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> docs</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> CMakeLists.txt</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> extern</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> googletest</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> scripts</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> helper.py</span></span><br></pre></td></tr></table></figure><h3 id="还不错的视频参考"><a href="#还不错的视频参考" class="headerlink" title="还不错的视频参考"></a>还不错的视频参考</h3><ol><li><a href="https://www.bilibili.com/video/BV1Z44y1c7UX">CMake, Tests and Tooling for C/C++ Projects</a></li><li><a href="https://www.bilibili.com/video/BV1Tr4y1Z762">Update to Modern C++</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近沉迷写c++以及cmake构建项目(不是吧,这也能沉迷?),主要关注的是一个项目的架构,以及一些辅助工具,比如生成文档,代码检查(sanitize)等,打算使用Rust写一个非常简单的c++项目的generator&lt;br&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://www.sekyoro.top/tags/Rust/"/>
    
    <category term="Cpp" scheme="https://www.sekyoro.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>xmake:另一个C++现代构建系统</title>
    <link href="https://www.sekyoro.top/2024/09/11/C-%E7%8E%B0%E4%BB%A3%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>https://www.sekyoro.top/2024/09/11/C-%E7%8E%B0%E4%BB%A3%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/</id>
    <published>2024-09-11T09:22:10.000Z</published>
    <updated>2024-09-14T10:42:43.084Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>主要起因是我在逛Reddit帖子时,看到关于一些c++构建系统的评价. cmake似乎有些过于复杂,它与vcpkg,conan的包管理之间的”融合”可能在有些时候也显得麻烦. 一些人尝试了我没见过的选项,</p><p>所以这里主要试试除了cmake之外的构建工具(这些选项中个人目前看好xmake),除了<a href="https://xmake.io/#/getting_started">xmake</a>之外,还有<a href="https://mesonbuild.com/">The Meson Build system</a>，<a href="https://spack.io/about/">About Spack - Spack</a>，<a href="https://bazel.google.cn/versions/7.3.0/about/intro?hl=zh-cn">Bazel 简介 (google.cn)</a>等等.我选择xmake主要原因是其自带的包管理和方便的写法<br><span id="more"></span></p><p>在进一步介绍xmake之前,有必要区分构建工具和包管理工具.c++目前常用的包管理工具有vcpkg,cpm以及conan,它们都有自己的registries,类似于node的npm,cargo的crates,python的pip registries,java的maven仓库. 都是社区或官方维护的库下载点,一般来允许用户注册后上传自己的包(不过考虑到c++生态是一堆轮子哥,用第三方库的人可能没有python,js一半多).</p><h2 id="纯纯FetchContent"><a href="#纯纯FetchContent" class="headerlink" title="纯纯FetchContent"></a>纯纯FetchContent</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## from https://cmakebyexample.dev/use-library-fetchcontent/</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.28</span>)</span><br><span class="line"><span class="keyword">project</span>(my-<span class="keyword">project</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(</span><br><span class="line">  cpr</span><br><span class="line">  GIT_REPOSITORY https://github.com/libcpr/cpr.git</span><br><span class="line">  <span class="comment"># https://github.com/libcpr/cpr/releases</span></span><br><span class="line">  GIT_TAG <span class="number">1.10</span>.<span class="number">4</span>)</span><br><span class="line">FetchContent_MakeAvailable(cpr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(my-app main.cpp)</span><br><span class="line"><span class="keyword">target_compile_features</span>(my-app PUBLIC cxx_std_20)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(my-app PRIVATE cpr::cpr)</span><br></pre></td></tr></table></figure><p>利用cmake内置功能,下载相应库.它需要从源代码构建curl.</p><blockquote><p>FetchContent 可让您直接在 CMake 项目中包含外部项目，从而更轻松地处理依赖关系，而无需用户单独下载和构建，或依赖系统级软件包管理器。它通过自动处理下载、构建和配置这些依赖项等任务，简化了将外部代码引入项目的过程。</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line"></span><br><span class="line">FetchContent_Declare(</span><br><span class="line">    my_dependency</span><br><span class="line">    GIT_REPOSITORY https://github.com/example/my_dependency.git</span><br><span class="line">    GIT_TAG v1.<span class="number">0.0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">FetchContent_MakeAvailable(my_dependency)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now you can use the components of &#x27;my_dependency&#x27; in your project</span></span><br></pre></td></tr></table></figure><h2 id="vcpkg"><a href="#vcpkg" class="headerlink" title="vcpkg"></a>vcpkg</h2><p>包仓库<a href="https://vcpkg.io/en/packages">Browse public vcpkg packages</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir myModule &amp;&amp; <span class="built_in">cd</span> myModule</span><br><span class="line">vcpkg --new application <span class="comment"># 创建应用</span></span><br></pre></td></tr></table></figure><p>在目录下生成了两个文件,<code>vcpkg.json</code>和<code>vcpkg-confuguration.json</code>分别用于存依赖信息和仓库信息.初始前者为空,后者</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;default-registry&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;git&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;baseline&quot;</span>: <span class="string">&quot;9760ce6194ef51aa4faf77b6321e1280daa4545c&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;repository&quot;</span>: <span class="string">&quot;https://github.com/microsoft/vcpkg&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;registries&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;artifact&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;https://github.com/microsoft/vcpkg-ce-catalog/archive/refs/heads/main.zip&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;microsoft&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认的 <code>vcpkg-configuration.json</code> 文件引入了基线约束，指定了项目应使用的依赖项的最小版本,将 <code>vcpkg-configuration.json</code> 添加到代码控制中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg add port fmt</span><br></pre></td></tr></table></figure><p>添加依赖信息,这里并没有下载包,所以直接引入头文件会报错的</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911180835085.png" alt="image-20240911180835085"></p><p>使用下面指令下载<code>vcpkg.json</code>中的包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install</span><br></pre></td></tr></table></figure><p>还会贴心提示在cmake中如何使用</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911181040866.png" alt="image-20240911181040866"></p><p>vcpkg官方推荐使用<code>CMakePresets.json</code>配置进行构建</p><blockquote><p>使用预设，项目的顶层目录必须包含名为 CMakePresets.json 或 CMakeUserPresets.json 的文 件。若两个文件都存在，将先解析 CMakePresets.json，再解析 CMakeUserPresets.json。这两个文件 有相同的格式，但使用方式略有不同</p></blockquote><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911181547753.png" alt="image-20240911181547753"></p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911181640286.png" alt="image-20240911181640286"></p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cmake</span> <span class="built_in">--listpresets</span> <span class="comment"># 列出写的预设</span></span><br><span class="line"><span class="string">cmake</span> <span class="built_in">--preset=name</span> <span class="comment">#选择某个预设</span></span><br></pre></td></tr></table></figure><p>其要求写入缓存变量<code>CMAKE_TOOLCHAIN_FILE</code>就是本机安装的<code>vcpkg.cmake</code>,</p><p>如果你设置了<code>VCPKG_ROOT</code>环境变量,可以使用”$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake”</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">&quot;configurePresets&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">       <span class="attr">&quot;displayname&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;generator&quot;</span>: <span class="string">&quot;Ninja&quot;</span>, # 构建工具</span><br><span class="line">      <span class="attr">&quot;binaryDir&quot;</span>: <span class="string">&quot;$&#123;sourceDir&#125;/build&quot;</span>, # 构建输出目录</span><br><span class="line">      <span class="attr">&quot;cacheVariables&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;CMAKE_TOOLCHAIN_FILE&quot;</span>: <span class="string">&quot;&lt;VCPKG_ROOT&gt;/scripts/buildsystems/vcpkg.cmake&quot;</span> #设置vcpkg工具链</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>version 字段指定要使用的 JSON 模式。版本 1 是 CMake 3.19 的第一个版本，只支持 configurePresets。版本 2 增加了 buildPresets 和 testPresets，CMake 3.20 开始支持; 版本 3 增加了 更多选项，CMake 3.21 开始支持。 可选的 cmakeMinimumRequired 字段可以用来定义构建此项目所需的 CMake 的最小版本。由于 最低要求通常也在 CMakeLists.txt 文件中说明，这通常会省略。 这三个列表:configurePresets、buildPresets 和 testPresets，每个列表都包含了用于配置、构建和 测试项目的配置。构建和测试的预置要求至少有一个配置预置，将在本节后面看到。 vendor 字段包含特定于供应商或 IDE 信息的可选映射。CMake 不解释该字段的内容</p><p>然后写上cmake文件,因为先使用preset会执行</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.23</span>)</span><br><span class="line"><span class="keyword">project</span>(HelloWorld)</span><br><span class="line"><span class="keyword">find_package</span>(fmt CONFIG REQUIRED) <span class="comment">#重点 find_package找包</span></span><br><span class="line"><span class="keyword">add_executable</span>(HelloWorld main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(HelloWorld PRIVATE fmt::fmt) <span class="comment">#进行链接</span></span><br></pre></td></tr></table></figure><p>执行<code>cmake --preset=name</code>会进行构建,如果没有安装相应库,也会安装.所以上面的<code>vcpkg install</code>就没必要执行了.</p><p>我在使用时遇到了找不到实现的问题,这貌似需要设置vcpkg triplet,网上有一些triplets模板,简单来说需要设置一系列vcpkg变量</p><ul><li><a href="https://stackoverflow.com/questions/74422058/how-to-use-vcpkg-with-clang-on-linux">How to use vcpkg with clang on linux? - Stack Overflow</a> 创建的自己的triplets<a href="https://learn.microsoft.com/zh-cn/vcpkg/users/examples/overlay-triplets-linux-dynamic">使用覆盖三联密码 | Microsoft Learn</a></li><li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/triplets.md">vcpkg/docs/users/triplets.md at master · microsoft/vcpkg (github.com)</a></li><li><a href="https://learn.microsoft.com/zh-cn/vcpkg/concepts/triplets">三元组 | Microsoft Learn</a>在windows默认的就是msvc的,难怪编译不过,我使用的时mingw…</li><li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/triplets.md">vcpkg/docs/users/triplets.md at master · microsoft/vcpkg (github.com)</a></li><li><a href="https://stackoverflow.com/questions/78962135/cmake-add-library-with-set-property-can-not-found-fmt-dll-on-windows/78962177?noredirect=1#comment139223613_78962177">c++ - cmake add_library with set_property can not found fmt dll on windows - Stack Overflow</a> 在windows上编译后将动态库拷贝一份到可执行程序同一个目录.<code>exe文件运行必须依赖同一目录(或者环境变量)下的dll</code></li></ul><p>一个简单的方法时设置<code>VCPKG_TARGET_TRIPLET</code>变量为”x64-mingw-dynamic”,表示使用mingw的动态库.或者使用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install fmt:x64-mingw-dynamic</span><br></pre></td></tr></table></figure><p>可以设置 <code>VCPKG_TARGET_TRIPLET</code>(需要下载和使用的库的架构)和<code>VCPKG_HOST_TRIPLET</code>(生成自己的库需要的构建架构)来设置target和host的架构,使用<code>VCPKG_OVERLAY_TRIPLETS</code>使用社区的.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg <span class="built_in">help</span> triplets </span><br></pre></td></tr></table></figure><p>查看官方和社区提供的triplets.</p><h3 id="Triplets"><a href="#Triplets" class="headerlink" title="Triplets"></a>Triplets</h3><p>triplets指定平台架构,并按照对应的架构去设置toolchain,默认是在vcpkg/triplets下找一个符合平台的,比如<code>vcpkg install xxx:abcd</code>,其中abcd就是一个triplets,设置好triplet后清单模式下就去下载相应的包</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912123855699.png" alt="image-20240912123855699" style="zoom:50%;" /></p><blockquote><p>更新:如果你只是想用clang++编译器,在<code>CMakeLists.txt</code>project指令之前指定即可</p></blockquote><p>用于交叉编译的,也就是在宿主机上编译不同平台架构的程序/库.</p><p>默认triplets</p><ul><li>Windows: <code>x64-windows</code></li><li>Linux: <code>x64-linux</code></li><li>OSX: <code>x64-osx</code></li></ul><p>可以分别指定target-triplet和host-triplet设置对应需要的工具链名称,会根据对应的名字去vcpkg/triplets找,或者使用overlay-triplets覆盖目录</p><p>以上的问题可以总结为</p><ol><li><p>使用clang需要配置triplets,可以使用社区的</p><p><a href="https://github.com/microsoft/vcpkg/issues/38042">How to compile vcpkg libraries using Clang? · Issue #38042 · microsoft/vcpkg (github.com)</a></p><p><a href="https://learn.microsoft.com/zh-cn/vcpkg/users/examples/overlay-triplets-linux-dynamic">使用覆盖三联密码 | Microsoft Learn</a></p><p><a href="https://github.com/Neumann-A/my-vcpkg-triplets/tree/master">Neumann-A/my-vcpkg-triplets: my collection of vcpkg triplets (github.com)</a></p></li></ol><p>我注意到社区中的triplets中很多使用了<code>VCPKG_CHAINLOAD_TOOLCHAIN_FILE</code>指定要使用的备用 CMake 工具链文件,如果设置将替代所有其他编译器检测逻辑.默认情况下工具链文件是从 <code>scripts/toolchains/</code> 适合平台选择的,使用<code>--overlay-triplets</code>选择一个目录进行覆盖<a href="https://learn.microsoft.com/zh-cn/vcpkg/users/examples/overlay-triplets-linux-dynamic">使用覆盖三联密码 | Microsoft Learn</a></p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911232109031.png" alt="image-20240911232109031"></p><blockquote><p>CMake 使用工具链实用程序来编译、link libraries和创建archives，并执行其他任务来进行构建。</p><p>可用的工具链由启用的语言决定。在正常编译中，<strong>CMake 会根据系统自省和默认值自动为主机编译确定工具链</strong>。在交叉编译情况下，可指定一个包含编译器和工具路径信息的工具链文件</p></blockquote><p>下面信息很重要,cmake在project()指令处查找可用的工具链,在<code>CMAKE_TOOLCHAIN_FILE</code>中处理vcpkg逻辑,其中将默认调用合适的vckpg/scripts/toolchains/中的toolchain</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911232412863.png" alt="image-20240911232412863"></p><ol><li>在windows上使用vcpkg安装得到的动态库如果想要自己放在一个统一的3rdparty目录,include目录和bin目录中再自己设置link</li></ol><p>需要放在可执行程序目录下,可以通过设置路径解决</p><p><a href="https://blog.csdn.net/Tracker647/article/details/142070768">CMake+MinGW+vcpkg项目引入三方库的两种方式（手动路径，vcpkg）-CSDN博客</a></p><p><a href="https://stackoverflow.com/questions/78962135/cmake-add-library-with-set-property-can-not-found-fmt-dll-on-windows/78962177?noredirect=1#comment139223613_78962177">c++ - cmake add_library with set_property can not found fmt dll on windows - Stack Overflow</a>注意需要设置链接的.lib和.dll库,通过<code>IMPORTED_IMPLIB</code>设置输出的.lib库</p><blockquote><ul><li><strong>IMPORTED_LOCATION</strong>：用于存储导入库的实际文件路径，通常是共享库或可执行文件的位置。</li><li><strong>IMPORTED_IMPLIB</strong>：用于存储导入库（导入库 .lib 文件）的路径，通常在 Windows 平台上使用。</li></ul></blockquote><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911230257291.png" alt="image-20240911230257291"></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(HelloWorld)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;CMAKE_SOURCE_DIR: $&#123;CMAKE_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(HelloWorld main.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(fmt SHARED IMPORTED)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> fmt PROPERTY IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="number">3</span>rdparty/fmt_x64-mingw-dynamic/bin/libfmt.dll)</span><br><span class="line"><span class="comment"># 改变导入库的.dll的位置</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(fmt INTERFACE <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="number">3</span>rdparty/fmt_x64-mingw-dynamic/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(HelloWorld fmt)</span><br><span class="line"><span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> HelloWorld POST_BUILD     <span class="comment">#-for copy libs in windows</span></span><br><span class="line">            <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy_if_different </span><br><span class="line">            <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="number">3</span>rdparty/fmt_x64-mingw-dynamic/bin/libfmt.dll </span><br><span class="line">            <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/build)</span><br><span class="line">            <span class="comment"># 将输出动态库放在build目录下</span></span><br></pre></td></tr></table></figure><p>需要添加设置<code>IMORTED_IMPLIB</code>路径</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(fmt SHARED IMPORTED)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> fmt PROPERTY</span><br><span class="line">  IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="number">3</span>rdparty/fmt_x64-mingw-dynamic/bin/libfmt.dll</span><br><span class="line">  IMORTED_IMPLIB <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="number">3</span>rdparty/fmt_x64-mingw-dynamic/lib/libfmt.lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>注意,使用vcpkg自动引入需要设置build_type,这样第三方库的动态库.dll就放在对应位置不用改了.</p></blockquote><p>使用vcpkg时注意,</p><ol><li>设置<code>CMAKE_TOOLCHAIN_FILE</code>要在project指令之前</li></ol><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911224541731.png" alt="image-20240911224541731"></p><ol><li>使用find_package(xxx <strong>CONFIG</strong> REQUIRED)</li><li>推荐使用preset</li><li>设置<code>CMAKE_EXPORT_COMPILE_COMMANDS</code>为ON让clangd检测头文件目录</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build -S /my/project --preset debug</span><br></pre></td></tr></table></figure><p>除了下载包之外,也有打包、发布等常用功能,已经满足常用需求了,cmake本身有cpack,但没有vcpkg提供的一些发布功能</p><p>要创建vcpkg包,首先创建manifest清单文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;libogg&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version-string&quot;</span>: <span class="string">&quot;1.3.3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Ogg is a multimedia container format, and the native file and stream format for the Xiph.org multimedia codecs.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目<code>vcpkg.json</code>中写上包内容,然后创建<code>portfile.cmake</code>,修改下面的配置</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vcpkg_from_github(</span><br><span class="line">    OUT_SOURCE_PATH SOURCE_PATH</span><br><span class="line">    REPO xiph/ogg</span><br><span class="line">    <span class="keyword">REF</span> v1.<span class="number">3.3</span></span><br><span class="line">    SHA512 <span class="number">0</span>bd6095d647530d4cb1f509eb5e99965a25cc3dd9b8125b93abd6b248255c890cf20710154bdec40568478eb5c4cde724abfb2eff1f3a04e63acef0fbbc9799b</span><br><span class="line">    HEAD_REF <span class="keyword">master</span></span><br><span class="line"><span class="title">)</span></span><br></pre></td></tr></table></figure><p>用于GitHub存储库路径的REPO,用于使用稳定标签/提交的REF，以及带有下载文件校验和的SHA512,别人使用时也使用vcpkg下载</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vcpkg_cmake_configure(SOURCE_PATH <span class="variable">$&#123;SOURCE_PATH&#125;</span>)</span><br><span class="line">vcpkg_cmake_install()</span><br><span class="line"><span class="keyword">file</span>(<span class="keyword">INSTALL</span> <span class="string">&quot;$&#123;SOURCE_PATH&#125;/COPYING&quot;</span> DESTINATION <span class="string">&quot;$&#123;CURRENT_PACKAGES_DIR&#125;/share/libogg&quot;</span> RENAME copyright)</span><br></pre></td></tr></table></figure><p>缺点就是微软文档实在烂,不是翻译的问题,英文原文的用词像是东拼西凑,感觉像是不停换人写出来的.</p><h2 id="CPM-cmake"><a href="#CPM-cmake" class="headerlink" title="CPM.cmake"></a>CPM.cmake</h2><p>轻量的包管理工具<a href="https://github.com/cpm-cmake/CPM.cmake">cpm-cmake/CPM.cmake: 📦 CMake’s missing package manager. A small CMake script for setup-free, cross-platform, reproducible dependency management. (github.com)</a>,基于cmake的FetchContent.</p><p>你只需要<code>include</code>提供的<code>cpm.cmake</code>文件即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p cmake</span><br><span class="line">wget -O cmake/CPM.cmake https://github.com/cpm-cmake/CPM.cmake/releases/latest/download/get_cpm.cmake</span><br></pre></td></tr></table></figure><p>此外也可以在cmake文件中下载</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># download CPM.cmake</span></span><br><span class="line"><span class="keyword">file</span>(</span><br><span class="line">  DOWNLOAD</span><br><span class="line">  https://github.com/cpm-cmake/CPM.cmake/releases/download/v0.<span class="number">38.3</span>/CPM.cmake</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/cmake/CPM.cmake</span><br><span class="line">  EXPECTED_HASH SHA256=cc155ce02e7945e7b8967ddfaff0b050e958a723ef7aad3766d368940cb15494</span><br><span class="line">)</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/cmake/CPM.cmake)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add dependencies here</span></span><br><span class="line">CPMAddPackage(...)</span><br><span class="line"></span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>然后就能直接使用了,</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CPMAddPackage(</span><br><span class="line">  NAME          <span class="comment"># The unique name of the dependency (should be the exported target&#x27;s name)</span></span><br><span class="line">  VERSION       <span class="comment"># The minimum version of the dependency (optional, defaults to 0)</span></span><br><span class="line">  PATCHES       <span class="comment"># Patch files to be applied sequentially using patch and PATCH_OPTIONS (optional)</span></span><br><span class="line">  OPTIONS       <span class="comment"># Configuration options passed to the dependency (optional)</span></span><br><span class="line">  DOWNLOAD_ONLY <span class="comment"># If set, the project is downloaded, but not configured (optional)</span></span><br><span class="line">  [...]         <span class="comment"># Origin parameters forwarded to FetchContent_Declare, see below</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>来源可以由 GIT_REPOSITORY 指定，但也支持其他来源，如一般的URL。如果没有明确指定 GIT_TAG，则默认为 v(VERSION)，这是 git 项目的通用约定。另一方面，如果没有明确指定 VERSION，在某些常见情况下，CPM 可以根据 git 标签自动识别版本。GIT_TAG 也可以设置为特定的提交或分支名称（如 master），但不建议这样做，因为这样的软件包只有在缓存被清除时才会被更新</p><p>如果将附加的可选参数 EXCLUDE_FROM_ALL 设为真,则默认情况下不会编译依赖关系中定义的任何目标.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A git package from a given uri with a version</span></span><br><span class="line">CPMAddPackage(<span class="string">&quot;uri@version&quot;</span>)</span><br><span class="line"><span class="comment"># A git package from a given uri with a git tag or commit hash</span></span><br><span class="line">CPMAddPackage(<span class="string">&quot;uri#tag&quot;</span>)</span><br><span class="line"><span class="comment"># A git package with both version and tag provided</span></span><br><span class="line">CPMAddPackage(<span class="string">&quot;uri@version#tag&quot;</span>)</span><br></pre></td></tr></table></figure><p>与findpackage差别,在 CMake 项目中添加库的通常方法是调用 find_package(\<PackageName>)，并与 \<PackageName>_LIBRARIES 变量中定义的库进行链接。这种方法虽然简单，<strong>但可能会导致无法预测的编译，因为它需要在系统中安装库，而且不清楚添加的是哪个版本的库</strong>。此外，<strong>交叉编译项目（如mobile项目）也很困难</strong>，因为需要针对每个目标架构手动重建依赖关系。</p><p>CPM.cmake 允许明确定义依赖关系，并从源代码构建依赖关系。请注意，该行为不同于 find_package，因为使用 CPM.cmake 添加软件包后，导出到父作用域的变量（如 \<PackageName>_LIBRARIES ）将不可见。如果需要，可以手动实现该行为<a href="https://github.com/cpm-cmake/CPM.cmake/issues/132">find_package and CPMFindPackage have different behaviors · Issue #132 · cpm-cmake/CPM.cmake (github.com)</a>。</p><p>与fech_content差别,CPM.cmake 会检查任何添加的依赖项的版本号，如果另一个依赖项需要更新版,则会发出警告。<br>离线编译： CPM.cmake 将覆盖 CMake 的下载和更新命令，如果本地有所有依赖项，则可在离线状态下配置新的构建。<br>自动浅层克隆：如果提供了版本标签（如 v2.2.0）并使用了 CPM_SOURCE_CACHE，CPM.cmake 将执行依赖关系的浅层克隆，这应比完全克隆更快，同时使用的存储空间更少。可重写：通过设置 CMake 标志，所有 CPMAddPackage 都可配置为使用 find_package，从而轻松集成到可能需要通过系统的软件包管理器进行本地版本控制的项目中。软件包锁定文件可实现更简便的跨依赖关系管理。<br>每次编译时，可使用 CMake CLI 参数覆盖依赖关系。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.28</span>)</span><br><span class="line"><span class="keyword">project</span>(my-<span class="keyword">project</span>)</span><br><span class="line"><span class="keyword">include</span>(cmake/CPM.cmake)</span><br><span class="line">CPMAddPackage(<span class="string">&quot;gh:fmtlib/fmt#10.2.0&quot;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(my-app main.cpp)</span><br><span class="line"><span class="keyword">target_compile_features</span>(my-app PRIVATE cxx_std_20)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(my-app fmt::fmt)</span><br></pre></td></tr></table></figure><p>上面的就使用<code>CPMAddPackage</code>添加了github上的fmtlib作者的fmt库,版本10.2.0</p><p>更多例子<a href="https://github.com/cpm-cmake/CPM.cmake/tree/master/examples">CPM.cmake/examples at master · cpm-cmake/CPM.cmake (github.com)</a></p><h2 id="CONAN"><a href="#CONAN" class="headerlink" title="CONAN"></a>CONAN</h2><p>这里做简单介绍,conan有仓库中心<a href="https://conan.io/center">Conan 2.0: C and C++ Open Source Package Manager</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install conan</span><br></pre></td></tr></table></figure><p>在项目中创建<code>conanfile.txt</code>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[requires]</span><br><span class="line">zlib/1.2.11</span><br><span class="line"></span><br><span class="line">[generators]</span><br><span class="line">CMakeDeps</span><br><span class="line">CMakeToolchain</span><br></pre></td></tr></table></figure><p>generators表示将使用CMakeDeps来生成关于Zlib库文件安装位置的信息，CMakeToolchain通过CMake工具链文件传递构建信息给CMake</p><p>此外还要创建conan profile,里面提供本机系统信息,</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conan profile detect --force</span><br></pre></td></tr></table></figure><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912092357159.png" alt="image-20240912092357159"></p><p>生成的信息可以修改,比如改编译器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conan install . --output-folder=build --build=missing</span><br></pre></td></tr></table></figure><p>安装库,在build目录下会生成preset和conan_toolchain.cmake文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(compressor C)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(ZLIB REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> src/main.c)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> ZLIB::ZLIB)</span><br></pre></td></tr></table></figure><p>再写个cmake文件,链接库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"><span class="comment"># assuming Visual Studio 15 2017 is your VS version and that it matches your default profile</span></span><br><span class="line">cmake .. -G <span class="string">&quot;Visual Studio 15 2017&quot;</span> -DCMAKE_TOOLCHAIN_FILE=<span class="string">&quot;conan_toolchain.cmake&quot;</span></span><br><span class="line">cmake --build . --config Release</span><br></pre></td></tr></table></figure><p>利用toolchain文件导入包. </p><p>上面讲的都是包管理工具(实际上脱离不了相应的构建工具),最大的问题就是两者分开了,但事实上完全可以放在一起,就像rust的cargo,<code>cargo build</code>,<code>cargo add</code></p><h2 id="xmake"><a href="#xmake" class="headerlink" title="xmake"></a>xmake</h2><p>xmake包括了自带的构建工具和包管理,也有项目创建工具的功能.xmake使用lua配置. xmake create创建项目,可以选择语言和模板(竟然还包括zig)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake create --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912100635482.png" alt="image-20240912100635482"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake create -P hello</span><br></pre></td></tr></table></figure><p>创建好后目录下有<code>xmake.lua</code>,使用xmake即可直接构建.<code>xmake run hello</code>运行程序,</p><p>在<code>xmake.lua</code>中常见配置就是创建可执行程序,库,添加头文件,设置语言标准等.</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;library&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;shared&quot;</span>) # 设置生成的类型</span><br><span class="line">    add_files(<span class="string">&quot;src/library/*.c&quot;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_deps(<span class="string">&quot;library&quot;</span>) # 添加依赖</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此外<code>add_headerfiles</code>添加头文件,<code>set_languages</code>设置语言版本.</p><p><code>xmake f -p</code>表示配置架构</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmake config -m debug xmake`</span><br><span class="line">xmake run -d hello</span><br></pre></td></tr></table></figure><p>可以进行debug</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake f -p [macosx|linux|iphoneos ..] -a [x86_64|i386|arm64 ..] -m [debug|release]</span><br></pre></td></tr></table></figure><p>使用xmake配置项目,注意编译器设置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake f -p linux --sdk=/user/toolsdk --cxx=armv7-linux-clang++</span><br></pre></td></tr></table></figure><p>我在windows上使用clang++工具,配置llvm工具链即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmake f -p cross --toolchain=llvm --sdk=<span class="string">&quot;C:\Program Files\LLVM&quot;</span> </span><br><span class="line">xmake</span><br><span class="line">xmake run hello</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake -v <span class="comment"># 验证工具链配置</span></span><br></pre></td></tr></table></figure><p>或者使用mingw</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake f -p mingw</span><br></pre></td></tr></table></figure><p>xmake官方有<code>`xmake-repo</code>仓库用于下载包,</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;tbox 1.6.*&quot;</span>, <span class="string">&quot;libpng ~1.16&quot;</span>, <span class="string">&quot;zlib&quot;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;tbox&quot;</span>, <span class="string">&quot;libpng&quot;</span>, <span class="string">&quot;zlib&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面配置从官方仓库中添加了依赖,执行<code>xmake</code>进行构建,会拉取相关的源包，然后自动编译安装，最后编译项目，并链接依赖包,此外还可以设置第三方依赖,从vcpkg,conan等地方</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;vcpkg::zlib&quot;</span>, <span class="string">&quot;vcpkg::pcre2&quot;</span>)</span><br></pre></td></tr></table></figure><p>此外还有独立的xrepo可用于下载包,可以指定平台,版本等,支持从vcpkg,conan中搜索下载.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xrepo install zlib tbox </span><br><span class="line">xrepo install <span class="string">&quot;zlib &gt;=1.2.0&quot;</span> </span><br><span class="line">xrepo install -p iphoneos -a arm64 zlib</span><br><span class="line">xrepo install vcpkg::zlib </span><br><span class="line">xrepo install conan::zlib/1.2.11 </span><br></pre></td></tr></table></figure><p>我写了下面<code>xmake.lua</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">add_requires(<span class="string">&quot;fmt&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">add_files(<span class="string">&quot;src/*.cpp&quot;</span>)</span><br><span class="line">add_packages(<span class="string">&quot;fmt::fmt&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果说vcpkg重点是选好triplet、toolchainfile,那么xmake也是配好toolchain</p><p>我直接配置<code>xmake f -p windows</code>使用msvc能成功build,如果要使用clang,配置好平台和工具链即可,相比vcpkg要好一些,vcpkg官方对clang/llvm貌似没有那么上心,官方triplet都没有,只能用社区的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmake f -p windows  --toolchain=clang-cl </span><br><span class="line">xmake f -p windows  --toolchain=clang <span class="comment">#或者</span></span><br></pre></td></tr></table></figure><p><code>xmake show -l toolchains</code>查看所有的toolchains</p><p>或者在<code>xmake.lua</code>中使用</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_plat(<span class="built_in">os</span>.host())</span><br><span class="line">set_arch(<span class="built_in">os</span>.arch())</span><br><span class="line">set_toochains(<span class="string">&quot;clang&quot;</span>)</span><br><span class="line"># 或者直接统一设置</span><br><span class="line">set_toochains(<span class="string">&quot;clang&quot;</span>,&#123;palt=<span class="built_in">os</span>.host(),arch=<span class="built_in">os</span>.arch()&#125;)</span><br></pre></td></tr></table></figure><p>目前还存在头文件无法识别的问题</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912121858364.png" alt="image-20240912121858364" style="zoom:50%;" /></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake project -k compile_commands</span><br></pre></td></tr></table></figure><p>参考作者给出的解决<a href="https://github.com/xmake-io/xmake-vscode/issues/40">支持为vscode-cpptools提供intellisense配置信息 · Issue #40 · xmake-io/xmake-vscode (github.com)</a>生成<code>compile_commands.json</code>包含编译器,工作目录和头文件目录等信息.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmake project -k vsxmake -m <span class="string">&quot;debug,release&quot;</span> <span class="comment"># New vsproj generator (Recommended)</span></span><br><span class="line">xmake project -k vs -m <span class="string">&quot;debug,release&quot;</span></span><br><span class="line">xmake project -k cmake</span><br><span class="line">xmake project -k ninja</span><br><span class="line">xmake project -k compile_commands</span><br></pre></td></tr></table></figure><p>因为目前就langd和vscode的intellisense能检测文件中头文件目录信息等,需要这个文件</p><p>使用下来的体验就是写起来比cmake用的轻松,文档写的案例也比较全面.但是因为没有深度使用,一些细节不知道怎样.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因为我已经在很多项目中使用了cmake,经验相对更多,xmake学习起来并不困难,搭配官方文档很容易搭建一个项目.</p><p>但目前还是推荐使用cmake+vcpkg/cpm.cmake方案,因为更成熟,解决方案更多.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要起因是我在逛Reddit帖子时,看到关于一些c++构建系统的评价. cmake似乎有些过于复杂,它与vcpkg,conan的包管理之间的”融合”可能在有些时候也显得麻烦. 一些人尝试了我没见过的选项,&lt;/p&gt;
&lt;p&gt;所以这里主要试试除了cmake之外的构建工具(这些选项中个人目前看好xmake),除了&lt;a href=&quot;https://xmake.io/#/getting_started&quot;&gt;xmake&lt;/a&gt;之外,还有&lt;a href=&quot;https://mesonbuild.com/&quot;&gt;The Meson Build system&lt;/a&gt;，&lt;a href=&quot;https://spack.io/about/&quot;&gt;About Spack - Spack&lt;/a&gt;，&lt;a href=&quot;https://bazel.google.cn/versions/7.3.0/about/intro?hl=zh-cn&quot;&gt;Bazel 简介 (google.cn)&lt;/a&gt;等等.我选择xmake主要原因是其自带的包管理和方便的写法&lt;br&gt;</summary>
    
    
    
    
    <category term="c++ build" scheme="https://www.sekyoro.top/tags/c-build/"/>
    
  </entry>
  
  <entry>
    <title>Dear-ImGUI:不太一样的GUI</title>
    <link href="https://www.sekyoro.top/2024/09/11/Dear-ImGUI-%E4%B8%8D%E5%A4%AA%E4%B8%80%E6%A0%B7%E7%9A%84GUI/"/>
    <id>https://www.sekyoro.top/2024/09/11/Dear-ImGUI-%E4%B8%8D%E5%A4%AA%E4%B8%80%E6%A0%B7%E7%9A%84GUI/</id>
    <published>2024-09-11T07:00:54.000Z</published>
    <updated>2024-09-14T09:36:28.556Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>之前介绍过Qt,作为c++界面(事实上不只是界面,Qt本身已经成了写C++的一种工具了)工具,采用的是创建控件然后绑定事件处理的逻辑,与winform,WPF等都是类似的,但是这里介绍一种不太一样的GUI库,其使用immediate mode,也就是在每一帧进行处理,没有保留状态维护. 在游戏界面开发中受到热捧.<br><span id="more"></span></p><p>这种立即模式可能受到一些游戏开发的喜爱,ImGui<a href="https://github.com/ocornut/imgui">ocornut/imgui: Dear ImGui: Bloat-free Graphical User interface for C++ with minimal dependencies (github.com)</a>直到最近还不停有commit,Unity也采用了类似模式构建控件<a href="https://docs.unity.cn/cn/2019.4/Manual/gui-Basics.html">IMGUI 基础知识 - Unity 手册</a>. 在Rust也有<a href="https://github.com/emilk/egui">emilk/egui: egui: an easy-to-use immediate mode GUI in Rust that runs on both web and native (github.com)</a>,Go也有<a href="https://gioui.org/">Gio UI</a>.</p><p>下面写个简单的ImGUI程序学习学习.</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>我们把GUI分成了retained mode和immediate mode</p><p><img data-src="https://learn.microsoft.com/en-us/windows/win32/learnwin32/images/graphics06.png" alt="a diagram that shows retained-mode graphics."></p><p>保留模式(retained mode) API 是声明式的。应用程序通过图形基元（如形状和线条）构建场景。图形库将场景模型存储在内存中。要绘制帧，图形库会将场景转换为一组绘图命令。在帧与帧之间，图形库会将场景保存在内存中。要更改渲染的内容，应用程序会发出更新场景的命令，例如添加或删除一个形状。然后图形库负责重新绘制场景。</p><p><img data-src="https://learn.microsoft.com/en-us/windows/win32/learnwin32/images/graphics07.png" alt="a diagram that shows immediate-mode graphics."></p><p>即时模式 API (immediate mode)是程序性的。每次绘制新帧时，应用程序都会直接发出绘制命令。图形库不会在帧与帧之间存储场景模型。相反，应用程序会跟踪场景</p><p>保留模式 API 使用起来可能更简单，因为 API 会为您完成更多工作，如初始化、状态维护和清理。另一方面，它们通常灵活性较差，因为 API 强加了自己的场景模型。此外，保留模式 API 对内存的要求可能更高，因为它需要提供通用场景模型。使用即时模式 API，您可以实现有针对性的优化。</p><p>此外注意到还有DirectUI的说法,区分win32窗体<a href="https://www.zhihu.com/question/20580684"> DirectUI与GUI框架有什么区别，如MFC，QT，wxWidgets的区别是什么？ - 知乎 (zhihu.com)</a></p><blockquote><p>系统窗口的消息路由是操作系统负责的，比如按钮上的消息就会被自动分发给按钮的窗口过程。而DirectUI这类框架创建的窗口的消息是由应用程序负责的路由的，无论你点击了窗口中哪个按钮，消息统统分发给单一的窗口过程，它再根据鼠标的坐标判决应该由哪个对象进一步处理消息</p></blockquote><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>imgui背后需要调用图形backend和窗体调用. 它提供了几种不同的头文件,包括win32(窗体)+direcx11/12(图形api),glfw+opengl,sdl+opengl,glfw+vulkan等等.</p><p>这里我使用glfw+opengl.</p><p>你可以在在对应的官方仓库下载源码或者预编译包链接使用,但是为了更方便地使用,可以直接使用包管理器vcpkg等下载然后再cmake中加上两句即可. vcpkg具体使用可以参考<a href="https://www.sekyoro.top/2024/09/11/C-现代构建系统/#more">xmake:另一个C++现代构建系统 | Sekyoro的博客小屋</a>.</p><p>简单来说就是</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir project &amp;&amp; <span class="built_in">cd</span> project</span><br><span class="line">vcpkg new --application</span><br><span class="line">vcpkg add port opengl</span><br><span class="line">cmake install <span class="comment"># 如果在cmakepresets中设置好了直接cmake --preset=&lt;preset_name&gt;即可</span></span><br><span class="line">cmake --build build</span><br></pre></td></tr></table></figure><p>然后在<code>main.cpp</code>添加相应代码,执行程序</p><p><img data-src="https://s2.loli.net/2024/09/14/IdSPbTwpMn5U1XC.png" alt="image-20240914172255349"></p><blockquote><p>很多时候一些c++程序员喜欢把源码下载到本地然后进行编译,得到的库统一放在vendor/3rd_party目录,但是利用现代工具(vcpkg,conan等)可以方便地进行交叉编译(在宿主机上通过不同工具链得到其他架构的库/可执行程序),何乐而不为呢?</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://github.com/ocornut/imgui">ocornut/imgui: Dear ImGui: Bloat-free Graphical User interface for C++ with minimal dependencies (github.com)</a></p></li><li><p><a href="https://blog.codingnow.com/2020/07/game_ui.html">云风的 BLOG: 游戏 UI 模块的选择 (codingnow.com)</a></p><p>如果你不想使用Qt庞然大物,也不想使用提供内置功能太少的界面库,可以试试SFML<a href="https://www.sfml-dev.org/">SFML (sfml-dev.org)</a>.</p></li><li><p><a href="https://tulach.cc/writing-gui-apps-for-windows-is-painful/">Writing GUI apps for Windows is painful - Samuel Tulach</a>一篇介绍windows上桌面程序开发框架选择的文章,提到了winui3,qt以及使用其他技术栈链接.dll库,比如wpf等.事实上我已经多次谈论界面开发/桌面开发/移动端开发,注意一个事实,一些库不只是用于界面绘制的,除去界面绘制,一些基本工具库的提供往往也非常有必要.所以在windows下使用微软带来的生态是很好的(wpf,maui,winui3等),在移动端下使用compose也很舒服.还有Flutter也吃Dart的生态. 此外也有很多使用web的技术,比如electron,tauri,<a href="https://pywebview.flowrl.com/">pywebview (flowrl.com)</a></p><p>很多时候没有必要考虑跨平台的需求(那就做web).</p><p>(delphi和lazarus有谁用过?)<a href="https://www.zhihu.com/question/54905309">用 Lazarus 做 GUI 程序合适吗？ - 知乎 (zhihu.com)</a></p></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前介绍过Qt,作为c++界面(事实上不只是界面,Qt本身已经成了写C++的一种工具了)工具,采用的是创建控件然后绑定事件处理的逻辑,与winform,WPF等都是类似的,但是这里介绍一种不太一样的GUI库,其使用immediate mode,也就是在每一帧进行处理,没有保留状态维护. 在游戏界面开发中受到热捧.&lt;br&gt;</summary>
    
    
    
    
    <category term="GUI" scheme="https://www.sekyoro.top/tags/GUI/"/>
    
  </entry>
  
  <entry>
    <title>cs144:intro to computer network</title>
    <link href="https://www.sekyoro.top/2024/09/01/cs144-intro-to-computer-network/"/>
    <id>https://www.sekyoro.top/2024/09/01/cs144-intro-to-computer-network/</id>
    <published>2024-09-01T11:50:34.000Z</published>
    <updated>2024-09-12T12:47:21.943Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>开始计划做点计算机课程lab,涉及到操作系统、并行分布式系统,计算机网络,数据库系统等等.<br><span id="more"></span></p><p>代码lian’jie<a href="https://github.com/drowning-in-codes/build-my-own-x/tree/main/cs144">build-my-own-x/cs144 at main · drowning-in-codes/build-my-own-x (github.com)</a></p><h2 id="Lab0"><a href="#Lab0" class="headerlink" title="Lab0"></a>Lab0</h2><p>第一个项目minnow,看看<code>CMakeLists.txt</code>,写得是真的好.</p><p>首先确保generator必须是Unix Makefiles,然后保证out of build(也就是src和build目录不同,使用cmake -B build)</p><p>然后添加其他辅助cmake脚本,这里通过<code>include</code>指令添加,应该是为了访问父作用域的变量. 然后添加头文件目录,最后使用<code>add_subdirectory</code>添加需要编译的子项目.每个目录下都是一个<code>CMakeLists.txt</code>,设置<code>CMAKE_EXPORT_COMPILE_COMMANDS</code>得到编译指令(也是为了搭配一些编辑器使用).光是CmakeLists.txt就学到很多c++项目组织的知识.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.24</span>.<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(minnow CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$&#123;CMAKE_GENERATOR&#125;</span> <span class="keyword">STREQUAL</span> <span class="string">&quot;Unix Makefiles&quot;</span>)</span><br><span class="line">  <span class="keyword">set</span>(CMAKE_MAKE_PROGRAM <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/scripts/make-parallel.sh&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span> <span class="keyword">STREQUAL</span> <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>)</span><br><span class="line">  <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Minnow must be built outside its source directory, e.g. `cmake -B build`.&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(etc/build_type.cmake)</span><br><span class="line"><span class="keyword">include</span>(etc/cflags.cmake)</span><br><span class="line"><span class="keyword">include</span>(etc/scanners.cmake)</span><br><span class="line"><span class="keyword">include</span>(etc/tests.cmake)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/util&quot;</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/src&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/util&quot;</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/src&quot;</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/tests&quot;</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/apps&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure><p>在添加的cmake脚本中,包括设置构建类型的(Debug或Release),一些编译器设置,clang-tidy和format用于语法提示和格式化,以及一些测试.</p><p>在代码中,许多c++17和20新东西都用上了,比如string_view,span等,</p><p>第一次作业要求写一个bytestream的reader和writer,分别读取和写入字节流. 我看了一些网上的实现,太吓人了,还使用<code>`std::deque</code>等容器,根本没必要,还可能在提交测试时出现heap overflow. 直接使用string即可,熟悉一下一些STL常用操作.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;byte_stream.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ByteStream::<span class="built_in">ByteStream</span>(<span class="keyword">uint64_t</span> capacity) : <span class="built_in">capacity_</span>(capacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Writer::is_closed</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> _is_closed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Writer::push</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  std::<span class="keyword">size_t</span> data_len = data.<span class="built_in">length</span>();</span><br><span class="line">  std::<span class="keyword">size_t</span> avai_cap = <span class="keyword">this</span>-&gt;<span class="built_in">available_capacity</span>();</span><br><span class="line">  <span class="keyword">if</span> (data_len &gt;= avai_cap) &#123;</span><br><span class="line">    _buffer.<span class="built_in">insert</span>(_buffer.<span class="built_in">end</span>(), data.<span class="built_in">begin</span>(), data.<span class="built_in">begin</span>() + avai_cap);</span><br><span class="line">    push_counts += avai_cap;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _buffer.<span class="built_in">insert</span>(_buffer.<span class="built_in">end</span>(), data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>());</span><br><span class="line">    push_counts += data_len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Writer::close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  _is_closed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">Writer::available_capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> capacity_ - _buffer.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">Writer::bytes_pushed</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> push_counts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Reader::is_finished</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> _is_closed &amp;&amp; _buffer.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">Reader::bytes_popped</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> pop_counts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string_view <span class="title">Reader::peek</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">if</span> (_buffer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  string_view sv&#123;&amp;*_buffer.<span class="built_in">begin</span>(), _buffer.<span class="built_in">size</span>()&#125;;</span><br><span class="line">  <span class="keyword">return</span> sv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reader::pop</span><span class="params">(<span class="keyword">uint64_t</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">if</span> (_buffer.<span class="built_in">size</span>() &lt;= len) &#123;</span><br><span class="line">    pop_counts += _buffer.<span class="built_in">size</span>();</span><br><span class="line">    _buffer.<span class="built_in">clear</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _buffer.<span class="built_in">assign</span>(_buffer.<span class="built_in">begin</span>() + len, _buffer.<span class="built_in">end</span>());</span><br><span class="line">    pop_counts += len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">Reader::bytes_buffered</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> _buffer.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/09/03/7M1R6WH3g8iKQdc.png" alt="image-20240903120538215"></p><blockquote><p>后面我看到有人使用queue\<string>,效果还不错.所以我又改了😅</p><p>逻辑是每次push数据,都是推一个新的string,如果没有超过容量直接推,如果超了就截断后再推.</p><p>pop数据时,如果queue中string数据长度大于len,就不需要将该数据pop掉,而是设置为removed_prefix,方便peek时返回. 如果小于等于,就将其推掉再看下一个string的长度.</p></blockquote><h2 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h2><p>第一个实验就折磨了我很久,写一个对乱序(是指的发送的数据段的序列是乱的,数据段substring内部是顺序的)的字节流进行重排的reassembler.</p><p><img data-src="https://s2.loli.net/2024/09/06/gJCwbV4RtfLrW9j.png" alt="image-20240906172137248"></p><p>重点就是上面的图,绿色加红色的段落是固定长度并且只会往右移动到发送过来的数据最大长度.</p><p>如果来的数据段first_index为first_unasembled_index,那就说明来对了.但是在push到bytestream之前,需要注意可能有重叠部分,</p><p><img data-src="https://s2.loli.net/2024/09/06/cgsVmdDfLGSXWBj.png" alt="image-20240906172716413"></p><p>比如上面有重叠部分,需要截断数据,比较好的方法是将incoming data前面没有重叠的部分取出来作为新的数据,后面准备直接push到bytestream</p><p><img data-src="https://s2.loli.net/2024/09/06/RvQ3uFjrKMeIVwX.png" alt="image-20240906173236584"></p><p>有人就要问了,为啥不直接将这段数据直接都推进去,就像下图中红框这样,如果像上面那样截断,不就要后面多推一次吗？</p><p><img data-src="https://s2.loli.net/2024/09/06/84oJBaVHhO1PkDj.png" alt="image-20240906173340799"></p><p>理论上来说也是可行的,包括也可以像下面这样截断,但隐含的问题是,这两种方法后面的数据都有可能overlap.</p><p><img data-src="https://s2.loli.net/2024/09/06/wGFBxXy8jOcgWkr.png" alt="image-20240906173540255"></p><p>而像第一种截断方法中绿色那一段数据就不会有overlap.  而且后面的数据重复段可能不止一个,需要连续处理知道处理完后面的所有数据或者部分重叠.</p><p>如果是完全重叠,就可以直接删掉这段,比如下面的红色段数据.</p><p><img data-src="https://s2.loli.net/2024/09/06/UjCw2PEJ9mtbeAp.png" alt="image-20240906174432079"></p><p>除了对后面的数据做截断,针对排在前面的数据也是类似. 注意,在这里并没有对超过first_unaccepted_index的数据段进行截取.</p><p><img data-src="https://s2.loli.net/2024/09/06/letiLN4d5mMpsHS.png" alt="image-20240906173933135"></p><p>总的来说,首先需要对数据的first_index和大小进行调整,比如截断啥的. 使得它没有与其他数据段重叠.</p><p>然后就是判断更新后的first_index与first_unassemble_index,如果相等,push数据(由于在上一节push的实现中,如果数据长度大于capacity,就只会将数据填满,超过的数据忽略),否则放在一个map<uint64_t,string>中,称为substrings,注意这里有多种选择,你可以将其超过first_unassemble_index的段截断,也可以先直接推进去,后面再处理,但为了节省内存,可以直接先截断.</p><p>可能到这里有人以为已经结束了,但当推送了某个数据之后,可能后面的substrings就能使用上了,就需要进行处理.如果是next_assembled_idx(其实就是first_unassemble_idx==bytes_pushed),就继续推,因为前面存substrings中的数据时已经考虑到了截断超过first_unassemble_index的数据,数据长度加起来肯定小于容量,这里直接推进去就行了.</p><p><img data-src="https://s2.loli.net/2024/09/06/Czik8Pc4KM2rBHE.png" alt="image-20240906173613597" style="zoom:50%;" /></p><h2 id="Lab2"><a href="#Lab2" class="headerlink" title="Lab2"></a>Lab2</h2><blockquote><p>TCP是一种协议，它在不可靠的数据报上可靠地传输一对流控制的字节流(每个方向一个)。双方或“peers”参与TCP连接，每个peers都充当(其自身输出字节流的)“发送者”和“接收者”</p></blockquote><p><img data-src="https://s2.loli.net/2024/09/06/nzAsKGwy4xWNqH3.png" alt="image-20240906180021011"></p><p>首先需要实现一个32-bit的相对索引wrapper与64位绝对索引相互转换.</p><p><img data-src="https://s2.loli.net/2024/09/06/dD4tQgeqRLTm8vj.png" alt="image-20240906234140049"></p><p>而注意在接受的数据段(stream index),是直接从0开始,不包括SYN的.</p><p>从接收到的absolute seqno-&gt;seqno,也就是从64位转为32位,比较简单,可以采取取余或者直接<code>static_cat&lt;uint32_t&gt;</code>即可,相当于把多出的截断.从seqno-&gt;absolute seqno,有非常多可能,比如假设seqno-zero_point的值是144,那么就有可能是144+GAP*k,其中GAP是<code>1UL&lt;&lt;32</code>. 所以需要一个值帮助确定,checkpoint就是这个值,离它最近的就是这个absolute seqno. 需要做的就是求k. k是(checkpoint-absolute seqno)/(1UL&lt;&lt;32)的四舍五入值.  但是要注意,如果checpoint&lt;absolute seqno,上面的公式就会出问题.</p><p>当checpoint&lt;absolute seqno时,直接返回<code>seqno-zero_point</code>即可.</p><p>在此基础上需要实现TCP receiver.</p><p>它将(1)从peer的发送方接收消息并使用Reassembler重新组装字节流</p><p>(2)将包含确认号(ackno)和窗口大小的消息发送回peer的发送方.</p><p>注意SYN和FIN并不包含在数据payload中,但是在计算ackno时需要加上相应的值以确定需要的数据index. </p><p>接收到数据时,如果带有SYN则对应的seqno就是zero_point(并不是数据的开始,zero_point+1才是数据),我们本身需要的是发过来的数据在absolute seqno中的索引,但这个值我们无法确定,checkpoint可以设置为bytes_pushed也就是first_unassembled_index,因为这是我们需要的值.在获得absolute seqno后还需要-1除去SYN,然后再insert数据. 如果writer关闭则设置FIN关闭,方便后面send及时关闭.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCPSenderMessage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Wrap32 seqno &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">bool</span> SYN &#123;&#125;;</span><br><span class="line">std::string payload &#123;&#125;;</span><br><span class="line"><span class="keyword">bool</span> FIN &#123;&#125;;</span><br><span class="line"><span class="keyword">bool</span> RST &#123;&#125;;</span><br><span class="line"><span class="comment">// How many sequence numbers does this segment use?</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">sequence_length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> SYN + payload.<span class="built_in">size</span>() + FIN; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCPReceiverMessage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">std::optional&lt;Wrap32&gt; ackno &#123;&#125;;</span><br><span class="line"><span class="keyword">uint16_t</span> window_size &#123;&#125;;</span><br><span class="line"><span class="keyword">bool</span> RST &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPReceiver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Construct with given Reassembler</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">TCPReceiver</span><span class="params">( Reassembler&amp;&amp; reassembler )</span> : reassembler_( std::move( reassembler ) ) &#123;</span>&#125;</span><br><span class="line"><span class="comment">// The TCPReceiver receives TCPSenderMessages from the peer&#x27;s TCPSender.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">( TCPSenderMessage message )</span></span>;</span><br><span class="line"><span class="comment">// The TCPReceiver sends TCPReceiverMessages to the peer&#x27;s TCPSender.</span></span><br><span class="line"><span class="function">TCPReceiverMessage <span class="title">send</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">// Access the output (only Reader is accessible non-const)</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> Reassembler&amp; <span class="title">reassembler</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> reassembler_; &#125;</span><br><span class="line"><span class="function">Reader&amp; <span class="title">reader</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reassembler_.<span class="built_in">reader</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Reader&amp; <span class="title">reader</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> reassembler_.<span class="built_in">reader</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Writer&amp; <span class="title">writer</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> reassembler_.<span class="built_in">writer</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Reassembler reassembler_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在send中,需要返回ackno和window_size,后者就是writer().available_capacity(),但注意如果初始化时超过了就设置MAX.</p><p>前者就是目前接收到的数据加上标志位.</p><p>发送数据时首先初始化SYN作为开始位置,开始位置之后的一个位置是数据位置.发送数据时携带这个标志和数据payload,同时每次只允许最多发送uint_32_t数据,所以发送数据时需要将原本64位的索引转成32位</p><blockquote><p>在TCP报头中，空间是宝贵的，流中的每个字节的索引不是用64位索引表示，而是用32位的“序列号”或“seqno”表示。这增加了复杂性</p></blockquote><p><img data-src="https://s2.loli.net/2024/09/07/gE7IOc6ZdzyKbel.png" alt="image-20240907145920140"></p><p>当接收者拿到32位的相对索引时如何知道在绝对位置上的索引呢<img data-src="https://s2.loli.net/2024/09/07/HRkMqCVI5ApihuJ.png" alt="image-20240907151332005"></p><p>关键是确定checkpoint,因为absolute seqno可能是k*GAP+offset,offset是小于GAP的.</p><p>假设如下图,如果此时发送一个之前的重复段,实际的absolute seqno比较小,如果使用bytes_pushed,那么可能会导致得到的first_index比较大. 出现这种情况的前提是,bytes_pushed&gt;uint32_t,因为此时会有多个可能的绝对位置,如果再发送之前的数据,那么absolute seqno的first_index就会选择错误.</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240907152015454.png" alt="image-20240907152015454"></p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240907155828700.png" alt="image-20240907155828700"></p><p>当我尝试这么测试时,要么报错oom要么timeout.</p><h2 id="Lab3"><a href="#Lab3" class="headerlink" title="Lab3"></a>Lab3</h2><p>实现TcpSender.在文档中需要要点都说了.但是有些细节还是容易忘.</p><p>首先在push方法中,什么时候发送数据?</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240908231650614.png" alt="image-20240908231650614"></p><p>只要有可读数据并且空余的window_size就能使用transmit读取数据.什么叫做空余的window_size,只要window_size大于0就能发送数据吗,事实上并不是,比如如果我连续发送了很多数据,但是window_size一直为0,我还需要不断发送直到读完所有数据吗,貌似也是可行的. 更好的方式是window_size如果小于outstanding_bytes的数量,那就先等着,直到接收到peer发来的ackno更新window_size.  每次发送的数据就是window_size-outstanding_bytes,但是有个MAX_PAYLOAD_SIZE的限制,另外注意发送的数据大小是包含SYN的,也就是说如果是开始的数据,window_size =100,那么只能发送99个数据.payload大小是99.</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240907171424559.png" alt="image-20240907171424559"></p><p>如何确定sender需要发送FIN？</p><p>首先reader需要结束,也就是reader().is_finished() (注意不是bytes_bufferd==0,还需要reader关闭,因为还没有关闭时也有可能存在buffer为空的情况).此外剩余的数据已经小于window_size-outstanding_bytes(相当于peer还剩的空间).</p><p>然后发送数据,开启计时同时增加发送的index和outstanding_bytes,保存发送的信息. 当接收到ackno和window_size时进行更新窗口大小,并根据ackno删除数据,如果确实超过了保留数据的ackno+seq_len,那就更新ack_abs_seqno,此外重新设置timer,如果清空了outstanding_byte_stream,那就关闭定时器,否则还是打开但需要重置时间.tick方法计时器超时并且还有重传数据时,发送最早的重传数据,重置timer,如果window_size不为0,double重传时间,重传次数+1,背后的逻辑可能是,如果window_size为0,表示peer没有什么要接受的,没有那么急</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240908234129034.png" alt="image-20240908234129034"></p><p>注意,当window_size为0时,说明peer没有需要的数据了,但如果依然能发送(&gt;outstanding_bytes),就需要多发送1byte数据来查看peer还能否扩展空间.如果没有数据了就不发了. </p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240908235508628.png" alt="image-20240908235508628"></p><p>想象一下,如果peer依然发送window_size=0,在tick中我们就会不断重试,直到超过次数然后退出.</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240908235847377.png" alt="image-20240908235847377" style="zoom:50%;" /></p><h2 id="Lab4"><a href="#Lab4" class="headerlink" title="Lab4"></a>Lab4</h2><p>使用之前的工具进行数据分析.无代码</p><h2 id="Lab5"><a href="#Lab5" class="headerlink" title="Lab5"></a>Lab5</h2><p>在有了TCP实现之后,还需要怎么封装才能传输信息?</p><ul><li>TCP-in-UDP-in-IP:TCP段可以在用户数据报的有效载荷中携带。在正常(用户空间)设置中工作时，这是最容易实现的:Linux提供了一个接口(“数据报套接字”，UDPSocket)，它允许应用程序只提供用户数据报的有效载荷和目标地址，内核负责构造UDP报头、IP报头和以太网报头，然后将数据包发送到适当的下一跳</li><li>内核确保每个套接字具有本地和远程地址和端口号的独占组合，并且由于内核负责将这些写入UDP和IP头，因此它可以保证不同应用程序之间的隔离</li><li>TCP-in-IP:在通常的用法中，TCP段几乎总是直接放在互联网数据报中，在IP和TCP头之间没有UDP头。这就是人们所说的“TCP/IP”.“这有点难以实施。Linux提供了一个称为TUN设备的接口，它允许应用程序提供一个完整的Internet数据报，内核负责其余的工作(写入以太网头，并实际通过物理以太网卡发送，等等)。但是应用程序必须自己构造完整的IP报头，而不仅仅是有效负载</li><li>TCP-in-IP-in-Ethernet: 在上述方法中仍然依赖Linux内核来实现部分网络堆栈。每次代码向TUN设备写入IP数据报时，Linux都必须用IP数据报作为有效负载构建一个适当的链路层(以太网)帧。这意味着Linux必须找出下一跳以太网目的地址，给定下一跳的IP地址。如果不知道,Linux广播一个查询:“谁声明了以下内容?IP地址?以太网地址是什么?，然后等待回复。这些功能由网络接口执行:一个将出站IP数据报转换为链路层(例如，以太网)帧的组件，反之亦然。(在实际系统中，网络接口通常有eth0、eth1、wlan0等名称)</li></ul><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240908231059785.png" alt="image-20240908231059785" style="zoom: 50%;" /></p><p>这一节说白了就是实现简单的ARP,保存IP地址与MAC(以太网)地址映射.</p><p>关键是两个方法,接受数据和发送数据.对于发送数据,如果在映射表中,那就直接发送,如果不在,那就需要发送arp消息,但前提是之前没有发送过或者发送后超过了一定时间,发送arp消息后timer置0.注意发送的arp请求消息中,目标以太网地址为0,广播地址在以太网地址字段中而不是arp中.arp消息是payload,以太网头是header.然后将要发送的消息和next_hop保存,等接受到相应的地址后再发送.对于接受消息,如果数据是ip数据报并且目标ip是自己,就接受消息并且更新映射表,如果是新的映射设置timer,否则不管.然后看新的映射是否跟保存的消息的目标ip相同,相同则发送.如果是arp消息,也更新映射与timer,如果是请求就发送自己的ip.否则根据更新的映射发送消息. 在tick中更新timer,并且如果超时就删除对应映射. 需要注意的是,什么时候需要开启timer,什么时候删除.</p><p>发送了arp消息时需要设置为0,接收到arp回应时删除对应arp请求的ip记录. 接收到新的映射时开启timer,超过30s后删除映射表和timer. </p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240910202737584.png" alt="image-20240910202737584" style="zoom:67%;" /></p><h2 id="Lab6"><a href="#Lab6" class="headerlink" title="Lab6"></a>Lab6</h2><p>一个router有几个网络接口，可以在其中任何一个接口上接收Internet数据报.</p><p>router的工作是根据路由表转发它收到的数据报:路由表是一个规则列表，它告诉router，对于任何给定的数据报，</p><p>•发送哪个接口</p><p>•下一跳IP地址</p><p>实现一个路由器，它可以为给定的数据报得到这两个东西。</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240910204547680.png" alt="image-20240910204547680"></p><p>这里本身逻辑并不复杂,写一个路由表记录ip掩码和掩码后的地址,对应下一跳地址和interface. 首先遍历interface,拿到消息队列,对于每个消息ttl的ttl如果小于等于1,直接丢掉,否则拿去匹配路由表中,找到最长匹配的ip地址.</p><p>我一开始使用的路由表结构是map,但是发现一直过不了,改成multimap就过了,说明有重复的key,我的结构体如下,如果有重复key,表明掩码长度.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_addr</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> masked_ipaddr&#123;&#125;; #掩码后的地址</span><br><span class="line"><span class="keyword">uint8_t</span> prefix_length&#123;&#125;; # 前缀长度</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> ip_addr&amp; ip_) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> prefix_length &lt; ip_.prefix_length;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由两种解决方法,要么使用multimap允许重复key,要么将&lt;比较操作为修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> masked_ipaddr&#123;&#125;;</span><br><span class="line">    <span class="keyword">uint8_t</span> prefix_length&#123;&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> ip_addr&amp; ip_) <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(prefix_length != ip_.prefix_length) &#123;</span><br><span class="line">        <span class="keyword">return</span> prefix_length&lt;ip_.prefix_length;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> masked_ipaddr&lt;ip_.masked_ipaddr;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>c++20增加了<code>&lt;=&gt;</code>操作符和 std::strong_ordering,std::weak_ordering<br>,std::partial_ordering. 定义一个默认的<code>&lt;=&gt;</code>操作符基本就能允许所有比较,实在是太酷啦! 比较顺序与类中声明成员的顺序一致.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  std::string name&#123;&#125;;</span><br><span class="line">  <span class="keyword">double</span> value&#123;&#125;;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span>&lt;=&gt;(<span class="keyword">const</span> Person &amp;) <span class="keyword">const</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person p1&#123;.name = <span class="string">&quot;张三&quot;</span>, .value = <span class="number">12.</span>&#125;, p2&#123;.name = <span class="string">&quot;李四&quot;</span>, .value = <span class="number">13.</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;我们都一样&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lab7"><a href="#Lab7" class="headerlink" title="Lab7"></a>Lab7</h2><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912173600895.png" alt="image-20240912173600895"></p><p>lab7也是测试</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912200347129.png" alt="image-20240912200347129"></p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912200356663.png" alt="image-20240912200356663"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次计算机网络实验,从一开始的bytestream,到reassember,再到tcpsender,reader,最后写路由分配ip数据报. </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/Kiprey/sponge/tree/master">Kiprey/sponge: CS144 Lab Assignments (github.com)</a></li><li><a href="https://github.com/Kenshin2438/CS144">Kenshin2438/CS144: CS 144: Introduction to Computer Networking, Winter 2024 (github.com)</a></li><li><a href="https://cs144.github.io/">CS 144: Introduction to Computer Networking</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;开始计划做点计算机课程lab,涉及到操作系统、并行分布式系统,计算机网络,数据库系统等等.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>dive deeper into functional programming</title>
    <link href="https://www.sekyoro.top/2024/08/17/dive-deeper-into-functional-programming/"/>
    <id>https://www.sekyoro.top/2024/08/17/dive-deeper-into-functional-programming/</id>
    <published>2024-08-17T06:49:47.000Z</published>
    <updated>2024-08-29T12:43:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>我们在许多编程语言中都能看到一些函数式编程,其最初起源于大学实验室、数学推理的思想,虽然在目前大型软件的源代码中相对OOP编程并没有那么多,但是在一些核心数据处理中利用函数式编程能一定程度上保证程序正确性.这里使用<a href="https://ocaml.org/">ocaml.org</a>学习函数式编程.</p><span id="more"></span><p>相对来说,ocaml,elixir,scala以及clojure等在工业界用得比其他语言要多一点,主要原因个人认为还是对于大数据、多线程的处理以及语法上的可读性.  学习这些语言能帮助扩展思维以及在其他现代的编程语言中,你很可能会看见类似的设计和思想.</p><p>函数式语言的设计往往非常优雅严谨,以此达到编写正确优美的代码.下面以ocaml作介绍.</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>OCaml语法的主要部分是表达式。就像命令式语言中的程序主要由命令构建一样，函数式语言中的程序主要由表达式构建。表达式的例子包括2+2和increment 21</p><p>在函数式语言中，计算的主要任务是将表达式求值为一个值。值是一个表达式，它不需要执行任何计算。所以，<strong>所有的值都是表达式，但不是所有的表达式都是值</strong>。值的例子包括2、true和”yay!”</p><h3 id="Assertions"><a href="#Assertions" class="headerlink" title="Assertions"></a>Assertions</h3><p>表达式assert e求e的值。如果结果为真，则不再发生任何事情，整个表达式的求值为一个名为unit的特殊值。unit写作()，类型为unit。但如果结果为false，则会引发异常。</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="literal">()</span> = <span class="keyword">assert</span> (f input1 = output1)</span><br><span class="line"><span class="keyword">let</span> <span class="literal">()</span> = <span class="keyword">assert</span> (f input2 = output2)</span><br><span class="line"><span class="keyword">let</span> <span class="literal">()</span> = <span class="keyword">assert</span> (f input3 = output3)</span><br></pre></td></tr></table></figure><h3 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h3><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">3</span> + <span class="number">5</span> &gt; <span class="number">2</span> <span class="keyword">then</span> <span class="string">&quot;yay!&quot;</span> <span class="keyword">else</span> <span class="string">&quot;boo!&quot;</span></span><br></pre></td></tr></table></figure><h3 id="let表达式"><a href="#let表达式" class="headerlink" title="let表达式"></a>let表达式</h3><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">42</span> <span class="keyword">in</span> x + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>注意<code>let x = 42;;</code>是定义而不是表达式</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(** [fact n] is [n!].</span></span><br><span class="line"><span class="comment">    Requires: [n &gt;= 0]. *)</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> fact n = <span class="keyword">if</span> n = <span class="number">0</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> n * fact (n - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> inc x = x + <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> inc = <span class="keyword">fun</span> x -&gt; x + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h3><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">square (inc <span class="number">5</span>);;</span><br><span class="line"><span class="number">5</span> |&gt; inc |&gt; square;;</span><br></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>这是在其他编程语言中非常常见的,包括map,filter,fold等等操作</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(** [add1 lst] adds 1 to each element of [lst]. *)</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> add1 = <span class="keyword">function</span></span><br><span class="line">  | <span class="literal">[]</span> -&gt; <span class="literal">[]</span></span><br><span class="line">  | h :: t -&gt; (h + <span class="number">1</span>) :: add1 t</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lst1 = add1 [<span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> map f = <span class="keyword">function</span></span><br><span class="line">  | <span class="literal">[]</span> -&gt; <span class="literal">[]</span></span><br><span class="line">  | h :: t -&gt; f h :: map f t</span><br><span class="line"></span><br><span class="line"><span class="comment">(** [add1 lst] adds 1 to each element of [lst]. *)</span></span><br><span class="line"><span class="keyword">let</span> add1 = map (<span class="keyword">fun</span> x -&gt; x + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">(** [concat_bang lst] concatenates &quot;!&quot; to each element of [lst]. *)</span></span><br><span class="line"><span class="keyword">let</span> concat_bang = map (<span class="keyword">fun</span> x -&gt; x ^ <span class="string">&quot;!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p x = print_int x; print_newline<span class="literal">()</span>; x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lst = map p [<span class="number">1</span>; <span class="number">2</span>]</span><br></pre></td></tr></table></figure><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> filter p = <span class="keyword">function</span></span><br><span class="line">  | <span class="literal">[]</span> -&gt; <span class="literal">[]</span></span><br><span class="line">  | h :: t -&gt; <span class="keyword">if</span> p h <span class="keyword">then</span> h :: filter p t <span class="keyword">else</span> filter p t</span><br></pre></td></tr></table></figure><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> combine op init = <span class="keyword">function</span></span><br><span class="line">            | <span class="literal">[]</span> -&gt; init</span><br><span class="line">            | h::t -&gt; op h (combine op init t)</span><br><span class="line"><span class="keyword">let</span> sum = combine ( + ) <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> concat = combine (^) <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="primitive-types和values"><a href="#primitive-types和values" class="headerlink" title="primitive types和values"></a>primitive types和values</h2><p>基本类型是内置的和最基本的类型:整数、浮点数、字符、字符串和布尔值。它们将被识别为类似于其他编程语言中的基本类型.</p><p>除了上面之外,Ocaml还有许多东西,但我也就止于此了.目前我主要关注的还高阶函数</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://cs3110.github.io/textbook/chapters/intro/past.html">1.1. The Past of OCaml — OCaml Programming: Correct + Efficient + Beautiful (cs3110.github.io)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在许多编程语言中都能看到一些函数式编程,其最初起源于大学实验室、数学推理的思想,虽然在目前大型软件的源代码中相对OOP编程并没有那么多,但是在一些核心数据处理中利用函数式编程能一定程度上保证程序正确性.这里使用&lt;a href=&quot;https://ocaml.org/&quot;&gt;ocaml.org&lt;/a&gt;学习函数式编程.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>CUDA101</title>
    <link href="https://www.sekyoro.top/2024/08/16/CUDA101/"/>
    <id>https://www.sekyoro.top/2024/08/16/CUDA101/</id>
    <published>2024-08-16T10:23:41.000Z</published>
    <updated>2024-08-29T12:43:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>作为既对AI又对sys、hpc感兴趣的人来说,cuda编程应该是不可不看的,我也早有耳闻.这里简单学习一下.<br><span id="more"></span></p><p>目前AI大模型的推理以及AI+HPC、深度学习系统构建等都需要了解cuda以及使用cuda编程,通过使用cuda、c++以及pybind写一些深度学习算子等提升运行速度都是一些常见应用途径.</p><h2 id="介绍CUDA"><a href="#介绍CUDA" class="headerlink" title="介绍CUDA"></a>介绍CUDA</h2><blockquote><p><a href="https://www.geeksforgeeks.org/how-to-run-cuda-c-c-on-jupyter-notebook-in-google-colaboratory/">CUDA</a> stands for Compute Unified Device Architecture. It is an extension of C/C++ programming. CUDA is a programming language that uses the Graphical Processing Unit (GPU). It is a parallel computing platform and an API (Application Programming Interface) model, Compute Unified Device Architecture was developed by Nvidia. This allows computations to be performed in parallel while providing well-formed speed. Using CUDA, one can harness the power of the Nvidia GPU to perform common computing tasks, such as processing matrices and other linear algebra operations, rather than simply performing graphical calculations.</p></blockquote><p><img data-src="https://media.geeksforgeeks.org/wp-content/uploads/20211007112954/UntitledDiagram1.jpg" alt="img" style="zoom:67%;" /></p><ul><li>上图展示了16个并行(流)多(streaming multiprocessor)处理块(digrams)</li><li>每个并行多处理块有8个并行处理器(streanming processors),所以一共128个并行处理器</li><li>每个并行处理器有一个乘加单元 (Multiplication and Addition Unit)和一个加单元(multiplication unit).</li><li>一张GT200显卡有30个并行多处理器,每个处理器有8个并行处理器,所以一共240个并行处理器,有多余1的TFLOP处理能力</li><li>每个流处理器都是线程，每个应用程序可以运行数千个线程</li><li>G80卡有16个流多处理器(SMs)，每个SM有8个流处理器(SPs)，即总共128个SPs，每个流多处理器支持768个线程(注意:不是每个SP)。</li><li>最终，每个流式多处理器有 8 个 SP 后，每个 SP 最多支持 <strong>768/8 = 96 个线程</strong>。可在 128 个 SP 上运行的线程总数 - 128* 96 = 12 228 次(=16*768)</li><li>因此，这些处理器被称为大规模并行处理器(massively parallel)。</li><li>G80 芯片的内存带宽为 86.4GB/s。</li><li>G80 芯片的内存带宽为 86.4GB/s，与 CPU 之间的通信通道为 8GB/s（4GB/s 上传到 CPU RAM，4GB/s 从 CPU RAM 下载）。</li></ul><h4 id="CUDA工作"><a href="#CUDA工作" class="headerlink" title="CUDA工作"></a>CUDA工作</h4><ul><li>GPU 一次运行一个内核（一组任务）。</li><li>每个内核由独立的 ALU 组块组成。</li><li>每个区块包含线程，线程是计算的层次。</li><li>每个块中的线程通常共同计算一个值。</li><li>同一区块中的线程可以共享内存。</li><li>在 CUDA 中，从 CPU 向 GPU 发送信息通常是计算中最典型的部分。</li><li>对每个线程而言，本地内存速度最快，共享内存次之，全局、静态和纹理内存速度最慢。</li></ul><h4 id="CUDA以及工作流程"><a href="#CUDA以及工作流程" class="headerlink" title="CUDA以及工作流程"></a>CUDA以及工作流程</h4><ul><li>将数据加载到 CPU 内存</li><li>将数据从 CPU 复制到 GPU 内存 - 例如，cudaMemcpy(…, cudaMemcpyHostToDevice)</li><li>使用设备变量调用 GPU 内核 - 例如，kernel&lt;&lt;&lt;&gt;&gt; (gpuVar)</li><li>将结果从 GPU 复制到 CPU 内存 - 例如，cudaMemcpy(…, cudaMemcpyDeviceToHost)</li><li>在 CPU 上使用结果</li></ul><h2 id="编写CUDA代码"><a href="#编写CUDA代码" class="headerlink" title="编写CUDA代码"></a>编写CUDA代码</h2><p>需要在Nvidia显卡下安装cudatoolkit,以使用nvcc编译器和一些库.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__global__ void cuda_hello()&#123;</span><br><span class="line">    printf(&quot;Hello World from GPU!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cuda_hello&lt;&lt;&lt;1,1&gt;&gt;&gt;(); </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_<em>global_</em>说明符表示在设备(GPU)上运行的函数.这样的函数可以通过宿主代码调用,例如示例中的main()函数,也被称为“<em>kernel</em>”</p><p>当调用内核时，它的执行配置通过&lt;&lt;&lt;…&gt;&gt;&gt;语法，例如cuda_hello&lt;&lt;<1,1>&gt;&gt;()。在CUDA术语中，这被称为“<em>kernel launch</em>”</p><p>CPU和GPU是独立的实体。它们都有自己的内存空间。CPU不能直接访问GPU内存，反之亦然。在CUDA术语中，CPU内存称为主机内存，GPU内存称为设备内存。指向CPU和GPU内存的指针分别称为主机指针和设备指针.</p><p>对于GPU可以访问的数据，它必须呈现在设备内存中。CUDA提供了用于分配设备内存和主机与设备内存之间数据传输的api。</p><ol><li>分为宿主内存给宿主数据</li><li>分配设备内存</li><li>将输入数据从宿主内存转到设备内存</li><li>执行kernels(_<em>global\</em>_标识 )</li><li>将输出从设备转移到宿主</li></ol><p>CUDA提供了几个用于分配设备内存的函数。最常见的是<code>cudaMalloc()</code>和<code>cudaFree()</code></p><p>分配了GPU内存后需要将cpu内存上的数据copy到设备上,利用<code>cudaMemcpy</code></p><p>然后调用kernel(内核执行配置&lt;<1,1>&gt;&gt;表示内核启动时只有1个线程),在设备上执行,最后进行free<code>cudaFree(void *devPtr);</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cudaMalloc(void **devPtr, size_t count);</span><br><span class="line">cudaFree(void *devPtr);</span><br><span class="line">cudaMemcpy(void *dst, void *src, size_t count, cudaMemcpyKind kind)</span><br></pre></td></tr></table></figure><h4 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h4><p>NVIDIA提供了一个名为nvprof的命令行分析器工具，它可以更深入地了解CUDA程序的性能。</p><p>CUDA使用内核执行配置&lt;&lt;&lt;…&gt;&gt;&gt;告诉CUDA<strong>运行时在GPU上启动多少线程</strong></p><p>CUDA将线程组织成一个称为“thread block”的组。内核可以启动多个线程块，组织成一个“grid”结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt; <span class="string">M , T &gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>表示启动M个线程块,每个线程块包括T个线程.</p><h4 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h4><p>CUDA为访问线程信息提供了内置变量。其中的<code>threadIdx.x</code>和<code>blockDim.x</code>分别表示,一个块内线程的索引以及一个块中线程数量.</p><p>假设在一个块内的多个线程执行并行程序.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__global__ void vector_add(float *out, float *a, float *b, int n) &#123;</span><br><span class="line">    int index = 0;</span><br><span class="line">    int stride = 1</span><br><span class="line">    for(int i = index; i &lt; n; i += stride)&#123;</span><br><span class="line">        out[i] = a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://cuda-tutorial.readthedocs.io/en/latest/tutorials/tutorial02/01_parallel_thread.png" alt="parallel thread"></p><p>假设N个数据,一共256个线程,那么对于第k个线程,它会执行N/256次iteration,每次执行kernel中的代码</p><h4 id="thread-blocks"><a href="#thread-blocks" class="headerlink" title="thread blocks"></a>thread blocks</h4><p>CUDA gpu有几个并行处理器，称为流多处理器或SMs。每个SM由多个并行处理器组成，可以运行多个并发线程块。为了利用CUDA gpu，内核应该启动多个线程块。</p><p>对于block,有<code>blockIdx.x</code>以及<code>gridDim.x</code>分别表示块索引和块的数量.</p><p><img data-src="https://cuda-tutorial.readthedocs.io/en/latest/tutorials/tutorial02/02_parallel_block.png" alt="parallel block"></p><p>要将线程分配给特定元素，我们需要知道每个线程的唯一索引。该指数可计算如下</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int tid <span class="operator">=</span> blockIdx.<span class="keyword">x</span> * blockDim.<span class="keyword">x</span> + threadaddx.<span class="keyword">x</span></span><br></pre></td></tr></table></figure><p>为了利用并行多线程的优势(否则就是多个线程计算相同的代码),需要将对应的数据索引修改为线程的索引.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#define N 100000</span><br><span class="line">__global__ void addOfblocks(int n, float *x, float *y) &#123;</span><br><span class="line">  int idx = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">  int stride = blockDim.x * gridDim.x;</span><br><span class="line">  for (int i = idx; i &lt; n; i += stride) y[i] = x[i] + y[i];</span><br><span class="line">&#125;</span><br><span class="line">__global__ void addOfThreads(int n, float *x, float *y) &#123;</span><br><span class="line">  int idx = threadIdx.x;</span><br><span class="line">  int stride = blockDim.x;</span><br><span class="line">  for (int i = idx; i &lt; n; i += blockDim) y[i] = x[i] + y[i];</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">  float *a, *out;</span><br><span class="line"></span><br><span class="line">  cudaMallocManaged(&amp;a, N * sizeof(float));</span><br><span class="line">  cudaMallocManaged(&amp;out, N * sizeof(float));</span><br><span class="line">  for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">    a[i] = 2;</span><br><span class="line">    b[i] = 4;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add&lt;&lt;&lt;2, 4&gt;&gt;&gt;(N, a, b);</span><br><span class="line">  cudaDeviceSynchronize();</span><br><span class="line"></span><br><span class="line">  cudaFree(a);</span><br><span class="line">  cudaFree(b);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#define N 10000000</span><br><span class="line">__global__ void vector_add(float* out, float* a, float* b, int n) &#123;</span><br><span class="line">  int stride = 1;</span><br><span class="line">  for (int i = 0; i &lt; n; i += stride) &#123;</span><br><span class="line">    out[i] = a[i] + b[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__global__ void cuda_hello() &#123;</span><br><span class="line">  printf(&quot;Hello from block %d, thread %d\n&quot;, blockDim.x, threadIdx.x);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">  cuda_hello&lt;&lt;&lt;1, 4&gt;&gt;&gt;();</span><br><span class="line">  float *a, *b, *out;</span><br><span class="line">  float *d_a, *d_b, *d_out;</span><br><span class="line">  a = (float*)malloc(N * sizeof(float));</span><br><span class="line">  b = (float*)malloc(N * sizeof(float));</span><br><span class="line">  for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">    a[i] = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">    b[i] = 4;</span><br><span class="line">  &#125;</span><br><span class="line">  out = (float*)malloc(N * sizeof(float));</span><br><span class="line">  cudaMalloc((void**)&amp;d_b, sizeof(float) * N);</span><br><span class="line">  cudaMemcpy(d_b, b, sizeof(float) * N, cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">  cudaMalloc((void**)&amp;d_out, sizeof(float) * N);</span><br><span class="line">  cudaMemcpy(d_out, out, sizeof(float) * N, cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">  cudaMalloc((void**)&amp;d_a, sizeof(float) * N);</span><br><span class="line">  cudaMemcpy(d_a, a, sizeof(float) * N, cudaMemcpyHostToDevice);</span><br><span class="line">  vector_add&lt;&lt;&lt;1, 1&gt;&gt;&gt;(d_out, d_a, d_b, N);</span><br><span class="line">  cudaMemcpy(out, d_out, sizeof(float) * N, cudaMemcpyDeviceToHost);</span><br><span class="line">  printf(&quot;out[0] = %f\n&quot;, out[0]);</span><br><span class="line">  cudaFree(d_a);</span><br><span class="line">  free(a);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">// Kernel function to add the elements of two arrays</span><br><span class="line">__global__ void add(int n, float *x, float *y) &#123;</span><br><span class="line">  int idx = threadIdx.x;</span><br><span class="line">  int stride = blockDim.x;</span><br><span class="line">  for (int i = idx; i &lt; n; i+=stride) y[i] = x[i] + y[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">  int N = 1 &lt;&lt; 20;</span><br><span class="line">  float *x, *y;</span><br><span class="line"></span><br><span class="line">  // Allocate Unified Memory – accessible from CPU or GPU</span><br><span class="line">  cudaMallocManaged(&amp;x, N * sizeof(float));</span><br><span class="line">  cudaMallocManaged(&amp;y, N * sizeof(float));</span><br><span class="line"></span><br><span class="line">  // initialize x and y arrays on the host</span><br><span class="line">  for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">    x[i] = 1.0f;</span><br><span class="line">    y[i] = 2.0f;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Run kernel on 1M elements on the GPU</span><br><span class="line">  add&lt;&lt;&lt;1, 1&gt;&gt;&gt;(N, x, y);</span><br><span class="line"></span><br><span class="line">  // Wait for GPU to finish before accessing on host</span><br><span class="line">  cudaDeviceSynchronize();</span><br><span class="line"></span><br><span class="line">  // Check for errors (all values should be 3.0f)</span><br><span class="line">  float maxError = 0.0f;</span><br><span class="line">  for (int i = 0; i &lt; N; i++) maxError = fmax(maxError, fabs(y[i] - 3.0f));</span><br><span class="line">  std::cout &lt;&lt; &quot;Max error: &quot; &lt;&lt; maxError &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  // Free memory</span><br><span class="line">  cudaFree(x);</span><br><span class="line">  cudaFree(y);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><ol><li><a href="https://github.com/cuda-mode/lectures?tab=readme-ov-file">cuda-mode/lectures: Material for cuda-mode lectures (github.com)</a></li><li><a href="https://github.com/CodedK/CUDA-by-Example-source-code-for-the-book-s-examples-/tree/master">CodedK/CUDA-by-Example-source-code-for-the-book-s-examples-: CUDA by Example, written by two senior members of the CUDA software platform team, shows programmers how to employ this new technology. The authors introduce each area of CUDA development through working examples. (github.com)</a></li><li><a href="https://gist.github.com/diorahman/648478c2c5c24d819f0f">CUDA Books: Self taught (github.com)</a> maybe this is what all we need.</li><li><a href="https://developer.nvidia.com/blog/even-easier-introduction-cuda/">An Even Easier Introduction to CUDA | NVIDIA Technical Blog</a></li><li><a href="https://github.com/whutbd/cuda-learn-note?tab=readme-ov-file">whutbd/cuda-learn-note: 🎉CUDA 笔记 / 高频面试题汇总 / C++笔记，个人笔记，更新随缘: sgemm、sgemv、warp reduce、block reduce、dot product、elementwise、softmax、layernorm、rmsnorm、hist etc. (github.com)</a></li><li><a href="https://cuda-tutorial.readthedocs.io/en/latest/tutorials/tutorial01/">Tutorial 01: Say Hello to CUDA - CUDA Tutorial (cuda-tutorial.readthedocs.io)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为既对AI又对sys、hpc感兴趣的人来说,cuda编程应该是不可不看的,我也早有耳闻.这里简单学习一下.&lt;br&gt;</summary>
    
    
    
    
    <category term="cuda" scheme="https://www.sekyoro.top/tags/cuda/"/>
    
  </entry>
  
  <entry>
    <title>typst学习与工具使用</title>
    <link href="https://www.sekyoro.top/2024/08/11/typst%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.sekyoro.top/2024/08/11/typst%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</id>
    <published>2024-08-11T08:51:38.000Z</published>
    <updated>2024-08-29T12:43:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>目前使用Latex的的一些问题,也是很多新手常常遇到的</p><ul><li>一些命令不知道名字或者不知道是否有类似的命令,<strong>官方没有友好的reference</strong>.</li><li><strong>报错信息</strong>有些让人疑惑,一些标记语法写法让程序员很难受.</li><li><strong>Latex编译速度并不快</strong></li><li>本地编写Latex光装环境就难倒一批人.</li><li>一些库之间冲突太多,有些时候排版也不自然.</li></ul><p>于是我想尝试一些typst作为写一些小文章、简历甚至slides.</p><span id="more"></span><p>官方<a href="https://typst.app/">Typst: Compose papers faster</a>提供了在线的工具<a href="https://typst.app/">Typst: Compose papers faster</a>,目前社区也挺活跃的,当然写学术论文可能还是Latex占据绝大多数生态,不过在写个人文章或者简历方面Typst还是有优势的</p><p>下面以官方介绍和使用Latex的人的视角学学Typst.首先可以使用vscode安装相关插件或者官方在线工具方便协作(希望后期能超越Overleaf).</p><h2 id="Scripting"><a href="#Scripting" class="headerlink" title="Scripting"></a>Scripting</h2><blockquote><p>像写代码一样写typst</p></blockquote><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>在Typst中，标记和代码融合为一体。<strong>除了最常见的元素(加粗、斜体等表示)外，所有元素都是用函数创建的</strong>。为了尽可能方便，Typst提供了紧凑的语法来将代码表达式嵌入到标记中:用#符号引入表达式，在表达式完成后继续正常的标记解析。如果一个字符将继续表达式，但应被解释为文本，则表达式可以强制以分号(;)结束。</p><h3 id="Blocks"><a href="#Blocks" class="headerlink" title="Blocks"></a>Blocks</h3><p>有两种块,code blocks和content block,可以随意地嵌套</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#&#123;</span><br><span class="line">  let a = [from]</span><br><span class="line">  let b = [*world*]</span><br><span class="line">  [hello ]</span><br><span class="line">  a + [ the ] + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绑定和解构"><a href="#绑定和解构" class="headerlink" title="绑定和解构"></a>绑定和解构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#let name = &quot;Typst&quot;</span><br><span class="line">This is #name&#x27;s documentation.</span><br><span class="line">It explains #name.</span><br><span class="line"></span><br><span class="line">#let add(x, y) = x + y</span><br><span class="line">Sum is #add(2, 3).</span><br></pre></td></tr></table></figure><p>Let绑定也可以用来解构数组和字典。在这种情况下，赋值的左侧应该镜像一个数组或字典。. .操作符可以在模式中使用一次，以收集数组或字典项的剩余部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#let (x, y) = (1, 2)</span><br><span class="line">The coordinates are #x, #y.</span><br><span class="line"></span><br><span class="line">#let (a, .., b) = (1, 2, 3, 4)</span><br><span class="line">The first element is #a.</span><br><span class="line">The last element is #b.</span><br><span class="line"></span><br><span class="line">#let books = (</span><br><span class="line">  Shakespeare: &quot;Hamlet&quot;,</span><br><span class="line">  Homer: &quot;The Odyssey&quot;,</span><br><span class="line">  Austen: &quot;Persuasion&quot;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#let (Austen,) = books</span><br><span class="line">Austen wrote #Austen.</span><br><span class="line"></span><br><span class="line">#let (Homer: h) = books</span><br><span class="line">Homer wrote #h.</span><br><span class="line"></span><br><span class="line">#let (Homer, ..other) = books</span><br><span class="line">#for (author, title) in other [</span><br><span class="line">  #author wrote #title.</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><p>if和loops</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#if 1 &lt; 2 [</span><br><span class="line">  This is shown</span><br><span class="line">] else [</span><br><span class="line">  This is not.</span><br><span class="line">]</span><br><span class="line">#for c in &quot;ABC&quot; [</span><br><span class="line">  #c is a letter.</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">#let n = 2</span><br><span class="line">#while n &lt; 10 &#123;</span><br><span class="line">  n = (n * 2) - 1</span><br><span class="line">  (n,)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><p>众所周知,我们常用的一些操作包括针对字体,包括斜体、加粗、各种数学格式，针对图(Figure)、表(Table,常用三线表)、公式(包括内联的以及占据整行的)￥%……&amp;*（|</p><p><img data-src="https://s2.loli.net/2024/08/11/ygxDBYOMmH2pCv5.png" alt="image-20240811172259678"></p><p>此外针对论文,有引用,论文参考,作者介绍(在Latex中常用<code>\thanks</code>)等等.上面列举了一些常用 素.</p><p>Typst目前的command有markup模式(默认)和code模式,markup模式就像是输入正常的内容,在进阶一点就是通过一些简单的标记markup改变内容表现,code模式及看起来更强大,能调用许多命令.</p><p>通过#使用code模式,[]在code模式中将使用content.</p><div class="table-container"><table><thead><tr><th>New mode</th><th>Syntax</th><th>Example</th></tr></thead><tbody><tr><td>Code</td><td>Prefix the code with <code>#</code></td><td><code>Number: #(1 + 2)</code></td></tr><tr><td>Math</td><td>Surround equation with <script type="math/tex">..</script></td><td><script type="math/tex">-x$ is the opposite of $x</script></td></tr><tr><td>Markup</td><td>Surround markup with <code>[..]</code></td><td><code>let name = [*Typst!*]</code></td></tr></tbody></table></div><h2 id="Arguments"><a href="#Arguments" class="headerlink" title="Arguments"></a>Arguments</h2><p>code模式就像函数一样,有参数,也需要content(相当于输入).</p><blockquote><p>一个函数可以有多个参数。有些参数是位置参数。</p><p>许多函数使用命名参数而不是位置参数来提高可读性。</p></blockquote><p><img data-src="https://s2.loli.net/2024/08/11/iRjep4UnkyCWsOb.png" alt="image-20240811183015272" style="zoom: 80%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Typst is an #underline[alternative]</span><br><span class="line">to LaTeX.</span><br><span class="line"></span><br><span class="line">#rect(fill: aqua)[Get started here!]</span><br></pre></td></tr></table></figure><h2 id="Data-Types"><a href="#Data-Types" class="headerlink" title="Data Types"></a>Data Types</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Data type</th><th style="text-align:left">Example</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://typst.app/docs/reference/foundations/content/">Content</a></td><td style="text-align:left"><code>[*fast* typesetting]</code></td></tr><tr><td style="text-align:left"><a href="https://typst.app/docs/reference/foundations/str/">String</a></td><td style="text-align:left"><code>&quot;Pietro S. Author&quot;</code></td></tr><tr><td style="text-align:left"><a href="https://typst.app/docs/reference/foundations/int/">Integer</a></td><td style="text-align:left"><code>23</code></td></tr><tr><td style="text-align:left"><a href="https://typst.app/docs/reference/foundations/float/">Floating point number</a></td><td style="text-align:left"><code>1.459</code></td></tr><tr><td style="text-align:left"><a href="https://typst.app/docs/reference/layout/length/">Absolute length</a></td><td style="text-align:left"><code>12pt</code>, <code>5in</code>, <code>0.3cm</code>, …</td></tr><tr><td style="text-align:left"><a href="https://typst.app/docs/reference/layout/ratio/">Relative length</a></td><td style="text-align:left"><code>65%</code></td></tr></tbody></table></div><blockquote><p>内容和字符串之间的区别在于，内容可以包含标记，包括函数调用，而字符串实际上只是一个普通的字符序列</p></blockquote><p>Typst提供控制流结构和操作符，例如用于添加内容的+或用于检查两个变量之间是否相等的==</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if 1 &lt; 2 [</span><br><span class="line">  This is shown</span><br><span class="line">] else [</span><br><span class="line">  This is not.</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="show-rule"><a href="#show-rule" class="headerlink" title="show rule"></a>show rule</h2><p>使用show规则，您可以重新定义Typst如何显示某些元素。指定Typst应该以不同的方式显示哪些元素以及它们的外观。Show规则可以应用于文本实例、许多函数，甚至整个文档。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#show &quot;ArtosFlow&quot;: name =&gt; box[</span><br><span class="line">  #box(image(</span><br><span class="line">    &quot;logo.svg&quot;,</span><br><span class="line">    height: 0.7em,</span><br><span class="line">  ))</span><br><span class="line">  #name</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/08/11/VjBAwbrCaTmlitu.png" alt="image-20240811220712931" style="zoom:50%;" /></p><p>上面第一个也可以省略内容参数,直接写函数</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#show</span>: <span class="selector-tag">project</span><span class="selector-class">.with</span>(</span><br><span class="line">  <span class="attribute">theme</span>: rgb(<span class="string">&quot;#0F83C0&quot;</span>),</span><br><span class="line">  <span class="attribute">name</span>: <span class="string">&quot;proanimer&quot;</span>,</span><br><span class="line">  <span class="attribute">title</span>: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">  <span class="attribute">contact</span>:(</span><br><span class="line">    contact(</span><br><span class="line">      <span class="attribute">text</span>: <span class="string">&quot;personal blog&quot;</span>,</span><br><span class="line">      <span class="attribute">link</span>: <span class="string">&quot;https://sekyoro.top&quot;</span></span><br><span class="line">    ),</span><br><span class="line">    contact(</span><br><span class="line">      <span class="attribute">text</span>: <span class="string">&quot;gmail&quot;</span>,</span><br><span class="line">      <span class="attribute">link</span>:<span class="string">&quot;mailto:bukalala174@gmail.com&quot;</span></span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="set-rule"><a href="#set-rule" class="headerlink" title="set rule"></a>set rule</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#set heading(numbering: &quot;I.&quot;)</span><br><span class="line">#set text(</span><br><span class="line">  font: &quot;New Computer Modern&quot;</span><br><span class="line">)</span><br><span class="line">#set text(</span><br><span class="line">  font: &quot;New Computer Modern&quot;,</span><br><span class="line">  size: 10pt</span><br><span class="line">)</span><br><span class="line">#set page(</span><br><span class="line">  paper: &quot;a6&quot;,</span><br><span class="line">  margin: (x: 1.8cm, y: 1.5cm),</span><br><span class="line">)</span><br><span class="line">#set par(</span><br><span class="line">  justify: true,</span><br><span class="line">  leading: 0.52em,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>show和set是两种全局设置样式的表达式,差别是show 更细致,针对选择的元素</p><ul><li><a href="https://typst.app/docs/reference/text/text/"><code>text</code></a> to set font family, size, color, and other properties of text</li><li><a href="https://typst.app/docs/reference/layout/page/"><code>page</code></a> to set the page size, margins, headers, enable columns, and footers</li><li><a href="https://typst.app/docs/reference/model/par/"><code>par</code></a> to justify paragraphs, set line spacing, and more</li><li><a href="https://typst.app/docs/reference/model/heading/"><code>heading</code></a> to set the appearance of headings and enable numbering</li><li><a href="https://typst.app/docs/reference/model/document/"><code>document</code></a> to set the metadata contained in the PDF output, such as title and autho</li></ul><h3 id="Field获取"><a href="#Field获取" class="headerlink" title="Field获取"></a>Field获取</h3><p>可以使用点表示法访问值上的字段。值可以是:</p><ul><li>a <a href="https://typst.app/docs/reference/foundations/dictionary/">dictionary</a> that has the specified key,</li><li>a <a href="https://typst.app/docs/reference/symbols/symbol/">symbol</a> that has the specified modifier,</li><li>a <a href="https://typst.app/docs/reference/foundations/module/">module</a> containing the specified definition,</li><li><a href="https://typst.app/docs/reference/foundations/content/">content</a> consisting of an element that has the specified field. The available fields match the arguments of the <a href="https://typst.app/docs/reference/foundations/function/#element-functions">element function</a> that were given when the element was constructed.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#let dict = (greet: &quot;Hello&quot;)</span><br><span class="line">#dict.greet \</span><br><span class="line">#emoji.face</span><br><span class="line"></span><br><span class="line">#let it = [= Heading]</span><br><span class="line">#it.body \</span><br><span class="line">#it.depth</span><br></pre></td></tr></table></figure><h2 id="实战写一个简历"><a href="#实战写一个简历" class="headerlink" title="实战写一个简历"></a>实战写一个简历</h2><p>你并不需要看每一个方法的介绍,看多了也没用,先来看看其他人怎么写的.</p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>首先需要一个基本模板,模板中包括<strong>设置一些基本值</strong>,以及<strong>一些辅助函数</strong>.</p><p>基本值包括字体、页面等配置.一般使用<code>#set</code>和<code>#show</code>设置. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#set par(justify: true)</span><br><span class="line">#set text(</span><br><span class="line">font: &quot;Linux Libertine&quot;,</span><br><span class="line">size: 11pt,</span><br><span class="line">) </span><br><span class="line">#set page(</span><br><span class="line">paper: &quot;us-letter&quot;,</span><br><span class="line">header: align(</span><br><span class="line">  right + horizon,</span><br><span class="line">  title</span><br><span class="line">),</span><br><span class="line">...</span><br><span class="line">)</span><br><span class="line">//设置页面,段落与字体</span><br></pre></td></tr></table></figure><p>考虑通过一个show rule和函数包装起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#let conf(title,doc) = &#123;</span><br><span class="line">  set par(justify: true,)</span><br><span class="line">  set text(font:&quot;0xProto Nerd Font Propo&quot;,size:11pt)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#show: doc =&gt; conf(</span><br><span class="line">  &quot;Paper title&quot;,</span><br><span class="line">  doc</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用命名参数,这样需要在写函数时设置默认值.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#let conf(</span><br><span class="line">  title: none,</span><br><span class="line">  authors: (),</span><br><span class="line">  abstract: [],</span><br><span class="line">  doc,</span><br><span class="line">) = &#123;</span><br><span class="line">  // Set and show rules from before.</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  set align(center)</span><br><span class="line">  text(17pt, title)</span><br><span class="line"></span><br><span class="line">  let count = authors.len()</span><br><span class="line">  let ncols = calc.min(count, 3)</span><br><span class="line">  grid(</span><br><span class="line">    columns: (1fr,) * ncols,</span><br><span class="line">    row-gutter: 24pt,</span><br><span class="line">    ..authors.map(author =&gt; [</span><br><span class="line">      #author.name \</span><br><span class="line">      #author.affiliation \</span><br><span class="line">      #link(&quot;mailto:&quot; + author.email)</span><br><span class="line">    ]),</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  par(justify: false)[</span><br><span class="line">    *Abstract* \</span><br><span class="line">    #abstract</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  set align(left)</span><br><span class="line">  columns(2, doc)</span><br><span class="line">&#125;</span><br><span class="line">#show: doc =&gt; conf(</span><br><span class="line">  title: [Towards Improved Modelling],</span><br><span class="line">  authors: (</span><br><span class="line">    (</span><br><span class="line">      name: &quot;Theresa Tungsten&quot;,</span><br><span class="line">      affiliation: &quot;Artos Institute&quot;,</span><br><span class="line">      email: &quot;tung@artos.edu&quot;,</span><br><span class="line">    ),</span><br><span class="line">    (</span><br><span class="line">      name: &quot;Eugene Deklan&quot;,</span><br><span class="line">      affiliation: &quot;Honduras State&quot;,</span><br><span class="line">      email: &quot;e.deklan@hstate.hn&quot;,</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">  abstract: lorem(80),</span><br><span class="line">  doc,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在单独的文件中写模板,使用<code>import</code>导入并使用函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;conf.typ&quot;: conf</span><br><span class="line">#show: doc =&gt; conf(</span><br><span class="line">  title: [</span><br><span class="line">    Towards Improved Modelling</span><br><span class="line">  ],</span><br><span class="line">  authors: (</span><br><span class="line">    (</span><br><span class="line">      name: &quot;Theresa Tungsten&quot;,</span><br><span class="line">      affiliation: &quot;Artos Institute&quot;,</span><br><span class="line">      email: &quot;tung@artos.edu&quot;,</span><br><span class="line">    ),</span><br><span class="line">    (</span><br><span class="line">      name: &quot;Eugene Deklan&quot;,</span><br><span class="line">      affiliation: &quot;Honduras State&quot;,</span><br><span class="line">      email: &quot;e.deklan@hstate.hn&quot;,</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">  abstract: lorem(80),</span><br><span class="line">  doc,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">= Introduction</span><br><span class="line">#lorem(90)</span><br><span class="line"></span><br><span class="line">== Motivation</span><br><span class="line">#lorem(140)</span><br><span class="line"></span><br><span class="line">== Problem Statement</span><br><span class="line">#lorem(50)</span><br><span class="line"></span><br><span class="line">= Related Work</span><br><span class="line">#lorem(200)</span><br></pre></td></tr></table></figure><p>也可以使用<code>#import &quot;temp.typ&quot;: *</code>导入去掉命名空间. </p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Call a function.</span><br><span class="line">#list([A], [B])</span><br><span class="line"></span><br><span class="line">// Named arguments and trailing</span><br><span class="line">// content blocks.</span><br><span class="line">#enum(start: 2)[A][B]</span><br><span class="line"></span><br><span class="line">// Version without parentheses.</span><br><span class="line">#list[A][B]</span><br></pre></td></tr></table></figure><p>函数是Typst的基本构建块。Typst提供了各种排版任务的函数。此外，您编写的标记是由函数支持的，所有的样式都是通过函数实现的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#let alert(body, fill: red) = &#123;</span><br><span class="line">  set text(white)</span><br><span class="line">  set align(center)</span><br><span class="line">  rect(</span><br><span class="line">    fill: fill,</span><br><span class="line">    inset: 8pt,</span><br><span class="line">    radius: 4pt,</span><br><span class="line">    [*Warning:\ #body*],</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#alert[</span><br><span class="line">  Danger is imminent!</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">#alert(fill: blue)[</span><br><span class="line">  KEEP OFF TRACKS</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>函数有<code>with</code>和<code>where</code>,<code>with</code>返回一个预先应用了给定参数的新函数</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个选择器，该选择器筛选属于此函数的元素，其字段具有给定参数的值</span></span><br><span class="line">#show heading.where(level: 2): set text(blue)</span><br><span class="line"><span class="section">= Section</span></span><br><span class="line"><span class="section">== Subsection</span></span><br><span class="line"><span class="section">=== Sub-subection</span></span><br></pre></td></tr></table></figure><h3 id="看看别人的"><a href="#看看别人的" class="headerlink" title="看看别人的"></a>看看别人的</h3><p>我在Github上搜刮了一堆别人的模板,写的很不错. 主要使用的方法就是上面提到的函数、set rule,show rule以及map,join等方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">#let contact(text:&quot;&quot;,link:none) = &#123;</span><br><span class="line">  (text:text,link:link)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#let subSection(title:&quot;&quot;,titleEnd:none,subTitle:none,subTitleEnd:none,content:[]) = &#123;</span><br><span class="line">  (title:title,titleEnd:titleEnd,subTitle:subTitle,subTitleEnd:subTitleEnd,content:content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#let section(title:&quot;&quot;,content:subSection()) = &#123;</span><br><span class="line">  (title:title,content:content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#let project(</span><br><span class="line">  theme:rgb(&quot;#4273B0&quot;),</span><br><span class="line">  name:&quot;&quot;,</span><br><span class="line">  email:none,</span><br><span class="line">  title:none,</span><br><span class="line">  contact:((text:[],link:&quot;&quot;)),</span><br><span class="line">  skills:(</span><br><span class="line">    languages:()</span><br><span class="line">  ),</span><br><span class="line">  main:(</span><br><span class="line">   ( title:&quot;&quot;,content:[])</span><br><span class="line">  ),</span><br><span class="line">  sidebar:(),</span><br><span class="line">  body</span><br><span class="line">) = &#123;</span><br><span class="line">  let backgroundTitle(content) = &#123;</span><br><span class="line">    align(center,box(fill:theme,text(white,size:1.25em,weight:&quot;bold&quot;,upper(content)),width:1fr,inset:0.3em))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let secondaryTitle(content) = &#123;</span><br><span class="line">    text(weight:&quot;bold&quot;,size:1.125em,upper(content))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let italicColorTitle(content) = &#123;</span><br><span class="line">    text(weight:&quot;bold&quot;,style:&quot;italic&quot;,size:1.125em,theme,content)</span><br><span class="line">  &#125;</span><br><span class="line">  let contactColumn = align(center)[#contact.map(c =&gt; &#123;</span><br><span class="line">    if c.link == none [</span><br><span class="line">      #c.text\</span><br><span class="line">    ] else [</span><br><span class="line">      #underline(link(c.link,text(theme,c.text)))\</span><br><span class="line">    ]</span><br><span class="line">  &#125;).join()]</span><br><span class="line"></span><br><span class="line">  grid(</span><br><span class="line">    columns:(1fr,2fr),</span><br><span class="line">    column-gutter:2em,</span><br><span class="line">    contactColumn,</span><br><span class="line">    titleColumn</span><br><span class="line">  )</span><br><span class="line">  set par(justify: true)</span><br><span class="line">  let formattedLanguageSkills = [</span><br><span class="line">    #text(skills.languages.join(&quot; • &quot;))</span><br><span class="line">  ]</span><br><span class="line">  let createLeftRight(left:[],right:none)=&#123;</span><br><span class="line">    if(right == none) &#123;</span><br><span class="line">      align(start,text(left))</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      grid(</span><br><span class="line">        columns:(1fr,1fr),</span><br><span class="line">        align(start,text(left)),</span><br><span class="line">        align(end,right) </span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let parseSubSections(subSections) = &#123;</span><br><span class="line">    subSections.map(s=&gt;&#123;</span><br><span class="line">      [</span><br><span class="line">        #createLeftRight(</span><br><span class="line">          left:secondaryTitle(s.title),</span><br><span class="line">          right:if s.titleEnd != none [</span><br><span class="line">            #italicColorTitle(s.titleEnd)</span><br><span class="line">          ]</span><br><span class="line">        )</span><br><span class="line">        #if s.subTitle != none or s.subTitleEnd != none [</span><br><span class="line">          #text(top-edge: 0.2em,</span><br><span class="line">          createLeftRight(left: italicColorTitle(s.subTile),right:s.subTitleEnd)</span><br><span class="line">          )</span><br><span class="line">        ]</span><br><span class="line">        #s.content</span><br><span class="line">      ]</span><br><span class="line">    &#125;).join()</span><br><span class="line">  &#125;</span><br><span class="line">  let parseSection(seciton) = &#123;</span><br><span class="line">    section.map(m=&gt;&#123;</span><br><span class="line">      [</span><br><span class="line">        #backgroundTitle(m.title),</span><br><span class="line">        #parseSubSections(m.content)</span><br><span class="line">      ]</span><br><span class="line">    &#125;).join()</span><br><span class="line">  &#125;</span><br><span class="line">  let mainSection = parseSection(main)</span><br><span class="line">  let sidebarSection = parseSection(sidebar)</span><br><span class="line">  grid(</span><br><span class="line">    columns: (1fr,2fr),</span><br><span class="line">  column-gutter: 1em,</span><br><span class="line">  sidebarSection,</span><br><span class="line">  mainSection</span><br><span class="line">  )</span><br><span class="line">// Main body.</span><br><span class="line">  set par(justify:true)</span><br><span class="line">  show: columns.with(3,gutter:1.3em)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;template.typ&quot;: *</span><br><span class="line"></span><br><span class="line">#set page(</span><br><span class="line">  margin:(</span><br><span class="line">    left: 10mm,</span><br><span class="line">    right: 10mm,</span><br><span class="line">    top: 15mm,</span><br><span class="line">    bottom: 15mm</span><br><span class="line">  )</span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line">#set text(font: &quot;Mulish&quot;)</span><br><span class="line"></span><br><span class="line">#show: project.with(</span><br><span class="line">  theme: rgb(&quot;#0F83C0&quot;),</span><br><span class="line">  name: &quot;proanimer&quot;,</span><br><span class="line">  title: &quot;Software Engineer&quot;,</span><br><span class="line">  contact:(</span><br><span class="line">    contact(</span><br><span class="line">      text: &quot;personal blog&quot;,</span><br><span class="line">      link: &quot;https://sekyoro.top&quot;</span><br><span class="line">    ),</span><br><span class="line">    contact(</span><br><span class="line">      text: &quot;gmail&quot;,</span><br><span class="line">      link:&quot;mailto:bukalala174@gmail.com&quot;</span><br><span class="line">    )</span><br><span class="line">  ),</span><br><span class="line">  main:(</span><br><span class="line">    section(</span><br><span class="line">      title:&quot;Work Experience&quot;,</span><br><span class="line">      content:(</span><br><span class="line">        subSection(</span><br><span class="line">          title: &quot;Freelancer&quot;,</span><br><span class="line">          subTitle: &quot;Software Engineer&quot;,</span><br><span class="line">          content:list(</span><br><span class="line">            [&quot;Developed a personal blog using Gatsby and React, with a focus on performance and accessibility.&quot;],</span><br><span class="line">            [&quot;Implemented a custom CMS using React and Firebase, allowing for easy content management.&quot;],</span><br><span class="line">            [&quot;Optimized the blog for SEO, resulting in a 50% increase in organic traffic.&quot;],</span><br><span class="line">            [&quot;Designed and implemented a custom theme, resulting in a 30% increase in user engagement.&quot;]</span><br><span class="line">          )</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  ),</span><br><span class="line">  sidebar:(</span><br><span class="line">    section(</span><br><span class="line">      title: &quot;Skills&quot;,</span><br><span class="line">      content:(</span><br><span class="line">        subSection(</span><br><span class="line">          title: &quot;Languages&quot;,</span><br><span class="line">          content: list(</span><br><span class="line">            [&quot;JavaScript&quot;, &quot;TypeScript&quot;, &quot;Python&quot;, &quot;Java&quot;, &quot;C++&quot;]</span><br><span class="line">          )</span><br><span class="line">        ),</span><br><span class="line">        )</span><br><span class="line">      ),</span><br><span class="line">      section(</span><br><span class="line">        title:&quot;Education&quot;,</span><br><span class="line">        content:(</span><br><span class="line">          subSection(</span><br><span class="line">            title: &quot;University of British Columbia&quot;,</span><br><span class="line">            titleEnd: &quot;Vancouver, BC&quot;,</span><br><span class="line">            subTitle: &quot;Bachelor of Computer Science&quot;,</span><br><span class="line">            subTitleEnd: &quot;(2018 - 2022)&quot;</span><br><span class="line">          )</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>肯定没有必要使用typst写简历的,主要还是想替代Latex写点小论文或者文章,可以拿简历练练手.</p><p>如果真需要简历可以在网上填写信息直接生成.</p><h2 id="如何写一个幻灯片"><a href="#如何写一个幻灯片" class="headerlink" title="如何写一个幻灯片"></a>如何写一个幻灯片</h2><blockquote><p>用手拖来拖去制作幻灯片实在太麻烦了,我们喜欢简洁、可控与重用.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 为了跨项目重用构建块,可以创建和导入Typst包.包导入被指定为名称空间、名称和版本的三元组</span><br><span class="line">#import &quot;@preview/example:0.1.0&quot;: add</span><br><span class="line">#add(2, 7)</span><br></pre></td></tr></table></figure><p>使用编程的方式写ppt主要目的是为了方便写公式,图片摆放以及更加简洁.这里使用touying包制作,目前typst都是生成pdf格式的,也完全可以使用相关软件播放.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;@preview/touying:0.4.2&quot;: *</span><br><span class="line"></span><br><span class="line">#let s = themes.simple.register()</span><br><span class="line">#let (init, slides) = utils.methods(s)</span><br><span class="line">#show: init</span><br><span class="line"></span><br><span class="line">#let (slide, empty-slide) = utils.slides(s)</span><br><span class="line">#show: slides</span><br><span class="line"></span><br><span class="line">= Title</span><br><span class="line"></span><br><span class="line">This is written in Typst.</span><br><span class="line"></span><br><span class="line">== First Slide</span><br><span class="line"></span><br><span class="line">Hello, Touying!</span><br><span class="line">This is written in Typst.</span><br><span class="line">Attention = $frac(Q*K^(T),sqrt(d))*V$</span><br><span class="line"></span><br><span class="line">#pause</span><br><span class="line"></span><br><span class="line">Hello, Typst!</span><br></pre></td></tr></table></figure><p>最后说一下,利用<a href="https://github.com/jgm/pandoc">jgm/pandoc: Universal markup converter (github.com)</a>完全可以实现latex与typst互换.</p><h2 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h2><p>目前使用感觉还是很不错,优点包括两个</p><ul><li>使用命令语法对程序员友好,官方文档全面</li><li>编译速度快,本地写也很方便</li></ul><p>如果要说缺点就是 生态相对Latex没那么好,如果想要实现一些效果网上可能没有现成方法,有些东西目前也没有支持<a href="https://typst.app/docs/roadmap/">Roadmap – Typst Documentation</a></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol><li><a href="https://typst.app/docs">Typst Documentation</a></li><li><a href="https://typst.app/universe/package/touying/">touying – Typst Universe</a> typst写幻灯片, 此外Latex也有beamer<a href="https://latex-beamer.com/quick-start/">LaTeX Beamer introduction / Quick-start guide - LaTeX Beamer (latex-beamer.com)</a>库类似的功能</li><li><a href="https://github.com/jgm/pandoc">jgm/pandoc: Universal markup converter (github.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;目前使用Latex的的一些问题,也是很多新手常常遇到的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一些命令不知道名字或者不知道是否有类似的命令,&lt;strong&gt;官方没有友好的reference&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;报错信息&lt;/strong&gt;有些让人疑惑,一些标记语法写法让程序员很难受.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Latex编译速度并不快&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;本地编写Latex光装环境就难倒一批人.&lt;/li&gt;
&lt;li&gt;一些库之间冲突太多,有些时候排版也不自然.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是我想尝试一些typst作为写一些小文章、简历甚至slides.&lt;/p&gt;</summary>
    
    
    
    
    <category term="写作" scheme="https://www.sekyoro.top/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>profile a deep learning model</title>
    <link href="https://www.sekyoro.top/2024/07/30/profile-a-deep-learning-model/"/>
    <id>https://www.sekyoro.top/2024/07/30/profile-a-deep-learning-model/</id>
    <published>2024-07-30T07:34:36.000Z</published>
    <updated>2024-07-31T03:54:33.021Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这是大型软件、算法开发中容易被忽视同时也并不简单的一环,如何分析一个程序.这涉及到分析内存、使用一系列现有工具并进行可能冗长的测试. 但不管怎样,这是走向成熟应用关键的一步,</p><span id="more"></span><h3 id="如何进行性能分析"><a href="#如何进行性能分析" class="headerlink" title="如何进行性能分析"></a>如何进行性能分析</h3><blockquote><p>过早的性能分析是万恶之源</p></blockquote><p>你可以先完成程序的基本功能再进行优化,分析的方式和工具很多.最基础的包括计时.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line">n = random.randint(<span class="number">1</span>, <span class="number">10</span>) * <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前时间 </span></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行一些操作</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sleeping for &#123;&#125; ms&quot;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">time.sleep(n/<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较当前时间和起始时间</span></span><br><span class="line"><span class="built_in">print</span>(time.time() - start)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Sleeping for 500 ms</span></span><br><span class="line"><span class="comment"># 0.5713930130004883</span></span><br></pre></td></tr></table></figure><p>考虑到一个程序执行时间包含太多部分,比如如果你的电脑同时跑着太多程序并且内存不太够,造成的中断等也会影响时间.</p><p>对于工具来说,需要区分真实时间、用户时间和系统时间.通常来说,用户时间+系统时间代表了进程所消耗的实际 CPU .</p><ul><li>真实时间 - 从程序开始到结束流失掉的真实时间，包括其他进程的执行时间以及阻塞消耗的时间（例如等待 I/O或网络）；</li><li><em>User</em> - CPU 执行用户代码所花费的时间；</li><li><em>Sys</em> - CPU 执行系统内核代码所花费的时间</li></ul><p>对于cpu,内存,事件分析以及可视化等,都有一系列工具处理,具体可看<a href="https://missing-semester-cn.github.io/2020/debugging-profiling/">调试及性能分析 · the missing semester of your cs education (missing-semester-cn.github.io)</a></p><h3 id="深度学习模型的性能分析"><a href="#深度学习模型的性能分析" class="headerlink" title="深度学习模型的性能分析"></a>深度学习模型的性能分析</h3><p>如何评估一个模型在实际部署或者推理时的效果,计算量和参数都是重要因素,一个限制GPU/CPU,一个限制内存.<br>此外对于图像或视频,fps也是重要因素,对于大模型而言就是输出token的速度,说白了就是输出时间,影响了实时性和用户使用体验,个人认为这个因素也跟计算量和参数相关.<br>那么如何计算模型计算量和参数量呢?<br>根据字面意思,参数量好理解,无非几种网络结构,每种网络结构都或多或少有参数,每个参数当作f32或者其他类型计算即可. 当然实际推理或者部署完全可以使用量化的方法得到整数,甚至是i8类型.这样就把参数量降低了,此外浮点数变成了整数,事实上计算也降低了复杂度,因为浮点数计算在CPU/GPU上往往更复杂.</p><p>这样一想,计算参数量就比较简单了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_param</span>(<span class="params">model</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Calculate the number of parameters in the model.</span></span><br><span class="line"><span class="string">    :param model: model</span></span><br><span class="line"><span class="string">    :return: number of parameters</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    param_num =  <span class="built_in">sum</span>(p.numel() <span class="keyword">for</span> p <span class="keyword">in</span> model.parameters() <span class="keyword">if</span> p.requires_grad)</span><br><span class="line">    <span class="built_in">print</span>(param_num*<span class="number">4</span>/<span class="number">1024</span>/<span class="number">1024</span>, <span class="string">&#x27;MB&#x27;</span>) <span class="comment"># assume dtype float32</span></span><br></pre></td></tr></table></figure><p>那如何计算计算量呢,由于浮点数和整数运算上在CPU计算的不同,我们只考虑更为复杂的浮点数计算,就有了FLOPs. FLOPS计算如下,卷积层和全连接计算不同</p><p><img data-src="https://s2.loli.net/2024/07/30/QchEs9vxK1unXjH.png" alt="image-20240730111224462"></p><p>还有些地方使用的是MACs和MAdds,</p><p>MAC：Multiply Accumulate，乘加运算。乘积累加运算（英语：Multiply Accumulate, MAC）是在数字信号处理器或一些微处理器中的特殊运算。实现此运算操作的硬件电路单元，被称为“乘数累加器”。这种运算的操作，是将乘法的乘积结果和累加器的值相加，再存入累加器：</p><script type="math/tex; mode=display">a ← a + b × c</script><p>使用MAC可以将原本需要的两个指令操作减少到一个指令操作，从而提高运算效率。</p><blockquote><p>MAdds 本质上与 MACs 相同，都是指一次乘法和一次加法的组合。术语 MAdds 更常见于一些文献中，尤其是早期的文献。实际上，在大多数情况下，MACs 和 MAdds 可以互换使用.</p><p>1个 MACs 包含一个乘法操作与一个加法操作，大约包含2个 FLOPs。因此，通常 MACs 与 FLOPs 存在一个2倍的关系。(但是很多时候又会把它们会混淆合在一起)</p></blockquote><p>抽象地高度来说</p><blockquote><ul><li>计算量是指网络模型需要计算的<strong>运算次数</strong>，参数量是指网络模型自带的<strong>参数数量</strong>多少</li><li>计算量对应<strong>时间复杂度</strong>，参数量对应于<strong>空间复杂度</strong></li><li>计算量决定了<strong>网络执行时间的长短</strong>，参数量决定了占用显存的量</li></ul></blockquote><p><a href="https://blog.csdn.net/qq_33952811/article/details/124276599">5种方法获取Torch网络模型参数量计算量等信息_查看模型参数量-CSDN博客</a></p><h3 id="fvcore"><a href="#fvcore" class="headerlink" title="fvcore"></a>fvcore</h3><p>Meta的开源工具,包含pytorch layers,计算flop,计算参数,</p><p><strong>FlopCountAnalysis</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from fvcore<span class="selector-class">.nn</span> import FlopCountAnalysis</span><br><span class="line">flops = FlopCountAnalysis(model, input)</span><br><span class="line">flops<span class="selector-class">.total</span>()</span><br><span class="line">flops<span class="selector-class">.by_operator</span>()</span><br><span class="line"><span class="function"><span class="title">Counter</span><span class="params">(&#123;<span class="string">&#x27;conv&#x27;</span>: <span class="number">194616</span>, <span class="string">&#x27;addmm&#x27;</span>: <span class="number">80040</span>&#125;)</span></span></span><br><span class="line">flops<span class="selector-class">.by_module</span>()</span><br><span class="line">Counter(&#123;<span class="string">&#x27;&#x27;</span>: <span class="number">274656</span>, <span class="string">&#x27;conv1&#x27;</span>: <span class="number">48600</span>,</span><br><span class="line">         <span class="string">&#x27;conv2&#x27;</span>: <span class="number">146016</span>, <span class="string">&#x27;fc1&#x27;</span>: <span class="number">69120</span>,</span><br><span class="line">         <span class="string">&#x27;fc2&#x27;</span>: <span class="number">10080</span>, <span class="string">&#x27;fc3&#x27;</span>: <span class="number">840</span>&#125;)</span><br><span class="line">flops<span class="selector-class">.by_module_and_operator</span>()</span><br><span class="line">&#123;<span class="string">&#x27;&#x27;</span>: Counter(&#123;<span class="string">&#x27;conv&#x27;</span>: <span class="number">194616</span>, <span class="string">&#x27;addmm&#x27;</span>: <span class="number">80040</span>&#125;),</span><br><span class="line"> <span class="string">&#x27;conv1&#x27;</span>: Counter(&#123;<span class="string">&#x27;conv&#x27;</span>: <span class="number">48600</span>&#125;),</span><br><span class="line"> <span class="string">&#x27;conv2&#x27;</span>: Counter(&#123;<span class="string">&#x27;conv&#x27;</span>: <span class="number">146016</span>&#125;),</span><br><span class="line"> <span class="string">&#x27;fc1&#x27;</span>: Counter(&#123;<span class="string">&#x27;addmm&#x27;</span>: <span class="number">69120</span>&#125;),</span><br><span class="line"> <span class="string">&#x27;fc2&#x27;</span>: Counter(&#123;<span class="string">&#x27;addmm&#x27;</span>: <span class="number">10080</span>&#125;),</span><br><span class="line"> <span class="string">&#x27;fc3&#x27;</span>: Counter(&#123;<span class="string">&#x27;addmm&#x27;</span>: <span class="number">840</span>&#125;)&#125;</span><br></pre></td></tr></table></figure><p><strong>flop_count_table</strong></p><p>Format the per-module parameters and flops of a model in a table</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(flop_count_table(FlopCountAnalysis(model, inputs)))</span><br></pre></td></tr></table></figure><p>可以单独看某个模块的参数量和计算量.</p><h3 id="torch-profiler"><a href="#torch-profiler" class="headerlink" title="torch profiler"></a>torch profiler</h3><p>pytorch官方工具</p><blockquote><p>PyTorch Profiler是一个允许在训练和推理期间收集性能指标的工具。Profiler的上下文管理器API可以用来更好地理解哪些模型操作符是最昂贵的，检查它们的输入形状和堆栈跟踪，研究设备内核活动并可视化执行跟踪</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">with</span> profile(activities=[ProfilerActivity.CUDA], record_shapes=<span class="literal">True</span>, use_cuda=<span class="literal">True</span>) <span class="keyword">as</span> prof:</span><br><span class="line">        <span class="keyword">with</span> record_function(<span class="string">&quot;model_inference&quot;</span>):</span><br><span class="line">            model(input_data[<span class="string">&#x27;ego&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;GPU time sorted operators:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(prof.key_averages().table(sort_by=<span class="string">&quot;cuda_time_total&quot;</span>, row_limit=<span class="number">10</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;CPU time sorted operators:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(prof.key_averages().table(sort_by=<span class="string">&quot;cpu_time_total&quot;</span>, row_limit=<span class="number">10</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面计算了GPU和CPU的时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> torch.profiler.profile(</span><br><span class="line">    activities=[</span><br><span class="line">        torch.profiler.ProfilerActivity.CPU,</span><br><span class="line">        torch.profiler.ProfilerActivity.CUDA,</span><br><span class="line">    ]</span><br><span class="line">) <span class="keyword">as</span> p:</span><br><span class="line">    code_to_profile()</span><br><span class="line"><span class="built_in">print</span>(p.key_averages().table(</span><br><span class="line">    sort_by=<span class="string">&quot;self_cuda_time_total&quot;</span>, row_limit=-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/07/31/3yWSVITxsYGHbR8.png" alt="image-20240731115415621"></p><h3 id="deepspeed"><a href="#deepspeed" class="headerlink" title="deepspeed"></a>deepspeed</h3><p>大模型训练的加速框架,微软开源的.一般的模型上面两个足以.这里不过多介绍.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> deepspeed.profiling.flops_profiler <span class="keyword">import</span> FlopsProfiler</span><br><span class="line"></span><br><span class="line">model = Model()</span><br><span class="line">prof = FlopsProfiler(model)</span><br><span class="line"></span><br><span class="line">profile_step = <span class="number">5</span></span><br><span class="line">print_profile= <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> step, batch <span class="keyword">in</span> <span class="built_in">enumerate</span>(data_loader):</span><br><span class="line">  <span class="comment"># start profiling at training step &quot;profile_step&quot;</span></span><br><span class="line">  <span class="keyword">if</span> step == profile_step:</span><br><span class="line">    prof.start_profile()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># forward() method</span></span><br><span class="line">  loss = model(batch)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># end profiling and print output</span></span><br><span class="line">  <span class="keyword">if</span> step == profile_step: <span class="comment"># if using multi nodes, check global_rank == 0 as well</span></span><br><span class="line">    prof.stop_profile()</span><br><span class="line">    flops = prof.get_total_flops()</span><br><span class="line">    macs = prof.get_total_macs()</span><br><span class="line">    params = prof.get_total_params()</span><br><span class="line">    <span class="keyword">if</span> print_profile:</span><br><span class="line">        prof.print_model_profile(profile_step=profile_step)</span><br><span class="line">    prof.end_profile()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># runs backpropagation</span></span><br><span class="line">  loss.backward()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># weight update</span></span><br><span class="line">  optimizer.step()</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>除了上面几个之外,还有thop,stat以及ptflops等,其中一个问题时,很多库要求给出输出的tensor shape,但实际情况是输入的是一个list或者dict然后在模型中进行处理,为了避免模型改动,我推荐可以使用thop.</p></blockquote><h3 id="运行模型时间"><a href="#运行模型时间" class="headerlink" title="运行模型时间"></a>运行模型时间</h3><p>前面讲到如果要测试程序时间,并没有想的那么简单.在pytorch中提供了<code>torch.cuda.Event</code></p><p><a href="https://github.com/yifanlu0227/HEAL/blob/4882bd02514725fa5e2e5717d410de739f33790e/opencood/tools/profiler/params_calc.py">HEAL/opencood/tools/profiler/params_calc.py at 4882bd02514725fa5e2e5717d410de739f33790e · yifanlu0227/HEAL (github.com)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inference_throughput_cuda_event</span>(<span class="params">model, data</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start inference throughput performance test&quot;</span>)</span><br><span class="line">    run_num = <span class="number">50</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;warm up ...\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad(): <span class="comment"># warm up</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(run_num):</span><br><span class="line">            output = model(data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;warm up done.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># synchronize 等待所有 GPU 任务处理完才返回 CPU 主线程</span></span><br><span class="line">    torch.cuda.synchronize()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置用于测量时间的 cuda Event, 这是PyTorch 官方推荐的接口</span></span><br><span class="line">    starter, ender = torch.cuda.Event(enable_timing=<span class="literal">True</span>), torch.cuda.Event(enable_timing=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 初始化一个时间容器</span></span><br><span class="line">    run_num = <span class="number">200</span></span><br><span class="line">    timings = np.zeros((run_num,))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;start testing ...\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(run_num):</span><br><span class="line">            starter.record()</span><br><span class="line">            output = model(data)</span><br><span class="line">            ender.record()</span><br><span class="line">            torch.cuda.synchronize() <span class="comment"># 等待GPU任务完成</span></span><br><span class="line">            curr_time = starter.elapsed_time(ender) <span class="comment"># 从 starter 到 ender 之间用时,单位为毫秒</span></span><br><span class="line">            timings[i] = curr_time / <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    infer_thro = run_num / timings.<span class="built_in">sum</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;inference throughput (cuda event): &quot;</span>, infer_thro)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> infer_thro</span><br></pre></td></tr></table></figure><p>经过我自己测试,如果显存足够的情况下,很多时候直接使用time结果类似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start_time = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(run_num):</span><br><span class="line">    output = model(data)</span><br><span class="line">end_time = time.time()</span><br><span class="line">infer_thro = run_num / (end_time - start_time)</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><p><a href="https://missing-semester-cn.github.io/2020/debugging-profiling/">调试及性能分析 · the missing semester of your cs education (missing-semester-cn.github.io)</a></p></li><li><p><a href="https://discuss.pytorch.org/t/correct-way-to-calculate-flops-in-model/67198/14">Correct way to calculate FLOPS in model - PyTorch Forums</a></p><p>以下是我看到的分析深度学习模型计算量和参数量的工具</p><ul><li><a href="https://pytorch.org/docs/stable/profiler.html">torch.profiler — PyTorch 2.4 documentation</a></li><li><a href="https://www.deepspeed.ai/tutorials/flops-profiler/">Flops Profiler - DeepSpeed</a></li><li><a href="https://github.com/facebookresearch/fvcore">facebookresearch/fvcore: Collection of common code that’s shared among different research projects in FAIR computer vision team. (github.com)</a> </li></ul></li></ol><p>profiler <a href="https://github.com/yifanlu0227/HEAL/tree/4882bd02514725fa5e2e5717d410de739f33790e/opencood/tools/profiler">HEAL/opencood/tools/profiler at 4882bd02514725fa5e2e5717d410de739f33790e · yifanlu0227/HEAL (github.com)</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是大型软件、算法开发中容易被忽视同时也并不简单的一环,如何分析一个程序.这涉及到分析内存、使用一系列现有工具并进行可能冗长的测试. 但不管怎样,这是走向成熟应用关键的一步,&lt;/p&gt;</summary>
    
    
    
    
    <category term="deep learning" scheme="https://www.sekyoro.top/tags/deep-learning/"/>
    
    <category term="profiler" scheme="https://www.sekyoro.top/tags/profiler/"/>
    
  </entry>
  
  <entry>
    <title>Go+HTMX: web开发降低心智负担的一种选择?</title>
    <link href="https://www.sekyoro.top/2024/07/27/go-htmx-web%E5%BC%80%E5%8F%91%E9%99%8D%E4%BD%8E%E5%BF%83%E6%99%BA%E8%B4%9F%E6%8B%85%E7%9A%84%E4%B8%80%E7%A7%8D%E9%80%89%E6%8B%A9/"/>
    <id>https://www.sekyoro.top/2024/07/27/go-htmx-web%E5%BC%80%E5%8F%91%E9%99%8D%E4%BD%8E%E5%BF%83%E6%99%BA%E8%B4%9F%E6%8B%85%E7%9A%84%E4%B8%80%E7%A7%8D%E9%80%89%E6%8B%A9/</id>
    <published>2024-07-27T02:35:43.000Z</published>
    <updated>2024-07-28T08:53:33.521Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>众所周知,一段时间前我一直在关注web开发框架,总的来说,大同小异. 如何进行快速开发小应用,是一个并不简单回答的问题.这里我给出一个解决方案:Go+HTMX.<br><span id="more"></span></p><p>这两个技术我不过多介绍,htmx顾名思义,在html上封了一层提供与后端交互的功能. 使用Go因为它的简洁且自带GC,不像c++和rust需要仔细小心管理内存,没有选用Java/C#也是因为后两者使用通常都要带上巨大的库(大型库会带来依赖上的安装、管理以及心智负担),在开发小应用时往往没有必要.  HTMX主要承担了一部分js的作用.</p><p>htmlx只有14k的大小,没有其他依赖,增强了html的功能. 再次说明,我介绍这个技术栈目的是为了快速开发中小应用,如果为了工作或是进一步学习,推荐Java/C#/Go等,再不济也是Python/PHP/Ruby.搭配vue/react/svelte/solid.</p><p>关于Go的web开发,常用Gin作为框架,主要写REST API和自带的模板引擎解析html,这里不多赘述.</p><p>下面介绍htmx的一些重要功能</p><h2 id="HTMX"><a href="#HTMX" class="headerlink" title="HTMX"></a>HTMX</h2><h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>使用html的属性发送请求.</p><h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><div class="table-container"><table><thead><tr><th style="text-align:left">Attribute</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://htmx.org/attributes/hx-get/">hx-get</a></td><td style="text-align:left">Issues a <code>GET</code> request to the given URL</td></tr><tr><td style="text-align:left"><a href="https://htmx.org/attributes/hx-post/">hx-post</a></td><td style="text-align:left">Issues a <code>POST</code> request to the given URL</td></tr><tr><td style="text-align:left"><a href="https://htmx.org/attributes/hx-put/">hx-put</a></td><td style="text-align:left">Issues a <code>PUT</code> request to the given URL</td></tr><tr><td style="text-align:left"><a href="https://htmx.org/attributes/hx-patch/">hx-patch</a></td><td style="text-align:left">Issues a <code>PATCH</code> request to the given URL</td></tr><tr><td style="text-align:left"><a href="https://htmx.org/attributes/hx-delete/">hx-delete</a></td><td style="text-align:left">Issues a <code>DELETE</code> request to the given URL</td></tr></tbody></table></div><h4 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a>trigger</h4><p>通过<code>hx-trigger</code>设置触发动作</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hx-post</span>=<span class="string">&quot;/mouse_entered&quot;</span> <span class="attr">hx-trigger</span>=<span class="string">&quot;mouseenter&quot;</span>&gt;</span></span><br><span class="line">    [Here Mouse, Mouse!]</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以设置mofiers和filters修改默认行为.</p><p>还可以使用轮询</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hx-get</span>=<span class="string">&quot;/news&quot;</span> <span class="attr">hx-trigger</span>=<span class="string">&quot;every 2s&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hx-get</span>=<span class="string">&quot;/messages&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">hx-trigger</span>=<span class="string">&quot;load delay:1s&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">hx-swap</span>=<span class="string">&quot;outerHTML&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置indicator表明已经发出请求</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">hx-get</span>=<span class="string">&quot;/click&quot;</span>&gt;</span></span><br><span class="line">    Click Me!</span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;htmx-indicator&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/spinner.gif&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.htmx-indicator</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.htmx-request</span> <span class="selector-class">.htmx-indicator</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.htmx-request</span><span class="selector-class">.htmx-indicator</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当htmx发出请求时，它将把一个htmx-request类放到一个元素上(如果指定，可以是请求元素或另一个元素)。htmx-request类会使带有html-indicator类的子元素的不透明度变为1。</p><p>可以设置修改的元素.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">hx-get</span>=<span class="string">&quot;/click&quot;</span> <span class="attr">hx-indicator</span>=<span class="string">&quot;#indicator&quot;</span>&gt;</span></span><br><span class="line">        Click Me!</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;indicator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;htmx-indicator&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/spinner.gif&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="target"><a href="#target" class="headerlink" title="target"></a>target</h4><p>响应默认加载到请求的元素中,可以修改</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;q&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">hx-get</span>=<span class="string">&quot;/trigger_delay&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">hx-trigger</span>=<span class="string">&quot;keyup delay:500ms changed&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">hx-target</span>=<span class="string">&quot;#search-results&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">placeholder</span>=<span class="string">&quot;Search...&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;search-results&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h4><p>htmx提供了几种不同的方法来将返回的HTML交换到DOM.默认情况下,内容会替换目标元素的innerHTML.可以通过使用hx-swap属性来修改这个值:</p><div class="table-container"><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><code>innerHTML</code></td><td style="text-align:left">the default, puts the content inside the target element</td></tr><tr><td style="text-align:left"><code>outerHTML</code></td><td style="text-align:left">replaces the entire target element with the returned content</td></tr><tr><td style="text-align:left"><code>afterbegin</code></td><td style="text-align:left">prepends the content before the first child inside the target</td></tr><tr><td style="text-align:left"><code>beforebegin</code></td><td style="text-align:left">prepends the content before the target in the target’s parent element</td></tr><tr><td style="text-align:left"><code>beforeend</code></td><td style="text-align:left">appends the content after the last child inside the target</td></tr><tr><td style="text-align:left"><code>afterend</code></td><td style="text-align:left">appends the content after the target in the target’s parent element</td></tr><tr><td style="text-align:left"><code>delete</code></td><td style="text-align:left">deletes the target element regardless of the response</td></tr><tr><td style="text-align:left"><code>none</code></td><td style="text-align:left">does not append content from response (<a href="https://htmx.org/docs/#oob_swaps">Out of Band Swaps</a> and <a href="https://htmx.org/docs/#response-headers">Response Headers</a> will still be processed)</td></tr></tbody></table></div><p>以上就是htmx中Ajax的基本使用,如果知道ajax的运作,那么使用就不会太难.</p><h3 id="属性继承"><a href="#属性继承" class="headerlink" title="属性继承"></a>属性继承</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hx-confirm</span>=<span class="string">&quot;Are you sure?&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">hx-delete</span>=<span class="string">&quot;/account&quot;</span>&gt;</span></span><br><span class="line">        Delete My Account</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">hx-put</span>=<span class="string">&quot;/account&quot;</span>&gt;</span></span><br><span class="line">        Update My Account</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面两个button继承了hx-confirm的值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hx-confirm</span>=<span class="string">&quot;Are you sure?&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">hx-delete</span>=<span class="string">&quot;/account&quot;</span>&gt;</span></span><br><span class="line">        Delete My Account</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">hx-put</span>=<span class="string">&quot;/account&quot;</span>&gt;</span></span><br><span class="line">        Update My Account</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">hx-confirm</span>=<span class="string">&quot;unset&quot;</span> <span class="attr">hx-get</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span><br><span class="line">        Cancel</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>利用unset取消</p><h3 id="增强表单和链接"><a href="#增强表单和链接" class="headerlink" title="增强表单和链接"></a>增强表单和链接</h3><p>HTML支持使用hx-boost属性“增强”常规HTML锚和表单.该属性将把所有锚标记和表单转换为AJAX请求,默认情况下,这些请求以页面主体为目标。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hx-boost</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/blog&quot;</span>&gt;</span>Blog<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个div中的锚标记将向/blog发出一个AJAX GET请求，并将响应交换到body标记中</p><h3 id="配置响应处理"><a href="#配置响应处理" class="headerlink" title="配置响应处理"></a>配置响应处理</h3><p>htmx期望对它发出的AJAX请求的响应是HTML,通常是HTML片段(尽管与hx-select标记匹配的完整HTML文档也很有用).然后,HTML将返回的HTML交换到指定目标的文档中,并使用指定的交换策略.<br>有时您可能不希望在交换中执行任何操作,但仍然可能触发客户端事件.<br>对于这种情况,默认情况下,您可以返回204 - No Content响应代码，并且html将忽略响应的内容.<br>在服务器错误响应的事件中(例如404或501)，html将触发html:responseerror事件，你可以处理。<br>如果出现连接错误，将触发html:sendError事件。</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">responseHandling: [</span><br><span class="line">     &#123;code:<span class="string">&quot;204&quot;</span>, swap: <span class="literal">false</span>&#125;,   <span class="comment">// 204 - No Content by default does nothing, but is not an error</span></span><br><span class="line">     &#123;code:<span class="string">&quot;[23]..&quot;</span>, swap: <span class="literal">true</span>&#125;, <span class="comment">// 200 &amp; 300 responses are non-errors and are swapped</span></span><br><span class="line">     &#123;code:<span class="string">&quot;[45]..&quot;</span>, swap: <span class="literal">false</span>, <span class="keyword">error</span>:<span class="literal">true</span>&#125;, <span class="comment">// 400 &amp; 500 responses are not swapped and are errors</span></span><br><span class="line"> ]</span><br></pre></td></tr></table></figure><p>可以配置下面这些选项:</p><ul><li><code>code</code> - a String representing a regular expression that will be tested against response codes.</li><li><code>swap</code> - <code>true</code> if the response should be swapped into the DOM, <code>false</code> otherwise</li><li><code>error</code> - <code>true</code> if htmx should treat this response as an error</li><li><code>ignoreTitle</code> - <code>true</code> if htmx should ignore title tags in the response</li><li><code>select</code> - A CSS selector to use to select content from the response</li><li><code>target</code> - A CSS selector specifying an alternative target for the response</li><li><code>swapOverride</code> - An alternative swap mechanism for the response</li></ul><h3 id="配置请求头和响应头"><a href="#配置请求头和响应头" class="headerlink" title="配置请求头和响应头"></a>配置请求头和响应头</h3><h4 id="Request-Headers"><a href="#Request-Headers" class="headerlink" title="Request Headers"></a>Request Headers</h4><p>htmx includes a number of useful headers in requests:</p><div class="table-container"><table><thead><tr><th style="text-align:left">Header</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><code>HX-Boosted</code></td><td style="text-align:left">indicates that the request is via an element using <a href="https://htmx.org/attributes/hx-boost/">hx-boost</a></td></tr><tr><td style="text-align:left"><code>HX-Current-URL</code></td><td style="text-align:left">the current URL of the browser</td></tr><tr><td style="text-align:left"><code>HX-History-Restore-Request</code></td><td style="text-align:left">“true” if the request is for history restoration after a miss in the local history cache</td></tr><tr><td style="text-align:left"><code>HX-Prompt</code></td><td style="text-align:left">the user response to an <a href="https://htmx.org/attributes/hx-prompt/">hx-prompt</a></td></tr><tr><td style="text-align:left"><code>HX-Request</code></td><td style="text-align:left">always “true”</td></tr><tr><td style="text-align:left"><code>HX-Target</code></td><td style="text-align:left">the <code>id</code> of the target element if it exists</td></tr><tr><td style="text-align:left"><code>HX-Trigger-Name</code></td><td style="text-align:left">the <code>name</code> of the triggered element if it exists</td></tr><tr><td style="text-align:left"><code>HX-Trigger</code></td><td style="text-align:left">the <code>id</code> of the triggered element if it exists</td></tr></tbody></table></div><h4 id="Response-Headers"><a href="#Response-Headers" class="headerlink" title="Response Headers"></a>Response Headers</h4><ul><li><a href="https://htmx.org/headers/hx-location/"><code>HX-Location</code></a> - allows you to do a client-side redirect that does not do a full page reload</li><li><a href="https://htmx.org/headers/hx-push-url/"><code>HX-Push-Url</code></a> - pushes a new url into the history stack</li><li><code>HX-Redirect</code> - can be used to do a client-side redirect to a new location</li><li><code>HX-Refresh</code> - if set to “true” the client-side will do a full refresh of the page</li><li><a href="https://htmx.org/headers/hx-replace-url/"><code>HX-Replace-Url</code></a> - replaces the current URL in the location bar</li><li><code>HX-Reswap</code> - allows you to specify how the response will be swapped. See <a href="https://htmx.org/attributes/hx-swap/">hx-swap</a> for possible values</li><li><code>HX-Retarget</code> - a CSS selector that updates the target of the content update to a different element on the page</li><li><code>HX-Reselect</code> - a CSS selector that allows you to choose which part of the response is used to be swapped in. Overrides an existing <a href="https://htmx.org/attributes/hx-select/"><code>hx-select</code></a> on the triggering element</li><li><a href="https://htmx.org/headers/hx-trigger/"><code>HX-Trigger</code></a> - allows you to trigger client-side events</li><li><a href="https://htmx.org/headers/hx-trigger/"><code>HX-Trigger-After-Settle</code></a> - allows you to trigger client-side events after the settle step</li><li><a href="https://htmx.org/headers/hx-trigger/"><code>HX-Trigger-After-Swap</code></a> - allows you to trigger client-side events after the swap step</li></ul><p>htmx请求的顺序:</p><ul><li>元素被trigger<ul><li>收集需要发送的数据</li><li><code>htmx-request</code>类被放在元素上</li><li>通过AJAX异步地请求<ul><li>获得响应后与 <code>htmx-swapping</code>类地内容转换</li><li>可选的swap延迟</li><li>实际交换内容完成<ul><li><code>htmx-swapping</code> 类被移除</li><li><code>htmx-added</code> 类被添加到每个更改的元素上</li><li><code>htmx-settling</code> 类添加到target上</li><li>默认延迟</li><li>DOM完成</li><li><code>htmx-settling</code> 被移除</li><li><code>htmx-added</code>类被移除</li></ul></li></ul></li></ul></li></ul><h3 id="FYI"><a href="#FYI" class="headerlink" title="FYI"></a>FYI</h3><ol><li><a href="https://www.youtube.com/watch?v=jeT8m7490Pg">https://www.youtube.com/watch?v=jeT8m7490Pg</a></li><li><a href="https://htmx.org/"> htmx - high power tools for html</a>事实上,htmx是有争议的技术,但不妨碍它依旧很受欢迎</li><li><a href="https://golang-china.github.io/gopl-zh/ch1/ch1-01.html">Hello, World - Go语言圣经 (golang-china.github.io)</a></li><li><a href="https://golang.google.cn/learn/">Get Started - The Go Programming Language (google.cn)</a></li><li>More htmx examples<a href="https://htmx.org/examples/"> htmx ~ Examples</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;众所周知,一段时间前我一直在关注web开发框架,总的来说,大同小异. 如何进行快速开发小应用,是一个并不简单回答的问题.这里我给出一个解决方案:Go+HTMX.&lt;br&gt;</summary>
    
    
    
    
    <category term="web" scheme="https://www.sekyoro.top/tags/web/"/>
    
    <category term="htmx" scheme="https://www.sekyoro.top/tags/htmx/"/>
    
  </entry>
  
  <entry>
    <title>building makemore</title>
    <link href="https://www.sekyoro.top/2024/07/24/building-makemore/"/>
    <id>https://www.sekyoro.top/2024/07/24/building-makemore/</id>
    <published>2024-07-24T03:12:49.000Z</published>
    <updated>2024-07-24T03:13:21.123Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://karpathy.ai/zero-to-hero.html">Neural Networks: Zero To Hero (karpathy.ai)</a><br><span id="more"></span></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://karpathy.ai/zero-to-hero.html&quot;&gt;Neural Networks: Zero To Hero (karpathy.ai)&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>BTMC:重返Modern Cpp</title>
    <link href="https://www.sekyoro.top/2024/07/21/BTMC-%E9%87%8D%E8%BF%94Modern-Cpp/"/>
    <id>https://www.sekyoro.top/2024/07/21/BTMC-%E9%87%8D%E8%BF%94Modern-Cpp/</id>
    <published>2024-07-21T07:13:09.000Z</published>
    <updated>2024-09-12T08:46:48.742Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>之前写过modern cpp学习,但是只是过了一遍文字. 最近我在使用c++重写karpathy的micrograd,学到了很多.这里记录一下重要的东西</p><span id="more"></span><h3 id="模板黑魔法"><a href="#模板黑魔法" class="headerlink" title="模板黑魔法"></a>模板黑魔法</h3><blockquote><p>黑魔法是常人无法参透的,这里仅作简单介绍</p></blockquote><p>TODO:</p><h3 id="模板特化"><a href="#模板特化" class="headerlink" title="模板特化"></a>模板特化</h3><p>模板特化是C++模板机制中的一个重要特性，它允许程序员针对特定的数据类型或一组数据类型对模板进行定制。当编译器遇到一个特化的模板实例时，它会使用特化版本而不是通用模板版本。这可以用于优化特定类型的性能，处理不同数据类型之间的差异，或者实现完全不同的行为。</p><h4 id="模板特化概述"><a href="#模板特化概述" class="headerlink" title="模板特化概述"></a>模板特化概述</h4><p>假设你有一个模板函数<code>identity</code>，它的作用是返回传入的参数本身：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">identity</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">identity</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数模板特化"><a href="#函数模板特化" class="headerlink" title="函数模板特化"></a>函数模板特化</h4><p>你可以为特定类型（如<code>std::string</code>）特化这个模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">std::string identity&lt;std::string&gt;(<span class="keyword">const</span> std::string&amp; s) &#123;</span><br><span class="line">    <span class="comment">// 可以添加一些特定于std::string的操作</span></span><br><span class="line">    <span class="comment">// 例如，转换为大写</span></span><br><span class="line">    std::string result = s;</span><br><span class="line">    std::<span class="built_in">transform</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>(), result.<span class="built_in">begin</span>(), ::toupper);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，对于<code>std::string</code>类型，<code>identity</code>函数将返回一个全部字符转为大写的字符串，而对其他类型则保持原样。</p><h4 id="类模板特化"><a href="#类模板特化" class="headerlink" title="类模板特化"></a>类模板特化</h4><p>类模板也可以被特化。例如，假设我们有一个类模板<code>Box</code>，它可以存储任何类型的数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">const</span> T&amp; value)</span> </span>&#123; data = value; &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以为<code>int</code>类型特化<code>Box</code>类，以便为整数添加额外的功能，比如自动增加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;</span><span class="keyword">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; data = value + <span class="number">1</span>; &#125; <span class="comment">// 自动增加</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，<code>Box&lt;int&gt;</code>的行为就与<code>Box&lt;T&gt;</code>的通用版本不同了。</p><h4 id="完全特化与部分特化"><a href="#完全特化与部分特化" class="headerlink" title="完全特化与部分特化"></a>完全特化与部分特化</h4><p>完全特化是指为模板的所有参数指定特定类型，如上面的例子所示。部分特化是指只指定模板的部分参数，通常用于多参数模板，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分特化Pair&lt;int, int&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;</span><span class="keyword">int</span>, <span class="keyword">int</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="函数模板实例化"><a href="#函数模板实例化" class="headerlink" title="函数模板实例化"></a>函数模板实例化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> z = max&lt;<span class="keyword">int</span>&gt;(x, y); <span class="comment">// 函数模板实例化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="限定类型"><a href="#限定类型" class="headerlink" title="限定类型"></a>限定类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> = std::<span class="keyword">enable_if_t</span>&lt;std::is_arithmetic_v&lt;T&gt;&gt;&gt;</span><br><span class="line">class NumericWrapper &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumericWrapper</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        data = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getData</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>c++20以上使用<strong>concept</strong>能够好做限制,这里不做详细介绍.<a href="https://en.cppreference.com/w/cpp/concepts">Concepts library (since C++20) - cppreference.com</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> NumericType = std::is_arithmetic_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;NumericType T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumericWrapper</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumericWrapper</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        data = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getData</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">NumericWrapper&lt;<span class="keyword">int</span>&gt; <span class="title">intWrapper</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">NumericWrapper&lt;<span class="keyword">double</span>&gt; <span class="title">doubleWrapper</span><span class="params">(<span class="number">3.14</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的声明会导致编译错误</span></span><br><span class="line">    <span class="comment">// NumericWrapper&lt;std::string&gt; stringWrapper(&quot;Hello&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SFINAE与enable-if"><a href="#SFINAE与enable-if" class="headerlink" title="SFINAE与enable_if"></a>SFINAE与enable_if</h4><p>使用 <code>std::enable_if</code> 和 SFINAE（Substitution Failure Is Not An Error,替代错误不是错误）来限定类型。这种方法允许你在模板的定义阶段就排除不符合要求的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</span><br><span class="line">class NumericWrapper &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumericWrapper</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        data = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getData</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumericWrapper</span>&lt;</span>T, std::<span class="keyword">enable_if_t</span>&lt;std::is_arithmetic_v&lt;T&gt;&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumericWrapper</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        data = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getData</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">NumericWrapper&lt;<span class="keyword">int</span>&gt; <span class="title">intWrapper</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">NumericWrapper&lt;<span class="keyword">double</span>&gt; <span class="title">doubleWrapper</span><span class="params">(<span class="number">3.14</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的声明不会导致编译错误，但会生成一个空模板实例</span></span><br><span class="line">    <span class="function">NumericWrapper&lt;std::string&gt; <span class="title">stringWrapper</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>; <span class="comment">// 不符合要求的类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>模板特化常用于：</p><ul><li>为特定类型提供更高效的实现。</li><li>解决某些类型不适用的通用算法问题。</li><li>提供对基本类型和用户定义类型的统一接口，同时保持内部实现的差异性。</li></ul><h3 id="智能指针的使用场景"><a href="#智能指针的使用场景" class="headerlink" title="智能指针的使用场景"></a>智能指针的使用场景</h3><p>智能指针是C++中用来自动管理动态分配内存的一种手段，能帮助避免内存泄漏和其他与手动管理内存相关的问题.</p><p>智能指针本身也是指针,但是会通过编译器自动管理,表现行为像一个栈上的变量一样,在作用域之外就会自动析构.</p><p><code>std::unique_ptr</code>是一种独占所有权的智能指针，它保证了对所指向对象的独占访问。这意味着在同一时刻，只有一个<code>std::unique_ptr</code>可以指向同一个对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用new分配内存，并使用std::unique_ptr管理</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">uptr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用std::make_unique简化创建过程</span></span><br><span class="line">    std::unique_ptr&lt;<span class="keyword">int</span>&gt; uptr2 = std::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问智能指针所指向的对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;uptr points to: &quot;</span> &lt;&lt; *uptr &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;uptr2 points to: &quot;</span> &lt;&lt; *uptr2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unique_ptr在离开作用域时自动释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::shared_ptr</code>允许多个指针共享同一对象的所有权。当最后一个指向该对象的<code>std::shared_ptr</code>销毁时，对象的内存会被释放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个shared_ptr</span></span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">int</span>&gt; sptr1 = std::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从sptr1复制所有权</span></span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">int</span>&gt; sptr2 = sptr1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问智能指针所指向的对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sptr1 points to: &quot;</span> &lt;&lt; *sptr1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sptr2 points to: &quot;</span> &lt;&lt; *sptr2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shared_ptr在引用计数变为0时释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::weak_ptr不增加引用计数，它用于观察std::shared_ptr所管理的对象，而不会影响对象的生命周期。当std::shared_ptr不再存在时，std::weak_ptr可以被用来检查对象是否还活着，并锁定一个std::shared_ptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个shared_ptr</span></span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">int</span>&gt; sptr = std::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个weak_ptr</span></span><br><span class="line">    std::weak_ptr&lt;<span class="keyword">int</span>&gt; wptr = sptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查weak_ptr是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (!wptr.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">        std::shared_ptr&lt;<span class="keyword">int</span>&gt; sptr2 = wptr.<span class="built_in">lock</span>(); <span class="comment">// 锁定一个shared_ptr</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;wptr points to: &quot;</span> &lt;&lt; *sptr2 &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放shared_ptr，观察weak_ptr的行为</span></span><br><span class="line">    sptr.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次检查weak_ptr是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (wptr.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The object has been deleted.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板类的友元函数重载-lt-lt-符号"><a href="#模板类的友元函数重载-lt-lt-符号" class="headerlink" title="模板类的友元函数重载&lt;&lt;符号"></a>模板类的友元函数重载&lt;&lt;符号</h3><p>给一个模板类写个友元函数重载<code>&lt;&lt;</code>方便ostream输出信息,但是报错链接出错.</p><p><a href="https://blog.csdn.net/Move_now/article/details/64530664">函数模板和友元重载运算符报”无法解析的外部符”的解决方法_输出运算符重载 无法解析-CSDN博客</a></p><p><strong>两次编译的函数头不一样，因为友元函数并不属于类的成员函数，所以需要单独声明此友元函数是函数模板</strong>，如果没有声明，但是后面在实现的时候又使用了<code>template &lt;class T&gt;</code>，就会导致错误的发生。</p><h3 id="右值和移动"><a href="#右值和移动" class="headerlink" title="右值和移动"></a>右值和移动</h3><blockquote><p>Use std::move(x) to turn x, an l-value, to an r-value so  that you can immediately take its resources</p></blockquote><ul><li><p><strong>泛左值</strong>（“泛化 (generalized)”的左值）是一个<strong>求值可确定某个对象或函数的标识的表达式</strong>；</p></li><li><p>纯右值</p><p>（“纯 (pure)”的右值）是求值符合下列之一的表达式：</p><ul><li>计算某个运算符的操作数的值（这种纯右值没有<em>结果对象</em>）</li><li>初始化某个对象（称这种纯右值有一个<em>结果对象</em>）</li></ul></li><li><p><strong>亡值</strong>（“将亡 (expiring)”的值）是代表它的资源能够被重新使用的对象或位域的泛左值；</p></li><li><strong>左值 (lvalue)</strong> 是并非亡值的泛左值；</li></ul><p>移动语义允许在对象从一个位置移动到另一个位置时，通过移动而非复制对象的状态，从而避免了昂贵的复制操作。这在处理大型对象或资源（如文件句柄、智能指针）时尤其重要，因为移动语义可以显著提升性能。</p><p>右值通常用来表示临时对象或字面量，这些对象在表达式求值后就不再需要。例如，函数返回的临时对象、构造函数参数中的字面量等都是右值</p><p>右值引用用于实现移动语义</p><h3 id="OOP-in-C"><a href="#OOP-in-C" class="headerlink" title="OOP in C++"></a>OOP in C++</h3><blockquote><p>C++中的面向对象设计也许并不好或者说糟糕</p></blockquote><p>编译器会为每个类默认生成特别方法,包括</p><ul><li>无参构造</li><li>拷贝构造</li><li>拷贝赋值</li><li>移动构造</li><li>移动赋值</li><li>析构方法</li></ul><p>如果类中的变量没有人为内存的分配,也许你并不需要显式声明拷贝、移动与析构方法.</p><p>当声明拷贝构造、赋值时,最好声明移动构造、赋值以及析构方法.</p><p><code>std::move</code>在移动构造、赋值中使用,表明需要使用移动操作,而不要在main中使用.</p><h4 id="Type-Safety"><a href="#Type-Safety" class="headerlink" title="Type Safety"></a>Type Safety</h4><blockquote><p>Type Safety: The extent to  which a language prevents  typing errors</p></blockquote><p>使用<code>std::optional</code></p><h2 id="Beyond-C-2a"><a href="#Beyond-C-2a" class="headerlink" title="Beyond C++2a"></a>Beyond C++2a</h2><h3 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">concept</span> Addable = <span class="built_in">requries</span>(T a, T b) &#123;</span><br><span class="line">  a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">requires</span> Addable&lt;T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;Addable T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>限制泛型中参数的类型. </p><p><img data-src="https://s2.loli.net/2024/08/19/C6l2sNhcEtTBwa7.png" alt="image-20240819005006425"></p><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>目前我认为模块机制在c++生态用得不是很多,权当了解即可.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">module</span> myModule</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">import</span> myModule</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">sayHello</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.geeksforgeeks.org/modules-in-cpp-20/">Modules in C++ 20 - GeeksforGeeks</a></p><h3 id="std-ranges"><a href="#std-ranges" class="headerlink" title="std::ranges"></a>std::ranges</h3><p>引入头文件<code>#include&lt;ranges&gt;</code>和<code>#include&lt;algorithms&gt;</code></p><p>常用的一些算法通常是对迭代器进行操作(STL)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>()+<span class="number">1</span>,v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>在引入ranges后,有了更加统一的方法</p><blockquote><p>ranges是“项的集合”或“可迭代的东西”的抽象。最基本的定义只要求在ranges上存在begin()和end()</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::ranges::<span class="built_in">sort</span>(std::views::<span class="built_in">drop</span>(v,<span class="number">5</span>));</span><br><span class="line">std::ranges::<span class="built_in">sort</span>(std::views::<span class="built_in">reverse</span>(v));</span><br><span class="line">std::ranges::<span class="built_in">sort</span>(std::views::<span class="built_in">drop</span>(std::views::<span class="built_in">reverse</span>(v),<span class="number">5</span>));</span><br></pre></td></tr></table></figure><p>有多个关于ranges的concept</p><div class="table-container"><table><thead><tr><th>Concept</th><th>Description</th></tr></thead><tbody><tr><td><code>std::ranges::input_range</code></td><td>can be iterated from beginning to end <strong>at least once</strong></td></tr><tr><td><code>std::ranges::forward_range</code></td><td>can be iterated from beginning to end <strong>multiple times</strong></td></tr><tr><td><code>std::ranges::bidirectional_range</code></td><td>iterator can also move backwards with <code>--</code></td></tr><tr><td><code>std::ranges::random_access_range</code></td><td>you can jump to elements <strong>in constant-time</strong> <code>[]</code></td></tr><tr><td><code>std::ranges::contiguous_range</code></td><td>elements are always stored consecutively in memory</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center"><code>std::forward_list</code></th><th style="text-align:center"><code>std::list</code></th><th style="text-align:center"><code>std::deque</code></th><th style="text-align:center"><code>std::array</code></th><th style="text-align:center"><code>std::vector</code></th><th></th></tr></thead><tbody><tr><td style="text-align:center"><code>std::ranges::input_range</code></td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td>✅</td></tr><tr><td style="text-align:center"><code>std::ranges::forward_range</code></td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td>✅</td></tr><tr><td style="text-align:center"><code>std::ranges::bidirectional_range</code></td><td style="text-align:center"></td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td>✅</td></tr><tr><td style="text-align:center"><code>std::ranges::random_access_range</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td>✅</td></tr><tr><td style="text-align:center"><code>std::ranges::contiguous_range</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✅</td><td>✅</td></tr></tbody></table></div><p>views的一个关键特性是，无论它们应用了什么转换，它们都是在请求元素的时候进行的，而不是在创建views的时候</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> v = vec | std::views::reverse | std::views::<span class="built_in">drop</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; *v.<span class="built_in">begin</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><p>views是一种特定类型的ranges，在std::ranges::view中被形式化。</p><h3 id="C-20之后定义比较运算符"><a href="#C-20之后定义比较运算符" class="headerlink" title="C++20之后定义比较运算符"></a>C++20之后定义比较运算符</h3><p>为了检查是否相等，现在定义 == 操作符就够了。 <strong>当编译器找不到表达式的匹配声明 a!=b 时，编译器会重写表达式并查找!(a\==b)。若这不起作用，编译器也会尝试改变操作数的顺序，所以也会尝试!(b==a)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> TypeA&amp;, <span class="keyword">const</span> TypeB&amp;);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">struct NullTerm &#123;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>== (<span class="keyword">auto</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *pos == <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// end is where iterator points to \verb+&#x27;\0&#x27;+</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于所有的关系操作符，没有等价的规则说定义小于操作符就足够了。但现在，只需要定义新的操作符 &lt;=&gt; 即可。</p><p>通常，== 可以通过定义 == 和!= 操作符来处理对象的相等性，而 &lt;=&gt; 操作符通过定义关系操作 符来处理对象的顺序。若通过 =default 声明操作符 &lt;=&gt;，则可以使用了一个特殊的规则，即默认成员操作符 &lt;=&gt;:</p><p>• 若比较成员不抛出异常，则是 noexcept </p><p>• 若可在编译时比较成员，则是 constexpr </p><p>• 因为重写，还可以支持第一个操作数的隐式类型转换</p><p>通常情况下，== 和 &lt;=&gt; 操作符处理不同但相关的事情: • == 操作符定义相等性，可由相等操作符 == 和!= 使用。 • &lt;=&gt; 操作符定义了排序，可以由关系操作符 &lt;、&lt;=、&gt; 和 &gt;= 使用</p><h3 id="auto类型推断"><a href="#auto类型推断" class="headerlink" title="auto类型推断"></a>auto类型推断</h3><p>c++20之后,在普通函数中即可使用.</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="static-inline和extern-链接类型"><a href="#static-inline和extern-链接类型" class="headerlink" title="static,inline和extern. 链接类型"></a>static,inline和extern. 链接类型</h3><p>链接使用linker将多个编译得到.o文件链接为可执行程序. 多个链接单元不允许重复定义的变量或函数等.</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240909213919267.png" alt="image-20240909213919267"></p><p>inline,避免多次定义<br>inline 修饰的函数具有外部链接属性(externallinkage)。在链接时,只会保留一个定义。C++17 引入了内联变量（inline variable）的概念，<strong>允许在头文件中定义变量而不会违反 One Definition Rule（ODR）</strong>。<br>要声明内联变量,可以在变量声明前加上 inline 关键字。这告诉编译器允许多个编译单元中都有这个变量的定义,而不会引发 ODR 错误<br>static,内部链接属性(internal linkage),修饰的全局变量的作用域仅限于定义它的文件。这意味着其他文件无法访问该变量,使用 static 可以避免命名冲突，因为每个源文件中的 static变量是独立的，即使它们同名也不会互相干扰<br>extern,用于声明一个全局变量或函数,表明该变量或函数在其他文件中定义。它允许在一个文件中使用另一个文件中定义的变量<br>当 extern 用于声明一个变量或函数时,它指定该符号具有外部链接属性<br>通常在头文件中定义/声明全局变量，以便其他源文件可以包含该头文件并使用这些变量<br>在多个文件中重复定义同名的 extern 变量,会导致链接错误<br>外部链接属性意味着该符号可以被程序中的其他翻译单元访问。<br>对于函数,默认情况下它们就具有外部链接属性,无需使用 extern 关键字。</p><blockquote><p>在 C++ 中，类的成员方法如果在类的定义中直接实现,则默认是 <strong>inline</strong> 的.内联函数具有外部链接属性，是弱符号。在类外实现默认不是inline,对应强符号。</p><p>一般将不需要内联的成员函数的定义编写在.cpp文件中，这样可以避免此类错误,这样多个其他文件引入头文件时不会造成重定义.</p></blockquote><h3 id="模板声明和定义放一个文件的目的"><a href="#模板声明和定义放一个文件的目的" class="headerlink" title="模板声明和定义放一个文件的目的."></a>模板声明和定义放一个文件的目的.</h3><p>在使用模板时，这种习惯性做法将变得不再有用，<strong>因为当实例化一个模板时，编译器必须看到模板确切的定义，而不仅仅是它的声明</strong>。因此，最好的办法就是将模板的声明和定义都放置在同一个.h文件</p><p>因为在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现，在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在，所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。</p><h3 id="现代c-中类似函数式编程思想中的一些操作-比如filter-map-reduce-fold-等"><a href="#现代c-中类似函数式编程思想中的一些操作-比如filter-map-reduce-fold-等" class="headerlink" title="现代c++中类似函数式编程思想中的一些操作,比如filter,map,reduce(fold)等"></a>现代c++中类似函数式编程思想中的一些操作,比如filter,map,reduce(fold)等</h3><ol><li><code>std::transform</code> (类似 map)</li></ol><p><code>std::transform</code> 是 C++ 标准库中的一个算法,位于 <code>&lt;algorithm&gt;</code> 头文件中。它可以对容器中的元素应用一个函数,并将结果存储到另一个容器中。这类似于函数式编程中的 <code>map</code> 操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">squares</span><span class="params">(numbers.size())</span></span>;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">transform</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), squares.<span class="built_in">begin</span>(), [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> x * x; &#125;);</span><br></pre></td></tr></table></figure><ol><li><code>std::remove_if和std::erase</code> (类似 filter)</li></ol><p>虽然 C++ 标准库中没有直接对应 <code>filter</code> 的算法,但可以使用 <code>std::remove_if</code> 和 <code>std::erase</code> 来实现类似的功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">numbers.<span class="built_in">erase</span>(std::<span class="built_in">remove_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;), numbers.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>注意remove和remove_if一般需要搭配std::erase进行实际删除,因为前两者会返回一个新容器,而旧的容器没有被改变. 被remove的值会在后面,前面的值保持原来的相对位置,使用erase(new_it_end,old_end)进行删除.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 谓词：如果元素是偶数，则返回 true</span></span><br><span class="line">    <span class="keyword">auto</span> is_even = [](<span class="keyword">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::ranges::remove_if 将偶数元素移到容器的末尾</span></span><br><span class="line">    <span class="keyword">auto</span> new_end = std::ranges::<span class="built_in">remove_if</span>(numbers, is_even);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::erase 删除这些元素</span></span><br><span class="line">    numbers.<span class="built_in">erase</span>(new_end, numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果：1 3 5 7 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::views中存在filter可以在不改变原数据实现上述功能,或者使用copy_if搭配</p><blockquote><p>视图是一种在范围上应用并执行某些操作的东西。视图不拥有数据，它的复制、移动或赋值时间复杂度为常数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; evenNumbers;</span><br><span class="line">    std::<span class="built_in">copy_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(evenNumbers), isEven);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : evenNumbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Output: 2 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong><code>std::back_inserter</code> 返回一个后向插入迭代器</strong>,当被解引用并赋值时,会在容器末尾执行 <code>push_back()</code> 操作。</li><li><strong>允许通常会覆盖元素的算法</strong>（如 <code>std::copy</code>）改为在容器末尾插入新元素。</li><li><strong>可与支持 <code>push_back()</code> 成员函数的容器一起使用</strong>,例如 <code>std::vector</code> 和 <code>std::deque</code>。</li><li><strong>不能用于不支持 <code>push_back()</code> 的容器</strong>,如 <code>std::set</code> 或 <code>std::map</code>,这种情况下可以使用 <code>std::inserter</code> 代替。</li><li><p><strong>使用 <code>std::back_inserter</code> 比在算法循环内手动调用 <code>push_back()</code> 更高效</strong>。</p></li><li><p><code>std::accumulate</code> (类似 reduce/fold)</p></li></ol><p><code>std::accumulate</code> 是 C++ 标准库中的一个算法,位于 <code>&lt;numeric&gt;</code> 头文件中。它可以对容器中的元素进行累积操作,类似于函数式编程中的 <code>reduce</code> 或 <code>fold</code> 操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = std::<span class="built_in">accumulate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>c++中也有std::reduce, 更适合于可以并行处理的场景，尤其是当操作是可交换和可结合的（例如加法和乘法）时。以选择不提供初始值，在这种情况下，它会默认构造一个初始值。这可能导致潜在的问题</p><ol><li><code>std::ranges</code> (C++20 中的函数式编程风格)</li></ol><p>C++20 引入了 <code>std::ranges</code> 库,它提供了一种更函数式编程风格的操作容器的方式。使用 <code>std::views</code> 命名空间中的算法,可以实现类似 <code>map</code>、<code>filter</code> 和 <code>reduce</code> 的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cpp<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> squares = numbers | std::views::<span class="built_in">transform</span>([](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> x * x; &#125;);</span><br></pre></td></tr></table></figure><ol><li>Lambda 表达式</li></ol><p>C++11 引入了 lambda 表达式,它允许你定义匿名函数。Lambda 表达式可以与上述算法一起使用,提供了类似函数式编程中的 <code>map</code>、<code>filter</code> 和 <code>reduce</code> 的功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cpp<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = std::<span class="built_in">accumulate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">0</span>, [](<span class="keyword">int</span> acc, <span class="keyword">int</span> x) &#123; <span class="keyword">return</span> acc + x; &#125;);</span><br></pre></td></tr></table></figure><p>使用mutable使得lambda函数可以修改闭包的值.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按引用捕获</span></span><br><span class="line">   <span class="keyword">auto</span> modifyByReference = [&amp;value]()<span class="keyword">mutable</span> &#123;</span><br><span class="line">       value += <span class="number">5</span>; <span class="comment">// 修改外部变量</span></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><p>上面我最想提到的就是std::ranges和std::views,有了它们通过<code>|</code>符号,才有了函数式编程的感觉😋 下面更细致介绍一下</p><p>C++20 引入了 <strong>Ranges</strong> 库，这是对传统算法和迭代器库的扩展和概括，使得操作数据结构（如数组、向量等）更加简洁和强大。</p><ul><li><p><strong>范围（Range）</strong>：范围是一个可以迭代的对象，通常由两个迭代器（一个指向起始位置，另一个指向结束位置）表示。C++ 标准库中的容器（如 <code>std::vector</code> 和 <code>std::list</code>）都是范围的实现。</p></li><li><p><strong>适配器（Adaptor）</strong>：范围适配器是用于转换一个范围为另一个范围的功能。例如，<code>std::views::filter</code> 可以创建一个新范围，其中只包含满足特定条件的元素。</p></li><li><blockquote><p>视图不拥有数据。因此，视图不会延长其数据的生命周期。因此，视图只能对左值操作。如果在临时范围上定义视图，则编译将失败。</p></blockquote></li></ul><ol><li><p><strong>组合性</strong>：Ranges 允许将多个算法通过管道符号 <code>|</code> 组合在一起，形成更简洁的代码。例如，可以将过滤和变换操作组合在一起，而无需创建中间容器。</p></li><li><p><strong>惰性求值</strong>：许多范围适配器是惰性求值的，意味着它们不会立即计算结果，而是在实际需要时才会执行。这可以提高性能，尤其是在处理大型数据集时。</p></li><li><p><strong>简化语法</strong>：使用 Ranges，可以避免显式地获取迭代器的繁琐步骤，直接在容器上调用算法。</p></li><li><p><strong>并行支持</strong>：C++20 Ranges 还支持并行执行，允许在多核处理器上高效地处理数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用copy_if拷贝数组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ranges&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; even_numbers;</span><br><span class="line"></span><br><span class="line">    std::ranges::<span class="built_in">copy_if</span>(numbers, std::<span class="built_in">back_inserter</span>(even_numbers), [](<span class="keyword">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : even_numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 2 4 6</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用filter和transform变换容器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ranges&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用范围适配器过滤出偶数并平方</span></span><br><span class="line">    <span class="keyword">auto</span> even_squares = numbers </span><br><span class="line">                        | std::views::<span class="built_in">filter</span>([](<span class="keyword">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;)</span><br><span class="line">                        | std::views::<span class="built_in">transform</span>([](<span class="keyword">int</span> n) &#123; <span class="keyword">return</span> n * n; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : even_squares) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 4 16 36</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外还有std::views::reverse,take,drop等等操作.在我看来可以直接使用ranges替代很多algorithm中的操作了. </p><h4 id="范围算法-Range-Algorithms"><a href="#范围算法-Range-Algorithms" class="headerlink" title="范围算法(Range Algorithms)"></a>范围算法(Range Algorithms)</h4><p><code>std::ranges::copy</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cpp<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; destination;</span><br><span class="line">std::ranges::<span class="built_in">copy</span>(numbers, std::<span class="built_in">back_inserter</span>(destination));</span><br></pre></td></tr></table></figure><p><code>std::ranges::transform</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppstd::vector&lt;<span class="keyword">int</span>&gt; transformed;</span><br><span class="line">std::ranges::<span class="built_in">transform</span>(numbers, std::<span class="built_in">back_inserter</span>(transformed), [](<span class="keyword">int</span> n) &#123; <span class="keyword">return</span> n * <span class="number">2</span>; &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppint count = std::ranges::<span class="built_in">count_if</span>(numbers, [](<span class="keyword">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Even numbers count: &quot;</span> &lt;&lt; count; <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure><p><code>std::ranges::for_each</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ranges&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::views::filter 过滤偶数，然后遍历并打印</span></span><br><span class="line">    std::ranges::for_each(numbers | std::views::<span class="built_in">filter</span>([](<span class="keyword">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;),</span><br><span class="line">                           [](<span class="keyword">int</span> n) &#123;</span><br><span class="line">                               std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                           &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::views::iota</code>是一个范围工厂，用于通过逐渐增加初始值来创建元素序列。这个序列可以是有限的或无限的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; vec2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: std::views::<span class="built_in">iota</span>(<span class="number">0</span>, <span class="number">10</span>)) vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: std::views::<span class="built_in">iota</span>(<span class="number">0</span>) | std::views::<span class="built_in">take</span>(<span class="number">10</span>)) vec2.<span class="built_in">push_back</span>(i);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vec == vec2: &quot;</span> &lt;&lt; (vec == vec2) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: vec) std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于map也有像python那样的操作了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::unordered_map&lt;std::string, <span class="keyword">int</span>&gt; m&#123;&#123;<span class="string">&quot;jack&quot;</span>,  <span class="number">10086</span>&#125;,&#123;<span class="string">&quot;black&quot;</span>, <span class="number">10010</span>&#125;&#125;;                                </span><br><span class="line">    <span class="keyword">auto</span> names = std::views::<span class="built_in">keys</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;name: names) &#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> values = std::views::<span class="built_in">values</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;value: values) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_42896106/article/details/128737878">C++ 20 新特性 ranges 精讲_c++ ranges-CSDN博客</a></p></li></ol><h3 id="decay蜕变类型"><a href="#decay蜕变类型" class="headerlink" title="decay蜕变类型"></a>decay蜕变类型</h3><p><code>std::decay</code> 是 C++ 标准库中的一个类型特征，用于对类型进行转换，主要用于在模板编程中简化类型处理。它的主要功能是将类型转换为其“衰变”类型（decayed type）</p><p>具体来说，<code>std::decay</code> 进行以下三种类型转换：</p><ol><li><strong>去除引用</strong>：如果类型是引用类型（如 <code>int&amp;</code> 或 <code>const int&amp;</code>），<code>std::decay</code> 会去掉引用，返回原始类型（如 <code>int</code>）。</li><li><strong>去除常量和易变性修饰符</strong>：如果类型是常量（<code>const</code>）或易变（<code>volatile</code>）的，<code>std::decay</code> 会去掉这些修饰符。</li><li><strong>数组和函数转换</strong>：如果类型是数组（如 <code>int</code>）或函数（如 <code>int()</code>），<code>std::decay</code> 会将其转换为指针类型（如 <code>int*</code> 或 <code>int(*)()</code>）。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本类型</span></span><br><span class="line">    std::cout &lt;&lt; std::is_same&lt;std::decay&lt;<span class="keyword">int</span>&gt;::type, <span class="keyword">int</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用类型</span></span><br><span class="line">    std::cout &lt;&lt; std::is_same&lt;std::decay&lt;<span class="keyword">int</span>&amp;&gt;::type, <span class="keyword">int</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; std::is_same&lt;std::decay&lt;<span class="keyword">const</span> <span class="keyword">int</span>&amp;&gt;::type, <span class="keyword">int</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组类型</span></span><br><span class="line">    std::cout &lt;&lt; std::is_same&lt;std::decay&lt;<span class="keyword">int</span>[<span class="number">10</span>]&gt;::type, <span class="keyword">int</span>*&gt;::value &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数类型</span></span><br><span class="line">    std::cout &lt;&lt; std::is_same&lt;std::decay&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt;::type, <span class="built_in"><span class="keyword">void</span></span>(*)(<span class="keyword">int</span>)&gt;::value &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>volatile</code> 是 C++ 中的一个类型修饰符，用于告诉编译器某个变量的值可能会在程序的控制之外发生变化。这意味着编译器在优化代码时不应假设该变量的值是固定的</p></blockquote><h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><p>​    在 <code>multimap</code> 中，键可以重复。这意味着多个键值对可以具有相同的键，而在 <code>map</code> 中，键是唯一的，插入相同的键会覆盖之前的值.</p><p><code>multimap</code> 通常是基于红黑树实现的，这使得插入、删除和查找操作的时间复杂度为 O(log n)，其中 n 是元素的数量.<code>multimap</code> 不支持使用下标运算符（<code>[]</code>）或 <code>at()</code> 方法直接访问元素，因为相同的键可能对应多个值。</p><p>​    要访问特定键的所有值，可以使用 <code>equal_range()</code> 方法，该方法返回一个包含所有匹配键的值的迭代器范围.</p><p>​    <code>multimap</code> 中的元素是按照键的顺序存储的，默认情况下，使用 <code>std::less&lt;Key&gt;</code> 进行排序，确保元素按升序排列。相同的键值会按照插入顺序排列</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.learncpp.com/">Learn C++ – Skill up with our free tutorials (learncpp.com)</a></li><li><a href="https://cplusplus.com/">cplusplus.com</a></li><li><a href="https://en.cppreference.com/w/">cppreference.com</a></li><li><a href="https://changkun.de/modern-cpp/">现代 C++ 教程: 高速上手 C++ 11/14/17/20 - Modern C++ Tutorial: C++ 11/14/17/20 On the Fly (changkun.de)</a></li><li><a href="https://learn-cpp.guyutongxue.site/">首页 | 谷雨同学的 C++ 教程 (guyutongxue.site)</a></li><li><a href="https://web.stanford.edu/class/cs106l/index.html">CS 106L: Standard C++ Programming (stanford.edu)</a></li><li>Best Practices<a href="https://lefticus.gitbooks.io/cpp-best-practices/content">https://lefticus.gitbooks.io/cpp-best-practices/content</a></li></ul><p>cpp书单<a href="https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list">c++ faq - The Definitive C++ Book Guide and List - Stack Overflow</a></p><p>感谢大模型的辅助</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前写过modern cpp学习,但是只是过了一遍文字. 最近我在使用c++重写karpathy的micrograd,学到了很多.这里记录一下重要的东西&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://www.sekyoro.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>学习llama3</title>
    <link href="https://www.sekyoro.top/2024/07/08/%E5%AD%A6%E4%B9%A0llama3/"/>
    <id>https://www.sekyoro.top/2024/07/08/%E5%AD%A6%E4%B9%A0llama3/</id>
    <published>2024-07-08T06:44:29.000Z</published>
    <updated>2024-07-08T15:22:46.235Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>llama3是meta开源的大模型,在开源大模型中占着重要地位,在这之前可能是Mistral,目前也有gemma2,Qwen2以及微软的Phi3等.<br><span id="more"></span></p><p>llama表现很不错,<a href="https://toloka.ai/llm-leaderboard/">LLM Leaderboard (toloka.ai)</a>,很多模型都是在它基础上微调得到的.</p><p>这里将llama介绍分为位置编码,transformer层,ffn层以及其中的norm的改进.</p><p>llama3相比于llama2,上下文窗口增大,tokenizer从sentencepiece变为tiktoken,token数也增多了.</p><div class="table-container"><table><thead><tr><th><strong>Feature</strong></th><th><strong>LLaMa 2</strong></th><th><strong>LLaMa 3</strong></th></tr></thead><tbody><tr><td><strong>Training Data Size</strong></td><td>2 trillion tokens</td><td>15 trillion tokens (7x larger)</td></tr><tr><td><strong>Context Window</strong></td><td>4K tokens</td><td>8k tokens</td></tr><tr><td><strong>Focus Area</strong></td><td>General language understanding</td><td>Nuance, context, complex tasks</td></tr><tr><td><strong>False Refusal Rate</strong></td><td>Higher</td><td>Lower</td></tr><tr><td><strong>Response Diversity</strong></td><td>Lower</td><td>Higher</td></tr><tr><td><strong>Code Generation</strong></td><td>Limited capability</td><td>Enhanced capability</td></tr></tbody></table></div><h2 id="旋转位置编码"><a href="#旋转位置编码" class="headerlink" title="旋转位置编码"></a>旋转位置编码</h2><blockquote><p>旋转位置嵌入（RoPE）是一种用于基于transformer模型的技术，可将位置信息纳入标记表示中。与依赖正弦和余弦函数的传统位置编码不同，<strong>RoPE 利用旋转矩阵来编码绝对和相对位置信息</strong>。这种方法的提出是为了提高位置嵌入在transformer中的有效性。Meta的LLaMA、清华的ChatGLM都采用了RoPE</p></blockquote><script type="math/tex; mode=display">\begin{aligned}\mathrm{RoPE}(x,m)& =xe^{mi\theta} \\\langle\mathrm{RoPE}(q_j,m),\mathrm{RoPE}(k_j,n)\rangle & =\langle q_je^{mi\theta},k_je^{ni\theta}\rangle  \\&=q_jk_je^{mi\theta}\overline{e^{ni\theta}} \\&=q_jk_je^{(m-n)i\theta} \\&=\mathrm{RoPE}(q_jk_j,m-n)\end{aligned}\begin{aligned}\mathrm{RoPE}(x,m)& =xe^{mi\theta} \\\langle\mathrm{RoPE}(q_j,m),\mathrm{RoPE}(k_j,n)\rangle & =\langle q_je^{mi\theta},k_je^{ni\theta}\rangle  \\&=q_jk_je^{mi\theta}\overline{e^{ni\theta}} \\&=q_jk_je^{(m-n)i\theta} \\&=\mathrm{RoPE}(q_jk_j,m-n)\end{aligned}</script><p>在llama3中代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">precompute_freqs_cis</span>(<span class="params">dim: <span class="built_in">int</span>, end: <span class="built_in">int</span>, theta: <span class="built_in">float</span> = <span class="number">10000.0</span></span>):</span></span><br><span class="line">    freqs = <span class="number">1.0</span> / (theta ** (torch.arange(<span class="number">0</span>, dim, <span class="number">2</span>)[: (dim // <span class="number">2</span>)].<span class="built_in">float</span>() / dim)) <span class="comment"># 一个位置上的特征</span></span><br><span class="line">    t = torch.arange(end, device=freqs.device, dtype=torch.float32)</span><br><span class="line">    freqs = torch.outer(t, freqs)</span><br><span class="line">    freqs_cis = torch.polar(torch.ones_like(freqs), freqs)  <span class="comment"># complex64 # 得到e^freqs^ shape [T,dim//2]</span></span><br><span class="line">    <span class="keyword">return</span> freqs_cis</span><br><span class="line"></span><br><span class="line">self.freqs_cis = precompute_freqs_cis(</span><br><span class="line">    params.dim // params.n_heads,</span><br><span class="line">    params.max_seq_len * <span class="number">2</span>,</span><br><span class="line">    params.rope_theta,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reshape_for_broadcast</span>(<span class="params">freqs_cis: torch.Tensor, x: torch.Tensor</span>):</span></span><br><span class="line">    ndim = x.ndim</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">0</span> &lt;= <span class="number">1</span> &lt; ndim</span><br><span class="line">    <span class="keyword">assert</span> freqs_cis.shape == (x.shape[<span class="number">1</span>], x.shape[-<span class="number">1</span>])</span><br><span class="line">    shape = [d <span class="keyword">if</span> i == <span class="number">1</span> <span class="keyword">or</span> i == ndim - <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">for</span> i, d <span class="keyword">in</span> <span class="built_in">enumerate</span>(x.shape)]</span><br><span class="line">    <span class="keyword">return</span> freqs_cis.view(*shape)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_rotary_emb</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        xq: torch.Tensor,</span></span></span><br><span class="line"><span class="params"><span class="function">        xk: torch.Tensor,</span></span></span><br><span class="line"><span class="params"><span class="function">        freqs_cis: torch.Tensor,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) -&gt; <span class="type">Tuple</span>[torch.Tensor, torch.Tensor]:</span></span><br><span class="line">    xq_ = torch.view_as_complex(xq.<span class="built_in">float</span>().reshape(*xq.shape[:-<span class="number">1</span>], -<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">#shape [bs,seq_len,dim//2,2] -&gt; [bs,seq_len,dim]</span></span><br><span class="line">    xk_ = torch.view_as_complex(xk.<span class="built_in">float</span>().reshape(*xk.shape[:-<span class="number">1</span>], -<span class="number">1</span>, <span class="number">2</span>))<span class="comment">#shape [bs,seq_len,dim//2,2] -&gt; [bs,seq_len,dim]</span></span><br><span class="line">    freqs_cis = reshape_for_broadcast(freqs_cis, xq_) <span class="comment"># [1,seq_len,dim]</span></span><br><span class="line">    xq_out = torch.view_as_real(xq_ * freqs_cis).flatten(<span class="number">3</span>)<span class="comment">#[bs,seq_len,dim//2,2] type float32 -&gt; </span></span><br><span class="line">    xk_out = torch.view_as_real(xk_ * freqs_cis).flatten(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> xq_out.type_as(xq), xk_out.type_as(xk)</span><br><span class="line"></span><br><span class="line">xq, xk = apply_rotary_emb(xq, xk, freqs_cis=freqs_cis)</span><br></pre></td></tr></table></figure><p>计算freqs_cis,其是一个复数,旋转编码通常应用在q和k上.</p><script type="math/tex; mode=display">\mathrm{RoPE}(x_m^{(1)},x_m^{(2)},m)=\begin{bmatrix}\cos(m\theta)&-\sin(m\theta)\\\sin(m\theta)&\cos(m\theta)\end{bmatrix}\begin{bmatrix}x_m^{(1)}\\x_m^{(2)}\end{bmatrix}=\begin{bmatrix}x_m^{(1)}\cos(m\theta)-x_m^{(2)}\sin(m\theta)\\x_m^{(2)}\cos(m\theta)+x_m^{(1)}\sin(m\theta)\end{bmatrix}\\\Theta=\theta_i=10,000^{-\frac{2(i-1)}d},where(i\in[1,2,\ldots,d])\text{ for the $\frac{d}{2}$ pairs of features.}</script><p>下面是另一种实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RotaryPositionalEmbeddings</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, d: <span class="built_in">int</span>, base: <span class="built_in">int</span> = <span class="number">10_000</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.base = base</span><br><span class="line">        self.d = d</span><br><span class="line">        self.cos_cached = <span class="literal">None</span></span><br><span class="line">        self.sin_cached = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_build_cache</span>(<span class="params">self, x: torch.Tensor</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.cos_cached <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> x.shape[<span class="number">0</span>] &lt;= self.cos_cached.shape[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        seq_len = x.shape[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># THETA = 10,000^(-2*i/d) or 1/10,000^(2i/d)</span></span><br><span class="line">        theta = <span class="number">1.</span> / (self.base ** (torch.arange(<span class="number">0</span>, self.d, <span class="number">2</span>).<span class="built_in">float</span>() / self.d)).to(x.device)</span><br><span class="line">        <span class="comment"># Position index [0,1,...]</span></span><br><span class="line">        seq_idx = torch.arange(seq_len, device=x.device).<span class="built_in">float</span>().to(x.device)</span><br><span class="line"></span><br><span class="line">        idx_theta = torch.einsum(<span class="string">&#x27;n,d-&gt;nd&#x27;</span>, seq_idx,</span><br><span class="line">                                 theta)  <span class="comment"># Calculates m*(THETA) = [ [0, 0...], [THETA_1, THETA_2...THETA_d/2], ... [seq-1*(THETA_1), seq-1*(THETA_2)...] ]</span></span><br><span class="line"></span><br><span class="line">        idx_theta2 = torch.cat([idx_theta, idx_theta],</span><br><span class="line">                               dim=<span class="number">1</span>)  <span class="comment"># [THETA_1, THETA_2...THETA_d/2] -&gt; [THETA_1, THETA_2...THETA_d]</span></span><br><span class="line">        self.cos_cached = idx_theta2.cos()[:, <span class="literal">None</span>, <span class="literal">None</span>, :]  <span class="comment"># Cache [cosTHETA_1, cosTHETA_2...cosTHETA_d]</span></span><br><span class="line">        self.sin_cached = idx_theta2.sin()[:, <span class="literal">None</span>, <span class="literal">None</span>, :]  <span class="comment"># cache [sinTHETA_1, sinTHETA_2...sinTHETA_d]</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_neg_half</span>(<span class="params">self, x: torch.Tensor</span>):</span></span><br><span class="line">        d_2 = self.d // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> torch.cat([-x[:, :, :, d_2:], x[:, :, :, :d_2]], dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x: torch.Tensor</span>):</span></span><br><span class="line">        self._build_cache(x)</span><br><span class="line">        neg_half_x = self._neg_half(x)</span><br><span class="line">        x_rope = (x * self.cos_cached[:x.shape[<span class="number">0</span>]]) + (neg_half_x * self.sin_cached[:x.shape[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> x_rope</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    x = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]], dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">    x = x[:, <span class="literal">None</span>, <span class="literal">None</span>, :]</span><br><span class="line"></span><br><span class="line">    p = RotaryPositionalEmbeddings(<span class="number">4</span>)(x)</span><br><span class="line">    <span class="built_in">print</span>(p)</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{bmatrix}x_m^{(i)}\\x_m^{(i+d/2)}\end{bmatrix}=\begin{bmatrix}x_m^{(i)}\cos(m\theta_i)-x_m^{(i+d/2)}\sin(m\theta_i)\\x_m^{(i+d/2)}\cos(m\theta_i)+x_m^{(i)}\sin(m\theta_i)\end{bmatrix}</script><h2 id="RSMNorm"><a href="#RSMNorm" class="headerlink" title="RSMNorm"></a>RSMNorm</h2><p>另一种规范化的方式,方法是在2019年的论文中提出的<a href="https://arxiv.org/pdf/1910.07467">1910.07467 (arxiv.org)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RMSNorm</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, dim: <span class="built_in">int</span>, eps: <span class="built_in">float</span> = <span class="number">1e-6</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.eps = eps</span><br><span class="line">        self.weight = nn.Parameter(torch.ones(dim))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_norm</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x * torch.rsqrt(x.<span class="built_in">pow</span>(<span class="number">2</span>).mean(-<span class="number">1</span>, keepdim=<span class="literal">True</span>) + self.eps)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        output = self._norm(x.<span class="built_in">float</span>()).type_as(x)</span><br><span class="line">        <span class="keyword">return</span> output * self.weight</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">y=\frac{x}{\sqrt{\text{RMS}[x]+\epsilon}}*\gamma</script><p>在llama3中,有三个地方使用,在attention,ffn以及在所有transformer layer之后,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h = x + self.attention(self.attention_norm(x), start_pos, freqs_cis, mask)</span><br><span class="line">out = h + self.feed_forward(self.ffn_norm(h))</span><br></pre></td></tr></table></figure><h2 id="GroupQuery-Attention-amp-amp-KVcache"><a href="#GroupQuery-Attention-amp-amp-KVcache" class="headerlink" title="GroupQuery Attention&amp;&amp;KVcache"></a>GroupQuery Attention&amp;&amp;KVcache</h2><p>GroupQuery:query的head数是kv的head数的若干倍.</p><p>KV cache:在生成新的token时,K和V往往改变不大,也就不需要怎么计算,所以只需要存下计算的值即可.这是节约显存的操作.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Attention</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, args: ModelArgs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.n_kv_heads = args.n_heads <span class="keyword">if</span> args.n_kv_heads <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> args.n_kv_heads</span><br><span class="line">        model_parallel_size = fs_init.get_model_parallel_world_size()</span><br><span class="line">        self.n_local_heads = args.n_heads // model_parallel_size</span><br><span class="line">        self.n_local_kv_heads = self.n_kv_heads // model_parallel_size</span><br><span class="line">        self.n_rep = self.n_local_heads // self.n_local_kv_heads</span><br><span class="line">        self.head_dim = args.dim // args.n_heads</span><br><span class="line"></span><br><span class="line">        self.wq = ColumnParallelLinear(</span><br><span class="line">            args.dim,</span><br><span class="line">            args.n_heads * self.head_dim,</span><br><span class="line">            bias=<span class="literal">False</span>,</span><br><span class="line">            gather_output=<span class="literal">False</span>,</span><br><span class="line">            init_method=<span class="keyword">lambda</span> x: x,</span><br><span class="line">        )</span><br><span class="line">        self.wk = ColumnParallelLinear(</span><br><span class="line">            args.dim,</span><br><span class="line">            self.n_kv_heads * self.head_dim,</span><br><span class="line">            bias=<span class="literal">False</span>,</span><br><span class="line">            gather_output=<span class="literal">False</span>,</span><br><span class="line">            init_method=<span class="keyword">lambda</span> x: x,</span><br><span class="line">        )</span><br><span class="line">        self.wv = ColumnParallelLinear(</span><br><span class="line">            args.dim,</span><br><span class="line">            self.n_kv_heads * self.head_dim,</span><br><span class="line">            bias=<span class="literal">False</span>,</span><br><span class="line">            gather_output=<span class="literal">False</span>,</span><br><span class="line">            init_method=<span class="keyword">lambda</span> x: x,</span><br><span class="line">        )</span><br><span class="line">        self.wo = RowParallelLinear(</span><br><span class="line">            args.n_heads * self.head_dim,</span><br><span class="line">            args.dim,</span><br><span class="line">            bias=<span class="literal">False</span>,</span><br><span class="line">            input_is_parallel=<span class="literal">True</span>,</span><br><span class="line">            init_method=<span class="keyword">lambda</span> x: x,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.cache_k = torch.zeros(</span><br><span class="line">            (</span><br><span class="line">                args.max_batch_size,</span><br><span class="line">                args.max_seq_len,</span><br><span class="line">                self.n_local_kv_heads,</span><br><span class="line">                self.head_dim,</span><br><span class="line">            )</span><br><span class="line">        ).cuda()</span><br><span class="line">        self.cache_v = torch.zeros(</span><br><span class="line">            (</span><br><span class="line">                args.max_batch_size,</span><br><span class="line">                args.max_seq_len,</span><br><span class="line">                self.n_local_kv_heads,</span><br><span class="line">                self.head_dim,</span><br><span class="line">            )</span><br><span class="line">        ).cuda()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            self,</span></span></span><br><span class="line"><span class="params"><span class="function">            x: torch.Tensor,</span></span></span><br><span class="line"><span class="params"><span class="function">            start_pos: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            freqs_cis: torch.Tensor,</span></span></span><br><span class="line"><span class="params"><span class="function">            mask: <span class="type">Optional</span>[torch.Tensor],</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>):</span></span><br><span class="line">        bsz, seqlen, _ = x.shape</span><br><span class="line">        xq, xk, xv = self.wq(x), self.wk(x), self.wv(x)</span><br><span class="line"></span><br><span class="line">        xq = xq.view(bsz, seqlen, self.n_local_heads, self.head_dim)</span><br><span class="line">        xk = xk.view(bsz, seqlen, self.n_local_kv_heads, self.head_dim)</span><br><span class="line">        xv = xv.view(bsz, seqlen, self.n_local_kv_heads, self.head_dim)</span><br><span class="line"></span><br><span class="line">        xq, xk = apply_rotary_emb(xq, xk, freqs_cis=freqs_cis)</span><br><span class="line"></span><br><span class="line">        self.cache_k = self.cache_k.to(xq)</span><br><span class="line">        self.cache_v = self.cache_v.to(xq)</span><br><span class="line"></span><br><span class="line">        self.cache_k[:bsz, start_pos: start_pos + seqlen] = xk</span><br><span class="line">        self.cache_v[:bsz, start_pos: start_pos + seqlen] = xv</span><br><span class="line"></span><br><span class="line">        keys = self.cache_k[:bsz, : start_pos + seqlen]</span><br><span class="line">        values = self.cache_v[:bsz, : start_pos + seqlen]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># repeat k/v heads if n_kv_heads &lt; n_heads</span></span><br><span class="line">        keys = repeat_kv(</span><br><span class="line">            keys, self.n_rep</span><br><span class="line">        )  <span class="comment"># (bs, cache_len + seqlen, n_local_heads, head_dim)</span></span><br><span class="line">        values = repeat_kv(</span><br><span class="line">            values, self.n_rep</span><br><span class="line">        )  <span class="comment"># (bs, cache_len + seqlen, n_local_heads, head_dim)</span></span><br><span class="line"></span><br><span class="line">        xq = xq.transpose(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># (bs, n_local_heads, seqlen, head_dim)</span></span><br><span class="line">        keys = keys.transpose(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># (bs, n_local_heads, cache_len + seqlen, head_dim)</span></span><br><span class="line">        values = values.transpose(</span><br><span class="line">            <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        )  <span class="comment"># (bs, n_local_heads, cache_len + seqlen, head_dim)</span></span><br><span class="line">        scores = torch.matmul(xq, keys.transpose(<span class="number">2</span>, <span class="number">3</span>)) / math.sqrt(self.head_dim)</span><br><span class="line">        <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            scores = scores + mask  <span class="comment"># (bs, n_local_heads, seqlen, cache_len + seqlen)</span></span><br><span class="line">        scores = F.softmax(scores.<span class="built_in">float</span>(), dim=-<span class="number">1</span>).type_as(xq)</span><br><span class="line">        output = torch.matmul(scores, values)  <span class="comment"># (bs, n_local_heads, seqlen, head_dim)</span></span><br><span class="line">        output = output.transpose(<span class="number">1</span>, <span class="number">2</span>).contiguous().view(bsz, seqlen, -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.wo(output)</span><br></pre></td></tr></table></figure><h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transformer</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, params: ModelArgs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.params = params</span><br><span class="line">        self.vocab_size = params.vocab_size</span><br><span class="line">        self.n_layers = params.n_layers</span><br><span class="line"></span><br><span class="line">        self.tok_embeddings = VocabParallelEmbedding(</span><br><span class="line">            params.vocab_size, params.dim, init_method=<span class="keyword">lambda</span> x: x</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.layers = torch.nn.ModuleList()</span><br><span class="line">        <span class="keyword">for</span> layer_id <span class="keyword">in</span> <span class="built_in">range</span>(params.n_layers):</span><br><span class="line">            self.layers.append(TransformerBlock(layer_id, params))</span><br><span class="line"></span><br><span class="line">        self.norm = RMSNorm(params.dim, eps=params.norm_eps)</span><br><span class="line">        self.output = ColumnParallelLinear(</span><br><span class="line">            params.dim, params.vocab_size, bias=<span class="literal">False</span>, init_method=<span class="keyword">lambda</span> x: x</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.freqs_cis = precompute_freqs_cis(</span><br><span class="line">            params.dim // params.n_heads,</span><br><span class="line">            params.max_seq_len * <span class="number">2</span>,</span><br><span class="line">            params.rope_theta,</span><br><span class="line">        )</span><br><span class="line"><span class="meta">    @torch.inference_mode()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, tokens: torch.Tensor, start_pos: <span class="built_in">int</span></span>):</span></span><br><span class="line">        _bsz, seqlen = tokens.shape</span><br><span class="line">        h = self.tok_embeddings(tokens)</span><br><span class="line">        self.freqs_cis = self.freqs_cis.to(h.device)</span><br><span class="line">        freqs_cis = self.freqs_cis[start_pos: start_pos + seqlen]</span><br><span class="line"></span><br><span class="line">        mask = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> seqlen &gt; <span class="number">1</span>:</span><br><span class="line">            mask = torch.full((seqlen, seqlen), <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>), device=tokens.device)</span><br><span class="line"></span><br><span class="line">            mask = torch.triu(mask, diagonal=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># When performing key-value caching, we compute the attention scores</span></span><br><span class="line">            <span class="comment"># only for the new sequence. Thus, the matrix of scores is of size</span></span><br><span class="line">            <span class="comment"># (seqlen, cache_len + seqlen), and the only masked entries are (i, j) for</span></span><br><span class="line">            <span class="comment"># j &gt; cache_len + i, since row i corresponds to token cache_len + i.</span></span><br><span class="line">            mask = torch.hstack(</span><br><span class="line">                [torch.zeros((seqlen, start_pos), device=tokens.device), mask]</span><br><span class="line">            ).type_as(h)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:</span><br><span class="line">            h = layer(h, start_pos, freqs_cis, mask)</span><br><span class="line">        h = self.norm(h)</span><br><span class="line">        output = self.output(h).<span class="built_in">float</span>()</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransformerBlock</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, layer_id: <span class="built_in">int</span>, args: ModelArgs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.n_heads = args.n_heads</span><br><span class="line">        self.dim = args.dim</span><br><span class="line">        self.head_dim = args.dim // args.n_heads</span><br><span class="line">        self.attention = Attention(args)</span><br><span class="line">        self.feed_forward = FeedForward(</span><br><span class="line">            dim=args.dim,</span><br><span class="line">            hidden_dim=<span class="number">4</span> * args.dim,</span><br><span class="line">            multiple_of=args.multiple_of,</span><br><span class="line">            ffn_dim_multiplier=args.ffn_dim_multiplier,</span><br><span class="line">        )</span><br><span class="line">        self.layer_id = layer_id</span><br><span class="line">        self.attention_norm = RMSNorm(args.dim, eps=args.norm_eps)</span><br><span class="line">        self.ffn_norm = RMSNorm(args.dim, eps=args.norm_eps)</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            self,</span></span></span><br><span class="line"><span class="params"><span class="function">            x: torch.Tensor,</span></span></span><br><span class="line"><span class="params"><span class="function">            start_pos: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            freqs_cis: torch.Tensor,</span></span></span><br><span class="line"><span class="params"><span class="function">            mask: <span class="type">Optional</span>[torch.Tensor],</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>):</span></span><br><span class="line">        h = x + self.attention(self.attention_norm(x), start_pos, freqs_cis, mask)</span><br><span class="line">        out = h + self.feed_forward(self.ffn_norm(h))</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="silu激活函数"><a href="#silu激活函数" class="headerlink" title="silu激活函数"></a>silu激活函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeedForward</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            self,</span></span></span><br><span class="line"><span class="params"><span class="function">            dim: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            hidden_dim: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            multiple_of: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            ffn_dim_multiplier: <span class="type">Optional</span>[<span class="built_in">float</span>],</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        hidden_dim = <span class="built_in">int</span>(<span class="number">2</span> * hidden_dim / <span class="number">3</span>)</span><br><span class="line">        <span class="comment"># custom dim factor multiplier</span></span><br><span class="line">        <span class="keyword">if</span> ffn_dim_multiplier <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            hidden_dim = <span class="built_in">int</span>(ffn_dim_multiplier * hidden_dim)</span><br><span class="line">        hidden_dim = multiple_of * ((hidden_dim + multiple_of - <span class="number">1</span>) // multiple_of)</span><br><span class="line"></span><br><span class="line">        self.w1 = ColumnParallelLinear(</span><br><span class="line">            dim, hidden_dim, bias=<span class="literal">False</span>, gather_output=<span class="literal">False</span>, init_method=<span class="keyword">lambda</span> x: x</span><br><span class="line">        )</span><br><span class="line">        self.w2 = RowParallelLinear(</span><br><span class="line">            hidden_dim, dim, bias=<span class="literal">False</span>, input_is_parallel=<span class="literal">True</span>, init_method=<span class="keyword">lambda</span> x: x</span><br><span class="line">        )</span><br><span class="line">        self.w3 = ColumnParallelLinear(</span><br><span class="line">            dim, hidden_dim, bias=<span class="literal">False</span>, gather_output=<span class="literal">False</span>, init_method=<span class="keyword">lambda</span> x: x</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.w2(F.silu(self.w1(x)) * self.w3(x)) <span class="comment">#注意这里与一般的ffn差别,F.silu(self.w1(x))起了类似gate的作用</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pytorch.org/docs/stable/_images/SiLU.png" alt="../_images/SiLU.png" style="zoom:67%;" /></p><script type="math/tex; mode=display">silu(x)=x*σ(x)</script><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://github.com/naklecha/llama3-from-scratch">naklecha/llama3-from-scratch: llama3 implementation one matrix multiplication at a time (github.com)</a></li><li><a href="https://github.com/meta-llama/llama3">github.com</a></li><li><a href="https://github.com/aju22/RoPE-PyTorch/blob/main/RoPE.ipynb">RoPE-PyTorch/RoPE.ipynb at main · aju22/RoPE-PyTorch (github.com)</a></li><li><a href="https://nn.labml.ai/transformers/rope/index.html">Rotary Positional Embeddings (RoPE) (labml.ai)</a></li><li><a href="https://mett29.github.io/posts/kv-cache/">What is the KV cache? | Matt Log (mett29.github.io)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;llama3是meta开源的大模型,在开源大模型中占着重要地位,在这之前可能是Mistral,目前也有gemma2,Qwen2以及微软的Phi3等.&lt;br&gt;</summary>
    
    
    
    
    <category term="llm" scheme="https://www.sekyoro.top/tags/llm/"/>
    
  </entry>
  
  <entry>
    <title>from grad to tensor</title>
    <link href="https://www.sekyoro.top/2024/07/08/from-grad-to-tensor/"/>
    <id>https://www.sekyoro.top/2024/07/08/from-grad-to-tensor/</id>
    <published>2024-07-08T02:09:09.000Z</published>
    <updated>2024-07-16T14:40:36.858Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>inspired by <a href="https://github.com/karpathy/micrograd">karpathy/micrograd: A tiny scalar-valued autograd engine and a neural net library on top of it with PyTorch-like API (github.com)</a>and <a href="https://nrehiew.github.io/blog/pytorch/">Taking PyTorch for Granted | wh (nrehiew.github.io)</a>. </p><p>感谢Karpathy以及x上所有真心探讨技术的网友.这属于karpathy的<a href="https://github.com/karpathy/nn-zero-to-hero?tab=readme-ov-file">karpathy/nn-zero-to-hero: Neural Networks: Zero to Hero ,(github.com)</a>课程.事实上他还有很多值得一看的课程和repos.</p><span id="more"></span><p>tensor分成哪些部分?</p><blockquote><p>一个tensor可以分为元数据区和存储区（Storage）</p><p>信息区主要保存着tensor的形状（size）、步长（stride）、数据类型（type）,storage_offset,layout等信息,而真正的<strong>数据则保存成连续数组,存储在存储区</strong></p></blockquote><h3 id="tensor的存储"><a href="#tensor的存储" class="headerlink" title="tensor的存储"></a>tensor的存储</h3><p>tensor数据底层存储是<strong>连续的</strong>,<del>相对应的就是链表</del>. pytorch使用Storage类存储数据. 可以使用tensor.storage()访问存储的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = torch.arange(<span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(data.storage().dtype)</span><br><span class="line"><span class="built_in">print</span>(data.storage().device)</span><br><span class="line"><span class="built_in">print</span>(data.storage().data_ptr()) <span class="comment">#这里 存储数据也能访问数据的属性</span></span><br></pre></td></tr></table></figure><blockquote><p>All storage classes except for <a href="https://pytorch.org/docs/stable/storage.html#torch.UntypedStorage"><code>torch.UntypedStorage</code></a> will be removed in the future, and <a href="https://pytorch.org/docs/stable/storage.html#torch.UntypedStorage"><code>torch.UntypedStorage</code></a> will be used in all cases.</p></blockquote><p>但是在最新的python中除了untypedstorage类其他都已经deprecated了,而在untypedstorage中数据是字节类型,并且也无法调用<code>dtype</code>这些属性,变得更加纯粹了.</p><p><img data-src="https://s2.loli.net/2024/07/10/Ns8SM3QlpoeB4Ix.png" alt="image-20240710221322389"></p><p>事实上,大多数类似的数据都是这样的,比如常用库numpy.</p><p><img data-src="https://www.tomasbeuzen.com/python-programming-for-data-science/_images/numpy_paper.png" alt="img" style="zoom:150%;" /></p><h3 id="tensor的访问"><a href="#tensor的访问" class="headerlink" title="tensor的访问"></a>tensor的访问</h3><p>pytorch数据存储是一维的,但是会根据它的一些元数据改变对它的”解释”,而影响解释的元数据就是tride (<code>as_strided</code>可以使得两个tensor的size,stride和storage_offset一致)</p><blockquote><p><strong>stride</strong> stride是从一个元素到指定维度的另一个元素的间隔数,如果不指定维度,就返回在每个维度上的stride的tuple</p><p>Stride is the jump necessary to go from one element to the next one in the specified dimension <a href="https://pytorch.org/docs/stable/generated/torch.Tensor.dim.html#torch.Tensor.dim"><code>dim</code></a>. </p><p>A tuple of all strides is returned when no argument is passed in. Otherwise, an integer value is returned as the stride in the particular dimension <a href="https://pytorch.org/docs/stable/generated/torch.Tensor.dim.html#torch.Tensor.dim"><code>dim</code></a>.</p><p><strong>storage_offset</strong>  返回tensor的第一个元素与storage的第一个元素的偏移量。</p><p>Returns <code>self</code> tensor’s offset in the underlying storage in terms of number of storage elements (not bytes).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;x = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">&gt;x.storage_offset()</span><br><span class="line">&gt;x[<span class="number">3</span>:].storage_offset()</span><br></pre></td></tr></table></figure></blockquote><p>pytorch中tensor存储区的数据是连续的,而stride规定了如何访问.访问的方式就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = torch.randn(<span class="number">1</span>,<span class="number">20</span>,<span class="number">20</span>) </span><br><span class="line">stride = data.stride() <span class="comment"># -&gt; (400, 20, 1)</span></span><br><span class="line">data[<span class="number">0</span>][<span class="number">2</span>][<span class="number">3</span>] -&gt;  <span class="number">0</span>*stride[<span class="number">0</span>]+<span class="number">2</span>*stride[<span class="number">2</span>]+<span class="number">3</span>*stride[<span class="number">3</span>]-&gt;也就是说这个数据在第<span class="number">2</span>*<span class="number">20</span>+<span class="number">3</span>*<span class="number">1</span>=<span class="number">43</span>个</span><br></pre></td></tr></table></figure><p>注意torch存储数据是行优先,也就是说,像下面这样的数据,第二个是0.6960而不是-0.5163. 所以访问时就类似索引乘以对应的行/列数,从这个角度来看,stride就是一个映射函数.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ <span class="number">1.6427</span>,  <span class="number">0.6960</span>,  <span class="number">0.7865</span>,  <span class="number">0.9934</span>,  <span class="number">0.4952</span>],</span><br><span class="line">        [-<span class="number">0.5163</span>, -<span class="number">0.0823</span>, -<span class="number">1.2630</span>, -<span class="number">0.9474</span>,  <span class="number">1.1055</span>],</span><br><span class="line">        [ <span class="number">0.1538</span>,  <span class="number">1.0177</span>, -<span class="number">1.8064</span>,  <span class="number">0.6440</span>, -<span class="number">1.4661</span>],</span><br><span class="line">        [ <span class="number">0.3305</span>,  <span class="number">0.2681</span>,  <span class="number">0.2768</span>, -<span class="number">0.3924</span>,  <span class="number">0.1743</span>],</span><br><span class="line">        [-<span class="number">0.8965</span>, -<span class="number">0.5499</span>, -<span class="number">0.4545</span>, -<span class="number">1.1470</span>,  <span class="number">0.6883</span>]])</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/07/10/s7ZuEzmD3vnAoiH.png" alt="image-20240710220152997"></p><h3 id="tensor操作"><a href="#tensor操作" class="headerlink" title="tensor操作"></a>tensor操作</h3><p>可以对tensor的数据进行操作,比如下面运算,会改变tensor的存储数据.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = torch.randn((<span class="number">4</span>, <span class="number">2</span>))</span><br><span class="line">stride = data.stride()</span><br><span class="line"><span class="built_in">print</span>(data, stride)</span><br><span class="line">data[<span class="number">0</span>, <span class="number">1</span>] = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(data, stride)</span><br><span class="line">data.add_(torch.ones((<span class="number">4</span>, <span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>(data, stride)</span><br></pre></td></tr></table></figure><p>但是有些操作不会,其只会返回数据相同(指的是数据在底层存储上相同)的<strong>视图</strong>(view),这些操作包括<code>t()</code>,<code>expand</code>,<code>transpose</code>,<code>permute</code>,<code>view</code>,<code>squeeze</code>等等,操作后的tensor数据不变(也就是views),但stride<strong>可能</strong>会改变,也就是说解释数据的方式会变.</p><blockquote><p>底层存储并没有改变,只需将映射函数从旧形状的坐标系调整为新形状的坐标系。 如果映射函数已经将形状作为输入,那么只需更改形状属性即可。</p></blockquote><ul><li><code>reshape()</code>、<code>reshape_as()</code> 和 <code>flatten()</code> 可以返回视图或新张量,所以后续代码不要假定它返回的存储数据是否跟原本输入相同.</li><li>如果输入的张量已经连续,<code>contiguous()</code> 会返回自身,否则会通过复制数据返回一个新的连续张量.</li></ul><p>下面一个例子报错原因,就是stride的问题,具体来说,这里转置之后stride变了,size没变,使得后续的view操作不满足条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(<span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>) <span class="comment"># 3 x 3 stride (3,1)  size(3,3)</span></span><br><span class="line">x.t().view(<span class="number">1</span>, -<span class="number">1</span>) <span class="comment"># x.t() stride (1,3)  size(3,3)</span></span><br><span class="line"><span class="comment"># &gt;&gt; RuntimeError: view size is not compatible with input tensor&#x27;s </span></span><br><span class="line"><span class="comment"># size and stride. Use .reshape() instead</span></span><br></pre></td></tr></table></figure><p>首先,<code>view</code>作用是返回一个存储数据相同,但shape/size可能不同的视图,要求新的视图与输入数据<strong>相兼容</strong>( 1.<strong>新的视图的每个dimension必须是输入的子空间</strong>或者2.<strong>新的视图的维度满足下面条件</strong>（连续性),否则不能得到新的视图.</p><script type="math/tex; mode=display">假设得到的新的tensor维度涉及d,..,d+k,对其中所有维度要求:\\\text{stride}[i]=\text{stride}[i+1]\times\text{size}[i+1]</script><blockquote><p>如果不清楚是否可以执行 view()，建议使用 reshape()</p><p>reshape:如果形状兼容,则返回视图,否则返回拷贝(相当于调用 contiguous)</p></blockquote><p>view之后size变为(1,9),这符合条件1,也就是size相符,再看这里(1,9)表明第二个维度跨域(span across)了原本输入的两个维度,而原本输入的两个维度中的第一个维度需要满足连续性条件,但是 stride[0] =  1 , stride[1]*size[1] = 1*3=3 不符合,所以view操作失败.</p><p>更抽象地说,因为没有办法在不改变底层数据的情况下对张量进行flatten处理.</p><blockquote><p>我们能否从tensor的stride(3,1)推得tensor size是(3,3)?</p><p>答案是不能,它的size也完全可以是(4,3). 反过来size也不能推出stride.</p></blockquote><p>在上面的例子中,比如底层数据是[1,2,3,4,5,6,7,8,9],stride是[3,1]. 也就是说在第一个维度下,数据到相同维度的下个数据间隔为3,同理第二个维度间隔为1,</p><p>经过转置之后,因为解释数据的方式变了,因为需要改变解释数据的方式,所以stride需要改变为(1,3).  再进行view(1,-1),如果不报错的话,size就是(1,9),你可能会认为结果不就是[[1,4,7,2,5,8…]]吗,但这个tensor的stride为多少呢? 是(9,1)吗,并不是.为什么呢,</p><p>因为底层数据[1,2,3,4,5,6,7,8,9],要查找第二个维度上的数据,比如1到4,在底层数据中是stride是3,而4到7也是3,所以是stride是(9,3),然而这跟size(1,9)不匹配(stride乘起来应该跟size乘起来应该相同,这是最起码的保证).</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tensor(<span class="string">[[1, 2, 3],</span></span><br><span class="line"><span class="string">        [4, 5, 6],</span></span><br><span class="line"><span class="string">        [7, 8, 9]]</span>) </span><br><span class="line">        ⬇⬇</span><br><span class="line">        tensor(<span class="string">[[1, 4, 7],</span></span><br><span class="line"><span class="string">        [2, 5, 8],</span></span><br><span class="line"><span class="string">        [3, 6, 9]]</span>)</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/07/13/XRp2T8JgGrNQBwY.png" alt="在这里插入图片描述" style="zoom: 67%;" /></p><h3 id="tensor的广播"><a href="#tensor的广播" class="headerlink" title="tensor的广播"></a>tensor的广播</h3><p>PyTorch 的广播规则:(如何说一个tensor是可广播的)</p><ul><li><p>两个张量必须至少有一个维度</p></li><li><p>从最右边的维开始,两个维必须大小相等,其中一个为 1 或者其中一个不存在。</p><blockquote><p>Two tensors are “broadcastable” if the following rules hold:</p><ul><li>Each tensor has at least one dimension.</li><li>When iterating over the dimension sizes, starting at the trailing dimension, the dimension sizes must either be equal, one of them is 1, or one of them does not exist.</li></ul><p><a href="https://pytorch.org/docs/stable/notes/broadcasting.html#broadcasting-semantics">Broadcasting semantics — PyTorch 2.3 documentation</a></p><p>If two tensors <code>x</code>, <code>y</code> are “broadcastable”, the resulting tensor size is calculated as follows:</p><ul><li>If the number of dimensions of <code>x</code> and <code>y</code> are not equal, prepend 1 to the dimensions of the tensor with fewer dimensions to make them equal length.</li><li>Then, for each dimension size, the resulting dimension size is the max of the sizes of <code>x</code> and <code>y</code> along that dimension.</li></ul></blockquote></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from https://nrehiew.github.io/blog/pytorch/</span></span><br><span class="line"><span class="keyword">for</span> each dimension, starting from the right:</span><br><span class="line"><span class="keyword">if</span> both shapes have this dimension:</span><br><span class="line"><span class="keyword">if</span> they are different:</span><br><span class="line">neither is 1: error</span><br><span class="line"><span class="keyword">else</span>: use larger dimension </span><br><span class="line"><span class="keyword">else</span> they are the same: use dimension</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">use whichever dimension exists</span><br></pre></td></tr></table></figure><p>广播,不存在数据copy.这意味着,如果将一个小张量广播到一个大得多的形状,就不会产生内存或性能开销。</p><p>其次,由于较小张量中使用的实际元素是相同的,因此梯度会沿着这个较小维度中的项目累积.这在调试梯度或执行涉及广播的自定义自动梯度函数时特别有用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x=torch.empty(<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>)</span><br><span class="line">y=torch.empty(  <span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">(x+y).size()</span><br><span class="line"></span><br><span class="line">x=torch.empty(<span class="number">1</span>)</span><br><span class="line">y=torch.empty(<span class="number">3</span>,<span class="number">1</span>,<span class="number">7</span>)</span><br><span class="line">(x+y).size()</span><br><span class="line"></span><br><span class="line">x=torch.empty(<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>)</span><br><span class="line">y=torch.empty(<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">(x+y).size()</span><br></pre></td></tr></table></figure><p>如果一个 PyTorch 操作支持广播,那么它的张量数据就会自动扩展为大小相等的数据(无需复制数据),所以本质上也是返回一个视图.</p><h3 id="利用矩阵乘法进行广播"><a href="#利用矩阵乘法进行广播" class="headerlink" title="利用矩阵乘法进行广播"></a>利用矩阵乘法进行广播</h3><p>矩阵是二维的,但是tensor是不限制的.</p><p><strong>多维tensor如何相乘的呢?</strong></p><ol><li>取两个张量的最后两个维度,检查它们是否可以相乘.如果不能,则出错</li><li>广播剩余维数.结果形状为 [广播后的维数] + [矩阵乘法的结果形状]。</li><li>将 [广播后的维数] 作为批处理维度，执行batched matrix multiplication(其实就是矩阵乘法,但是两个相乘的矩阵分别来自不同的batch中的相同的index)</li></ol><p>使用torch.matmul进行tensor相乘,它的计算方式如下</p><ul><li><p>如果都是一维,进行点乘</p></li><li><p>如果都是二维,进行矩阵乘,,如果是1维和二维,在一维度之前添加一个维度在进行矩阵乘,乘完之后再去掉.</p></li><li><p>如果是二维和1维,进行矩阵-向量乘法,得到向量.</p></li><li><p>如果两个参数都至少为 1 维,且至少一个参数为 N 维(N &gt; 2),则返回一个batched matrix multiplication.</p><p>如果第一个参数是一维的,那么在进行batched matrix multiplication,会在其维度前添加一维,然后删除.</p><p>如果第二个参数是一维的,则在其维度后加上 1,以便进行batched matrix multiply,并在运算后删除.</p><p>非矩阵(即批处理)维度将被广播(因此必须是<strong>可广播的</strong>)</p><p>比如(jx1xnxn)和(kxnxn)得到(jxkxnxn),在batch上广播得到(jxk),简单来说就是最后两维(不够进行广播)进行相乘,除了后面两维,其他维度直接进行广播.</p></li></ul><blockquote><p>注意:广播逻辑在确定输入是否可广播时，只查看批次维度，而不查看矩阵维度。</p><p>这跟上面的广播逻辑不同.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = torch.randn((<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>)) <span class="comment"># 3 x 4 x 1 x 2</span></span><br><span class="line">b = torch.randn((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment"># 1 x 2 x 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Matrix Multiply Shape: 1x2 @ 2x3 -&gt; 1x3</span></span><br><span class="line"><span class="comment"># Batch Shape: We broadcast (3, 4) and (1) -&gt; (3, 4)</span></span><br><span class="line"><span class="comment"># Result shape: 3 x 4 x 1 x 3</span></span><br><span class="line">c = torch.zeros((<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># iterate over the batch dimensions of (3, 4)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">a_slice = a[i][j] <span class="comment"># 1 x 2</span></span><br><span class="line">b_slice = b[<span class="number">0</span>] <span class="comment"># 2 x 3</span></span><br><span class="line">c[i][j] = a_slice @ b_slice <span class="comment"># 1 x 3</span></span><br><span class="line"><span class="keyword">assert</span> torch.equal(torch.matmul(a, b), c)</span><br></pre></td></tr></table></figure><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>PyTorch 的核心是它的自动微分引擎.一般来说,<strong>每次在两个张量之间进行微分操作时,PyTorch 都会通过回调函数自动构建出整个计算图. 然后,当调用 .backward() 时,每个张量的梯度都会被更新</strong>. 这是 PyTorch 最大的抽象.</p><p>从标量的求导开始扩展到高维,这并不困难.首先需要理解标量的基本运算中的加/减法,乘法,幂、指以及对数.一个softmax操作就包含了加,幂指的操作.</p><p> 可以将矩阵乘法看作是多个标量值的一系列乘法和加法运算,只需指定这些标量运算的后向运算,两个矩阵相乘的导数就自然而然地产生了.</p><p>从标量的角度来考虑梯度还有一个好处，就是可以直观地了解张量操作对梯度的影响。</p><p>例如，.reshape()、.transpose()、.cat 和 .split()等操作不会影响单个值及其在标量的梯度。 因此这些操作对张量梯度的影响自然就是操作梯度本身。 </p><p>例如,使用 .reshape(-1) 对张量进行扁平化处理,对梯度的影响与调用 .reshape(-1) 对张量的梯度的影响相同。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="矩阵相乘"><a href="#矩阵相乘" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h4><p>不使用 GPU 也能实现的优化方法.</p><p> 一种可能的优化方法是利用内存访问模式,而不是改变算法。 回想一下,在给定 A @ B 的情况下，我们正在重复计算 A 中的一行和 B 中的一列的点乘. </p><p>简单的解决方法是转置,将其转为列主模式(column-first),这样每次从内存加载时,我们就可以在同一缓存行中加载 B 列中的正确项目.</p><p>转置是一种O(N) 操作，因此只适用于较大的矩阵.</p><p>另一种无需缓存的算法是对矩阵块进行运算，而不是一次性对整个矩阵进行运算。 这就是所谓的<strong>块矩阵乘法</strong>。 其原理是将矩阵分解成较小的块，然后在这些块上执行矩阵乘法。 这样做的另一个好处是减少了高速缓存的读取次数，因为我们现在是在矩阵的较小块上进行运算。</p><h4 id="内存和中间值"><a href="#内存和中间值" class="headerlink" title="内存和中间值"></a>内存和中间值</h4><blockquote><p>这里原文<a href="https://nrehiew.github.io/blog/pytorch/">Taking PyTorch for Granted | wh (nrehiew.github.io)</a>似乎有typos,我进行了修正</p></blockquote><p>在反向传播时,符合直觉的想法是保留中间值的梯度,以便后续计算leaf tensor的梯度.但是有些时候并不需要中间值的梯度</p><p>比如(a*b)+(c*d)=e,进行反向传播求e在a的梯度时如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_t1 = a * b</span><br><span class="line">_t2 = c * d</span><br><span class="line">e = _t1 + _t2</span><br></pre></td></tr></table></figure><p>其实就是求b,所以并不需要保留_t1和_t2的值.</p><h3 id="micrograd-from-scratch"><a href="#micrograd-from-scratch" class="headerlink" title="micrograd from scratch"></a>micrograd from scratch</h3><p>此外还有个tinygrad的项目也是受此启发,在pytorch和micrograd中得到改进.</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://github.com/karpathy/micrograd">karpathy/micrograd: A tiny scalar-valued autograd engine and a neural net library on top of it with PyTorch-like API (github.com)</a></li><li><a href="https://github.com/karpathy/nn-zero-to-hero?tab=readme-ov-file">karpathy/nn-zero-to-hero: Neural Networks: Zero to Hero (github.com)</a></li><li><a href="https://github.com/karpathy/nanoGPT">karpathy/nanoGPT: The simplest, fastest repository for training/finetuning medium-sized GPTs. (github.com)</a></li><li><a href="https://blog.csdn.net/weixin_44008424/article/details/110764494">pytorch笔记（一）——tensor的storage()、stride()、storage_offset（）_pytorch storage-CSDN博客</a></li><li><a href="https://blog.csdn.net/m0_46653437/article/details/108742525">PyTorch中张量的shape和stride的关系_shape和strides-CSDN博客</a></li><li><a href="http://blog.ezyang.com/2019/05/pytorch-internals/">PyTorch internals : ezyang’s blog</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;inspired by &lt;a href=&quot;https://github.com/karpathy/micrograd&quot;&gt;karpathy/micrograd: A tiny scalar-valued autograd engine and a neural net library on top of it with PyTorch-like API (github.com)&lt;/a&gt;and &lt;a href=&quot;https://nrehiew.github.io/blog/pytorch/&quot;&gt;Taking PyTorch for Granted | wh (nrehiew.github.io)&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;感谢Karpathy以及x上所有真心探讨技术的网友.这属于karpathy的&lt;a href=&quot;https://github.com/karpathy/nn-zero-to-hero?tab=readme-ov-file&quot;&gt;karpathy/nn-zero-to-hero: Neural Networks: Zero to Hero ,(github.com)&lt;/a&gt;课程.事实上他还有很多值得一看的课程和repos.&lt;/p&gt;</summary>
    
    
    
    
    <category term="tensor" scheme="https://www.sekyoro.top/tags/tensor/"/>
    
  </entry>
  
  <entry>
    <title>i3wm,Neovim与Alacritty的使用与配置</title>
    <link href="https://www.sekyoro.top/2024/07/06/i3wm%E3%80%81Neovim%E4%B8%8EAlacritty%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.sekyoro.top/2024/07/06/i3wm%E3%80%81Neovim%E4%B8%8EAlacritty%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE/</id>
    <published>2024-07-06T03:54:41.000Z</published>
    <updated>2024-07-06T15:11:39.814Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>常用的窗口管理器,编辑器与终端模拟器等等<br><span id="more"></span><br>这些工具都有相对的优劣,我个人觉得<strong>生态</strong>,<strong>稳定性</strong>是两个非常重要的因素. 生态好就会有不断的更新和维护,稳定性会让用户更好的长期适应.</p><h3 id="i3wm"><a href="#i3wm" class="headerlink" title="i3wm"></a>i3wm</h3><p>i3wm是个基于x11的窗口管理器,生态很强<a href="https://github.com/fz-wu/i3_user_guide_Chinese">fz-wu/i3_user_guide_Chinese: i3wm官方指南,方便同学们学习i3wm. i3是一个平铺式的窗口管理器 (github.com)</a></p><p><img data-src="https://i3wm.org/docs/modes.png" alt="Container modes"></p><p>类似的还有awesome wm,dwm,也有基于wayland的compositor hyprland(没有使用hyprland也是因为感觉还不太稳定,等过段时间再看看).详情看<a href="https://wiki.archlinux.org/title/Comparison_of_tiling_window_managers">Comparison of tiling window managers - ArchWiki (archlinux.org)</a>和<a href="https://wiki.archlinux.org/title/Wayland#Tiling">Wayland - ArchWiki (archlinux.org)</a></p><p>具体配置文档<a href="https://i3wm.org/docs/userguide.html#configuring">i3: i3 User’s Guide (i3wm.org)</a></p><p>一个例子<a href="https://github.com/levinit/i3wm-config/blob/master/i3/config">i3wm-config/i3/config at master · levinit/i3wm-config (github.com)</a></p><p>i3本身不支持透明等功能,还需要安装其他工具<a href="https://zocoxx.com/archlinux-i3wm.html">ArchLinux系统i3wm配置及体验记录 – ZocoXX</a>,<a href="https://levinit.github.io/i3wm-config/#:~:text=编辑 i3%2Fconfig 文件可切换模式。,随机模式：自动切换壁纸，将要用作壁纸的图片放到 ~%2FPictures%2Fwallpapers 即可。">i3wm-config | my i3wm config (levinit.github.io)</a></p><h3 id="awesomewm"><a href="#awesomewm" class="headerlink" title="awesomewm"></a>awesomewm</h3><p>使用lua配置,相对i3的文本配置,个人认为更友好,上手门槛更低.<a href="https://github.com/atsepkov/awesome-awesome-wm">atsepkov/awesome-awesome-wm: A curated list of awesome tools/scripts/configs for Awesome Window Manager. (github.com)</a>,除了本身窗口管理外,还有查看CPU资源,图片等工具需要额外安装.</p><p>所以比较方便的做法就是clone其他人的配置😅</p><p><strong>i3</strong></p><ul><li><a href="https://github.com/addy-dclxvi/i3-starterpack">addy-dclxvi/i3-starterpack: A simple guide (and example of configuration) to install i3 &amp; its and essentials packages, then make them look eye candy. (github.com)</a></li><li><a href="https://github.com/sainathadapa/i3-wm-config">sainathadapa/i3-wm-config: I3 tiling window manager configuration (github.com)</a></li><li><a href="https://github.com/levinit/i3wm-config">levinit/i3wm-config: my i3wm config (github.com)</a></li><li><a href="https://github.com/typecraft-dev/dotfiles">typecraft-dev/dotfiles (github.com)</a></li></ul><p><strong>awesome</strong></p><ul><li><a href="https://github.com/raven2cz/dotfiles">raven2cz/dotfiles: Dotfiles are the customization files in GNU/Linux. This repository assembly together all my others github config repos to one union. You can choose this global conf for your system or check other repos.</a></li><li><a href="https://github.com/pw4ever/awesome-wm-config">pw4ever/awesome-wm-config: awesome window manager config with persistent dynamic tagging (github.com)</a></li></ul><p><strong>hyprland</strong><a href="https://wiki.hyprland.org/Configuring/">Configuring – Hyprland Wiki</a></p><ul><li><a href="https://github.com/SolDoesTech/hyprland">SolDoesTech/hyprland: collection of dot config files for hyprland with a simple install script for a fresh Arch linux with yay (github.com)</a></li><li><a href="https://github.com/notwidow/hyprland">notwidow/hyprland: hyprland config (github.com)</a></li><li><a href="https://github.com/AhmedSaadi0/my-hyprland-config/blob/main/hyprland.conf">my-hyprland-config/hyprland.conf at main · AhmedSaadi0/my-hyprland-config (github.com)</a></li></ul><p>个人感觉还是hyprland的配置和文档好,但是使用上bug可能不少.</p><h3 id="Neovim"><a href="#Neovim" class="headerlink" title="Neovim"></a>Neovim</h3><p>基于vim的编辑器,更好地进行配置、安装插件.</p><p>主要是需要了解neovim的一些配置语法,如果为了方便直接使用lazyvim等配置即可.</p><p><a href="https://neovim.io/doc/user/lua-guide.html">Lua-guide - Neovim docs</a> neovim使用vim.*等变量替代了原本的vimscript,不过你依然可以使用vim.cmd执行vimscript,使用vim.fn执行函数</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim.cmd(<span class="string">&quot;colorscheme habamax&quot;</span>)</span><br><span class="line">vim.cmd.highlight(&#123; <span class="string">&quot;Error&quot;</span>, <span class="string">&quot;guibg=red&quot;</span> &#125;)</span><br><span class="line"><span class="built_in">print</span>(vim.fn.printf(<span class="string">&#x27;Hello from %s&#x27;</span>, <span class="string">&#x27;Lua&#x27;</span>))</span><br><span class="line"><span class="keyword">local</span> reversed_list = vim.fn.<span class="built_in">reverse</span>(&#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> &#125;)</span><br><span class="line">vim.<span class="built_in">print</span>(reversed_list) <span class="comment">-- &#123; &quot;c&quot;, &quot;b&quot;, &quot;a&quot; &#125;</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">print_stdout</span><span class="params">(chan_id, data, name)</span></span></span><br><span class="line">  <span class="built_in">print</span>(data[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">vim.fn.jobstart(<span class="string">&#x27;ls&#x27;</span>, &#123; on_stdout = print_stdout &#125;)</span><br></pre></td></tr></table></figure><h4 id="vim-变量"><a href="#vim-变量" class="headerlink" title="vim.*变量"></a>vim.*变量</h4><p><a href="https://neovim.io/doc/user/lua.html#vim.g">vim.g</a>: global variables (<a href="https://neovim.io/doc/user/eval.html#g%3A">g:</a>)</p><p><a href="https://neovim.io/doc/user/lua.html#vim.b">vim.b</a>: variables for the current buffer (<a href="https://neovim.io/doc/user/eval.html#b%3A">b:</a>)</p><p><a href="https://neovim.io/doc/user/lua.html#vim.w">vim.w</a>: variables for the current window (<a href="https://neovim.io/doc/user/eval.html#w%3A">w:</a>)</p><p><a href="https://neovim.io/doc/user/lua.html#vim.t">vim.t</a>: variables for the current tabpage (<a href="https://neovim.io/doc/user/eval.html#t%3A">t:</a>)</p><p><a href="https://neovim.io/doc/user/lua.html#vim.v">vim.v</a>: predefined Vim variables (<a href="https://neovim.io/doc/user/eval.html#v%3A">v:</a>)</p><p><a href="https://neovim.io/doc/user/lua.html#vim.env">vim.env</a>: environment variables defined in the editor session</p><h4 id="设置options"><a href="#设置options" class="headerlink" title="设置options"></a>设置options</h4><p>options就是vim中的表现比如set smarttab</p><p>设置全局和本地选项（例如在 init.lua 中）最方便的方法是通过 vim.opt.<br>设置全局和本地选项最方便的方法是通过 vim.opt 和它的朋友们：<br>vim.opt: 行为类似于 :set<br>vim.opt_global: 行为类似于 :setglobal<br>vim.opt_local：行为类似于 :setlocal</p><h5 id="vim-opt"><a href="#vim-opt" class="headerlink" title="vim.opt"></a>vim.opt</h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim.opt.smarttab = <span class="literal">true</span></span><br><span class="line">vim.opt.smarttab = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>代价是不能直接访问选项值，而必须<br>使用 vim.opt:get()：</p><h5 id="vim-o"><a href="#vim-o" class="headerlink" title="vim.o"></a>vim.o</h5><p>有一种更直接的类似变量的访问方式,使用 vim.o<br>vim.o：行为类似于 :set<br>vim.go：行为类似于 :setglobal<br>vim.bo：用于缓冲区选项<br>vim.wo：用于窗口的选项</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vim.o.smarttab = <span class="literal">false</span> <span class="comment">-- :set nosmarttab</span></span><br><span class="line"><span class="built_in">print</span>(vim.o.smarttab)</span><br><span class="line"><span class="comment">--&gt; false</span></span><br><span class="line">vim.o.listchars = <span class="string">&#x27;space:_,tab:&gt;~&#x27;</span> <span class="comment">-- :set listchars=&#x27;space:_,tab:&gt;~&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(vim.o.listchars)</span><br><span class="line"><span class="comment">--&gt; &#x27;space:_,tab:&gt;~&#x27;</span></span><br><span class="line">vim.o.isfname = vim.o.isfname .. <span class="string">&#x27;,@-@&#x27;</span> <span class="comment">-- :set isfname+=@-@</span></span><br><span class="line"><span class="built_in">print</span>(vim.o.isfname)</span><br><span class="line"><span class="comment">--&gt; &#x27;@,48-57,/,.,-,_,+,,,#,$,%,~,=,@-@&#x27;</span></span><br><span class="line">vim.bo.shiftwidth = <span class="number">4</span> <span class="comment">-- :setlocal shiftwidth=4</span></span><br><span class="line"><span class="built_in">print</span>(vim.bo.shiftwidth)</span><br><span class="line"><span class="comment">--&gt; 4</span></span><br><span class="line">vim.bo[<span class="number">4</span>].expandtab = <span class="literal">true</span> <span class="comment">-- sets expandtab to true in buffer 4</span></span><br><span class="line">vim.wo.number = <span class="literal">true</span>       <span class="comment">-- sets number to true in current window</span></span><br><span class="line">vim.wo[<span class="number">0</span>].number = <span class="literal">true</span>    <span class="comment">-- same as above</span></span><br><span class="line">vim.wo[<span class="number">0</span>][<span class="number">0</span>].number = <span class="literal">true</span> <span class="comment">-- sets number to true in current buffer</span></span><br><span class="line">                           <span class="comment">-- in current window only</span></span><br><span class="line"><span class="built_in">print</span>(vim.wo[<span class="number">0</span>].number)    <span class="comment">--&gt; true</span></span><br></pre></td></tr></table></figure><h4 id="Mappings"><a href="#Mappings" class="headerlink" title="Mappings"></a>Mappings</h4><p>设置执行命令的快捷键.</p><p>可以使用 vim.keymap.set() 创建映射。该函数需要三个参数：<br>{mode} 是一个字符串或字符串表，包含映射生效的模式前缀。前缀是 :map-modes 中列出的前缀，或 :map! 中的”!”，或 :map 中的空字符串。<br>{lhs} 是一个字符串，包含应触发映射的键序列。<br>{rhs} 是包含 Vim 命令或 Lua 函数的字符串，当输入 {lhs} 时应执行该命令或函数。空字符串等同于 <Nop>，表示禁用按键。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Normal mode mapping for Vim command</span></span><br><span class="line">vim.keymap.set(<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;&lt;Leader&gt;ex1&#x27;</span>, <span class="string">&#x27;&lt;cmd&gt;echo &quot;Example 1&quot;&lt;cr&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">-- Normal and Command-line mode mapping for Vim command</span></span><br><span class="line">vim.keymap.set(&#123;<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;, <span class="string">&#x27;&lt;Leader&gt;ex2&#x27;</span>, <span class="string">&#x27;&lt;cmd&gt;echo &quot;Example 2&quot;&lt;cr&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">-- Normal mode mapping for Lua function</span></span><br><span class="line">vim.keymap.set(<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;&lt;Leader&gt;ex3&#x27;</span>, vim.treesitter.start)</span><br><span class="line"><span class="comment">-- Normal mode mapping for Lua function with arguments</span></span><br><span class="line">vim.keymap.set(<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;&lt;Leader&gt;ex4&#x27;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">print</span>(<span class="string">&#x27;Example 4&#x27;</span>) <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><h4 id="Autocommands"><a href="#Autocommands" class="headerlink" title="Autocommands"></a>Autocommands</h4><p>自动命令是一个 Vim 命令或一个 Lua 函数，每当触发一个或多个事件（如文件被打开）时就会自动执行。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vim.api.nvim_create_autocmd(&#123;<span class="string">&quot;BufEnter&quot;</span>, <span class="string">&quot;BufWinEnter&quot;</span>&#125;, &#123;</span><br><span class="line">  pattern = &#123;<span class="string">&quot;*.c&quot;</span>, <span class="string">&quot;*.h&quot;</span>&#125;,</span><br><span class="line">  command = <span class="string">&quot;echo &#x27;Entering a C or C++ file&#x27;&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">-- Same autocommand written with a Lua function instead</span></span><br><span class="line">vim.api.nvim_create_autocmd(&#123;<span class="string">&quot;BufEnter&quot;</span>, <span class="string">&quot;BufWinEnter&quot;</span>&#125;, &#123;</span><br><span class="line">  pattern = &#123;<span class="string">&quot;*.c&quot;</span>, <span class="string">&quot;*.h&quot;</span>&#125;,</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">print</span>(<span class="string">&quot;Entering a C or C++ file&quot;</span>) <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">-- User event triggered by MyPlugin</span></span><br><span class="line">vim.api.nvim_create_autocmd(<span class="string">&quot;User&quot;</span>, &#123;</span><br><span class="line">  pattern = <span class="string">&quot;MyPlugin&quot;</span>,</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">print</span>(<span class="string">&quot;My Plugin Works!&quot;</span>) <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="User-commands"><a href="#User-commands" class="headerlink" title="User commands"></a>User commands</h4><p>用户命令可通过 nvim_create_user_command() 创建。该函数须要三个参数：<br>命令名称字符串（必须以大写字母开头，以区别于内置命令）；<br>一个包含 Vim 命令或 Lua 函数的字符串，命令调用时执行该字符串；<br>包含命令属性的表格；此外，它还可以包含关键字 desc（描述命令的字符串）、force（设置为 false 以避免替换已存在的同名命令）和 preview（用于 :command-preview 的 Lua 函数）。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim.api.nvim_create_user_command(<span class="string">&#x27;Test&#x27;</span>, <span class="string">&#x27;echo &quot;It works!&quot;&#x27;</span>, &#123;&#125;)</span><br><span class="line">vim.cmd.Test()</span><br><span class="line"><span class="comment">--&gt; It works!</span></span><br></pre></td></tr></table></figure><p>可以使用lazyvim,lunarvim,Astrovim或者nvchad等配置文件,已经为我们配置好了很多东西.</p><h4 id="LazyVim"><a href="#LazyVim" class="headerlink" title="LazyVim"></a>LazyVim</h4><p><code>lazyvim</code>规定了每个lazyvim的库应该怎么编写,编写方式按照文档规定.<code>nvchad</code>,<code>astrovim</code>都是按照这种方式的.</p><p>默认keymaps<a href="https://www.lazyvim.org/keymaps">⌨️ Keymaps | LazyVim</a></p><p><a href="https://www.lazyvim.org/configuration/plugins">Plugins | LazyVim</a></p><p>拿Lazyvim举例,相当于packer.nvim等插件管理器的替代,<code>lazy.vim</code>中默认设置如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  root = vim.fn.stdpath(<span class="string">&quot;data&quot;</span>) .. <span class="string">&quot;/lazy&quot;</span>, <span class="comment">-- directory where plugins will be installed</span></span><br><span class="line">  defaults = &#123;</span><br><span class="line">    <span class="comment">-- Set this to `true` to have all your plugins lazy-loaded by default.</span></span><br><span class="line">    <span class="comment">-- Only do this if you know what you are doing, as it can lead to unexpected behavior.</span></span><br><span class="line">    lazy = <span class="literal">false</span>, <span class="comment">-- should plugins be lazy-loaded?</span></span><br><span class="line">    <span class="comment">-- It&#x27;s recommended to leave version=false for now, since a lot the plugin that support versioning,</span></span><br><span class="line">    <span class="comment">-- have outdated releases, which may break your Neovim install.</span></span><br><span class="line">    version = <span class="literal">nil</span>, <span class="comment">-- always use the latest git commit</span></span><br><span class="line">    <span class="comment">-- version = &quot;*&quot;, -- try installing the latest stable version for plugins that support semver</span></span><br><span class="line">    <span class="comment">-- default `cond` you can use to globally disable a lot of plugins</span></span><br><span class="line">    <span class="comment">-- when running inside vscode for example</span></span><br><span class="line">    cond = <span class="literal">nil</span>, <span class="comment">---@type boolean|fun(self:LazyPlugin):boolean|nil</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">-- leave nil when passing the spec as the first argument to setup()</span></span><br><span class="line">  spec = <span class="literal">nil</span>, <span class="comment">---@type LazySpec</span></span><br><span class="line">  local_spec = <span class="literal">true</span>, <span class="comment">-- load project specific .lazy.lua spec files. They will be added at the end of the spec.</span></span><br><span class="line">  lockfile = vim.fn.stdpath(<span class="string">&quot;config&quot;</span>) .. <span class="string">&quot;/lazy-lock.json&quot;</span>, <span class="comment">-- lockfile generated after running update.</span></span><br><span class="line">  <span class="comment">---@type number? limit the maximum amount of concurrent tasks</span></span><br><span class="line">  concurrency = jit.<span class="built_in">os</span>:<span class="built_in">find</span>(<span class="string">&quot;Windows&quot;</span>) <span class="keyword">and</span> (vim.uv.available_parallelism() * <span class="number">2</span>) <span class="keyword">or</span> <span class="literal">nil</span>,</span><br><span class="line">  git = &#123;</span><br><span class="line">    <span class="comment">-- defaults for the `Lazy log` command</span></span><br><span class="line">    <span class="comment">-- log = &#123; &quot;--since=3 days ago&quot; &#125;, -- show commits from the last 3 days</span></span><br><span class="line">    <span class="built_in">log</span> = &#123; <span class="string">&quot;-8&quot;</span> &#125;, <span class="comment">-- show the last 8 commits</span></span><br><span class="line">    timeout = <span class="number">120</span>, <span class="comment">-- kill processes that take more than 2 minutes</span></span><br><span class="line">    url_format = <span class="string">&quot;https://github.com/%s.git&quot;</span>,</span><br><span class="line">    <span class="comment">-- lazy.nvim requires git &gt;=2.19.0. If you really want to use lazy with an older version,</span></span><br><span class="line">    <span class="comment">-- then set the below to false. This should work, but is NOT supported and will</span></span><br><span class="line">    <span class="comment">-- increase downloads a lot.</span></span><br><span class="line">    filter = <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  pkg = &#123;</span><br><span class="line">    enabled = <span class="literal">true</span>,</span><br><span class="line">    cache = vim.fn.stdpath(<span class="string">&quot;state&quot;</span>) .. <span class="string">&quot;/lazy/pkg-cache.lua&quot;</span>,</span><br><span class="line">    versions = <span class="literal">true</span>, <span class="comment">-- Honor versions in pkg sources</span></span><br><span class="line">    <span class="comment">-- the first package source that is found for a plugin will be used.</span></span><br><span class="line">    sources = &#123;</span><br><span class="line">      <span class="string">&quot;lazy&quot;</span>,</span><br><span class="line">      <span class="string">&quot;rockspec&quot;</span>,</span><br><span class="line">      <span class="string">&quot;packspec&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  rocks = &#123;</span><br><span class="line">    root = vim.fn.stdpath(<span class="string">&quot;data&quot;</span>) .. <span class="string">&quot;/lazy-rocks&quot;</span>,</span><br><span class="line">    server = <span class="string">&quot;https://nvim-neorocks.github.io/rocks-binaries/&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  dev = &#123;</span><br><span class="line">    <span class="comment">---@type string | fun(plugin: LazyPlugin): string directory where you store your local plugin projects</span></span><br><span class="line">    <span class="built_in">path</span> = <span class="string">&quot;~/projects&quot;</span>,</span><br><span class="line">    <span class="comment">---@type string[] plugins that match these patterns will use your local versions instead of being fetched from GitHub</span></span><br><span class="line">    patterns = &#123;&#125;, <span class="comment">-- For example &#123;&quot;folke&quot;&#125;</span></span><br><span class="line">    fallback = <span class="literal">false</span>, <span class="comment">-- Fallback to git when local plugin doesn&#x27;t exist</span></span><br><span class="line">  &#125;,</span><br><span class="line">  install = &#123;</span><br><span class="line">    <span class="comment">-- install missing plugins on startup. This doesn&#x27;t increase startup time.</span></span><br><span class="line">    missing = <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">-- try to load one of these colorschemes when starting an installation during startup</span></span><br><span class="line">    colorscheme = &#123; <span class="string">&quot;habamax&quot;</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  ui = &#123;</span><br><span class="line">    <span class="comment">-- a number &lt;1 is a percentage., &gt;1 is a fixed size</span></span><br><span class="line">    size = &#123; width = <span class="number">0.8</span>, height = <span class="number">0.8</span> &#125;,</span><br><span class="line">    <span class="built_in">wrap</span> = <span class="literal">true</span>, <span class="comment">-- wrap the lines in the ui</span></span><br><span class="line">    <span class="comment">-- The border to use for the UI window. Accepts same border values as |nvim_open_win()|.</span></span><br><span class="line">    border = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">    <span class="comment">-- The backdrop opacity. 0 is fully opaque, 100 is fully transparent.</span></span><br><span class="line">    backdrop = <span class="number">60</span>,</span><br><span class="line">    title = <span class="literal">nil</span>, <span class="comment">---@type string only works when border is not &quot;none&quot;</span></span><br><span class="line">    title_pos = <span class="string">&quot;center&quot;</span>, <span class="comment">---@type &quot;center&quot; | &quot;left&quot; | &quot;right&quot;</span></span><br><span class="line">    <span class="comment">-- Show pills on top of the Lazy window</span></span><br><span class="line">    pills = <span class="literal">true</span>, <span class="comment">---@type boolean</span></span><br><span class="line">    icons = &#123;</span><br><span class="line">      cmd = <span class="string">&quot; &quot;</span>,</span><br><span class="line">      <span class="built_in">config</span> = <span class="string">&quot;&quot;</span>,</span><br><span class="line">      event = <span class="string">&quot; &quot;</span>,</span><br><span class="line">      favorite = <span class="string">&quot; &quot;</span>,</span><br><span class="line">      ft = <span class="string">&quot; &quot;</span>,</span><br><span class="line">      init = <span class="string">&quot; &quot;</span>,</span><br><span class="line">      import = <span class="string">&quot; &quot;</span>,</span><br><span class="line">      keys = <span class="string">&quot; &quot;</span>,</span><br><span class="line">      lazy = <span class="string">&quot;󰒲 &quot;</span>,</span><br><span class="line">      <span class="built_in">loaded</span> = <span class="string">&quot;●&quot;</span>,</span><br><span class="line">      not_loaded = <span class="string">&quot;○&quot;</span>,</span><br><span class="line">      plugin = <span class="string">&quot; &quot;</span>,</span><br><span class="line">      runtime = <span class="string">&quot; &quot;</span>,</span><br><span class="line">      <span class="built_in">require</span> = <span class="string">&quot;󰢱 &quot;</span>,</span><br><span class="line">      source = <span class="string">&quot; &quot;</span>,</span><br><span class="line">      start = <span class="string">&quot; &quot;</span>,</span><br><span class="line">      task = <span class="string">&quot;✔ &quot;</span>,</span><br><span class="line">      list = &#123;</span><br><span class="line">        <span class="string">&quot;●&quot;</span>,</span><br><span class="line">        <span class="string">&quot;➜&quot;</span>,</span><br><span class="line">        <span class="string">&quot;★&quot;</span>,</span><br><span class="line">        <span class="string">&quot;‒&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">-- leave nil, to automatically select a browser depending on your OS.</span></span><br><span class="line">    <span class="comment">-- If you want to use a specific browser, you can define it here</span></span><br><span class="line">    browser = <span class="literal">nil</span>, <span class="comment">---@type string?</span></span><br><span class="line">    throttle = <span class="number">20</span>, <span class="comment">-- how frequently should the ui process render events</span></span><br><span class="line">    custom_keys = &#123;</span><br><span class="line">      <span class="comment">-- You can define custom key maps here. If present, the description will</span></span><br><span class="line">      <span class="comment">-- be shown in the help menu.</span></span><br><span class="line">      <span class="comment">-- To disable one of the defaults, set it to false.</span></span><br><span class="line"></span><br><span class="line">      [<span class="string">&quot;&lt;localleader&gt;l&quot;</span>] = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span><span class="params">(plugin)</span></span></span><br><span class="line">          <span class="built_in">require</span>(<span class="string">&quot;lazy.util&quot;</span>).float_term(&#123; <span class="string">&quot;lazygit&quot;</span>, <span class="string">&quot;log&quot;</span> &#125;, &#123;</span><br><span class="line">            cwd = plugin.dir,</span><br><span class="line">          &#125;)</span><br><span class="line">        <span class="keyword">end</span>,</span><br><span class="line">        desc = <span class="string">&quot;Open lazygit log&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      [<span class="string">&quot;&lt;localleader&gt;t&quot;</span>] = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span><span class="params">(plugin)</span></span></span><br><span class="line">          <span class="built_in">require</span>(<span class="string">&quot;lazy.util&quot;</span>).float_term(<span class="literal">nil</span>, &#123;</span><br><span class="line">            cwd = plugin.dir,</span><br><span class="line">          &#125;)</span><br><span class="line">        <span class="keyword">end</span>,</span><br><span class="line">        desc = <span class="string">&quot;Open terminal in plugin dir&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  diff = &#123;</span><br><span class="line">    <span class="comment">-- diff command &lt;d&gt; can be one of:</span></span><br><span class="line">    <span class="comment">-- * browser: opens the github compare view. Note that this is always mapped to &lt;K&gt; as well,</span></span><br><span class="line">    <span class="comment">--   so you can have a different command for diff &lt;d&gt;</span></span><br><span class="line">    <span class="comment">-- * git: will run git diff and open a buffer with filetype git</span></span><br><span class="line">    <span class="comment">-- * terminal_git: will open a pseudo terminal with git diff</span></span><br><span class="line">    <span class="comment">-- * diffview.nvim: will open Diffview to show the diff</span></span><br><span class="line">    cmd = <span class="string">&quot;git&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  checker = &#123;</span><br><span class="line">    <span class="comment">-- automatically check for plugin updates</span></span><br><span class="line">    enabled = <span class="literal">false</span>,</span><br><span class="line">    concurrency = <span class="literal">nil</span>, <span class="comment">---@type number? set to 1 to check for updates very slowly</span></span><br><span class="line">    notify = <span class="literal">true</span>, <span class="comment">-- get a notification when new updates are found</span></span><br><span class="line">    frequency = <span class="number">3600</span>, <span class="comment">-- check for updates every hour</span></span><br><span class="line">    check_pinned = <span class="literal">false</span>, <span class="comment">-- check for pinned packages that can&#x27;t be updated</span></span><br><span class="line">  &#125;,</span><br><span class="line">  change_detection = &#123;</span><br><span class="line">    <span class="comment">-- automatically check for config file changes and reload the ui</span></span><br><span class="line">    enabled = <span class="literal">true</span>,</span><br><span class="line">    notify = <span class="literal">true</span>, <span class="comment">-- get a notification when changes are found</span></span><br><span class="line">  &#125;,</span><br><span class="line">  performance = &#123;</span><br><span class="line">    cache = &#123;</span><br><span class="line">      enabled = <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    reset_packpath = <span class="literal">true</span>, <span class="comment">-- reset the package path to improve startup time</span></span><br><span class="line">    rtp = &#123;</span><br><span class="line">      reset = <span class="literal">true</span>, <span class="comment">-- reset the runtime path to $VIMRUNTIME and your config directory</span></span><br><span class="line">      <span class="comment">---@type string[]</span></span><br><span class="line">      paths = &#123;&#125;, <span class="comment">-- add any custom paths here that you want to includes in the rtp</span></span><br><span class="line">      <span class="comment">---@type string[] list any plugins you want to disable here</span></span><br><span class="line">      disabled_plugins = &#123;</span><br><span class="line">        <span class="comment">-- &quot;gzip&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;matchit&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;matchparen&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;netrwPlugin&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;tarPlugin&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;tohtml&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;tutor&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;zipPlugin&quot;,</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">-- lazy can generate helptags from the headings in markdown readme files,</span></span><br><span class="line">  <span class="comment">-- so :help works even for plugins that don&#x27;t have vim docs.</span></span><br><span class="line">  <span class="comment">-- when the readme opens with :help it will be correctly displayed as markdown</span></span><br><span class="line">  readme = &#123;</span><br><span class="line">    enabled = <span class="literal">true</span>,</span><br><span class="line">    root = vim.fn.stdpath(<span class="string">&quot;state&quot;</span>) .. <span class="string">&quot;/lazy/readme&quot;</span>,</span><br><span class="line">    files = &#123; <span class="string">&quot;README.md&quot;</span>, <span class="string">&quot;lua/**/README.md&quot;</span> &#125;,</span><br><span class="line">    <span class="comment">-- only generate markdown helptags for plugins that dont have docs</span></span><br><span class="line">    skip_if_doc_exists = <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  state = vim.fn.stdpath(<span class="string">&quot;state&quot;</span>) .. <span class="string">&quot;/lazy/state.json&quot;</span>, <span class="comment">-- state info for checker and other things</span></span><br><span class="line">  <span class="comment">-- Enable profiling of lazy.nvim. This will add some overhead,</span></span><br><span class="line">  <span class="comment">-- so only enable this when you are debugging lazy.nvim</span></span><br><span class="line">  profiling = &#123;</span><br><span class="line">    <span class="comment">-- Enables extra stats on the debug tab related to the loader cache.</span></span><br><span class="line">    <span class="comment">-- Additionally gathers stats about all package.loaders</span></span><br><span class="line">    loader = <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">-- Track each new require in the Lazy profiling tab</span></span><br><span class="line">    <span class="built_in">require</span> = <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>options.lua</code>中配置了一些全局变量以及vim许多属性.</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- This file is automatically loaded by plugins.core</span></span><br><span class="line">vim.g.mapleader = <span class="string">&quot; &quot;</span></span><br><span class="line">vim.g.maplocalleader = <span class="string">&quot;\\&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- LazyVim auto format</span></span><br><span class="line">vim.g.autoformat = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- LazyVim picker to use.</span></span><br><span class="line"><span class="comment">-- Can be one of: telescope, fzf</span></span><br><span class="line"><span class="comment">-- Leave it to &quot;auto&quot; to automatically use the picker</span></span><br><span class="line"><span class="comment">-- enabled with `:LazyExtras`</span></span><br><span class="line">vim.g.lazyvim_picker = <span class="string">&quot;auto&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- LazyVim root dir detection</span></span><br><span class="line"><span class="comment">-- Each entry can be:</span></span><br><span class="line"><span class="comment">-- * the name of a detector function like `lsp` or `cwd`</span></span><br><span class="line"><span class="comment">-- * a pattern or array of patterns like `.git` or `lua`.</span></span><br><span class="line"><span class="comment">-- * a function with signature `function(buf) -&gt; string|string[]`</span></span><br><span class="line">vim.g.root_spec = &#123; <span class="string">&quot;lsp&quot;</span>, &#123; <span class="string">&quot;.git&quot;</span>, <span class="string">&quot;lua&quot;</span> &#125;, <span class="string">&quot;cwd&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- LazyVim automatically configures lazygit:</span></span><br><span class="line"><span class="comment">--  * theme, based on the active colorscheme.</span></span><br><span class="line"><span class="comment">--  * editorPreset to nvim-remote</span></span><br><span class="line"><span class="comment">--  * enables nerd font icons</span></span><br><span class="line"><span class="comment">-- Set to false to disable.</span></span><br><span class="line">vim.g.lazygit_config = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Options for the LazyVim statuscolumn</span></span><br><span class="line">vim.g.lazyvim_statuscolumn = &#123;</span><br><span class="line">  folds_open = <span class="literal">false</span>, <span class="comment">-- show fold sign when fold is open</span></span><br><span class="line">  folds_githl = <span class="literal">false</span>, <span class="comment">-- highlight fold sign with git sign color</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Optionally setup the terminal to use</span></span><br><span class="line"><span class="comment">-- This sets `vim.o.shell` and does some additional configuration for:</span></span><br><span class="line"><span class="comment">-- * pwsh</span></span><br><span class="line"><span class="comment">-- * powershell</span></span><br><span class="line"><span class="comment">-- LazyVim.terminal.setup(&quot;pwsh&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Hide deprecation warnings</span></span><br><span class="line">vim.g.deprecation_warnings = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Set filetype to `bigfile` for files larger than 1.5 MB</span></span><br><span class="line"><span class="comment">-- Only vim syntax will be enabled (with the correct filetype)</span></span><br><span class="line"><span class="comment">-- LSP, treesitter and other ft plugins will be disabled.</span></span><br><span class="line"><span class="comment">-- mini.animate will also be disabled.</span></span><br><span class="line">vim.g.bigfile_size = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1.5</span> <span class="comment">-- 1.5 MB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Show the current document symbols location from Trouble in lualine</span></span><br><span class="line">vim.g.trouble_lualine = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> opt = vim.opt</span><br><span class="line"></span><br><span class="line">opt.autowrite = <span class="literal">true</span> <span class="comment">-- Enable auto write</span></span><br><span class="line"><span class="comment">-- only set clipboard if not in ssh, to make sure the OSC 52</span></span><br><span class="line"><span class="comment">-- integration works automatically. Requires Neovim &gt;= 0.10.0</span></span><br><span class="line">opt.clipboard = vim.env.SSH_TTY <span class="keyword">and</span> <span class="string">&quot;&quot;</span> <span class="keyword">or</span> <span class="string">&quot;unnamedplus&quot;</span> <span class="comment">-- Sync with system clipboard</span></span><br><span class="line">opt.completeopt = <span class="string">&quot;menu,menuone,noselect&quot;</span></span><br><span class="line">opt.conceallevel = <span class="number">2</span> <span class="comment">-- Hide * markup for bold and italic, but not markers with substitutions</span></span><br><span class="line">opt.confirm = <span class="literal">true</span> <span class="comment">-- Confirm to save changes before exiting modified buffer</span></span><br><span class="line">opt.cursorline = <span class="literal">true</span> <span class="comment">-- Enable highlighting of the current line</span></span><br><span class="line">opt.expandtab = <span class="literal">true</span> <span class="comment">-- Use spaces instead of tabs</span></span><br><span class="line">opt.fillchars = &#123;</span><br><span class="line">  foldopen = <span class="string">&quot;&quot;</span>,</span><br><span class="line">  foldclose = <span class="string">&quot;&quot;</span>,</span><br><span class="line">  fold = <span class="string">&quot; &quot;</span>,</span><br><span class="line">  foldsep = <span class="string">&quot; &quot;</span>,</span><br><span class="line">  diff = <span class="string">&quot;╱&quot;</span>,</span><br><span class="line">  eob = <span class="string">&quot; &quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">opt.foldlevel = <span class="number">99</span></span><br><span class="line">opt.formatexpr = <span class="string">&quot;v:lua.require&#x27;lazyvim.util&#x27;.format.formatexpr()&quot;</span></span><br><span class="line">opt.formatoptions = <span class="string">&quot;jcroqlnt&quot;</span> <span class="comment">-- tcqj</span></span><br><span class="line">opt.grepformat = <span class="string">&quot;%f:%l:%c:%m&quot;</span></span><br><span class="line">opt.grepprg = <span class="string">&quot;rg --vimgrep&quot;</span></span><br><span class="line">opt.ignorecase = <span class="literal">true</span> <span class="comment">-- Ignore case</span></span><br><span class="line">opt.inccommand = <span class="string">&quot;nosplit&quot;</span> <span class="comment">-- preview incremental substitute</span></span><br><span class="line">opt.jumpoptions = <span class="string">&quot;view&quot;</span></span><br><span class="line">opt.laststatus = <span class="number">3</span> <span class="comment">-- global statusline</span></span><br><span class="line">opt.linebreak = <span class="literal">true</span> <span class="comment">-- Wrap lines at convenient points</span></span><br><span class="line">opt.list = <span class="literal">true</span> <span class="comment">-- Show some invisible characters (tabs...</span></span><br><span class="line">opt.mouse = <span class="string">&quot;a&quot;</span> <span class="comment">-- Enable mouse mode</span></span><br><span class="line">opt.number = <span class="literal">true</span> <span class="comment">-- Print line number</span></span><br><span class="line">opt.pumblend = <span class="number">10</span> <span class="comment">-- Popup blend</span></span><br><span class="line">opt.pumheight = <span class="number">10</span> <span class="comment">-- Maximum number of entries in a popup</span></span><br><span class="line">opt.relativenumber = <span class="literal">true</span> <span class="comment">-- Relative line numbers</span></span><br><span class="line">opt.scrolloff = <span class="number">4</span> <span class="comment">-- Lines of context</span></span><br><span class="line">opt.sessionoptions = &#123; <span class="string">&quot;buffers&quot;</span>, <span class="string">&quot;curdir&quot;</span>, <span class="string">&quot;tabpages&quot;</span>, <span class="string">&quot;winsize&quot;</span>, <span class="string">&quot;help&quot;</span>, <span class="string">&quot;globals&quot;</span>, <span class="string">&quot;skiprtp&quot;</span>, <span class="string">&quot;folds&quot;</span> &#125;</span><br><span class="line">opt.shiftround = <span class="literal">true</span> <span class="comment">-- Round indent</span></span><br><span class="line">opt.shiftwidth = <span class="number">2</span> <span class="comment">-- Size of an indent</span></span><br><span class="line">opt.shortmess:append(&#123; W = <span class="literal">true</span>, I = <span class="literal">true</span>, c = <span class="literal">true</span>, C = <span class="literal">true</span> &#125;)</span><br><span class="line">opt.showmode = <span class="literal">false</span> <span class="comment">-- Dont show mode since we have a statusline</span></span><br><span class="line">opt.sidescrolloff = <span class="number">8</span> <span class="comment">-- Columns of context</span></span><br><span class="line">opt.signcolumn = <span class="string">&quot;yes&quot;</span> <span class="comment">-- Always show the signcolumn, otherwise it would shift the text each time</span></span><br><span class="line">opt.smartcase = <span class="literal">true</span> <span class="comment">-- Don&#x27;t ignore case with capitals</span></span><br><span class="line">opt.smartindent = <span class="literal">true</span> <span class="comment">-- Insert indents automatically</span></span><br><span class="line">opt.spelllang = &#123; <span class="string">&quot;en&quot;</span> &#125;</span><br><span class="line">opt.spelloptions:append(<span class="string">&quot;noplainbuffer&quot;</span>)</span><br><span class="line">opt.splitbelow = <span class="literal">true</span> <span class="comment">-- Put new windows below current</span></span><br><span class="line">opt.splitkeep = <span class="string">&quot;screen&quot;</span></span><br><span class="line">opt.splitright = <span class="literal">true</span> <span class="comment">-- Put new windows right of current</span></span><br><span class="line">opt.statuscolumn = <span class="string">[[%!v:lua.require&#x27;lazyvim.util&#x27;.ui.statuscolumn()]]</span></span><br><span class="line">opt.tabstop = <span class="number">2</span> <span class="comment">-- Number of spaces tabs count for</span></span><br><span class="line">opt.termguicolors = <span class="literal">true</span> <span class="comment">-- True color support</span></span><br><span class="line">opt.timeoutlen = vim.g.vscode <span class="keyword">and</span> <span class="number">1000</span> <span class="keyword">or</span> <span class="number">300</span> <span class="comment">-- Lower than default (1000) to quickly trigger which-key</span></span><br><span class="line">opt.undofile = <span class="literal">true</span></span><br><span class="line">opt.undolevels = <span class="number">10000</span></span><br><span class="line">opt.updatetime = <span class="number">200</span> <span class="comment">-- Save swap file and trigger CursorHold</span></span><br><span class="line">opt.virtualedit = <span class="string">&quot;block&quot;</span> <span class="comment">-- Allow cursor to move where there is no text in visual block mode</span></span><br><span class="line">opt.wildmode = <span class="string">&quot;longest:full,full&quot;</span> <span class="comment">-- Command-line completion mode</span></span><br><span class="line">opt.winminwidth = <span class="number">5</span> <span class="comment">-- Minimum window width</span></span><br><span class="line">opt.<span class="built_in">wrap</span> = <span class="literal">false</span> <span class="comment">-- Disable line wrap</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> vim.fn.has(<span class="string">&quot;nvim-0.10&quot;</span>) == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">  opt.smoothscroll = <span class="literal">true</span></span><br><span class="line">  opt.foldexpr = <span class="string">&quot;v:lua.require&#x27;lazyvim.util&#x27;.ui.foldexpr()&quot;</span></span><br><span class="line">  opt.foldmethod = <span class="string">&quot;expr&quot;</span></span><br><span class="line">  opt.foldtext = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  opt.foldmethod = <span class="string">&quot;indent&quot;</span></span><br><span class="line">  opt.foldtext = <span class="string">&quot;v:lua.require&#x27;lazyvim.util&#x27;.ui.foldtext()&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Fix markdown indentation settings</span></span><br><span class="line">vim.g.markdown_recommended_style = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>自定义的一些keymap如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- This file is automatically loaded by lazyvim.config.init</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- DO NOT USE `LazyVim.safe_keymap_set` IN YOUR OWN CONFIG!!</span></span><br><span class="line"><span class="comment">-- use `vim.keymap.set` instead</span></span><br><span class="line"><span class="keyword">local</span> map = LazyVim.safe_keymap_set</span><br><span class="line"></span><br><span class="line"><span class="comment">-- better up/down</span></span><br><span class="line">map(&#123; <span class="string">&quot;n&quot;</span>, <span class="string">&quot;x&quot;</span> &#125;, <span class="string">&quot;j&quot;</span>, <span class="string">&quot;v:count == 0 ? &#x27;gj&#x27; : &#x27;j&#x27;&quot;</span>, &#123; desc = <span class="string">&quot;Down&quot;</span>, expr = <span class="literal">true</span>, silent = <span class="literal">true</span> &#125;)</span><br><span class="line">map(&#123; <span class="string">&quot;n&quot;</span>, <span class="string">&quot;x&quot;</span> &#125;, <span class="string">&quot;&lt;Down&gt;&quot;</span>, <span class="string">&quot;v:count == 0 ? &#x27;gj&#x27; : &#x27;j&#x27;&quot;</span>, &#123; desc = <span class="string">&quot;Down&quot;</span>, expr = <span class="literal">true</span>, silent = <span class="literal">true</span> &#125;)</span><br><span class="line">map(&#123; <span class="string">&quot;n&quot;</span>, <span class="string">&quot;x&quot;</span> &#125;, <span class="string">&quot;k&quot;</span>, <span class="string">&quot;v:count == 0 ? &#x27;gk&#x27; : &#x27;k&#x27;&quot;</span>, &#123; desc = <span class="string">&quot;Up&quot;</span>, expr = <span class="literal">true</span>, silent = <span class="literal">true</span> &#125;)</span><br><span class="line">map(&#123; <span class="string">&quot;n&quot;</span>, <span class="string">&quot;x&quot;</span> &#125;, <span class="string">&quot;&lt;Up&gt;&quot;</span>, <span class="string">&quot;v:count == 0 ? &#x27;gk&#x27; : &#x27;k&#x27;&quot;</span>, &#123; desc = <span class="string">&quot;Up&quot;</span>, expr = <span class="literal">true</span>, silent = <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Move to window using the &lt;ctrl&gt; hjkl keys</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-h&gt;&quot;</span>, <span class="string">&quot;&lt;C-w&gt;h&quot;</span>, &#123; desc = <span class="string">&quot;Go to Left Window&quot;</span>, remap = <span class="literal">true</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-j&gt;&quot;</span>, <span class="string">&quot;&lt;C-w&gt;j&quot;</span>, &#123; desc = <span class="string">&quot;Go to Lower Window&quot;</span>, remap = <span class="literal">true</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-k&gt;&quot;</span>, <span class="string">&quot;&lt;C-w&gt;k&quot;</span>, &#123; desc = <span class="string">&quot;Go to Upper Window&quot;</span>, remap = <span class="literal">true</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-l&gt;&quot;</span>, <span class="string">&quot;&lt;C-w&gt;l&quot;</span>, &#123; desc = <span class="string">&quot;Go to Right Window&quot;</span>, remap = <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Resize window using &lt;ctrl&gt; arrow keys</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-Up&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;resize +2&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;Increase Window Height&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-Down&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;resize -2&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;Decrease Window Height&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-Left&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;vertical resize -2&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;Decrease Window Width&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-Right&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;vertical resize +2&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;Increase Window Width&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Move Lines</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;A-j&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;m .+1&lt;cr&gt;==&quot;</span>, &#123; desc = <span class="string">&quot;Move Down&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;A-k&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;m .-2&lt;cr&gt;==&quot;</span>, &#123; desc = <span class="string">&quot;Move Up&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;&lt;A-j&gt;&quot;</span>, <span class="string">&quot;&lt;esc&gt;&lt;cmd&gt;m .+1&lt;cr&gt;==gi&quot;</span>, &#123; desc = <span class="string">&quot;Move Down&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;&lt;A-k&gt;&quot;</span>, <span class="string">&quot;&lt;esc&gt;&lt;cmd&gt;m .-2&lt;cr&gt;==gi&quot;</span>, &#123; desc = <span class="string">&quot;Move Up&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;v&quot;</span>, <span class="string">&quot;&lt;A-j&gt;&quot;</span>, <span class="string">&quot;:m &#x27;&gt;+1&lt;cr&gt;gv=gv&quot;</span>, &#123; desc = <span class="string">&quot;Move Down&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;v&quot;</span>, <span class="string">&quot;&lt;A-k&gt;&quot;</span>, <span class="string">&quot;:m &#x27;&lt;-2&lt;cr&gt;gv=gv&quot;</span>, &#123; desc = <span class="string">&quot;Move Up&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- buffers</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;S-h&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;bprevious&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;Prev Buffer&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;S-l&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;bnext&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;Next Buffer&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;[b&quot;</span>, <span class="string">&quot;&lt;cmd&gt;bprevious&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;Prev Buffer&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;]b&quot;</span>, <span class="string">&quot;&lt;cmd&gt;bnext&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;Next Buffer&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;bb&quot;</span>, <span class="string">&quot;&lt;cmd&gt;e #&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;Switch to Other Buffer&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;`&quot;</span>, <span class="string">&quot;&lt;cmd&gt;e #&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;Switch to Other Buffer&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;bd&quot;</span>, LazyVim.ui.bufremove, &#123; desc = <span class="string">&quot;Delete Buffer&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;bD&quot;</span>, <span class="string">&quot;&lt;cmd&gt;:bd&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;Delete Buffer and Window&quot;</span> &#125;)</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p><code>autocmd.lua</code>如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- This file is automatically loaded by lazyvim.config.init.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">augroup</span><span class="params">(name)</span></span></span><br><span class="line">  <span class="keyword">return</span> vim.api.nvim_create_augroup(<span class="string">&quot;lazyvim_&quot;</span> .. name, &#123; clear = <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Check if we need to reload the file when it changed</span></span><br><span class="line">vim.api.nvim_create_autocmd(&#123; <span class="string">&quot;FocusGained&quot;</span>, <span class="string">&quot;TermClose&quot;</span>, <span class="string">&quot;TermLeave&quot;</span> &#125;, &#123;</span><br><span class="line">  group = augroup(<span class="string">&quot;checktime&quot;</span>),</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> vim.o.buftype ~= <span class="string">&quot;nofile&quot;</span> <span class="keyword">then</span></span><br><span class="line">      vim.cmd(<span class="string">&quot;checktime&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Highlight on yank</span></span><br><span class="line">vim.api.nvim_create_autocmd(<span class="string">&quot;TextYankPost&quot;</span>, &#123;</span><br><span class="line">  group = augroup(<span class="string">&quot;highlight_yank&quot;</span>),</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    vim.highlight.on_yank()</span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- resize splits if window got resized</span></span><br><span class="line">vim.api.nvim_create_autocmd(&#123; <span class="string">&quot;VimResized&quot;</span> &#125;, &#123;</span><br><span class="line">  group = augroup(<span class="string">&quot;resize_splits&quot;</span>),</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> current_tab = vim.fn.tabpagenr()</span><br><span class="line">    vim.cmd(<span class="string">&quot;tabdo wincmd =&quot;</span>)</span><br><span class="line">    vim.cmd(<span class="string">&quot;tabnext &quot;</span> .. current_tab)</span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- go to last loc when opening a buffer</span></span><br><span class="line">vim.api.nvim_create_autocmd(<span class="string">&quot;BufReadPost&quot;</span>, &#123;</span><br><span class="line">  group = augroup(<span class="string">&quot;last_loc&quot;</span>),</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">(event)</span></span></span><br><span class="line">    <span class="keyword">local</span> exclude = &#123; <span class="string">&quot;gitcommit&quot;</span> &#125;</span><br><span class="line">    <span class="keyword">local</span> buf = event.buf</span><br><span class="line">    <span class="keyword">if</span> vim.tbl_contains(exclude, vim.bo[buf].filetype) <span class="keyword">or</span> vim.b[buf].lazyvim_last_loc <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    vim.b[buf].lazyvim_last_loc = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">local</span> mark = vim.api.nvim_buf_get_mark(buf, <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">    <span class="keyword">local</span> lcount = vim.api.nvim_buf_line_count(buf)</span><br><span class="line">    <span class="keyword">if</span> mark[<span class="number">1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> mark[<span class="number">1</span>] &lt;= lcount <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">pcall</span>(vim.api.nvim_win_set_cursor, <span class="number">0</span>, mark)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- close some filetypes with &lt;q&gt;</span></span><br><span class="line">vim.api.nvim_create_autocmd(<span class="string">&quot;FileType&quot;</span>, &#123;</span><br><span class="line">  group = augroup(<span class="string">&quot;close_with_q&quot;</span>),</span><br><span class="line">  pattern = &#123;</span><br><span class="line">    <span class="string">&quot;PlenaryTestPopup&quot;</span>,</span><br><span class="line">    <span class="string">&quot;help&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lspinfo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;notify&quot;</span>,</span><br><span class="line">    <span class="string">&quot;qf&quot;</span>,</span><br><span class="line">    <span class="string">&quot;spectre_panel&quot;</span>,</span><br><span class="line">    <span class="string">&quot;startuptime&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tsplayground&quot;</span>,</span><br><span class="line">    <span class="string">&quot;neotest-output&quot;</span>,</span><br><span class="line">    <span class="string">&quot;checkhealth&quot;</span>,</span><br><span class="line">    <span class="string">&quot;neotest-summary&quot;</span>,</span><br><span class="line">    <span class="string">&quot;neotest-output-panel&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dbout&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gitsigns.blame&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">(event)</span></span></span><br><span class="line">    vim.bo[event.buf].buflisted = <span class="literal">false</span></span><br><span class="line">    vim.keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;&lt;cmd&gt;close&lt;cr&gt;&quot;</span>, &#123; buffer = event.buf, silent = <span class="literal">true</span> &#125;)</span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- make it easier to close man-files when opened inline</span></span><br><span class="line">vim.api.nvim_create_autocmd(<span class="string">&quot;FileType&quot;</span>, &#123;</span><br><span class="line">  group = augroup(<span class="string">&quot;man_unlisted&quot;</span>),</span><br><span class="line">  pattern = &#123; <span class="string">&quot;man&quot;</span> &#125;,</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">(event)</span></span></span><br><span class="line">    vim.bo[event.buf].buflisted = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- wrap and check for spell in text filetypes</span></span><br><span class="line">vim.api.nvim_create_autocmd(<span class="string">&quot;FileType&quot;</span>, &#123;</span><br><span class="line">  group = augroup(<span class="string">&quot;wrap_spell&quot;</span>),</span><br><span class="line">  pattern = &#123; <span class="string">&quot;*.txt&quot;</span>, <span class="string">&quot;*.tex&quot;</span>, <span class="string">&quot;*.typ&quot;</span>, <span class="string">&quot;gitcommit&quot;</span>, <span class="string">&quot;markdown&quot;</span> &#125;,</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    vim.opt_local.<span class="built_in">wrap</span> = <span class="literal">true</span></span><br><span class="line">    vim.opt_local.spell = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Fix conceallevel for json files</span></span><br><span class="line">vim.api.nvim_create_autocmd(&#123; <span class="string">&quot;FileType&quot;</span> &#125;, &#123;</span><br><span class="line">  group = augroup(<span class="string">&quot;json_conceal&quot;</span>),</span><br><span class="line">  pattern = &#123; <span class="string">&quot;json&quot;</span>, <span class="string">&quot;jsonc&quot;</span>, <span class="string">&quot;json5&quot;</span> &#125;,</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    vim.opt_local.conceallevel = <span class="number">0</span></span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Auto create dir when saving a file, in case some intermediate directory does not exist</span></span><br><span class="line">vim.api.nvim_create_autocmd(&#123; <span class="string">&quot;BufWritePre&quot;</span> &#125;, &#123;</span><br><span class="line">  group = augroup(<span class="string">&quot;auto_create_dir&quot;</span>),</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">(event)</span></span></span><br><span class="line">    <span class="keyword">if</span> event.<span class="built_in">match</span>:<span class="built_in">match</span>(<span class="string">&quot;^%w%w+:[\\/][\\/]&quot;</span>) <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> file = vim.uv.fs_realpath(event.<span class="built_in">match</span>) <span class="keyword">or</span> event.<span class="built_in">match</span></span><br><span class="line">    vim.fn.mkdir(vim.fn.fnamemodify(file, <span class="string">&quot;:p:h&quot;</span>), <span class="string">&quot;p&quot;</span>)</span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vim.filetype.add(&#123;</span><br><span class="line">  pattern = &#123;</span><br><span class="line">    [<span class="string">&quot;.*&quot;</span>] = &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span><span class="params">(path, buf)</span></span></span><br><span class="line">        <span class="keyword">return</span> vim.bo[buf]</span><br><span class="line">            <span class="keyword">and</span> vim.bo[buf].filetype ~= <span class="string">&quot;bigfile&quot;</span></span><br><span class="line">            <span class="keyword">and</span> <span class="built_in">path</span></span><br><span class="line">            <span class="keyword">and</span> vim.fn.getfsize(<span class="built_in">path</span>) &gt; vim.g.bigfile_size</span><br><span class="line">            <span class="keyword">and</span> <span class="string">&quot;bigfile&quot;</span></span><br><span class="line">          <span class="keyword">or</span> <span class="literal">nil</span></span><br><span class="line">      <span class="keyword">end</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vim.api.nvim_create_autocmd(&#123; <span class="string">&quot;FileType&quot;</span> &#125;, &#123;</span><br><span class="line">  group = augroup(<span class="string">&quot;bigfile&quot;</span>),</span><br><span class="line">  pattern = <span class="string">&quot;bigfile&quot;</span>,</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">(ev)</span></span></span><br><span class="line">    vim.b.minianimate_disable = <span class="literal">true</span></span><br><span class="line">    vim.schedule(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">      vim.bo[ev.buf].syntax = vim.filetype.<span class="built_in">match</span>(&#123; buf = ev.buf &#125;) <span class="keyword">or</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="如何配置Lazyvim"><a href="#如何配置Lazyvim" class="headerlink" title="如何配置Lazyvim"></a>如何配置Lazyvim</h5><p>lazyvim的官方建议:</p><ol><li>文件结构如下,可以在plugins文件夹中设置</li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~/.config/nvim</span><br><span class="line">├── <span class="keyword">lua</span></span><br><span class="line">│   ├── config</span><br><span class="line">│   │   └── lazy.<span class="keyword">lua</span></span><br><span class="line">│   └── plugins</span><br><span class="line">│       ├── spec1.<span class="keyword">lua</span></span><br><span class="line">│       ├── **</span><br><span class="line">│       └── spec2.<span class="keyword">lua</span></span><br><span class="line">└── init.<span class="keyword">lua</span></span><br></pre></td></tr></table></figure><p>默认的<code>lazy.lua</code>大概长下面这样,通过lazy.lua修改一些简单配置</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> lazypath = vim.fn.stdpath(<span class="string">&quot;data&quot;</span>) .. <span class="string">&quot;/lazy/lazy.nvim&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> (vim.uv <span class="keyword">or</span> vim.loop).fs_stat(lazypath) <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">local</span> lazyrepo = <span class="string">&quot;https://github.com/folke/lazy.nvim.git&quot;</span></span><br><span class="line">  <span class="keyword">local</span> out = vim.fn.system(&#123; <span class="string">&quot;git&quot;</span>, <span class="string">&quot;clone&quot;</span>, <span class="string">&quot;--filter=blob:none&quot;</span>, <span class="string">&quot;--branch=stable&quot;</span>, lazyrepo, lazypath &#125;)</span><br><span class="line">  <span class="keyword">if</span> vim.v.shell_error ~= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    vim.api.nvim_echo(&#123;</span><br><span class="line">      &#123; <span class="string">&quot;Failed to clone lazy.nvim:\n&quot;</span>, <span class="string">&quot;ErrorMsg&quot;</span> &#125;,</span><br><span class="line">      &#123; out, <span class="string">&quot;WarningMsg&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="string">&quot;\nPress any key to exit...&quot;</span> &#125;,</span><br><span class="line">    &#125;, <span class="literal">true</span>, &#123;&#125;)</span><br><span class="line">    vim.fn.getchar()</span><br><span class="line">    <span class="built_in">os</span>.<span class="built_in">exit</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">vim.opt.rtp:prepend(lazypath)</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;lazy&quot;</span>).setup(&#123;</span><br><span class="line">  spec = &#123;</span><br><span class="line">    <span class="comment">-- add LazyVim and import its plugins</span></span><br><span class="line">    &#123; <span class="string">&quot;LazyVim/LazyVim&quot;</span>, import = <span class="string">&quot;lazyvim.plugins&quot;</span> &#125;,</span><br><span class="line">    <span class="comment">-- import/override with your plugins</span></span><br><span class="line">    &#123; import = <span class="string">&quot;plugins&quot;</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  defaults = &#123;</span><br><span class="line">    <span class="comment">-- By default, only LazyVim plugins will be lazy-loaded. Your custom plugins will load during startup.</span></span><br><span class="line">    <span class="comment">-- If you know what you&#x27;re doing, you can set this to `true` to have all your custom plugins lazy-loaded by default.</span></span><br><span class="line">    lazy = <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">-- It&#x27;s recommended to leave version=false for now, since a lot the plugin that support versioning,</span></span><br><span class="line">    <span class="comment">-- have outdated releases, which may break your Neovim install.</span></span><br><span class="line">    version = <span class="literal">false</span>, <span class="comment">-- always use the latest git commit</span></span><br><span class="line">    <span class="comment">-- version = &quot;*&quot;, -- try installing the latest stable version for plugins that support semver</span></span><br><span class="line">  &#125;,</span><br><span class="line">  install = &#123; colorscheme = &#123; <span class="string">&quot;tokyonight&quot;</span>, <span class="string">&quot;habamax&quot;</span> &#125; &#125;,</span><br><span class="line">  checker = &#123; enabled = <span class="literal">true</span> &#125;, <span class="comment">-- automatically check for plugin updates</span></span><br><span class="line">  performance = &#123;</span><br><span class="line">    rtp = &#123;</span><br><span class="line">      <span class="comment">-- disable some rtp plugins</span></span><br><span class="line">      disabled_plugins = &#123;</span><br><span class="line">        <span class="string">&quot;gzip&quot;</span>,</span><br><span class="line">        <span class="comment">-- &quot;matchit&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;matchparen&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;netrwPlugin&quot;,</span></span><br><span class="line">        <span class="string">&quot;tarPlugin&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tohtml&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tutor&quot;</span>,</span><br><span class="line">        <span class="string">&quot;zipPlugin&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="pugin-spec"><a href="#pugin-spec" class="headerlink" title="pugin spec"></a>pugin spec</h5><p>可以这样修改插件的一些选项<a href="https://lazy.folke.io/spec">🔌 Plugin Spec | lazy.nvim (folke.io)</a></p><p>此外通过plugin spec下载或者更改插件的配置</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  <span class="comment">-- the colorscheme should be available when starting Neovim</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;folke/tokyonight.nvim&quot;</span>,</span><br><span class="line">    lazy = <span class="literal">false</span>, <span class="comment">-- make sure we load this during startup if it is your main colorscheme</span></span><br><span class="line">    priority = <span class="number">1000</span>, <span class="comment">-- make sure to load this before all the other start plugins</span></span><br><span class="line">    <span class="built_in">config</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">      <span class="comment">-- load the colorscheme here</span></span><br><span class="line">      vim.cmd(<span class="string">[[colorscheme tokyonight]]</span>)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- I have a separate config.mappings file where I require which-key.</span></span><br><span class="line">  <span class="comment">-- With lazy the plugin will be automatically loaded when it is required somewhere</span></span><br><span class="line">  &#123; <span class="string">&quot;folke/which-key.nvim&quot;</span>, lazy = <span class="literal">true</span> &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;nvim-neorg/neorg&quot;</span>,</span><br><span class="line">    <span class="comment">-- lazy-load on filetype</span></span><br><span class="line">    ft = <span class="string">&quot;norg&quot;</span>,</span><br><span class="line">    <span class="comment">-- options for neorg. This will automatically call `require(&quot;neorg&quot;).setup(opts)`</span></span><br><span class="line">    opts = &#123;</span><br><span class="line">      <span class="built_in">load</span> = &#123;</span><br><span class="line">        [<span class="string">&quot;core.defaults&quot;</span>] = &#123;&#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;dstein64/vim-startuptime&quot;</span>,</span><br><span class="line">    <span class="comment">-- lazy-load on a command</span></span><br><span class="line">    cmd = <span class="string">&quot;StartupTime&quot;</span>,</span><br><span class="line">    <span class="comment">-- init is called during startup. Configuration for vim plugins typically should be set in an init function</span></span><br><span class="line">    init = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">      vim.g.startuptime_tries = <span class="number">10</span></span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;hrsh7th/nvim-cmp&quot;</span>,</span><br><span class="line">    <span class="comment">-- load cmp on InsertEnter</span></span><br><span class="line">    event = <span class="string">&quot;InsertEnter&quot;</span>,</span><br><span class="line">    <span class="comment">-- these dependencies will only be loaded when cmp loads</span></span><br><span class="line">    <span class="comment">-- dependencies are always lazy-loaded unless specified otherwise</span></span><br><span class="line">    dependencies = &#123;</span><br><span class="line">      <span class="string">&quot;hrsh7th/cmp-nvim-lsp&quot;</span>,</span><br><span class="line">      <span class="string">&quot;hrsh7th/cmp-buffer&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">config</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">      <span class="comment">-- ...</span></span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- if some code requires a module from an unloaded plugin, it will be automatically loaded.</span></span><br><span class="line">  <span class="comment">-- So for api plugins like devicons, we can always set lazy=true</span></span><br><span class="line">  &#123; <span class="string">&quot;nvim-tree/nvim-web-devicons&quot;</span>, lazy = <span class="literal">true</span> &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- you can use the VeryLazy event for things that can</span></span><br><span class="line">  <span class="comment">-- load later and are not important for the initial UI</span></span><br><span class="line">  &#123; <span class="string">&quot;stevearc/dressing.nvim&quot;</span>, event = <span class="string">&quot;VeryLazy&quot;</span> &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;Wansmer/treesj&quot;</span>,</span><br><span class="line">    keys = &#123;</span><br><span class="line">      &#123; <span class="string">&quot;J&quot;</span>, <span class="string">&quot;&lt;cmd&gt;TSJToggle&lt;cr&gt;&quot;</span>, desc = <span class="string">&quot;Join Toggle&quot;</span> &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    opts = &#123; use_default_keymaps = <span class="literal">false</span>, max_join_length = <span class="number">150</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;monaqa/dial.nvim&quot;</span>,</span><br><span class="line">    <span class="comment">-- lazy-load on keys</span></span><br><span class="line">    <span class="comment">-- mode is `n` by default. For more advanced options, check the section on key mappings</span></span><br><span class="line">    keys = &#123; <span class="string">&quot;&lt;C-a&gt;&quot;</span>, &#123; <span class="string">&quot;&lt;C-x&gt;&quot;</span>, mode = <span class="string">&quot;n&quot;</span> &#125; &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- local plugins need to be explicitly configured with dir</span></span><br><span class="line">  &#123; dir = <span class="string">&quot;~/projects/secret.nvim&quot;</span> &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- you can use a custom url to fetch a plugin</span></span><br><span class="line">  &#123; url = <span class="string">&quot;git@github.com:folke/noice.nvim.git&quot;</span> &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- local plugins can also be configured with the dev option.</span></span><br><span class="line">  <span class="comment">-- This will use &#123;config.dev.path&#125;/noice.nvim/ instead of fetching it from GitHub</span></span><br><span class="line">  <span class="comment">-- With the dev option, you can easily switch between the local and installed version of a plugin</span></span><br><span class="line">  &#123; <span class="string">&quot;folke/noice.nvim&quot;</span>, dev = <span class="literal">true</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><strong>[1]</strong></td><td><code>string?</code></td><td>Short plugin url. Will be expanded using <a href="https://lazy.folke.io/configuration"><code>config.git.url_format</code></a>. Can also be a <code>url</code> or <code>dir</code>.</td></tr><tr><td><strong>dependencies</strong></td><td><code>LazySpec[]</code></td><td>A list of plugin names or plugin specs that should be loaded when the plugin loads. Dependencies are always lazy-loaded unless specified otherwise. When specifying a name, make sure the plugin spec has been defined somewhere else.</td></tr><tr><td><strong>enabled</strong></td><td><code>boolean?</code> or <code>fun():boolean</code></td><td>When <code>false</code>, or if the <code>function</code> returns false, then this plugin will not be included in the spec</td></tr><tr><td><strong>cond</strong></td><td><code>boolean?</code> or <code>fun(LazyPlugin):boolean</code></td><td>Behaves the same as <code>enabled</code>, but won’t uninstall the plugin when the condition is <code>false</code>. Useful to disable some plugins in vscode, or firenvim for example.</td></tr><tr><td><strong>priority</strong></td><td><code>number?</code></td><td>Only useful for <strong>start</strong> plugins (<code>lazy=false</code>) to force loading certain plugins first. Default priority is <code>50</code>. It’s recommended to set this to a high number for colorschemes</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><strong>init</strong></th><th><code>fun(LazyPlugin)</code></th><th><code>init</code> functions are always executed during. Mostly useful for setting <code>vim.g.*</code> configuration used by <strong>Vim</strong> plugins startup</th></tr></thead><tbody><tr><td><strong>opts</strong></td><td><code>table</code> or <code>fun(LazyPlugin, opts:table)</code></td><td><code>opts</code> should be a table (will be merged with parent specs), return a table (replaces parent specs) or should change a table. The table will be passed to the <code>Plugin.config()</code> function. Setting this value will imply <code>Plugin.config()</code></td></tr><tr><td><strong>config</strong></td><td><code>fun(LazyPlugin, opts:table)</code> or <code>true</code></td><td><code>config</code> is executed when the plugin loads. The default implementation will automatically run <code>require(MAIN).setup(opts)</code> if <code>opts</code> or <code>config = true</code> is set. Lazy uses several heuristics to determine the plugin’s <code>MAIN</code> module automatically based on the plugin’s <strong>name</strong>. <em>(<code>opts</code> is the recommended way to configure plugins)</em>.</td></tr><tr><td><strong>main</strong></td><td><code>string?</code></td><td>You can specify the <code>main</code> module to use for <code>config()</code> and <code>opts()</code>, in case it can not be determined automatically. See <code>config()</code></td></tr><tr><td><strong>build</strong></td><td><code>fun(LazyPlugin)</code> or <code>string</code> or <code>false</code> or a list of build commands</td><td><code>build</code> is executed when a plugin is installed or updated. See <a href="https://lazy.folke.io/developers#building">Building</a> for more information.</td></tr></tbody></table></div><h5 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h5><p>添加插件非常简单，只需将插件规格添加到 lua/plugins/*.lua 下的某个文件中即可。可以在其中创建任意数量的文件。允许缓存所有插件spec。<br>规格更改更新时将自动重新加载，因此 :Lazy UI 始终是最新的。</p><p>可以在 lua/plugins 文件夹中为每个插件创建一个文件,也可以为某些功能创建一个包含所有插件规格的独立文件.</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  <span class="comment">-- add symbols-outline</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;simrat39/symbols-outline.nvim&quot;</span>,</span><br><span class="line">    cmd = <span class="string">&quot;SymbolsOutline&quot;</span>, # 根据命令进行懒惰加载</span><br><span class="line">    keys = &#123; &#123; <span class="string">&quot;&lt;leader&gt;cs&quot;</span>, <span class="string">&quot;&lt;cmd&gt;SymbolsOutline&lt;cr&gt;&quot;</span>, desc = <span class="string">&quot;Symbols Outline&quot;</span> &#125; &#125;, #Lazy-<span class="built_in">load</span> on key mapping</span><br><span class="line">    opts = &#123;</span><br><span class="line">      <span class="comment">-- add your options that should be passed to the setup() function here</span></span><br><span class="line">      position = <span class="string">&quot;right&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>懒加载规则</strong></p><p>lazy.nvim 可自动懒加载 Lua 模块. 这意味着,如果你有一个懒加载的插件 A 和一个需要插件 A 的模块的插件 B,那么插件 A 将按照预期按需加载。</p><p>此外,还可以对事件(events)、命令(cmd)、文件类型(filetype)和按键映射(key mappings)进行懒加载.</p><p>当以下情况之一为真时，插件将被懒加载：</p><ul><li>该插件仅作为依赖项(dependency)存在于plugin spec中</li><li>它有一个事件、cmd、ft 或keys关键字</li><li>config.defaults.lazy == true</li></ul><p><strong>自定义Plugin Specs</strong></p><p>默认合并规则：</p><p>cmd：将使用自定义命令扩展命令列表<br>event：事件列表，将使用自定义事件进行扩展<br>ft：文件类型列表将使用自定义文件类型进行扩展<br>keys：键映射列表，将使用自定义键映射进行扩展<br>opts：自定义选项将与默认选项合并<br>dependencies：依赖项列表将使用自定义依赖项进行扩展<br>任何其他属性都将<strong>覆盖</strong>默认值,比如spec</p><p>也就是说如果lazyvim中有了你想下载的插件,你可通过在plugins目录下添加一个lua文件修改,如果你想添加一个没有的插件,操作是一样的,无非是少了一些默认的配置<strong>.</strong></p><blockquote><p>在可能的情况下，始终使用 opts 而不是 config。</p></blockquote><p><strong>增加或者禁用插件keymap</strong></p><p>添加 keys= 的规则。</p><p>也可以通过设置默认 keymap 为 false 来禁用.要覆盖一个关键映射,只需添加一个具有相同 lhs 和新 rhs 的关键映射(也就是按键相同,操作不同)</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  <span class="string">&quot;nvim-telescope/telescope.nvim&quot;</span>,</span><br><span class="line">  keys = &#123;</span><br><span class="line">    <span class="comment">-- disable the keymap to grep files</span></span><br><span class="line">    &#123;<span class="string">&quot;&lt;leader&gt;/&quot;</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">    <span class="comment">-- change a keymap</span></span><br><span class="line">    &#123; <span class="string">&quot;&lt;leader&gt;ff&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope find_files&lt;cr&gt;&quot;</span>, desc = <span class="string">&quot;Find Files&quot;</span> &#125;,</span><br><span class="line">    <span class="comment">-- add a keymap to browse plugin files</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;&lt;leader&gt;fp&quot;</span>,</span><br><span class="line">      <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">require</span>(<span class="string">&quot;telescope.builtin&quot;</span>).find_files(&#123; cwd = <span class="built_in">require</span>(<span class="string">&quot;lazy.core.config&quot;</span>).options.root &#125;) <span class="keyword">end</span>,</span><br><span class="line">      desc = <span class="string">&quot;Find Plugin File&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h5 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h5><ul><li>如果想去的缓冲区离您所在的位置很近，请使用 H 和 L。</li><li>否则，如果缓冲区已打开，请使用 \<leader>，</li><li>对于其他文件，使用 <leader><space>。</li><li>使用 \<leader>bd 关闭不再需要的缓冲区</li><li>使用 \<leader>ss 快速跳转到所处缓冲区中的函数</li><li><p>使用 \<c-o>、\<c-i> 和 gd 浏览代码</p></li><li><p>使用 \<leader>bp 可以固定缓冲区，使用 \<leader>bP 可以删除所有未固定的缓冲区</p></li><li>在你将来想做但现在不需要的文件中添加 TODO,并删除它们的缓冲区,git 会跟踪它们</li><li>如果要禁用某个缓冲区的自动格式化，则为该缓冲区设置 <code>vim.b.autoformat = false</code>。</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Disable autoformat for lua files</span></span><br><span class="line">vim.api.nvim_create_autocmd(&#123; <span class="string">&quot;FileType&quot;</span> &#125;, &#123;</span><br><span class="line">  pattern = &#123; <span class="string">&quot;lua&quot;</span> &#125;,</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    vim.b.autoformat = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以使用 <code>&lt;leader&gt;uf</code>来启用该缓冲区的自动格式化。</p><p>除了layvim的配置,neotree等使用的插件的配置也应该看看</p><p>如果你想学习vim,可以通过vim tutor或者在线的vim adventure练习.</p><h3 id="Alacritty"><a href="#Alacritty" class="headerlink" title="Alacritty"></a>Alacritty</h3><p>GPU加速的终端模拟器,保持了最小的核心功能,没有窗口分割等(如果想要更多功能,考虑使用wezterm(基本不需要什么配置),配置使用lua).</p><p>Alacritty的配置非常轻松,使用.toml<a href="https://alacritty.org/config-alacritty.html">Alacritty</a>,结构比较清晰</p><p>下面是一个例子</p><p><a href="https://github.com/TwiggieSmallz/Default-Alacritty-TOML-Config/blob/main/alacritty.toml">Default-Alacritty-TOML-Config/alacritty.toml at main · TwiggieSmallz/Default-Alacritty-TOML-Config (github.com)</a></p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[GENERAL]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[ENV]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[WINDOW]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[SCROLLING]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[FONT]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[SELECTION]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[TERMINAL]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[CURSOR]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[font]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[HINTS]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">size</span> = <span class="number">12.0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[font.bold]</span></span><br><span class="line"><span class="attr">family</span> = <span class="string">&quot;monospace&quot;</span></span><br><span class="line"><span class="attr">style</span> = <span class="string">&quot;Bold&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[font.bold_italic]</span></span><br><span class="line"><span class="attr">family</span> = <span class="string">&quot;monospace&quot;</span></span><br><span class="line"><span class="attr">style</span> = <span class="string">&quot;Bold Italic&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[font.italic]</span></span><br><span class="line"><span class="attr">family</span> = <span class="string">&quot;monospace&quot;</span></span><br><span class="line"><span class="attr">style</span> = <span class="string">&quot;Italic&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[font.normal]</span></span><br><span class="line"><span class="attr">family</span> = <span class="string">&quot;monospace&quot;</span></span><br><span class="line"><span class="attr">style</span> = <span class="string">&quot;Regular&quot;</span></span><br></pre></td></tr></table></figure><h3 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h3><p>有许多操作具体我也在学习,欢迎交流.感觉目前使用neovim写点小demo还是不错的,大项目可以使用jetbrains的IDE.</p><p>如果你想geek一点,使用arch的文档以及常用的软件<a href="https://wiki.archlinux.org/">ArchWiki (archlinux.org)</a>和<a href="https://github.com/ihchiz/Awesome-Linux-Software-zh_CN#窗口管理">ihchiz/Awesome-Linux-Software-zh_CN: 🐧 一个 Linux 上超赞的应用，软件，工具以及其它资源的集中地。 (github.com)</a>,下载和使用这类软件非常全面和方便. 可以考虑使用<a href="https://github.com/archcraft-os">Archcraft (github.com)</a>试试,自带许多配置文件.</p><p>也可以看看我介绍的一些日常开发setup<a href="https://protool-ten.vercel.app/setup/setup.html">protools (protool-ten.vercel.app)</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;常用的窗口管理器,编辑器与终端模拟器等等&lt;br&gt;</summary>
    
    
    
    
    <category term="setup" scheme="https://www.sekyoro.top/tags/setup/"/>
    
  </entry>
  
  <entry>
    <title>协作感知算法:三</title>
    <link href="https://www.sekyoro.top/2024/06/30/%E5%8D%8F%E4%BD%9C%E6%84%9F%E7%9F%A5%E7%AE%97%E6%B3%95-%E4%B8%89/"/>
    <id>https://www.sekyoro.top/2024/06/30/%E5%8D%8F%E4%BD%9C%E6%84%9F%E7%9F%A5%E7%AE%97%E6%B3%95-%E4%B8%89/</id>
    <published>2024-06-30T05:46:08.000Z</published>
    <updated>2024-09-12T13:39:58.742Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>一些稍微新一点或者之前没看到的想法还不错的协同感知论文<br><span id="more"></span></p><h2 id="More-Robust"><a href="#More-Robust" class="headerlink" title="More Robust"></a>More Robust</h2><p>提升检测精度,尤其是在位置噪声较大的情况下</p><h3 id="Self-Localized-Collaborative-Perception"><a href="#Self-Localized-Collaborative-Perception" class="headerlink" title="Self-Localized Collaborative Perception"></a>Self-Localized Collaborative Perception</h3><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>协作感知因其能够解决单智能体感知中的几个固有挑战（包括遮挡和超出范围问题）而受到广泛关注。然而，现有的<strong>协作感知系统严重依赖精确的定位系统来在智能体之间建立一致的空间坐标系</strong>。这种依赖使它们容易受到大型姿势错误或恶意攻击的影响，从而导致感知性能大幅降低。</p><p>为了解决这个问题，提出了 CoBEVGlue，这是一种新颖的自定位协作感知系统，无需使用外部定位系统即可实现更全面、更稳健的协作。CoBEVGlue 的核心是一个新颖的空间对齐模块，它通过有效匹配跨智能体的共可见对象来提供智能体之间的相对姿态。我们在真实数据集和模拟数据集上验证了我们的方法。</p><p>结果表明，i） CoBEVGlue 在<strong>任意定位噪声和攻击下实现了最先进的检测性能</strong>;ii） <strong>空间对齐模块可以与大多数以前的方法无缝集成</strong>，将它们的性能平均提高 57.7%</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>准确的感知对于自动驾驶汽车的导航和安全至关重要 。尽管大规模数据集 和强大的模型 推动了进步，但单智能体感知本身受到遮挡和远程问题 的限制，这可能导致灾难性的后果。利用现代通信技术，目前对协作感知的研究使多个智能体之间能够共享感知信息，从根本上提高了感知性能。</p><p>在高质量数据集和创新协作技术的推动下，协作感知系统有可能显著提高交通网络的安全性</p><p>在这个新兴的协作感知领域，大多数主流工作都做出了一个过于简化的假设：<strong>每个代理使用的全局定位系统（通常是 GPS 或 SLAM）足够精确，可以建立一个一致的协作空间坐标系</strong></p><p>然而，来自真实世界协作感知数据集V2V4Real和DAIR-V2X 的快照显示，即使经过细致和资源密集型的离线校准，地面实况定位仍然存在噪声。在<strong>计算限制和实时约束下，这些不准确之处在实际应用中可能会更加严重</strong>。</p><p>此外，定位系统容易受到长期存在但仍未解决的攻击。这些攻击允许攻击者随意操纵位置，进一步破坏定位系统的可靠性。这种显著噪声和恶意攻击的普遍挑战与早期工作所考虑的理想场景形成鲜明对比，这些工作主要关注轻微的姿态不准确，未能超越大噪声下无协作的基线.</p><p>为了消除对可能不可靠的外部定位系统的依赖，<strong>一种直接的解决方案是通过点云配准推断协作智能体的相对姿态，这种技术在多智能体协作系统中得到广泛应用。点云配准方法应用最近邻算法来识别广泛的3D点集之间的对应关系，然后是稳健的技术来计算这些假定对应关系的转换</strong>。尽管这些方法被证明对协作映射等延迟容忍应用有效，但对于带宽受限的协作感知系统来说，大量3D数据的实时传输是不切实际的。因此，在创建一个没有定位错误的系统，同时保持实际应用的通信效率方面，存在明显的差距。</p><p>为了填补这一空白，提出了 CoBEVGlue，这是一种自定位的协作感知系统，专为多个智能体设计，无需依赖外部定位系统即可实现更全面的感知，从而在降低通信成本的同时实现效率。CoBEVGlue 遵循以前的协作感知系统 的管道，并使用其关键的空间对齐模块 BEVGlue 来估计智能体与每个智能体检测和跟踪的物体之间的相对姿态。</p><p>BEVGlue <strong>背后的核心思想是从跨代理的鸟瞰感知数据中搜索共见对象，并计算与这些共见对象的相对变换，确保一致的协作空间坐标系</strong>。(The core idea behind BEVGlue is to search for the co-visible objects from the bird’s eye view perceptual data across agents and calculate the relative transformation with these co-visible objects, ensuring a consistent spatial coordinate system for collaboration.)确保一致的空间坐标系以进行协作。BEVGlue 包括三个关键组件：i） 对象图建模(object graph modeling)，将<strong>每个智能体的观察结果转换为具有丰富信息的对象图，包括对象形状、航向、跟踪 ID 和对象之间不变的空间关系</strong>;ii） 时间一致的最大子图检测，它有效地利用对象图中的空间和时间数据来检测最大的公共子图，遵循严格的空间同构约束和时间一致性;iii） 相对姿态计算，它<strong>使用检测到的公共子图计算代理之间的姿态关系</strong>，而无需使用耗时的异常值拒绝算法。</p><p>拟议的 CoBEVGlue 系统具有三个显着优势：</p><p>i） 它独立于外部定位设备运行，展示了其对噪音和恶意攻击的弹性</p><p>ii） 它带来的通信开销很小，因为 CoBEVGlue 仅使用带有跟踪 ID 的对象边界框来估计代理之间的相对姿势</p><p>;iii） 其核心模块 BEVGlue 通过在<strong>检测到的公共子图之间</strong>保持严格的空间同构约束和匹配结果之间随时间的时间一致性来确保高质量的匹配结果。</p><p>为了评估所提出的方法的有效性，考虑了三个数据集上的协作式3D目标检测任务：OPV2V、DAIR-V2X和V2V4Real，涵盖模拟和真实世界场景。结果表明，CoBEVGlue 赋予了强大的协作感知系统的性能与依赖精确定位信息的系统相当，并在存在定位噪声和攻击时实现了最先进的检测性能</p><p>为了获得对定位噪声的抵抗力，以前的工作考虑了两种主要方法：<strong>基于学习和基于匹配</strong>。基于学习的方法旨在构建健壮的网络架构，以减少姿态错误的影响。例如，V2VNet（稳健性） 设计了姿态回归、全局一致性和注意力聚合模块来纠正相对姿态并专注于姿态误差较小的邻居;V2X-ViT 使用多尺度窗口注意力来捕获各种范围内的特征。另一方面，基于匹配的方法<strong>寻求开发健壮的框架或网络架构。示例包括 FPV-RCNN和 CoAlign，它们使用基于 IoU 的匹配策略估计代理之间的相对姿势</strong>。但是，它们只能纠正外部定位中的微小不准确之处，因为这些方法依赖于基本精确的初始相对姿势。当噪声较大或存在攻击时，它们的性能会显著下降。<strong>相比之下，我们的工作认为协作感知独立于外部定位系统</strong></p><p>尽管本文的最终目标是提高检测能力，但<strong>点云配准方法的进步激发了我们提出新颖的自定位协作感知系统</strong>。传统的点云配准方法专注于改进迭代最近点 （ICP） 算法及其变体  导致了收敛和噪声弹性的改进。最近典型的点云配准工作流程包括提取<strong>本地 3D 特征描述符和进行配准。为了提取 3D 局部描述符，快速点特征直方图等传统方法利用了手工制作的特征</strong>。</p><p>最近的技术为此目的采用了基于学习的方法。在配准方面，<strong>传统方法通常采用最近邻算法进行匹配，并采用稳健优化来剔除异常值</strong>，而<strong>现代深度配准方法则利用自注意机制来确定对应关系</strong>。SGAligner率先使用预构建的 3D 场景图进行配准。然而，与前面的策略类似，它需要传输密集的点云和高维特征。这些方法广泛应用于容忍延迟的多智能体系统，如协同映射和 3D 场景图生成.但是，协作对象检测任务需要实时进行精确的相对姿态估计。遗憾的是，<strong>V2X 网络难以实时传输点云配准方法所需的密集点云和特征。为了克服这一限制</strong>，我们的方法优先考虑对象级注册，仅用 8 个 float 数字表示每个对象(To overcome this limitation, our approach prioritizes object-level registration, representing each object with just eight float numbers.)。这项创新显著降低了计算协作自动驾驶汽车之间相对姿态所需的带宽和计算成本，从而有效地解决了传输困境(This innovation markedly reduces the bandwidth necessary and computation cost for calculating relative poses among collaborative autonomous vehicles, thus efficiently resolving the transmission dilemma)</p><p>最大公共子图（Maximum Common Subgraph Detection,MCS）检测问题被归类为NPhard，在各个科学领域中都至关重要，需要平衡精度和计算效率的算法。传统方法主要采用分支定界算法和将 MCS 检测转化为最大团问题的技术. 机器学习的最新进展已经看到了图神经网络和强化学习在 MCS 检测中的应用，MCS 检测试图学习合适的启发式方法来进行图匹配。尽管他们进行了创新，但它们仍然受到搜索空间探索的启发式性质的限制，并且在最坏的情况下会受到指数级时间复杂度的影响。在这项工作中，我们<strong>使用几何不变对象姿态图对每个代理检测到的边界框进行建模，并利用空间约束和时间一致性来有效地解决问题。</strong></p><p><img data-src="https://s2.loli.net/2024/09/03/TPz1njuNZGi7Qbc.png" alt="image-20240903155532374"></p><script type="math/tex; mode=display">\begin{aligned}\mathbf{F}_i^t,\mathbf{D}_i^t& =f_{\text{detection}\&\text{tracking}}\left(\mathbf{O}_i^t\right), \\\xi_{j\to i}^t& =f_{\mathrm{BEVGlue}}\left(\mathrm{D}_i^t,\mathrm{D}_j^t\right), \\\mathbf{F}_{j\to i}^t& =f_{\text{transform}}\left(\mathbf{F}_j^t,\xi_{j\to i}^t\right), \\\mathbf{F}_{i}^{\prime}t& =f_{\mathrm{fusion}}\left(\{\mathbf{F}_{j\to i}^t\}_{j=1,2,\cdots,N}\right), \\\mathbf{B}_i^t& =f_{\mathrm{decoder}}\left(\mathbf{F}_i^{'t}\right), \end{aligned}</script><p>精确的姿态信息<strong>要求每个代理利用外部定位系统来获取其全局位置并计算协作者之间的相对变换</strong>。这种对外部定位的依赖充满了挑战，包括容易受到噪声干扰和恶意攻击造成的潜在安全漏洞。<strong>BEVGlue 旨在通过利用感知数据来确保准确的相对姿态估计来解决这些问题</strong>，从而增强协作感知的弹性和有效性。</p><p>为了估计智能体之间的相对姿态 ξt j→i，BEVGlue 的主要思想是识别共可见的物体，然后根据这些共见物体计算变换。为了挖掘智能体之间的这种内部对应关系，BEVGlue 提出了三个模块：（i） 对象图建模，（ii） 时间一致的最大公共子图检测，以及 （iii） 相对姿态计算。</p><p><strong>Object Graph Modeling</strong></p><p>鉴于极点和参考方向在物理世界中具有清晰和单一的定义，因此可以实现不同对象图之间边缘特征计算的一致性。具体来说，如果在基于智能体 j 计算智能体图 Gt j 上的边缘特征 e^t^<em>j,mn</em> 时，节点 m 和 n 的检测结果对于第 i 个和第 j 个智能体都是准确的，则它与 e^t^<em>i,mn</em> 相同。</p><p>对象图提供了一种创新方法来对每个代理的观察进行建模：i） 节点属性包含时间跟踪数据，这有助于保持随时间推移的匹配一致性;ii） 边缘特征在从不同代理的角度得出的对象图中是一致的，这意味着应用于 D^t^<em>i</em> 的旋转和平移不会改变 e^t^ <em>i,mn</em> 的值。这意味着，当两个对象同时被不同的代理观察时，无论视角如何变化，边缘属性都保持一致。</p><p>对象图提供了一种创新方法来对每个代理的观察进行建模：i） <strong>节点属性包含时间跟踪数据，这有助于保持随时间推移的匹配一致性</strong>;ii） <strong>边缘特征在从不同代理的角度得出的对象图中是一致的</strong>，这意味着应用于 D^t^<em>i</em> 的旋转和平移不会改变 e^t^<em>i,mn</em> 的值。这意味着，当两个对象同时被不同的代理观察时，无论视角如何变化，边缘属性都保持一致</p><blockquote><p>每个代理根据自己的检测结构建模一个对象图,图中有一些节点和边.</p><p>每个节点属性包括bbox的宽高和id,边节点属性包括相对距离,相对航向角和航向角相对</p></blockquote><p><img data-src="https://s2.loli.net/2024/09/03/2oyQWEVrpMiRLhA.png" alt="image-20240903170504372"></p><script type="math/tex; mode=display">\mathcal{H}_{(i,j)}^t=f_{\mathrm{MCS}}\left(\mathcal{G}_i^t,\mathcal{G}_j^t,\mathcal{H}_{(i,j)}^{t-1}\right).</script><p>上面的MCS函数可以分为三个过程.具体我就不说了,这篇文章一般,在一些介绍上还有点含糊不清.</p><p><img data-src="https://s2.loli.net/2024/09/05/NxJjAighnW1tEVX.png" alt="image-20240905150424806"></p><h3 id="Multi-Agent-Collaborative-Perception-via-Motion-Aware-Robust-Communication-Network"><a href="#Multi-Agent-Collaborative-Perception-via-Motion-Aware-Robust-Communication-Network" class="headerlink" title="Multi-Agent Collaborative Perception via Motion-Aware Robust Communication Network"></a>Multi-Agent Collaborative Perception via Motion-Aware Robust Communication Network</h3><h2 id="More-domain-invariant"><a href="#More-domain-invariant" class="headerlink" title="More domain-invariant"></a>More domain-invariant</h2><p>提升迁移性,在仿真数据集上训练能在真实数据集上保证良好的效果.</p><h3 id="V2X-DGW-Domain-Generalization-for-Multi-agent-Perception-under-Adverse-Weather-Conditions"><a href="#V2X-DGW-Domain-Generalization-for-Multi-agent-Perception-under-Adverse-Weather-Conditions" class="headerlink" title="V2X-DGW: Domain Generalization for Multi-agent Perception under Adverse Weather Conditions"></a>V2X-DGW: Domain Generalization for Multi-agent Perception under Adverse Weather Conditions</h3><h2 id="More-Communication-efficient"><a href="#More-Communication-efficient" class="headerlink" title="More Communication-efficient"></a>More Communication-efficient</h2><p>减少传输的数据大小,使得通信更高效.</p><h3 id="ERMVP-Communication-Efficient-and-Collaboration-Robust-Multi-Vehicle-Perception-in-Challenging-Environments"><a href="#ERMVP-Communication-Efficient-and-Collaboration-Robust-Multi-Vehicle-Perception-in-Challenging-Environments" class="headerlink" title="ERMVP: Communication-Efficient and Collaboration-Robust Multi-Vehicle Perception in Challenging Environments"></a>ERMVP: Communication-Efficient and Collaboration-Robust Multi-Vehicle Perception in Challenging Environments</h3><p>​    协作感知通过使自动驾驶汽车能够交换互补信息来提高感知性能。尽管它有可能彻底改变移动行业，但各种环境中的挑战，如<strong>通信带宽限制</strong>、定位错误和<strong>信息聚合效率低下</strong>，阻碍了它在实际应用中的实施。在这项工作中，我们提出了 ERMVP，这是一种在具有挑战性的环境中进行通信高效和协作的鲁棒多车辆感知方法。具体来说，ERMVP 具有三个明显的优势i） 它利用分层特征采样策略来抽象一组具有代表性的特征向量，使用更少的通信开销实现高效通信;ii） 它采用稀疏一致性特征来执行精确的空间位置校准，有效减轻车辆定位错误的影响;iii） 引入了一种开创性的特征融合和交互范式，以在不同车辆和数据源之间集成整体空间语义。</p><p>自动驾驶汽车被广泛认为是提高道路安全和交通效率的重要手段。这些车辆配备了激光雷达、摄像头和其他传感器，能够准确感知周围环境，以确保安全可靠的运行。<strong>然而，单车感知系统不可避免地存在缺点 ，例如传感器视野有限，容易被遮挡，以及由于数据稀疏和低分辨率而难以检测远处物体。</strong></p><p>最近，车对车 （V2V） 通信技术和深度学习的进步刺激了协作感知技术的创新和进步。这项技术允许互联自动驾驶汽车 （CAV） 共享传感数据，从而实现更全面的环境感知.</p><p>​    尽管协作感知技术在移动出行行业转型方面显示出巨大潜力，但其实际应用面临一些挑战，包括通信带宽限制、<strong>定位错误和信息聚合效率低下</strong></p><p>在实际场景中，无线通信资源和可靠性的约束严重阻碍了延迟敏感协作感知的有效性。虽然最近的工作通过精心设计的机制实现了感知性能和通信带宽之间的平衡，但这些方法有其局限性，因为它们主要考虑信息压缩而不是空间冗余。这种狭窄的关注点会加剧高压缩比下的性能下降.</p><p>​    此外,复杂的动态环境会导致定位错误，从而导致相对变换估计不准确和空间特征错位。这种相对姿势噪声会产生误导性特征，从而对协作感知的有效性产生不利影响。现有的方法试图通过密集的计算来优化整体姿态，但高延迟使其不适合实时动态感知.同时,协作方法只关注聚合信息，而忽视了自我载体固有的感知优势.此范例容易受到协作噪声引入的扰动的影响,包括异步运动模糊和不准确的投影.这样的缺点成为实现最佳感知性能的瓶颈.</p><p>相比之下，<strong>以自我为中心的特征可能包含不受协作噪声影响的局部准确空间位置信息</strong>。因此，建立务实的协作感知系统的首要任务是有效克服上述挑战.</p><p><img data-src="https://s2.loli.net/2024/09/05/5dxPGSYCcNgRBbn.png" alt="image-20240905153336761"></p><p>基于这些观察提出了 ERMVP，这是一种在具有挑战性的环境中通信高效且协作稳健的多车辆感知方法。具体来说,（i） 首先设计了一种高级滤波器和合并特征采样策略来解决无线通信资源的局限性。此策略同时考虑类间和类内冗余关系，以从冗余特征中抽象出一组精炼的特征向量，从而使用更少的通信开销实现高效通信.(ii)其次，我们引入了一个即插即用功能空间校准模块，以减轻车辆定位错误的影响。该模块巧妙地利用共识稀疏前景特征来对齐自我车辆和合作者之间的相对姿态关系，而无需任何精确的姿态监督。(iii)此外提出了一种开创性的特征融合和交互范式,以整合整体空间语义。</p><p>该范式包括两个关键组件:第一个是基于注意力的特征融合模块，在本地和全局注意力之间交替,以融合来自不同车辆的异构信息.</p><p>第二种是准确性增强特征交互策略,它利用以自我为中心的特征中固有的准确位置信息来增强融合特征提供的丰富语义信息.</p><p>• 我们提出了 ERMVP，这是一种<strong>通信高效</strong>且<strong>协作稳健</strong>的多车辆感知方法，它<strong>解决了通信带宽限制、定位错误和信息聚合效率挑战</strong>。</p><p>• 我们开发了一个过滤和合并特征采样策略来提高通信效率，一个用<strong>于精确空间特征对齐的特征空间校准模块，以及两个信息聚合组件来优化融合过程。</strong></p><p>• 我们对真实世界和模拟数据集进行了广泛的实验。结果表明了我们方法的优越性和所提出组件的必要性。</p><h5 id="Filter-and-Merge-Feature-Sampling"><a href="#Filter-and-Merge-Feature-Sampling" class="headerlink" title="Filter and Merge Feature Sampling"></a>Filter and Merge Feature Sampling</h5><p>以前的工作利用了精心设计的机制，如信息熵通信选择 [37] 和空间异质性映射来减少所需的传输带宽。</p><p>然而，这些方法主要关注前台和后台特征之间的类间冗余，而忽略了特征之间的类内冗余，从而导致次优压缩。为了解决这一差距，我们引入了一种高级过滤和合并特征采样策略 （FMS）。该策略同时考虑了类间和类内冗余关系，有效地从原始特征图中提取了一组简洁而独特的特征向量，从而更有效地减少了通信开销。FMS 由以下两个核心组件组成。</p><p>Filter Sampler(滤波器采样器).在对象检测中，包含对象的前景区域比背景区域更重要。因此，我们将减少空间冗余的想法实现到特征过滤器采样器模块中，旨在保留感知上重要但稀疏的特征向量集。由于显式学习二进制采样器是不可行的，因此我们开发了一种置信度过滤器策略.最初,为特征图生成检测置信度图。它反映了不同空间区域的感知重要性，较高的级别表示潜在的对象区域，较低的级别通常表示冗余的背景区域.</p><script type="math/tex; mode=display">C_i=\Phi_{\mathrm{con_gen}}\left(F_i\right)\in[0,1]^{H\times W}</script><p>其中 Φcon_gen（·） 表示具有检测解码器结构的置信度生成网络。然后对置信度图进行阈值处理，然后进行非极大值抑制，从而产生二进制掩码 B。</p><script type="math/tex; mode=display">\tilde{F}_{i}=B\odot F_{i}</script><p>Merge Sampler(合并采样器):在用滤波器采样器提取详细的前景特征向量集后，我们<strong>使用合并采样器进行额外的优化，通过加权合并来提炼相似或重复的前景特征向量</strong>。该过程分为三个阶段：信息驱动的<strong>特征分组</strong>、注意力启发的<strong>特征合并</strong>和基于索引的<strong>特征重建</strong>(information-driven feature grouping, attention-inspired feature merging, and index-based feature reconstruction.)</p><ol><li><p>应用最近邻聚类算法的变体对前景特征向量集进行分组.给定一组特征向量 $F^{~}_{i}$ =[x1，x2,…,xL] 和集群中心 $X_c$，我们计算每个特征向量的指标 δi。</p><p>δi 的计算方法是最小特征距离减去到任何其他聚类中心向量的平均像素距离</p></li></ol><script type="math/tex; mode=display">\delta_i=\min_{j:x_j\in X_c}\left(\left\|x_i-x_j\right\|_2^2-\gamma\left\|p(x_i),p(x_j)\right\|_2^2\right)</script><ol><li>合并特征向量的一种简单策略是平均集群中的每个特征向量。但是，此方案可能会受到异常值特征向量的严重影响。从注意力机制中汲取灵感，利<strong>用置信度分数作为指导来量化每个特征的重要性</strong>。因此，第 i 个簇 Gi 的合并特征向量 ̃ 习 计算为</li></ol><script type="math/tex; mode=display">\widetilde{x}_i=\frac{\sum_{j\in G_i}c_jx_j}{\sum_{j\in G_i}c_j}</script><ol><li>在特征分组和合并过程中，每个特征向量都分配给一个集群，每个集群由一个合并的向量表示。<strong>维护原始特征向量和合并特征向量之间的索引对应关系的记录</strong>。利用这个索引记录，自我车辆确保合并的特征向量被映射到它们的相应位置，从而重建特征图</li></ol><p>定位错误可能导致车辆之间的特征图错位。这种错位会导致自我车辆误解物体的位置，从而导致感知能力下降，为了应对这一挑战，引入了特征空间校准模块 （FSC） 来促进精确的特征对齐</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240909091549936.png" alt="image-20240909091549936"></p><p>涉及三个阶段：一致性匹配、几何验证和误差调制。</p><p>​    将自我车辆的拟议匹配区域表示为 P，将协作车辆在嘈杂姿势条件下识别的区域表示为 Q。利用 P 和 Q，构建了一个加权二分图，其中每条边的权重由节点之间的距离决定，封装在成本矩阵中。然后将匹配过程转换为线性分配任务，目的是确定具有最低累积边缘权重的匹配结果。此过程将生成匹配的对 M</p><p>​    由于对象位于专用区域和检测噪声，可能会出现无效匹配。为了解决这个问题，我们利用 RANSAC 来过滤和筛选一组与预期几何变换一致的匹配项。首先，选择一个随机匹配子集Ms ，然后利用奇异值分解计算变换矩阵Γ s .当Γ s应用于Ms内的所有对时，如果这些对之间的变换后距离保持在阈值η以下，则认为该集合是正确对齐的。阈值η反映了原始协作框架内允许的定位误差。这个过程是迭代进行的，以确定与最大正确匹配数相关的最佳变换矩阵。最终得到一个最优的精化变换矩阵Γ r，并将其应用于后续的空间标定操作中，得到对齐后的特征’ Zj = Γ rZj</p><p>​    为了增强校准方法在各种环境下的适应性，我们融入了<strong>误差调制策略。该策略旨在实现定位误差与标定过程中产生的估计误差之间的平衡</strong>。它测量了自我和协作特征在调整状态和原始状态下的重叠比例。</p><h4 id="Attention-based-Feature-Fusion"><a href="#Attention-based-Feature-Fusion" class="headerlink" title="Attention-based Feature Fusion"></a>Attention-based Feature Fusion</h4><p>在多车辆协作场景中，车辆能够捕获来自不同空间区域的异构信息。为了高效地融合来自多个车辆的感知特征，我们提出了一种注意力特征融合方法( AFF )。AFF利用交替的局部和全局注意力，在遮挡变化的交通场景中实现位置级别的精确匹配，并捕获道路拓扑和交通状态的全局语义注意力</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240909094342791.png" alt="image-20240909094342791"></p><p>该模块允许系统从局部视图分析空间相关性,同时也捕获全局特征响应,确保在动态、复杂和遮挡变化的交通场景中实现高效和精确的感知.最后得到融合特征H~i~</p><h4 id="Accuracy-Enhanced-Feature-Interaction"><a href="#Accuracy-Enhanced-Feature-Interaction" class="headerlink" title="Accuracy Enhanced Feature Interaction"></a>Accuracy Enhanced Feature Interaction</h4><p>​    先前的工作已经证明了融合特征可以提供更丰富的语义信息，从而提高感知性能。然而，它们可能会受到协作噪声的影响，如异步运动模糊和不准确的投影,这会损害准确的位置信息,成为感知性能最优实现的瓶颈.以自我为中心的特征可能包含局部关键的空间位置信息,而不受协作噪声的影响.</p><p>​    为此,我们提出了一种准确性增强的特征交互( Accuracy Enhanced Feature Interaction，AEI )策略,该策略利用自我中心特征固有的准确位置信息来增强协同融合特征提供的丰富语义信息.</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240909105358537.png" alt="image-20240909105358537"></p><h3 id="Pragmatic-Communication-in-Multi-Agent-Collaborative-Perception"><a href="#Pragmatic-Communication-in-Multi-Agent-Collaborative-Perception" class="headerlink" title="Pragmatic Communication in Multi-Agent Collaborative Perception"></a>Pragmatic Communication in Multi-Agent Collaborative Perception</h3><p>​    多智能体协同感知的目标是使智能体通过通信交换互补的感知信息，从而实现更全面的感知。协同感知保证了扩展的可视性，通过障碍物和识别小的、远距离的目标，从而实现对环境的彻底理解。它为从根本上克服单智能体感知的物理局限性提供了一个很有前途的方向，如视场受限、遮挡、远距离等问题。作为自主系统的最前沿，协作感知可以增强感知能力，并在各种现实世界的应用中进一步提高系统的功能和安全性，包括自动驾驶机器人技术和无人驾驶.</p><p>​    为了应对这一挑战，关键在于在通信预算范围内优化消息以满足每个智能体的特定感知任务需求。一种直接的方法是在传统的香农通信范式中使用信源编码。该方法将原始数据编码为一系列代码，将较短的代码分配给频繁数据，将较长的代码分配给稀有数据，在不损失信息的情况下创建紧凑的表示。在协同感知的背景下，该方法在支持者端有效地将感知数据压缩为消息，并在接收者端确保无损复制.</p><p>​    这种方法提高了通信效率，同时保留了对包括感知在内的一般下游任务的效用。然而，这种Shannon范式在需要为特定下游任务定制通信的场景中具有根本的局限性，因为它不可避免地浪费了无关的资源数据。例如，在相机-传感器-智能体协作的车辆检测任务中，香农范式对每个像素进行统一编码，而不区分非必要的背景和关键的车辆像素。这些背景像素在无助于检测性能的情况下极大地浪费了通信资源，从而影响了感知-通信的权衡。</p><h3 id="What-Makes-Good-Collaborative-Views-Contrastive-Mutual-Information-Maximization-for-Multi-Agent-Perception"><a href="#What-Makes-Good-Collaborative-Views-Contrastive-Mutual-Information-Maximization-for-Multi-Agent-Perception" class="headerlink" title="What Makes Good Collaborative Views? Contrastive Mutual Information Maximization for Multi-Agent Perception"></a>What Makes Good Collaborative Views? Contrastive Mutual Information Maximization for Multi-Agent Perception</h3><h2 id="Towards-Label-Efficient"><a href="#Towards-Label-Efficient" class="headerlink" title="Towards Label Efficient"></a>Towards Label Efficient</h2><h3 id="COˆ3-Cooperative-Unsupervised-3D-Representation-Learning-for-Autonomous-Driving"><a href="#COˆ3-Cooperative-Unsupervised-3D-Representation-Learning-for-Autonomous-Driving" class="headerlink" title="COˆ3: Cooperative Unsupervised 3D Representation Learning for Autonomous Driving"></a>COˆ3: Cooperative Unsupervised 3D Representation Learning for Autonomous Driving</h3><h4 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h4><p>针对室内场景点云的无监督对比学习已经取得了巨大的成功。然而，室外场景点云的无监督表示学习仍然具有挑战性，因为以前的方法需要重建整个场景并捕获对比目标的部分视图。这在有运动物体、障碍物和传感器的室外场景中是不可行的。在本文中，我们提出了CO ( 3，即协同对比学习和上下文形状预测，以无监督的方式学习室外场景点云的三维表示。与现有方法相比，CO3有几个优点。( 1 )利用车载侧和基础设施侧的LiDAR点云<strong>构建足够差异但同时保持共同语义信息的视图进行对比学习，比以往方法构建的视图更合适</strong>。( 2 )在对比目标的基础上，<strong>提出了上下文形状预测作为预训练目标，为无监督的三维点云表示学习带来了更多与任务相关的信息，有利于将学习到的表示迁移到下游的检测任务中</strong>。( 3 )与以往的方法相比，CO ( 3 )学习到的表示可以迁移到不同类型的LiDAR传感器采集的室外场景数据集上。( 4 ) CO ( 3在Once和KITTI d上都改进了当前最先进的方法</p><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>​    激光雷达作为室外环境中最可靠的传感器，能够精确地测量物体的三维位置，机器人和计算机视觉领域都对激光雷达点云的感知任务表现出强烈的兴趣，包括三维物体检测、分割和跟踪，这些任务对于自动驾驶系统至关重要。迄今为止，在详细的标注数据上从头开始随机初始化和直接训练仍然占据着该领域的主导地位。与此相反，最近图像领域的研究工作侧重于从图像构建具有不同视角对比目标的无监督表示学习</p><p>他们以无监督的方式使用ImageNet 等大规模数据集对2D骨干网络进行预训练，并使用预训练的骨干网络在不同的数据集上初始化下游神经网络，在2D目标检测中实现了从头开始训练的显著性能提升。受这些成功的启发，结合自动驾驶车辆中丰富的未    标记数据探索了室外场景点云的无监督表示学习，以提高三维目标检测任务的性能。在过去的十年中，从无标签数据中学习三维表示在单目标和室内场景点云中取得了巨大的成功。对于单个物体的点云，如CAD模型，先前的工作通过最小化对比损失来预训练3D编码器来预测全局表示，并针对包括物体分类和配准在内的低级下游任务。为了将这一思想扩展到室内场景点云的高层感知任务，Point Contrast 提出重建整个室内场景，从两个不同的姿态采集部分点云，并将其作为对比学习中的两个视图来学习稠密的(点级或三维像素水平)表示</p><p><img data-src="https://s2.loli.net/2024/09/12/Q2bxeyYMCcFtz5K.png" alt="image-20240912213954703"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/CatOneTwo/Collaborative-Perception-in-Autonomous-Driving/tree/main?tab=readme-ov-file">CatOneTwo/Collaborative-Perception-in-Autonomous-Driving: (2023 ITSM) Collaborative Perception in Autonomous Driving: Methods, Datasets and Challenges (github.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;一些稍微新一点或者之前没看到的想法还不错的协同感知论文&lt;br&gt;</summary>
    
    
    
    
    <category term="collaborative perception" scheme="https://www.sekyoro.top/tags/collaborative-perception/"/>
    
  </entry>
  
  <entry>
    <title>Rust learning:from germ to grave</title>
    <link href="https://www.sekyoro.top/2024/06/29/Rust-learning-from-germ-to-grave/"/>
    <id>https://www.sekyoro.top/2024/06/29/Rust-learning-from-germ-to-grave/</id>
    <published>2024-06-29T04:51:24.000Z</published>
    <updated>2024-08-29T12:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Rust官方推荐的三个资料,分别是The Rust programming language,Rust by examples以及ruslings,已经相当充足了.包括相对全面的书,代码例子以及方便的互动式exercises.个人觉得,the book相当于字典,虽然其实还有内容更多的reference,而examples更加易懂上手,rustlings相当于刷题,把关键东西了解一遍.</p><p>所以从这三个东西入手开始Rust学习之旅,一些地方会跟c++对比.<br><span id="more"></span></p><h3 id="宏macro"><a href="#宏macro" class="headerlink" title="宏macro"></a>宏macro</h3><p>术语宏指的是Rust中的一系列特性:带有macro_rules的声明性宏!还有三种过程宏:</p><ul><li>Custom <code>#[derive]</code> macros that specify code added with the <code>derive</code> attribute used on structs and enums</li><li>Attribute-like macros that define custom attributes usable on any item</li><li>Function-like macros that look like function calls but operate on the tokens specified as their argument</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> vec &#123;</span><br><span class="line">    ( $( $x:expr ),* ) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> temp_vec = <span class="built_in">Vec</span>::new();</span><br><span class="line">            $(</span><br><span class="line">                temp_vec.push($x);</span><br><span class="line">            )*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量binding"><a href="#变量binding" class="headerlink" title="变量binding"></a>变量binding</h3><p>知识点:</p><ol><li>不变性 Rust默认不可变,不像c++到处声明const</li><li>scope和shadowing 主要有variable shadowing,也就是可以重声明,在c++中不允许</li><li>将一个mut的值赋值给non-mut的值,在那个域内,non-mute的值也不能被改变</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Number &#123;&#125;&quot;</span>, x);</span><br><span class="line">    x = <span class="number">5</span>; </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Number &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="string">&quot;T-H-R-E-E&quot;</span>; <span class="comment">// don&#x27;t change this line</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Spell a Number : &#123;&#125;&quot;</span>, number);</span><br><span class="line">    <span class="keyword">let</span> number = <span class="number">3</span>; <span class="comment">// don&#x27;t rename this variable</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Number plus two is : &#123;&#125;&quot;</span>, number + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> _mutable_integer = <span class="number">7i32</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Shadowing by immutable `_mutable_integer`</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> _mutable_integer = _mutable_integer;</span><br><span class="line">        </span><br><span class="line">        _mutable_integer = <span class="number">50</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// `_mutable_integer` goes out of scope</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ok! `_mutable_integer` is not frozen in this scope</span></span><br><span class="line">    _mutable_integer = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="Primitives"><a href="#Primitives" class="headerlink" title="Primitives"></a>Primitives</h3><h4 id="字面量和操作符"><a href="#字面量和操作符" class="headerlink" title="字面量和操作符"></a>字面量和操作符</h4><ol><li>推荐在使用字面量是后面加上类型.</li><li>原生类型本身可以printable</li></ol><p>元组、数组与slices. </p><p>元组,通过()表示,通过.num索引,可以使用#[derive(Debug)]实现方法打印.</p><p>数组 [T;length]声明,编译时已知.</p><p>切片(Slices)与数组类似,但它们的长度在编译时是未知的。相反,切片是一个由两个字(word)组成的对象:第一个字是指向数据的指针,第二个字是切片的长度。字的大小与 <code>usize</code> 类型相同,由处理器架构决定,例如在 x86-64 上为 64 位。切片可用于借用数组的一部分,它的类型签名为 <code>&amp;[T]</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function borrows a slice.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">analyze_slice</span></span>(slice: &amp;[<span class="built_in">i32</span>]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;First element of the slice: &#123;&#125;&quot;</span>, slice[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The slice has &#123;&#125; elements&quot;</span>, slice.len());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xs: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// All elements can be initialized to the same value.</span></span><br><span class="line"><span class="keyword">let</span> ys: [<span class="built_in">i32</span>; <span class="number">500</span>] = [<span class="number">0</span>; <span class="number">500</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Borrow the whole array as a slice.&quot;</span>);</span><br><span class="line">analyze_slice(&amp;xs);</span><br></pre></td></tr></table></figure><h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><h4 id="structures"><a href="#structures" class="headerlink" title="structures"></a>structures</h4><p>使用 <code>struct</code> 关键字可以创建三种类型的结构体(struct):</p><ol><li>元组结构体(Tuple structs)，基本上是命名元组。</li><li>经典的 C 风格结构体。</li><li>无字段的单元结构体(Unit structs)，在泛型编程中很有用。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    age: <span class="built_in">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A unit struct</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Unit</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A tuple struct</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span></span>(<span class="built_in">i32</span>, <span class="built_in">f32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A struct with two fields</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">f32</span>,</span><br><span class="line">    y: <span class="built_in">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A tuple struct</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span></span>(<span class="built_in">i32</span>, <span class="built_in">f32</span>);</span><br><span class="line"><span class="comment">// Instantiate a tuple struct</span></span><br><span class="line"><span class="keyword">let</span> pair = Pair(<span class="number">1</span>, <span class="number">0.1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Access the fields of a tuple struct</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;pair contains &#123;:?&#125; and &#123;:?&#125;&quot;</span>, pair.<span class="number">0</span>, pair.<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destructure a tuple struct</span></span><br><span class="line"><span class="keyword">let</span> Pair(integer, decimal) = pair;</span><br></pre></td></tr></table></figure><h4 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a>Enums</h4><p><code>enum</code>关键字允许创建一个可以是几种不同变体(variant)之一的类型。任何在结构体(struct)中有效的变体,在枚举(enum)中也是有效的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    kind: IpAddrKind,</span><br><span class="line">    address: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V4,</span><br><span class="line">    address: <span class="built_in">String</span>::from(<span class="string">&quot;127.0.0.1&quot;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V6,</span><br><span class="line">    address: <span class="built_in">String</span>::from(<span class="string">&quot;::1&quot;</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="constants"><a href="#constants" class="headerlink" title="constants"></a>constants</h4><p>Rust 有两种不同类型的常量,可以在任何作用域(包括全局)中声明。两种常量都需要显式的类型注解:</p><ol><li><code>const</code>: 不可变的值(最常见的情况)。</li><li><code>static</code>: 可能是可变的变量,拥有 <code>&#39;static</code> 生命周期。<code>&#39;static</code> 生命周期是被推断出来的,不需要显式指定。访问或修改可变的 <code>static</code> 变量是不安全的</li></ol><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h4 id="强大的包管理系统"><a href="#强大的包管理系统" class="headerlink" title="强大的包管理系统"></a>强大的包管理系统</h4><p>一个rust项目可能是lib也可以是main,分别代表生成库和可执行程序. 注意可以既存在main.rs和lib.rs.</p><ul><li><strong>Packages:</strong> A Cargo feature that lets you build, test, and share crates</li><li><strong>Crates:</strong> A tree of modules that produces a library or executable</li><li><strong>Modules</strong> and <strong>use:</strong> Let you control the organization, scope, and privacy of paths</li><li><strong>Paths:</strong> A way of naming an item, such as a struct, function, or module</li></ul><p>crate根文件是Rust编译器启动的源文件,它构成了crate的根模块</p><p>包(Packages)是提供一组功能的一个或多个crate的集合。一个包包含一个Cargo.toml。描述如何构建这些crate的Toml文件。Cargo实际上是一个包，其中包含用于构建代码的命令行工具的二进制crate。Cargo包还包含一个二进制包所依赖的库包。其他项目可以依赖Cargo库crate来使用Cargo命令行工具使用的相同逻辑。</p><p>crate有两种形式:二进制(binary)crate或库(library )crate。二进制crate是可以编译为可运行的可执行文件的程序，例如命令行程序或服务器。每个程序都必须有一个名为main的函数，用于定义可执行程序运行时发生的情况。</p><p>library crate<strong>没有main函数</strong>，也不能编译成可执行文件。相反，它们定义了旨在与多个项目共享的功能。</p><h5 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h5><ol><li><p>从crate根目录开始:当编译一个crate时，编译器<strong>首先查找crate根文件</strong>(通常是src/lib.rs,为库crate或src/main.rs表示二进制文件)用于编译代码。</p></li><li><p>声明模块:在crate根文件中，你可以声明新的模块;假设你用mod garden;声明了一个“花园”模块。编译器将在这些地方查找模块的代码：</p><p> 内联下载mod garden之后</p><p> 在src/garden.rs文件中</p><p>在src/garden/mod.rs文件中   查找模块的规律就是同级目录同名文件或者同名子目录中的<code>mod.rs</code>文件</p></li><li><p>声明子模块:在crate根目录之外的任何文件中(除了<code>src/main/lib.rs</code>的文件中)，都可以声明子模块。例如，你可以声明mod vegetables;在<code>src/garden.rs</code>。编译器将在以下地方以父模块命名的目录中查找子模块的代码:</p><p>内联，直接跟在mod vegetables后面</p><p>在src/garden/vegetables.rs文件中</p><p>在src/garden/vegetables/mod.rs文件中     查找子模块的规律就是与文件同名子目录中的同名模块文件或者同名模块目录中的<code>mod.rs</code>文件</p></li><li><p>模块中的代码路径:一旦模块成为crate的一部分,只要隐私规则允许,就可以使用代码路径从同一crate中的任何其他地方引用该模块中的代码。例如，garden vegetables模块中的Asparagus类型可以在crate::garden::vegetables::Asparagus中找到。</p></li><li><p>私有vs.公共:默认情况下，模块内的代码对其父模块是私有的。要使一个模块为公共，请使用pub mod而不是mod声明它。要使公共模块中的项也为公共，请在声明它们之前使用pub。</p></li><li><p>use关键字:在作用域中，use关键字创建项的快捷方式，以减少长路径的重复。在任何可以引用crate::garden::vegetables::Asparagus的作用域中，你可以使用crate::garden::vegetables::Asparagus创建一个快捷方式;从那时起，你只需要编写Asparagus就可以在作用域中使用该类型。</p><p>​     注意,<code>use</code>是用于减少名称重复的,<code>pub mod</code>才是用于引入的.</p><p>使用<code>mod</code>组织代码结构,提到src/main.rs和src/lib.rs被称为crate roots.命名的原因是这两个文件的内容在crate的模块结构(称为模块树)的根位置形成了一个名为crate的模块</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">seat_at_table</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">take_order</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">serve_order</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">take_payment</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 模块树,注意</span></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">crate</span></span><br><span class="line"><span class="string"> └── front_of_house</span></span><br><span class="line"><span class="string">     ├── hosting</span></span><br><span class="line"><span class="string">     │   ├── add_to_waitlist</span></span><br><span class="line"><span class="string">     │   └── seat_at_table</span></span><br><span class="line"><span class="string">     └── serving</span></span><br><span class="line"><span class="string">         ├── take_order</span></span><br><span class="line"><span class="string">         ├── serve_order</span></span><br><span class="line"><span class="string">         └── take_payment</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><strong>Path</strong></p><p>在模块树中如何找到一个item</p><p><strong>绝对路径</strong>是从crate根目录开始的完整路径;对于来自外部crate的代码，绝对路径以crate名称开头，而对于来自当前crate的代码，它以文字crate开头。</p><p>相对路径从当前模块开始，使用当前模块中的self、super或标识符。</p></li></ol><p>父模块中的项不能使用子模块中的私有项，但子模块中的项可以使用其祖先模块中的项。这是因为子模块封装并隐藏了它们的实现细节，但是子模块可以看到它们被定义的上下文。</p><p>sibling之间可以调用模块,比如同在crate下的函数和模块,这个函数可以直接调用模块而不使用pub.</p><p><strong>相对路径</strong></p><p>使用super,self等引入.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">deliver_order</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fix_incorrect_order</span></span>() &#123;</span><br><span class="line">        cook_order();</span><br><span class="line">        super::deliver_order();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">cook_order</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意使得模块中的enum,structs,函数等pub才能访问.</p><blockquote><p>一个包可以同时包含src/main。Rs二进制crate根以及src/lib。默认情况下，两个crate都有包名。通常，具有这种既包含库又包含二进制crate模式的包在二进制crate中会有足够的代码来启动调用库crate中的代码的可执行文件。这使得其他项目可以从包提供的大部分功能中受益，因为库crate的代码可以共享</p></blockquote><p>使用<code>use</code>将paths引入作用域,要使用的话就要在同一mod作用域中.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用use将函数的父模块带入作用域意味着我们必须在调用函数时指定父模块。在调用函数时指定父模块可以清楚地表明该函数不是本地定义的，同时仍然可以最大限度地减少完整路径的重复。此外在使用struct、enum和其他项时，习惯上指定完整路径。</p><p>对于将两个具有相同名称的类型带入相同作用域的问题,除了引入父模块，还有另一种解决方案:在路径之后，可以为类型指定as和一个新的本地名称或别名。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="built_in">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">function1</span></span>() -&gt; <span class="built_in">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">function2</span></span>() -&gt; IoResult&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用use关键字将名称引入作用域时，在新作用域中可用的名称是private。为了使调用代码的代码能够引用该名称，就好像它是在该代码的作用域中定义的一样，可以组合pub和use。这种技术被称为再导出</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// restaurant  src/lib.rs</span></span><br><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在更改之前，外部代码必须通过restaurant::front_of_house::hosting::add_to_waitlist()来调用add_to_waitlist函数，这也需要将front_of_house模块标记为pub.现在外部代码可以使用restaurant::hosting::add_to_waitlist()代替。</p><p>标准std库也是一个包外部的crate。因为标准库是随Rust语言一起提供的，所以不需要更改Cargo.toml。但是需要用use来引用它，以便将其中的项引入包的作用域。</p><p>推荐模块命名不要为<code>mod.rs</code>,使用名为<code>mod.rs</code>文件的风格的主要缺点是项目最终可能会有许多名为mod.rs的文件,当同时在编辑器中打开它们时,这可能会令人困惑。</p><h3 id="使用Cargo构建大项目"><a href="#使用Cargo构建大项目" class="headerlink" title="使用Cargo构建大项目"></a>使用Cargo构建大项目</h3><h4 id="Release"><a href="#Release" class="headerlink" title="Release"></a>Release</h4><p>在debug和release构建时可以使用不同的选项,在<code>Cargo.toml</code>中</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[profile.dev]</span><br><span class="line">opt-level = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[profile.release]</span><br><span class="line">opt-level = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>Cargo有两个主要配置profiles:运行Cargo构建时使用的开发配置文件和运行Cargo构建—发布时使用的发布配置文件。运行<code>cargo build --release</code>使用<code>release</code> profile.</p><p>当没有显式地添加任何profiles时，Cargo对应用的每个profiles都有默认设置。通过添加[profile.]*]部分，自定义的任何配置文件,覆盖任何子集的默认设置。</p><p>option-level设置控制Rust将应用于代码的优化数量，范围为0到3。应用更多的优化会延长编译时间，因此，如果您正在开发并经常编译代码，那么您可能希望通过更少的优化来加快编译速度，即使结果代码运行得更慢。</p><p>因此dev的默认选项级别为0。准备发布代码时，最好花更多的时间进行编译。将只在发布模式下编译一次，但是将多次运行编译后的程序，因此发布模式以较长的编译时间换取运行速度更快的代码</p><p>使用<code>cargo publish</code>进行发布,注意需要注册crates.io账号,如果需要更新版本更改<code>version</code>再推送即可</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;guessing_game&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;A fun game where you guess what number the computer has chosen.&quot;</span></span><br><span class="line"><span class="attr">license</span> = <span class="string">&quot;MIT OR Apache-2.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure><p>使用<code>cargo yank --vers [versionNumber]</code>可以阻止使用这个项目的某个版本的依赖.</p><p>yank一个版本可以防止新项目依赖于该版本，同时允许所有依赖于该版本的现有项目继续进行。</p><h4 id="workspaces"><a href="#workspaces" class="headerlink" title="workspaces"></a>workspaces</h4><p>工作区是一组共享Cargo.lock,和输出目录的packages. 常见工作流是一个可执行文件的packages和多个生成库的packages.</p><p>在根目录下创建<code>Cargo.toml</code>,其中添加packages名字,假设根目录名字add</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[workspace]</span><br><span class="line"></span><br><span class="line">members = [</span><br><span class="line">    <span class="string">&quot;adder&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new adder</span><br></pre></td></tr></table></figure><p>目录结构如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── <span class="module-access"><span class="module"><span class="identifier">Cargo</span>.</span></span>lock</span><br><span class="line">├── <span class="module-access"><span class="module"><span class="identifier">Cargo</span>.</span></span>toml</span><br><span class="line">├── adder</span><br><span class="line">│   ├── <span class="module-access"><span class="module"><span class="identifier">Cargo</span>.</span></span>toml</span><br><span class="line">│   └── src</span><br><span class="line">│       └── main.rs</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure><p>工作区在顶层有一个目标目录，编译后的工件将被放置到该目录中;adder包没有自己的目标目录。即使要从adder目录中运行cargo构建，编译后的工件仍然会在add/target而不是add/adder/target中结束。Cargo在工作区的目标目录中采用这样的结构，因为工作区的crate是相互依赖的。</p><blockquote><p>如果每个crate都有自己的目标目录，那么每个crate都必须重新编译工作空间中的其他crate，以便将工件放置在自己的目标目录中。通过共享一个目标目录，crate可以避免不必要的重新构建。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new add_one --lib</span><br></pre></td></tr></table></figure><p>继续添加crate,加入workspace中.</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[workspace]</span></span><br><span class="line"><span class="attr">members</span> = [</span><br><span class="line">    <span class="string">&quot;adder&quot;</span>,</span><br><span class="line">    <span class="string">&quot;add_one&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>添加本地项目中的依赖</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// adder/Cargo.toml</span></span><br><span class="line">[dependencies]</span><br><span class="line">add_one = &#123; path = <span class="string">&quot;../add_one&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>在顶层目录运行<code>cargo build</code>,然后指定<code>-p</code>运行指定可执行程序<code>cargo run -p adder</code></p><p>如果要使workspace下两个crate使用同一版本同一个依赖,可以使得其中一个crate依赖另一个依赖,build之后在顶层cargo.lock中会有相关依赖信息.</p><blockquote><p>Cargo将确保工作空间中使用rand包的每个包中的每个crate都使用相同的版本，只要它们指定rand的兼容版本，就可以节省空间并确保工作空间中的crate彼此兼容</p></blockquote><p>workspace中的项目测试,在顶层目录中<code>cargo test</code>运行每个crate中的测试,使用<code>cargo test -p</code>指定,发布项目同理,<code>cargo publish -p</code>.</p><p><code>cargo install</code>命令在本地安装和使用二进制crate.</p><p>所有使用cargo install安装的二进制文件都存储在安装根目录的bin文件夹中。如果没有任何自定义配置，这个目录将是<code>$HOME/.cargo/bin</code></p><p>如果<code>$PATH</code>中的二进制文件名为<code>cargo-something</code>，则可以通过运行Cargo something来将其作为Cargo子命令运行。在运行cargo——list时会列出这样的自定义命令。</p><h4 id="cargo-fmt-clippy"><a href="#cargo-fmt-clippy" class="headerlink" title="cargo fmt/clippy"></a>cargo fmt/clippy</h4><p>分别用于格式化和语法提示</p><h4 id="cargo-doc"><a href="#cargo-doc" class="headerlink" title="cargo doc"></a>cargo doc</h4><p>非常方便的生成文档的工具</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo doc --no-deps --open</span><br></pre></td></tr></table></figure><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p>单元测试 集成测试 benchmarks</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo <span class="built_in">test</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> test&#123;</span><br><span class="line"><span class="keyword">use</span> super::*;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line">    func()&#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外也有doc-test,用于测试文档中的代码.尝试使用<code>criterion</code><a href="https://bheisler.github.io/criterion.rs/book/index.html">Criterion.rs - Criterion.rs Documentation (bheisler.github.io)</a>进行benchmark测试.</p><h4 id="log"><a href="#log" class="headerlink" title="log"></a>log</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> log::&#123;error,warn,info,debug,trace&#125;;</span><br><span class="line">error!();</span><br><span class="line">warn!();</span><br><span class="line">info!();</span><br><span class="line">debug!();</span><br><span class="line">trace!();</span><br></pre></td></tr></table></figure><h3 id="dyn"><a href="#dyn" class="headerlink" title="dyn"></a>dyn</h3><p>Rust 编译器需要知道每个函数的返回类型需要多少空间。这意味着所有函数都必须返回一个具体类型。与其他语言不同，如果你有个像 <code>Animal</code> 那样的的 trait，则不能编写返回 <code>Animal</code> 的函数，因为其不同的实现将需要不同的内存量。</p><p>但是，<strong>有一个简单的解决方法。相比于直接返回一个 trait 对象，我们的函数返回一个包含一些 <code>Animal</code> 的 <code>Box</code></strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">walk</span></span> &#123;</span><br><span class="line"> <span class="function"><span class="keyword">fn</span> <span class="title">xx</span></span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">a</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> walk <span class="keyword">for</span> a &#123;</span><br><span class="line"> <span class="function"><span class="keyword">fn</span> <span class="title">xx</span></span>()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> walk <span class="keyword">for</span> b &#123;</span><br><span class="line"> <span class="function"><span class="keyword">fn</span> <span class="title">xx</span></span>()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line"><span class="keyword">let</span> t = <span class="built_in">vec!</span>[<span class="built_in">Box</span>::new(a&#123;]&#125;),<span class="built_in">Box</span>::new(b&#123;&#125;)]; <span class="comment">// Box&lt;dyn walk&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>box</code> 只是对堆中某些内存的引用。因为引用的大小是静态已知的，并且编译器可以保证引用指向已分配的堆 <code>Animal</code>，所以可以从函数中返回 trait.</p><p>每当在堆上分配内存时，Rust 都会尝试尽可能明确。因此，如果<strong>函数以这种方式返回指向堆的 trait 指针，则需要使用 <code>dyn</code> 关键字编写返回类型</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sheep</span></span> &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cow</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Animal</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实例方法签名</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">noise</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 `Sheep` 的 `Animal` trait。</span></span><br><span class="line"><span class="keyword">impl</span> Animal <span class="keyword">for</span> Sheep &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">noise</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span> &#123;</span><br><span class="line">        <span class="string">&quot;baaaaah!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 `Cow` 的 `Animal` trait。</span></span><br><span class="line"><span class="keyword">impl</span> Animal <span class="keyword">for</span> Cow &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">noise</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span> &#123;</span><br><span class="line">        <span class="string">&quot;moooooo!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一些实现 Animal 的结构体，但是在编译时我们不知道哪个结构体。</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">random_animal</span></span>(random_number: <span class="built_in">f64</span>) -&gt; <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Animal&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> random_number &lt; <span class="number">0.5</span> &#123;</span><br><span class="line">        <span class="built_in">Box</span>::new(Sheep &#123;&#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Box</span>::new(Cow &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> random_number = <span class="number">0.234</span>;</span><br><span class="line">    <span class="keyword">let</span> animal = random_animal(random_number);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;You&#x27;ve randomly chosen an animal, and it says &#123;&#125;&quot;</span>, animal.noise());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>与C++类似,rust也使用了一套机制保证内存安全. 智能指针相比于借用(引用)来说,其在大多数情况下拥有所有权.</p><p>常用智能指针类型如下</p><ul><li><code>Box&lt;T&gt;</code> for allocating values on the heap</li><li><code>Rc&lt;T&gt;</code>, a reference counting type that enables multiple ownership</li><li><p><code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code>, accessed through <code>RefCell&lt;T&gt;</code>, a type that enforces the borrowing rules at runtime instead of compile time</p></li><li><p><strong>RefCell</strong>：智能指针，允许运行时动态获取可变引用，跟踪借用以保证安全性</p></li><li><strong>Arc</strong>:线程安全的reference counting type</li></ul><p>此外,有<strong>Ref</strong>:用于在不可变借用的情况下安全地访问数据和<strong>Cell</strong>分别用来安全访问数据.</p><h4 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, <span class="built_in">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> list = Cons(<span class="number">1</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">2</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">3</span>, <span class="built_in">Box</span>::new(Nil))))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Rc"><a href="#Rc" class="headerlink" title="Rc"></a>Rc</h4><p>你必须通过使用Rust类型Rc\<T>显式地启用多重所有权，Rc\<T>是引用计数的缩写。Rc\<T>类型跟踪对一个值的引用次数，以确定该值是否仍在使用。如果对一个值的引用为零，则可以清除该值，而不会导致任何引用无效。</p><p>当<strong>想要在堆上分配一些数据供程序的多个部分读取,并且在编译时无法确定哪个部分将最后使用该数据时</strong>,使用Rc\<T>类型。<strong>如果知道哪一部分将最后完成,就可以将该部分设置为数据的所有者,并且在编译时强制执行的正常所有权规则将生效。</strong></p><p>注意，<strong>Rc\<T>仅用于单线程场景</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust中，<code>Cell</code> 是标准库中的一个类型，它提供了一种在可变引用的限制下安全地更新数据的方法。<code>Cell</code> 是一个非线程安全的类型，主要用于单线程环境下的可变状态管理。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::Cell;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个 Cell</span></span><br><span class="line">    <span class="keyword">let</span> count = Cell::new(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 get() 获取值</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Initial value: &#123;&#125;&quot;</span>, count.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 set() 修改值</span></span><br><span class="line">    count.set(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;New value: &#123;&#125;&quot;</span>, count.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与Rc\<T>不同，RefCell\<T>类型表示它所持有的数据的单一所有权.</p><p>通过引用和Box\<T>，借用规则的不变量在编译时强制执行。使用RefCell\<T>，这些<strong>不变量在运行时强制执行</strong>。对于引用，如果违反了这些规则，就会出现编译器错误。对于RefCell\<T>，如果你违反了这些规则，你的程序就会panic并退出。</p><blockquote><p>在编译时检查借用规则的优点是，在开发过程中可以更快地捕获错误，并且不会对运行时性能产生影响，因为所有的分析都是事先完成的。由于这些原因，在大多数情况下，在编译时检查借用规则是最好的选择，这就是为什么这是Rust的默认值。</p><p>在运行时检查借阅规则的优点是，在编译时检查不允许的情况下，允许某些内存安全的场景。静态分析和Rust编译器一样，本质上是保守的。代码的一些属性是不可能通过分析代码来检测的</p></blockquote><p>与Rc\<T>类似，RefCell\<T>仅用于单线程场景，如果您尝试在多线程上下文中使用它，则会给您一个编译时错误。(尝试使用Mutex以及Arc)</p><h4 id="Arc"><a href="#Arc" class="headerlink" title="Arc"></a>Arc</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = Arc::clone(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Weak"><a href="#Weak" class="headerlink" title="Weak"></a>Weak</h4><p>同c++中的weak_ptr,避免循环引用.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,</span><br><span class="line">    children: RefCell&lt;<span class="built_in">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> leaf = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::new(Weak::new()),</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.borrow().upgrade());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> branch = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        parent: RefCell::new(Weak::new()),</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[Rc::clone(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.borrow().upgrade());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell"></a>RefCell</h4><p>Rc\<T>允许同一数据的多个所有者;Box\<T>和RefCell\<T>具有单个所有者。</p><p>Box\<T>允许在编译时检查不可变或可变借用(意味着只有单一读取和修改者,同时也是owner);Rc\<T>只允许在编译时不可变借用(相当于可以有多个可读,不能更改值,可以考虑搭配RefCell修改);</p><p>RefCell\<T>允许在运行时检查不可变或可变的借用。因为RefCell\<T>允许在运行时检查可变借用，所以即使RefCell\<T>是不可变的，你也可以改变RefCell\<T>中的值。</p><blockquote><p>内部可变性是Rust中的一种设计模式，它允许你改变数据，即使数据有不可变的引用;</p><p>这就是使用RefCell的目的.</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Messenger</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, msg: &amp;<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">LimitTracker</span></span>&lt;<span class="symbol">&#x27;a</span>, T: Messenger&gt; &#123;</span><br><span class="line">    messenger: &amp;<span class="symbol">&#x27;a</span> T,</span><br><span class="line">    value: <span class="built_in">usize</span>,</span><br><span class="line">    max: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; LimitTracker&lt;<span class="symbol">&#x27;a</span>, T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Messenger,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(messenger: &amp;<span class="symbol">&#x27;a</span> T, max: <span class="built_in">usize</span>) -&gt; LimitTracker&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">        LimitTracker &#123;</span><br><span class="line">            messenger,</span><br><span class="line">            value: <span class="number">0</span>,</span><br><span class="line">            max,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_value</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> percentage_of_max = <span class="keyword">self</span>.value <span class="keyword">as</span> <span class="built_in">f64</span> / <span class="keyword">self</span>.max <span class="keyword">as</span> <span class="built_in">f64</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">1.0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger.send(<span class="string">&quot;Error: You are over your quota!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.9</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger</span><br><span class="line">                .send(<span class="string">&quot;Urgent warning: You&#x27;ve used up over 90% of your quota!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.75</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger</span><br><span class="line">                .send(<span class="string">&quot;Warning: You&#x27;ve used up over 75% of your quota!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MockMessenger</span></span> &#123;</span><br><span class="line">        sent_messages: RefCell&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123;</span><br><span class="line">                sent_messages: RefCell::new(<span class="built_in">vec!</span>[]),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Messenger <span class="keyword">for</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sent_messages.borrow_mut().push(<span class="built_in">String</span>::from(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_sends_an_over_75_percent_warning_message</span></span>() &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.borrow().len(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用RefCell\<T>的常见方法是与Rc\<T>结合使用。回想一下，Rc\<T>允许您拥有某些数据的多个所有者，但它只提供对该数据的不可变访问。如果你有一个Rc\<T>持有一个RefCell\<T>，可以得到一个值，可以有多个所有者，你可以改变</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在有多个owner情况下修改数据 使用Rc和RefCell</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(Rc&lt;RefCell&lt;<span class="built_in">i32</span>&gt;&gt;, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = Rc::new(RefCell::new(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> b = Cons(Rc::new(RefCell::new(<span class="number">3</span>)), Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(Rc::new(RefCell::new(<span class="number">4</span>)), Rc::clone(&amp;a));</span><br><span class="line"></span><br><span class="line">    *value.borrow_mut() += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a after = &#123;a:?&#125;&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b after = &#123;b:?&#125;&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c after = &#123;c:?&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下,没有特别情况可以使用Box,类似于c++中unique_ptr,Rc类似于shared_ptr.</p><p>Arc和Mutex用于多线程情况. RefCell本身是运行时改变借用可变性,在一些情况下可以使用.</p><h4 id="Trait-对比Concept-in-C-20"><a href="#Trait-对比Concept-in-C-20" class="headerlink" title="Trait 对比Concept in C++20"></a>Trait 对比Concept in C++20</h4><p>Rust中trait与泛型结合很好,同时由于Rust没有类的继承,可以考虑使用泛型继承和组合实现类似效果. 可以<strong>使用<code>:</code>以及where和<code>+</code>搭配可以对trait的继承以及对泛型的限制进行描述</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> train walk &#123;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">xxx</span></span>();</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">yy</span></span>()&#123;<span class="built_in">println!</span>(<span class="string">&quot;&quot;</span>)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">zzz</span></span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">run</span></span>:walk &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">ttt</span></span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">func</span></span>(s:<span class="keyword">dyn</span> run)&#123;&#125;</span><br><span class="line"><span class="comment">// 限制结构的泛型</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Hi</span></span>&lt;T:run&gt; &#123;</span><br><span class="line">  T:value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现结构的trait</span></span><br><span class="line"><span class="keyword">impl</span> walk <span class="keyword">for</span> Hi&lt;T&gt; <span class="keyword">where</span> T:walk &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外trait也可以写泛型(这在c++中往往是常见行为). trait在继承时使用<code>:</code>和<code>+</code>,在泛型使用时使用<code>:</code>或<code>where</code>,<code>+</code>.</p><p>在c++中concept更偏向于限制泛型,而rust中trait还有接口的含义(通过实现接口而不是继承满足要求).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> integral = std::is_integral&lt;T&gt;::value;</span><br></pre></td></tr></table></figure><p>声明concept如上,此外可以使用<code>&amp;&amp;</code>搭配,还可以使用requires</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Addable = <span class="built_in"><span class="keyword">requires</span></span>(T a, T b) &#123; a + b; &#125;;  <span class="comment">// a + b 可通过编译即可</span></span><br></pre></td></tr></table></figure><ol><li><code>requires &#123; requirement-seq &#125;</code></li><li><code>requires ( parameter-list(optional) ) &#123; requirement-seq &#125;</code></li></ol><p><code>requirements-seq</code> 可以是：简单要求、类型要求、复合要求、嵌套要求.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">concept</span> Check = <span class="built_in"><span class="keyword">requires</span></span>(T a, T b) &#123;</span><br><span class="line">    &#123; a.<span class="built_in">clear</span>() &#125; <span class="keyword">noexcept</span>;  <span class="comment">// 支持clear,且不抛异常</span></span><br><span class="line">    &#123; a + b &#125; <span class="keyword">noexcept</span>-&gt;std::same_as&lt;<span class="keyword">int</span>&gt;;  <span class="comment">// std::same_as&lt;decltype((a + b)), int&gt;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> C =</span><br><span class="line">    <span class="built_in"><span class="keyword">requires</span></span>(T x) &#123;</span><br><span class="line">    &#123;*x&#125;;                                 <span class="comment">// *x有意义</span></span><br><span class="line">    &#123; x + <span class="number">1</span> &#125; -&gt; std::same_as&lt;<span class="keyword">int</span>&gt;;       <span class="comment">// x + 1有意义且std::same_as&lt;decltype((x + 1)), int&gt;，即x+1是int类型</span></span><br><span class="line">    &#123; x * <span class="number">1</span> &#125; -&gt; std::convertible_to&lt;T&gt;;  <span class="comment">// x * 1 有意义且std::convertible_to&lt; decltype((x *1),T&gt;，即x*1可转变为T类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">concept</span> Check = <span class="built_in"><span class="keyword">requires</span></span>(T a, T b) &#123;</span><br><span class="line">    <span class="keyword">requires</span> std::same_as&lt;<span class="keyword">decltype</span>((a + b)), <span class="keyword">int</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">concept</span> Check = <span class="built_in"><span class="keyword">requires</span></span>(T a, T b) &#123;</span><br><span class="line">    &#123; a + b &#125; -&gt; std::same_as&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而使用concept如下,使用和定义concept时都可以使用requires和&amp;&amp;.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">requires</span> integral&lt;T&gt; </span></span><br><span class="line"><span class="function">T <span class="title">inc</span><span class="params">(T a)</span> </span>&#123; <span class="keyword">return</span> ++a; &#125; <span class="comment">// 个人推荐</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">inc</span><span class="params">(T a)</span> <span class="keyword">requires</span> integral&lt;T&gt; </span>&#123; <span class="keyword">return</span> ++a; &#125; <span class="comment">//</span></span><br><span class="line"><span class="keyword">template</span> &lt;integral T&gt;</span><br><span class="line"><span class="function">T <span class="title">inc</span><span class="params">(T&amp; a)</span> </span>&#123; <span class="keyword">return</span> ++a; &#125; <span class="comment">//</span></span><br><span class="line"><span class="function">integral <span class="keyword">auto</span> <span class="title">inc</span><span class="params">(integral <span class="keyword">auto</span> a)</span> </span>&#123; <span class="keyword">return</span> ++a; &#125; <span class="comment">// 泛型函数 使用concept限制</span></span><br></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>作为偏底层的编程语言,c/c++,rust,zig等目前都还在发展,即使c++已过五十年,但C++2a中Concepts,Modules,Coroutines(协程)等新特性都不断出现(虽然在其他语言中早就有了),所以还是地位仍在的.而后两者在前端工具构建上均大显身手,期待后续发展.</p><p>我也很喜欢使用C/C++,Go,Rust等写一些小程序demo.</p><h3 id="FYI"><a href="#FYI" class="headerlink" title="FYI"></a>FYI</h3><p>一些语言高级特性</p><ol><li><a href="https://draveness.me/metaprogramming/">谈元编程与表达能力 - 面向信仰编程 (draveness.me)</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/tuna/tunight/2020-04-25-generics-and-metaprogramming/slides.pdf">从泛型 (Generics) 到元编程 (Metaprogramming) (tsinghua.edu.cn)</a></li></ol><p><img data-src="https://s2.loli.net/2024/06/29/5tfZJquDxgvKros.png" alt="image-20240629202803323"></p><p><img data-src="https://s2.loli.net/2024/06/29/gZaJPSIc5sdzM91.png" alt="image-20240629202943879"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust官方推荐的三个资料,分别是The Rust programming language,Rust by examples以及ruslings,已经相当充足了.包括相对全面的书,代码例子以及方便的互动式exercises.个人觉得,the book相当于字典,虽然其实还有内容更多的reference,而examples更加易懂上手,rustlings相当于刷题,把关键东西了解一遍.&lt;/p&gt;
&lt;p&gt;所以从这三个东西入手开始Rust学习之旅,一些地方会跟c++对比.&lt;br&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://www.sekyoro.top/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>不同编程语言之间的互操作</title>
    <link href="https://www.sekyoro.top/2024/06/25/%E4%B8%8D%E5%90%8C%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%92%E6%93%8D%E4%BD%9C/"/>
    <id>https://www.sekyoro.top/2024/06/25/%E4%B8%8D%E5%90%8C%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%92%E6%93%8D%E4%BD%9C/</id>
    <published>2024-06-25T02:55:48.000Z</published>
    <updated>2024-06-26T14:30:06.066Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>当项目比较大涉及到多门编程语言时会有这种需求.通常是要求调用C/C++等.<br>某些语言之间相对来说调用就比较简单,比如Go和C,Rust和C等.但是其他语言相对来说就麻烦了.本文主要涉及Python,JS,Java和C/C+的互相调用,以备不时之需.</p><p>TL;DR:Python使用pybind11,JS使用emcc,Java使用JNI.<br><span id="more"></span></p><h2 id="Python和C或Cpp"><a href="#Python和C或Cpp" class="headerlink" title="Python和C或Cpp"></a>Python和C或Cpp</h2><h3 id="Python调用C-Cpp"><a href="#Python调用C-Cpp" class="headerlink" title="Python调用C/Cpp"></a>Python调用C/Cpp</h3><h4 id="Ctypes"><a href="#Ctypes" class="headerlink" title="Ctypes"></a>Ctypes</h4><p>ctypes 是Python的外部函数库。它提供了与 C语言兼容的数据类型，并允许调用 DLL 或共享库中的函数。可使用该模块以纯 Python 形式对这些库进行封装</p><p>写一个c文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a*a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成动态库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc func.c -fPIC -shared -std=c99 -o func.so</span><br></pre></td></tr></table></figure><blockquote><p>-fPIC 作用于编译阶段，告诉编译器产生<strong>与位置无关代码</strong>(Position-Independent Code)，则产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。</p></blockquote><p>得到动态库后就能直接调用了,注意在windows上(其实指的是使用MSVC生成dll)需要使用<code>ctypes.WinDLL</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> cdll</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    f = cdll.LoadLibrary(<span class="string">&quot;./func.so&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(f.func(<span class="number">99</span>))</span><br></pre></td></tr></table></figure><p>这种方法缺点是是能调用一些已有的动态库,且不涉及复杂数据结构,只能是c语言.</p><h4 id="C-C-扩展Python"><a href="#C-C-扩展Python" class="headerlink" title="C/C++扩展Python"></a>C/C++扩展Python</h4><p>使用<code>Python.h</code>头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PY_MAJOR_VERSION &gt;= 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyInt_Check PyLong_Check</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyInt_AsLong PyLong_AsLong</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyObject* <span class="title">list_sum</span><span class="params">(PyObject *self, PyObject *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PyObject *pList;</span><br><span class="line">    PyObject *pItem;</span><br><span class="line">    Py_ssize_t n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!PyArg_ParseTuple(args, <span class="string">&quot;O!&quot;</span>, &amp;PyList_Type, &amp;pList))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n = PyList_Size(pList);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        pItem = PyList_GetItem(pList, i);</span><br><span class="line">        <span class="keyword">if</span>(!PyInt_Check(pItem)) &#123;</span><br><span class="line">            PyErr_SetString(PyExc_TypeError, <span class="string">&quot;list items must be integers.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result += PyInt_AsLong(pItem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Py_BuildValue(<span class="string">&quot;i&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">   &#123; <span class="string">&quot;sum&quot;</span>, (PyCFunction)list_sum, METH_VARARGS, <span class="string">&quot;sum method&quot;</span> &#125;,</span><br><span class="line">   &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef</span> <span class="title">python_api_sum_module</span> =</span> &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;python_api_sum&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Python interface for the array sum&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">PyMODINIT_FUNC <span class="title">PyInit_python_api_sum</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> PyModule_Create(&amp;python_api_sum_module);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3/extending/extending.html">1. 使用 C 或 C++ 扩展 Python — Python 3.12.4 文档</a></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -shared  -std=c99 -fPIC <span class="constructor">$(<span class="params">python3</span>-<span class="params">config</span> --<span class="params">includes</span>)</span> <span class="constructor">$(<span class="params">python3</span>-<span class="params">config</span> --<span class="params">ldflags</span>)</span> test.c -o test<span class="constructor">$(<span class="params">python3</span>-<span class="params">config</span> --<span class="params">extension</span>-<span class="params">suffix</span>)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在windows上推荐使用msys2工具下载Mingw工具链,</p><h4 id="pybind11"><a href="#pybind11" class="headerlink" title="pybind11"></a>pybind11</h4><p>这是最简单的方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pybind11</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pybind11/pybind11.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PYBIND11_MODULE(example, m) &#123;</span><br><span class="line">    m.doc() = <span class="string">&quot;pybind11 example plugin&quot;</span>; <span class="comment">// optional module docstring</span></span><br><span class="line"></span><br><span class="line">    m.def(<span class="string">&quot;add&quot;</span>, &amp;add, <span class="string">&quot;A function that adds two numbers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种方式注意gcc与python版本问题,两者都需要通过gcc/g++访问其下的python的include和lib目录. 我在windows上Mingw的python版本太低,比如<code>--extension-suffix</code>总是报错,我建议直接在Linux上写.</p><h3 id="C-Cpp调用Python"><a href="#C-Cpp调用Python" class="headerlink" title="C/Cpp调用Python"></a>C/Cpp调用Python</h3><h4 id="C-C-扩展Python-1"><a href="#C-C-扩展Python-1" class="headerlink" title="C/C++扩展Python"></a>C/C++扩展Python</h4><p>类似上面的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;Python.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, char *argv[]) &#123;</span><br><span class="line">  // 初始化python解释器.C/C++中调用Python之前必须先初始化解释器</span><br><span class="line">  Py_Initialize();</span><br><span class="line">  // 执行一个简单的执行python脚本命令</span><br><span class="line">  PyRun_SimpleString(<span class="string">&quot;print(&#x27;hello world&#x27;)\n&quot;</span>);</span><br><span class="line">  PyRun_SimpleString(<span class="string">&quot;import sys&quot;</span>);</span><br><span class="line">  PyRun_SimpleString(<span class="string">&quot;sys.path.append(&#x27;.&#x27;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  PyObject* pModule = PyImport_ImportModule(<span class="string">&quot;sum&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>( pModule == NULL )&#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;module not found&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    // <span class="number">4</span>、调用函数</span><br><span class="line">    PyObject* pFunc = PyObject_GetAttrString(pModule, <span class="string">&quot;say&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>( !pFunc || !PyCallable_Check(pFunc))&#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;not found function add_num&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    // </span><br><span class="line">    PyObject_CallObject(pFunc, NULL);</span><br><span class="line">  // 撤销Py_Initialize()和随后使用Python/C API函数进行的所有初始化</span><br><span class="line">  Py_Finalize();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Pybind"><a href="#Pybind" class="headerlink" title="Pybind"></a>Pybind</h4><p>同上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pybind11/pybind11.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pybind11/stl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pybind11/embed.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> py = pybind11;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  py::scoped_interpreter guard&#123;&#125;; </span><br><span class="line">  py::object sum = py::module_::<span class="built_in"><span class="keyword">import</span></span>(<span class="string">&quot;sum&quot;</span>);</span><br><span class="line">  py::object py_list_sum = sum.<span class="built_in">attr</span>(<span class="string">&quot;py_list_sum&quot;</span>);</span><br><span class="line">  <span class="keyword">int</span> result = <span class="built_in">py_list_sum</span>(std::vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;).cast&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;py_list_sum([1,2,3,4,5]) result:&quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>事实上还有更多方式,不过上面的已经足够了,详细的可以看看其他教程.</p><p><a href="https://www.hbblog.cn/python%26C%2B%2B/python和C的交互/#32-pybind11python">一文总结Python和C/C++的交互方式 - 海滨的Blog (hbblog.cn)</a></p><p><a href="https://python3-cookbook-personal.readthedocs.io/zh-cn/latest/chapters/p15_c_extensions.html">第十五章：C语言扩展 — python3-cookbook 2.0.0 文档 (python3-cookbook-personal.readthedocs.io)</a></p><p>这里推荐pybind的方法,相对功能更强,使用也不复杂.</p><h2 id="JavaScript和C或Cpp"><a href="#JavaScript和C或Cpp" class="headerlink" title="JavaScript和C或Cpp"></a>JavaScript和C或Cpp</h2><h3 id="Js调用C-Cpp"><a href="#Js调用C-Cpp" class="headerlink" title="Js调用C/Cpp"></a>Js调用C/Cpp</h3><h4 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h4><p>对于浏览器端,这应该是最通用的方式了.使用Emscripten,将源代码转为assembly格式通过浏览器调用.但是需要浏览器支持. </p><p><a href="https://developer.mozilla.org/en-US/docs/WebAssembly/C_to_Wasm">Compiling a New C/C++ Module to WebAssembly - WebAssembly | MDN (mozilla.org)</a></p><p>按照官网方式下载安装,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emcc hello.c -s WASM=1 -o hello.html</span><br></pre></td></tr></table></figure><ul><li><code>-s WASM=1</code> — 指定我们想要的 wasm 输出形式。最新版emcc默认为1,0表示输出asm.js</li><li><code>-o hello.html</code> — 指定这个选项将会生成 HTML 页面来运行我们的代码，并且会生成 wasm 模块，以及编译和实例化 wasm 模块所需要的“胶水”js 代码，这样我们就可以直接在 web 环境中使用了。</li></ul><p>这个时候在你的源码文件夹应该有下列文件：</p><ul><li><code>hello.wasm</code> 二进制的 wasm 模块代码</li><li><code>hello.js</code> 一个包含了用来在原生 C 函数和 JavaScript/wasm 之间转换的胶水代码的 JavaScript 文件</li><li><code>hello.html</code> 一个用来加载，编译，实例化你的 wasm 代码并且将它输出在浏览器显示上的一个 HTML 文件</li></ul><p>使用一个支持 WebAssembly 的浏览器，加载生成的 <code>hello.html</code>。自从 Firefox 版本 52、Chrome 版本 57 和 Opera 版本 44 开始，已经默认启用了 WebAssembly(注意不是通过文件方式打开)</p><p>上面是在html加载后会调用main函数中的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;emscripten/emscripten.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> EMSCRIPTEN_KEEPALIVE <span class="title">myFunction</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;我的函数已被调用\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emcc -o hello3.html hello3.c -O3 -s WASM=1 -s <span class="string">&quot;EXPORTED_RUNTIME_METHODS=[&#x27;ccall&#x27;]&quot;</span> --shell-file html_template/shell_minimal.html</span><br></pre></td></tr></table></figure><p>如果要导入函数,通过设置EXPORTED_RUNTIME_METHODS导出ccall,而ccall会在 JS 代码之中调用 C 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&lt;button class=&quot;mybutton&quot;&gt;运行我的函数&lt;/button&gt; //html</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;.mybutton&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;检查控制台&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> result = Module.ccall(</span><br><span class="line">    <span class="string">&quot;myFunction&quot;</span>, <span class="comment">// name of C function</span></span><br><span class="line">    <span class="literal">null</span>, <span class="comment">// return type</span></span><br><span class="line">    <span class="literal">null</span>, <span class="comment">// argument types</span></span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">  ); <span class="comment">// arguments</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="https://ruanyifeng.com/blog/2017/09/asmjs_emscripten.html">asm.js 和 Emscripten 入门教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p>emcc既支持asm.js也支持WASM,两者都能实现类似的效果,不过目前还是WASM风头正劲</p><h4 id="c-addons"><a href="#c-addons" class="headerlink" title="c++ addons"></a>c++ addons</h4><p><a href="https://nodejs.org/docs/v20.15.0/api/addons.html#c-addons">C++ addons | Node.js v20.15.0 Documentation (nodejs.org)</a></p><p>使用<code>node.h</code>头文件并下载node-gyp编译得到动态库,再通过node调用.</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> demo &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> v8::FunctionCallbackInfo;</span><br><span class="line"><span class="keyword">using</span> v8::Isolate;</span><br><span class="line"><span class="keyword">using</span> v8::Local;</span><br><span class="line"><span class="keyword">using</span> v8::Object;</span><br><span class="line"><span class="keyword">using</span> v8::<span class="keyword">String</span>;</span><br><span class="line"><span class="keyword">using</span> v8::Value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method</span><span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">  Isolate* isolate = args.<span class="built_in">GetIsolate</span>();</span><br><span class="line">  args.<span class="built_in">GetReturnValue</span>().<span class="built_in">Set</span>(<span class="keyword">String</span>::<span class="built_in">NewFromUtf8</span>(</span><br><span class="line">      isolate, <span class="string">&quot;world&quot;</span>).<span class="built_in">ToLocalChecked</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(Local&lt;Object&gt; exports)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">NODE_SET_METHOD</span>(exports, <span class="string">&quot;hello&quot;</span>, Method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NODE_MODULE</span>(NODE_GYP_MODULE_NAME, Initialize)</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace demo</span></span><br></pre></td></tr></table></figure><p>这个也要注意使用的编译器,我在windows上默认使用visual studio,需要后缀.cpp.</p><p>创建binding.gyp,然后使用node-gyp</p><figure class="highlight gyp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;targets&#x27;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&#x27;target_name&#x27;</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;sources&#x27;</span>: [ </span><br><span class="line">                <span class="string">&#x27;src/hello.cc&#x27;</span>,</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node-gyp configure</span><br><span class="line">node-gyp build</span><br></pre></td></tr></table></figure><p>编译后得到.node文件使用js调用即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">&#x27;./build/Release/addon.node&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">&#x27;./build/Debug/addon.node&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Native-abstractions-for-Node-js"><a href="#Native-abstractions-for-Node-js" class="headerlink" title="Native abstractions for Node.js"></a>Native abstractions for Node.js</h4><p>Node-API 是用于构建native addons的 API。它<strong>独立于底层 JavaScript 运行时</strong>（如 V8），并作为 Node.js 自身的一部分进行维护。该 API 在不同版本的 Node.js 中具有稳定的应用二进制接口 (ABI)<strong>。其目的是使附加组件不受底层 JavaScript 引擎变化的影响</strong>，并允许为某一版本编译的模块无需重新编译即可在以后版本的 Node.js 上运行。addons使用node-gyp 等构建/打包。</p><p><a href="https://nodejs.org/docs/v20.15.0/api/addons.html#native-abstractions-for-nodejs">C++ addons | Node.js v20.15.0 Documentation (nodejs.org)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.cc using Node-API</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node_api.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> demo &#123;</span><br><span class="line"></span><br><span class="line"><span class="function">napi_value <span class="title">Method</span><span class="params">(napi_env env, napi_callback_info args)</span> </span>&#123;</span><br><span class="line">  napi_value greeting;</span><br><span class="line">  napi_status status;</span><br><span class="line"></span><br><span class="line">  status = <span class="built_in">napi_create_string_utf8</span>(env, <span class="string">&quot;world&quot;</span>, NAPI_AUTO_LENGTH, &amp;greeting);</span><br><span class="line">  <span class="keyword">if</span> (status != napi_ok) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> greeting;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">napi_value <span class="title">init</span><span class="params">(napi_env env, napi_value exports)</span> </span>&#123;</span><br><span class="line">  napi_status status;</span><br><span class="line">  napi_value fn;</span><br><span class="line"></span><br><span class="line">  status = <span class="built_in">napi_create_function</span>(env, <span class="literal">nullptr</span>, <span class="number">0</span>, Method, <span class="literal">nullptr</span>, &amp;fn);</span><br><span class="line">  <span class="keyword">if</span> (status != napi_ok) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  status = <span class="built_in">napi_set_named_property</span>(env, exports, <span class="string">&quot;hello&quot;</span>, fn);</span><br><span class="line">  <span class="keyword">if</span> (status != napi_ok) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> exports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NAPI_MODULE</span>(NODE_GYP_MODULE_NAME, init)</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace demo</span></span><br></pre></td></tr></table></figure><p>好处是兼容性更高,api看起来也更易懂.</p><h3 id="C-Cpp调用Js"><a href="#C-Cpp调用Js" class="headerlink" title="C/Cpp调用Js"></a>C/Cpp调用Js</h3><h4 id="C-addons"><a href="#C-addons" class="headerlink" title="C addons"></a>C addons</h4><p>同上,可以考虑使用回调等方法在c中调用js.</p><p><a href="https://ruanyifeng.com/blog/2017/09/asmjs_emscripten.html">asm.js 和 Emscripten 入门教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p>如果是node那就按照官方文档使用addons(事实上也可以使用Emscripte转为asm.js进行调用),如果是浏览器,那推荐使用WASM,除能转换c/c++之外还有Rust等,在前端也是有前景的技术之一.<a href="https://developer.mozilla.org/zh-CN/docs/WebAssembly/C_to_Wasm#编译_emscripten">Emscripten</a></p><p>通过asm.js调用c++代码,方法类似,目前emcc的WASM默认为1也就是默认生成WASM,但使用时通过下面命令得到asm.js</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emcc index.cpp -s <span class="string">&quot;EXPORTED_FUNCTIONS=[‘_main’,&#x27;_myFunction&#x27;]&quot;</span> -s WASM=0 -s EXPORTED_RUNTIME_METHODS=<span class="string">&quot;[&#x27;ccall&#x27;]&quot;</span> -o index.js</span><br></pre></td></tr></table></figure><p>在js文件中调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">&quot;./output.js&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> resulst = <span class="built_in">module</span>.onRuntimeInitialized(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">module</span>.ccall(<span class="string">&#x27;myFunction&#x27;</span>,&#123;</span><br><span class="line"><span class="literal">null</span>, <span class="comment">// return type</span></span><br><span class="line"><span class="literal">null</span>, <span class="comment">// argument type</span></span><br><span class="line"><span class="literal">null</span>, <span class="comment">// arguments</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>asm.js 的技术能将 C / C++ 转成 JS 引擎可以运行的代码。那么它与 WASM有何区别呢？</p><p>回答是，两者的功能基本一致，就是转出来的代码不一样<strong>：asm.js 是文本，WebAssembly 是二进制字节码</strong>，因此运行速度更快、体积更小。从长远来看，WebAssembly 的前景更光明。</p><p>但是，这并不意味着 asm.js 肯定会被淘汰，因为它有两个优点：首先，它是文本，人类可读，比较直观；其次，所有浏览器都支持 asm.js，不会有兼容性问题。</p></blockquote><h2 id="Java和C或Cpp"><a href="#Java和C或Cpp" class="headerlink" title="Java和C或Cpp"></a>Java和C或Cpp</h2><p>Java调用C/Cpp有多种方式,这里只介绍一种.</p><p>JNI,通过native声明</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package org.example;</span><br><span class="line"><span class="comment">//TIP To &lt;b&gt;Run&lt;/b&gt; code, press &lt;shortcut actionId=&quot;Run&quot;/&gt; or</span></span><br><span class="line"><span class="comment">// click the &lt;icon src=&quot;AllIcons.Actions.Execute&quot;/&gt; icon in the gutter.</span></span><br><span class="line">public <span class="keyword">class</span> Main &#123;</span><br><span class="line">    public native void say<span class="constructor">Hello()</span>;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line"><span class="comment">//        System.load(&quot;./sayHello.dll&quot;);</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>load<span class="constructor">Library(<span class="string">&quot;sayHello&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>get<span class="constructor">Property(<span class="string">&quot;java.library.path&quot;</span>)</span>);</span><br><span class="line">        Main m = <span class="keyword">new</span> <span class="constructor">Main()</span>;</span><br><span class="line">        m.say<span class="constructor">Hello()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>javac -h ./ Main.java</code>转为头文件,内容如下</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class org_example_Main */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_org_example_Main</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_org_example_Main</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     org_example_Main</span></span><br><span class="line"><span class="comment"> * Method:    sayHello</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_org_example_Main_sayHello</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *, jobject)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后写一个cpp去实现方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;org_example_Main.h&quot;</span></span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_org_example_Main_sayHello</span><span class="params">(JNIEnv *, jobject)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello im from cpp&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后生成dll文件,注意头文件要有jdk中的头文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -Wall -shared -fPIC -IC:/Users/proanimer/.jdks/openjdk-22.0.1/include -IC:/Users/proanimer/.jdks/openjdk-22.0.1/include/win32 sayHello.cpp -o sayHello.dll</span><br></pre></td></tr></table></figure><p>得到的dll文件就能被<code>`System.loadLibrary</code>加载了,但注意dll文件放的位置,会去环境变量中的PATH去找,如果直接放在同一目录下没有额外设置是没有导入的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"><span class="comment">//TIP To &lt;b&gt;Run&lt;/b&gt; code, press &lt;shortcut actionId=&quot;Run&quot;/&gt; or</span></span><br><span class="line"><span class="comment">// click the &lt;icon src=&quot;AllIcons.Actions.Execute&quot;/&gt; icon in the gutter.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;sayHello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.library.path&quot;</span>));</span><br><span class="line">        Main m = <span class="keyword">new</span> Main();</span><br><span class="line">        m.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过class打包为jarr包,然后直接调用jar包(jar包需要调用dll)即可.</p><ol><li><code>java -jar &lt;jarfile&gt;</code>: 运行指定的 Java 归档文件(JAR 文件)。</li><li><code>java -cp &lt;classpath&gt; &lt;main-class&gt;</code>: 指定类路径并运行指定的主类。</li><li><code>java -D&lt;property&gt;=&lt;value&gt;</code>: 设置 Java 系统属性。</li><li><code>java -verbose</code>: 开启详细输出模式。</li><li><code>java -version</code>: 显示 Java 版本信息。</li><li><code>java -help</code>: 显示 Java 命令行帮助。</li></ol><p>其他方法可以看看<a href="https://blog.csdn.net/giveaname/article/details/106615257">JNA —— Java调用C/C++动态库_jna调用c++类-CSDN博客</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://blog.csdn.net/weixin_43552133/article/details/128377535">gcc生成静态库与动态库（附带使用方法）_gcc 生成静态库-CSDN博客</a></li><li><a href="https://www.runoob.com/w3cnote/cpp-static-library-and-dynamic-library.html">C++静态库与动态库 | 菜鸟教程 (runoob.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;当项目比较大涉及到多门编程语言时会有这种需求.通常是要求调用C/C++等.&lt;br&gt;某些语言之间相对来说调用就比较简单,比如Go和C,Rust和C等.但是其他语言相对来说就麻烦了.本文主要涉及Python,JS,Java和C/C+的互相调用,以备不时之需.&lt;/p&gt;
&lt;p&gt;TL;DR:Python使用pybind11,JS使用emcc,Java使用JNI.&lt;br&gt;</summary>
    
    
    
    
    <category term="programming" scheme="https://www.sekyoro.top/tags/programming/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程介绍与入门</title>
    <link href="https://www.sekyoro.top/2024/06/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%85%A5%E9%97%A8/"/>
    <id>https://www.sekyoro.top/2024/06/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%85%A5%E9%97%A8/</id>
    <published>2024-06-23T12:21:01.000Z</published>
    <updated>2024-06-28T04:08:28.489Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>之前在看其他人交流帖子的时候提到学习函数式编程提升思维(虽然感觉有点大肆宣传的感觉),但看了一些函数式编程的例子,感觉在数据处理和多线程上有独特的效果,如果使用面向对象,那就会变得比较麻烦,所以这里仅作简单介绍.<br><span id="more"></span><br>个人认为,函式编程是一种思想,而不是具体某种工具. C++可以进行函数式编程,Java也可以,只不过看支持程度而已.<strong>现代的编程语言已经把函数式编程的思想融入进去了</strong> .</p><p>什么是函数式编程呢？在网上你可以看到很多定义，但大都离不开这些特性。</p><ul><li><strong>First Class</strong> 函数：函数可以被应用，也可以被当作数据。</li><li><strong>Pure</strong> 纯函数，无副作用：任意时刻以相同参数调用函数任意次数得到的结果都一样。</li><li><strong>Referential Transparency</strong> 引用透明：可以被表达式替代。</li><li><strong>Expression</strong> 基于表达式：表达式可以被计算，促进数据流动，状态声明就像是一个暂停，好像数据到这里就会停滞了一下。</li><li><strong>Immutable</strong> 不可变性：参数不可被修改、变量不可被修改—宁可牺牲性能，也要产生新的数据（Rust内存模型例外）。</li><li><strong>High Order Function</strong> 大量使用高阶函数：变量存储、闭包应用、函数高度可组合。</li><li><strong>Curry</strong> 柯里化：对函数进行降维，方便进行组合。</li><li><strong>Composition</strong> 函数组合：将多个单函数进行组合，像流水线一样工作。</li></ul><p>另外还有一些特性，有的会提到，有的一笔带过，但实际也是一个特性（以Haskell为例）。</p><ul><li><strong>Type Inference</strong> 类型推导：如果无法确定数据的类型，那函数怎么去组合？（常见，但非必需）</li><li><strong>Lazy Evaluation</strong> 惰性求值：函数天然就是一个执行环境，惰性求值是很自然的选择。</li><li><strong>Side Effect</strong> IO：一种类型，用于处理副作用。一个不能执行打印文字、修改文件等操作的程序，是没有意义的，总要有位置处理副作用。（边缘）</li></ul><blockquote><p>函数式编程语言的一些核心特点,如不可变数据、高阶函数、惰性求值等。它们为现代软件开发带来了新的编程模式和思维方式。<br>本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。</p></blockquote><ul><li><p>数据是不可变(immutable)的： 如果要更改数据（如数组），需要返回一个包含更改内容的新数组，而不是原来的数组。</p></li><li><p>函数是无状态的： 函数每次都像第一次一样运行！换句话说，对于相同的参数，函数总是给出相同的返回值。</p></li></ul><p>一般来说，您应该遵循三个最佳实践：</p><ol><li><strong>函数应至少接受一个参数。</strong></li><li><p><strong>函数应返回数据或另一个函数。</strong></p></li><li><p><strong>不要使用循环</strong></p></li></ol><h3 id="函数一等公民"><a href="#函数一等公民" class="headerlink" title="函数一等公民"></a>函数一等公民</h3><ul><li>函数是”头等公民”,可以作为参数传递,返回值,赋值给变量等。</li><li>允许编写高阶函数,增强了代码的灵活性和表达力。</li></ul><blockquote><p>函数没什么特殊的，你可以像对待任何其他数据类型一样对待它们——把它们存在数组里，当作参数传递，赋值给变量…等等。</p></blockquote><p>具体来说,看看别人的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hi = <span class="function"><span class="params">name</span> =&gt;</span> <span class="string">`Hi <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">const</span> greeting = <span class="function"><span class="params">name</span> =&gt;</span> hi(name); <span class="comment">// 没有必要的操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> greeting = hi; <span class="comment">// 相同的作用</span></span><br><span class="line">greeting(<span class="string">&quot;times&quot;</span>); <span class="comment">// &quot;Hi times&quot;</span></span><br></pre></td></tr></table></figure><p>再来一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这行</span></span><br><span class="line">ajaxCall(<span class="function"><span class="params">json</span> =&gt;</span> callback(json));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于这行</span></span><br><span class="line">ajaxCall(callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 那么，重构下 getServerStuff</span></span><br><span class="line"><span class="keyword">const</span> getServerStuff = <span class="function"><span class="params">callback</span> =&gt;</span> ajaxCall(callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...就等于</span></span><br><span class="line"><span class="keyword">const</span> getServerStuff = ajaxCall <span class="comment">// &lt;-- 看，没有括号哦</span></span><br></pre></td></tr></table></figure><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BlogController = &#123;</span><br><span class="line">  <span class="built_in">index</span>(posts) &#123; <span class="keyword">return</span> Views.<span class="built_in">index</span>(posts); &#125;,</span><br><span class="line">  show(<span class="keyword">post</span>) &#123; <span class="keyword">return</span> Views.show(<span class="keyword">post</span>); &#125;,</span><br><span class="line">  create(attrs) &#123; <span class="keyword">return</span> <span class="keyword">Db</span>.create(attrs); &#125;,</span><br><span class="line">  <span class="keyword">update</span>(<span class="keyword">post</span>, attrs) &#123; <span class="keyword">return</span> <span class="keyword">Db</span>.<span class="keyword">update</span>(<span class="keyword">post</span>, attrs); &#125;,</span><br><span class="line">  destroy(<span class="keyword">post</span>) &#123; <span class="keyword">return</span> <span class="keyword">Db</span>.destroy(<span class="keyword">post</span>); &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BlogController = &#123;</span><br><span class="line">  index: Views.index,</span><br><span class="line">  show: Views.show,</span><br><span class="line">  create: <span class="keyword">Db</span>.create,</span><br><span class="line">  <span class="keyword">update</span>: <span class="keyword">Db</span>.<span class="keyword">update</span>,</span><br><span class="line">  destroy: <span class="keyword">Db</span>.destroy,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样修改有什么意义?=&gt;除了节省代码,减少冗余之外,外面的函数修改后,里面的函数可以不用改了.这也增加了可重用性,说到可重用性,还有一点就是在不涉及到具体业务的函数上命名应该更加通用.</p><p>另外涉及到类似js中的this值时最好使用bind,apply等绑定避免出错.</p><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>纯函数(Pure Function)是函数式编程中的一个核心概念。它有以下几个特点:</p><ol><li><strong>无副作用(No Side Effects)</strong>:<ul><li><strong>纯函数不会修改函数外部的任何状态</strong>,如全局变量、I/O操作等。</li><li><strong>只依赖于输入参数</strong>,不会产生意外的输出。</li></ul></li><li><strong>确定性(Deterministic)</strong>:<ul><li>对于相同的输入,纯函数总是返回相同的输出。</li><li>没有”隐藏的”依赖或状态会影响函数的结果。</li></ul></li><li><strong>可测试性(Testable)</strong>:<ul><li>纯函数易于单元测试,因为不需要考虑外部环境的影响。</li><li>可以独立地测试每个函数,不会受到其他函数的干扰。</li></ul></li><li><strong>可组合性(Composable)</strong>:<ul><li>纯函数可以被轻松地组合成更复杂的功能。</li><li>函数的输出可以作为另一个函数的输入,形成管道式的数据处理。</li></ul></li><li><strong>并发性(Concurrency)</strong>:<ul><li>由于没有副作用,纯函数可以安全地在多线程环境中并发执行。</li><li>不需要担心竞争条件和同步问题。</li></ul></li></ol><p>通常我们定义输入输出（IO）是不纯的，因为<strong>IO操作不仅操作了数据，还操作了这个数据范畴外部的世界，比如打印、播放声音、修改变量状态、网络请求等。这些操作并不是说对程序造成了破坏，相反，一个完整的程序一定是需要它们的，不然我们的所有计算都将毫无意义</strong>。</p><p>但纯函数是可预测的，引用透明的，我们希望代码中更多地出现纯函数式的代码，<strong>这样的代码可以被预测，可以被表达式替换，而更多地把IO操作放到一个统一的位置做处理</strong></p><blockquote><p><em>副作用</em>是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的<em>可观察的交互</em>。</p></blockquote><p>此外会对输入数据原地改变的函数也是不纯的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xs = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯的</span></span><br><span class="line">xs.slice(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//=&gt; [1,2,3]</span></span><br><span class="line"></span><br><span class="line">xs.slice(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//=&gt; [1,2,3]</span></span><br><span class="line"></span><br><span class="line">xs.slice(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//=&gt; [1,2,3]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不纯的</span></span><br><span class="line">xs.splice(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//=&gt; [1,2,3]</span></span><br><span class="line"></span><br><span class="line">xs.splice(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//=&gt; [4,5]</span></span><br><span class="line"></span><br><span class="line">xs.splice(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//=&gt; []</span></span><br></pre></td></tr></table></figure><h4 id="追求“纯”的理由"><a href="#追求“纯”的理由" class="headerlink" title="追求“纯”的理由"></a>追求“纯”的理由</h4><p>from <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html">第 3 章: 纯函数的好处 · 函数式编程指北 (gitbooks.io)</a></p><p><strong>可缓存性（Cacheable）</strong></p><p>首先，纯函数总能够根据输入来做缓存。实现缓存的一种典型方式是 memoize 技术：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> squareNumber  = memoize(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> x*x; &#125;);</span><br><span class="line"></span><br><span class="line">squareNumber(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//=&gt; 16</span></span><br><span class="line"></span><br><span class="line">squareNumber(<span class="number">4</span>); <span class="comment">// 从缓存中读取输入值为 4 的结果</span></span><br><span class="line"><span class="comment">//=&gt; 16</span></span><br><span class="line"></span><br><span class="line">squareNumber(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//=&gt; 25</span></span><br><span class="line"></span><br><span class="line">squareNumber(<span class="number">5</span>); <span class="comment">// 从缓存中读取输入值为 5 的结果</span></span><br><span class="line"><span class="comment">//=&gt; 25</span></span><br></pre></td></tr></table></figure><p>下面的代码是一个简单的实现，尽管它不太健壮。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> memoize = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arg_str = <span class="built_in">JSON</span>.stringify(<span class="built_in">arguments</span>);</span><br><span class="line">    cache[arg_str] = cache[arg_str] || f.apply(f, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> cache[arg_str];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>值得注意的一点是，可以通过延迟执行的方式把不纯的函数转换为纯函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pureHttpCall = memoize(<span class="function"><span class="keyword">function</span>(<span class="params">url, params</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> $.getJSON(url, params); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里有趣的地方在于我们并没有真正发送 http 请求——只是返回了一个函数，当调用它的时候才会发请求。这个函数之所以有资格成为纯函数，是因为它总是会根据相同的输入返回相同的输出：给定了 <code>url</code> 和 <code>params</code> 之后，它就只会返回同一个发送 http 请求的函数。</p><p>我们的 <code>memoize</code> 函数工作起来没有任何问题，虽然它缓存的并不是 http 请求所返回的结果，而是生成的函数。</p><p>现在来看这种方式意义不大，不过很快我们就会学习一些技巧来发掘它的用处。重点是<strong>可以缓存任意一个函数，不管它们看起来多么具有破坏性</strong>。</p><p><strong>可移植性／自文档化（Portable / Self-Documenting）</strong></p><p>纯函数是完全自给自足的，它需要的所有东西都能轻易获得。仔细思考思考这一点…这种自给自足的好处是什么呢？首先，纯函数的依赖很明确，因此更易于观察和理解——没有偷偷摸摸的小动作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不纯的</span></span><br><span class="line"><span class="keyword">var</span> signUp = <span class="function"><span class="keyword">function</span>(<span class="params">attrs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> user = saveUser(attrs);</span><br><span class="line">  welcomeUser(user);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> saveUser = <span class="function"><span class="keyword">function</span>(<span class="params">attrs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> user = Db.save(attrs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> welcomeUser = <span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    Email(user, ...);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯的</span></span><br><span class="line"><span class="keyword">var</span> signUp = <span class="function"><span class="keyword">function</span>(<span class="params">Db, Email, attrs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> user = saveUser(Db, attrs);</span><br><span class="line">    welcomeUser(Email, user);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> saveUser = <span class="function"><span class="keyword">function</span>(<span class="params">Db, attrs</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> welcomeUser = <span class="function"><span class="keyword">function</span>(<span class="params">Email, user</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个例子表明，纯函数对于其依赖必须要诚实，这样我们就能知道它的目的。仅从纯函数版本的 <code>signUp</code> 的签名就可以看出，它将要用到 <code>Db</code>、<code>Email</code> 和 <code>attrs</code>，这在最小程度上给了我们足够多的信息。</p><p>后面我们会学习如何<strong>不通过这种仅仅是延迟执行的方式来让一个函数变纯，不过这里的重点应该很清楚，那就是相比不纯的函数，纯函数能够提供多得多的信息</strong></p><p>其次，通过强迫“注入”依赖，或者把它们当作参数传递，我们的应用也更加灵活；因为数据库或者邮件客户端等等都参数化了（别担心，我们有办法让这种方式不那么单调乏味）。如果要使用另一个 <code>Db</code>，只需把它传给函数就行了。如果想在一个新应用中使用这个可靠的函数，尽管把新的 <code>Db</code> 和 <code>Email</code> 传递过去就好了，非常简单。</p><p>在 JavaScript 的设定中，可移植性可以意味着把函数序列化（serializing）并通过 socket 发送。也可以意味着代码能够在 web workers 中运行。总之，可移植性是一个非常强大的特性。</p><p>命令式编程中“典型”的方法和过程都深深地根植于它们所在的环境中，通过状态、依赖和有效作用（available effects）达成；纯函数与此相反，它与环境无关，只要我们愿意，可以在任何地方运行它。</p><p>你上一次把某个类方法拷贝到新的应用中是什么时候？我最喜欢的名言之一是 Erlang 语言的作者 Joe Armstrong 说的这句话：“面向对象语言的问题是，它们永远都要随身携带那些隐式的环境。你只需要一个香蕉，但却得到一个拿着香蕉的大猩猩…以及整个丛林”。</p><p><strong>可测试性（Testable）</strong></p><p>第三点，纯函数让测试更加容易。我们不需要伪造一个“真实的”支付网关，或者每一次测试之前都要配置、之后都要断言状态（assert the state）。只需简单地给函数一个输入，然后断言输出就好了。</p><p>事实上，我们发现函数式编程的社区正在开创一些新的测试工具，能够帮助我们自动生成输入并断言输出。这超出了本书范围，但是我强烈推荐你去试试 <em>Quickcheck</em>——一个为函数式环境量身定制的测试工具。</p><p><strong>合理性（Reasonable）</strong></p><p>很多人相信使用纯函数最大的好处是<em>引用透明性</em>（referential transparency）。如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的。</p><p>由于纯函数总是能够根据相同的输入返回相同的输出，所以它们就能够保证总是返回同一个结果，这也就保证了引用透明性。我们来看一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Immutable = <span class="built_in">require</span>(<span class="string">&#x27;immutable&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> decrementHP = <span class="function"><span class="keyword">function</span>(<span class="params">player</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> player.set(<span class="string">&quot;hp&quot;</span>, player.hp-<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isSameTeam = <span class="function"><span class="keyword">function</span>(<span class="params">player1, player2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> player1.team === player2.team;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> punch = <span class="function"><span class="keyword">function</span>(<span class="params">player, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(isSameTeam(player, target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> decrementHP(target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jobe = Immutable.Map(&#123;<span class="attr">name</span>:<span class="string">&quot;Jobe&quot;</span>, <span class="attr">hp</span>:<span class="number">20</span>, <span class="attr">team</span>: <span class="string">&quot;red&quot;</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> michael = Immutable.Map(&#123;<span class="attr">name</span>:<span class="string">&quot;Michael&quot;</span>, <span class="attr">hp</span>:<span class="number">20</span>, <span class="attr">team</span>: <span class="string">&quot;green&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">punch(jobe, michael);</span><br><span class="line"><span class="comment">//=&gt; Immutable.Map(&#123;name:&quot;Michael&quot;, hp:19, team: &quot;green&quot;&#125;)</span></span><br></pre></td></tr></table></figure><p><code>decrementHP</code>、<code>isSameTeam</code> 和 <code>punch</code> 都是纯函数，所以是引用透明的。我们可以使用一种叫做“等式推导”（equational reasoning）的技术来分析代码。所谓“等式推导”就是“一对一”替换，有点像在不考虑程序性执行的怪异行为（quirks of programmatic evaluation）的情况下，手动执行相关代码。我们借助引用透明性来剖析一下这段代码。</p><p>首先内联 <code>isSameTeam</code> 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> punch = <span class="function"><span class="keyword">function</span>(<span class="params">player, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(player.team === target.team) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> decrementHP(target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为是不可变数据，我们可以直接把 <code>team</code> 替换为实际值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> punch = <span class="function"><span class="keyword">function</span>(<span class="params">player, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="string">&quot;red&quot;</span> === <span class="string">&quot;green&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> decrementHP(target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>if</code> 语句执行结果为 <code>false</code>，所以可以把整个 <code>if</code> 语句都删掉：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> punch = <span class="function"><span class="keyword">function</span>(<span class="params">player, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> decrementHP(target);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果再内联 <code>decrementHP</code>，我们会发现这种情况下，<code>punch</code> 变成了一个让 <code>hp</code> 的值减 1 的调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> punch = <span class="function"><span class="keyword">function</span>(<span class="params">player, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> target.set(<span class="string">&quot;hp&quot;</span>, target.hp-<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总之，等式推导带来的分析代码的能力对重构和理解代码非常重要。事实上，我们重构海鸥程序使用的正是这项技术：利用加和乘的特性。对这些技术的使用将会贯穿本书，真的。</p><p><strong>并行代码</strong></p><p>因为可以并行运行任意纯函数。因为纯函数根本不需要访问共享的内存，而且根据其定义，纯函数也不会因副作用而进入竞争态（race condition）。</p><p>并行代码在服务端 js 环境以及使用了 web worker 的浏览器那里是非常容易实现的，因为它们使用了线程（thread）。不过出于对非纯函数复杂度的考虑，当前主流观点还是避免使用这种并行。</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做”函数的合成”（compose）</p><p>将计算过程分解成可复用的函数，典型例子就是<code>map</code>方法和<code>reduce</code>方法组合而成MapReduce算法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">compose(f, compose(g, h))</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">compose(compose(f, g), h)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">compose(f, g, h)</span><br></pre></td></tr></table></figure><h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>在学习JS的时候,你可能已经注意到这个概念了</p><p><code>f(x)</code>和<code>g(x)</code>合成为<code>f(g(x))</code>，有一个隐藏的前提，就是<code>f</code>和<code>g</code>都只能接受一个参数。如果可以接受多个参数，比如<code>f(x, y)</code>和<code>g(a, b, c)</code>，函数合成就非常麻烦。</p><p>这时就需要函数柯里化了。所谓”柯里化”，就是把一个多参数的函数，转化为单参数函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 柯里化之前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化之后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addX</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addX(<span class="number">2</span>)(<span class="number">1</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>有了柯里化以后，我们就能做到，所有函数只接受一个参数。后文的内容除非另有说明，都默认函数只有一个参数，就是所要处理的那个值。</p><p>除了上面提到的之外,还有很多其他特性,就需要自己学习了.</p><h3 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h3><blockquote><p>Functor可以简单地理解为一个能够保存值,并且能够对这些值执行某些操作的容器。更具体地说,Functor是一个实现了<code>fmap</code>函数的类型类。<code>fmap</code>函数允许我们对Functor中包含的值执行某种变换操作,并将结果包装到新的Functor中返回。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个列表</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用fmap对列表中的元素进行平方变换</span></span><br><span class="line">squared_numbers = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, numbers))</span><br><span class="line"><span class="built_in">print</span>(squared_numbers) <span class="comment"># Output: [1, 4, 9, 16, 25]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"><span class="comment"># Option类型作为Functor</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">safe_divide</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> a / b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用fmap对Optional类型执行变换</span></span><br><span class="line">result1 = safe_divide(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(result1)  <span class="comment"># Output: 5.0</span></span><br><span class="line"></span><br><span class="line">result2 = safe_divide(<span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(result2)  <span class="comment"># Output: None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用fmap对Maybe类型执行变换</span></span><br><span class="line">doubled_result1 = <span class="keyword">lambda</span> x: x * <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(doubled_result1, [result1, result2]))) <span class="comment"># Output: [10.0, None]</span></span><br></pre></td></tr></table></figure><h3 id="Monoid"><a href="#Monoid" class="headerlink" title="Monoid"></a>Monoid</h3><blockquote><p>Monoid是一个具有以下两个特性的代数结构:</p><ol><li>二元操作(称为”合并”操作)</li><li>一个特殊的单位元</li></ol><p>更具体地说,一个类型<code>T</code>是一个Monoid,如果它满足以下两个条件:</p><ol><li>存在一个二元操作<code>combine(a: T, b: T) -&gt; T</code>，该操作是<strong>associative</strong>的,即<code>combine(a, combine(b, c)) = combine(combine(a, b), c)</code>。</li><li>存在一个特殊的值<code>empty: T</code>，被称为单位元,对于任意<code>x: T</code>都有<code>combine(x, empty) = x</code>和<code>combine(empty, x) = x</code></li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 整数求和操作</span></span><br><span class="line">numbers1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">numbers2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">total = <span class="built_in">sum</span>(numbers1) + <span class="built_in">sum</span>(numbers2)</span><br><span class="line"><span class="built_in">print</span>(total)  <span class="comment"># Output: 21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0作为单位元</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>([]) + <span class="built_in">sum</span>(numbers1))  <span class="comment"># Output: 6</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(numbers1) + <span class="built_in">sum</span>([]))  <span class="comment"># Output: 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串拼接操作</span></span><br><span class="line">greeting1 = <span class="string">&quot;Hello, &quot;</span></span><br><span class="line">greeting2 = <span class="string">&quot;world!&quot;</span></span><br><span class="line">combined_greeting = greeting1 + greeting2</span><br><span class="line"><span class="built_in">print</span>(combined_greeting)  <span class="comment"># Output: &quot;Hello, world!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 空字符串作为单位元</span></span><br><span class="line">empty_string = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(empty_string + greeting1)  <span class="comment"># Output: &quot;Hello, &quot;</span></span><br><span class="line"><span class="built_in">print</span>(greeting1 + empty_string)  <span class="comment"># Output: &quot;Hello, &quot;</span></span><br></pre></td></tr></table></figure><h3 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h3><blockquote><p>可以被视为Functor的一种特殊形式,具有额外的性质和操作。</p><p>简单来说,Monad是一个满足以下条件的类型<code>M[_]</code>:</p><ol><li>它是一个Functor,即存在<code>fmap</code>操作,可以对Monad内部的值进行变换。</li><li>它具有一个<code>return</code>操作,可以将一个值包装进Monad。</li><li>它具有一个<code>flatMap</code>(或<code>bind</code>)操作,可以对Monad内部的值进行变换并”扁平化”结果。</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    <span class="keyword">return</span> [x, x * <span class="number">2</span>, x * <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用flatMap操作</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">results = [y <span class="keyword">for</span> x <span class="keyword">in</span> numbers <span class="keyword">for</span> y <span class="keyword">in</span> multiply(x)]</span><br><span class="line"><span class="built_in">print</span>(results)  <span class="comment"># Output: [1, 2, 3, 2, 4, 6, 3, 6, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用列表推导式实现flatMap</span></span><br><span class="line">results = [multiply(x) <span class="keyword">for</span> x <span class="keyword">in</span> numbers]</span><br><span class="line"><span class="built_in">print</span>(results)  <span class="comment"># Output: [[1, 2, 3], [2, 4, 6], [3, 6, 9]]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://ruanyifeng.com/blog/2015/07/monad.html">图解 Monad - 阮一峰的网络日志 (ruanyifeng.com)</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IO类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IO</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">effect</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._effect = effect;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// pure操作</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">of</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="function">() =&gt;</span> value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind操作</span></span><br><span class="line">  <span class="function"><span class="title">bind</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="function">() =&gt;</span> fn(<span class="built_in">this</span>._effect()).run());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._effect();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">const</span> greet = <span class="function"><span class="params">name</span> =&gt;</span> <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line"><span class="keyword">const</span> getInput = <span class="function">() =&gt;</span> prompt(<span class="string">&#x27;What is your name?&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sayHello = <span class="keyword">new</span> IO(getInput)</span><br><span class="line">  .bind(<span class="function"><span class="params">name</span> =&gt;</span> <span class="keyword">new</span> IO(<span class="function">() =&gt;</span> greet(name)))</span><br><span class="line">  .bind(<span class="function"><span class="params">message</span> =&gt;</span> <span class="keyword">new</span> IO(<span class="function">() =&gt;</span> alert(message)));</span><br><span class="line"></span><br><span class="line">sayHello.run(); <span class="comment">// 弹出对话框并显示&#x27;Hello, &#123;输入的名字&#125;!&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h3><blockquote><p>Applicative可以被视为Functor的一种特殊形式,具有以下特点:</p><ol><li>它是一个Functor,即存在<code>fmap</code>操作,可以对Applicative内部的值进行变换。</li><li>它具有一个<code>pure</code>操作,可以将一个值包装进Applicative。</li><li>它具有一个<code>ap</code>(apply)操作,可以将一个函数包装进Applicative应用到另一个Applicative上</li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Either类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Either</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">of</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Right(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">left</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Left(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ap操作</span></span><br><span class="line">  <span class="function"><span class="title">ap</span>(<span class="params">other</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> Left) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (other <span class="keyword">instanceof</span> Left) &#123;</span><br><span class="line">      <span class="keyword">return</span> other;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Right(<span class="built_in">this</span>._value(other._value));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Right</span> <span class="keyword">extends</span> <span class="title">Either</span> </span>&#123;</span><br><span class="line">  <span class="comment">// pure操作</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">of</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Right(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Left</span> <span class="keyword">extends</span> <span class="title">Either</span> </span>&#123;</span><br><span class="line">  <span class="comment">// pure操作</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">of</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Left(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"><span class="keyword">const</span> result1 = Either.of(add).ap(Either.of(<span class="number">3</span>)).ap(Either.of(<span class="number">4</span>)); <span class="comment">// Right(7)</span></span><br><span class="line"><span class="keyword">const</span> result2 = Either.of(add).ap(Either.of(<span class="number">3</span>)).ap(Either.left(<span class="string">&#x27;error&#x27;</span>)); <span class="comment">// Left(&#x27;error&#x27;)</span></span><br></pre></td></tr></table></figure><p><a href="https://sxyz.blog/functors-applicatives-and-monads-in-pictures/">图解 Functor、Applicative、Monad (sxyz.blog)</a></p><p><a href="https://blog.forec.cn/2017/03/02/translation-adit-faamip/">图解 Functor, Applicative 和 Monad | Forec’s Notes</a></p><p><img data-src="https://p0.meituan.net/travelcube/652d533cc899998d4822ac6ed58cce89128094.png" alt="图 30" style="zoom:50%;" /></p><p><strong>使用函数式编程的一些原因</strong></p><ul><li>方便debug</li></ul><p>因为写成了函数,方便写单元测试而且由于是纯函数，输入固定那输出就是固定的</p><ul><li>代码重用</li></ul><p>纯函数方便组合也方便使用</p><ul><li>另一种思维方式</li></ul><p>是的，除了OOP之外，你可以站在这样的角度写特别的代码</p><p>如果你要学习具体某个函数式编程语言,可以考虑Clojure,Elixir,Haskell或者更加新的Ocaml.(我个人推荐)</p><p>下面给一些函数式编程语言分个类.</p><p>Lisp 家族</p><ul><li>Common Lisp</li><li>Scheme</li><li>Racket</li><li>Clojure</li></ul><p>这些语言都属于 Lisp 语言家族,具有强大的宏系统和元编程能力,非常适合进行函数式和声明式编程。</p><p>支持函数式编程的多范式语言</p><ul><li>Scala</li><li>F#</li><li>Clojure</li><li>Kotlin</li><li>Swift</li></ul><p>这类语言融合了函数式和面向对象等多种编程范式,兼具函数式和命令式编程的特点。它们在工业界应用较为广泛。</p><p>纯函数式语言</p><ul><li>Haskell</li><li>PureScript</li></ul><p>这类语言严格遵循函数式编程的原则,没有可变状态,强调代数类型系统和惰性求值。它们更偏向于学术和研究领域。</p><p>并发/分布式函数式语言:</p><ul><li>Erlang</li><li>Elixir</li><li>OCaml</li></ul><p>这些语言擅长构建高并发、分布式和容错的应用程序,利用函数式编程的优势来应对复杂的并发问题。</p><p>JavaScript 衍生语言</p><ul><li>PureScript</li><li>Elm</li><li>ReasonML</li><li>TypeScript</li></ul><p>这类语言在 JavaScript 的基础上增加了静态类型系统和其他函数式特性,旨在提高 JavaScript 的可靠性和可维护性</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/readme/guides/functional-programming-basics">Functional Programming 101 (github.com)</a></li><li><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/">Introduction · 函数式编程指北 (gitbooks.io)</a></li><li><a href="https://ruanyifeng.com/blog/2017/02/fp-tutorial.html">函数式编程入门教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></li><li><a href="https://tech.meituan.com/2022/10/13/dive-into-functional-programming-01.html">深入理解函数式编程（上） - 美团技术团队 (meituan.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前在看其他人交流帖子的时候提到学习函数式编程提升思维(虽然感觉有点大肆宣传的感觉),但看了一些函数式编程的例子,感觉在数据处理和多线程上有独特的效果,如果使用面向对象,那就会变得比较麻烦,所以这里仅作简单介绍.&lt;br&gt;</summary>
    
    
    
    
    <category term="functional programming" scheme="https://www.sekyoro.top/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>使用pytorch时你可能需要注意的地方</title>
    <link href="https://www.sekyoro.top/2024/06/23/effective_pytorch/"/>
    <id>https://www.sekyoro.top/2024/06/23/effective_pytorch/</id>
    <published>2024-06-23T08:16:46.000Z</published>
    <updated>2024-07-11T12:44:39.617Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Pytorch是很好的深度学习框架,但在使用时你可能仍然不清楚其中一些概念.这里我只以官方文档为依据尝试解释其中一些概念和方法. 我这里可以称作Effective Pytorch.<br><span id="more"></span></p><blockquote><p>update:为了更好的理解pytorch,也许可以从零写点代码<a href="https://github.com/karpathy/micrograd">karpathy/micrograd: A tiny scalar-valued autograd engine and a neural net library on top of it with PyTorch-like API (github.com)</a></p><p><a href="https://nrehiew.github.io/blog/pytorch/">Taking PyTorch for Granted | wh (nrehiew.github.io)</a></p></blockquote><h2 id="tensor"><a href="#tensor" class="headerlink" title="tensor"></a>tensor</h2><h3 id="Tensor"><a href="#Tensor" class="headerlink" title="Tensor"></a>Tensor</h3><p>pytorch默认浮点类型是torch.float32,可以使用<code>torch.set_default_dtype</code>修改</p><p>torch.zeros等默认类型就是就是torch.float32,使用<code>torch.set_default_dtype</code>修改默认类型.</p><p>torch.tensor() 总是复制<code>data</code>(深拷贝,表示地址不相同).如果你有一个张量数据,<strong>只是想更改它的 requires<em>grad 标志,请使用 requires_grad</em>() 或 detach() 来避免复制</strong>.</p><p>如果你有一个 numpy 数组,并<strong>希望避免复制,请使用 torch.as_tensor()</strong>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">torch.device(<span class="string">&#x27;cuda:0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">torch.device(<span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">torch.device(<span class="string">&#x27;mps&#x27;</span>)</span><br><span class="line"></span><br><span class="line">torch.device(<span class="string">&#x27;cuda&#x27;</span>)  <span class="comment"># current cuda device</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]])</span><br><span class="line">x.stride() <span class="comment">#(5,1)</span></span><br><span class="line"></span><br><span class="line">x.t().stride() <span class="comment">#(1,5)</span></span><br></pre></td></tr></table></figure><h3 id="Views"><a href="#Views" class="headerlink" title="Views"></a>Views</h3><p>PyTorch 允许张量成为现有张量的 “views”.<strong>视图张量与其基础张量共享相同的底层数据</strong>.支持 “views “可以避免显式数据复制,从而使我们能够进行快速、高效的内存重塑、切片和元素操作.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t = torch.rand(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">b = t.view(<span class="number">2</span>, <span class="number">8</span>)</span><br><span class="line">t.storage().data_ptr() == b.storage().data_ptr()  <span class="comment"># `t` and `b` share the same underlying data.</span></span><br><span class="line">b[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">3.14</span></span><br><span class="line">t[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>由于views与其基础张量共享底层数据,因此如果修改views中的数据,也会反映在基础张量中.</p><p>通常,PyTorch 操作会返回一个新的张量作为输出,例如 add().但在视图操作中,输出是输入张量的视图,以避免不必要的数据复制.创建视图时不会发生数据移动,视图张量只是改变了解释相同数据的方式.</p><p><strong>对连续张量进行视图处理可能会产生非连续张量</strong>.transpose() 就是一个常见的例子.(包括view,transpose等操作都会返回view,也就是数据存储与输入相同)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">base = torch.tensor([[<span class="number">0</span>, <span class="number">1</span>],[<span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line">base.is_contiguous()</span><br><span class="line">t = base.transpose(<span class="number">0</span>, <span class="number">1</span>)  <span class="comment"># `t` is a view of `base`. No data movement happened here.</span></span><br><span class="line">t.is_contiguous()</span><br><span class="line">c = t.contiguous()</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/06/25/vKDYZ7A1jb3g9kO.png" alt="image-20240625212647753"></p><p><a href="https://zhuanlan.zhihu.com/p/342856639">通过公式判断张量是否连续 - 知乎 (zhihu.com)</a></p><h2 id="Extending-PyTorch"><a href="#Extending-PyTorch" class="headerlink" title="Extending PyTorch"></a>Extending PyTorch</h2><p>原文<a href="https://pytorch.org/docs/stable/notes/extending.html">Extending PyTorch — PyTorch 2.3 documentation</a></p><h3 id="extending-torch-autograd"><a href="#extending-torch-autograd" class="headerlink" title="extending torch.autograd"></a>extending torch.autograd</h3><p>为 autograd 添加操作需要为每个操作实现一个新的 Function 子类.</p><h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h5><p>一般来说,如果想在模型中<strong>执行不可微分的计算或依赖非 PyTorch 库</strong>（如 NumPy）,但仍希望您的操作能与其他操作连锁并与 autograd 引擎一起工作,那么请使用自定义函数.</p><p>在某些情况下,也可以<strong>使用自定义函数来提高性能和内存使用率</strong>: 如果您使用 C++ 扩展实现了前向和后向传递,您可以将它们封装在 Function 中,以便与 autograd 引擎对接.如果您想减少为后向传递保存的缓冲区数量,可以使用自定义函数将操作组合在一起.</p><p>如果想在后向传递过程中改变梯度或执行副作用，可以考虑register一个张量或模块hook</p><h5 id="什么时候不用"><a href="#什么时候不用" class="headerlink" title="什么时候不用"></a>什么时候不用</h5><p>如果已经可以用 PyTorch 的内置操作来编写函数,那么它的反向图（很可能）已经可以被 autograd 记录下来.在这种情况下,不需要自己实现后向函数.可以考虑使用一个普通的 Python 函数。</p><p>如果需要维护状态,即可训练参数,则应（也可以）使用自定义模块torch.nn. </p><p>如果想在后向传递过程中改变梯度或执行副作用,可以考虑注册一个张量或模块钩子。</p><blockquote><p>注意,我在看pytorch2.3时 register_backward_hook已经deprecated了,使用register_full_backward_hook</p></blockquote><p>使用一个<code>register_full_backward_hook</code>将梯度变为相反数.</p><p><code>hook(module, grad_input, grad_output) -&gt; tuple(Tensor) 或 None</code><br>grad_input 和 grad_output 是元组，分别包含<strong>相对于输入和输出的梯度</strong>。<strong>钩子不应修改其参数</strong>,但<strong>可以选择返回一个新的相对于输入的梯度，该梯度将在后续计算中代替 grad_input</strong>.对于所有非张量参数，grad_input 和 grad_output 中的条目均为 “None”.</p><p>如果想在后向传递过程中改变梯度或执行副作用，可以考虑注册一个张量或模块钩子.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backward_hook</span>(<span class="params">module, grad_input, grad_output</span>):</span></span><br><span class="line">    output_grad_input = - grad_input[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> (output_grad_input,)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">negGradient</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(negGradient, self).__init__()</span><br><span class="line">        self.register_full_backward_hook(backward_hook)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>在domain adaptation的早期论文比如DANN中,一般会使用<code>Function</code>进行梯度变为负数,其实也可以注册backward的hook实现.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_GradReverseLayer</span>(<span class="params">Function</span>):</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">ctx, x, constant</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(constant, <span class="built_in">int</span>) <span class="keyword">and</span> constant &gt; <span class="number">0</span></span><br><span class="line">        ctx.constant = constant</span><br><span class="line">        <span class="keyword">return</span> x.view_as(x)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">ctx, grad_output</span>):</span></span><br><span class="line">        <span class="keyword">return</span> grad_output.neg() * ctx.constant, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GradReverseLayer</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, weight</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(GradReverseLayer, self).__init__()</span><br><span class="line">        self.weight = weight</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> _GradReverseLayer.apply(x, self.weight)</span><br></pre></td></tr></table></figure><p>既然介绍了<code>register_full_backward_hook</code>,再说说<code>register_forward_hook</code>,每次 forward() 计算完输出后，都会调用该钩子。如果 with_kwargs 为 False 或未指定，输入将只包含给模块的位置参数。关键字参数不会传递给钩子，只会传递给 forward。<strong>钩子可以修改输出.钩子可以就地修改输入,但不会对 forward 产生影响</strong>,因为钩子是在调用 forward() 之后才调用的.</p><p>可以看看这篇文章<a href="https://blog.csdn.net/m0_51661400/article/details/135091359">深入理解PyTorch中的Hook机制：特征可视化的重要工具与实践-CSDN博客</a></p><h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><p>采取以下步骤 1. 继承类 Function 并实现 forward()、（可选）setup_context() 和 backward() 方法。2. 在 ctx 参数上调用适当的方法。3. 声明您的函数是否支持 double backward。4. 使用 gradcheck 验证梯度是否正确。</p><p>step1:</p><ol><li>forward() 是执行操作的代码。它可以接受任意多个参数,如果指定默认值,其中一些参数是可选的.在调用之前,跟踪历史的张量参数（即 requires_grad=True）将被转换为不跟踪历史的参数,它们的使用将被记录在图中。请注意,此逻辑不会遍历列表/数据集/任何其他数据结构,只会考虑作为调用直接参数的张量.您可以返回一个张量输出，如果有多个输出，也可以返回一个张量元组。</li><li>setup_context()（可选）。可以编写一个接受 ctx 对象的 “组合 “forward()，或者（从 PyTorch 2.0 开始）编写一个不接受 ctx 的单独 forward()，以及一个用于修改 ctx 的 setup_context()方法。forward() 应该具有计算功能，而 <strong>setup_context() 应该只负责修改 ctx（而不具有任何计算功能</strong>）。一般来说，独立的 forward() 和 setup_context()更接近 PyTorch 本机操作的工作方式，因此更容易与各种 PyTorch 子系统兼容。</li><li>backward()（或 vjp()）定义梯度公式。<strong>输出有多少个张量参数，它就有多少个张量参数，每个张量参数都代表该输出的梯度</strong>。<strong>切勿就地修改这些参数。它应该返回与输入相同数量的张量，其中每个张量都包含对应输入的梯度。</strong>如果输入不需要梯度（needs_input_grad 是一个布尔元组，表示每个输入是否需要梯度计算）,或者是非张量对象，则可以返回 python:None。此外,如果 forward() 的参数是可选的,只要它们都是 None,返回的梯度值就会多于输入值。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exp</span>(<span class="params">Function</span>):</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">ctx, i</span>):</span></span><br><span class="line">        result = i.exp()</span><br><span class="line">        ctx.save_for_backward(result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">ctx, grad_output</span>):</span></span><br><span class="line">        result, = ctx.saved_tensors</span><br><span class="line">        <span class="keyword">return</span> grad_output * result</span><br><span class="line"><span class="comment"># Use it by calling the apply method:</span></span><br><span class="line">output = Exp.apply(<span class="built_in">input</span>)</span><br></pre></td></tr></table></figure><p>step 2：正确使用 ctx 中的函数，以确保新函数在 autograd 引擎中正常工作。</p><p>ctx上有许多方法可用于调用,比较多的就是<code>save_for_backward</code></p><blockquote><p>必须<strong>使用 save_for_backward()来保存要在后向传递中使用的张量</strong>。<strong>非张量应直接保存在 ctx 上</strong>。如果既不是输入也不是输出的张量被保存,那函数函数可能不支持double backward 。</p></blockquote><p>此外还有<code>set_materialize_grads</code></p><blockquote><p>set_materialize_grads()可以用来告诉 autograd 引擎，在输出不依赖于输入的情况下，<strong>通过不对后向函数中的梯度张量进行实体化来优化梯度计算</strong>。</p></blockquote><p>step3:如果函数不支持double backward ，则应通过使用 once_differentiable() 对逆运算进行装饰来明确声明这一点。使用此装饰器后，通过函数执行double backward 的尝试将产生错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.autograd.gradcheck(Exp.apply, x)</span><br></pre></td></tr></table></figure><p>step4:建议使用 torch.autograd.gradcheck() 检查后向函数是否能正确计算前向梯度,方法是使用后向函数计算雅各布矩阵,并将该值与使用有限差分法数值计算的雅各布值进行逐元素比较。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Inherit from Function</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearFunction</span>(<span class="params">Function</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Note that forward, setup_context, and backward are @staticmethods</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params"><span class="built_in">input</span>, weight, bias</span>):</span></span><br><span class="line">        output = <span class="built_in">input</span>.mm(weight.t())</span><br><span class="line">        <span class="keyword">if</span> bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            output += bias.unsqueeze(<span class="number">0</span>).expand_as(output)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="comment"># inputs is a Tuple of all of the inputs passed to forward.</span></span><br><span class="line">    <span class="comment"># output is the output of the forward().</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup_context</span>(<span class="params">ctx, inputs, output</span>):</span></span><br><span class="line">        <span class="built_in">input</span>, weight, bias = inputs</span><br><span class="line">        ctx.save_for_backward(<span class="built_in">input</span>, weight, bias)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># This function has only a single output, so it gets only one gradient</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">ctx, grad_output</span>):</span></span><br><span class="line">        <span class="comment"># This is a pattern that is very convenient - at the top of backward</span></span><br><span class="line">        <span class="comment"># unpack saved_tensors and initialize all gradients w.r.t. inputs to</span></span><br><span class="line">        <span class="comment"># None. Thanks to the fact that additional trailing Nones are</span></span><br><span class="line">        <span class="comment"># ignored, the return statement is simple even when the function has</span></span><br><span class="line">        <span class="comment"># optional inputs.</span></span><br><span class="line">        <span class="built_in">input</span>, weight, bias = ctx.saved_tensors</span><br><span class="line">        grad_input = grad_weight = grad_bias = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># These needs_input_grad checks are optional and there only to</span></span><br><span class="line">        <span class="comment"># improve efficiency. If you want to make your code simpler, you can</span></span><br><span class="line">        <span class="comment"># skip them. Returning gradients for inputs that don&#x27;t require it is</span></span><br><span class="line">        <span class="comment"># not an error.</span></span><br><span class="line">        <span class="keyword">if</span> ctx.needs_input_grad[<span class="number">0</span>]:</span><br><span class="line">            grad_input = grad_output.mm(weight)</span><br><span class="line">        <span class="keyword">if</span> ctx.needs_input_grad[<span class="number">1</span>]:</span><br><span class="line">            grad_weight = grad_output.t().mm(<span class="built_in">input</span>)</span><br><span class="line">        <span class="keyword">if</span> bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> ctx.needs_input_grad[<span class="number">2</span>]:</span><br><span class="line">            grad_bias = grad_output.<span class="built_in">sum</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> grad_input, grad_weight, grad_bias</span><br></pre></td></tr></table></figure><p>上面这个例子已经写得很好了.为了更方便地使用这些自定义操作，<strong>建议将它们别名或封装在一个函数中。</strong>使用函数封装可以让我们支持默认参数和关键字参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Option 1: alias</span></span><br><span class="line">linear = LinearFunction.apply</span><br><span class="line"></span><br><span class="line"><span class="comment"># Option 2: wrap in a function, to support default args and keyword args.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear</span>(<span class="params"><span class="built_in">input</span>, weight, bias=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> LinearFunction.apply(<span class="built_in">input</span>, weight, bias)</span><br></pre></td></tr></table></figure><p>此外还有输入没有tensor的情况,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MulConstant</span>(<span class="params">Function</span>):</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">tensor, constant</span>):</span></span><br><span class="line">        <span class="keyword">return</span> tensor * constant</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup_context</span>(<span class="params">ctx, inputs, output</span>):</span></span><br><span class="line">        <span class="comment"># ctx is a context object that can be used to stash information</span></span><br><span class="line">        <span class="comment"># for backward computation</span></span><br><span class="line">        tensor, constant = inputs</span><br><span class="line">        ctx.constant = constant <span class="comment"># 注意这里直接使用ctx.xx = xx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">ctx, grad_output</span>):</span></span><br><span class="line">        <span class="comment"># We return as many input gradients as there were arguments.</span></span><br><span class="line">        <span class="comment"># Gradients of non-Tensor arguments to forward must be None.</span></span><br><span class="line">        <span class="keyword">return</span> grad_output * ctx.constant, <span class="literal">None</span></span><br><span class="line">  <span class="comment"># 上面代码可以改为 使用set_materialize_grads,因为计算梯度不需要tensor.</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MulConstant</span>(<span class="params">Function</span>):</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">tensor, constant</span>):</span></span><br><span class="line">        <span class="keyword">return</span> tensor * constant</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup_context</span>(<span class="params">ctx, inputs, output</span>):</span></span><br><span class="line">        tensor, constant = inputs</span><br><span class="line">        ctx.set_materialize_grads(<span class="literal">False</span>)</span><br><span class="line">        ctx.constant = constant</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">ctx, grad_output</span>):</span></span><br><span class="line">        <span class="comment"># Here we must handle None grad_output tensor. In this case we</span></span><br><span class="line">        <span class="comment"># can skip unnecessary computations and just return None.</span></span><br><span class="line">        <span class="keyword">if</span> grad_output <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># We return as many input gradients as there were arguments.</span></span><br><span class="line">        <span class="comment"># Gradients of non-Tensor arguments to forward must be None.</span></span><br><span class="line">        <span class="keyword">return</span> grad_output * ctx.constant, <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>如果需要保存在 forward() 中计算的任何 “中间 “张量，必须将它们作为输出返回，或者将 forward 和 setup_context()合并.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCube</span>(<span class="params">torch.autograd.Function</span>):</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="comment"># We wish to save dx for backward. In order to do so, it must</span></span><br><span class="line">        <span class="comment"># be returned as an output.</span></span><br><span class="line">        dx = <span class="number">3</span> * x ** <span class="number">2</span></span><br><span class="line">        result = x ** <span class="number">3</span></span><br><span class="line">        <span class="keyword">return</span> result, dx</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup_context</span>(<span class="params">ctx, inputs, output</span>):</span></span><br><span class="line">        x, = inputs</span><br><span class="line">        result, dx = output</span><br><span class="line">        ctx.save_for_backward(x, dx)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">ctx, grad_output, grad_dx</span>):</span></span><br><span class="line">        x, dx = ctx.saved_tensors</span><br><span class="line">        <span class="comment"># In order for the autograd.Function to work with higher-order</span></span><br><span class="line">        <span class="comment"># gradients, we must add the gradient contribution of `dx`,</span></span><br><span class="line">        <span class="comment"># which is grad_dx * 6 * x.</span></span><br><span class="line">        result = grad_output * dx + grad_dx * <span class="number">6</span> * x</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># Wrap MyCube in a function so that it is clearer what the output is</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_cube</span>(<span class="params">x</span>):</span></span><br><span class="line">    result, dx = MyCube.apply(x)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>将forward和setup_context合在一起</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearFunction</span>(<span class="params">Function</span>):</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="comment"># ctx is the first argument to forward</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">ctx, <span class="built_in">input</span>, weight, bias=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="comment"># The forward pass can use ctx.</span></span><br><span class="line">        ctx.save_for_backward(<span class="built_in">input</span>, weight, bias)</span><br><span class="line">        output = <span class="built_in">input</span>.mm(weight.t())</span><br><span class="line">        <span class="keyword">if</span> bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            output += bias.unsqueeze(<span class="number">0</span>).expand_as(output)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">ctx, grad_output</span>):</span></span><br><span class="line">        <span class="built_in">input</span>, weight, bias = ctx.saved_tensors</span><br><span class="line">        grad_input = grad_weight = grad_bias = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ctx.needs_input_grad[<span class="number">0</span>]:</span><br><span class="line">            grad_input = grad_output.mm(weight)</span><br><span class="line">        <span class="keyword">if</span> ctx.needs_input_grad[<span class="number">1</span>]:</span><br><span class="line">            grad_weight = grad_output.t().mm(<span class="built_in">input</span>)</span><br><span class="line">        <span class="keyword">if</span> bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> ctx.needs_input_grad[<span class="number">2</span>]:</span><br><span class="line">            grad_bias = grad_output.<span class="built_in">sum</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> grad_input, grad_weight, grad_bias</span><br></pre></td></tr></table></figure><h3 id="extending-torch-nn"><a href="#extending-torch-nn" class="headerlink" title="extending torch.nn"></a>extending torch.nn</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linear</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, input_features, output_features, bias=<span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.input_features = input_features</span><br><span class="line">        self.output_features = output_features</span><br><span class="line"></span><br><span class="line">        <span class="comment"># nn.Parameter is a special kind of Tensor, that will get</span></span><br><span class="line">        <span class="comment"># automatically registered as Module&#x27;s parameter once it&#x27;s assigned</span></span><br><span class="line">        <span class="comment"># as an attribute. Parameters and buffers need to be registered, or</span></span><br><span class="line">        <span class="comment"># they won&#x27;t appear in .parameters() (doesn&#x27;t apply to buffers), and</span></span><br><span class="line">        <span class="comment"># won&#x27;t be converted when e.g. .cuda() is called. You can use</span></span><br><span class="line">        <span class="comment"># .register_buffer() to register buffers.</span></span><br><span class="line">        <span class="comment"># nn.Parameters require gradients by default.</span></span><br><span class="line">        self.weight = nn.Parameter(torch.empty(output_features, input_features))</span><br><span class="line">        <span class="keyword">if</span> bias:</span><br><span class="line">            self.bias = nn.Parameter(torch.empty(output_features))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># You should always register all possible parameters, but the</span></span><br><span class="line">            <span class="comment"># optional ones can be None if you want.</span></span><br><span class="line">            self.register_parameter(<span class="string">&#x27;bias&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Not a very smart way to initialize weights</span></span><br><span class="line">        nn.init.uniform_(self.weight, -<span class="number">0.1</span>, <span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">if</span> self.bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            nn.init.uniform_(self.bias, -<span class="number">0.1</span>, <span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        <span class="comment"># See the autograd section for explanation of what happens here.</span></span><br><span class="line">        <span class="keyword">return</span> LinearFunction.apply(<span class="built_in">input</span>, self.weight, self.bias)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extra_repr</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># (Optional)Set the extra information about this module. You can test</span></span><br><span class="line">        <span class="comment"># it by printing an object of this class.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;input_features=&#123;&#125;, output_features=&#123;&#125;, bias=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">            self.input_features, self.output_features, self.bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>可以通过定义具有与 Tensor 匹配的方法的自定义类来创建模拟 Tensor 的自定义类型。如果自定义 Python 类型定义了名为<code>__torch_function__</code>的方法，当您的自定义类的实例<strong>被传递给 torch 命名空间中的函数时</strong>，PyTorch 将调用您的 <code>__torch_function__</code>实现。这使得为 torch 命名空间中的任何函数定义自定义实现成为可能，<code>__torch_function__</code>实现可以调用这些函数，从而允许您的用户在他们已经为 Tensor 编写的现有 PyTorch 工作流中使用您的自定义类型。</p><p>这适用于<strong>与 Tensor 无关的 “duck “类型</strong>以及 <strong>Tensor 子类</strong>。</p><h5 id="Extending-torch-Tensor-like-type"><a href="#Extending-torch-Tensor-like-type" class="headerlink" title="Extending torch Tensor-like type"></a>Extending torch Tensor-like type</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">HANDLED_FUNCTIONS = &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScalarTensor</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, N, value</span>):</span></span><br><span class="line">        self._N = N</span><br><span class="line">        self._value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ScalarTensor(N=&#123;&#125;, value=&#123;&#125;)&quot;</span>.<span class="built_in">format</span>(self._N, self._value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tensor</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._value * torch.eye(self._N)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__torch_function__</span>(<span class="params">cls, func, types, args=(<span class="params"></span>), kwargs=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> kwargs <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            kwargs = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> func <span class="keyword">not</span> <span class="keyword">in</span> HANDLED_FUNCTIONS <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">all</span>(</span><br><span class="line">            <span class="built_in">issubclass</span>(t, (torch.Tensor, ScalarTensor))</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> types</span><br><span class="line">        ):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br><span class="line">        <span class="keyword">return</span> HANDLED_FUNCTIONS[func](*args, **kwargs)</span><br></pre></td></tr></table></figure><p>为 ScalarTensor 添加 <code>__torch_function__</code> 实现后,上述操作就有可能成功.这次添加一个<code>__torch_function__</code> 实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">HANDLED_FUNCTIONS = &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScalarTensor</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, N, value</span>):</span></span><br><span class="line">        self._N = N</span><br><span class="line">        self._value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ScalarTensor(N=&#123;&#125;, value=&#123;&#125;)&quot;</span>.<span class="built_in">format</span>(self._N, self._value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tensor</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._value * torch.eye(self._N)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__torch_function__</span>(<span class="params">cls, func, types, args=(<span class="params"></span>), kwargs=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> kwargs <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            kwargs = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> func <span class="keyword">not</span> <span class="keyword">in</span> HANDLED_FUNCTIONS <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">all</span>(</span><br><span class="line">            <span class="built_in">issubclass</span>(t, (torch.Tensor, ScalarTensor))</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> types</span><br><span class="line">        ):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br><span class="line">        <span class="keyword">return</span> HANDLED_FUNCTIONS[func](*args, **kwargs)</span><br></pre></td></tr></table></figure><p><code>__torch_function__</code>方法需要四个参数:func,对要重载的 torch API 函数的引用；types，实现 <code>__torch_function__</code>的 Tensor-likes 类型列表；args,传递给函数的参数元组；kwargs,传递给函数的关键字参数 dict,它使用名为 HANDLED_FUNCTIONS 的全局调度表来存储自定义实现.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">implements</span>(<span class="params">torch_function</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Register a torch function override for ScalarTensor&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">        functools.update_wrapper(func, torch_function)</span><br><span class="line">        HANDLED_FUNCTIONS[torch_function] = func</span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@implements(<span class="params">torch.mean</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mean</span>(<span class="params"><span class="built_in">input</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float</span>(<span class="built_in">input</span>._value) / <span class="built_in">input</span>._N</span><br><span class="line"></span><br><span class="line">d = ScalarTensor(<span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">torch.mean(d)</span><br></pre></td></tr></table></figure><p>从 1.7.0 版开始，应用于 torch.Tensor 子类的 <strong>torch.Tensor 方法</strong>和<strong>公共 torch.* 命名空间中的函数</strong>将返回子类实例，而不是 torch.Tensor 实例.</p><p>如果希望对所有张量方法进行全局覆盖,可以使用<code>__torch_function__</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingTensor</span>(<span class="params">torch.Tensor</span>):</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__torch_function__</span>(<span class="params">cls, func, types, args=(<span class="params"></span>), kwargs=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="comment"># <span class="doctag">NOTE:</span> Logging calls Tensor.__repr__, so we can&#x27;t log __repr__ without infinite recursion</span></span><br><span class="line">        <span class="keyword">if</span> func <span class="keyword">is</span> <span class="keyword">not</span> torch.Tensor.__repr__:</span><br><span class="line">            logging.info(<span class="string">f&quot;func: <span class="subst">&#123;func.__name__&#125;</span>, args: <span class="subst">&#123;args!r&#125;</span>, kwargs: <span class="subst">&#123;kwargs!r&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> kwargs <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            kwargs = &#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__torch_function__(func, types, args, kwargs)</span><br></pre></td></tr></table></figure><p>在子类的<code>__torch_function__</code> 中应注意始终调用 super().<strong>torch_function</strong>(func,…)，而不是直接调用 func。如果不这样做，可能会导致 func 返回到 <code>__torch_function__</code>中，从而引起无限递归。</p><h2 id="torch-autograd"><a href="#torch-autograd" class="headerlink" title="torch.autograd"></a>torch.autograd</h2><p>torch.autograd 提供了实现任意标量值函数自动微分的类和函数.</p><p>它只需对现有代码做极少的改动—你只需用 requires_grad=True 关键字声明需要计算梯度的张量.</p><p>目前只持浮点张量类型（半浮点、浮点、双浮点和 bfloat16）和复合张量类型（cfloat、cdouble）的 autograd.</p><h3 id="detach-计算图与leaf-tensor"><a href="#detach-计算图与leaf-tensor" class="headerlink" title="detach 计算图与leaf tensor"></a>detach 计算图与leaf tensor</h3><p><code>Tensor.detach()</code>返回一个从当前计算图中分离出来的新张量,生成的张量永远不需要梯度,目前替代了<code>.data</code>方法.</p><p> PyTorch 中,计算图(Computation Graph)是一个非常重要的概念.它是一种用于表示和执行机器学习模型的数据结构.</p><p>具体来说,PyTorch 中的计算图由以下几个关键组件组成:</p><ol><li><strong>张量(Tensor)</strong>:计算图的基本单元,表示输入数据、中间结果和最终输出.</li><li><strong>操作(Operation)</strong>:在张量上执行的各种数学运算,如加法、乘法、卷积等.</li><li><strong>节点(Node)</strong>:表示张量和操作,计算图由这些节点组成.</li><li><strong>边(Edge)</strong>:表示节点之间的依赖关系,数据沿着边流动.</li></ol><p>当在 PyTorch 中定义和执行机器学习模型时,PyTorch 会自动构建一个计算图来表示模型的结构和数据流.这个计算图可以用于以下几个方面:</p><ol><li><strong>前向传播</strong>:通过计算图,PyTorch 可以自动计算模型的输出.</li><li><strong>反向传播</strong>:当您调用 <code>loss.backward()</code> 时,PyTorch 会沿着计算图反向传播梯度,从而更新模型参数.</li><li><strong>可视化</strong>:您可以使用 PyTorch 提供的工具(如 TensorBoard)来可视化计算图,更好地理解模型的结构.</li><li><strong>优化</strong>:PyTorch 的优化器会利用计算图的结构来提高优化效率.</li></ol><p>detach使得tensor从计算图中分离具体是什么含义?简单来说,使得它本身requires_grad=False,它之前的计算也被阻断了.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span> = torch.randn(<span class="number">1</span>, <span class="number">20</span>, <span class="number">10</span>)</span><br><span class="line">model = nn.Linear(<span class="number">10</span>, <span class="number">3</span>)</span><br><span class="line">inter = model(<span class="built_in">input</span>)</span><br><span class="line">model2 = nn.Linear(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">output = model2(inter.detach())</span><br><span class="line">loss = torch.mean(output - <span class="number">1</span>)</span><br><span class="line">loss.backward()</span><br><span class="line"><span class="built_in">print</span>(model.weight.grad) <span class="comment"># None</span></span><br></pre></td></tr></table></figure><p>按照惯例,所有<strong>requires_grad 为False的张量都是leaf tensor</strong>.</p><p>对于<strong>requires_grad 为 True 的张量,如果它们是由用户创建(没有经过计算,包括移动到GPU的操作)的,那么它们将是叶子张量</strong>.这意味着它们不是操作的结果,因此 grad_fn 为 None.</p><p>只有叶子张量才会在调用 backward() 时被填充梯度.要为非叶子张量填充阶值,可以使用 retain_grad().</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xx = torch.randn(<span class="number">1</span>, <span class="number">3</span>).requires_grad_(<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(xx.grad_fn, xx.is_leaf) <span class="comment"># None,True</span></span><br><span class="line">model = nn.Linear(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">output = model(xx)</span><br><span class="line">loss = torch.mean(output - <span class="number">1</span>)</span><br><span class="line">loss.backward()</span><br><span class="line"><span class="built_in">print</span>(xx.grad_fn, xx.grad) <span class="comment"># None,tensor([[.., ..,  ..]])</span></span><br><span class="line"><span class="built_in">print</span>(model.weight.grad_fn, model.weight.grad) <span class="comment"># None,,tensor([[.., ..,  ..]])</span></span><br><span class="line"><span class="built_in">print</span>(model.bias.grad_fn, model.bias.grad) <span class="comment"># None,tensor([1])</span></span><br><span class="line"><span class="built_in">print</span>(model.weight.is_leaf, model.bias.is_leaf) <span class="comment"># True,True</span></span><br></pre></td></tr></table></figure><p>只能获取计算图中叶子节点的梯度属性,这些节点的 requires_grad 属性设置为 True.对于图中的所有其他节点,梯度属性将不可用.</p><p>出于性能考虑,我们只能在给定图形上使用一次后向操作执行梯度计算.如果我们需要在同一图形上执行多次 backward 调用,则需要向 backward 调用传递 retain_graph=True 属性.</p><p>几个问题:</p><p>leaf tensor的grad_fn一定为空吗? 不一定,用户创建的requires_grad为True的tensor的grad_fn不为空</p><p>leaf tensor一定是模型输入吗?不一定,事实上直接创建一个模型,它的weight和bias也是leaf tensor</p><h3 id="属于旧时代的Variable和data"><a href="#属于旧时代的Variable和data" class="headerlink" title="属于旧时代的Variable和data"></a>属于旧时代的Variable和data</h3><p>Variable API 已被弃用:使用张量时,不再需要Variable.如果 requires_grad 设置为 True,Autograd 将自动支持张量.</p><p>Variable(tensor) 和 Variable(tensor, requires_grad) 仍按预期工作,但它们返回的是张量而不是变量.</p><p>var.data 与 tensor.data 相同.</p><p>var.backward()、var.detach()、var.register_hook() 等方法现在可以在具有相同方法名的张量上运行.</p><p>此外,现在还可以使用 torch.randn()、torch.zeros()、torch.none() 等工厂方法创建 requires_grad=True 的张量:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autograd_tensor = torch.randn((<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>api</th><th>介绍</th></tr></thead><tbody><tr><td><code>torch.Tensor.grad</code></td><td>This attribute is <code>None</code> by default and becomes a Tensor the first time a call to <a href="https://pytorch.org/docs/stable/generated/torch.autograd.backward.html#torch.autograd.backward"><code>backward()</code></a> computes gradients for <code>self</code></td></tr><tr><td><code>torch.Tensor.requires_grad</code></td><td>Is <code>True</code> if gradients need to be computed for this Tensor, <code>False</code> otherwise.</td></tr><tr><td><code>torch.Tensor.is_leaf</code></td><td>All Tensors that have <code>requires_grad</code> which is <code>False</code> will be leaf Tensors by convention.</td></tr><tr><td><code>torch.Tensor.backward</code>([gradient, …])</td><td>Computes the gradient of current tensor wrt graph leaves.</td></tr><tr><td><code>torch.Tensor.detach</code></td><td>Returns a new Tensor, detached from the current graph.</td></tr><tr><td><code>torch.Tensor.detach_</code></td><td>Detaches the Tensor from the graph that created it, making it a leaf.</td></tr><tr><td><code>torch.Tensor.register_hook</code>(hook)</td><td>Registers a backward hook.</td></tr><tr><td><code>torch.Tensor.register_post_accumulate_grad_hook</code>(hook)</td><td>Registers a backward hook that runs after grad accumulation.</td></tr><tr><td><code>torch.Tensor.retain_grad</code>()</td><td>Enables this Tensor to have their <a href="https://pytorch.org/docs/stable/generated/torch.autograd.grad.html#torch.autograd.grad"><code>grad</code></a> populated during <a href="https://pytorch.org/docs/stable/generated/torch.autograd.backward.html#torch.autograd.backward"><code>backward()</code></a>.</td></tr></tbody></table></div><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>要创建自定义 autograd.Function,请继承该类并实现 forward() 和 backward() 静态方法.然后,要在前向传递中使用自定义 op,调用类方法 apply.不要直接调用 forward().</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exp</span>(<span class="params">Function</span>):</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">ctx, i</span>):</span></span><br><span class="line">        result = i.exp()</span><br><span class="line">        ctx.save_for_backward(result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">ctx, grad_output</span>):</span></span><br><span class="line">        result, = ctx.saved_tensors</span><br><span class="line">        <span class="keyword">return</span> grad_output * result</span><br><span class="line"></span><br><span class="line">Use it by calling the apply method:</span><br><span class="line">output = Exp.apply(<span class="built_in">input</span>)</span><br></pre></td></tr></table></figure><h2 id="ONNX格式"><a href="#ONNX格式" class="headerlink" title="ONNX格式"></a>ONNX格式</h2><p>在实际部署时非常常用的模型格式,是屏蔽了框架的.</p><p><a href="https://pytorch.org/tutorials/advanced/super_resolution_with_onnxruntime.html">(optional) Exporting a Model from PyTorch to ONNX and Running it using ONNX Runtime — PyTorch Tutorials 2.3.0+cu121 documentation</a></p><h3 id="保存模型"><a href="#保存模型" class="headerlink" title="保存模型"></a>保存模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line">dummy_input = torch.randn(<span class="number">10</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>, device=<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line">model = torchvision.models.alexnet(pretrained=<span class="literal">True</span>).cuda()</span><br><span class="line"></span><br><span class="line">input_names = [ <span class="string">&quot;actual_input_1&quot;</span> ] + [ <span class="string">&quot;learned_%d&quot;</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>) ]</span><br><span class="line">output_names = [ <span class="string">&quot;output1&quot;</span> ]</span><br><span class="line"></span><br><span class="line">torch.onnx.export(model, dummy_input, <span class="string">&quot;alexnet.onnx&quot;</span>, verbose=<span class="literal">True</span>, input_names=input_names, output_names=output_names)</span><br></pre></td></tr></table></figure><p>生成的 <code>alexnet.onnx</code> 文件包含一个 <a href="https://developers.google.com/protocol-buffers/">protocol buffer</a>,其中包含了导出的模型(在本例中为 AlexNet)的网络结构和参数.<code>verbose=True</code> 参数会导致导出器打印出模型的人类可读表示.</p><h4 id="加载模型"><a href="#加载模型" class="headerlink" title="加载模型"></a>加载模型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install onnx</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> onnx</span><br><span class="line"><span class="comment"># Load the ONNX model</span></span><br><span class="line">model = onnx.load(<span class="string">&quot;alexnet.onnx&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check that the model is well formed</span></span><br><span class="line">onnx.checker.check_model(model)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print a human readable representation of the graph</span></span><br><span class="line"><span class="built_in">print</span>(onnx.helper.printable_graph(model.graph))</span><br><span class="line">You can also run the exported model <span class="keyword">with</span> one of the many runtimes that support ONNX. For example after installing ONNX Runtime, you can load <span class="keyword">and</span> run the model:</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onnxruntime <span class="keyword">as</span> ort</span><br><span class="line"></span><br><span class="line">ort_session = ort.InferenceSession(<span class="string">&quot;alexnet.onnx&quot;</span>)</span><br><span class="line"></span><br><span class="line">outputs = ort_session.run(</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    &#123;<span class="string">&quot;actual_input_1&quot;</span>: np.random.randn(<span class="number">10</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>).astype(np.float32)&#125;,</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(outputs[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># Print a human readable representation of the graph</span></span><br><span class="line"><span class="built_in">print</span>(onnx.helper.printable_graph(model.graph))</span><br></pre></td></tr></table></figure><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input to the model</span></span><br><span class="line">x = torch.randn(batch_size, <span class="number">1</span>, <span class="number">224</span>, <span class="number">224</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">torch_out = torch_model(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Export the model</span></span><br><span class="line">torch.onnx.export(torch_model,               <span class="comment"># model being run</span></span><br><span class="line">                  x,                         <span class="comment"># model input (or a tuple for multiple inputs)</span></span><br><span class="line">                  <span class="string">&quot;super_resolution.onnx&quot;</span>,   <span class="comment"># where to save the model (can be a file or file-like object)</span></span><br><span class="line">                  export_params=<span class="literal">True</span>,        <span class="comment"># store the trained parameter weights inside the model file</span></span><br><span class="line">                  opset_version=<span class="number">10</span>,          <span class="comment"># the ONNX version to export the model to</span></span><br><span class="line">                  do_constant_folding=<span class="literal">True</span>,  <span class="comment"># whether to execute constant folding for optimization</span></span><br><span class="line">                  input_names = [<span class="string">&#x27;input&#x27;</span>],   <span class="comment"># the model&#x27;s input names</span></span><br><span class="line">                  output_names = [<span class="string">&#x27;output&#x27;</span>], <span class="comment"># the model&#x27;s output names</span></span><br><span class="line">                  dynamic_axes=&#123;<span class="string">&#x27;input&#x27;</span> : &#123;<span class="number">0</span> : <span class="string">&#x27;batch_size&#x27;</span>&#125;,    <span class="comment"># variable length axes</span></span><br><span class="line">                                <span class="string">&#x27;output&#x27;</span> : &#123;<span class="number">0</span> : <span class="string">&#x27;batch_size&#x27;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>在pytorch中直接使用<code>torch.onnx.export</code>即可.</p><p>因为导出运行了模型,我们需要提供一个输入张量 <code>x</code>.这个输入的值可以是随机的,只要它的类型和大小是正确的.请注意,除非指定为dynamic_axes,否则导出的 ONNX 图中输入的所有维度大小都会被固定下来.在这个示例中,使用批量大小为 1 的输入导出模型,但在 <code>torch.onnx.export()</code> 的 <code>dynamic_axes</code> 参数中指定了第一个维度为动态的.因此,导出的模型将接受大小为 <code>[batch_size, 1, 224, 224]</code> 的输入,其中 <code>batch_size</code> 可以是可变的.</p><p>同时还计算了模型输出 <code>torch_out</code>,我们将使用它来验证在 ONNX Runtime 中运行时导出的模型是否计算出相同的值.</p><p>但在使用 ONNX Runtime 验证模型输出之前,我们会先使用 ONNX API 检查 ONNX 模型.首先,<code>onnx.load(&quot;super_resolution.onnx&quot;)</code> 会加载保存的模型,并输出一个 <code>onnx.ModelProto</code> 结构.然后,<code>onnx.checker.check_model(onnx_model)</code> 会验证模型的结构,并确认模型具有有效的架构.通过检查模型的版本、图结构以及节点及其输入和输出,来验证 ONNX 图的有效性.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> onnx</span><br><span class="line">onnx_model = onnx.load(<span class="string">&quot;super_resolution.onnx&quot;</span>)</span><br><span class="line">onnx.checker.check_model(onnx_model)</span><br></pre></td></tr></table></figure><p>使用 ONNX Runtime 的 Python API 计算输出,通常情况下,这一部分可以在单独的进程中或其他机器上完成,但我们将继续在同一进程中进行,这样我们就可以验证 ONNX Runtime 和 PyTorch 为该网络计算出的值是否相同.</p><p>为了使用 ONNX Runtime 运行模型,我们需要为模型创建一个InferenceSession,并设置所需的配置参数(这里我们使用默认配置).创建会话后,我们就可以使用 <code>run()</code> API 来评估模型了.该调用的输出是一个列表,包含 ONNX Runtime 计算得出的模型输出.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> onnxruntime</span><br><span class="line"></span><br><span class="line">ort_session = onnxruntime.InferenceSession(<span class="string">&quot;super_resolution.onnx&quot;</span>, providers=[<span class="string">&quot;CPUExecutionProvider&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_numpy</span>(<span class="params">tensor</span>):</span></span><br><span class="line">    <span class="keyword">return</span> tensor.detach().cpu().numpy() <span class="keyword">if</span> tensor.requires_grad <span class="keyword">else</span> tensor.cpu().numpy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># compute ONNX Runtime output prediction</span></span><br><span class="line">ort_inputs = &#123;ort_session.get_inputs()[<span class="number">0</span>].name: to_numpy(x)&#125;</span><br><span class="line">ort_outs = ort_session.run(<span class="literal">None</span>, ort_inputs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># compare ONNX Runtime and PyTorch results</span></span><br><span class="line">np.testing.assert_allclose(to_numpy(torch_out), ort_outs[<span class="number">0</span>], rtol=<span class="number">1e-03</span>, atol=<span class="number">1e-05</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Exported model has been tested with ONNXRuntime, and the result looks good!&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>在模型中避免使用numpy,tensor.data,tensor.shape不能使用in_place操作</p><h2 id="自动混合精度"><a href="#自动混合精度" class="headerlink" title="自动混合精度"></a>自动混合精度</h2><p>torch.amp 为混合精度提供了方便的方法,其中一些操作使用 torch.float32 （浮点）数据类型,另一些操作使用较低精度的浮点数据类型 (lower_precision_fp):torch.float16（半精度）或 torch.bfloat16.一些操作,如线性层和卷积,在 lower_precision_fp 下速度更快.其他操作,如还原,通常需要 float32 的动态范围.混合精度试图将每个操作与相应的数据类型相匹配.</p><p>通常,数据类型为 torch.float16 的 “自动混合精度训练 “使用 torch.autocast 和 torch.cpu.amp.GradScaler 或 torch.cuda.amp.GradScaler.</p><p>torch.autocast 实例可对所选上下文进行自动casting.自动cast会自动选择 GPU 运算的精度,从而在保持精度的同时提高性能.</p><p>torch.cuda.amp.GradScaler 的实例有助于方便地执行梯度缩放步骤.<strong>梯度缩放可最大限度地减少梯度下溢</strong>,从而改善具有 float16 梯度的网络的收敛性.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Creates model and optimizer in default precision</span></span><br><span class="line">model = Net().cuda()</span><br><span class="line">optimizer = optim.SGD(model.parameters(), ...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates a GradScaler once at the beginning of training.</span></span><br><span class="line">scaler = GradScaler()  <span class="comment"># 1. 创建gradscaler</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> epochs:</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">input</span>, target <span class="keyword">in</span> data:</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Runs the forward pass with autocasting.</span></span><br><span class="line">        <span class="comment"># 2.使得模型训练时相关参数类型自动转换</span></span><br><span class="line">        <span class="keyword">with</span> autocast(device_type=<span class="string">&#x27;cuda&#x27;</span>, dtype=torch.float16):</span><br><span class="line">            output = model(<span class="built_in">input</span>)</span><br><span class="line">            loss = loss_fn(output, target)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Scales loss.  Calls backward() on scaled loss to create scaled gradients.</span></span><br><span class="line">        <span class="comment"># Backward passes under autocast are not recommended.</span></span><br><span class="line">        <span class="comment"># Backward ops run in the same dtype autocast chose for corresponding forward ops.</span></span><br><span class="line">        scaler.scale(loss).backward()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># scaler.step() first unscales the gradients of the optimizer&#x27;s assigned params.</span></span><br><span class="line">        <span class="comment"># If these gradients do not contain infs or NaNs, optimizer.step() is then called,</span></span><br><span class="line">        <span class="comment"># otherwise, optimizer.step() is skipped.</span></span><br><span class="line">        scaler.step(optimizer)   </span><br><span class="line">        <span class="comment"># Updates the scale for next iteration.</span></span><br><span class="line">        scaler.update()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Creates model and optimizer in default precision</span></span><br><span class="line">model = Net().cuda()</span><br><span class="line">optimizer = optim.SGD(model.parameters(), ...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">input</span>, target <span class="keyword">in</span> data:</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Enables autocasting for the forward pass (model + loss)</span></span><br><span class="line">    <span class="keyword">with</span> torch.autocast(device_type=<span class="string">&quot;cuda&quot;</span>):</span><br><span class="line">        output = model(<span class="built_in">input</span>)</span><br><span class="line">        loss = loss_fn(output, target)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Exits the context manager before backward()</span></span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure><p>所有由 scaler.scale(loss).backward() 生成的梯度都是按比例缩放的.如果要在 backward() 和 scaler.step(optimizer) 之间修改或检查参数的 .grad 属性,应首先取消缩放.</p><p><strong>梯度惩罚</strong></p><p>梯度惩罚的实现通常使用 torch.autograd.grad() 创建梯度,将它们组合起来创建惩罚值,并将惩罚值添加到损失中.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> epochs:</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">input</span>, target <span class="keyword">in</span> data:</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = model(<span class="built_in">input</span>)</span><br><span class="line">        loss = loss_fn(output, target)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Creates gradients</span></span><br><span class="line">        grad_params = torch.autograd.grad(outputs=loss,</span><br><span class="line">                                          inputs=model.parameters(),</span><br><span class="line">                                          create_graph=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Computes the penalty term and adds it to the loss</span></span><br><span class="line">        grad_norm = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> grad <span class="keyword">in</span> grad_params:</span><br><span class="line">            grad_norm += grad.<span class="built_in">pow</span>(<span class="number">2</span>).<span class="built_in">sum</span>()</span><br><span class="line">        grad_norm = grad_norm.sqrt()</span><br><span class="line">        loss = loss + grad_norm</span><br><span class="line"></span><br><span class="line">        loss.backward()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># clip gradients here, if desired</span></span><br><span class="line"></span><br><span class="line">        optimizer.step()</span><br></pre></td></tr></table></figure><p>要通过梯度缩放实现梯度惩罚,应缩放传递给 torch.autograd.grad() 的输出张量.因此,生成的梯度也将被缩放,在合并生成惩罚值之前应取消缩放.</p><p>此外,惩罚项的计算是前向传递的一部分,因此应在自动传递上下文中进行.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">scaler = torch.cuda.amp.GradScaler()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> epochs:</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">input</span>, target <span class="keyword">in</span> data:</span><br><span class="line">        optimizer0.zero_grad()</span><br><span class="line">        optimizer1.zero_grad()</span><br><span class="line">        <span class="keyword">with</span> autocast(device_type=<span class="string">&#x27;cuda&#x27;</span>, dtype=torch.float16):</span><br><span class="line">            output0 = model0(<span class="built_in">input</span>)</span><br><span class="line">            output1 = model1(<span class="built_in">input</span>)</span><br><span class="line">            loss0 = loss_fn(<span class="number">2</span> * output0 + <span class="number">3</span> * output1, target)</span><br><span class="line">            loss1 = loss_fn(<span class="number">3</span> * output0 - <span class="number">5</span> * output1, target)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># (retain_graph here is unrelated to amp, it&#x27;s present because in this</span></span><br><span class="line">        <span class="comment"># example, both backward() calls share some sections of graph.)</span></span><br><span class="line">        scaler.scale(loss0).backward(retain_graph=<span class="literal">True</span>)</span><br><span class="line">        scaler.scale(loss1).backward()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># You can choose which optimizers receive explicit unscaling, if you</span></span><br><span class="line">        <span class="comment"># want to inspect or modify the gradients of the params they own.</span></span><br><span class="line">        scaler.unscale_(optimizer0)</span><br><span class="line"></span><br><span class="line">        scaler.step(optimizer0)</span><br><span class="line">        scaler.step(optimizer1)</span><br><span class="line"></span><br><span class="line">        scaler.update()</span><br></pre></td></tr></table></figure><p>如果网络有多个损失,则必须对每个损耗单独调用 scaler.scale.如果的网络有多个优化器,您可以在任何一个优化器上单独调用 scaler.unscale_,并且必须在每个优化器上单独调用 scaler.step.</p><p>autocast不在在 float64 或非浮点类型上进行转换.。为了获得最佳性能和稳定性,在autocast区域中使用out-of-place运算,也就是使用类似a.addmm(b, c)这种操作.</p><p>autocast会将with下的区域中的运算自动转换,自动转发应只包含网络的前向传递，包括损失计算。 </p><p>不建议使用自动转发的后向传递. 后向操作的运算类型是autocast之前的类型.</p><h4 id="cuda上会转为float16的运算"><a href="#cuda上会转为float16的运算" class="headerlink" title="cuda上会转为float16的运算"></a>cuda上会转为float16的运算</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__matmul__`, `addbmm`, `addmm`, `addmv`, `addr`, `baddbmm`, `bmm`, `chain_matmul`, `multi_dot`, `conv1d`, `conv2d`, `conv3d`, `conv_transpose1d`, `conv_transpose2d`, `conv_transpose3d`, `GRUCell`, `linear`, `LSTMCell`, `matmul`, `mm`, `mv`, `prelu`, `RNNCell</span><br></pre></td></tr></table></figure><h4 id="cuda上会转为float32的运算"><a href="#cuda上会转为float32的运算" class="headerlink" title="cuda上会转为float32的运算"></a>cuda上会转为float32的运算</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__pow__`, `__rdiv__`, `__rpow__`, `__rtruediv__`, `acos`, `asin`, `binary_cross_entropy_with_logits`, `cosh`, `cosine_embedding_loss`, `cdist`, `cosine_similarity`, `cross_entropy`, `cumprod`, `cumsum`, `dist`, `erfinv`, `exp`, `expm1`, `group_norm`, `hinge_embedding_loss`, `kl_div`, `l1_loss`, `layer_norm`, `log`, `log_softmax`, `log10`, `log1p`, `log2`, `margin_ranking_loss`, `mse_loss`, `multilabel_margin_loss`, `multi_margin_loss`, `nll_loss`, `norm`, `normalize`, `pdist`, `poisson_nll_loss`, `<span class="built_in">pow</span>`, `prod`, `reciprocal`, `rsqrt`, `sinh`, `smooth_l1_loss`, `soft_margin_loss`, `softmax`, `softmin`, `softplus`, `<span class="built_in">sum</span>`, `renorm`, `tan`, `triplet_margin_loss</span><br></pre></td></tr></table></figure><p>还有一些运算需要多个输入,如果输入全是float32那输出就是float32.也就是promote to the widest input type</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addcdiv`, `addcmul`, `atan2`, `bilinear`, `cross`, `dot`, `grid_sample`, `index_put`, `scatter_add`, `tensordot</span><br></pre></td></tr></table></figure><h4 id="CPU上会转为bfloat16的运算"><a href="#CPU上会转为bfloat16的运算" class="headerlink" title="CPU上会转为bfloat16的运算"></a>CPU上会转为bfloat16的运算</h4><p>bfloat是比较特殊的数据类型,是针对深度学习运算特别调整指数位和小数位,使得相对于同等位数的float,其精度更小,但能表示的值范围更大,而且针对显卡运算更快(显卡厂商调整了)</p><div class="table-container"><table><thead><tr><th>Format</th><th>Bits</th><th>Exponent</th><th>Fraction</th><th>sign(符号)</th></tr></thead><tbody><tr><td>FP32</td><td>32</td><td>8</td><td>23</td><td>1</td></tr><tr><td>FP16</td><td>16</td><td>5</td><td>10</td><td>1</td></tr><tr><td>BF16</td><td>16</td><td>8</td><td>7</td><td>1</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conv1d`, `conv2d`, `conv3d`, `bmm`, `mm`, `baddbmm`, `addmm`, `addbmm`, `linear`, `matmul`, `_convolution</span><br></pre></td></tr></table></figure><h4 id="CPU上会转为bfloat32的运算"><a href="#CPU上会转为bfloat32的运算" class="headerlink" title="CPU上会转为bfloat32的运算"></a>CPU上会转为bfloat32的运算</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conv_transpose1d, conv_transpose2d, conv_transpose3d, avg_pool3d, binary_cross_entropy, grid_sampler, grid_sampler_2d, _grid_sampler_2d_cpu_fallback, grid_sampler_3d, polar, prod, quantile, nanquantile, stft, cdist, trace, view_as_complex, cholesky, cholesky_inverse, cholesky_solve, inverse, lu_solve, orgqr, inverse, ormqr, pinverse, max_pool3d, max_unpool2d, max_unpool3d, adaptive_avg_pool3d, reflection_pad1d, reflection_pad2d, replication_pad1d, replication_pad2d, replication_pad3d, mse_loss, ctc_loss, kl_div, multilabel_margin_loss, fft_fft, fft_ifft, fft_fft2, fft_ifft2, fft_fftn, fft_ifftn, fft_rfft, fft_irfft, fft_rfft2, fft_irfft2, fft_rfftn, fft_irfftn, fft_hfft, fft_ihfft, linalg_matrix_norm, linalg_cond, linalg_matrix_rank, linalg_solve, linalg_cholesky, linalg_svdvals, linalg_eigvals, linalg_eigvalsh, linalg_inv, linalg_householder_product, linalg_tensorinv, linalg_tensorsolve, fake_quantize_per_tensor_affine, eig, geqrf, lstsq, _lu_with_info, qr, solve, svd, symeig, triangular_solve, fractional_max_pool2d, fractional_max_pool3d, adaptive_max_pool3d, multilabel_margin_loss_forward, linalg_qr, linalg_cholesky_ex, linalg_svd, linalg_eig, linalg_eigh, linalg_lstsq, linalg_inv_ex</span><br></pre></td></tr></table></figure><p>类似的,cpu上也有promote to the widest input type的运算.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat, stack, index_copy</span><br></pre></td></tr></table></figure><h2 id="单机器-多GPU-训练最佳实践"><a href="#单机器-多GPU-训练最佳实践" class="headerlink" title="单机器(多GPU)训练最佳实践"></a>单机器(多GPU)训练最佳实践</h2><p>如果有多个GPU,每个GPU上运行复制的权重相同的模型,数据分发到多个GPU上,这样就能加快训练.但是有些使用一个GPU上容不下一个完整的模型,这个时候,将一个模型拆到不同的GPU上就是一个可行的方案.</p><p>这里就要提到model parallel(模型并行),模型并行是将一个模型的不同子网络放到不同的设备上,并相应地forward,以便在设备间移动中间输出.</p><blockquote><p>如果是跨机器,可以通过RPC<a href="https://pytorch.org/tutorials/intermediate/rpc_tutorial.html">Getting Started with Distributed RPC Framework — PyTorch Tutorials 2.3.0+cu121 documentation</a></p></blockquote><p>一个简单的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToyModel</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(ToyModel, self).__init__()</span><br><span class="line">        self.net1 = torch.nn.Linear(<span class="number">10</span>, <span class="number">10</span>).to(<span class="string">&#x27;cuda:0&#x27;</span>)</span><br><span class="line">        self.relu = torch.nn.ReLU()</span><br><span class="line">        self.net2 = torch.nn.Linear(<span class="number">10</span>, <span class="number">5</span>).to(<span class="string">&#x27;cuda:1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.relu(self.net1(x.to(<span class="string">&#x27;cuda:0&#x27;</span>)))</span><br><span class="line">        <span class="keyword">return</span> self.net2(x.to(<span class="string">&#x27;cuda:1&#x27;</span>))</span><br><span class="line">model = ToyModel()</span><br><span class="line">loss_fn = nn.MSELoss()</span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">optimizer.zero_grad()</span><br><span class="line">outputs = model(torch.randn(<span class="number">20</span>, <span class="number">10</span>))</span><br><span class="line">labels = torch.randn(<span class="number">20</span>, <span class="number">5</span>).to(<span class="string">&#x27;cuda:1&#x27;</span>)</span><br><span class="line">loss_fn(outputs, labels).backward()</span><br><span class="line">optimizer.step()</span><br></pre></td></tr></table></figure><p>把模型不同部分放在了不同GPU上,并且forward时把数据也放在对应位置.注意计算损失时,label也要放对应位置.</p><p>只需修改几行代码，就可以在多个 GPU 上运行现有的单 GPU 模块.继承现有的 ResNet 模块,并在构建过程中将各层拆分到两个 GPU.然后,覆盖forward方法,通过相应移动中间输出来缝合两个子网络.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision.models.resnet <span class="keyword">import</span> ResNet, Bottleneck</span><br><span class="line"></span><br><span class="line">num_classes = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelParallelResNet50</span>(<span class="params">ResNet</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(ModelParallelResNet50, self).__init__(</span><br><span class="line">            Bottleneck, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>], num_classes=num_classes, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">        self.seq1 = nn.Sequential(</span><br><span class="line">            self.conv1,</span><br><span class="line">            self.bn1,</span><br><span class="line">            self.relu,</span><br><span class="line">            self.maxpool,</span><br><span class="line"></span><br><span class="line">            self.layer1,</span><br><span class="line">            self.layer2</span><br><span class="line">        ).to(<span class="string">&#x27;cuda:0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.seq2 = nn.Sequential(</span><br><span class="line">            self.layer3,</span><br><span class="line">            self.layer4,</span><br><span class="line">            self.avgpool,</span><br><span class="line">        ).to(<span class="string">&#x27;cuda:1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.fc.to(<span class="string">&#x27;cuda:1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.seq2(self.seq1(x).to(<span class="string">&#x27;cuda:1&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> self.fc(x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>最后做了相关实验,发现在多个GPU上模型并行执行时间更长,因为多个 GPU 中只有一个在工作，而其他的也不做,同时数据从不同GPU中复制时也需要时间.</p><p><img data-src="https://pytorch.org/tutorials/_images/mp_vs_rn.png" alt="img"></p><h2 id="多GPU训练"><a href="#多GPU训练" class="headerlink" title="多GPU训练"></a>多GPU训练</h2><h4 id="并行方案"><a href="#并行方案" class="headerlink" title="并行方案"></a>并行方案</h4><p><code>DataParallel</code>是单进程、多线程的,只能在单台机器上(可以多GPU)运行,而 <code>DistributedDataParallel</code> 是多进程的,可以在单台和多台机器上运行.</p><p>即使在单台机器上,DataParallel 通常也比 DistributedDataParallel 慢,这是因为线程间的 GIL 竞争、每次迭代的复制模型，以及分散输入和收集输出所带来的额外开销.</p><blockquote><p>实际为了方便,完全可以仅使用DataParaller在多GPU上运行.</p></blockquote><div class="table-container"><table><thead><tr><th>DataParallel</th><th>disc</th></tr></thead><tbody><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.DataParallel.html#torch.nn.DataParallel"><code>nn.DataParallel</code></a></td><td>Implements data parallelism at the module level.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel"><code>nn.parallel.DistributedDataParallel</code></a></td><td>Implement distributed data parallelism based on <code>torch.distributed</code> at module level.</td></tr></tbody></table></div><p>模型并行:如果模型太大,无法在单个 GPU 上运行,就必须使用模型并行功能将其分割到多个 GPU 上.</p><p>分布式数据并行（DistributedDataParallel,DDP）可与模型并行一起使用，而数据并行（DataParallel）目前还不能。当 DDP 与模型并行相结合时,每个 DDP 进程都将使用模型并行,而所有进程都将使用数据并行。</p><p>多GPU训练有每个GPU一个线程</p><p><code>torch.nn.DataParallel</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">model = MyModel()</span><br><span class="line">dp_model = nn.DataParallel(model)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets autocast in the main thread</span></span><br><span class="line"><span class="keyword">with</span> autocast(device_type=<span class="string">&#x27;cuda&#x27;</span>, dtype=torch.float16):</span><br><span class="line">    <span class="comment"># dp_model&#x27;s internal threads will autocast.</span></span><br><span class="line">    output = dp_model(<span class="built_in">input</span>)</span><br><span class="line">    <span class="comment"># loss_fn also autocast</span></span><br><span class="line">    loss = loss_fn(output)</span><br></pre></td></tr></table></figure><p>上面方法是最简单的弊端是后续的loss计算只会在<code>cuda:0</code>上进行,没法并行,因此会导致负载不均衡的问题</p><p>文档推荐使用<code>DistributedDataParallel</code></p><blockquote><p>为什么尽管增加了复杂性,还是会考虑使用 DistributedDataParallel 而不是 DataParallel:</p><p>首先,DataParallel 是单进程、多线程的,只能在单机上运行,而 <strong>DistributedDataParallel 是多进程的,可以在单机和多机训练中运行.即使在单台机器上,DataParallel 通常也比 DistributedDataParallel 慢,这是由于线程间的 GIL 竞争、每次迭代的复制模型,以及分散输入和收集输出所带来的额外开销.</strong></p><p>分布式数据并行（DistributedDataParallel）可与模型并行一起使用,而数据并行（DataParallel）目前还不能.当 DDP 与模型并行相结合时,每个 DDP 进程都将使用模型并行,而所有进程都将使用数据并行.</p><p>如果模型需要跨越多台机器,或者您的用例不符合数据并行模式,请使用RPC API,以通用的分布式训练.</p></blockquote><p>在模块级基于 torch.distributed 实现分布式数据并行.<br>该容器通过在每个模型副本之间同步梯度来提供数据并行性.要同步的设备由输入 process_group 指定,默认情况下是整个世界.请注意,DistributedDataParallel 不会在参与的 GPU 之间对输入进行分块或分片；用户负责定义如何进行分块或分片,例如通过使用 DistributedSampler.</p><p>此外需要进行初始化 torch.distributed.init_process_group()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.distributed <span class="keyword">as</span> dist</span><br><span class="line"><span class="keyword">import</span> torch.multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> torch.nn.parallel <span class="keyword">import</span> DistributedDataParallel <span class="keyword">as</span> DDP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">example</span>(<span class="params">rank, world_size</span>):</span></span><br><span class="line">    <span class="comment"># create default process group</span></span><br><span class="line">    dist.init_process_group(<span class="string">&quot;gloo&quot;</span>, rank=rank, world_size=world_size)</span><br><span class="line">    <span class="comment"># create local model</span></span><br><span class="line">    model = nn.Linear(<span class="number">10</span>, <span class="number">10</span>).to(rank)</span><br><span class="line">    <span class="comment"># construct DDP model</span></span><br><span class="line">    ddp_model = DDP(model, device_ids=[rank])</span><br><span class="line">    <span class="comment"># define loss function and optimizer</span></span><br><span class="line">    loss_fn = nn.MSELoss()</span><br><span class="line">    optimizer = optim.SGD(ddp_model.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># forward pass</span></span><br><span class="line">    outputs = ddp_model(torch.randn(<span class="number">20</span>, <span class="number">10</span>).to(rank))</span><br><span class="line">    labels = torch.randn(<span class="number">20</span>, <span class="number">10</span>).to(rank)</span><br><span class="line">    <span class="comment"># backward pass</span></span><br><span class="line">    loss_fn(outputs, labels).backward()</span><br><span class="line">    <span class="comment"># update parameters</span></span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    world_size = <span class="number">2</span></span><br><span class="line">    mp.spawn(example,</span><br><span class="line">        args=(world_size,),</span><br><span class="line">        nprocs=world_size,</span><br><span class="line">        join=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># Environment variables which need to be</span></span><br><span class="line">    <span class="comment"># set when using c10d&#x27;s default &quot;env&quot;</span></span><br><span class="line">    <span class="comment"># initialization mode.</span></span><br><span class="line">    os.environ[<span class="string">&quot;MASTER_ADDR&quot;</span>] = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">    os.environ[<span class="string">&quot;MASTER_PORT&quot;</span>] = <span class="string">&quot;29500&quot;</span></span><br><span class="line">    main()                                  </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo_model_parallel</span>(<span class="params">rank, world_size</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Running DDP with model parallel example on rank <span class="subst">&#123;rank&#125;</span>.&quot;</span>)</span><br><span class="line">    setup(rank, world_size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># setup mp_model and devices for this process</span></span><br><span class="line">    dev0 = rank * <span class="number">2</span></span><br><span class="line">    dev1 = rank * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    mp_model = ToyMpModel(dev0, dev1)</span><br><span class="line">    ddp_mp_model = DDP(mp_model)</span><br><span class="line"></span><br><span class="line">    loss_fn = nn.MSELoss()</span><br><span class="line">    optimizer = optim.SGD(ddp_mp_model.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    <span class="comment"># outputs will be on dev1</span></span><br><span class="line">    outputs = ddp_mp_model(torch.randn(<span class="number">20</span>, <span class="number">10</span>))</span><br><span class="line">    labels = torch.randn(<span class="number">20</span>, <span class="number">5</span>).to(dev1)</span><br><span class="line">    loss_fn(outputs, labels).backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line">    cleanup()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    n_gpus = torch.cuda.device_count()</span><br><span class="line">    <span class="keyword">assert</span> n_gpus &gt;= <span class="number">2</span>, <span class="string">f&quot;Requires at least 2 GPUs to run, but got <span class="subst">&#123;n_gpus&#125;</span>&quot;</span></span><br><span class="line">    world_size = n_gpus</span><br><span class="line">    run_demo(demo_basic, world_size)</span><br><span class="line">    run_demo(demo_checkpoint, world_size)</span><br><span class="line">    world_size = n_gpus//<span class="number">2</span></span><br><span class="line">    run_demo(demo_model_parallel, world_size)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sampler = DistributedSampler(dataset) <span class="keyword">if</span> is_distributed <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">loader = DataLoader(dataset, shuffle=(sampler <span class="keyword">is</span> <span class="literal">None</span>),</span><br><span class="line">                    sampler=sampler)</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(start_epoch, n_epochs):</span><br><span class="line">     <span class="keyword">if</span> is_distributed:</span><br><span class="line">         sampler.set_epoch(epoch)</span><br><span class="line">     train(loader)</span><br></pre></td></tr></table></figure><p>它与 torch.nn.parallel.DistributedDataParallel 结合使用尤其有用.在这种情况下,<strong>每个进程都可以传递一个 DistributedSampler 实例作为 DataLoader 采样器</strong>,并加载其独有的原始数据集子集.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch  </span><br><span class="line"><span class="keyword">import</span> torch.distributed <span class="keyword">as</span> dist  </span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn  </span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim  </span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader, Dataset, DistributedSampler  </span><br><span class="line"><span class="keyword">from</span> torch.nn.parallel <span class="keyword">import</span> DistributedDataParallel <span class="keyword">as</span> DDP  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#### 自定义数据集和模型  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDataset</span>(<span class="params">Dataset</span>):</span>  </span><br><span class="line">    <span class="comment"># 实现__len__和__getitem__方法  </span></span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModel</span>(<span class="params">nn.Module</span>):</span>  </span><br><span class="line">    <span class="comment"># 定义模型结构,可能需要考虑如何拆分模型  </span></span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#### 初始化分布式环境  </span></span><br><span class="line">dist.init_process_group(backend=<span class="string">&#x27;nccl&#x27;</span>, init_method=<span class="string">&#x27;tcp://localhost:23456&#x27;</span>, rank=<span class="number">0</span>, world_size=torch.cuda.device_count())  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#### 初始化数据集和模型  </span></span><br><span class="line">dataset = MyDataset()  </span><br><span class="line">sampler = DistributedSampler(dataset)  </span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">32</span>, shuffle=<span class="literal">False</span>, sampler=sampler)  </span><br><span class="line">model = MyModel()  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#### 拆分模型（这通常需要根据模型的具体结构来手动完成）  </span></span><br><span class="line"><span class="comment">#### 例如,如果模型有两个主要部分,可以将它们分别放到不同的设备上  </span></span><br><span class="line">model_part1 = model.part1.to(<span class="string">&#x27;cuda:0&#x27;</span>)  </span><br><span class="line">model_part2 = model.part2.to(<span class="string">&#x27;cuda:1&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#### 使用DistributedDataParallel包装模型  </span></span><br><span class="line">model = DDP(model, device_ids=[torch.cuda.current_device()])  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#### 定义损失函数和优化器  </span></span><br><span class="line">criterion = nn.CrossEntropyLoss()  </span><br><span class="line">optimizer = optim.Adam(model.parameters(), lr=<span class="number">0.001</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#### 训练循环  </span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):  </span><br><span class="line">    <span class="keyword">for</span> inputs, labels <span class="keyword">in</span> dataloader:  </span><br><span class="line">        inputs, labels = inputs.to(model.device), labels.to(model.device)  </span><br><span class="line">        optimizer.zero_grad()  </span><br><span class="line">        outputs = model(inputs)  </span><br><span class="line">        loss = criterion(outputs, labels)  </span><br><span class="line">        loss.backward()  </span><br><span class="line">        optimizer.step()  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#### 销毁分布式进程组  </span></span><br><span class="line">dist.destroy_process_group()</span><br></pre></td></tr></table></figure><p><a href="https://github.com/jia-zhuang/pytorch-multi-gpu-training">jia-zhuang/pytorch-multi-gpu-training: 整理 pytorch 单机多 GPU 训练方法与原理 (github.com)</a></p><h2 id="常用Container"><a href="#常用Container" class="headerlink" title="常用Container"></a>常用Container</h2><div class="table-container"><table><thead><tr><th>Containers</th><th>介绍</th></tr></thead><tbody><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module"><code>Module</code></a></td><td>Base class for all neural network modules.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.Sequential.html#torch.nn.Sequential"><code>Sequential</code></a></td><td>A sequential container.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.ModuleList.html#torch.nn.ModuleList"><code>ModuleList</code></a></td><td>Holds submodules in a list.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.ModuleDict.html#torch.nn.ModuleDict"><code>ModuleDict</code></a></td><td>Holds submodules in a dictionary.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.ParameterList.html#torch.nn.ParameterList"><code>ParameterList</code></a></td><td>Holds parameters in a list.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.ParameterDict.html#torch.nn.ParameterDict"><code>ParameterDict</code></a></td><td>Holds parameters in a dictionary.</td></tr></tbody></table></div><p><code>Module</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">20</span>, <span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">20</span>, <span class="number">20</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = F.relu(self.conv1(x))</span><br><span class="line">        <span class="keyword">return</span> F.relu(self.conv2(x))</span><br></pre></td></tr></table></figure><p><code>Sequential</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">model = nn.Sequential(</span><br><span class="line">          nn.Conv2d(<span class="number">1</span>,<span class="number">20</span>,<span class="number">5</span>),</span><br><span class="line">          nn.ReLU(),</span><br><span class="line">          nn.Conv2d(<span class="number">20</span>,<span class="number">64</span>,<span class="number">5</span>),</span><br><span class="line">          nn.ReLU()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using Sequential with OrderedDict. This is functionally the</span></span><br><span class="line"><span class="comment"># same as the above code</span></span><br><span class="line">model = nn.Sequential(OrderedDict([</span><br><span class="line">          (<span class="string">&#x27;conv1&#x27;</span>, nn.Conv2d(<span class="number">1</span>,<span class="number">20</span>,<span class="number">5</span>)),</span><br><span class="line">          (<span class="string">&#x27;relu1&#x27;</span>, nn.ReLU()),</span><br><span class="line">          (<span class="string">&#x27;conv2&#x27;</span>, nn.Conv2d(<span class="number">20</span>,<span class="number">64</span>,<span class="number">5</span>)),</span><br><span class="line">          (<span class="string">&#x27;relu2&#x27;</span>, nn.ReLU())</span><br><span class="line">        ]))</span><br></pre></td></tr></table></figure><p><code>ModuleList</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModule</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.linears = nn.ModuleList([nn.Linear(<span class="number">10</span>, <span class="number">10</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># ModuleList can act as an iterable, or be indexed using ints</span></span><br><span class="line">        <span class="keyword">for</span> i, l <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.linears):</span><br><span class="line">            x = self.linears[i // <span class="number">2</span>](x) + l(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p><code>ModuleDict</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModule</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.choices = nn.ModuleDict(&#123;</span><br><span class="line">                <span class="string">&#x27;conv&#x27;</span>: nn.Conv2d(<span class="number">10</span>, <span class="number">10</span>, <span class="number">3</span>),</span><br><span class="line">                <span class="string">&#x27;pool&#x27;</span>: nn.MaxPool2d(<span class="number">3</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        self.activations = nn.ModuleDict([</span><br><span class="line">                [<span class="string">&#x27;lrelu&#x27;</span>, nn.LeakyReLU()],</span><br><span class="line">                [<span class="string">&#x27;prelu&#x27;</span>, nn.PReLU()]</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, choice, act</span>):</span></span><br><span class="line">        x = self.choices[choice](x)</span><br><span class="line">        x = self.activations[act](x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p><code>ParameterList</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModule</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.params = nn.ParameterList([nn.Parameter(torch.randn(<span class="number">10</span>, <span class="number">10</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># ParameterList can act as an iterable, or be indexed using ints</span></span><br><span class="line">        <span class="keyword">for</span> i, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.params):</span><br><span class="line">            x = self.params[i // <span class="number">2</span>].mm(x) + p.mm(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p><code>ParameterDict</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModule</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.params = nn.ParameterDict(&#123;</span><br><span class="line">                <span class="string">&#x27;left&#x27;</span>: nn.Parameter(torch.randn(<span class="number">5</span>, <span class="number">10</span>)),</span><br><span class="line">                <span class="string">&#x27;right&#x27;</span>: nn.Parameter(torch.randn(<span class="number">5</span>, <span class="number">10</span>))</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, choice</span>):</span></span><br><span class="line">        x = self.params[choice].mm(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2 id="容易混淆和遗忘的方法"><a href="#容易混淆和遗忘的方法" class="headerlink" title="容易混淆和遗忘的方法"></a>容易混淆和遗忘的方法</h2><h3 id="torch-Tensor-scatter"><a href="#torch-Tensor-scatter" class="headerlink" title="torch.Tensor.scatter_"></a>torch.Tensor.scatter_</h3><p>torch.scatter的in-place操作</p><p><code>Tensor.scatter_(dim, index, src, *, reduce=None) → [Tensor</code>]</p><p><strong>按照 <code>index</code> 张量中指定的索引,将张量 <code>src</code> 中的所有值写入 <code>self</code> 中</strong>.</p><p>对于 <code>src</code> 中的每个值,其输出索引在 <code>dimension != dim</code> 时由 <code>src</code> 中的索引指定,在 <code>dimension = dim</code> 时由 <code>index</code> 中的相应值指定.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self[index[i][j][k]][j][k] = src[i][j][k]  <span class="comment"># if dim == 0</span></span><br><span class="line">self[i][index[i][j][k]][k] = src[i][j][k]  <span class="comment"># if dim == 1</span></span><br><span class="line">self[i][j][index[i][j][k]] = src[i][j][k]  <span class="comment"># if dim == 2</span></span><br></pre></td></tr></table></figure><p>self、index 和 src（如果是张量）的<strong>维数应该相同</strong>.对于<strong>所有维度d,index.size(d) &lt;= src.size(d)</strong>；对于所有<strong>维度 d != dim,index.size(d) &lt;= self.size(d)</strong>,index 和 src 不会广播.</p><p>与gather逆操作,常用作写one-hot量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">index = torch.tensor([[<span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">value = <span class="number">2</span></span><br><span class="line">torch.zeros(<span class="number">3</span>, <span class="number">5</span>).scatter_(<span class="number">0</span>, index, value)</span><br><span class="line"></span><br><span class="line">src = torch.arange(<span class="number">1</span>, <span class="number">11</span>).reshape((<span class="number">2</span>, <span class="number">5</span>))</span><br><span class="line">src</span><br><span class="line">index = torch.tensor([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>]])</span><br><span class="line">torch.zeros(<span class="number">3</span>, <span class="number">5</span>, dtype=src.dtype).scatter_(<span class="number">0</span>, index, src)</span><br><span class="line">index = torch.tensor([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>]])</span><br><span class="line">torch.zeros(<span class="number">3</span>, <span class="number">5</span>, dtype=src.dtype).scatter_(<span class="number">1</span>, index, src)</span><br><span class="line"></span><br><span class="line">torch.full((<span class="number">2</span>, <span class="number">4</span>), <span class="number">2.</span>).scatter_(<span class="number">1</span>, torch.tensor([[<span class="number">2</span>], [<span class="number">3</span>]]),</span><br><span class="line">           <span class="number">1.23</span>, reduce=<span class="string">&#x27;multiply&#x27;</span>)</span><br><span class="line">torch.full((<span class="number">2</span>, <span class="number">4</span>), <span class="number">2.</span>).scatter_(<span class="number">1</span>, torch.tensor([[<span class="number">2</span>], [<span class="number">3</span>]]),</span><br><span class="line">           <span class="number">1.23</span>, reduce=<span class="string">&#x27;add&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="torch-gather"><a href="#torch-gather" class="headerlink" title="torch.gather"></a>torch.gather</h3><p><code>torch.gather(input, dim, index, *, sparse_grad=False, out=None) → [Tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor)</code></p><p>输入和索引的维数必须相同. <strong>在 d != dim的维度 中，index.size(d) &lt;= input.size(d)</strong>。输入和index不会相互广播</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">out[i][j][k] = <span class="built_in">input</span>[index[i][j][k]][j][k]  <span class="comment"># if dim == 0</span></span><br><span class="line">out[i][j][k] = <span class="built_in">input</span>[i][index[i][j][k]][k]  <span class="comment"># if dim == 1</span></span><br><span class="line">out[i][j][k] = <span class="built_in">input</span>[i][j][index[i][j][k]]  <span class="comment"># if dim == 2</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">torch.gather(t, <span class="number">1</span>, torch.tensor([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>]]))</span><br></pre></td></tr></table></figure><p>上面的代码就是把t根据index torch.tensor([[0, 0], [1, 0]])重新得到一个tensor.</p><blockquote><p>scatter是通过index将src的数据放在input中</p><p>gather是通过index将input的数据取出来</p></blockquote><h3 id="torch-split"><a href="#torch-split" class="headerlink" title="torch.split"></a>torch.split</h3><p><code>torch.split(tensor, split_size_or_sections, dim=0</code></p><p>将张量分割成块.每个块都是原始张量的一个view.</p><p>如果 split_size_or_sections 是整数类型,那么张量将被分割成大小相等的块（如果可能）.如果张量在给定维度 dim 上的大小不能被 split_size 整除,则最后一个块的大小会变小.</p><p>如果 split_size_or_sections 是一个列表,那么张量将被分割成 len(split_size_or_sections)小块,其大小与 split_size_or_sections 一致.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = torch.arange(<span class="number">10</span>).reshape(<span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">torch.split(a, <span class="number">2</span>)</span><br><span class="line">(tensor([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">         [<span class="number">2</span>, <span class="number">3</span>]]),</span><br><span class="line"> tensor([[<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">         [<span class="number">6</span>, <span class="number">7</span>]]),</span><br><span class="line"> tensor([[<span class="number">8</span>, <span class="number">9</span>]]))</span><br><span class="line">torch.split(a, [<span class="number">1</span>, <span class="number">4</span>])</span><br><span class="line">(tensor([[<span class="number">0</span>, <span class="number">1</span>]]),</span><br><span class="line"> tensor([[<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">         [<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">         [<span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">         [<span class="number">8</span>, <span class="number">9</span>]]))</span><br></pre></td></tr></table></figure><h3 id="torch-tensor-split"><a href="#torch-tensor-split" class="headerlink" title="torch.tensor_split"></a>torch.tensor_split</h3><p><code>torch.tensor_split(input, indices_or_sections, dim=0) → List of Tensors</code></p><p>根据 indices_or_sections 指定的索引或部分数,将张量沿维度 dim 分割成多个子张量,所有子张量都是输入的视图.</p><ul><li><p>如果 indices_or_sections 是一个整数 n 或一个数值为 n 的零维长张量，则输入会沿着维度 dim 被分割成 n 个部分。如果输入沿着维数 dim 被 n 整除，则每个部分的大小相等，即 input.size(dim) / n。如果输入不能被 n 整除，则第一个 int(input.size(dim) % n) 部分的大小为 int(input.size(dim) / n) + 1，其余部分的大小为 int(input.size(dim)/n)。</p></li><li><p>如果 indices_or_sections 是一个 ints 列表或元组，或者是一个一维长张量，那么输入将在列表、元组或张量中的每个索引处沿着维度 dim 分割。例如，如果 indices_or_sections=[2,3]，dim=0，则会产生张量 input[:2]、input[2:3] 和 input[3:]。</p></li><li><p>如果 indices_or_sections 是张量，在 CPU 上必须是零维或一维长张量。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(<span class="number">8</span>)</span><br><span class="line">torch.tensor_split(x, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">x = torch.arange(<span class="number">7</span>)</span><br><span class="line">torch.tensor_split(x, <span class="number">3</span>)</span><br><span class="line">torch.tensor_split(x, (<span class="number">1</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">x = torch.arange(<span class="number">14</span>).reshape(<span class="number">2</span>, <span class="number">7</span>)</span><br><span class="line">x</span><br><span class="line">torch.tensor_split(x, <span class="number">3</span>, dim=<span class="number">1</span>)</span><br><span class="line">torch.tensor_split(x, (<span class="number">1</span>, <span class="number">6</span>), dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>split如果输入是整数,按照dim分成多段,每段dim上的大小等于这个整数(如果能除尽)</p><p>如果输入是list,每段大小就对应list中的值(list的长度也跟dim对应的大小相同).返回tuple[Tensor,…]</p><p>tensor_split如果输入是整数,能除尽的话结果就跟split类似,否则前<code>int(input.size(dim) % n)</code> 段 大小<code>int(input.size(dim) / n) + 1</code>, 后面的大小 为<code>int(input.size(dim) / n)</code></p><p>如果是list,每一段数据是list中的两个indices,也就是</p><p>For instance, <code>indices_or_sections=[2, 3]</code> and <code>dim=0</code> would result in the tensors <code>input[:2]</code>, <code>input[2:3]</code>, and <code>input[3:]</code></p><p>两者默认dim都是0</p></blockquote><h3 id="torch-Tensor-repeat"><a href="#torch-Tensor-repeat" class="headerlink" title="torch.Tensor.repeat"></a>torch.Tensor.repeat</h3><p><code>Tensor.repeat(*sizes)</code></p><p>进行拷贝数据,沿指定维度重复此张量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">x.repeat(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">x.repeat(<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>).size()</span><br></pre></td></tr></table></figure><h3 id="torch-repeat-interleave"><a href="#torch-repeat-interleave" class="headerlink" title="torch.repeat_interleave"></a>torch.repeat_interleave</h3><p><code>torch.repeat_interleave(input, repeats, dim=None, *, output_size=None)</code></p><ul><li><strong>input</strong> (<a href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor"><em>Tensor</em></a>) – the input tensor.</li><li><strong>repeats</strong> (<a href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor"><em>Tensor</em></a> <em>or</em> <a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a>) – The number of repetitions for each element. repeats is broadcasted to fit the shape of the given axis.</li><li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a><em>,</em> <em>optional</em>) – The dimension along which to repeat values. <strong>By default, use the flattened input array, and return a flat output array</strong>.</li></ul><p><strong>output_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a><em>,</em> <em>optional</em>) – Total output size for the given axis ( e.g. sum of repeats). If given, it will avoid stream synchronization needed to calculate output shape of the tensor.</p><p>重复的方式是每个值后重复一次</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">x.repeat_interleave(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># tensor([1, 1, 2, 2, 3, 3])</span></span><br><span class="line">y = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">torch.repeat_interleave(y, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># tensor([1, 1, 2, 2, 3, 3, 4, 4])</span></span><br><span class="line">torch.repeat_interleave(y, <span class="number">3</span>, dim=<span class="number">1</span>)</span><br><span class="line">torch.repeat_interleave(y, torch.tensor([<span class="number">1</span>, <span class="number">2</span>]), dim=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># tensor([[1, 2],</span></span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">torch.repeat_interleave(y, torch.tensor([<span class="number">1</span>, <span class="number">2</span>]), dim=<span class="number">0</span>, output_size=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># tensor([[1, 2],</span></span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>]])</span><br></pre></td></tr></table></figure><h3 id="torch-Tensor-expand"><a href="#torch-Tensor-expand" class="headerlink" title="torch.Tensor.expand"></a>torch.Tensor.expand</h3><p><code>Tensor.expand(*sizes)</code></p><p>返回输入张量的新视图,并将单维度扩展到更大尺寸.</p><p>将 -1 作为维度的大小意味着不改变该维度的大小.</p><p>张量也可以扩展到更多维数,新的维数将被添加到前面。对于新维度,大小不能设置为-1.</p><p>扩展张量不会分配新的内存,只会在现有张量上创建一个新的视图,其中大小为 1 的维度会通过设置跨距为 0 来扩展为更大的维度.</p><blockquote><p>扩展张量的一个以上元素可能指向一个内存位置。 因此，in-place操作（尤其是矢量化操作）可能会导致不正确的行为。 如果需要写入张量，请先克隆它们。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([[<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">3</span>]])</span><br><span class="line">x.size() <span class="comment"># torch.Size([3, 1])</span></span><br><span class="line">x.expand(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">x.expand(-<span class="number">1</span>, <span class="number">4</span>)   <span class="comment"># -1 means not changing the size of that dimension</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([[<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">3</span>]])</span><br><span class="line"><span class="built_in">print</span>(x.expand(<span class="number">3</span>, <span class="number">4</span>).stride()) <span class="comment"># (1, 0)</span></span><br><span class="line"><span class="built_in">print</span>(x.expand(-<span class="number">1</span>, <span class="number">4</span>).stride()) <span class="comment"># (1, 0)</span></span><br></pre></td></tr></table></figure><h3 id="torch-Tensor-expand-as"><a href="#torch-Tensor-expand-as" class="headerlink" title="torch.Tensor.expand_as"></a>torch.Tensor.expand_as</h3><p><code>Tensor.expand_as(other)</code></p><p>将此张量展开为与其他张量相同的大小。self.expand_as(other) 相当于 self.expand(other.size())。</p><p>expand和repeat,前者返回view,后者返回数据.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(x.repeat(<span class="number">6</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(x.expand(<span class="number">6</span>, <span class="number">3</span>)) <span class="comment"># same</span></span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;Pytorch是很好的深度学习框架,但在使用时你可能仍然不清楚其中一些概念.这里我只以官方文档为依据尝试解释其中一些概念和方法. 我这里可以称作Effective Pytorch.&lt;br&gt;</summary>
    
    
    
    
    <category term="pytorch" scheme="https://www.sekyoro.top/tags/pytorch/"/>
    
  </entry>
  
  <entry>
    <title>A better C:from C++, Go,Rust to Zig</title>
    <link href="https://www.sekyoro.top/2024/06/23/A-better-C-from-C-Go-Rust-to-Zig/"/>
    <id>https://www.sekyoro.top/2024/06/23/A-better-C-from-C-Go-Rust-to-Zig/</id>
    <published>2024-06-23T03:28:16.000Z</published>
    <updated>2024-06-25T03:09:37.398Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>从C语言诞生已经五十多年了,现在已经有了许多高级语言,其中很多背靠大厂,比如Java,Go,C#,Dart,Swift等等(甲骨文,谷歌微软和苹果,这类语言通过公司更新).也有很多社区的语言,比如Python,Rust,PHP,Ruby等(这类语言往往通过早期创建者和一些核心成员更新和维护,这里面也有很多开源的语言,允许其他人修改).<br>相较于公司旗下的语言,社区类型的语言往往更加简洁,在使用或者生产下效率高,但也存在生态相对较差、工具链不够、更新发力不够持久、文档不够丰富的问题.</p><p>而 A better C的意思就是在后面的语言中找到性能较强,使用友好并且生态持续发展的语言.TLDR:在大型项目上还是使用C++,在一些工具链或者代码重构上可以考虑Rust. </p><span id="more"></span><blockquote><p>“世上其实只有两种编程语言，一种是大家一直喷它难用的，一种是根本没人用的。” —— C++ 的作者 Bjarne Stroustrup </p></blockquote><p>相对于Java,C#这种语言,我们尝试找到使用上更加轻型(指的是不依赖某种领域),性能更强占用更小的语言.</p><h2 id="Better-C"><a href="#Better-C" class="headerlink" title="Better C"></a>Better C</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>C++20目前已经有了很多Modern的特性,但是目前仍然缺乏的依然还是<code>build system,test harness, linter</code>,C++社区整体比较离散,也没有大公司拿出类似js的all in one的工具链,目前用得多的是vcpkg+cmake. 也有conan和xmake等等,但相对来说还是有欠缺,主要原因是C++没有所谓的官方,只有c++标准委员会,也不像其他公司常用的编程语言会有公司推出工具链.</p><p>但C++语言本身还是不错的,足够底层,足够值得学习.</p><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>Go背靠谷歌,生态目前感觉还是不够明朗,个人感觉可能是云原生基础设施上,如果你写过Go,就知道大型Web项目写Go还是有所欠缺,拿来写事务还是麻烦.</p><p>并且go的nil错误处理,module等依然遭受诟病.但是Go本身代码还是很容易读的,而且工具链也相对完善,有包管理工具,项目构建也可以使用cmake.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;html/template&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        p := Person&#123;</span><br><span class="line">            Name: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">            Age:  <span class="number">30</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        t, err := template.ParseFiles(<span class="string">&quot;templates/index.html&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        t.Execute(w, p)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Starting server on :8080&quot;</span>)</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(wrkID <span class="keyword">int</span>, jobs &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, results <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> job := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;worker %d started job %d\n&quot;</span>, wrkID, job)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;worker %d finished job %d\n&quot;</span>, wrkID, job)</span><br><span class="line">        results &lt;- job * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">    results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start workers</span></span><br><span class="line">    <span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= <span class="number">3</span>; w++ &#123;</span><br><span class="line">        <span class="keyword">go</span> worker(w, jobs, results)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send jobs</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++ &#123;</span><br><span class="line">        jobs &lt;- j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(jobs)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Collect results</span></span><br><span class="line">    <span class="keyword">for</span> a := <span class="number">1</span>; a &lt;= <span class="number">9</span>; a++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Result: %d\n&quot;</span>, &lt;-results)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h3><p>Rust,最近几年热度很高,但是也存在不少问题,上手门槛高,需要额外理解的概念不少.</p><p>Rust的一些优势包括以下几点：</p><ul><li>并发和并行：Rust内置对并行编程的支持，以及安全高效的多线程特性</li><li>性能：由于Rust代码不需要运行时，同时它不需要额外的垃圾回收器功耗，从而可以使用更少的资源并提高性能，</li><li>内存安全且无垃圾回收：由于所有权和借用等规则，Rust在没有垃圾回收器的情况下管理内存，从而实现更高效和可预测的性能</li><li>跨平台兼容性：Rust支持跨平台开发，意味着可以在多个系统上编译代码而不需要太多的修改代码</li><li>强大的生态系统：Rust拥有强大的工具和库生态系统。它的包管理器Cargo显著简化了依赖管理和与外部库集成的难度</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    age: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Person &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(name: &amp;<span class="built_in">str</span>, age: <span class="built_in">u32</span>) -&gt; Person &#123;</span><br><span class="line">        Person &#123;</span><br><span class="line">            name: <span class="built_in">String</span>::from(name),</span><br><span class="line">            age,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">greet</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hello, my name is &#123;&#125; and I&#x27;m &#123;&#125; years old.&quot;</span>, <span class="keyword">self</span>.name, <span class="keyword">self</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> alice = Person::new(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    alice.greet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Direction</span></span> &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">move_player</span></span>(direction: Direction) &#123;</span><br><span class="line">    <span class="keyword">match</span> direction &#123;</span><br><span class="line">        Direction::Up =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Moving up&quot;</span>),</span><br><span class="line">        Direction::Down =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Moving down&quot;</span>),</span><br><span class="line">        Direction::Left =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Moving left&quot;</span>),</span><br><span class="line">        Direction::Right =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Moving right&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    move_player(Direction::Up);</span><br><span class="line">    move_player(Direction::Left);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Zig"><a href="#Zig" class="headerlink" title="Zig"></a>Zig</h3><p>Zig官方是这么说的:Zig 是一种通用的编程语言和工具链，用于维护<strong>健壮</strong>、<strong>最优</strong>和<strong>可重用</strong>的软件.</p><p>既然有了C++和Rust,为什么又要搞这么多东西?<a href="https://ziglang.org/zh/learn/why_zig_rust_d_cpp/">有了 C++、D 和 Rust，为什么还需要 Zig？ ⚡ Zig Programming Language (ziglang.org)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line">const parseInt = std.fmt.parseInt;</span><br><span class="line"></span><br><span class="line">test &quot;parse integers&quot; &#123;</span><br><span class="line">    const input = &quot;123 67 89,99&quot;;</span><br><span class="line">    const ally = std.testing.allocator;</span><br><span class="line"></span><br><span class="line">    var list = std.ArrayList(u32).init(ally);</span><br><span class="line">    // Ensure the list is freed at scope exit.</span><br><span class="line">    // Try commenting out this line!</span><br><span class="line">    defer list.deinit();</span><br><span class="line"></span><br><span class="line">    var it = std.mem.tokenizeAny(u8, input, &quot; ,&quot;);</span><br><span class="line">    while (it.next()) |num| &#123;</span><br><span class="line">        const n = try parseInt(u32, num, 10);</span><br><span class="line">        try list.append(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const expected = [_]u32&#123; 123, 67, 89, 99 &#125;;</span><br><span class="line"></span><br><span class="line">    for (expected, list.items) |exp, actual| &#123;</span><br><span class="line">        try std.testing.expectEqual(exp, actual);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">pub fn main() !void &#123;</span><br><span class="line">    const x: i32 = 5;</span><br><span class="line">    const y: i32 = 10;</span><br><span class="line">    const sum = x + y;</span><br><span class="line">    std.log.info(&quot;The sum of &#123;&#125; and &#123;&#125; is &#123;&#125;&quot;, .&#123; x, y, sum &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">fn greet(name: []const u8) void &#123;</span><br><span class="line">    std.log.info(&quot;Hello, &#123;&#125;!&quot;, .&#123;name&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn main() !void &#123;</span><br><span class="line">    greet(&quot;Alice&quot;);</span><br><span class="line">    greet(&quot;Bob&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方文档阐述了非常多Zig的优势,看起来特别吸引人,但是目前使用的人还是不多.</p><p>Zig的一些<strong>劣势</strong>包括：</p><ul><li>有限的生态系统：因为它仍处于早期阶段，Zig语言的生态系统比成熟语言更小</li><li>成熟度和工具：Zig是一种新语言，还有改进的空间。但请注意，仍然有一个强大而活跃的社区支持它</li><li>文档可用性：Zig是一种相对较新的语言，因此文档有限，社区正在努力提高文档的可用性</li></ul><p>开发者可以在系统编程中使用Zig来构建操作系统、设备驱动程序和嵌入式系统。其还在<a href="https://cloud.tencent.com/product/cli?from_column=20065&amp;from=20065">命令行工具</a>中也有很多应用场景，可用于创建高效和快速的命令行界面，构建系统脚本，或优化现有工具的性能。</p><p>在编译器和语言开发中，Zig以其元编程能力和对简易性的追求而闻名。比较著名的开源项目是Bun，其是一个使用Zig开发的JavaScript运行时。</p><p>与Rust一样，Zig也有一些更为专业的使用场景：</p><ul><li>游戏开发，因支持高性能游戏引擎、能够实时模拟</li><li>在嵌入式系统和物联网中，用于编程微控制器、传感器和其他资源受限设备</li><li>在密码应用中，用于实现加密算法、数字签名、安全通信协议和其他安全敏感组</li></ul><p>小小的Benchmark<a href="https://zserge.com/posts/better-c-benchmark/">A “Better C” Benchmark (zserge.com)</a></p><p>我为什么会看上面这些语言的比较,主要原因还是:C++很好,但没有完善的工具链,它的标准委员会也不会管这些,而一些大厂也没有开源一些工具使用；</p><p>Go的生态位跟C/C++和Rust这类语言还不一样后者的一些东西不会拿Go来重构;Rust的上手门槛高,但目前看来是最可行的C/C++在系统编程、工具链重构甚至于一些业务处理上的可行工具.</p><p>而Zig还远远没有完善,但上手门槛相对更低,但应该还是需要沉淀,更何况c语言即使到今天也在更新,生态还是在的.</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>之前一段时间有个叫Mojo的编程语言不断在宣传自己的在AI领域编程的地位:比C和Python性能更好.<a href="https://www.modular.com/max/mojo">Mojo 🔥: Programming language for all of AI (modular.com)</a></p><p>目前还在吹水建设阶段,看后续表现(其实大众看的是有没有相关大厂进局).</p><p>我常常会关注一些本身比较老但使用并不少的编程语言,因为这类编程语言有自己的生态位,文档可能不算新,官方网站也往往看起来很老,生态上也没有很大的持续发力点,但是我还是会时不时看看,毕竟其中很多可能也会用上.</p><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><p>之前的文章我也提到过,php生态位就是web,也是为web而生.你甚至不需要特意使用某些web框架来创建应用,它本身就支持很多操作.但是php本身有些语法还需要适应(很多人说语法丑陋).而它的web框架也特别多,从相对轻量ThinkPHP、Symfony到重型的Laravel,都可以试试.Swoole框架也使得从Web到 TCP、UDP、Socket上</p><p>还有相比swoole更易学习的workerman,workerman 是纯php写的网络框架.支持TCP长连接，支持Websocket、HTTP等协议.以及基于workerman的webman,webman用于替代传统的php-fpm架构，提供超高性能可扩展的HTTP服务。你可以用webman开发网站，也可以开发HTTP接口或者微服务</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$numbers</span> = <span class="keyword">array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;The first number is: &quot;</span> . <span class="variable">$numbers</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;The length of the array is: &quot;</span> . count(<span class="variable">$numbers</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$person</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&quot;name&quot;</span> =&gt; <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span> =&gt; <span class="number">30</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Name: &quot;</span> . <span class="variable">$person</span>[<span class="string">&quot;name&quot;</span>] . <span class="string">&quot;, Age: &quot;</span> . <span class="variable">$person</span>[<span class="string">&quot;age&quot;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$age</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = <span class="variable">$age</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Hello, my name is &quot;</span> . <span class="keyword">$this</span>-&gt;name . <span class="string">&quot; and I&#x27;m &quot;</span> . <span class="keyword">$this</span>-&gt;age . <span class="string">&quot; years old.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$alice</span> = <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="variable">$alice</span>-&gt;greet(); <span class="comment">// 输出 &quot;Hello, my name is Alice and I&#x27;m 30 years old.&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params"><span class="variable">$a</span>, <span class="variable">$b</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$b</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> \<span class="built_in">Exception</span>(<span class="string">&quot;Division by zero&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$a</span> / <span class="variable">$b</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable">$result</span> = divide(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (\<span class="built_in">Exception</span> <span class="variable">$e</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Error: &quot;</span> . <span class="variable">$e</span>-&gt;getMessage();</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$greet</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="variable">$name</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Hello, <span class="subst">$name</span>!&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable">$greet</span>(<span class="string">&quot;Alice&quot;</span>); <span class="comment">// 输出 &quot;Hello, Alice!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$numbers</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable">$doubledNumbers</span> = array_map(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="variable">$x</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$x</span> * <span class="number">2</span>;</span><br><span class="line">&#125;, <span class="variable">$numbers</span>);</span><br><span class="line"></span><br><span class="line">print_r(<span class="variable">$doubledNumbers</span>); <span class="comment">// 输出 [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><p><strong>推荐学习</strong>:</p><ul><li><a href="https://docs.golaravel.com/">Laravel - 为 WEB 艺术家创造的 PHP 框架。 (golaravel.com)</a></li><li><a href="https://symfony.com/">Symfony, High Performance PHP Framework for Web Development</a></li><li><a href="https://www.workerman.net/">高性能PHP应用容器 workerman</a></li><li><a href="https://www.workerman.net/doc/webman/README.html">webman 手册 (workerman.net)</a></li></ul><h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3><p>也是web生态,或者说应为rails而知名.国内相对来说没那么多使用ruby的.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">puts <span class="string">&quot;The first number is: <span class="subst">#&#123;numbers[<span class="number">0</span>]&#125;</span>&quot;</span></span><br><span class="line">puts <span class="string">&quot;The length of the array is: <span class="subst">#&#123;numbers.length&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">person = &#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span> =&gt; <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span> =&gt; <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line">puts <span class="string">&quot;Name: <span class="subst">#&#123;person[<span class="string">&quot;name&quot;</span>]&#125;</span>, Age: <span class="subst">#&#123;person[<span class="string">&quot;age&quot;</span>]&#125;</span>&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:name</span>, <span class="symbol">:age</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(name, age)</span></span></span><br><span class="line">    <span class="variable">@name</span> = name</span><br><span class="line">    <span class="variable">@age</span> = age</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">greet</span></span></span><br><span class="line">    puts <span class="string">&quot;Hello, my name is <span class="subst">#&#123;<span class="variable">@name</span>&#125;</span> and I&#x27;m <span class="subst">#&#123;<span class="variable">@age</span>&#125;</span> years old.&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Person 对象并调用方法</span></span><br><span class="line">alice = Person.new(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span><br><span class="line">alice.greet <span class="comment"># 输出 &quot;Hello, my name is Alice and I&#x27;m 30 years old.&quot;</span></span><br></pre></td></tr></table></figure><p><strong>推荐学习</strong>:</p><ul><li><a href="https://rubyonrails.org/">Ruby on Rails — A web-app framework that includes everything needed to create database-backed web applications according to the Model-View-Controller (MVC) pattern.</a></li></ul><h3 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h3><p>lua生态位是写一些游戏脚本或者一些工具的功能,比如neovim中的一些插件就会使用lua.另外一些嵌入式设备也会使用,主要是与其他语言搭配.这门语言本身非常小,</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> x = <span class="number">5</span></span><br><span class="line"><span class="keyword">local</span> y = <span class="number">10</span></span><br><span class="line"><span class="keyword">local</span> sum = x + y</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The sum of &quot;</span> .. x .. <span class="string">&quot; and &quot;</span> .. y .. <span class="string">&quot; is &quot;</span> .. sum)</span><br><span class="line"><span class="keyword">local</span> fruits = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用for循环遍历</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>, #fruits <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(fruits[i])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用for-in循环遍历</span></span><br><span class="line"><span class="keyword">for</span> _, fruit <span class="keyword">in</span> <span class="built_in">ipairs</span>(fruits) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(fruit)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 定义一个Person类</span></span><br><span class="line"><span class="keyword">local</span> Person = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person:new</span><span class="params">(name, age)</span></span></span><br><span class="line">    <span class="keyword">local</span> obj = &#123;</span><br><span class="line">        name = name,</span><br><span class="line">        age = age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setmetatable</span>(obj, <span class="built_in">self</span>)</span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person:greet</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, my name is &quot;</span> .. <span class="built_in">self</span>.name .. <span class="string">&quot; and I&#x27;m &quot;</span> .. <span class="built_in">self</span>.age .. <span class="string">&quot; years old.&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建Person对象并调用方法</span></span><br><span class="line"><span class="keyword">local</span> alice = Person:new(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span><br><span class="line">alice:greet()</span><br><span class="line"><span class="comment">-- 定义一个协程函数</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">count</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,n <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(i)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建并控制协程</span></span><br><span class="line"><span class="keyword">local</span> co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(count)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">5</span>)) <span class="comment">-- 输出 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)) <span class="comment">-- 输出 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)) <span class="comment">-- 输出 3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)) <span class="comment">-- 输出 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)) <span class="comment">-- 输出 5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)) <span class="comment">-- 输出 nil</span></span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义一个Vector2D类</span></span><br><span class="line"><span class="keyword">local</span> Vector2D = &#123;&#125;</span><br><span class="line">Vector2D.<span class="built_in">__index</span> = Vector2D</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vector2D:new</span><span class="params">(x, y)</span></span></span><br><span class="line">    <span class="keyword">local</span> obj = <span class="built_in">setmetatable</span>(&#123;x=x, y=y&#125;, Vector2D)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vector2D:add</span><span class="params">(other)</span></span></span><br><span class="line">    <span class="keyword">return</span> Vector2D:new(<span class="built_in">self</span>.x + other.x, <span class="built_in">self</span>.y + other.y)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vector2D:__tostring</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> .. <span class="built_in">self</span>.x .. <span class="string">&quot;, &quot;</span> .. <span class="built_in">self</span>.y .. <span class="string">&quot;)&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建和操作Vector2D对象</span></span><br><span class="line"><span class="keyword">local</span> v1 = Vector2D:new(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">local</span> v2 = Vector2D:new(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">local</span> v3 = v1:add(v2)</span><br><span class="line"><span class="built_in">print</span>(v3) <span class="comment">-- 输出 (4, 6)</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://www.lua.org/">The Programming Language Lua</a></li></ul><h3 id="一些有趣的东西"><a href="#一些有趣的东西" class="headerlink" title="一些有趣的东西"></a>一些有趣的东西</h3><p>[<a href="https://www.codementor.io/blog/worst-languages-to-learn-3phycr98zk">Worst Programming Languages to Learn in 2018 (codementor.io)</a>这篇文章在2018年给出了在工作上不推荐碰的语言,其中包括Dart,Rust,Ruby,Go等,事实上从工作的角度来看,一些函数式编程语言和门槛较高的语言上榜很正常,但是另外有些更可能是因为生态还不够大,但本身是做应用的,比如Dart和Go,所以还需要官网.</p><p>这份榜单比较激进,但总体还是很有趣的.像函数时语言Clojure和Elixir就相比更老的Haskell和Erlang就更好.</p><p>在2019年<a href="https://www.codementor.io/blog/worst-languages-2019-6mvbfg3w9x">Study of Programming Languages Not to Learn in 2019 (codementor.io)</a></p><p>这份榜单变得更符合我的知觉了,当然这些东西只是看看而已,比如下面的人就说自己拿CoffeeScript写应用到AppStore上赚了很多钱,所以,还是要看生态位.</p><p><img data-src="https://s2.loli.net/2024/06/23/OM87TjbGsdWXl4E.png" alt="image-20240623122150477"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;从C语言诞生已经五十多年了,现在已经有了许多高级语言,其中很多背靠大厂,比如Java,Go,C#,Dart,Swift等等(甲骨文,谷歌微软和苹果,这类语言通过公司更新).也有很多社区的语言,比如Python,Rust,PHP,Ruby等(这类语言往往通过早期创建者和一些核心成员更新和维护,这里面也有很多开源的语言,允许其他人修改).&lt;br&gt;相较于公司旗下的语言,社区类型的语言往往更加简洁,在使用或者生产下效率高,但也存在生态相对较差、工具链不够、更新发力不够持久、文档不够丰富的问题.&lt;/p&gt;
&lt;p&gt;而 A better C的意思就是在后面的语言中找到性能较强,使用友好并且生态持续发展的语言.TLDR:在大型项目上还是使用C++,在一些工具链或者代码重构上可以考虑Rust. &lt;/p&gt;</summary>
    
    
    
    
    <category term="programming language" scheme="https://www.sekyoro.top/tags/programming-language/"/>
    
  </entry>
  
</feed>
